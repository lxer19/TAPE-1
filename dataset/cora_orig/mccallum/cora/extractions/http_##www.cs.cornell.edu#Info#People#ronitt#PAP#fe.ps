URL: http://www.cs.cornell.edu/Info/People/ronitt/PAP/fe.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/ronitt/papers.html
Root-URL: 
Title: On the robustness of functional equations  
Author: Ronitt Rubinfeld 
Note: 1+cot 1Ax cosh  
Abstract: In this paper, we study the general question of how characteristics of functional equations influence whether or not they are robust. We isolate examples of properties which are necessary for the functional equations to be robust. On the other hand, we show other properties which are sufficient for robustness. We then study a general class of functional equations, which are of the form 8x; y F [f (x y); f(x + y); f(x); f (y)] = 0, where F is an algebraic function. We give conditions on such functional equations that imply robustness. Our results have applications to the area of self-testing/correcting programs. We show that self-testers and self-correctors can be found for many functions satisfying robust functional equations, including algebraic functions of trigonometric functions such as tan x; 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abadi, M., Feigenbaum, J., Kilian, J., </author> <title> "On Hiding Information from an Oracle", </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 39, No. 1, </volume> <month> August </month> <year> 1989, </year> <pages> pp. 29-50. </pages>
Reference-contexts: This notion of random self-reduciblity is somewhat different than other definitions given by [20] <ref> [1] </ref> [30], where the requirement on G is that it be computable in polynomial time. 7 the self-testers and self-correctors shown for finite groups into self-testers and self-correctors that apply to functions over rational domains.
Reference: [2] <author> L. Adleman, M. Huang, and K. Kompella. </author> <title> Efficient checkers for number-theoretic computations. </title> <note> To appear in Information and Computation. </note>
Reference: [3] <author> J. Aczel. </author> <title> Lectures on Functional Equations and their Applications, </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference-contexts: The linearity property is one of the famous, well-studied functional equations referred to as Cauchy's equations, and has been studied over many other domains and ranges with various properties (see the text by Aczel <ref> [3] </ref>). Functional equations are used widely in the study of the various functions that arise in areas such as mathematics, physics and economics. Several general classes of functional equations have been identified. <p> This work is supported by ONR Young Investigator Award N00014- 93-1-0590 and United States - Israel Binational Science Foundation Grant 92-00226. equations, iteration equations, multivariate functional equations and systems of functional equations. In Section 2, we present the definition of functional equations given in <ref> [3] </ref>. For the purposes of this introduction, we define functional equations as follows: Let D; R be an arbitrary domain and range. <p> The general solution, F , is the family of functions that are solutions to the functional equation. Figures 1 and 2 give several examples of functional equations and their solution sets over the reals <ref> [3, 25] </ref>. In Section 2, we describe the formal definition of characterizations as given by Rubinfeld and Sudan in [38], which can be viewed as a generalization of functional equations. All functional equations involve a "for all" quantifier. <p> In Section 5.2 we show that this does not limit the ability to construct self-testers for programs for these functions, due to the equality testing performed by self-testers. 2.2 Functional Equations In the text by Aczel <ref> [3] </ref> (p.1), functional equations are defined by first defining a term: Definition 1 (term) ([3] p.1) 1. The independent variables x 1 ; : : : ; x k are terms. 2. <p> The known functions used in <ref> [3] </ref> include addition, subtraction, division, multiplication, exponentiation, trigonometric and hyperbolic functions. In this paper, we will also include all functions computable by a Turing machine. Later in [3] (p.3) it is also noted that the functional equation must be identically satisfied for certain values of the variables (x 1 ; : <p> The known functions used in <ref> [3] </ref> include addition, subtraction, division, multiplication, exponentiation, trigonometric and hyperbolic functions. In this paper, we will also include all functions computable by a Turing machine. Later in [3] (p.3) it is also noted that the functional equation must be identically satisfied for certain values of the variables (x 1 ; : : : ; x k ) figuring in them, called the domain (we use the term neighborhood set in this paper).
Reference: [4] <author> J. Aczel, and J. Dhombres. </author> <title> Functional Equations in Several Variables, </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference: [5] <author> S. Ar, M. Blum, B. Codenotti, P. </author> <title> Gemmell. Checking approximate computations over the reals. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 786-795, </pages> <year> 1993. </year>
Reference-contexts: Are there any other examples of functions where their mutual properties lead to more efficient testers? It is important to find methods to extend all robustness results to the case of real valued computation as in [31], <ref> [5] </ref> [27]. One point of difficulty is that in real valued computation, none of the functional equations will be satisfied exactly, even when the program is giving very good approximations to the correct answers. <p> Thus, the area of functional inequalities, which is the investigation of which families of functions satisfy inequalities such as jf (x + y) f (x) f (y)j *, directly applies to this setting. Much of the work in [31] <ref> [5] </ref> [27] has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. <p> Much of the work in [31] <ref> [5] </ref> [27] has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. Other related results used for testing matrix multiplication, linear system solution, matrix inversion and determinant computation are in [5]. <p> Several functional inequalities have been shown to be robust in [31], <ref> [5] </ref>, [27]. Other related results used for testing matrix multiplication, linear system solution, matrix inversion and determinant computation are in [5]. Acknowledgements We wish to thank Mike Luby for initial conversations that eventually led to the idea behind this work, and Nati Linial for directing us to the area of functional equations as well as to many of the references.
Reference: [6] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and the intractability of approximation problems. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works [19] [9] [29] [10] [7] <ref> [6] </ref>. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems. <p> The linearity test and tests for low total degree polynomial functions that are given in [19] [37] <ref> [6] </ref> have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] [29] [7]). <p> The linearity test and tests for low total degree polynomial functions that are given in [19] [37] <ref> [6] </ref> have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] [29] [7]). <p> Conversely, Sudan [41] has noted that the property of being a probabilistically checkable proof can actually be viewed as an example of a robust functional equation (where the definition of F is generalized to include all polynomial time circuits): In the work of Arora, Lund, Motwani, Sudan and Szegedy <ref> [6] </ref>, each probabilistically checkable proof P can be viewed as a truth table of a function. <p> In <ref> [6] </ref> it is shown that one can construct an (F; N ) that characterizes the set of valid proofs, i.e., valid proofs are exactly those bit strings P for which F [P (y); P ( 1 (y)); : : : ; P ( k (y)); y] = 0 is satisfied for
Reference: [7] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <booktitle> In Proceedings of the 33rd Annual IEEE Symposium of the Foundations of Computer Science, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works [19] [9] [29] [10] <ref> [7] </ref> [6]. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems. <p> linearity test and tests for low total degree polynomial functions that are given in [19] [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] [29] <ref> [7] </ref>). Much recent research has been devoted to expanding the range of the robustness parameter ffi for which these tests work, as it directly influences the strength of results showing that it is computationally difficult to approximate certain NP-complete problems [36][11] [12].
Reference: [8] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multioracle queries. </title> <booktitle> In Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer Verlag LNCS 415, </publisher> <pages> pages 37- 48, </pages> <year> 1990. </year>
Reference: [9] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works [19] <ref> [9] </ref> [29] [10] [7] [6]. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems. <p> The linearity test and tests for low total degree polynomial functions that are given in [19] [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in <ref> [9] </ref> [29] [7]). Much recent research has been devoted to expanding the range of the robustness parameter ffi for which these tests work, as it directly influences the strength of results showing that it is computationally difficult to approximate certain NP-complete problems [36][11] [12].
Reference: [10] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in poly-logarithmic time. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works [19] [9] [29] <ref> [10] </ref> [7] [6]. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems.
Reference: [11] <author> Bellare, M., Coppersmith, D., Hastad, J., Kiwi, M., Sudan, M., </author> <title> "Linearity testing in characteristic two", </title> <booktitle> Proc. 36nd Annual Symposium on Foundations of Computer Science,, </booktitle> <address> pp.434-441. </address>
Reference-contexts: Bellare, Coppersmith, Hastad, Kiwi and Sudan <ref> [11] </ref> show that one can get a tighter result on the range of ffi that is useful over domains of the type GF (2) n where Coppersmith's example does not apply. Robust characterizations of total degree d polynomials are given in [38] 1 . <p> (x); f (y)] is (2ffi; ffi)-robust for ffi &lt; 1=8 and G that satisfies G [a; G [b; c]] = G [G [a; b]; c] 8a; b; c (we do not attempt to optimize the relationship between * and ffi in our proofs of (*; ffi)-robustness see [13], [26] and <ref> [11] </ref> for techniques for improving this relationship).
Reference: [12] <author> Bellare, M., Goldreich, O., Sudan, M., </author> <title> "Free bits and non-approximability", </title> <booktitle> Proc. 36nd Annual Symposium on Foundations of Computer Science,. </booktitle> <pages> 29 </pages>
Reference-contexts: The linearity test and tests for low total degree polynomial functions that are given in [19] [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] <ref> [12] </ref> (tests that functions are low degree in each variable are given and used in [9] [29] [7]). <p> Much recent research has been devoted to expanding the range of the robustness parameter ffi for which these tests work, as it directly influences the strength of results showing that it is computationally difficult to approximate certain NP-complete problems [36][11] <ref> [12] </ref>. <p> Reducing this quantity, even by a constant factor, while not significantly affecting the range of ffi; * achievable for maintaining a robust characterization (and thus not significantly reducing the efficiency of the characterization), has been useful for constructing more efficient probabilistically checkable proofs [14] <ref> [12] </ref>. We begin by investigating two extreme types of functional equations: 12 1. A k-minimal neighborhood set is one in which N D is described by k 1 functions 1 (x); : : : ; k1 (x) where the i 's are arbitrary functions mapping D to D.
Reference: [13] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically check-able proofs. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year>
Reference-contexts: = G [f (x); f (y)] is (2ffi; ffi)-robust for ffi &lt; 1=8 and G that satisfies G [a; G [b; c]] = G [G [a; b]; c] 8a; b; c (we do not attempt to optimize the relationship between * and ffi in our proofs of (*; ffi)-robustness see <ref> [13] </ref>, [26] and [11] for techniques for improving this relationship).
Reference: [14] <author> Bellare, M., Sudan, M., </author> <title> "Improved non-approximability results", </title> <booktitle> Proc. of the ACM Symposium on the Theory of Computing, </booktitle> <pages> pp. 184-193, </pages> <year> 1994. </year>
Reference-contexts: The linearity test and tests for low total degree polynomial functions that are given in [19] [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] <ref> [14] </ref> [12] (tests that functions are low degree in each variable are given and used in [9] [29] [7]). <p> Reducing this quantity, even by a constant factor, while not significantly affecting the range of ffi; * achievable for maintaining a robust characterization (and thus not significantly reducing the efficiency of the characterization), has been useful for constructing more efficient probabilistically checkable proofs <ref> [14] </ref> [12]. We begin by investigating two extreme types of functional equations: 12 1. A k-minimal neighborhood set is one in which N D is described by k 1 functions 1 (x); : : : ; k1 (x) where the i 's are arbitrary functions mapping D to D.
Reference: [15] <author> M. Blum. </author> <title> Designing programs to check their work. </title> <type> Technical Report TR-88-009, </type> <institution> International Computer Science Institute, </institution> <year> 1988. </year>
Reference: [16] <author> M. Blum, B. Codenotti, P. Gemmell, T. Shahoumian. </author> <title> Self-correcting for function fields of finite transcendental degree. </title> <type> Manuscript. </type>
Reference-contexts: For example, one can find functional 6 equations satisfied by specific classes of finite degree rational functions of x; e x ; sin x using the results of [43] <ref> [16] </ref>. Second, show that these properties are robust, so that it is possible to efficiently test whether the program is computing a function that is close to some function in F . We call this task property testing. <p> On a related note, the use of polynomial checks (or the functional equations that are defined by the polynomial checks) for the correction of programs with few errors is suggested in [43], and Blum, Codenotti, Gemmell and Shahoumian <ref> [16] </ref> build on the work of [43] to give self-correctors for the same functions. <p> A similar result was obtained independently by Blum, Codenotti, Gemmell and Shahoumian <ref> [16] </ref> where self-correcting using functional equations is studied in much greater depth. Organization of paper In Section 2 we present the formal definitions of exact and robust characterizations from [38]. In Section 3 we investigate certain general properties of functional equations that influence whether they are robust. <p> The direct use of polynomial checks suggested in [43] also yields functional equations which are not robust due to Corollary 10, however, the work of <ref> [16] </ref> shows how to transform the polynomial checks into more general functional equations for which the negative results in this section do not apply. A robust minimal functional equation Previous examples of robust functional equations have always been usable for self-correction as well.
Reference: [17] <author> Blum, M., Evans, W., Gemmell, P., Kannan, S., Naor, M., </author> <title> "Checking the Correctness of Memories" Proc. </title> <booktitle> 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 90-99, </pages> <year> 1991. </year>
Reference-contexts: If F is also robust over random choices of x; z, then a more efficient tester can be constructed. We use a bound on the runtime of the program being tested to devise a tester. The works of Blum, Evans, Gemmell, Kannan and Naor <ref> [17] </ref> and Micali [35] also construct checkers based on bounds on the runtime of the program being checked, but use very different methods.
Reference: [18] <author> M. Blum and S. Kannan. </author> <title> Program correctness checking : : : and the design of programs that check their work. </title> <booktitle> In Proceedings of the 21st Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: In this case, the range must be a field containing 2. Robustness and self-testing/correcting. In order to allow a programmer to use programs that are not known to be correct on all inputs, result checkers were introduced by Blum and Kannan <ref> [18] </ref>, and soon after, the related paradigms of self-testers and self-correctors were introduced by Blum, Luby and Rubinfeld [19]. (A notion similar to self-correctors was independently proposed by Lipton [34].) The paradigm of self-testers and self-correctors is intended to fit into the framework of result checkers, and in fact it is <p> Thus, if F and G have the same complexity, the functional equation is not useful for self-testing, since it does not have the "little-oh property" described in <ref> [18] </ref>. However, it is possible that more efficient self-testers can be constructed by looking at a smaller, carefully chosen, set of neighborhoods N and showing that the functional equation is still robust over N . <p> Furthermore, all require only a small multiplicative 21 overhead over the running time of P and are different, simpler and faster than any correct program for f in a precise sense defined in <ref> [18] </ref>. Checkers can be constructed by finding both a self-tester and a self-corrector for the function [19].
Reference: [19] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> J. Comp. Sys. Sci. </journal> <volume> Vol. 47, No. 3, </volume> <month> December </month> <year> 1993. </year> <booktitle> Preliminary version appears in Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works <ref> [19] </ref> [9] [29] [10] [7] [6]. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems. <p> There are many characterizations that are known to be robust: The first nontrivial characterization shown to be robust for constant *; ffi was the linearity property over finite groups in the work of Blum, Luby and Rubinfeld <ref> [19] </ref>. <p> Robustness and self-testing/correcting. In order to allow a programmer to use programs that are not known to be correct on all inputs, result checkers were introduced by Blum and Kannan [18], and soon after, the related paradigms of self-testers and self-correctors were introduced by Blum, Luby and Rubinfeld <ref> [19] </ref>. (A notion similar to self-correctors was independently proposed by Lipton [34].) The paradigm of self-testers and self-correctors is intended to fit into the framework of result checkers, and in fact it is observed that a self-tester and a self-corrector for a function can be combined to give a checker [19]. <p> <ref> [19] </ref>. (A notion similar to self-correctors was independently proposed by Lipton [34].) The paradigm of self-testers and self-correctors is intended to fit into the framework of result checkers, and in fact it is observed that a self-tester and a self-corrector for a function can be combined to give a checker [19]. If a function has a checker, then one can determine whether program P is giving the correct answer on a particular input or whether there is a bug in the program. <p> On the contrary, it is easy to come up with examples of programs that pass the above tests but do not compute the correct function on a large fraction of inputs. Still, it has been shown that in many cases, using properties to test programs is mathematically justified (cf. <ref> [19] </ref> [37] [31] [38]). Essentially one can show that some of these tests can be used in conjunction with other simple tests in order to determine that a program is correct on most inputs. <p> This paper concentrates on the task of property testing. It is shown in <ref> [19] </ref> that self-correctors exist for any function that is random self-reducible, 3 since if the program is known to be correct on most inputs, then the correct value of the function at any particular input x can be inferred, even though the program may be incorrect on input x. <p> In particular, any function satisfying the linearity property is random self-reducible <ref> [19] </ref>. <p> input x via f (x) = G [f (y 1 ); : : : ; f (y k ); y 1 ; : : : ; y k ] where G can be computed asymptotically faster than f and the y i 's are uniformly distributed, though not necessarily independent <ref> [19] </ref>. This notion of random self-reduciblity is somewhat different than other definitions given by [20] [1] [30], where the requirement on G is that it be computable in polynomial time. 7 the self-testers and self-correctors shown for finite groups into self-testers and self-correctors that apply to functions over rational domains. <p> In most examples, G will be the set of all functions, however we will see examples in which it is useful to have G be a smaller, efficiently recognizable, set of functions. To continue with the example of linear functions, a theorem of <ref> [19] </ref> can be used to say that for any finite group G and any ffi &lt; 2 9 , (P G ; N G ) is a (2ffi; ffi)-robust characterization of the linear functions mapping G to G. <p> The linearity test and tests for low total degree polynomial functions that are given in <ref> [19] </ref> [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] [29] [7]). <p> We now show that any addition theorem satisfying 8a; b; c G [a; G [b; c]] = G [G [a; b]; c] is robust. This proof follows an outline similar to Coppersmith's version of the proof of robustness of the linearity test which is described in <ref> [19] </ref>. However, the inner manipulations are different. Hence, whereas Coppersmith's proof works for any ffi 2=9, here we require ffi 1=8. Theorem 13 Let D = D 0 be a finite group and R = T a group. <p> Since the statement is independent of z and holds with positive probability, it must hold with probability 1. 2 2 5 Self-testing/correcting from functional equations We give informal definitions of self-testers and self-correctors. Formal definitions are given in <ref> [19] </ref>. <p> Furthermore, all require only a small multiplicative 21 overhead over the running time of P and are different, simpler and faster than any correct program for f in a precise sense defined in [18]. Checkers can be constructed by finding both a self-tester and a self-corrector for the function <ref> [19] </ref>. In this section, we give self-correctors and self-testers that are based on the class of functional equations of the form F [f (x y); f (x + y); f (x); f (y)] = 0. <p> If P is 1=12-close to f over D, then 8x; P r [Self-Correct (x; fi) = f (x)] 1 fi. The proof of this theorem follows the format in <ref> [19] </ref> and is based on the fact that since calls to P are made on uniformly distributed inputs in D, at each iteration, all calls are answered correctly by P with probability at least 3=4. <p> For example, Pexider's equations are f (x+y) = g (x)+h (y); f (x+y) = g (x)h (y); f (xy) = g (x) + h (y), and f (xy) = g (x)h (y). which are generalizations of Cauchy's original functional equations. These equations have applications to the library setting <ref> [19] </ref>, where programs for several functions can be used to self-test and self-correct each other, as long as none of the answers are a priori assumed to be correct. The library setting has been used to find checkers that are significantly more efficient for functions such as determinant and rank.
Reference: [20] <author> Blum, M., and Micali, S., </author> <title> "How to Generate Cryptographically Strong Sequences of Pseudo-Random Bits", </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 13, </volume> <year> 1984, </year> <pages> pp. 850-864, </pages> <note> extended abstract in FOCS 1982. </note>
Reference-contexts: This notion of random self-reduciblity is somewhat different than other definitions given by <ref> [20] </ref> [1] [30], where the requirement on G is that it be computable in polynomial time. 7 the self-testers and self-correctors shown for finite groups into self-testers and self-correctors that apply to functions over rational domains.
Reference: [21] <author> M. Blum and H. Wasserman. </author> <title> Program result-checking: A theory of testing meets a test of theory. </title> <booktitle> In Proc. 35th FOCS, </booktitle> <pages> pp. 382-392, </pages> <year> 1994. </year>
Reference-contexts: Problems that can be viewed as linear or low degree polynomial functions, such as matrix multiplication, integer division, sine/cosine, integer multiplication, the mod function, modular multiplication, polynomial multiplication, modular exponentiation, Fast Fourier Transform and determinant, have been shown to have self-testers and self-correctors [19][8][34][23] [31][37][38][2] [28] <ref> [21] </ref>. Although many functions can be viewed as linear functions or low degree polynomials over an appropriate group structure, one concern was that these might be the only examples of functions that have self-testers and self-correctors.
Reference: [22] <author> E. Castillo, </author> <title> M.R. Ruiz-Cobo. Functional Equations and Modelling in Science and Engineering, </title> <publisher> Marcel Dekker, Inc., </publisher> <year> 1992. </year>
Reference: [23] <author> R. Cleve, M. Luby. </author> <title> A Note on Self-Testing/Correcting Methods for Trigonometric Functions, </title> <institution> International Computer Science Institute Technical Report TR-90-032, </institution> <month> July, </month> <year> 1990. </year>
Reference: [24] <author> Cody, W.J., </author> <title> "Performance evaluation of programs related to the real gamma function", </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1991, </year> <pages> pp. 46-54. </pages>
Reference-contexts: These functional equations can be used to test functions that are algebraic functions of trigonometric functions. The work of Cody <ref> [24] </ref> suggests the following test for programs computing the real gamma function over the reals: Pick random x and verify that P (2x) = (2) 1=2 2 2x1=2 P (x)P (x + 1=2). <p> As we will see later on, this result implies that certain methods of testing programs used in practice are related to this class and are therefore provably faulty. For example, our techniques apply to the functional equation that is used to test the real gamma function <ref> [24] </ref> (page 6). On the other hand, we mention an example, given by Sudan [41], of a minimal equation that is robust. We then show conditions under which k-total equations are always robust. In the following, we assume that D = D 0 . 3.1 Minimal functional equations. <p> This corollary shows that many tests that are used in practice to test programs should be used with more care. For example, in the functional equation 8x; f (2x) (2) 1=2 2 2x1=2 f (x)f (x + 1=2) = 0 used for testing the real gamma function by <ref> [24] </ref>, all of the i 's are linear functions ( 1 (x) = 2x; 2 (x) = x + 1=2). Thus the corollary implies that there exist programs which are very 14 different from any solution to this functional equation, yet pass the test most of the time.
Reference: [25] <author> Cody, W.J., Stoltz, L., </author> <title> "The use of Taylor series to test accuracy of function programs", </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1991, </year> <pages> pp. 55-63. </pages>
Reference-contexts: The general solution, F , is the family of functions that are solutions to the functional equation. Figures 1 and 2 give several examples of functional equations and their solution sets over the reals <ref> [3, 25] </ref>. In Section 2, we describe the formal definition of characterizations as given by Rubinfeld and Sudan in [38], which can be viewed as a generalization of functional equations. All functional equations involve a "for all" quantifier. <p> For example, matrix multiplication routines have been tested by verifying that the outputs satisfy the distributive property [39]. The work of Cody and Stolz <ref> [25] </ref> proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein [42, 43, 44, 45], suggests the use of polynomial checks for testing and correcting programs.
Reference: [26] <author> D. Coppersmith. </author> <type> Manuscript, </type> <month> December </month> <year> 1989. </year> <note> Result described in [19]. 30 </note>
Reference-contexts: The linearity property is known to be (2ffi; ffi)-robust when the domain and range are any finite group for any ffi &lt; 2=9 <ref> [26] </ref>. We are interested in the case when for all * &lt; 1, there is a constant ffi such that (F; N ) is (*; ffi)-robust over each of the domains in S. <p> There are many characterizations that are known to be robust: The first nontrivial characterization shown to be robust for constant *; ffi was the linearity property over finite groups in the work of Blum, Luby and Rubinfeld [19]. Coppersmith <ref> [26] </ref> gives a particularly elegant proof of the robustness of the linearity property as well as improves the allowable 2 Equation Solution f (x + y) = f (x)+f (y) f (x + y) = f (x)f (y)1 f (x + y) = f (x)+f (y) 1+[f (x)f (y)=a 2 ] <p> G [f (x); f (y)] is (2ffi; ffi)-robust for ffi &lt; 1=8 and G that satisfies G [a; G [b; c]] = G [G [a; b]; c] 8a; b; c (we do not attempt to optimize the relationship between * and ffi in our proofs of (*; ffi)-robustness see [13], <ref> [26] </ref> and [11] for techniques for improving this relationship).
Reference: [27] <author> F. Ergun, S R. Kumar, R. Rubinfeld. </author> <title> Approximate Checking of Polynomials and Functional Equations. </title> <booktitle> Proceedings of the 37nd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Are there any other examples of functions where their mutual properties lead to more efficient testers? It is important to find methods to extend all robustness results to the case of real valued computation as in [31], [5] <ref> [27] </ref>. One point of difficulty is that in real valued computation, none of the functional equations will be satisfied exactly, even when the program is giving very good approximations to the correct answers. <p> Thus, the area of functional inequalities, which is the investigation of which families of functions satisfy inequalities such as jf (x + y) f (x) f (y)j *, directly applies to this setting. Much of the work in [31] [5] <ref> [27] </ref> has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. <p> Much of the work in [31] [5] <ref> [27] </ref> has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. Other related results used for testing matrix multiplication, linear system solution, matrix inversion and determinant computation are in [5].
Reference: [28] <author> Funda Ergun, S Ravi Kumar, and D Sivakumar, </author> <title> "Self-testing without the generator bottleneck." </title> <note> Submitted to SIAM Journal on Computing. </note>
Reference-contexts: Problems that can be viewed as linear or low degree polynomial functions, such as matrix multiplication, integer division, sine/cosine, integer multiplication, the mod function, modular multiplication, polynomial multiplication, modular exponentiation, Fast Fourier Transform and determinant, have been shown to have self-testers and self-correctors [19][8][34][23] [31][37][38][2] <ref> [28] </ref> [21]. Although many functions can be viewed as linear functions or low degree polynomials over an appropriate group structure, one concern was that these might be the only examples of functions that have self-testers and self-correctors.
Reference: [29] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: In this case, we say that (F; N ) is robust over S (note that robustness is only interesting if 1=ffi is much smaller than jN j). Previous results on robust characterizations Robustness and related notions are used implicitly in a number of works [19] [9] <ref> [29] </ref> [10] [7] [6]. In the following sections, we describe the applications of robustness to program testing and to the study of probabilistically checkable proof systems. <p> exists a proof P of membership in the language such that V accepts P with probability 1 (where the probability is over the random strings R) and (2) if x is not in L, for all proofs P 0 , V accepts proof P 0 with probability at most 1=4 <ref> [29] </ref>. <p> The linearity test and tests for low total degree polynomial functions that are given in [19] [37] [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] <ref> [29] </ref> [7]). Much recent research has been devoted to expanding the range of the robustness parameter ffi for which these tests work, as it directly influences the strength of results showing that it is computationally difficult to approximate certain NP-complete problems [36][11] [12].
Reference: [30] <author> J. Feigenbaum, L. Fortnow. </author> <title> On the Random-Self-Reducibility of Complete Sets. </title> <journal> SIAM J. Computing, </journal> <year> 1993. </year>
Reference-contexts: This notion of random self-reduciblity is somewhat different than other definitions given by [20] [1] <ref> [30] </ref>, where the requirement on G is that it be computable in polynomial time. 7 the self-testers and self-correctors shown for finite groups into self-testers and self-correctors that apply to functions over rational domains.
Reference: [31] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: Still, it has been shown that in many cases, using properties to test programs is mathematically justified (cf. [19] [37] <ref> [31] </ref> [38]). Essentially one can show that some of these tests can be used in conjunction with other simple tests in order to determine that a program is correct on most inputs. <p> Self-correctors for functions that are not solvable for f (x), but are solvable for another of f (x y); f (x + y); f (y) can be similarly constructed. As in <ref> [31] </ref>, we assume that the program has been tested over a larger domain D m;s , in order to self-correct over the domain D n;s (this requires the more general definitions of self-correcting given in [31]). It suffices that m &gt; 12n. <p> As in <ref> [31] </ref>, we assume that the program has been tested over a larger domain D m;s , in order to self-correct over the domain D n;s (this requires the more general definitions of self-correcting given in [31]). It suffices that m &gt; 12n. <p> If P is (1=24)-close to f over D m;s , then 8x 2 D n;s ; P r [Self-Correct (x; fi) = f (x)] 1 fi. The proof of this theorem follows the format in <ref> [31] </ref>. Proof: [of Theorem 26] By the assumption on P , P (y) is correct with probability at least 1 1 24 . <p> Are there any other examples of functions where their mutual properties lead to more efficient testers? It is important to find methods to extend all robustness results to the case of real valued computation as in <ref> [31] </ref>, [5] [27]. One point of difficulty is that in real valued computation, none of the functional equations will be satisfied exactly, even when the program is giving very good approximations to the correct answers. <p> Thus, the area of functional inequalities, which is the investigation of which families of functions satisfy inequalities such as jf (x + y) f (x) f (y)j *, directly applies to this setting. Much of the work in <ref> [31] </ref> [5] [27] has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. <p> Much of the work in <ref> [31] </ref> [5] [27] has been in relating the class of functions that are solutions to functional inequalities to the class of functions that are solutions of the corresponding functional equations. Several functional inequalities have been shown to be robust in [31], [5], [27]. Other related results used for testing matrix multiplication, linear system solution, matrix inversion and determinant computation are in [5].
Reference: [32] <author> M. Klawe. </author> <title> Limitations on Explicit Constructions of Expanding Graphs. </title> <journal> in SIAM J. Computing, </journal> <volume> Vol. 13, No. 1, </volume> <pages> pp. 156-166, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: It was shown by Klawe <ref> [32] </ref> that for any given *, any graph on n nodes whose edges are defined by a constant number of linear functions has a cut containing o (n) edges which separates the graph into two large portions, each containing an * fraction of the nodes.
Reference: [33] <author> S Ravi Kumar and D Sivakumar, </author> <title> "Efficient self-testing/self-correction of linear recurrences," </title> <booktitle> Proc. 37th IEEE Foundations of Computer Science, </booktitle> <pages> pages 602-611, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: These results apply to polynomials over finite fields Z p (p prime), and finite subsets of rational domains. The first formal definition of robustness was given in [38]. Very recently, robust characterizations of functions satisfying linear recurrence relations have been given by Kumar and Sivakumar <ref> [33] </ref>. Our Results Our goal is to characterize the fundamental characteristics of functional equations that make them robust, in order to gain an understanding of how broadly robustness applies. It happens that the structure of the neighborhoods in N is very important to whether a characterization is robust.
Reference: [34] <author> R. Lipton. </author> <title> New directions in testing. </title> <journal> Distributed Computing and Cryptography, DI-MACS Series in Discrete Math and Theoretical Computer Science, American Mathematical Society, </journal> <volume> 2 </volume> <pages> 191-202, </pages> <year> 1991. </year>
Reference-contexts: to use programs that are not known to be correct on all inputs, result checkers were introduced by Blum and Kannan [18], and soon after, the related paradigms of self-testers and self-correctors were introduced by Blum, Luby and Rubinfeld [19]. (A notion similar to self-correctors was independently proposed by Lipton <ref> [34] </ref>.) The paradigm of self-testers and self-correctors is intended to fit into the framework of result checkers, and in fact it is observed that a self-tester and a self-corrector for a function can be combined to give a checker [19].
Reference: [35] <author> Micali, S. </author> <title> Computationally-Sound Proofs. </title> <booktitle> Proc. 35nd Annual Symposium on Foundations of Computer Science. </booktitle>
Reference-contexts: If F is also robust over random choices of x; z, then a more efficient tester can be constructed. We use a bound on the runtime of the program being tested to devise a tester. The works of Blum, Evans, Gemmell, Kannan and Naor [17] and Micali <ref> [35] </ref> also construct checkers based on bounds on the runtime of the program being checked, but use very different methods.
Reference: [36] <author> Polischuk, A., Spielman, D., </author> <title> "Nearly linear size holographic proofs", </title> <booktitle> Proc. 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 194-203, </pages> <year> 1994. </year>
Reference: [37] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proceedings of the 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 23-43, </pages> <year> 1992. </year>
Reference-contexts: Still, it has been shown that in many cases, using properties to test programs is mathematically justified (cf. [19] <ref> [37] </ref> [31] [38]). Essentially one can show that some of these tests can be used in conjunction with other simple tests in order to determine that a program is correct on most inputs. <p> The linearity test and tests for low total degree polynomial functions that are given in [19] <ref> [37] </ref> [6] have been used to construct probabilistically checkable proof systems in the recent results of [6] [14] [12] (tests that functions are low degree in each variable are given and used in [9] [29] [7]).
Reference: [38] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust Characterizations of Polynomials and their Applications to Program Testing. </title> <journal> SIAM J. of Computing, </journal> <volume> 25(2) </volume> <pages> 252-271, </pages> <year> 1996. </year>
Reference-contexts: Figures 1 and 2 give several examples of functional equations and their solution sets over the reals [3, 25]. In Section 2, we describe the formal definition of characterizations as given by Rubinfeld and Sudan in <ref> [38] </ref>, which can be viewed as a generalization of functional equations. All functional equations involve a "for all" quantifier. Here we are interested in comparing the solution to the functional equation when the "for all" quantifier is replaced by a "for most" quantifier. <p> A formal and more general definition due to <ref> [38] </ref> is given in Section 2. Often it is the case that N and F are defined and are known to be (*; ffi)-robust over an infinite set S of domains and corresponding neighborhood sets. <p> Bellare, Coppersmith, Hastad, Kiwi and Sudan [11] show that one can get a tighter result on the range of ffi that is useful over domains of the type GF (2) n where Coppersmith's example does not apply. Robust characterizations of total degree d polynomials are given in <ref> [38] </ref> 1 . Robust characterizations of maximum degree d polynomials are given in several works [9][29][10][38] 2 . These results apply to polynomials over finite fields Z p (p prime), and finite subsets of rational domains. The first formal definition of robustness was given in [38]. <p> d polynomials are given in <ref> [38] </ref> 1 . Robust characterizations of maximum degree d polynomials are given in several works [9][29][10][38] 2 . These results apply to polynomials over finite fields Z p (p prime), and finite subsets of rational domains. The first formal definition of robustness was given in [38]. Very recently, robust characterizations of functions satisfying linear recurrence relations have been given by Kumar and Sivakumar [33]. Our Results Our goal is to characterize the fundamental characteristics of functional equations that make them robust, in order to gain an understanding of how broadly robustness applies. <p> Still, it has been shown that in many cases, using properties to test programs is mathematically justified (cf. [19] [37] [31] <ref> [38] </ref>). Essentially one can show that some of these tests can be used in conjunction with other simple tests in order to determine that a program is correct on most inputs. <p> A similar result was obtained independently by Blum, Codenotti, Gemmell and Shahoumian [16] where self-correcting using functional equations is studied in much greater depth. Organization of paper In Section 2 we present the formal definitions of exact and robust characterizations from <ref> [38] </ref>. In Section 3 we investigate certain general properties of functional equations that influence whether they are robust. <p> properties (measurability, differentiability, continuity, boundedness), other properties such as computability by a polynomial time Turing machine, ...), by initial and boundary conditions and/or by conditions given in the form of another functional equation. 2.3 Exact and Robust Characterizations We now present the definitions of characterizations and robust characterizations given by <ref> [38] </ref>. D is used to represent a finite domain. We consider families of functions F where f 2 F maps elements from domain D to range R (we use R to denote the range of a function and &lt; to denote the set of real numbers). <p> T is a range containing 0. We illustrate these definitions using the example of linear functions. Here D = R = T = Z p and the family of linear functions is ff a ja 2 Z p where f a (x) = a xg. Definition 3 (Neighborhoods) <ref> [38] </ref> N D is a k-local neighborhood if it is an ordered tuple of (not necessarily distinct) k points (x 1 ; : : : ; x k ) from D k . A k-local collection of neighborhoods N D is a (multi)set of k-local neighborhoods. <p> A k-local collection of neighborhoods N D is a (multi)set of k-local neighborhoods. When D is understood from the context, we drop it from the subscript. Definition 4 (Properties) <ref> [38] </ref> P D;R;T is a k-local property if it is a function from R k fiD k to T . <p> Definition 5 (Exact Characterizations) <ref> [38] </ref> We say that (P D;R;T ; N D ) is an exact characterization of a family F of functions if a function f : D ! R satisfies P D;R;T over all neighborhoods N D 2 N D exactly when f 2 F . <p> The characterization is k-local if the property P D;R;T and the collection N D is k-local. When D; R; T are understood from the context, we drop them as subscripts. 4 This is a slight modification of the definition in <ref> [38] </ref>, where the function f satisfies P D;R;T if P D;R;T (f (x 1 ); : : : ; f (x k ); x 1 ; : : : ; x k ) = 1 and the range of the function P D;R;T is f0; 1g instead of T . 9 <p> Definition 6 (Robust Characterizations) <ref> [38] </ref> Let D 0 D. Let P D;R;T be a property over a collection of neighborhoods N D ; let F be such that (P D;R;T ; N D ) is an exact characterization of F . <p> However, the choice of neighborhoods heavily influences the robustness of the characterizations. A simple counting argument (similar to the one described later in Section 3.2) shows that the first property is (ffi; ffi)-robust for all ffi &lt; 1. The second property is (2ffi; ffi)-robust for ffi &lt; 1=1082 <ref> [38] </ref>. It is easy to see that for all *, the third property is not (*; ffi)-robust over S for any constant ffi. Thus the richness of the neighborhood set influences the robustness as well as the complexity of computing P D;R;T . <p> to the structure of the 's, it might be the case that F is easier to compute on those tuples defined by the 's (for example, efficient polynomial degree tests have been constructed by only performing tests on points that are evenly spaced: i (x; z) = x + iz <ref> [38] </ref>). If F is also robust over random choices of x; z, then a more efficient tester can be constructed. We use a bound on the runtime of the program being tested to devise a tester. <p> Though equality testing is often easier than the original testing task, it may still be inefficient, as in the case of multivariate polynomials <ref> [38] </ref>. For the functions considered in this paper, the problem of equality testing can be solved efficiently. We assume that the function values are given at a constant number of inputs, such that these values in conjuction with the property F are enough to completely specify the function.
Reference: [39] <author> Schriver, N., </author> <type> Personal communication. </type> <month> February </month> <year> 1990. </year>
Reference-contexts: The idea of testing programs by verifying that programs satisfy properties known to be satisfied by the functions being computed is not new to the self-testing/correcting approach. For example, matrix multiplication routines have been tested by verifying that the outputs satisfy the distributive property <ref> [39] </ref>. The work of Cody and Stolz [25] proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein [42, 43, 44, 45], suggests the use of polynomial checks for testing and correcting programs.
Reference: [40] <author> M. Sudan. </author> <title> Efficient checking of polynomials and proofs and the hardness of approximation problems. </title> <type> PhD Thesis. </type> <institution> U.C. Berkeley, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The following theorem, which says that k-total functional equations that characterize k 1-complete function families are necessarily robust, can be viewed as a generalization of a known theorem for degree (k 1) univariate polynomials (cf. <ref> [40] </ref>). Theorem 11 Let N = D k .
Reference: [41] <author> M. Sudan. </author> <title> Personal communications, </title> <booktitle> Summer 1994. </booktitle> <pages> 31 </pages>
Reference-contexts: Much recent research has been devoted to expanding the range of the robustness parameter ffi for which these tests work, as it directly influences the strength of results showing that it is computationally difficult to approximate certain NP-complete problems [36][11] [12]. Conversely, Sudan <ref> [41] </ref> has noted that the property of being a probabilistically checkable proof can actually be viewed as an example of a robust functional equation (where the definition of F is generalized to include all polynomial time circuits): In the work of Arora, Lund, Motwani, Sudan and Szegedy [6], each probabilistically checkable <p> For example, our techniques apply to the functional equation that is used to test the real gamma function [24] (page 6). On the other hand, we mention an example, given by Sudan <ref> [41] </ref>, of a minimal equation that is robust. We then show conditions under which k-total equations are always robust. In the following, we assume that D = D 0 . 3.1 Minimal functional equations. <p> Even so, there are minimal functional equations that are robust and can therefore be used to self-test. We describe an example of a minimal functional equation that is robust. This example was given by Sudan <ref> [41] </ref>: We say that a graph G (V; E) is an ff-expander if for all S V; jSj jV j=2, the set of nodes that are neighbors of S (not including nodes in S), is of size ffjSj. Fix constants d and ff.
Reference: [42] <author> F. Vainstein, </author> <title> Error Detection and Correction in Numerical Computations by Algebraic Methods, </title> <booktitle> Proceedings 9th International Symposium, </booktitle> <address> AAECC-9, New Orleans, LA, 1991, </address> <publisher> LNCS 539, Springer Verlag. </publisher>
Reference-contexts: The work of Cody and Stolz [25] proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein <ref> [42, 43, 44, 45] </ref>, suggests the use of polynomial checks for testing and correcting programs.
Reference: [43] <author> F. Vainstein, </author> <title> Algebraic Methods in Hardware/Software Testing. </title> <type> PhD Thesis, </type> <institution> Boston University, </institution> <year> 1993. </year>
Reference-contexts: The work of Cody and Stolz [25] proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein <ref> [42, 43, 44, 45] </ref>, suggests the use of polynomial checks for testing and correcting programs. <p> For example, one can find functional 6 equations satisfied by specific classes of finite degree rational functions of x; e x ; sin x using the results of <ref> [43] </ref> [16]. Second, show that these properties are robust, so that it is possible to efficiently test whether the program is computing a function that is close to some function in F . We call this task property testing. <p> In particular, any function satisfying the linearity property is random self-reducible [19]. On a related note, the use of polynomial checks (or the functional equations that are defined by the polynomial checks) for the correction of programs with few errors is suggested in <ref> [43] </ref>, and Blum, Codenotti, Gemmell and Shahoumian [16] build on the work of [43] to give self-correctors for the same functions. <p> On a related note, the use of polynomial checks (or the functional equations that are defined by the polynomial checks) for the correction of programs with few errors is suggested in <ref> [43] </ref>, and Blum, Codenotti, Gemmell and Shahoumian [16] build on the work of [43] to give self-correctors for the same functions. <p> Thus the corollary implies that there exist programs which are very 14 different from any solution to this functional equation, yet pass the test most of the time. The direct use of polynomial checks suggested in <ref> [43] </ref> also yields functional equations which are not robust due to Corollary 10, however, the work of [16] shows how to transform the polynomial checks into more general functional equations for which the negative results in this section do not apply.
Reference: [44] <author> F. Vainstein, </author> <title> Low Redundancy Polynomial Checks for Numerical Computation. Applicable Algebra in Engineering, Communication and Complexity, </title> <year> 1995. </year>
Reference-contexts: The work of Cody and Stolz [25] proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein <ref> [42, 43, 44, 45] </ref>, suggests the use of polynomial checks for testing and correcting programs.
Reference: [45] <author> F. Vainstein, </author> <title> Self Checking Design Technique for Numerical Computations. </title> <journal> Journal of VLSI Design, </journal> <year> 1995. </year>
Reference-contexts: The work of Cody and Stolz [25] proposes the use of Taylor series in order to test programs for exponential integrals. These techniques apply to Bessel functions and Dawson's integral. The work of Vainstein <ref> [42, 43, 44, 45] </ref>, suggests the use of polynomial checks for testing and correcting programs.
Reference: [46] <author> R. Zippel. </author> <title> Zero Testing of Algebraic Functions. </title> <journal> Information Processing Letters, </journal> <note> to appear. </note>
Reference-contexts: Similar results that apply to algebraic functions can be proven for domains over which algebraic functions are defined (see <ref> [46] </ref>). We now show that any addition theorem satisfying 8a; b; c G [a; G [b; c]] = G [G [a; b]; c] is robust. This proof follows an outline similar to Coppersmith's version of the proof of robustness of the linearity test which is described in [19].
Reference: [47] <author> R. Zippel. </author> <title> Effective Polynomial Computation. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year> <month> 32 </month>
Reference-contexts: Since 8a; b; c 2 V; H (a; b; c) = 0, we know that H (a; b; c) 0 <ref> [47] </ref>. 2 4.2 d'Alembert's equation and others In this section, we show that the robustness of functional equations of the form 8x; y F [f (x y); f (x + y); f (x); f (y)] = 0, is not limited to addition theorems by showing that when the domain D is
References-found: 47

