URL: http://www.cs.brown.edu/people/hs/ICDE96.ps.Z
Refering-URL: http://www.cs.brown.edu/people/hs/
Root-URL: 
Email: fhs,sbzg@cs.brown.edu  
Title: Approximate Queries and Representations for Large Data Sequences  
Author: Hagit Shatkay Stanley B. Zdonik 
Address: Providence, RI 02912  
Affiliation: Department of Computer Science Brown University  
Abstract: Many new database application domains such as experimental sciences and medicine are characterized by large sequences as their main form of data. Using approximate representation can significantly reduce the required storage and search space. A good choice of representation, can support a broad new class of approximate queries, needed in these domains. These queries are concerned with application-dependent features of the data as opposed to the actual sampled points. We introduce a new notion of generalized approximate queries and a general divide and conquer approach that supports them. This approach uses families of real-valued functions as an approximate representation. We present an algorithm for realizing our technique, and the results of applying it to medical cardiology data. 
Abstract-found: 1
Intro-found: 1
Reference: [ABV94] <author> W. G. Aref, D. Barbara and P. Vallabhaneni, </author> <title> The Handwritten Trie: Indexing Electronic Ink, </title> <type> Technical report, </type> <institution> Matsushita Information Technology Laboratory, Princeton, NJ, </institution> <month> Octo-ber </month> <year> 1994. </year>
Reference-contexts: These features are compared in order to find similarities, and distances are measured between the values of the features to accommodate approximate matches. Other recent work presented in <ref> [ABV94] </ref> deals with recognition, matching and indexing handwritten text. They break handwritten text into letters, and incorporate Hidden Markov Models that recognize letters into a lexicographic index structure to support search. This approach doesn't generalize well to other sequential data which is not as structured and predictable as handwritten text.
Reference: [AFS93] <author> R. Agrawal, C. Faloutsos and A. Swami, </author> <title> Efficient Similarity Search In Sequence Databases, </title> <booktitle> In The Fourth International Conference on Foundations of Data Organization and Algorithms, </booktitle> <address> Evanston, Illinois, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect. <p> The above definition describes an approximation notion since it abstracts away from particular values and allows us to talk about how things "approximately look". It generalizes the standard notion of approximation ( <ref> [Mot88, CS94, AFS93] </ref>) in the following ways: * Generalizes what the query denotes, from a single sequence (or a set closed under identity of values), to a set of similar sequences, which can be obtained from an exemplar through similarity-preserving transformations. <p> Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in <ref> [AFS93, FRM94] </ref>. This work is based on mapping all subsequences of fixed length to K-dimensional points, that are K coefficients of the DFT (Discrete Fourier Transform), and using minimal bounding rectangles for storage and indexing.
Reference: [AHU74] <author> A. V. Aho, J. E. Hopcroft and J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: The function is specified near each line. running our breaking program on a sequence, where the program calculates the approximating regres sion line of each resulting subsequence. 3. An index structure that supports pattern matching (like the ones discussed in <ref> [Fre60, AHU74, Sub95] </ref>) is maintained on the "positiveness" of the functions' slopes. For a fixed small number , there are 3 possible index values: + (slope &gt; ), (slope &lt; ), or 0 (slope is between and ). We take = 0:3.
Reference: [ALSS95] <author> R. Agrawal, K.-I. Lin, H. S. Sawhney and K. Shim, </author> <title> Fast Similarity Search in the Presence of Noise, Scaling, and Translation in Time-Series Databases, </title> <booktitle> In VLDB, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Moreover, it generalizes more recent notion of similarity over sequences (see Section 3 and <ref> [GK95, ALSS95] </ref>) from proximity under shifting/scaling of sequences, to closure under any form of feature preserving transformations. 2.3 Approximate Data Representation Sequences such as time series are characterized by their large volume. Data is constantly generated, sampled, gathered and analyzed. <p> Queries are sequences that are matched against stored data up to some error tolerance, measured using Euclidean distance. The work is extended in [GK95] to allow for shifting and scaling of sequence amplitude. (A similar extension, using the L 1 metric, without DFT, is presented in <ref> [ALSS95] </ref>). This approach finds efficient approximate representation for time series, under the assumption that low frequencies constitute data, and high frequency is noise. However, similarity tests relying on proximity in the frequency domain, can not detect similarity under transformations such as dilation (frequency reduction) or contraction (frequency increase).
Reference: [APWZ95] <author> R. Agrawal, G. Psaila, E. L. Wimmers and M. Zait, </author> <title> Querying Shapes of Histories, </title> <booktitle> In VLDB, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: One of the options is to use a visual query language in which the user draws the shape of the sequence he/she is looking for, points out the important dimensions for comparison, and specifies error tolerance in each dimension. Constraint logic programming [KKR90, BJM93], or the language presented in <ref> [APWZ95] </ref>, may provide a reasonable basis for an underlying query language. * Address efficiency considerations for storage and access of data stored in the approximated format.
Reference: [BJM93] <author> A. Brodsky, J. Jaffar and M. J. Maher, </author> <title> Toward Practical Constraint Databases, </title> <booktitle> In Proceedings of the 19th VLDB Conference, </booktitle> <pages> pp. 567-580, </pages> <address> Dublin,Ireland, </address> <year> 1993. </year>
Reference-contexts: One of the options is to use a visual query language in which the user draws the shape of the sequence he/she is looking for, points out the important dimensions for comparison, and specifies error tolerance in each dimension. Constraint logic programming <ref> [KKR90, BJM93] </ref>, or the language presented in [APWZ95], may provide a reasonable basis for an underlying query language. * Address efficiency considerations for storage and access of data stored in the approximated format.
Reference: [Car75] <author> A. F. Cardenas, </author> <title> Analysis and Performance of Inverted Data Base Structures, </title> <journal> Communications of the ACM, </journal> <volume> 18 , no. 5, </volume> <pages> 253-263, </pages> <month> May </month> <year> 1975. </year>
Reference-contexts: The distance parameter (* of Figure 8) was set to 60. the error tolerance on the distance. (That is, distance n ffi between two consecutive peaks). It can be answered easily, if we have an index, such as an inverted index structure ( <ref> [Car75, FJ91] </ref> or some variation on it) based on the time elapsed between peaks. Building such an index is reasonable, since this kind of query is often required [Eli95], and can be done as follows: 1. Find the peaks in the sequences.
Reference: [CR94] <author> M. Crochemore and W. Rytter, </author> <title> Text Algorithms. </title> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: A stored sequence is an exact match if it is identical to the solid curve, (i.e. distance = 0). This form of similarity is supported by algorithms from the domain of approximate pattern matching (e.g. <ref> [CR94] </ref>). This paper presents a more general notion of approximation, appropriate for the complex queries required in advanced multimedia and scientific applications. A query mechanism in this context should allow for the specification of the general shape of data without depending on specific values.
Reference: [CS94] <author> A. Chatterjee and A. Segev, </author> <title> Approximate Matching in Scientific Databases, </title> <booktitle> In Proceedings of the Twenty-Seventh Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pp. 448-457, </pages> <year> 1994. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect. <p> The above definition describes an approximation notion since it abstracts away from particular values and allows us to talk about how things "approximately look". It generalizes the standard notion of approximation ( <ref> [Mot88, CS94, AFS93] </ref>) in the following ways: * Generalizes what the query denotes, from a single sequence (or a set closed under identity of values), to a set of similar sequences, which can be obtained from an exemplar through similarity-preserving transformations.
Reference: [Dau92] <author> I. Daubechies, </author> <title> Ten Lectures on Wavelets, </title> <booktitle> Regional Conference Series in Applied Mathematics. Society for Industrial and Applied Mathematics, </booktitle> <year> 1992. </year>
Reference-contexts: Our method also reduces the amount of data to be scanned for answering such queries. Due to space limitations, we omitted the details of the algorithms, that we implemented for both breaking sequences and preprocessing them prior to breaking. We use various algorithms for filtering, compression (using the wavelet-transform <ref> [FS94, HJS94, Dau92] </ref>), and normalization (to have mean 0 and variance 1). Such preprocessing is useful for reducing the amount of data and for ensuring that our breaking algorithms work properly.
Reference: [Eli95] <author> J. Elion, </author> <title> Miriam Hospital, Private conversation, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: It can be answered easily, if we have an index, such as an inverted index structure ( [Car75, FJ91] or some variation on it) based on the time elapsed between peaks. Building such an index is reasonable, since this kind of query is often required <ref> [Eli95] </ref>, and can be done as follows: 1. Find the peaks in the sequences. This can be done while storing the data as part of the preprocessing by examining the slopes of the representing functions.
Reference: [Fis93] <author> K. </author> <type> Fischer, </type> <institution> Dept. of Geochemistry, Brown University, Private conversation, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Domain experts retrieve portions of the raw data, and use application programs to manipulate it. Thus, little use is made of available database management tools. For example, obtaining raw seismic data can take several days <ref> [Fis93] </ref>. The geochemist examines this data in the lab, and if it is not sufficient to answer the question at hand, another retrieval is issued. This extremely high latency limits scientific progress.
Reference: [FJ91] <author> C. Faloutsos and H. V. Jagadish, </author> <title> Hybrid Index Organizations for Text Databases, </title> <type> Technical Report UMIACS-TR-91-33 CS-TR-2621, </type> <institution> Department of Computer Science, University of Maryland, College Park, MD 20742, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: The distance parameter (* of Figure 8) was set to 60. the error tolerance on the distance. (That is, distance n ffi between two consecutive peaks). It can be answered easily, if we have an index, such as an inverted index structure ( <ref> [Car75, FJ91] </ref> or some variation on it) based on the time elapsed between peaks. Building such an index is reasonable, since this kind of query is often required [Eli95], and can be done as follows: 1. Find the peaks in the sequences.
Reference: [FL95] <author> C. Faloutsos and K.-I. Lin, </author> <title> FastMap: A Fast Algorithm for Indexing, Data-Mining and Visualization of Traditional and Multimedi Datasets, </title> <booktitle> In SIGMOD Proceedings of Annual Conference, </booktitle> <address> San Jose, California, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Moreover, their approach is based on indexing over all fixed-length subsequences of each sequence. We claim that not all subsequences are of interest, thus there is no need to facilitate efficient access to all subsequences. The above work is extended in another direction in <ref> [FL95] </ref> to deduce the K-dimensional representation from the given data, using a provided distance function for the data, and reducing this distance to a K-dimensional Euclidean distance. This technique is very useful in cases where the distance function is well defined but costly to compute.
Reference: [Fre60] <author> E. Fredkin, </author> <title> Trie Memory, </title> <journal> Communications of the ACM, </journal> <volume> 3 , no. 9, </volume> <pages> 490-500, </pages> <month> September </month> <year> 1960. </year>
Reference-contexts: The function is specified near each line. running our breaking program on a sequence, where the program calculates the approximating regres sion line of each resulting subsequence. 3. An index structure that supports pattern matching (like the ones discussed in <ref> [Fre60, AHU74, Sub95] </ref>) is maintained on the "positiveness" of the functions' slopes. For a fixed small number , there are 3 possible index values: + (slope &gt; ), (slope &lt; ), or 0 (slope is between and ). We take = 0:3.
Reference: [FRM94] <author> C. Faloutsos, M. Ranganathan and Y. Manolopoulos, </author> <title> Fast Subsequence Matching in Time-Series Databases, </title> <booktitle> In SIGMOD Proceedings of Annual Conference, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect. <p> It is sufficient to characterize "interesting" features in the data, and store these characterizations rather than whole sequences. Examples of such characterizations are differential equations, approximating polynomials, compressions, or main frequencies of DFT <ref> [FRM94] </ref>. Applications may require different alphabets of interesting features. For example, in order to find a word in a database of spoken recorded text, it is a good strategy to transform the sequence of sampled audio signals into a sequence of words, represented as strings of ASCII characters. <p> Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in <ref> [AFS93, FRM94] </ref>. This work is based on mapping all subsequences of fixed length to K-dimensional points, that are K coefficients of the DFT (Discrete Fourier Transform), and using minimal bounding rectangles for storage and indexing.
Reference: [FS94] <author> A. Finkelstein and D. H. Salesin, </author> <title> Multires-olution Curves, </title> <booktitle> In SIGGRAPH Computer Graphics Proceedings, </booktitle> <pages> pp. 261-268, </pages> <year> 1994. </year>
Reference-contexts: Our method also reduces the amount of data to be scanned for answering such queries. Due to space limitations, we omitted the details of the algorithms, that we implemented for both breaking sequences and preprocessing them prior to breaking. We use various algorithms for filtering, compression (using the wavelet-transform <ref> [FS94, HJS94, Dau92] </ref>), and normalization (to have mean 0 and variance 1). Such preprocessing is useful for reducing the amount of data and for ensuring that our breaking algorithms work properly.
Reference: [FvDFH90] <author> J. Foley, A. van Dam, S. Finer and J. Hughes, </author> <booktitle> Computer Graphics Principles and Practice, </booktitle> <pages> pp. 478-507, </pages> <booktitle> The Systems Programming Series. </booktitle> <publisher> Addison and Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Here we concentrate on the linear interpolation algorithm, and only briefly review the Bezier Curves and linear regression algorithms. Bezier Curves are used in computer graphics for rep 8 Implementation for Schneider's original algorithm was available through ftp wuarchive.wustl.edu at graphics/graphics/books/graphics-gems/Gems. resenting digitized curves <ref> [FvDFH90] </ref>. Computer--graphics techniques match our interest in queries based on "the way sequences look" (as demonstrated in Section 2.1). They also generalize well to sequences other than time-series (not functions of time), and to multidimensional sequences.
Reference: [GK95] <author> D. Q. Goldin and P. C. Kanellakis, </author> <title> On Similarity Queries for Time Series Data: Constraint Specification and Implementation, </title> <booktitle> In Proceedings of the International Conference on Principles and Practice of Constraint Programming, </booktitle> <address> Cassis, France, </address> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Moreover, it generalizes more recent notion of similarity over sequences (see Section 3 and <ref> [GK95, ALSS95] </ref>) from proximity under shifting/scaling of sequences, to closure under any form of feature preserving transformations. 2.3 Approximate Data Representation Sequences such as time series are characterized by their large volume. Data is constantly generated, sampled, gathered and analyzed. <p> Queries are sequences that are matched against stored data up to some error tolerance, measured using Euclidean distance. The work is extended in <ref> [GK95] </ref> to allow for shifting and scaling of sequence amplitude. (A similar extension, using the L 1 metric, without DFT, is presented in [ALSS95]). This approach finds efficient approximate representation for time series, under the assumption that low frequencies constitute data, and high frequency is noise.
Reference: [GS93] <author> H. Gunadi and A. Segev, </author> <title> Efficient Indexing Methods for Temporal Relations, </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pp. 496-509, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: They can be stored archivally and used when finer resolution is needed. 3 Related Work The work presented here lies in the intersection of two domains, namely, sequence support in databases and similarity (and approximation) queries. A lot of the recent work on databases for temporal and sequential data <ref> [Ric92, GS93, SS93, SZLV93, SLR94] </ref> does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94]. <p> We claim that sequences can be broken into meaningful subsequences, and each subsequence can be represented as a continuous and differentiable function. The data model underlying this approach must preserve and support sequential (temporal or other) ordering, as in <ref> [SZLV93, SS93, GS93] </ref>. Functions have the following desirable features: 1. Significant compression can be achieved. The exact compression rate depends on the nature of the data, the tolerated information loss, and the chosen functions. 2.
Reference: [HJS94] <author> M. L. Hilton, B. D. Jawerth and A. Sen-gupta, </author> <title> Compressing still and moving images with wavelets, </title> <journal> Multimedia Systems, </journal> <volume> 2, </volume> <pages> 218-227, </pages> <year> 1994. </year>
Reference-contexts: Our method also reduces the amount of data to be scanned for answering such queries. Due to space limitations, we omitted the details of the algorithms, that we implemented for both breaking sequences and preprocessing them prior to breaking. We use various algorithms for filtering, compression (using the wavelet-transform <ref> [FS94, HJS94, Dau92] </ref>), and normalization (to have mean 0 and variance 1). Such preprocessing is useful for reducing the amount of data and for ensuring that our breaking algorithms work properly.
Reference: [Jag91] <author> H. V. Jagadish, </author> <title> A Retrieval Technique for Similar Shapes, </title> <booktitle> In ACM SIGMOD Proceedings of the International Conference on Management of Data, </booktitle> <pages> pp. 208-217, </pages> <address> Denver, </address> <year> 1991. </year>
Reference-contexts: A lot of the recent work on databases for temporal and sequential data [Ric92, GS93, SS93, SZLV93, SLR94] does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences <ref> [Mum87, Jag91, SWZS94] </ref>, but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94].
Reference: [JMM95] <author> H. V. Jagadish, A. O. Mandelzon and T. Milo, </author> <title> Similarity-Based Queries, </title> <booktitle> In Proceedings of the ACM PODS Conference, </booktitle> <address> San Jose, Cal-ifornia, </address> <year> 1995. </year>
Reference-contexts: They break handwritten text into letters, and incorporate Hidden Markov Models that recognize letters into a lexicographic index structure to support search. This approach doesn't generalize well to other sequential data which is not as structured and predictable as handwritten text. Very recently Jagadish et al <ref> [JMM95] </ref> introduced a general framework, for approximate queries. It consists of a pattern language P, a transformation rule language T, and a query language L. Distance between objects is measured in terms of the cost of the transformation rules that map from one object to another. <p> Our approach is focused around prominent features, the transformations we consider are those that preserve them, and approximations are deviations from these features. In <ref> [JMM95] </ref> the transformation rules correspond to the deviations and differences between objects, rather than to "sameness". Our tailoring of the representation around the features, already embeds the predicates associated with "pattern" queries of [JMM95], into the represented data. <p> In <ref> [JMM95] </ref> the transformation rules correspond to the deviations and differences between objects, rather than to "sameness". Our tailoring of the representation around the features, already embeds the predicates associated with "pattern" queries of [JMM95], into the represented data. This facilitates indexing and efficient search, and allows for the transformation-rule based approximation of [JMM95], to be treated as a simple, quantified deviation from the stored data, and therefore to be handled as regular range queries. 4 Our Approach Divide and Conquer In this section we <p> Our tailoring of the representation around the features, already embeds the predicates associated with "pattern" queries of <ref> [JMM95] </ref>, into the represented data. This facilitates indexing and efficient search, and allows for the transformation-rule based approximation of [JMM95], to be treated as a simple, quantified deviation from the stored data, and therefore to be handled as regular range queries. 4 Our Approach Divide and Conquer In this section we introduce and demonstrate our idea of representing sequences in a way that facilitates generalized approximate queries.
Reference: [Kae94] <author> L. P. </author> <type> Kaelbling, </type> <institution> Dept. of Computer Science, Brown University, Private conversation, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: second shows the results of applying one of them to digitized electrocardiograms (ECGs). 5.1 Algorithms Review There are two classes of algorithms we have studied and implemented: On-line algorithms, determine breakpoints while data is being gathered, based on the data seen so far, with no overall view of the sequence <ref> [Kae94] </ref>. Their main merit is that an additional step of post-processing is not required. Their obvious deficiency is possible lack of accuracy. Hence, it is difficult to come up with an online algorithm that satisfies all our requirements for a wide variety of sequences.
Reference: [KKR90] <author> P. C. Kanellakis, G. M. Kuper and P. Z. Revesz, </author> <title> Constraint Query Languages, </title> <type> Technical Report CS-90-31, </type> <institution> Brown University, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: One of the options is to use a visual query language in which the user draws the shape of the sequence he/she is looking for, points out the important dimensions for comparison, and specifies error tolerance in each dimension. Constraint logic programming <ref> [KKR90, BJM93] </ref>, or the language presented in [APWZ95], may provide a reasonable basis for an underlying query language. * Address efficiency considerations for storage and access of data stored in the approximated format.
Reference: [Mot88] <author> A. Motro, </author> <title> VAGUE: A User Interface to Relational Databases that Permits Vague Queries, </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 6 , no. 3, </volume> <pages> 187-214, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect. <p> The above definition describes an approximation notion since it abstracts away from particular values and allows us to talk about how things "approximately look". It generalizes the standard notion of approximation ( <ref> [Mot88, CS94, AFS93] </ref>) in the following ways: * Generalizes what the query denotes, from a single sequence (or a set closed under identity of values), to a set of similar sequences, which can be obtained from an exemplar through similarity-preserving transformations.
Reference: [Mum87] <author> D. Mumford, </author> <title> The Problem of Robust Shape Descriptors, </title> <type> Technical Report CICS-P-40, </type> <institution> Center of Intelligent Control Systems, Har-vard University, </institution> <address> Cambridge, Mass., </address> <month> December </month> <year> 1987. </year>
Reference-contexts: A lot of the recent work on databases for temporal and sequential data [Ric92, GS93, SS93, SZLV93, SLR94] does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences <ref> [Mum87, Jag91, SWZS94] </ref>, but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94].
Reference: [Ric92] <author> J. Richardson, </author> <title> Supporting Lists in a Data Model (A Timely Approach), </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pp. 127-138, </pages> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: They can be stored archivally and used when finer resolution is needed. 3 Related Work The work presented here lies in the intersection of two domains, namely, sequence support in databases and similarity (and approximation) queries. A lot of the recent work on databases for temporal and sequential data <ref> [Ric92, GS93, SS93, SZLV93, SLR94] </ref> does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94].
Reference: [Sch90] <author> P. J. Schneider, </author> <title> An Algorithm for Automatically Fitting Digitized Curves, </title> <editor> In A. S. Glass-ner, editor, </editor> <booktitle> Graphic Gems, </booktitle> <pages> pp. 612-626. </pages> <publisher> Academic Press Edition, </publisher> <year> 1990. </year>
Reference-contexts: Off-line algorithms, are applied to complete sequences. The basic template of the algorithms we use 7 This is the * in Figure 8 of the next section. is given in Figure 8. It is a generalization of an algorithm for Bezier curve fitting <ref> [Sch90] </ref>. Any type of curve, c (such as polynomials of a fixed degree rather than the Bezier curves in the original algorithm), can be used within it, resulting in subsequences of the original sequence S, each of which can be approximated by a curve of type c. <p> However, unlike computer graphics applications, we have no indication of where curves start/end (no "mouse clicks"), nor do we allow user interference in the breaking process. The algorithm in <ref> [Sch90] </ref> supports fully automated curve fitting of digitized curves and therefore is useful for our purposes. Its strengths and weaknesses for breaking sequences are discussed in [Sha95]. A simpler version of curve fitting is the use of linear functions for curves.
Reference: [Sha95] <author> H. Shatkay, </author> <title> Approximate Queries and Representation for Large Data Sequences, </title> <type> Technical Report CS-95-03, </type> <institution> Brown University, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: We implemented and studied one family of on-line algorithms based on sliding a window, interpolating a polynomial through it, and breaking the sequence whenever it deviates significantly from the polynomial. Our experiments are documented in <ref> [Sha95] </ref>, and we are still studying algorithms using a related approach. Off-line algorithms, are applied to complete sequences. The basic template of the algorithms we use 7 This is the * in Figure 8 of the next section. is given in Figure 8. <p> We have instantiated the curve type, (c of Figure 8), in three ways a modified Bezier curve 8 , a linear-regression line, and an interpolation line through the endpoints of the respective sequences. A full report of our experiments can be found in <ref> [Sha95] </ref>. Here we concentrate on the linear interpolation algorithm, and only briefly review the Bezier Curves and linear regression algorithms. Bezier Curves are used in computer graphics for rep 8 Implementation for Schneider's original algorithm was available through ftp wuarchive.wustl.edu at graphics/graphics/books/graphics-gems/Gems. resenting digitized curves [FvDFH90]. <p> The algorithm in [Sch90] supports fully automated curve fitting of digitized curves and therefore is useful for our purposes. Its strengths and weaknesses for breaking sequences are discussed in <ref> [Sha95] </ref>. A simpler version of curve fitting is the use of linear functions for curves. We have experimented with both linear regression and linear interpolation of endpoints. The latter is simpler and produces better results, and is described in the remainder of this section.
Reference: [SLR94] <author> P. Seshadri, M. Livny and R. Ramakrish-nan, </author> <title> Sequence Query Processing, </title> <booktitle> In SIGMOD Proceedings of Annual Conference, </booktitle> <pages> pp. 430-441, </pages> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: They can be stored archivally and used when finer resolution is needed. 3 Related Work The work presented here lies in the intersection of two domains, namely, sequence support in databases and similarity (and approximation) queries. A lot of the recent work on databases for temporal and sequential data <ref> [Ric92, GS93, SS93, SZLV93, SLR94] </ref> does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94].
Reference: [SS93] <author> A. Segev and A. Shoshani, </author> <title> A Temporal Data Model Based on Time Series, </title> <editor> In A. U. Tansel et al., editors, </editor> <title> Temporal Databases, Theory, </title> <booktitle> Design, and Implementation, </booktitle> <pages> pp. 250-270. </pages> <publisher> Benjamin Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: They can be stored archivally and used when finer resolution is needed. 3 Related Work The work presented here lies in the intersection of two domains, namely, sequence support in databases and similarity (and approximation) queries. A lot of the recent work on databases for temporal and sequential data <ref> [Ric92, GS93, SS93, SZLV93, SLR94] </ref> does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94]. <p> We claim that sequences can be broken into meaningful subsequences, and each subsequence can be represented as a continuous and differentiable function. The data model underlying this approach must preserve and support sequential (temporal or other) ordering, as in <ref> [SZLV93, SS93, GS93] </ref>. Functions have the following desirable features: 1. Significant compression can be achieved. The exact compression rate depends on the nature of the data, the tolerated information loss, and the chosen functions. 2.
Reference: [Sub95] <author> B. Subramanian, </author> <type> PhD Thesis, Technical Report CS-95-34, </type> <institution> Brown University, </institution> <year> 1995. </year>
Reference-contexts: The function is specified near each line. running our breaking program on a sequence, where the program calculates the approximating regres sion line of each resulting subsequence. 3. An index structure that supports pattern matching (like the ones discussed in <ref> [Fre60, AHU74, Sub95] </ref>) is maintained on the "positiveness" of the functions' slopes. For a fixed small number , there are 3 possible index values: + (slope &gt; ), (slope &lt; ), or 0 (slope is between and ). We take = 0:3. <p> Find the peaks in the sequences. This can be done while storing the data as part of the preprocessing by examining the slopes of the representing functions. If data is already stored, an (existing) index structure (see <ref> [Sub95] </ref> for instance), that finds all subsequences of the form (+)() (as defined in Section 4.4) and returns their positions, can be used. 2. Start and end points of subsequences are part of the information obtained from the breaking algorithm, and are maintained with any representation of the sequence. <p> Hence there is a limited number of interval values, according to which the sequences can be indexed. A simple inverted file index is sufficient for this purpose and is used for this example. Using a more elaborate structure (see <ref> [Sub95] </ref>) would support more complex queries. The inverted-file index structure for our data is as shown in Figure 10. It consists of a B-Tree struc ture, which points to the postings file.
Reference: [SWZS94] <author> D. Shasha, J. T. Wang, K. Zhang and F. Y. Shih, </author> <title> Exact and Approximate Algorithms for Unordered Tree Matching, </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <volume> 24 , no. 2, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect. <p> A lot of the recent work on databases for temporal and sequential data [Ric92, GS93, SS93, SZLV93, SLR94] does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences <ref> [Mum87, Jag91, SWZS94] </ref>, but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94].
Reference: [SZLV93] <author> B. Subramanian, S. B. Zdonik, T. W. Le-ung and S. L. Vandenberg, </author> <title> Ordered Types in the Aqua Data Model, </title> <booktitle> In The 4th International Workshop on Database Programming Languages, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: They can be stored archivally and used when finer resolution is needed. 3 Related Work The work presented here lies in the intersection of two domains, namely, sequence support in databases and similarity (and approximation) queries. A lot of the recent work on databases for temporal and sequential data <ref> [Ric92, GS93, SS93, SZLV93, SLR94] </ref> does not address approximation. Very interesting work was done on similarity and approximation-based search for data other than sequences [Mum87, Jag91, SWZS94], but it does not generalize well to sequences. Similarity search on sequential data is presented in [AFS93, FRM94]. <p> We claim that sequences can be broken into meaningful subsequences, and each subsequence can be represented as a continuous and differentiable function. The data model underlying this approach must preserve and support sequential (temporal or other) ordering, as in <ref> [SZLV93, SS93, GS93] </ref>. Functions have the following desirable features: 1. Significant compression can be achieved. The exact compression rate depends on the nature of the data, the tolerated information loss, and the chosen functions. 2.
Reference: [WZJS94] <author> J. T. Wang, K. Zhang, K. Jeong and D. Shasha, </author> <title> A System for Approximate Tree Matching, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6 , no. 2, </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: They are not interested in the exact values in the time series as much as the overall shape of some subsequences. In this paper we introduce a new framework that facilitates a broad class of approximate queries over sequences. Previous work such as <ref> [Mot88, SWZS94, WZJS94, CS94, AFS93, FRM94] </ref> regards approximate queries, as queries to which the answers are not exactly what was asked for. The query defines an exact result in terms of specific values, which is the "best" we can expect.
References-found: 36

