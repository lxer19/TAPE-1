URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/117.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Title: EDEN The Paradise of Parallel and Concurrent Programming  
Author: Silvia Breitinger, Rita Loogen Philipps-Universitat Marburg Yolanda Ortega-Mallen 
Address: Madrid  
Affiliation: Universidad Complutense de  
Abstract: Parallel and concurrent programming tends to be very difficult due to the low-level concepts programmers have to deal with. Our aim is to simplify this task of programming by the declarative concurrent language `EDEN', an extension of a lazy functional language by constructs for the explicit specification of dynamic process systems. Following Shapiro [Sha89] we differentiate between transformational and reactive concurrent systems. Simple annotation-like notions for the explicit definition of processes are sufficient to describe the class of transformational systems. For the definition of reactive systems extra-functional constructs must be introduced. This paper focusses on the design of EDEN and illustrates its concepts with examples. 
Abstract-found: 1
Intro-found: 1
Reference: [BLOM94] <author> Karsten Bohlmann, Rita Loogen, and Yolanda Ortega-Mallen. </author> <title> Towards a functional process calculus. </title> <booktitle> In Proceedings of GULP-PRODE, </booktitle> <institution> Universita Politecnica de Valencia, </institution> <address> Spain, </address> <pages> pages 234 - 250, </pages> <year> 1994. </year>
Reference-contexts: It reflects the distinction between the computation and coordination language within EDEN. Similar as in <ref> [BLOM94] </ref> we use two levels of transition systems. On the upper level global effects on process systems are described. The lower level handles local effects within processes. The interface between the two levels are so-called `actions' by which the need for global events is communicated to the upper level.
Reference: [BLOM95a] <author> Silvia Breitinger, Rita Loogen, and Yolanda Ortega-Mallen. </author> <booktitle> Concurrency in Functional and Logic Languages. In Proceedings of the Fuji Int. Workshop on Functional and Logic Programming, </booktitle> <address> Japan. </address> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: The data flows from left to right and from top to bottom. Natural extensions of this are a torus structure or a general grid of size n fl n, which the interested reader both can find in our paper <ref> [BLOM95a] </ref>. grid : process&lt;process &lt; (*,*) -&gt; (*,*) &gt; -&gt; ((*,*),(*,*)) -&gt; ((*,*),(*,*))&gt; grid = process pabs :: process &lt; (*,*) -&gt; (*,*) &gt; input (left11,left21), (top11,top12) :: (*,*) output (right12,right22), (bot21,bot22) :: (*,*) body (right11,bot11) = pabs (left11,top11) (right12,bot12) = pabs (right12,top12) (right21,bot21) = pabs (left21,bot11) (right22,bot22) = pabs (right21,bot12)
Reference: [BLOM95b] <author> Silvia Breitinger, Rita Loogen, and Yolanda Ortega-Mallen. </author> <title> Eden | language definition and operational semantics. </title> <type> Technical report, </type> <institution> Philipps-Universitat Marburg, </institution> <year> 1995. </year>
Reference-contexts: The interested reader is referred to <ref> [BLOM95b] </ref>. The subset of EDEN which suffices for the specification of transformational systems, i.e. process abstractions and instantiations, can easily be translated into a pure lazy functional language and 10 thus tested on a sequential system.
Reference: [BS95] <author> Erik Barendsen and Sjaak Smetsers. </author> <title> Uniqueness Type Inference. </title> <booktitle> In Symposium on Programming Languages: Implementations, Logics and Programs, </booktitle> <address> PLILP'95, </address> <publisher> Springer LNCS 982, </publisher> <pages> pages 189-206, </pages> <year> 1995. </year>
Reference-contexts: The restrictions ensure that each dynamically created channel is used to establish a one-to-one connection between a unique writer process and the reader process which generated the channel. Channel variables can neither be duplicated nor be sent to several processes. A uniqueness type system in the style of <ref> [BS95] </ref> would allow a more flexible treatment of reply channel names. For the moment we do not consider such a treatment for simplicity. Example. (Hamming problem).
Reference: [CGK95] <author> Manuel M.T. Chakravarty, Yike Guo, and Martin Kohler. Goffin: </author> <title> higher order functions meet concurrent constraints. </title> <booktitle> First International Workshop on Concurrent Constraint Programming, </booktitle> <address> Venice, Italy, </address> <year> 1995. </year>
Reference-contexts: Nondeterministic computations can be encapsulated inside a special type of module, the so-called system module. Only implicit parallelism is considered within functional modules. The semantics of Maude is based on rewriting logic [Mes92]. Closer to our work is the language Goffin [CGKL94], <ref> [CGK95] </ref> with a concurrent constraint coordination language (see below) and Haskell as a computation language. It offers explicit parallelism, but no explicit notion of a process. Messages are exchanged via logical variables only. Concurrent constraint programming, as introduced by Saraswat [Sar93], allows for implicit parallelism.
Reference: [CGKL94] <author> Manuel M.T. Chakravarty, Yike Guo, Martin Kohler, and Hendrik C.R. </author> <title> Lock. Two limits of purely functional parallel programming and how to overcome them. </title> <type> internal report, </type> <year> 1994. </year>
Reference-contexts: Nondeterministic computations can be encapsulated inside a special type of module, the so-called system module. Only implicit parallelism is considered within functional modules. The semantics of Maude is based on rewriting logic [Mes92]. Closer to our work is the language Goffin <ref> [CGKL94] </ref>, [CGK95] with a concurrent constraint coordination language (see below) and Haskell as a computation language. It offers explicit parallelism, but no explicit notion of a process. Messages are exchanged via logical variables only. Concurrent constraint programming, as introduced by Saraswat [Sar93], allows for implicit parallelism.
Reference: [DFH + 93] <author> J. Darlington, A.J. Field, P.G. Harrison, P.H.J. Kelly, D.W.N. Sharp, Q. Wu, </author> <title> and R.L. While. Parallel Programming Using Skeleton Functions. </title> <booktitle> In Parallel Architectures and Languages Europe. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Section 3). Process networks can be extended dynamically, e.g. depending on tests for sufficient task granularity as suggested by the par op example above. Arbitrary regular topologies can be defined using recursive definitions. Following the skeleton idea (cf. <ref> [DFH + 93] </ref>), useful communication topologies can be defined and instantiated with suitable process abstractions for the computations to be performed by the respective 'cells', as the subsequent example illustrates. Example (Grid structure).
Reference: [dKC94] <author> Jacques Chassin de Kergommeaux and Philippe Codognet. </author> <title> Parallel logic programming systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(3):295 - 336, </volume> <year> 1994. </year>
Reference-contexts: In the following we will comment only on approaches supporting some notion of explicit parallelism or concurrency. In this class of languages, concurrent logic programming has the longest tradition (consult for example [Sha89] or <ref> [dKC94] </ref> for a survey). Although this area is not directly connected to our work, many important concepts such as incomplete messages originate from there. Facile [GMP89] was one of the first language designs which combine functional and concurrent programming.
Reference: [GC92] <author> David Gelernter and Nicolas Carriero. </author> <title> Coordination languages and their significance. </title> <journal> Communications of the ACM, </journal> <volume> 35(2):96 - 107, </volume> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Finally we sketch EDEN's operational semantics and give some hints at its implementation. 2 Garden: Process Systems The language EDEN is based on the lazy functional language Haskell [HW92]. According to the classification introduced by Carriero and Gelernter <ref> [GC92] </ref>, this language forms the computation model, which is extended with a coordination model that introduces processes in a functional style. A process can be created by applying a process abstraction to suitable input expressions.
Reference: [GMP89] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> Facile: A Symmetric Integration of Concurrent and Functional Programming. </title> <journal> Journal of Parallel Programming, </journal> <volume> 18(2), </volume> <year> 1989. </year> <month> 11 </month>
Reference-contexts: In this class of languages, concurrent logic programming has the longest tradition (consult for example [Sha89] or [dKC94] for a survey). Although this area is not directly connected to our work, many important concepts such as incomplete messages originate from there. Facile <ref> [GMP89] </ref> was one of the first language designs which combine functional and concurrent programming. It provides an interface between process calculus expressions and functional expressions using CCS-like constructs for concurrent composition and nondeterministic choice and thus models synchronized explicit communication on a rather low level of abstraction.
Reference: [Hud91] <author> Paul Hudak. </author> <title> Para-Functional Programming in Haskell. </title> <editor> In Szymanski, editor, </editor> <booktitle> Parallel Functional Languages and Compilers. </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: The aim of implicit parallelism is to speed up programs without troubling programmers with parallelism. We even count approaches with explicit annotations like e.g. Concurrent Clean [vEP93] or para-functional programming <ref> [Hud91] </ref> as implicit, because the semantics of annotated programs is usually defined as the semantics of the program without annotations, i.e. the annotations are semantically transparent. Explicit parallelism however provides a language with additional expressive power and requires an extension of the semantics as well.
Reference: [HW92] <editor> Paul Hudak and Phil (editors) Wadler. </editor> <title> Report on the programming language Haskell: a non-strict, purely functional language. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5) </volume> <pages> 1-162, </pages> <year> 1992. </year>
Reference-contexts: Our goal is the programming of systems with distributed memory. The language EDEN is an extension of the lazy functional language Haskell <ref> [HW92] </ref> by constructs which are necessary for the explicit definition of process structures. In order to preserve the characteristics of the purely functional kernel language, a clean (semantic) separation between processes and functional objects is required. <p> Explicit parallelism however provides a language with additional expressive power and requires an extension of the semantics as well. Usually the semantics is defined operationally only. 1.2 Our approach As mentioned above, EDEN is an extension on the lazy functional language Haskell <ref> [HW92] </ref> with new syntactic constructs for defining processes explicitly. These processes can communicate by the exchange of values via communication channels modelled by lazy lists. This kernel part of the language suffices for the specification of arbitrary transformational systems using the well-known approach of stream-based computation and communication [KM77]. <p> Finally we sketch EDEN's operational semantics and give some hints at its implementation. 2 Garden: Process Systems The language EDEN is based on the lazy functional language Haskell <ref> [HW92] </ref>. According to the classification introduced by Carriero and Gelernter [GC92], this language forms the computation model, which is extended with a coordination model that introduces processes in a functional style. A process can be created by applying a process abstraction to suitable input expressions.
Reference: [Kel89] <author> Paul Kelly. </author> <title> Functional Programming for Loosely Coupled Multiprocessors. </title> <publisher> Pitman, </publisher> <year> 1989. </year>
Reference-contexts: It provides an interface between process calculus expressions and functional expressions using CCS-like constructs for concurrent composition and nondeterministic choice and thus models synchronized explicit communication on a rather low level of abstraction. A further pioneer of the concurrent functional programming idea was Caliban <ref> [Kel89] </ref> that defines processes by very powerful annotations, but only restricted to the case of static networks. The younger languages Concurrent ML (CML) [Rep91] and Concurrent Haskell [PJF95] aim at a level of abstraction which is lower than that of EDEN.
Reference: [KM77] <author> G. Kahn and D.B. MacQueen. </author> <title> Coroutines and networks of parallel processes. </title> <booktitle> In IFIP 77. </booktitle> <publisher> North Holland, </publisher> <year> 1977. </year>
Reference-contexts: These processes can communicate by the exchange of values via communication channels modelled by lazy lists. This kernel part of the language suffices for the specification of arbitrary transformational systems using the well-known approach of stream-based computation and communication <ref> [KM77] </ref>. But EDEN goes further. It incorporates three additional concepts for the definition of general reactive systems: * dynamic creation of reply channels: This new feature simplifies the generation of complex communication topologies and increases the flexibility of the language.
Reference: [Mes92] <author> Jose Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 96:73 -155, </address> <year> 1992. </year>
Reference-contexts: Another important parallel functional language is Maude [MW92], where computations are structured by the introduction of modules. Nondeterministic computations can be encapsulated inside a special type of module, the so-called system module. Only implicit parallelism is considered within functional modules. The semantics of Maude is based on rewriting logic <ref> [Mes92] </ref>. Closer to our work is the language Goffin [CGKL94], [CGK95] with a concurrent constraint coordination language (see below) and Haskell as a computation language. It offers explicit parallelism, but no explicit notion of a process. Messages are exchanged via logical variables only.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: It is related to the `incomplete message principle' known from concurrent logic languages [Sha89] and the `channel name passing' principle of the -calculus <ref> [MPW92] </ref>, but is far more restricted in order to maintain the declarative nature of the language. * process internal synchronization primitives: The interface of EDEN processes consists of an arbitrary number of input and output channels. The main task of a process is the evaluation of its output channels.
Reference: [MW92] <author> Jose Meseguer and Timothy Winkler. </author> <booktitle> Parallel Programming in Maude. In Research Directions in High-Level Parallel Programming Languages, </booktitle> <volume> LNCS 574, </volume> <pages> pages 253-293. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: CML and Concurrent Haskell implicitly assume the availability of a shared memory, while EDEN is tailored at a distributed memory system. Another important parallel functional language is Maude <ref> [MW92] </ref>, where computations are structured by the introduction of modules. Nondeterministic computations can be encapsulated inside a special type of module, the so-called system module. Only implicit parallelism is considered within functional modules. The semantics of Maude is based on rewriting logic [Mes92].
Reference: [PJF95] <author> Simon Peyton Jones and Sigbjorn Finne. </author> <title> Concurrent Haskell: preliminary version. </title> <type> Technical Report G128QQ, </type> <institution> Department of Computer Science, University of Glasgow, </institution> <year> 1995. </year>
Reference-contexts: A further pioneer of the concurrent functional programming idea was Caliban [Kel89] that defines processes by very powerful annotations, but only restricted to the case of static networks. The younger languages Concurrent ML (CML) [Rep91] and Concurrent Haskell <ref> [PJF95] </ref> aim at a level of abstraction which is lower than that of EDEN.
Reference: [Rep91] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293 -305, </pages> <year> 1991. </year>
Reference-contexts: A further pioneer of the concurrent functional programming idea was Caliban [Kel89] that defines processes by very powerful annotations, but only restricted to the case of static networks. The younger languages Concurrent ML (CML) <ref> [Rep91] </ref> and Concurrent Haskell [PJF95] aim at a level of abstraction which is lower than that of EDEN.
Reference: [Sar93] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Closer to our work is the language Goffin [CGKL94], [CGK95] with a concurrent constraint coordination language (see below) and Haskell as a computation language. It offers explicit parallelism, but no explicit notion of a process. Messages are exchanged via logical variables only. Concurrent constraint programming, as introduced by Saraswat <ref> [Sar93] </ref>, allows for implicit parallelism. Synchronization is performed via ask and tell operations for the exchange of partial information with a global constraint store. EDEN's demand control mechanism within processes (see Section 4) is a strongly simplified version of this ask-and-tell mechanism.
Reference: [Sha89] <author> Ehud Shapiro. </author> <title> The Family of Concurrent Logic Programming Languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: As processes are dynamic entities they must be distinguished from static objects like values, functions or so-called process abstractions, which specify the behaviour of processes without being processes themselves. 1.1 Terminology Following the terminology of <ref> [Sha89] </ref> we use the following classification of concurrent systems. A transformational system or program receives some input at the beginning of its operation and yields an output at its end. <p> It incorporates three additional concepts for the definition of general reactive systems: * dynamic creation of reply channels: This new feature simplifies the generation of complex communication topologies and increases the flexibility of the language. It is related to the `incomplete message principle' known from concurrent logic languages <ref> [Sha89] </ref> and the `channel name passing' principle of the -calculus [MPW92], but is far more restricted in order to maintain the declarative nature of the language. * process internal synchronization primitives: The interface of EDEN processes consists of an arbitrary number of input and output channels. <p> In the following we will comment only on approaches supporting some notion of explicit parallelism or concurrency. In this class of languages, concurrent logic programming has the longest tradition (consult for example <ref> [Sha89] </ref> or [dKC94] for a survey). Although this area is not directly connected to our work, many important concepts such as incomplete messages originate from there. Facile [GMP89] was one of the first language designs which combine functional and concurrent programming.
Reference: [Tho93] <author> John Thornley. </author> <title> Integrating functional and imperative parallel programming: CC++ solutions to the salishan problems. </title> <type> Technical Report CS-TR-93-40, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: sortmerge (h:t) (h':t') = if h &lt; h' then h : (sortmerge t (h':t')) else h': (sortmerge (h:t) t' ) end end The Hamming problem is one of the so-called Salishan problems which have been proposed at the 1988 Salishan High-Speed Conference as a test set for parallel programming languages <ref> [Tho93] </ref>. 4 Harmony: Synchronisation of Threads The core language of EDEN is a lazy functional language, i.e. subexpressions are only evaluated when there is demand for them.
Reference: [vEP93] <author> Marco van Eekelen and Rinus Plasmeijer. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison Wesley, Int. Computer Science Series, </publisher> <year> 1993. </year> <month> 12 </month>
Reference-contexts: The aim of implicit parallelism is to speed up programs without troubling programmers with parallelism. We even count approaches with explicit annotations like e.g. Concurrent Clean <ref> [vEP93] </ref> or para-functional programming [Hud91] as implicit, because the semantics of annotated programs is usually defined as the semantics of the program without annotations, i.e. the annotations are semantically transparent. Explicit parallelism however provides a language with additional expressive power and requires an extension of the semantics as well.
References-found: 23

