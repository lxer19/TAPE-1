URL: http://www.cs.wisc.edu/~johannes/papers/rtss.ps
Refering-URL: http://www.cs.wisc.edu/~johannes/publications.html
Root-URL: 
Email: (wahab@cs.odu.edu).  (jeffay@cs.unc.edu).  (sanjoy@cs.uvm.edu).  
Title: A Proportional Share Resource Allocation Algorithm For Real-Time, Time-Shared Systems  
Author: Ion Stoica Hussein Abdel-Wahab Kevin Jeffay Sanjoy K. Baruah Johannes E. Gehrke C. Greg Plaxton k 
Address: Norfolk, VA 23529-0162  Chapel Hill, Chapel Hill, NC 27599-3175  Vermont, Burlignton, VT 05405  
Affiliation: Department of Computer Science, Old Dominion University,  Department of Computer Science, University of North Carolina at  Department of Computer Science, University of  
Abstract: We propose and analyze a proportional share resource allocation algorithm for realizing real-time performance in time-shared operating systems. In a proportional share system, processes are assigned a weight which determines a share (percentage) of the resource they are to receive. The resource is then allocated in discrete-sized time quanta in such a manner that each process makes progress at a precise, uniform rate. Proportional share allocation algorithms are of interest because (1) they provide a natural means of seamlessly integrating real- and non-real-time processing requirements in a general purpose operating system, (2) they are easy to implement (and in particular, easier than more traditional forms of real-time support such as periodic tasks), (3) they provide a simple and effective means of precisely controlling the real-time performance of a process including uniform, predictable degradation in times of system overload, and (4) they provide a natural means of policing processes so that process that use more of a resource than they request have no ill-effect on well-behaved processes. We present our algorithm and its analysis in the context of an idealized system in which a resource is assumed to be granted in arbitrarily small intervals of time and show that our algorithm guarantees that the difference between the service time that a process Department of Computer Science, University of Wisconsin Madisson, Madison, WI 53706-1685 (johannes@cs.wisc.edu). k Department of Computer Science, University of Texas at Austin, Austin, TX 78712-1188 (plaxton@cs.utexas.edu). should receive in the idealized system and the service time it actually receives in the real system is bounded by the size q of a time quantum. This demonstrates that our algorithm is capable of guaranteeing real-time response times to processes. Moreover, we also show that these bound are the best obtainable in a proportion share system and hence that our algorithm provides optimal performance. Lastly, the algorithm provides support for dynamic operations, such as processes joining or leaving the competition, and for both fractional and non-uniform time quanta. As a proof of concept we have implemented a prototype of a CPU scheduler under FreeBSD operating systems. The experimental results shows that our implementation perform within the theoretical bounds and hence supports real-time execution in a general purpose operating system. fl Department of Computer Science, Old Dominion University, Norfolk, VA 23529-0162 (stoica@cs.odu.edu).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. K. Baruah, J. E. Gehrke and C. G. Plaxton, </author> <title> "Fast Scheduling of Periodic Tasks on Multiple Resources", </title> <booktitle> Proc. of the 9th International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1995, </year> <pages> pp. </pages> <month> 280-288. </month> <title> (a) (b) (a) plots the number of iterations for three clients with weights 3, 2, and 1, respectively. Each client performs 50 iterations. Clients 2 and 3 begins at the same time; client 3 is delayed for 300 ms. (b) plots the clients' lags. </title>
Reference-contexts: This simplifies the implementation and eliminates the need of keeping an event queue. It is worth to mention that unlike other previous approximations [5], ours gurantees optimal lag bounds. Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed <ref> [1, 8, 11, 15] </ref>. Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton [1] achieves constant lag bounds in a static system. <p> Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed [1, 8, 11, 15]. Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton <ref> [1] </ref> achieves constant lag bounds in a static system. The idea to apply fair queueing algorithms to processor scheduling was first suggested by Parekh in [10].
Reference: [2] <author> S. K. Baruah, J. E. Gehrke and C. G. Plaxton, </author> <title> "Fair On-Line Scheduling of a Dynamic Set of Tasks on a Single Resource", </title> <type> Technical Report UTCS-TR-96-03, </type> <institution> Department of Computer Science, University of Texas at Austin. </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: The original problem was stated in terms of selecting a union chairman every year, such that the accumulated number of chairmen from each state (of the union) to be proportional to its weight. As shown in <ref> [2] </ref>, Ti-jdeman's results can be easily applied to solve the proportional share allocation problem. In the general setting, the resource is allocated in fixed time quanta, while the clients' shares may change at the beginning of every time quantum. In this way dynamic operation can be easily accommodated. <p> We note that two similar algorithms were independently developed (in parallel to our original work [12]) by Bennett and Zhang in the context of allocating bandwidth in communication networks [3], and by Baruah, Gehrke and Plaxton in the context of processor scheduling for fixed time quanta <ref> [2] </ref>. 3 In addition to introducing the concept of virtual eligible time (which was also independently introduced in [2] and [3]) our work makes several unique key contributions. First, by "decoupling" the request size from the size of the time quantum we generalize the previous known theoretical results [9]. <p> work [12]) by Bennett and Zhang in the context of allocating bandwidth in communication networks [3], and by Baruah, Gehrke and Plaxton in the context of processor scheduling for fixed time quanta <ref> [2] </ref>. 3 In addition to introducing the concept of virtual eligible time (which was also independently introduced in [2] and [3]) our work makes several unique key contributions. First, by "decoupling" the request size from the size of the time quantum we generalize the previous known theoretical results [9]. Moreover, our analyze can be easily extended to preemptive systems, as well.
Reference: [3] <author> J. C. R. Bennett and H. Zhang, </author> <title> "WF 2 Q : Worst-case Fair Queueing", </title> <address> INFOCOM'96, San-Francisco, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: We note that this translates into an O (1) bound for the positive lag. However, as shown in <ref> [3, 12, 17] </ref>, the bound for the negative lag can be as large as O (n), where n represents the number of active sessions (clients) in the system. <p> We note that two similar algorithms were independently developed (in parallel to our original work [12]) by Bennett and Zhang in the context of allocating bandwidth in communication networks <ref> [3] </ref>, and by Baruah, Gehrke and Plaxton in the context of processor scheduling for fixed time quanta [2]. 3 In addition to introducing the concept of virtual eligible time (which was also independently introduced in [2] and [3]) our work makes several unique key contributions. <p> by Bennett and Zhang in the context of allocating bandwidth in communication networks <ref> [3] </ref>, and by Baruah, Gehrke and Plaxton in the context of processor scheduling for fixed time quanta [2]. 3 In addition to introducing the concept of virtual eligible time (which was also independently introduced in [2] and [3]) our work makes several unique key contributions. First, by "decoupling" the request size from the size of the time quantum we generalize the previous known theoretical results [9]. Moreover, our analyze can be easily extended to preemptive systems, as well.
Reference: [4] <author> A. Demers, S. Keshav, and S. Shenkar, </author> <title> "Analysis and Simulation of a Fair Queueing Algorithm", </title> <journal> Journal of Inter-networking Research & Experience, </journal> <month> October </month> <year> 1990, </year> <pages> pp. 3-12. </pages>
Reference-contexts: Our algorithm is closely related to weighted fair queueing algorithms previously developed for bandwidth allocation in communication networks <ref> [4, 5, 9] </ref>, and general purpose proportional share algorithms, such stride scheduling [16, 17]. De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments [4]. <p> De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments <ref> [4] </ref>. Since in practice a packet transmission cannot be preempted, the authors proposed an algorithm, called Packet Fair Queueing (PFQ), in which the packets are serviced in the order in which they would finish in the corresponding fluid-flow system (i.e., in the increasing order of their virtual deadlines). <p> Once a client's request is fulfilled, it may either issue a new request or 5 A similar model was used by Demers et al <ref> [4] </ref> in studying fair-queuing algorithms in communication networks. become passive. For uniformity, throughout this pa-per we assume that the client is the sole initiator of the requests 6 . For flexibility we allow the requests to have any duration.
Reference: [5] <author> S. J. Golestani, </author> <title> "A Self-Clocked Fair Queueing Scheme for Broadband Applications", </title> <booktitle> Proc. of IEEE INFOCOM'94, </booktitle> <month> April </month> <year> 1994, </year> <pages> pp. 636-646. </pages>
Reference-contexts: Our algorithm is closely related to weighted fair queueing algorithms previously developed for bandwidth allocation in communication networks <ref> [4, 5, 9] </ref>, and general purpose proportional share algorithms, such stride scheduling [16, 17]. De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments [4]. <p> As a solution, Golestani has proposed a new algorithm, called Self-Clocked Fair Queueing (SCFQ), in which the virtual time is updated when the client joins/leaves the competition in the real system, and not in the idealized one <ref> [5] </ref>. Although this scheme can be more efficiently implemented, this does not come for free: the lag bounds increase to within a factor of two of the ones guaranteed by PFQ. <p> This simplifies the implementation and eliminates the need of keeping an event queue. It is worth to mention that unlike other previous approximations <ref> [5] </ref>, ours gurantees optimal lag bounds. Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed [1, 8, 11, 15]. <p> Unfortunately, this solution has two major drawbacks. First, in many situations, such as scheduling incoming packets in a high speed networking switch, maintaining the events in the fluid-flow system is too expensive in practice <ref> [5] </ref>. Second and more important, this solution assumes implicitly that the service time that a client will use is known in advance.
Reference: [6] <author> S. J. Le*er, M. K. McKusick, M. J. Karels and J. S. Quar-terman. </author> <title> "The Design and Implementation of the 4.3BSD UNIX Operating System," </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: fit between proportional share resource allocation scheme we advocate and general purpose operating system design. (a) (b) (a) plots the number of iterations over one second period for three clients with weights 3, 2, and 1, respec tively; (b) plots the clients' lags over the same interval. original FreeBSD scheduler <ref> [6] </ref>. All the processes that request proportional share or reservation services are assigned a reserved (user-level) priority, and are handled by our scheduler. All the other processes are scheduled by the regular FreeBSD scheduler.
Reference: [7] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment", </title> <journal> Journal of the ACM, </journal> <volume> Vol. 20, No. 1, </volume> <month> January </month> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference: [8] <author> U. Maheshwari, </author> <title> "Charged-based Proportional Scheduling", </title> <type> Technical Memorandum MIT/LCS/TM-529, </type> <institution> Laboratory for CS, MIT, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: This simplifies the implementation and eliminates the need of keeping an event queue. It is worth to mention that unlike other previous approximations [5], ours gurantees optimal lag bounds. Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed <ref> [1, 8, 11, 15] </ref>. Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton [1] achieves constant lag bounds in a static system.
Reference: [9] <author> A. K. Parekh and R. G. Gallager, </author> <title> "A Generalized Processor Sharing Approach To Flow Control in Integrated Services Networks-The Single Node Case", </title> <journal> ACM/IEEE Transactions on Netwrking, </journal> <volume> Vol. 1, No. 3, </volume> <year> 1992, </year> <pages> pp. 344-357. </pages>
Reference-contexts: Our algorithm is closely related to weighted fair queueing algorithms previously developed for bandwidth allocation in communication networks <ref> [4, 5, 9] </ref>, and general purpose proportional share algorithms, such stride scheduling [16, 17]. De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments [4]. <p> By using the concept of virtual time, previously introduced by Zhang [18], Parekh and Gallager have analyzed the PFQ 2 algorithm when the input traffic stream conforms to the leaky-bucket constraints <ref> [9, 10] </ref>. In particular, they shown that no packet is serviced T max latter than it would have been serviced in the fluid-flow system, where T max represents the time to transmit a packet of maximum size. <p> First, by "decoupling" the request size from the size of the time quantum we generalize the previous known theoretical results <ref> [9] </ref>. Moreover, our analyze can be easily extended to preemptive systems, as well. <p> In this way a client could trade between the allocation accuracy and scheduling overhead. We formulate our scheduling algorithm in terms of the behavior of an ideal, fluid-flow system that executes clients in a virtual-time time domain <ref> [18, 9] </ref>. 7 Abstractly, the virtual fluid-flow system executes each client for w i real-time time units during each virtual-time time unit. <p> Moreover, when a client with positive lag leaves, the value of virtual-time is updated according to Eq. (14). The following theorem gives the upper bound for the maximum delay of fulfilling a request in an S-system. We note that this result generalizes a previous result of Parekh and Gallager <ref> [9] </ref> which holds for the particular case in which a request is no larger than a time quantum.
Reference: [10] <author> A. K. Parekh, </author> <title> "A Generalized Processor Sharing Approach To Flow Control in Integrated Services Networks", </title> <type> Ph.D Thesis, </type> <institution> Department of EE and CS, MIT, </institution> <year> 1992. </year>
Reference-contexts: By using the concept of virtual time, previously introduced by Zhang [18], Parekh and Gallager have analyzed the PFQ 2 algorithm when the input traffic stream conforms to the leaky-bucket constraints <ref> [9, 10] </ref>. In particular, they shown that no packet is serviced T max latter than it would have been serviced in the fluid-flow system, where T max represents the time to transmit a packet of maximum size. <p> Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton [1] achieves constant lag bounds in a static system. The idea to apply fair queueing algorithms to processor scheduling was first suggested by Parekh in <ref> [10] </ref>.
Reference: [11] <author> I. Stoica, H. Abdel-Wahab, </author> <title> "A new approach to implement proportional share resource allocation", </title> <type> Technical Report TR-95-05, </type> <institution> CS Dpt., ODU, </institution> <month> April </month> <year> 1995, </year> <pages> pp. </pages> <note> 17 (also available at http://www.cs.odu.edu/~stoica/pubs.html) </note>
Reference-contexts: This simplifies the implementation and eliminates the need of keeping an event queue. It is worth to mention that unlike other previous approximations [5], ours gurantees optimal lag bounds. Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed <ref> [1, 8, 11, 15] </ref>. Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton [1] achieves constant lag bounds in a static system.
Reference: [12] <author> I. Stoica, H. Abdel-Wahab, </author> <title> "Earliest Eligible Virtual Deadline First: A Flexible and Accurate Mechanism for Proportional Share Resource Allocation", </title> <type> Technical Report TR-95-22, </type> <institution> CS Dpt., ODU, </institution> <month> November </month> <year> 1995, </year> <pages> pp. </pages> <note> 37 (also available at http://www.cs.odu.edu/~stoica/pubs.html) </note>
Reference-contexts: We note that this translates into an O (1) bound for the positive lag. However, as shown in <ref> [3, 12, 17] </ref>, the bound for the negative lag can be as large as O (n), where n represents the number of active sessions (clients) in the system. <p> In contrast to the above algorithms, by making use of both virtual eligible times and virtual deadlines, EEVDF achieves constant lag bounds, while providing full support for dynamic operations. We note that two similar algorithms were independently developed (in parallel to our original work <ref> [12] </ref>) by Bennett and Zhang in the context of allocating bandwidth in communication networks [3], and by Baruah, Gehrke and Plaxton in the context of processor scheduling for fixed time quanta [2]. 3 In addition to introducing the concept of virtual eligible time (which was also independently introduced in [2] and <p> In short, a gain for one client translates into a loss for the other active clients. Similarly, when a client with positive lag leaves, this translates into a gain for the remaining clients. The main question here is how to distribute this loss/gain among the remaining clients. In <ref> [12] </ref> we answered this question by distributing it in proportion to the clients' weights. In the remaining of this section we show that the same answer is obtained by approaching the problem from a different angle. <p> Unfor 8 Note that having this two operation, changing the client weight can be easily implemented as a leave followed by a rejoin operation <ref> [12] </ref>. tunately, since at this point we do not know for how long client 1 will continue to use the resource (we know only that it has made a two time units request from which it has received one time unit, and it still has to receive another one) we cannot <p> Mainly, this is because we need to implement an event queue which has to trade between the timer granularity and the overhead. As we have shown in <ref> [12] </ref> all the basic operation required to implement the EEVDF algorithm, i.e., inserting and deleting a request, and finding the eligible request with the earliest deadline can be implemented in O (log n), where n represents the number of active clients. <p> Corollary If no request of client k is larger than a time quantum, then at any time t its lag is bounded as follows: q &lt; lag k (t) &lt; q: Finally, we note that according to the following simple lemma (the proof can be found in <ref> [12] </ref>) the bounds given in the above corollary are optimal, i.e., they hold for any proportional share algorithm.
Reference: [13] <author> I. Stoica, H. Abdel-Wahab, K. Jeffay, </author> <title> "On the Duality between Resource Reservation and Proportional Share Resource Allocation", </title> <type> Technical Report TR-96-19, </type> <institution> CS Dpt., ODU, </institution> <month> May </month> <year> 1996, </year> <pages> pp. </pages> <note> 14 (also available at http://www.cs.odu.edu/~stoica/pubs.html) </note>
Reference-contexts: one can either adjust the weight of a client as needed when new clients enter and leave the competition to achieve constant real-time performance, or leave a client's weight constant and allow a client's performance to proportionally improve and/or degrade as clients come and go. (For a complete solution see <ref> [13] </ref>.) In the former case, one can ensure constant real-time performance so long as the set of active clients requiring constant performance do not cumulatively request shares of the processor greater than 1.0 (i.e., so long as these clients do not over utilize the processor).
Reference: [14] <author> R. </author> <title> Tijdeman, "The Chairmain Assignment Problem", </title> <journal> Discrete Mathematics, </journal> <volume> vol. 32, </volume> <year> 1980, </year> <pages> pp. 323-330. </pages>
Reference-contexts: In particular, we demonstrate how "traditional" real-time processes such as periodic tasks can be realized in a proportional share system. 2 Related Work Tijdeman was one of the first to formulate and analyze the proportional share allocation problem <ref> [14] </ref>. The original problem was stated in terms of selecting a union chairman every year, such that the accumulated number of chairmen from each state (of the union) to be proportional to its weight.
Reference: [15] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> "Lottery Scheduling: Flexible Proportional-Share Resource Management," </title> <booktitle> Proc. of the First Symposium on Operating System Design and Implementation, </booktitle> <month> November </month> <year> 1994, </year> <pages> pp. 1-12. </pages>
Reference-contexts: This simplifies the implementation and eliminates the need of keeping an event queue. It is worth to mention that unlike other previous approximations [5], ours gurantees optimal lag bounds. Besides the class of fair queuing algorithms, recently, a significant number of other proportional share algorithms have been developed <ref> [1, 8, 11, 15] </ref>. Although none of them guarantees constant lag bounds in a dynamic system, we note that the PD algorithm of Baruah, Gehrke, and Plaxton [1] achieves constant lag bounds in a static system.
Reference: [16] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> "Stride Scheduling: Deterministic Proportional Share Resource Menagement," </title> <type> Technical Memorandum, </type> <institution> MIT/LCS/TM-528, Laboratory for CS, MIT, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Our algorithm is closely related to weighted fair queueing algorithms previously developed for bandwidth allocation in communication networks [4, 5, 9], and general purpose proportional share algorithms, such stride scheduling <ref> [16, 17] </ref>. De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments [4]. <p> Finally, we note that all the dynamic operations, such as a client leaving or joining the competition, can be implemented in O (log n) time in both PFQ and SCFQ. Recently, Waldspurger and Weihl have developed a new proportional share allocation algorithm, called stride scheduling <ref> [16, 17] </ref>, which can be viewed as a cross-application of fair queueing to the domain of processor scheduling. Stride scheduling relies on the concept of global pass (which is similar to virtual time) to measure the work progress in the system. <p> The only previous known algorithms that address this problem are lottery and stride scheduling <ref> [16, 17] </ref>. However, the lag bounds guaranteed by stride scheduling are as large as O (n), where n represents the number of active clients (being a randomized algorithm, lottery does not guarantee tight bounds). In comparison, EEVDF guarantees optimal lag bounds of one time quantum. <p> The idea to apply fair queueing algorithms to processor scheduling was first suggested by Parekh in [10]. Waldspurger and Weihl were the first to actually develop and implement such an algorithm (stride scheduling) for processor scheduling <ref> [16, 17] </ref>. 4 Finally, to our best knowledge we are the first to implement and to test with a proportional share scheduler which guarantees constant lag bounds. 4 We note that they have also applied stride scheduling to other shared resources, such as lock access. 3 The Model We consider an <p> In this case, the request duration (length) is either specified by the client, or otherwise the scheduler assumes a "default" duration. This allows us to treat all continuous media, interactive, and batch activities in a consistent way. 7 We note that Waldspurger and Weihl <ref> [16, 17] </ref> use a similar concept (denoted global pass) in their stride scheduling. compare our approach with the ideal, we must be able to compute the service time that a client should receive in the fluid-flow system.
Reference: [17] <author> C. A. Waldspurger. </author> <title> "Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management," </title> <type> PhD Thesis, Technical Report, </type> <institution> MIT/LCS/TR-667, Laboratory for CS, MIT, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Our algorithm is closely related to weighted fair queueing algorithms previously developed for bandwidth allocation in communication networks [4, 5, 9], and general purpose proportional share algorithms, such stride scheduling <ref> [16, 17] </ref>. De-mers, Keshav, and Shenker were the first to apply the notion of fairness to a fluid-flow system that models an idealized communication switch in which sessions are serviced in arbitrarily small increments [4]. <p> We note that this translates into an O (1) bound for the positive lag. However, as shown in <ref> [3, 12, 17] </ref>, the bound for the negative lag can be as large as O (n), where n represents the number of active sessions (clients) in the system. <p> Finally, we note that all the dynamic operations, such as a client leaving or joining the competition, can be implemented in O (log n) time in both PFQ and SCFQ. Recently, Waldspurger and Weihl have developed a new proportional share allocation algorithm, called stride scheduling <ref> [16, 17] </ref>, which can be viewed as a cross-application of fair queueing to the domain of processor scheduling. Stride scheduling relies on the concept of global pass (which is similar to virtual time) to measure the work progress in the system. <p> The only previous known algorithms that address this problem are lottery and stride scheduling <ref> [16, 17] </ref>. However, the lag bounds guaranteed by stride scheduling are as large as O (n), where n represents the number of active clients (being a randomized algorithm, lottery does not guarantee tight bounds). In comparison, EEVDF guarantees optimal lag bounds of one time quantum. <p> The idea to apply fair queueing algorithms to processor scheduling was first suggested by Parekh in [10]. Waldspurger and Weihl were the first to actually develop and implement such an algorithm (stride scheduling) for processor scheduling <ref> [16, 17] </ref>. 4 Finally, to our best knowledge we are the first to implement and to test with a proportional share scheduler which guarantees constant lag bounds. 4 We note that they have also applied stride scheduling to other shared resources, such as lock access. 3 The Model We consider an <p> In this case, the request duration (length) is either specified by the client, or otherwise the scheduler assumes a "default" duration. This allows us to treat all continuous media, interactive, and batch activities in a consistent way. 7 We note that Waldspurger and Weihl <ref> [16, 17] </ref> use a similar concept (denoted global pass) in their stride scheduling. compare our approach with the ideal, we must be able to compute the service time that a client should receive in the fluid-flow system.
Reference: [18] <author> L. Zhang, "VirtualClock: </author> <title> A New Traffic Control Algo rithm for Packet-Switched Networks", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, no. 2, </volume> <month> May </month> <year> 1991, </year> <pages> pp. 101 124. </pages>
Reference-contexts: By using the concept of virtual time, previously introduced by Zhang <ref> [18] </ref>, Parekh and Gallager have analyzed the PFQ 2 algorithm when the input traffic stream conforms to the leaky-bucket constraints [9, 10]. <p> In this way a client could trade between the allocation accuracy and scheduling overhead. We formulate our scheduling algorithm in terms of the behavior of an ideal, fluid-flow system that executes clients in a virtual-time time domain <ref> [18, 9] </ref>. 7 Abstractly, the virtual fluid-flow system executes each client for w i real-time time units during each virtual-time time unit.
References-found: 18

