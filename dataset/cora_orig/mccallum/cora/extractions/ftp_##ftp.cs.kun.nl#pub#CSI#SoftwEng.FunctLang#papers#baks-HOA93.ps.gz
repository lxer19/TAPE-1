URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-HOA93.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: steffen@cs.kun.nl  maribel@lri.fr  
Phone: 2  
Title: Strong Normalization of Typeable Rewrite Systems  
Author: Steffen van Bakel fl Maribel Fernandez 
Address: Toernooiveld 1, 6525 ED Nijmegen, Nederland.  91405 Orsay Cedex, France.  
Affiliation: 1 Afdeling Informatica, Universiteit Nijmegen,  LRI B^at. 490, CNRS Universite de Paris-Sud,  
Abstract: This paper studies termination properties of rewrite systems that are typeable using intersection types. It introduces a notion of partial type assignment on Curryfied Term Rewrite Systems, that consists of assigning intersection types to function symbols, and specifying the way in which types can be assigned to nodes and edges between nodes in the tree representation of terms. Two operations on types are specified that are used to define type assignment on terms and rewrite rules, and are proven to be sound on both terms and rewrite rules. Using a more liberal approach to recursion, a general scheme for recursive definitions is presented, that generalizes primitive recursion, but has full Turing-machine computational power. It will be proved that, for all systems that satisfy this scheme, every typeable term is strongly normalizable.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. van Bakel. </author> <title> Complete restrictions of the Intersection Type Discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 135-163, </pages> <year> 1992. </year>
Reference-contexts: Moreover, the set of terms having a head-normal form, the set of terms having a normal form, and the set of strongly normalizable terms can all be characterized by the set of assignable types. Because of this power, type assignment in this system is undecidable. In <ref> [1] </ref> a system is studied that is a variant of the BCD-system: also in this system type assignment is undecidable. That paper also contains a proof, using a Computability Predicate [22], of the statement that all typeable terms are strongly normalizable; also the converse holds. <p> In Sect. 3 we introduce the general scheme and we prove that typeable systems satisfying this scheme are strongly normalizing on typeable terms. Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC [8], and refer to the papers [9], <ref> [1] </ref>, and [3] for an overview of intersection type assignment. For full definitions of rewrite systems we refer to [18] and [12]. <p> This means that the characterization of strongly normalizable terms and strongly normalizing CTRS can not be based on type conditions only, as it is possible for LC (see <ref> [1] </ref>). In this section we analyze the relations between typeability and strong normalization in CTRS. First we show the relation between strong normalization in CTRS and normalization in ` " ; however, since the property we are characterizing is non-decidable, the condition we obtain is non-decidable as well.
Reference: [2] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting Systems. </title> <type> Technical Report 92-03, </type> <institution> Department of Computer Science, University of Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: For example, type assignment in TRS in general does not satisfy the subject reduction property, i.e. types are not preserved under rewriting, as illustrated in [4]. Also, as argued in <ref> [2] </ref>, not every notion of type assignment for LC can be used for TRS, and vice versa. To study the problem of termination a notion of types can be of significant value. <p> It differs from ours in that function symbols are strongly-typed with sorts only, whereas we allow for types to contain type-variables as well, and in this way we can model polymorphism (by allowing for the replacement of type-variables in types by other types). In [4] and <ref> [2] </ref> two partial intersection type assignment systems for ATRS are presented. Apart from the difference in the syntactic definition, the system we present here is a restriction of the first one, mainly because we do not consider the type-constant !. <p> Unless stated otherwise, if 1 " " n is used to denote a type, then by convention all 1 ; : : :; n are assumed to be strict. Notice that T ! is a proper subset of T " . The notion of type assignment as presented in <ref> [2] </ref> is a (decidable) restriction of the one presented in this paper (and of the one presented in [4]). <p> However, if we restrict the system as in <ref> [2] </ref>, then typeability is decidable, and since the Strong Normalization Theorem we proved in Section 3.2 is still valid in this weaker system, any typeable CTRS satisfying the general scheme (as given in Def.3.2.2) is terminating on typeable terms.
Reference: [3] <author> S. van Bakel. </author> <title> Essential Intersection Type Assignment. </title> <editor> In R.K. Shyamasunda, editor, </editor> <booktitle> Proceedings of FST&TCS '93. 13 th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <volume> LNCS 761, </volume> <pages> pages 13-23, </pages> <address> Bombay, India, </address> <year> 1993. </year>
Reference-contexts: In Sect. 3 we introduce the general scheme and we prove that typeable systems satisfying this scheme are strongly normalizing on typeable terms. Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC [8], and refer to the papers [9], [1], and <ref> [3] </ref> for an overview of intersection type assignment. For full definitions of rewrite systems we refer to [18] and [12]. <p> Notice that if n = 0, then fB 1 , : : : , B n g = ;. 6 2.1 Operations on pairs In this subsection we present two different operations on pairs of hbasis, typei, namely substitution and expansion, that are variants of similar definitions given in <ref> [4, 5, 3] </ref>. The operation of substitution deals with the replacement of type-variables by types and is the one normally used. The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in [10, 21].
Reference: [4] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment in Applicative Term Rewriting Systems. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of TLCA '93. International Conference on Typed Lambda Calculi and Applications, </booktitle> <volume> LNCS 664, </volume> <pages> pages 29-44, </pages> <address> Utrecht, the Netherlands, </address> <year> 1993. </year>
Reference-contexts: For example, type assignment in TRS in general does not satisfy the subject reduction property, i.e. types are not preserved under rewriting, as illustrated in <ref> [4] </ref>. Also, as argued in [2], not every notion of type assignment for LC can be used for TRS, and vice versa. To study the problem of termination a notion of types can be of significant value. <p> CTRS are defined as a slight extension of the first order TRS defined in [12], in that functional types are allowed. They are restrictions of the Applicative TRS (ATRS) as defined in <ref> [4] </ref>, in that the role of Ap in the left-hand side is restricted further. In the past the role of types in TRS has been studied within the framework of first-order sorted rewrite systems [12], as used in the underlying model for the language OBJ (see e.g. [14]). <p> It differs from ours in that function symbols are strongly-typed with sorts only, whereas we allow for types to contain type-variables as well, and in this way we can model polymorphism (by allowing for the replacement of type-variables in types by other types). In <ref> [4] </ref> and [2] two partial intersection type assignment systems for ATRS are presented. Apart from the difference in the syntactic definition, the system we present here is a restriction of the first one, mainly because we do not consider the type-constant !. <p> For full definitions of rewrite systems we refer to [18] and [12]. Typeability of lambda terms in the system as presented in <ref> [4] </ref> is denoted in this paper by the symbol ` " , and by ` "! typeability in the system that is obtained from that one by removing the type-constant ! completely. <p> fact combinatory complete: every lambda term can be translated into a term in ACL; for details of such a translation, see [8, 13]. 2 Type assignment in CTRS The set of types that will be used in the remainder of this paper is a subset of the one used in <ref> [4] </ref>: since we are going to use types to study strong normalization, we will not consider the type constant !. This means that the system we present here is a subsystem of that of [4], and, in particular, no properties proved there are automatically `inherited'. <p> be used in the remainder of this paper is a subset of the one used in <ref> [4] </ref>: since we are going to use types to study strong normalization, we will not consider the type constant !. This means that the system we present here is a subsystem of that of [4], and, in particular, no properties proved there are automatically `inherited'. <p> Notice that T ! is a proper subset of T " . The notion of type assignment as presented in [2] is a (decidable) restriction of the one presented in this paper (and of the one presented in <ref> [4] </ref>). Decidability is, in that paper, achieved by limiting the structure of types, by requiring that in 1 " " n !t , the types 1 ; : : : ; n do not contain intersections. <p> Notice that if n = 0, then fB 1 , : : : , B n g = ;. 6 2.1 Operations on pairs In this subsection we present two different operations on pairs of hbasis, typei, namely substitution and expansion, that are variants of similar definitions given in <ref> [4, 5, 3] </ref>. The operation of substitution deals with the replacement of type-variables by types and is the one normally used. The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in [10, 21]. <p> The subject reduction property for this notion of reduction is: If B ` E t:, and t can be rewritten to t 0 , then B ` E t 0 :. To ensure the subject reduction property, as in <ref> [4] </ref>, type assignment on rewrite rules will be defined using the notion of principal pair for a typeable term. Definition 2.2.6 Let t 2 T (F; X ). <p> Since by part (i.b) of Def.2.2.7 all occurrences of the defined symbol in a rewrite rule are typed with the same type, type assignment of rewrite rules is actually defined using Milner's way of dealing with recursion [19]. Using the same technique as in <ref> [4] </ref>, it is possible to show that subject reduction holds. Theorem 2.2.8 Subject Reduction Theorem.
Reference: [5] <author> S. van Bakel. </author> <title> Principal type schemes for the Strict Type Assignment System. </title> <journal> Logic and Computation, </journal> <volume> 3(6) </volume> <pages> 643-670, </pages> <year> 1993. </year>
Reference-contexts: Notice that if n = 0, then fB 1 , : : : , B n g = ;. 6 2.1 Operations on pairs In this subsection we present two different operations on pairs of hbasis, typei, namely substitution and expansion, that are variants of similar definitions given in <ref> [4, 5, 3] </ref>. The operation of substitution deals with the replacement of type-variables by types and is the one normally used. The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in [10, 21].
Reference: [6] <author> F. Barbanera and M. Fernandez. </author> <title> Combining first and higher order rewrite systems with type assignment systems. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of TLCA '93. International 17 Conference on Typed Lambda Calculi and Applications, </booktitle> <volume> LNCS 664, </volume> <pages> pages 60-74, </pages> <address> Utrecht, the Netherlands, </address> <year> 1993. </year>
Reference-contexts: In fact, the approach we take here is very much the same as the one taken by Hindley in [16], where he defines the principal Curry-type scheme of an object in Combinatory Logic. Even this notion of type assignment could be regarded as a partial one. 2 In <ref> [6] </ref> another partial type assignment system for higher-order rewrite systems that uses intersection types is defined. <p> This kind of recursive definition was presented by Jouannaud and Okada in [17] for the incremental definition of higher order functionals based on first order definitions, so that the whole system is terminating. The general scheme of [17] was also used in <ref> [6] </ref> and [7] for defining higher order functions compatible with different lambda calculi. We will prove (using the well-known method of Computability Predicates [15], [22]) that for all typeable CTRS satisfying this scheme, every typeable term is strongly normalizable. In Sect. 1 we define CTRS. <p> This scheme for definitions is inspired by [17] where generalized primitive recursive definitions were shown strongly normalizing when combined with typed LC. The same results were shown in <ref> [6] </ref> in the context of type assignment systems for LC and in [7] for typed LC of order !.
Reference: [7] <author> F. Barbanera and M. Fernandez. </author> <title> Modularity of Termination and Confluence in Combinations of Rewrite Systems with ! . In A. </title> <editor> Lingas, R. Karlsson, and S. Carlsson, editors, </editor> <booktitle> Proceedings of ICALP '93. 20 th International Colloquium on Automata, Languages and Programming, </booktitle> <volume> LNCS 700, </volume> <pages> pages 657-668, </pages> <institution> Lund, Sweden, </institution> <year> 1993. </year>
Reference-contexts: This kind of recursive definition was presented by Jouannaud and Okada in [17] for the incremental definition of higher order functionals based on first order definitions, so that the whole system is terminating. The general scheme of [17] was also used in [6] and <ref> [7] </ref> for defining higher order functions compatible with different lambda calculi. We will prove (using the well-known method of Computability Predicates [15], [22]) that for all typeable CTRS satisfying this scheme, every typeable term is strongly normalizable. In Sect. 1 we define CTRS. <p> This scheme for definitions is inspired by [17] where generalized primitive recursive definitions were shown strongly normalizing when combined with typed LC. The same results were shown in [6] in the context of type assignment systems for LC and in <ref> [7] </ref> for typed LC of order !.
Reference: [8] <author> H. Barendregt. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: The type assignment system is presented in Sect. 2. In Sect. 3 we introduce the general scheme and we prove that typeable systems satisfying this scheme are strongly normalizing on typeable terms. Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC <ref> [8] </ref>, and refer to the papers [9], [1], and [3] for an overview of intersection type assignment. For full definitions of rewrite systems we refer to [18] and [12]. <p> R contains the rewrite rules 5 S (x; y; z) ! Ap (Ap (x; z); Ap (y; z)) I (x) ! x Because ACL is Curry-closed, it is in fact combinatory complete: every lambda term can be translated into a term in ACL; for details of such a translation, see <ref> [8, 13] </ref>. 2 Type assignment in CTRS The set of types that will be used in the remainder of this paper is a subset of the one used in [4]: since we are going to use types to study strong normalization, we will not consider the type constant !.
Reference: [9] <author> H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: In <ref> [9] </ref> the Intersection Type Discipline (the BCD-system) for LC is presented, which is a very powerful extension of Curry's system: it is closed under fi-equality. <p> In Sect. 3 we introduce the general scheme and we prove that typeable systems satisfying this scheme are strongly normalizing on typeable terms. Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC [8], and refer to the papers <ref> [9] </ref>, [1], and [3] for an overview of intersection type assignment. For full definitions of rewrite systems we refer to [18] and [12].
Reference: [10] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and -calculus semantics. </title> <editor> In J.R. Hindley and J.P. Seldin, editors, </editor> <booktitle> To H.B. Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: The operation of substitution deals with the replacement of type-variables by types and is the one normally used. The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in <ref> [10, 21] </ref>.
Reference: [11] <author> H.B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: To study the problem of termination a notion of types can be of significant value. For LC, there exists a well understood and well defined notion of type assignment, known as the Curry Type Assignment System <ref> [11] </ref> which expresses abstraction and application, and it can be shown that, for this notion of type assignment, all typeable terms are strongly normalizable. fl Supported by the Netherlands Organisation for the advancement of pure research (N.W.O.). 1 Curry's system forms the basis for a number of notions of type assignment
Reference: [12] <author> N. Dershowitz and J.P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 6, </booktitle> <pages> pages 245-320. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: For this purpose, we introduce a notion of type assignment on Curryfied TRS (CTRS) that uses intersection types. CTRS are defined as a slight extension of the first order TRS defined in <ref> [12] </ref>, in that functional types are allowed. They are restrictions of the Applicative TRS (ATRS) as defined in [4], in that the role of Ap in the left-hand side is restricted further. <p> They are restrictions of the Applicative TRS (ATRS) as defined in [4], in that the role of Ap in the left-hand side is restricted further. In the past the role of types in TRS has been studied within the framework of first-order sorted rewrite systems <ref> [12] </ref>, as used in the underlying model for the language OBJ (see e.g. [14]). <p> Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC [8], and refer to the papers [9], [1], and [3] for an overview of intersection type assignment. For full definitions of rewrite systems we refer to [18] and <ref> [12] </ref>. Typeability of lambda terms in the system as presented in [4] is denoted in this paper by the symbol ` " , and by ` "! typeability in the system that is obtained from that one by removing the type-constant ! completely. <p> [B ` " M : & 6= !] () M has a head normal form. iv) 9 B, [B ` "! M :] () M is strongly normalizable. 1.1 Curryfied Term Rewriting Systems In this subsection we will present Curryfied Term Rewriting Systems as an extension of first-order TRS ([18], <ref> [12] </ref>) that allow partial application of function symbols. <p> When R is computable, then by Prop. C1 every t in the image of R is strongly normalizable, so ! R is well-founded on the image of R. Also, because the union of the strict subterm relationship with a terminating rewrite relation is well-founded <ref> [12] </ref>, the relation (! R [ &gt;) mul is well-founded on fRg. Hence, when restricted to computable replacements, is a well-founded ordering. We use n when we want to indicate that the nth element of the triple has decreased but not the n-1 first ones.
Reference: [13] <author> M. Dezani-Ciancaglini and J.R. Hindley. </author> <title> Intersection types for combinatory logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 100 </volume> <pages> 303-324, </pages> <year> 1992. </year>
Reference-contexts: R contains the rewrite rules 5 S (x; y; z) ! Ap (Ap (x; z); Ap (y; z)) I (x) ! x Because ACL is Curry-closed, it is in fact combinatory complete: every lambda term can be translated into a term in ACL; for details of such a translation, see <ref> [8, 13] </ref>. 2 Type assignment in CTRS The set of types that will be used in the remainder of this paper is a subset of the one used in [4]: since we are going to use types to study strong normalization, we will not consider the type constant !.
Reference: [14] <author> K. Futatsugi, J. Goguen, J.P. Jouannaud, and J. Meseguer. </author> <booktitle> Principles of OBJ2. In Proceedings 12 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66, </pages> <year> 1985. </year>
Reference-contexts: In the past the role of types in TRS has been studied within the framework of first-order sorted rewrite systems [12], as used in the underlying model for the language OBJ (see e.g. <ref> [14] </ref>).
Reference: [15] <author> J.Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: The general scheme of [17] was also used in [6] and [7] for defining higher order functions compatible with different lambda calculi. We will prove (using the well-known method of Computability Predicates <ref> [15] </ref>, [22]) that for all typeable CTRS satisfying this scheme, every typeable term is strongly normalizable. In Sect. 1 we define CTRS. The type assignment system is presented in Sect. 2.
Reference: [16] <author> J.R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: In fact, the approach we take here is very much the same as the one taken by Hindley in <ref> [16] </ref>, where he defines the principal Curry-type scheme of an object in Combinatory Logic. Even this notion of type assignment could be regarded as a partial one. 2 In [6] another partial type assignment system for higher-order rewrite systems that uses intersection types is defined.
Reference: [17] <author> J.P. Jouannaud and M. Okada. </author> <title> Executable higher-order algebraic specification languages. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 350-361, </pages> <year> 1991. </year>
Reference-contexts: In order to ensure strong normalization of typeable terms in CTRS we will impose some syntactical restrictions on the rewrite rules: we will present a general scheme for recursive definitions that generalizes primitive recursion. This kind of recursive definition was presented by Jouannaud and Okada in <ref> [17] </ref> for the incremental definition of higher order functionals based on first order definitions, so that the whole system is terminating. The general scheme of [17] was also used in [6] and [7] for defining higher order functions compatible with different lambda calculi. <p> This kind of recursive definition was presented by Jouannaud and Okada in <ref> [17] </ref> for the incremental definition of higher order functionals based on first order definitions, so that the whole system is terminating. The general scheme of [17] was also used in [6] and [7] for defining higher order functions compatible with different lambda calculi. We will prove (using the well-known method of Computability Predicates [15], [22]) that for all typeable CTRS satisfying this scheme, every typeable term is strongly normalizable. In Sect. 1 we define CTRS. <p> From a practical point of view, a decidable, sufficient (but not necessary) condition is clearly better. For this reason, in the second subsection we introduce a general scheme, inspired by <ref> [17] </ref>, which imposes some syntactical restrictions on CTRS's rules so as to guarantee the strong normalization of all typeable terms. <p> However, the restriction to non-recursive systems is too strong indeed. In the following we will show that there is class of recursive functions that are safe: generalized primitive recursive functions satisfying the general scheme below. This scheme for definitions is inspired by <ref> [17] </ref> where generalized primitive recursive definitions were shown strongly normalizing when combined with typed LC. The same results were shown in [6] in the context of type assignment systems for LC and in [7] for typed LC of order !.
Reference: [18] <author> J.W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, Dov.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Clarendon Press, </publisher> <year> 1992. </year>
Reference-contexts: Section 4 contains the conclusions. 1 Preliminaries We assume the reader to be familiar with LC [8], and refer to the papers [9], [1], and [3] for an overview of intersection type assignment. For full definitions of rewrite systems we refer to <ref> [18] </ref> and [12]. Typeability of lambda terms in the system as presented in [4] is denoted in this paper by the symbol ` " , and by ` "! typeability in the system that is obtained from that one by removing the type-constant ! completely.
Reference: [19] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Introduction Most functional programming languages, like Miranda [23] or ML <ref> [19] </ref> for instance, although implemented through an extended Lambda Calculus (LC) or a combinator system, allow programmers to specify an algorithm (function) as a set of equations using pattern-matching, i.e. the formal parameter of a function is allowed to have structure. <p> Since by part (i.b) of Def.2.2.7 all occurrences of the defined symbol in a rewrite rule are typed with the same type, type assignment of rewrite rules is actually defined using Milner's way of dealing with recursion <ref> [19] </ref>. Using the same technique as in [4], it is possible to show that subject reduction holds. Theorem 2.2.8 Subject Reduction Theorem.
Reference: [20] <author> F. Pfenning. </author> <title> Partial Polymorphic Type Inference and Higher-Order Unification. </title> <booktitle> In Proceedings of the 1988 ACM conference on LISP and Functional Programming Languages, </booktitle> <pages> pages 153-163, </pages> <year> 1988. </year>
Reference-contexts: Our type assignment system is partial in the sense of <ref> [20] </ref>: we will assume that every function symbol already has a type (given in an environment), whose structure is usually motivated by a rewrite rule.
Reference: [21] <author> S. Ronchi della Rocca and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year>
Reference-contexts: The operation of substitution deals with the replacement of type-variables by types and is the one normally used. The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in <ref> [10, 21] </ref>.
Reference: [22] <author> W.W. Tait. </author> <title> Intensional interpretation of functional of finite types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32, </volume> <year> 1967. </year>
Reference-contexts: Because of this power, type assignment in this system is undecidable. In [1] a system is studied that is a variant of the BCD-system: also in this system type assignment is undecidable. That paper also contains a proof, using a Computability Predicate <ref> [22] </ref>, of the statement that all typeable terms are strongly normalizable; also the converse holds. In this paper we study the problem of termination of functional programs. <p> The general scheme of [17] was also used in [6] and [7] for defining higher order functions compatible with different lambda calculi. We will prove (using the well-known method of Computability Predicates [15], <ref> [22] </ref>) that for all typeable CTRS satisfying this scheme, every typeable term is strongly normalizable. In Sect. 1 we define CTRS. The type assignment system is presented in Sect. 2. <p> Theorem 3.2.1 is actually a corollary of the Strong Normalization Theorem (Thm.3.2.9). To prove this theorem, we will use the well-known method of Computability Predicates ([15], <ref> [22] </ref>). The proof will have two parts; in the first one we give the definition of a predicate Comp on bases, terms, and types, and prove some properties of Comp.
Reference: [23] <author> D.A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the conference on Functional Programming Languages and Computer Architecture, </booktitle> <volume> LNCS 201, </volume> <pages> pages 1-16. 18 </pages>
Reference-contexts: Introduction Most functional programming languages, like Miranda <ref> [23] </ref> or ML [19] for instance, although implemented through an extended Lambda Calculus (LC) or a combinator system, allow programmers to specify an algorithm (function) as a set of equations using pattern-matching, i.e. the formal parameter of a function is allowed to have structure.
References-found: 23

