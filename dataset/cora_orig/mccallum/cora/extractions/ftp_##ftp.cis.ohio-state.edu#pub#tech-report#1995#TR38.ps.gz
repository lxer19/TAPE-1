URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR38.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-engineer.html
Root-URL: 
Email: E-Mail: edwards@cis.ohio-state.edu  
Phone: Phone: (614) 292-5841  
Title: Representation Inheritance: A Safe Form of "White Box" Code Inheritance  
Author: Stephen H. Edwards 
Note: Copyright c 1995 by the author. All rights reserved.  
Date: September, 1995  
Web: URL: http://www.cis.ohio-state.edu/~edwards  
Address: 2015 Neil Avenue Columbus, Ohio 43210-1277  
Affiliation: Dept. of Computer and Information Science The Ohio State University 395 Dreese Lab  
Abstract-found: 0
Intro-found: 1
Reference: [BHKW94] <author> Paolo Bucci, Joseph E. Hollingsworth, Joan Krone, and Bruce W. Weide. </author> <title> Implementing components in RESOLVE. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In formalist terms, the assumptions that a class implementation depends on consist of two parts: the representation invariant and the abstraction function (or, more properly, abstraction relation <ref> [BHKW94, Lea89] </ref>). The representation invariant captures assumptions or programming conventions about the way information is recorded in the component's representation [LG86, pp. 72-74]. For example, the implementation of Two Way List described in Section 2 relies on several conventions: 1. <p> The "right" portion of the list begins with the node in the chain immediately following the one pointed to by pre fence (i.e., `pre fence-&gt;next'). Some languages also provide syntactic slots for expressing abstraction functions or relations <ref> [BHKW94] </ref>, [LG86]. The above statements of the representation invariant and the abstraction function are informal, but they capture critical information that is necessary for the correct functioning of the Two Way List methods.
Reference: [Edw93] <author> Stephen H. Edwards. </author> <title> Inheritance: One mechanism, many conflicting uses. </title> <editor> In Larry Latour, editor, </editor> <booktitle> Proceedings of the Sixth Annual Workshop on Software Reuse, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Failing to differentiate the various uses of inheritance, however, can complicate life for both component clients and component implementers difficult <ref> [Edw93] </ref>. To address the problems of clients, the "Liskov Substitutability Principle" (LSP) has been proposed as the appropriate meaning for subtyping, and thus for publicly visible inheritance relationships, in modern object-oriented (OO) languages [LW94].
Reference: [Hol94] <institution> Joseph Hollingsworth. Indiana University, </institution> <type> personal communication, </type> <year> 1994. </year>
Reference-contexts: Because of the subsequent notable reduction in bugs in student programs, he refers to such sentinels as "smart" nodes <ref> [Hol94] </ref>. 3 template &lt;class Item&gt; class Two Way List f // The same external declarations as in Figure 3 // ... private: // The representation of the class: struct TWL Node f Item i; TWL Nodefl next; TWL Nodefl previous; g; TWL Nodefl pre front; TWL Nodefl pre fence; // A
Reference: [LaL89] <author> Wilf R. LaLonde. </author> <title> Designing families of data types using exemplars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 212-248, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Inheritance as a programming language mechanism can be used to achieve several different goals, both in terms of expressing relationships between components and in terms of defining new components "by difference" from existing ones <ref> [LaL89] </ref>. Failing to differentiate the various uses of inheritance, however, can complicate life for both component clients and component implementers difficult [Edw93].
Reference: [Lea89] <author> Gary T. Leavens. </author> <title> Verifying Object-Oriented Programs That Use Subtypes. </title> <type> PhD thesis, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: In formalist terms, the assumptions that a class implementation depends on consist of two parts: the representation invariant and the abstraction function (or, more properly, abstraction relation <ref> [BHKW94, Lea89] </ref>). The representation invariant captures assumptions or programming conventions about the way information is recorded in the component's representation [LG86, pp. 72-74]. For example, the implementation of Two Way List described in Section 2 relies on several conventions: 1. <p> The work of Liskov and Wing in defining the subtype relation so that it preserves behavioral abstraction typifies this work [LW93, LW94]. In a similar vein, Gary Leavens describes a foundation for the modular verification of OO software built around interpreting inheritance as a behavioral abstraction <ref> [Lea89, LW95] </ref>. These approaches address the client-side reasoning issues posed by inheritance mechanisms, however, and do not directly address code inheritance. The safety problems with white box code reuse have been described by S. Muralidharan and Bruce Weide [MW90].
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Electrical Engineering and Computer Science Series. MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: In formalist terms, the assumptions that a class implementation depends on consist of two parts: the representation invariant and the abstraction function (or, more properly, abstraction relation [BHKW94, Lea89]). The representation invariant captures assumptions or programming conventions about the way information is recorded in the component's representation <ref> [LG86, pp. 72-74] </ref>. For example, the implementation of Two Way List described in Section 2 relies on several conventions: 1. The TWL Nodes within a Two Way List are doubly-connected in a single chain. 2. The pre front and pre fence pointers refer to nodes within the same chain. 3. <p> The pre front pointer always refers to the sentinel node at the beginning of the chain. 7 These conventions are stated informally here, but they could be easily formalized. Some languages, such as RESOLVE [W + 94], CLU <ref> [LG86] </ref>, and Eiffel [Mey88], even provide syntactic slots for expressing representation invariants. The abstraction function then relates representation values to the corresponding conceptual values they realize [LG86, pp. 70-71]. <p> Some languages, such as RESOLVE [W + 94], CLU [LG86], and Eiffel [Mey88], even provide syntactic slots for expressing representation invariants. The abstraction function then relates representation values to the corresponding conceptual values they realize <ref> [LG86, pp. 70-71] </ref>. It captures the intentions the implementer had in mind about the "meaning" of the representation|how it encodes the conceptual state that clients reason about. Informally, the doubly-linked chain representation of two-way lists is related to the conceptual model described in Section 2 as follows: 1. <p> The "right" portion of the list begins with the node in the chain immediately following the one pointed to by pre fence (i.e., `pre fence-&gt;next'). Some languages also provide syntactic slots for expressing abstraction functions or relations [BHKW94], <ref> [LG86] </ref>. The above statements of the representation invariant and the abstraction function are informal, but they capture critical information that is necessary for the correct functioning of the Two Way List methods. <p> In practice, however, programmers try to capture as much of the intended specification as is reasonable within the assertions the language does support, resulting in conflicting goals. Eiffel's invariant assertions typify this conflict; they must serve double-duty: 1. They should capture the abstract invariant <ref> [LG86, p. 92] </ref>, which defines client-visible constraints on an object's conceptual value. 2. They should also capture the representation invariant, which defines constraints on an object's internal state that is invisible to clients.
Reference: [LW93] <author> Barbara H. Liskov and Jeannette M. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP'93|Object-Oriented Programming, 7th European Conference, volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pages 118-141, </pages> <address> New York, NY, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The work of Liskov and Wing in defining the subtype relation so that it preserves behavioral abstraction typifies this work <ref> [LW93, LW94] </ref>. In a similar vein, Gary Leavens describes a foundation for the modular verification of OO software built around interpreting inheritance as a behavioral abstraction [Lea89, LW95]. These approaches address the client-side reasoning issues posed by inheritance mechanisms, however, and do not directly address code inheritance.
Reference: [LW94] <author> Barbara H. Liskov and Jeannette M. Wing. </author> <title> A behavioral notion of subtyp-ing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: To address the problems of clients, the "Liskov Substitutability Principle" (LSP) has been proposed as the appropriate meaning for subtyping, and thus for publicly visible inheritance relationships, in modern object-oriented (OO) languages <ref> [LW94] </ref>. Informally, the LSP requires that for one class to be a "subtype" of another, it must respect all of the externally visible behavioral commitments of its superclass. <p> The work of Liskov and Wing in defining the subtype relation so that it preserves behavioral abstraction typifies this work <ref> [LW93, LW94] </ref>. In a similar vein, Gary Leavens describes a foundation for the modular verification of OO software built around interpreting inheritance as a behavioral abstraction [Lea89, LW95]. These approaches address the client-side reasoning issues posed by inheritance mechanisms, however, and do not directly address code inheritance.
Reference: [LW95] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <note> to appear 1995. </note>
Reference-contexts: The work of Liskov and Wing in defining the subtype relation so that it preserves behavioral abstraction typifies this work [LW93, LW94]. In a similar vein, Gary Leavens describes a foundation for the modular verification of OO software built around interpreting inheritance as a behavioral abstraction <ref> [Lea89, LW95] </ref>. These approaches address the client-side reasoning issues posed by inheritance mechanisms, however, and do not directly address code inheritance. The safety problems with white box code reuse have been described by S. Muralidharan and Bruce Weide [MW90]. <p> Unfortunately, it is expensive to check these properties at run-time, perhaps prohibitively. As a result, facets of the component's representation invariant may be ignored by component designers when writing Eiffel assertions. Finally, the lack of separate specifications in Eiffel ensures that abstraction functions (or simulation relations <ref> [LW95] </ref>) will not be captured. In the Two Way List example, the assumption that the pre fence points to the node before the first item in the right half of the conceptual value of the list cannot be captured in an Eiffel invariant clause.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: The potential for leveraging inheritance for code reuse in this sense originally was advocated as one of the primary reuse benefits of OO techniques <ref> [Mey88, pp. 33-34, 270] </ref>. This is sometimes termed code inheritance, to distinguish it from specification inheritance, where subclasses are intended to inherit the behavioral specification of their superclass (es). <p> The pre front pointer always refers to the sentinel node at the beginning of the chain. 7 These conventions are stated informally here, but they could be easily formalized. Some languages, such as RESOLVE [W + 94], CLU [LG86], and Eiffel <ref> [Mey88] </ref>, even provide syntactic slots for expressing representation invariants. The abstraction function then relates representation values to the corresponding conceptual values they realize [LG86, pp. 70-71]. It captures the intentions the implementer had in mind about the "meaning" of the representation|how it encodes the conceptual state that clients reason about. <p> They note the efficiency concerns that make white box techniques desirable, but concentrate on clearly delineating the disadvantages that come with breaking encapsulation. Muralidharan and Weide propose no solutions to the problem. Perhaps the most well-known work that attempts to address the problems discussed here is Bertrand Meyer's Eiffel <ref> [Mey88] </ref>. There are several critical differences between Eiffel and the ideas described in this paper, however, which highlight the contributions of representation inheritance. <p> Unfortunately, under practical usage these mechanisms are not enough to ensure the safety that representation inheritance provides. Classes in Eiffel represent component implementations, and there is no facility for capturing the corresponding component specifications in the language <ref> [Mey88, p. 59] </ref>. As a result, the mechanisms in the language only support capturing information relevant to the implementation, and other details such as abstraction functions are not addressed.
Reference: [Mey94] <author> Bertrand Meyer. </author> <title> Reusable Software: The Base Object-Oriented Component Libraries. </title> <publisher> Prentice Hall International, </publisher> <address> Hertfordshire, UK, </address> <year> 1994. </year>
Reference-contexts: The C++ Two Way List class template in defines a generic component that is parameterized by the type of items in the list. It is similar in several respects to Bertrand Meyer's BILINEAR component <ref> [Mey94, pp. 141-146] </ref>, although Meyer's selection of primary operations and conceptual model differs in some details. Given this Two Way List declaration, we can now turn our attention to how one might implement a two-way list. <p> Of course, assertions that deal with the hidden state of objects are not helpful for client understanding, so it is common to see Eiffel invariants phrased in terms of publicly visible accessor functions <ref> [Mey94] </ref> rather than private state variables, turning them into abstract invariants. 10 In addition, the computational nature of Eiffel's assertion mechanism prevents some invariants from being expressed because they are not computable, and discourages programmers from writing down others that are expensive to check.
Reference: [MW90] <author> S. Muralidharan and Bruce W. Weide. </author> <booktitle> Should data abstraction be violated to enhance software reuse? In Proceedings of the 8th Annual National Conference on Ada Technology, </booktitle> <pages> pages 515-524, </pages> <address> Atlanta, GA, March 1990. ANCOST, </address> <publisher> Inc. </publisher>
Reference-contexts: These approaches address the client-side reasoning issues posed by inheritance mechanisms, however, and do not directly address code inheritance. The safety problems with white box code reuse have been described by S. Muralidharan and Bruce Weide <ref> [MW90] </ref>. They note the efficiency concerns that make white box techniques desirable, but concentrate on clearly delineating the disadvantages that come with breaking encapsulation. Muralidharan and Weide propose no solutions to the problem.
Reference: [PK90] <author> Dewayne E. Perry and Gail E. Kaiser. </author> <title> Adequate testing and object-oriented programming. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 2(5) </volume> <pages> 13-19, </pages> <month> Jan-uary/February </month> <year> 1990. </year>
Reference-contexts: This would actually cause inherited methods to fail, even though those methods in isolation work perfectly. Dewayne Perry and Gail Kaiser <ref> [PK90] </ref> describe requirements for adequately testing OO programs. They indicate that when subclasses are added to an inheritance hierarchy, it is necessary to retest not only the newly added methods in these subclasses, but also all of the inherited methods.
Reference: [W + 94] <author> Bruce W. Weide et al. </author> <title> Special feature: Component-based software using RESOLVE. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 21-67, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: simple formalization of this model of two-way lists is: type Two Way List is modeled by ( left : string of math [Item], right : string of math [Item] ) exemplar l initialization ensures l.left = empty string and l.right = empty string This formalization uses the notation of RESOLVE <ref> [W + 94] </ref>, although any convenient model-based specification notation could be used [Win90]. <p> The unconnected pointers on the sentinel nodes are set to NULL. 4. The pre front pointer always refers to the sentinel node at the beginning of the chain. 7 These conventions are stated informally here, but they could be easily formalized. Some languages, such as RESOLVE <ref> [W + 94] </ref>, CLU [LG86], and Eiffel [Mey88], even provide syntactic slots for expressing representation invariants. The abstraction function then relates representation values to the corresponding conceptual values they realize [LG86, pp. 70-71].
Reference: [Win90] <author> Jeannette M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 8-24, </pages> <month> September </month> <year> 1990. </year> <month> 13 </month>
Reference-contexts: List is modeled by ( left : string of math [Item], right : string of math [Item] ) exemplar l initialization ensures l.left = empty string and l.right = empty string This formalization uses the notation of RESOLVE [W + 94], although any convenient model-based specification notation could be used <ref> [Win90] </ref>.
References-found: 15

