URL: http://www.cs.wisc.edu/~fischer/zero-cost.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/
Root-URL: http://www.cs.wisc.edu
Title: Zero-cost Range Splitting  
Author: Steven M. Kurlander Charles N. Fischer 
Address: Wisconsin|Madison  
Affiliation: University of  
Abstract: This paper presents a new optimization technique that uses empty delay slots to improve code scheduling. We are able to split live ranges for free, by inserting spill code into empty delay slots. Splitting a live range can reduce interferences with other live ranges and can sometimes free registers. Live ranges no longer interfering with the split live range can sometimes make use of the extra register. Our algorithm, as a final pass over the code, exploits empty delay slots that would remain unused if spill code was not inserted. This paper proposes a variety of optimizations that use the extra registers generated from live range splitting, including coalescing live ranges and improving code scheduling. We present an algorithm for improving code scheduling and present implementation results. 
Abstract-found: 1
Intro-found: 1
Reference: [BCT92] <author> Preston Briggs, Keith D. Cooper, and Linda Torczon. </author> <title> Rematerialization. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 311-321, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Since the register allocator uses Chaitin's coloring algorithm, spilling a live range results in very short live ranges and unnecessary extra loads and stores. Briggs, Cooper, and Torczon <ref> [BCT92] </ref> associate a tag with individual values in a procedure's SSA graph. The tag indicates how a value should be spilled, as some values can be recomputed rather than saved in a temporary.
Reference: [CAC + 81] <author> Gregory J. Chaitin, Marc A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register allocation via coloring. </title> <booktitle> Computer Languages, </booktitle> <pages> pages 47-57, </pages> <year> 1981. </year>
Reference-contexts: In Figure 1, we split live range A (shown on the left-hand side), into live ranges A 0 and A 00 (shown on the right-hand side). Assuming A is unchanged (a never-killed value <ref> [CAC + 81] </ref>), we simply reload A in the delay slot shown. Live range B can now use the register assigned to A, as B's live range does not intersect with A 0 or A 00 's live range. <p> Our algorithm calls InsertLoadsStores to split a live range l, and then calls MarkWhereRegStillAllocated to determine where, after splitting l, a register is freed. 4.1 Inserting Loads and Stores Routine InsertLoadsStores splits live range l. If l is a never-killed value <ref> [CAC + 81] </ref>, we can avoid spilling to a temporary. We present the general case in which both loads and stores are needed to split l.
Reference: [CCK90] <author> David Callahan, Steve Carr, and Ken Kennedy. </author> <title> Improving register allocation for subscripted variables. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 53-64, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Loop unrolling, software pipelining, scalar replacement <ref> [CCK90] </ref>, code inlining, and interprocedural register allocation [Wal86] [Cho88] [SO90], significantly increase the demand for registers. A greater competition for registers can lead to an increase in register spilling and false register dependencies between instructions. <p> The benchmarks shown are floating-point, which we have observed to have a large number of register candidates and a large number of empty delay slots. The first two benchmarks are SPEC benchmarks and the rest have been optimized using scalar replacement <ref> [CCK90] </ref>. The third and fourth columns represent the average length of these live ranges before they were split and the average decrease in size of these live ranges afterwards. Splitting can significantly decrease the span of instructions where registers are allocated. <p> The benchmarks listed are floating-point intensive. We found floating-point benchmarks tended to have more delay slots and register candidates. The first four listed in Figure 7 are SPEC benchmarks. The scalar replacement optimization <ref> [CCK90] </ref> has been run on the latter three benchmarks. As our algorithm is a final pass over the code, these speedups are pure profit. Column speedups gives the speedup from our live range splitting algorithm and scheduler.
Reference: [CH90] <author> Fred C. Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Chaitin [Cha82] assumes all values reside in virtual registers. Chaitin then spills virtual registers until there are an equal number of virtual and real registers. Chaitin-style spilling creates very short live ranges, allowing for fewer conflicts with other live ranges. Chow and Hennessy <ref> [CH90] </ref>, in contrast, assume that all variables reside entirely in memory. If to A. a live range cannot be mapped to a single register, then loads and stores are added to generate smaller live ranges. <p> Handling live range coalescing as a final pass over the code might be done as follows. Live ranges can be represented by the basic blocks that they enclose [LH86] <ref> [CH90] </ref>. If the basic blocks where a register is freed encloses a live range that has been spilled during register allocation, the live range can sometimes be allocated the freed register and the spill code removed.
Reference: [Cha82] <author> Gregory J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: A longer live range conflicts with more live ranges than does a shorter one but costs less, as there are fewer loads and stores. Chaitin <ref> [Cha82] </ref> assumes all values reside in virtual registers. Chaitin then spills virtual registers until there are an equal number of virtual and real registers. Chaitin-style spilling creates very short live ranges, allowing for fewer conflicts with other live ranges. <p> As we observed the code generated for floating-point benchmarks tended to have more unfilled delay slots and more register candidates, we were most interested in these benchmarks. To generate code, we used the lcc compiler [FH91], with a coloring allocator <ref> [Cha82] </ref>, followed by the CSP phase of Goodman and Hsu's scheduler [GH88], as the back end. As noted in Section 4, the scheduler includes nop instructions, indicating where empty delay slots can be filled by instructions. <p> Both routines InsertLoadsStores and MarkWhereRegStillAllocated are as described in Sections 4.1 and 4.2, respectively. 5.1.1 Selecting Live Ranges The live ranges are ordered in increasing value based on the function cost degree . This function is adapted from graph coloring <ref> [Cha82] </ref>. We refer to cost as the number of instructions needed to split a live range into trivial single instruction ranges. A larger value of cost suggests more empty delay slots will be needed to insert spill code. <p> Unlike in <ref> [Cha82] </ref>, the value of a live range's degree does not change to avoid recomputing cost degree and reordering the live ranges after splitting a live range. Splitting a live range with a large degree potentially makes the register available to more live ranges.
Reference: [Cho88] <author> Fred C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-94, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Loop unrolling, software pipelining, scalar replacement [CCK90], code inlining, and interprocedural register allocation [Wal86] <ref> [Cho88] </ref> [SO90], significantly increase the demand for registers. A greater competition for registers can lead to an increase in register spilling and false register dependencies between instructions. The following is a (non-exhaustive) list of optimizations that are possible as part of a final pass over the code.
Reference: [FH91] <author> Christopher W. Fraser and David R. Han-son. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: As we observed the code generated for floating-point benchmarks tended to have more unfilled delay slots and more register candidates, we were most interested in these benchmarks. To generate code, we used the lcc compiler <ref> [FH91] </ref>, with a coloring allocator [Cha82], followed by the CSP phase of Goodman and Hsu's scheduler [GH88], as the back end. As noted in Section 4, the scheduler includes nop instructions, indicating where empty delay slots can be filled by instructions.
Reference: [GH88] <author> James R. Goodman and Wei-Chung Hsu. </author> <title> Code scheduling and register allocation in large basic blocks. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 442-452, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: To generate code, we used the lcc compiler [FH91], with a coloring allocator [Cha82], followed by the CSP phase of Goodman and Hsu's scheduler <ref> [GH88] </ref>, as the back end. As noted in Section 4, the scheduler includes nop instructions, indicating where empty delay slots can be filled by instructions. Our algorithm is a final pass over the code, intended to glean any remaining opportunities for optimizations.
Reference: [HG82] <author> John L. Hennessy and Thomas R. Gross. </author> <title> Code generation and reorganization in the presence of pipeline constraints. </title> <booktitle> In Proceedings of the 9th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 120-127, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Compiler writers use heuristics for register allocation and instruction scheduling, as both are NP-Complete [Set75] <ref> [HG82] </ref> [PS90]. Instruction scheduling tries to minimize the number of unfilled delay slots, cycles following an instruction in which its result is unavailable, by filling these slots with useful instructions. Register allocation policies almost never exploit delay slots even though register allocation and instruction scheduling are highly interdependent.
Reference: [HP90] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Simple dataflow analysis can be used to remove them. 6 Impact on the cache Cache performance benefits from temporal locality (a location will soon be referenced again) and spatial locality (if a location is referenced, nearby locations will soon be referenced) <ref> [HP90] </ref>. Entries in the current activation record are likely to exhibit temporal locality, as locals and temporaries will be rereferenced in the current activation record and exhibit spatial locality, as the activation record is contiguous. Optimizations (such as common subexpression elimination) generally allocate temporaries if it can improve the code.
Reference: [KH93] <author> Priyadarshan Kolte and Mary Jean Har-rold. </author> <title> Load/store range analysis for global register allocation. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277, </pages> <year> 1993. </year>
Reference-contexts: With additional analysis parts of the original live range can be coalesced, allowing load instructions to be removed <ref> [KH93] </ref>. Intersecting sets of basic blocks in which different registers are freed can sometimes be treated as a single set by inserting register move instructions into empty delay slots. We believe our live range splitting algorithm should be quite effective on superscalar processors, which issue multiple instructions per cycle.
Reference: [LH86] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Register allocation in the SPUR lisp compiler. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 255-263, </pages> <year> 1986. </year>
Reference-contexts: Handling live range coalescing as a final pass over the code might be done as follows. Live ranges can be represented by the basic blocks that they enclose <ref> [LH86] </ref> [CH90]. If the basic blocks where a register is freed encloses a live range that has been spilled during register allocation, the live range can sometimes be allocated the freed register and the spill code removed.
Reference: [Pin93] <author> Shlomit S. Pinter. </author> <title> Register allocation with instruction scheduling: a new approach. </title> <booktitle> In Proceedings of SIGPLAN '93 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 248-257, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Neither of these algorithms consider delay slots, however. Splitting a long live range using empty delay slots allows for the creation of shorter live ranges, (which conflict with fewer live ranges), but at the same cost as a long live range, since the spilling is free. Pinter <ref> [Pin93] </ref> proposes a parallel interference graph which includes the edges of a live range interference graph and a false dependence graph. False dependencies include anti and output-dependencies. A coloring of this graph produces code with no spills and no false register dependencies, which may limit code scheduling.
Reference: [PS90] <author> Krishna Palem and Barbara Simons. </author> <title> Scheduling time-critical instructions on RISC machines. </title> <booktitle> In Proceedings of the 17th Annual Symposium on Principals of Programming Languages, </booktitle> <pages> pages 270-280, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Compiler writers use heuristics for register allocation and instruction scheduling, as both are NP-Complete [Set75] [HG82] <ref> [PS90] </ref>. Instruction scheduling tries to minimize the number of unfilled delay slots, cycles following an instruction in which its result is unavailable, by filling these slots with useful instructions. Register allocation policies almost never exploit delay slots even though register allocation and instruction scheduling are highly interdependent.
Reference: [Set75] <author> Ravi Sethi. </author> <title> Complete register allocation problems. </title> <journal> SIAM J. Comput, </journal> <volume> 4 </volume> <pages> 226-248, </pages> <year> 1975. </year>
Reference-contexts: 1 Introduction Compiler writers use heuristics for register allocation and instruction scheduling, as both are NP-Complete <ref> [Set75] </ref> [HG82] [PS90]. Instruction scheduling tries to minimize the number of unfilled delay slots, cycles following an instruction in which its result is unavailable, by filling these slots with useful instructions. Register allocation policies almost never exploit delay slots even though register allocation and instruction scheduling are highly interdependent.
Reference: [SO90] <author> Vatsa Santhanam and Daryl Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proceedings of SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-39, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Loop unrolling, software pipelining, scalar replacement [CCK90], code inlining, and interprocedural register allocation [Wal86] [Cho88] <ref> [SO90] </ref>, significantly increase the demand for registers. A greater competition for registers can lead to an increase in register spilling and false register dependencies between instructions. The following is a (non-exhaustive) list of optimizations that are possible as part of a final pass over the code. <p> Applying interprocedural register allocation, a freed register around a call can allow the called procedure and its descendants in the call-graph (assuming the current procedure dominates these procedures in the call-graph) to make use of the register <ref> [SO90] </ref> In this paper we will use live range splitting to remove false register dependencies. 4 Live Range Splitting We aim for Chaitin's style of live range splitting, that is, we try to insert a load for each use of a live range and a store after each definition.
Reference: [Wal86] <author> David W. Wall. </author> <title> Global register allocation at link-time. </title> <booktitle> In Proceedings of SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Loop unrolling, software pipelining, scalar replacement [CCK90], code inlining, and interprocedural register allocation <ref> [Wal86] </ref> [Cho88] [SO90], significantly increase the demand for registers. A greater competition for registers can lead to an increase in register spilling and false register dependencies between instructions. The following is a (non-exhaustive) list of optimizations that are possible as part of a final pass over the code.
References-found: 17

