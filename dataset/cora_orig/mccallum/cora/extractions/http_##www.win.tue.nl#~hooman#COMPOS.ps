URL: http://www.win.tue.nl/~hooman/COMPOS.ps
Refering-URL: http://www.win.tue.nl/~hooman/COMPOS.html
Root-URL: http://www.win.tue.nl
Email: e-mail: hooman@win.tue.nl  
Title: Compositional Verification of Real-Time Applications  
Author: Jozef Hooman 
Web: http://www.win.tue.nl/win/cs/tt/hooman/  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Computing Science Eindhoven University of Technology  
Abstract: To support top-down design of distributed real-time systems, a framework of mixed terms has been incorporated in the verification system PVS. Programs and assertional specifications are treated in a uniform way. We focus on the timed behaviour of parallel composition and hiding, presenting several alternatives for the definition of a deno-tational semantics. This forms the basis of compositional proof rules for parallel composition and hiding. The formalism is applied to an example of a hybrid system, which also serves to illustrate our ideas on platform-independent programming. 
Abstract-found: 1
Intro-found: 1
Reference: [AH97] <author> R. Alur and T. Henzinger. </author> <title> Modularity for timed and hybrid systems. </title> <booktitle> In Proc. Conf. on Concurrency Theory (CONCUR '97), </booktitle> <pages> pages 74-88. </pages> <publisher> LNCS 1243, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: For instance, in the second framework the condition in the consequence rule can be weakened. Interesting is comparison with the refinement relation defined in <ref> [AH97] </ref>, which requires that if an observation of the implementation is projected onto the alphabet of the specification, an observation of the specification is obtained. <p> As mentioned in <ref> [AH97] </ref>, this relation implies P == Q P.
Reference: [dR85] <author> W.P. de Roever. </author> <title> The quest for compositionality a survey of assertion-based proof systems for concurrent programs, Part I: Concurrency based on shared variables. </title> <booktitle> In Proc. IFIP Working Conference 1985: The role of abstract models in computer science, </booktitle> <pages> pages 181-207. </pages> <publisher> North-Holland, </publisher> <year> 1985. </year>
Reference: [HdR86] <author> J. Hooman and W.P. de Roever. </author> <title> The quest goes on: a survey of proof systems for partial correctness of CSP. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <pages> pages 343-395. </pages> <publisher> LNCS 224, Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: To increase the confidence in the definition of parallel composition, an al-ternative definition is formulated and shown to be equivalent with the previous one. This alternative definition is similar to the trace-based semantics of parallel composition <ref> [Hoa85] </ref>, which turned out to be useful for the formulation of a compositional rule for (untimed) parallel composition [Zwi89]. Basic idea is that the projection of an observation of the parallel construct onto the alphabet of one of the components leads to an observation of this component.
Reference: [Hoo94] <author> J. Hooman. </author> <title> Correctness of real time systems by construction. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 19-40. </pages> <publisher> LNCS 863, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Another class of applications concerns the design of hybrid systems, containing both discrete and continuous components. For instance, a steam boiler control system has been specified and verified [VH96]. These applications are based on a formalization of the framework in PVS as described in <ref> [Hoo94] </ref>. There the proof rules for sequential programming constructs have been proved sound, but the rule for parallel composition was stated as an axiom, based on a manual soundness proof. <p> Focusing on parallel composition and hiding, we only describe the externally visible behaviour of a component in terms of the events that occur at any point of time. This clarifies the exposition, leaving extensions of the approach to deal with a local state along the lines of <ref> [Hoo94] </ref> to future work. 1.4 Overview The basic semantic primitives are defined in Sect. 2. Several equivalent formulations for the semantics of parallel composition can be found in Sect. 3. Moreover, we prove the soundness of a compositional rule for parallel composition. <p> Clearly more work is needed to investigate various notions of refinement in combination with the real-time frameworks developed here and to study their mutual relations. Also relevant is a comparison of extensions to sequential programs with a local state, similar to <ref> [Hoo94] </ref>. Another topic of future research concerns the specifications which are kept simple here, but might be more structured with, for instance, pre/post conditions or rely/guarantee (assumption/commitment) pairs. Current work includes research on the ideas of platform-independent design of real-time systems.
Reference: [Hoo95] <author> J. Hooman. </author> <title> Verifying part of the ACCESS.bus protocol using PVS. </title> <booktitle> In Proceedings 15th Conference on the Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> LNCS 1026, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: in the work described here, several errors have been detected by the formulation of alternative definitions and attempts to prove equivalence. 1.3 Applications and Topic of this Paper In previous work, our assertional framework has been used to verify several protocols with PVS, such as part of the ACCESS.bus protocol <ref> [Hoo95] </ref> and a membership protocol with local clocks and a dynamically changing network [Hoo97]. Another class of applications concerns the design of hybrid systems, containing both discrete and continuous components. For instance, a steam boiler control system has been specified and verified [VH96].
Reference: [Hoo97] <author> J. Hooman. </author> <title> Verification of distributed real-time and fault-tolerant protocols. In Algebraic Methodology and Software Technology (AMAST'97), </title> <note> to appear. LNCS 1349, Springer-Verlag, </note> <year> 1997. </year>
Reference-contexts: of alternative definitions and attempts to prove equivalence. 1.3 Applications and Topic of this Paper In previous work, our assertional framework has been used to verify several protocols with PVS, such as part of the ACCESS.bus protocol [Hoo95] and a membership protocol with local clocks and a dynamically changing network <ref> [Hoo97] </ref>. Another class of applications concerns the design of hybrid systems, containing both discrete and continuous components. For instance, a steam boiler control system has been specified and verified [VH96]. These applications are based on a formalization of the framework in PVS as described in [Hoo94].
Reference: [HvR97] <author> J. Hooman and O. van Roosmalen. </author> <title> Platform-independent verification of real-time programs. </title> <booktitle> In Proceedings of the Joint Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <pages> pages 183-192. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Our approach aims at a platform-independent program activity, postponing platform considerations as long as possible. This is achieved by extending conventional (untimed) programming languages with so-called timing annotations that only specify the relevant timing constraints <ref> [HvR97] </ref>. As a separate activity, these platform-independent programs are then scheduled on a particular execution platform. 1.2 Mechanized Proof Support To obtain mechanized support for our formal framework, we use the verification system PVS (Prototype Verification System) [ORS92,ORSvH95]. <p> We will use the framework of Sect. 3 and Sect. 5.1 (i.e., without environment events), to show a few steps towards the design of a discrete controller. Further, the example serves to illustrate recent ideas on platform-independent development of real-time systems <ref> [HvR97] </ref>, as indicated in the next section. 6.1 Platform-Independence The goal is to postpone platform-dependent design decisions as long as possible. To achieve this, we distinguish two activities: A platform-independent programming activity, where a program is developed independent of any particular architecture on which it has to be executed. <p> Current work includes research on the ideas of platform-independent design of real-time systems. Although an axiomatic semantics has been given for a simple language with timing annotations <ref> [HvR97] </ref>, more work is needed to obtain a formal semantics of a more realistic programming language and to incorporate this into PVS. Also the design process, supported by compositional proof rules, requires further study.
Reference: [MJ96] <author> M. Joseph, </author> <title> editor. Real-time Systems: Specification, Verification and Analysis. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Design a program satisfying the discrete specification, obtained in the pre vious step, of the control component. 6.3 Example Hybrid System The example presented here is a simplified version of a mine pump example <ref> [MJ96] </ref>. Consider a mine with a certain engine (e.g., a pump to evacuate water) which should not be operating when a certain amount of gas is present, because that might lead to an explosion. Following the steps above, first the requirements specification of the mine system is formulated.
Reference: [Old85] <author> E.-R. Olderog. </author> <title> Process theory: Semantics, specification and verification. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <pages> pages 442-509. </pages> <publisher> LNCS 224, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Observe that these approaches also have their consequences for the allowed refinements, although we used the same refinement relation for both approaches (a simple set inclusion, similar to the trace inclusion in e.g. <ref> [Old85] </ref>). For instance, in the second framework the condition in the consequence rule can be weakened. Interesting is comparison with the refinement relation defined in [AH97], which requires that if an observation of the implementation is projected onto the alphabet of the specification, an observation of the specification is obtained.
Reference: [Old91] <author> E.-R. Olderog. </author> <title> Nets, Terms and Formulas, </title> <booktitle> volume 23 of Camebridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Camebridge University Press, </publisher> <year> 1991. </year>
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference: [Sha98] <author> N. Shankar. </author> <title> Machine-assisted verification using theorem proving and model checking. </title> <editor> In M. Broy, editor, </editor> <title> Mathematical Programming Methodology, </title> <note> to appear. </note> <year> 1998. </year>
Reference-contexts: var setof [Time] % setof [Time] = [Time ! bool] P in I : bool = 9 t : t 2 I ^ P (t) P during I : bool = 8 t : t 2 I ) P (t) importing Connectives [Time] end TimePrim Theory Connectives is copied from <ref> [Sha98] </ref>; it lifts the boolean connectives to the domain of predicates over a given type.
Reference: [SO98] <author> M. Schenke and E.-R. Olderog. </author> <title> Transformational design of real-time systems Part I: From requirements to program specification. </title> <journal> Acta Informat-ica, </journal> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: To be able to formalize intermediate stages during the top-down design of a system, we aim at a framework where specifications and programming constructs can be mixed freely. This is inspired by similar work on untimed systems [Old85,Old91,Zwi89] and related to recent work on timed systems <ref> [SO98] </ref>. Example 1. As a simple example, consider a top-level specification T LSpec, in-cluding timing constraints. Suppose we decide to implement this as the parallel composition of two components specified by SpecComp 1 and SpecComp 2 .
Reference: [VH96] <author> J. Vitt and J. Hooman. </author> <title> Assertional specification and verification using PVS of the steam boiler control system. </title> <editor> In J.-R. Abrial, E. Borger, and H. Langmaack, editors, </editor> <title> Formal Methods for Industrial Applications: </title> <booktitle> Specifying and Programming the Steam Boiler Control, </booktitle> <pages> pages 453-472. </pages> <publisher> LNCS 1165, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Another class of applications concerns the design of hybrid systems, containing both discrete and continuous components. For instance, a steam boiler control system has been specified and verified <ref> [VH96] </ref>. These applications are based on a formalization of the framework in PVS as described in [Hoo94]. There the proof rules for sequential programming constructs have been proved sound, but the rule for parallel composition was stated as an axiom, based on a manual soundness proof.
Reference: [Zwi89] <author> J. Zwiers. </author> <title> Compositionality, Concurrency and Partial Correctness. </title> <publisher> LNCS 321, Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This alternative definition is similar to the trace-based semantics of parallel composition [Hoa85], which turned out to be useful for the formulation of a compositional rule for (untimed) parallel composition <ref> [Zwi89] </ref>. Basic idea is that the projection of an observation of the parallel construct onto the alphabet of one of the components leads to an observation of this component. Projection is here represented by intersection. Additionally, any observation function of the composition should only contain events of its alphabet.
References-found: 17

