URL: http://ftp.cs.yale.edu/pub/rodrigue/final-report.ps.gz
Refering-URL: http://ftp.cs.yale.edu/pub/rodrigue/
Root-URL: http://www.cs.yale.edu
Title: Implementing Parallel Shortest Paths Algorithms  
Author: Marios Papaefthymiou Joe Rodrigue 
Affiliation: Department of Electrical Engineering and Department of Computer Science Yale University  Department of Computer Science Yale University  
Abstract: We have implemented a parallel version of the Bellman-Ford algorithm for the single-source shortest paths problem. Our software has been developed on the CM-5 using C with CMMD communication primitives. We have empirically compared the efficiency of our implementation with a sequential implementation of the Bellman-Ford-Moore algorithm developed by Cherkassky, Goldberg and Radzik. We have performed our experiments using fifty randomly generated graphs with vertex counts in the range between 2 10 and 2 15 and edge counts in the range between 2 11 and 2 21 . In our experiments, the parallel implementation becomes faster than the sequential implementation when the average degree of the input graphs exceeds 2 5 or 2 6 . For the dense graphs in our test suite, we obtain speedups of up to 3.3 on 32 processors and up to 8.3 on 128 processors. In the implementation we discuss in this paper, several design decisions were taken in view of the limited time we had to complete a working version of our software. For example, instead of performing any kind of dynamic load balancing, we try to keep the computation load balanced by applying a straightforward data distribution scheme at the beginning of the computation. Moreover, in the code that runs on each processor, we avoid any sophisticated data structures and only use linear arrays. We are currently experimenting with alternative implementations that may lead to improved speedups, particularly on the denser graphs of our test suite. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. P. Bertsekas and J. N. Tsitsiklis. </author> <title> Parallel and Distributed Computation. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The solution of several problems such as routing in the Arpanet, VLSI design and commodity flow problems relies on shortest paths computations. Several sequential and parallel algorithms have been proposed for computing shortest paths <ref> [1, 3, 4, 6] </ref>. The practical efficiency of these algorithms has not been fully explored, however. Empirical studies of sequential shortest paths algorithms have been published only recently [2], and to our knowledge no performance comparison of sequential and parallel algorithms has ever been published.
Reference: [2] <author> B. Cherkassky, A. Goldberg, and T. Radzik. </author> <title> Shortest paths algorithms: theory and experimental evaluation. </title> <type> Technical Report STAN-CS-93-1480, </type> <institution> Stanford, </institution> <year> 1993. </year>
Reference-contexts: Several sequential and parallel algorithms have been proposed for computing shortest paths [1, 3, 4, 6]. The practical efficiency of these algorithms has not been fully explored, however. Empirical studies of sequential shortest paths algorithms have been published only recently <ref> [2] </ref>, and to our knowledge no performance comparison of sequential and parallel algorithms has ever been published. In this paper we present an empirical comparison of a parallel and a sequential implementation of the Bellman-Ford algorithm for the single-source shortest paths problem. <p> We developed our own parallel implementation of Bellman-Ford on a CM-5 parallel supercomputer, and compared its performance to that of a sequential Bellman-Ford-Moore implementation due to <ref> [2] </ref> running on a Sparc 2. The sequential implementation uses a parent-checking heuristic for improved performance. Our test suite was a collection of directed graphs with integer edge weights generated using the sprand random graph generator described in [2]. <p> compared its performance to that of a sequential Bellman-Ford-Moore implementation due to <ref> [2] </ref> running on a Sparc 2. The sequential implementation uses a parent-checking heuristic for improved performance. Our test suite was a collection of directed graphs with integer edge weights generated using the sprand random graph generator described in [2]. <p> These heuristics do not improve the algorithm's asymptotic behavior but they seem to work well in practice. The efficiency of the sequential implementation we have used in our experiments relies on the so-called parent-checking heuristic <ref> [2] </ref>. The implementation maintains a queue of vertices whose outgoing edges are to be relaxed. Using the parent-checking heuristic, when the algorithm pulls a vertex u off the queue it first checks if u's parent (u) is in 2 the queue; if so, the relaxation is skipped. <p> Intuitively, (u) being in the queue means that d (u) will soon be updated and so it would be pointless to relax u's outgoing edges until that update takes place. The authors of <ref> [2] </ref> report that this heuristic works well in practice. 3 Parallelizing the Bellman-Ford algorithm Our parallel implementation of Bellman-Ford relies on the fact that edges may be relaxed in any order. We tried to exploit this property to the greatest extent possible and experimented with several possible implementations. <p> The random test graphs were generated using the sprand network generator of Cherkassky, Goldberg and Radzik <ref> [2] </ref>. Each graph had edge weights in the interval [-5, 10] and contained one connected cycle of length V ; the other edges were random.
Reference: [3] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> McGraw-Hill, MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The solution of several problems such as routing in the Arpanet, VLSI design and commodity flow problems relies on shortest paths computations. Several sequential and parallel algorithms have been proposed for computing shortest paths <ref> [1, 3, 4, 6] </ref>. The practical efficiency of these algorithms has not been fully explored, however. Empirical studies of sequential shortest paths algorithms have been published only recently [2], and to our knowledge no performance comparison of sequential and parallel algorithms has ever been published. <p> Paths are represented by recording each vertex v's parent (v), so that the shortest path from the source s to v 6= s is recursively defined as the shortest path from s to (v) followed by the edge ((v); v). A good treatment is given in <ref> [3] </ref>. Several algorithms have been designed for solving single-source shortest paths. The efficiency of these algorithms relies mainly on assumptions about the nature of the edge weights. In the general case, where edge weights can take any integer value, the Bellman-Ford algorithm is asymptotically the fastest. <p> An interesting property of the Bellman-Ford algorithm is that within each pass we can consider the edges (u; v) in arbitrary order without affecting correctness. Researchers have provided efficient heuristics that improve the practical running time of the algorithm by visiting the edges in a particular order <ref> [3] </ref>. These heuristics do not improve the algorithm's asymptotic behavior but they seem to work well in practice. The efficiency of the sequential implementation we have used in our experiments relies on the so-called parent-checking heuristic [2].
Reference: [4] <author> Y. Han, V. Pan, and J. Reif. </author> <title> Efficient parallel algorithms for all-pairs shortest-paths in directed graphs. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: The solution of several problems such as routing in the Arpanet, VLSI design and commodity flow problems relies on shortest paths computations. Several sequential and parallel algorithms have been proposed for computing shortest paths <ref> [1, 3, 4, 6] </ref>. The practical efficiency of these algorithms has not been fully explored, however. Empirical studies of sequential shortest paths algorithms have been published only recently [2], and to our knowledge no performance comparison of sequential and parallel algorithms has ever been published.
Reference: [5] <author> R. Harlan. </author> <title> Searching in parallel: case study with singel-source shortest-paths algorithms. </title> <journal> ACM SIG CS Education bulletin, </journal> <volume> 23(1), </volume> <month> March </month> <year> 1991. </year>
Reference: [6] <author> G. Pantziou, P. Spirakis, and C. Zaroliagis. </author> <title> Efficient parallel algorithms for shortest paths in planar digraphs. </title> <journal> BIT, </journal> <volume> 32, </volume> <year> 1992. </year> <month> 9 </month>
Reference-contexts: The solution of several problems such as routing in the Arpanet, VLSI design and commodity flow problems relies on shortest paths computations. Several sequential and parallel algorithms have been proposed for computing shortest paths <ref> [1, 3, 4, 6] </ref>. The practical efficiency of these algorithms has not been fully explored, however. Empirical studies of sequential shortest paths algorithms have been published only recently [2], and to our knowledge no performance comparison of sequential and parallel algorithms has ever been published.
References-found: 6

