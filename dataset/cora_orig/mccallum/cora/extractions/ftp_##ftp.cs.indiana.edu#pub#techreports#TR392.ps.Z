URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR392.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Introduction to Behavior Tables  
Author: Kamlesh Rath, M. Esen Tuna, and Steven D. Johnson 
Date: december 1993  
Note: An  
Abstract: indiana university computer science department technical report no. 392 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. Sangiovanni-Vincentelli, </author> <title> "Sequential circuit design using synthesis and optimization," </title> <booktitle> in Proceedings of International Conference on Computer Design, </booktitle> <pages> pp. 328-333, </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: A high-level functional specification of a system is used to construct the behavior table specification. A sequence of transformations on the different facets of the design are used to construct a set of interacting boolean level behavior tables which can be realized using sequential logic synthesis tools (e.g. <ref> [1] </ref>). Many design automation systems use directed acyclic graph (DAG) based structures for design representation. Flamel [2] uses a DAG based representation to model data-flow and control-flow. Transformations are defined on the DAGs for scheduling and allocation.
Reference: [2] <author> H. Trickey, "Flamel: </author> <title> A high-level hardware compiler," </title> <booktitle> in Transactions on Computer-Aided Design 1987, </booktitle> <pages> pp. 259-269, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: A sequence of transformations on the different facets of the design are used to construct a set of interacting boolean level behavior tables which can be realized using sequential logic synthesis tools (e.g. [1]). Many design automation systems use directed acyclic graph (DAG) based structures for design representation. Flamel <ref> [2] </ref> uses a DAG based representation to model data-flow and control-flow. Transformations are defined on the DAGs for scheduling and allocation. The System Architect's Workbench [3] also uses a DAG based internal representation called Value Trace. Behavioral and structural transformations are defined on the value trace representation.
Reference: [3] <author> D. E. Thomas, E. M. Dirkes, R. A. Walker, J. V. Rajan, J. A. Nestor, and R. L. Blackburn, </author> <title> "The system architect's workbench," </title> <booktitle> in Proceedings of the 25th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 337-343, </pages> <year> 1988. </year>
Reference-contexts: Many design automation systems use directed acyclic graph (DAG) based structures for design representation. Flamel [2] uses a DAG based representation to model data-flow and control-flow. Transformations are defined on the DAGs for scheduling and allocation. The System Architect's Workbench <ref> [3] </ref> also uses a DAG based internal representation called Value Trace. Behavioral and structural transformations are defined on the value trace representation. The ADAM synthesis system [4] also uses data flow graphs for datapath synthesis. Graph based internal representations 2 are suited for either control-flow or data-flow representation.
Reference: [4] <author> R. Jain, K. Ku~cuk~cakar, M. J. Mlinar, and A. C. Parker, </author> <title> "Experience with the ADAM synthesis system," </title> <booktitle> in Proceedings of the 26th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 56-61, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Transformations are defined on the DAGs for scheduling and allocation. The System Architect's Workbench [3] also uses a DAG based internal representation called Value Trace. Behavioral and structural transformations are defined on the value trace representation. The ADAM synthesis system <ref> [4] </ref> also uses data flow graphs for datapath synthesis. Graph based internal representations 2 are suited for either control-flow or data-flow representation. Representing these and other facets in a single graph form is usually done by annotating the control-flow graph with data-flow and other information, as in HOP [5].
Reference: [5] <author> G. C. Gopalakrishnan, R. M. Fujimoto, V. Akella, and N. S. Mani, "HOP: </author> <title> A process model for synchronous hardware; semantics and experiments in process composition," Integration, </title> <journal> the VLSI journal, </journal> <volume> vol. 8, </volume> <pages> pp. 209-247, </pages> <year> 1989. </year>
Reference-contexts: Graph based internal representations 2 are suited for either control-flow or data-flow representation. Representing these and other facets in a single graph form is usually done by annotating the control-flow graph with data-flow and other information, as in HOP <ref> [5] </ref>. Petri-net based internal representations are also suited for control-flow representation but are not useful for data-flow representation. In the CAMAD [6] system, a petri-net model is used for control representation and a graph representation is used for datapath representation.
Reference: [6] <author> Z. Peng, </author> <title> A Formal Methodology for Automated Synthesis of VLSI Systems. </title> <type> PhD thesis, </type> <institution> Linkoping University, Sweden, </institution> <year> 1987. </year>
Reference-contexts: Representing these and other facets in a single graph form is usually done by annotating the control-flow graph with data-flow and other information, as in HOP [5]. Petri-net based internal representations are also suited for control-flow representation but are not useful for data-flow representation. In the CAMAD <ref> [6] </ref> system, a petri-net model is used for control representation and a graph representation is used for datapath representation. Semantics preserving structural transformations are used on the petri-net and graph representations to realize a circuit.
Reference: [7] <author> M. R. K. Patel, </author> <title> "A design representation for high level synthesis," </title> <booktitle> in Proceedings of EDAC, </booktitle> <pages> pp. 374-379, </pages> <year> 1990. </year>
Reference-contexts: In the CAMAD [6] system, a petri-net model is used for control representation and a graph representation is used for datapath representation. Semantics preserving structural transformations are used on the petri-net and graph representations to realize a circuit. Patel <ref> [7] </ref> proposes a hierarchical system of graph representations to describe concurrency, control-flow and data-flow aspects of a system. This representation addresses the problem of storage optimization for synthesis algorithms, but as Patel acknowledges "one of the first problems : : : is the detailed representation of the datapath".
Reference: [8] <author> R. A. Walker and D. E. Thomas, </author> <title> "Behavioral transformation for algorithmic level IC design," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 8, no. 10, </volume> <pages> pp. 1115-1128, </pages> <year> 1989. </year>
Reference-contexts: Behavior tables are indexed both by behavior and structure, and are suited for both behavioral and structural transformations. System-level synthesis in the System Architect's Workbench is accomplished by behavioral transformations <ref> [8] </ref>. Walker and Thomas show transformations on the controller and selector. Transformations to partition a design into processes are also shown. The processes created using their method have a very simple interaction scheme to transfer data values and control signals using message passing.
Reference: [9] <author> F. Vahid and D. D. Gajski, </author> <title> "Specification partitioning for system design," </title> <booktitle> in Proceedings of the 29th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 219-224, </pages> <year> 1992. </year>
Reference-contexts: Transformations to partition a design into processes are also shown. The processes created using their method have a very simple interaction scheme to transfer data values and control signals using message passing. Their approach can not synthesize components using complex protocols for data transfers and synchronization. SpecPart <ref> [9] </ref> partitions algorithm/process grained computations from the SpecChart behavioral specifications. Default protocols are used for interaction between components. The CHOP system-level design partitioner [10] uses task graphs to specify the protocol between every partition. Special purpose hardware units called data-transfer modules are used on both sides of each interaction.
Reference: [10] <author> K. Ku~cuk~cakar and A. C. Parker, "CHOP: </author> <title> A constraint-driven system-level partitioner," </title> <booktitle> in Proceedings of the 28th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 514-519, </pages> <year> 1991. </year>
Reference-contexts: Their approach can not synthesize components using complex protocols for data transfers and synchronization. SpecPart [9] partitions algorithm/process grained computations from the SpecChart behavioral specifications. Default protocols are used for interaction between components. The CHOP system-level design partitioner <ref> [10] </ref> uses task graphs to specify the protocol between every partition. Special purpose hardware units called data-transfer modules are used on both sides of each interaction.
Reference: [11] <author> S. D. Johnson, </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> Cambridge: MIT Press, </publisher> <year> 1984. </year> <note> ACM Distinguished Dissertation 1984. </note>
Reference-contexts: A system can be specified at the symbolic level and later transformed into a boolean system by assigning types to entries in the tables. The research reported here grew out of our existing design derivation system, which is based on first order functional algebra <ref> [11, 12] </ref>.
Reference: [12] <author> B. Bose, </author> <title> "DDD A Transformation system for Digital Design Derivation," </title> <type> Tech. Rep. 331, </type> <institution> Department of Computer Science, Indiana University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: A system can be specified at the symbolic level and later transformed into a boolean system by assigning types to entries in the tables. The research reported here grew out of our existing design derivation system, which is based on first order functional algebra <ref> [11, 12] </ref>. <p> Indirection transformations can be used to move parts of the system between control and datapath. The transformations on the datapath have been adapted for use on behavior tables from the algebra on purely functional datapath descriptions reported in <ref> [14, 12] </ref>. Column Insertion/Deletion/Renaming : A column denoting a new functional unit can be added to a behavior table with any value for any transition. A column can be deleted if all values in the column are don't cares.
Reference: [13] <author> S. Devadas and K. Keutzer, </author> <title> "An Automata-Theoretic Approach to Behavioral Equivalence," </title> <booktitle> in Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pp. 30-33, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In general, this involves verification of equivalence of logical and arithmetic expressions <ref> [13] </ref>, and is therefore a heuristic task. This relation applies only to internal predicates, registers and combinational signals. External input or output columns should not be transformed based on this relation.
Reference: [14] <author> S. D. Johnson, </author> <title> "Manipulating logical organization with system factorizations," in Hardware Specification, Verification and Synthesis: Mathematical Aspects (Leeser and Brown, </title> <editor> eds.), </editor> <volume> vol. </volume> <booktitle> 408 of LNCS, </booktitle> <pages> pp. 260-281, </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of Mathematical Sciences Institute Workshop, </booktitle> <institution> Cornell University, </institution> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Indirection transformations can be used to move parts of the system between control and datapath. The transformations on the datapath have been adapted for use on behavior tables from the algebra on purely functional datapath descriptions reported in <ref> [14, 12] </ref>. Column Insertion/Deletion/Renaming : A column denoting a new functional unit can be added to a behavior table with any value for any transition. A column can be deleted if all values in the column are don't cares. <p> Intuitively, a machine can interact with any path implementation of its complement. 4.3 Sequential Decomposition In this section we introduce the sequential decomposition transformation on the protocol facet of behavior tables. Sequential decomposition is a generalization of the factorization transformation on the datapath facet <ref> [14] </ref> to include protocols in factoring procedures from a system. This transformation is used to extract parts of a system at the operation, algorithm, or procedure level of granularity into a co-process, with non-trivial control synchronization and data transfer protocols.
Reference: [15] <author> K. Rath and S. D. Johnson, </author> <title> "Toward a basis for protocol specification and process decom-position," </title> <booktitle> in Proceedings of IFIP Conference on Hardware Description Languages and their Applications (D. </booktitle> <editor> Agnew, L. Claesen, and R. Camposano, </editor> <booktitle> eds.), </booktitle> <pages> pp. 157-174, </pages> <publisher> Elsevier, </publisher> <month> Apr. </month> <year> 1993. </year> <note> Also published as Technical Report No. 375, </note> <institution> Dept. of Computer Science, Indiana University. </institution>
Reference-contexts: We briefly sketch this language here more details can be found in <ref> [15] </ref>. ISL can not be used to specify the internal behavior of a system as internal register transfers and internal conditions. A definition in ISL is used to construct a machine that describes the control synchronization and data transfer protocol with its environment. <p> Data interactions occur over input/output data ports and control interactions occur over input/output control ports. The protocol is defined over input and output control ports (CI, CO ), input and output data ports (DI, DO), and data values (V ). We use an extension of the language presented in <ref> [15] </ref>, that allows for symbolic values on control and data ports. The syntax description of ISL is given in Figure 3. An interaction consists of a set of values on data ports guarded by certain truth values on control ports.
Reference: [16] <author> D. L. Dill, </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The machine model for the protocol specification is same as the one described in Section 2.1, with designated start and final states. The complement of the protocol specifies the environment machine. Our idea of complement is similar to Dill's idea of an environment of a trace structure <ref> [16] </ref>. The goal of the transformations on the protocol facet is to decompose a behavior table into interacting behavior tables using the specified protocol definition. We can specify the protocol of a component and incorporate an implementation of an interaction path of its complement into the other component.
Reference: [17] <author> S. Devadas and A. R. </author> <title> Newton, "Decomposition and factorization of sequential finite state machines," </title> <journal> Transactions on Computer-Aided Design 1989, </journal> <volume> vol. 8, </volume> <pages> pp. 1206-1217, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: This transformation is used to extract parts of a system at the operation, algorithm, or procedure level of granularity into a co-process, with non-trivial control synchronization and data transfer protocols. Sequential decomposition is different from classical FSM decomposition (e.g. <ref> [17] </ref>), which assumes tightly-coupled sub-machines that can share state and input information. A group of functions in a behavior table can be abstracted to a behavior table that performs the function. The protocol for communication with the abstract component is specified in ISL.
Reference: [18] <author> Z. Zhu and S. D. Johnson, </author> <title> "An algebraic framework for data abstraction in hardware description," </title> <booktitle> in Proceedings of The Oxford Workshop on Designing Correct Circuits (Jones and Sheeran, </booktitle> <editor> eds.), </editor> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: The conditions for validity of the data representation function have been adapted from our previous work on abstract data types <ref> [18] </ref>. 5.1 Transformations In this section we define the represents relation on the data abstraction facets of machines and the transformations to change levels of data abstraction. A type must be chosen for each column in the behavior table.
Reference: [19] <author> W. A. Hunt, </author> <title> "A formal HDL and its use in the FM9001 verification," in Mechanized Reasoning in Hardware Design (C. </title> <editor> Hoare and M. Gordon, eds.), </editor> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Ports in a behavior table that are connected in a net with ports in other behavior tables must have the same type. Changing the level of data abstraction of a port generates side-conditions for all ports in the net. 6 Example Deriving an FM9001 Implementation The FM9001 <ref> [19] </ref> is a 32-bit microprocessor, the third generation processor description defined by Hunt and mechanically verified at the gate level using the Nqthm theorem prover.
Reference: [20] <author> B. Bose and S. D. Johnson, "DDD-FM9001: </author> <title> Derivation of a verified microprocessor. an exercise in integrating verification with formal derivation," </title> <booktitle> in Proceedings of IFIP Conference on Correct Hardware Design and Verification Methods, </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Bose has derived an Actel FPGA implementation of the FM9001 using our digital design derivation tool <ref> [20] </ref>, which is adept at handling datapath oriented designs with monolithic control. Here, we give a sketch some of the transformations on a behavior table specification of the FM9001.
Reference: [21] <author> K. Rath, B. Bose, and S. D. Johnson, </author> <title> "Derivation of a DRAM memory interface by sequential decomposition," </title> <booktitle> in Proceedings of the International Conference on Computer Design, </booktitle> <pages> pp. 438-441, </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: Our methodology is powerful enough to derive the memory controller for a DRAM memory system, with a protocol specification from DRAM timing diagrams, (reported in <ref> [21] </ref>). 6.3 Data Abstraction Transformations Data abstraction is an important part of the design process, because it enables the designer to reason at the abstract symbolic level before assigning representations to functional units and values in a system.
References-found: 21

