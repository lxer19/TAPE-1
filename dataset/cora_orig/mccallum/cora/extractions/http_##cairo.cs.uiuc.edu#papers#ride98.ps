URL: http://cairo.cs.uiuc.edu/papers/ride98.ps
Refering-URL: http://cairo.cs.uiuc.edu/papers.html
Root-URL: http://www.cs.uiuc.edu
Email: fmanolesc,klarag@cs.uiuc.edu  
Title: A Scalable Approach to Continuous-Media Processing  
Author: Dragos-Anton Manolescu Klara Nahrstedt 
Address: 1304 W. Springfield Ave., Urbana, IL 61801  
Affiliation: Department of Computer Science  
Abstract: Techniques that emphasize software reuse and scalability are becoming more important than ever. In this paper we present a component-based model for continuous-media applications. Components encapsulate expert knowledge and facilitate reuse. They provide a toolkit that is used to create a wide range of continuous-media applications. Our model is scalable in several dimensions: media transformations, number of processors, number of configurations, media types, and processing and communication requirements. The paper is organized as a catalog of four software patterns. It is our belief that developers and researchers working on continuous-media applications can benefit from and apply software patterns as well. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Ackermann. </author> <title> Design and implementation of on object oriented media composition framework. </title> <booktitle> In Proc. Inter national Computer Music Conference, </booktitle> <address> Aarhus, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Introduction Current multimedia systems are complex. They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks <ref> [1, 5, 9] </ref>, design patterns [4, 2], software components [8]) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction.
Reference: [2] <author> F. Buschman, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal. </author> <title> Pattern-Oriented Software ArchitectureA System of Patterns. </title> <publisher> John Wiley & Sons, </publisher> <month> July </month> <year> 1996. </year> <pages> ISBN 0-47195 869-7. </pages>
Reference-contexts: Introduction Current multimedia systems are complex. They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks [1, 5, 9], design patterns <ref> [4, 2] </ref>, software components [8]) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction.
Reference: [3] <author> R. H. Campbell, V. Russo, and G. Johnston. </author> <title> Choices: The Design of a Multiprocessor Operating System. </title> <booktitle> In Proc. USENIX C++ Workshop, </booktitle> <pages> pages 109123, </pages> <address> Santa Fe, NM, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: One way to improve performance is to pack multiple messages into one container message such that all of them are transferred in one step. Although this technique has been successfully applied in operating systems <ref> [3] </ref>, it is not viable for continuous-media applications, where typical payloads contain time-sensitive data and have large memory footprints.
Reference: [4] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design PatternsElements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <note> ISBN 0-201-63361-2. </note>
Reference-contexts: Introduction Current multimedia systems are complex. They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks [1, 5, 9], design patterns <ref> [4, 2] </ref>, software components [8]) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction. <p> Consequently, the dynamic composition of filters allows an application to (1) adjust the resource consumption of the system at runtime; and (2) adapt to different computing and communications environments as well as changes in resource availability. Within a network, adjacent performance-critical modules can be regarded as a composite <ref> [4] </ref> filter and replaced with an optimized version that trades flexibility for performance. Static composition provides the underlying application (e.g., compiler) with enough information to collapse a sequence of modules into a functionally equivalent primitive module, reducing the overhead of inter-module communication [15].
Reference: [5] <author> S. J. Gibbs and D. C. Tsichritzis. </author> <title> Multimedia ProgrammingObjects, Environments and Frameworks. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <note> ISBN 0-201-42282-4. </note>
Reference-contexts: Introduction Current multimedia systems are complex. They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks <ref> [1, 5, 9] </ref>, design patterns [4, 2], software components [8]) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction.
Reference: [6] <author> K. L. Gong and L. A. Rowe. </author> <title> Parallel MPEG1 video encod ing. </title> <booktitle> In Proc. Picture Coding Symposium, </booktitle> <address> Sacramento, CA, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: For instances where the processing partition performs heavyweight, time-consuming computations, the application arranges to use the control wait states to perform computations for the processing partition. vE x a m p l e s The Berkeley parallel MPEG1 encoder <ref> [6] </ref> is partitioned in a similar way.
Reference: [7] <author> M. H. Jackson, J. E. Baldeschwieler, and L. A. Rowe. </author> <title> Berke ley Continuous Media Toolkit API. </title> <note> Submitted for publica tion, </note> <month> September </month> <year> 1996. </year>
Reference-contexts: Users that have knowledge only about the application domain create new applications by simply connecting modules, without performing any programming [10, 17]. Sometimes visual 1 In this context, module is any processing unit within the application domain. flow architecture. programming tools or scripting languages <ref> [7] </ref> assist the creation of module networks. <p> Similarly, the MPEG frame rate is at most 10% lower than the Berkeley player. This analysis shows that reusable, high-performance solutions are possible with today's technology. Other examples include ActiveMovie [12] and the Berkeley Continuous-Media Toolkit <ref> [7] </ref>. vI m p l e m e n t a t i o n n o t e s This section follows the guidelines from [15]. Processing modules inherit an input interface from PushInput and an output interface from PushOutputthe Push prefix is explained in Section 3. <p> It is used to send notification messages from a renderer (sink). All components of the architecture recognize a special asynchronous event which requires graceful flushing of old data, followed by resynchronization. This pattern is also employed by the Berkeley continuous-media toolkit <ref> [7] </ref> and the VuSys-tem [10]. vI m p l e m e n t a t i o n n o t e s A flexible implementation solution is to regard the payload as a composite message. <p> Timing control is employed by a Logical Time System (LTS) <ref> [7] </ref>. This is a user configurable clock that abstracts the time and encapsulates a mapping from real time to application time. The LTS schedules the continuous-media processing within the processing partition. QoS monitoring and management is performed by the QoS broker [14].
Reference: [8] <author> R. E. Johnson. </author> <title> Frameworks=(Components + Patterns). </title> <journal> Com munications of the ACM, </journal> <volume> 40(10), </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks [1, 5, 9], design patterns [4, 2], software components <ref> [8] </ref>) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction.
Reference: [9] <author> T. Lewis, </author> <title> editor. Object-Oriented Application Frameworks. </title> <type> Manning, </type> <year> 1995. </year> <note> ISBN 1-884777-06-6. </note>
Reference-contexts: Introduction Current multimedia systems are complex. They span many areas (e.g., music, graphics, real-time processing) and have to scale in several different directions (e.g., number of processing nodes in a distributed environment, number of continuous-media streams). Consequently, various techniques that emphasize reuse (e.g., application frameworks <ref> [1, 5, 9] </ref>, design patterns [4, 2], software components [8]) and provide scalable software solutions are attracting the interest of the industry. In this paper we present a component-based model applicable to continuous-media processing. The model is based on four software patterns that express expert knowledge about software construction. <p> The code is usually subject to instrumentation and developers fine-tune the critical parts. Although the size of the processing partition can be smaller than the control partition (50%-80% of an interactive application is devoted to user interface aspects <ref> [9] </ref>), the code executes many times a second (e.g., every 33ms for a rate of 30 frames/second) and most of the running time of an application is spent here.
Reference: [10] <author> C. J. Lindblad. </author> <title> A programming system for the dynamic manipulation of temporally sensitive data. </title> <type> Technical Re port 637, </type> <institution> Massachutes Institute of Technology, </institution> <month> August </month> <year> 1994. </year> <institution> Laboratory for Computer Science. </institution>
Reference-contexts: It facilitates the rise of end-user programming, automation and software components and emphasizes reuse at the module level. Users that have knowledge only about the application domain create new applications by simply connecting modules, without performing any programming <ref> [10, 17] </ref>. Sometimes visual 1 In this context, module is any processing unit within the application domain. flow architecture. programming tools or scripting languages [7] assist the creation of module networks. <p> It is used to send notification messages from a renderer (sink). All components of the architecture recognize a special asynchronous event which requires graceful flushing of old data, followed by resynchronization. This pattern is also employed by the Berkeley continuous-media toolkit [7] and the VuSys-tem <ref> [10] </ref>. vI m p l e m e n t a t i o n n o t e s A flexible implementation solution is to regard the payload as a composite message. <p> However, the shared resource requires the additional overhead typically associated with synchronization problemsmanaging the critical sections. Shared memory is not necessarily available if the modules are located across hardware boundaries. vE x a m p l e s The payload passing protocol in the VuSystem <ref> [10] </ref> has the following requirements: (1) reduced latency, which is equivalent to no buffering; (2) feed-back to upstream modules; and (3) no multi-threading (the VuSys-tem runs as a single-threaded process). Payloads are passed with one function call and the timing constraints are propagated through back-pressure. <p> The processing and control partitions are part of the same application and the inherent coupling between them cannot be overlooked. However, they can have different architectures and designs. As long as the overhead associated with inter-partition communication is small, they can even be implemented in different programming languages <ref> [10] </ref>. Removing QoS monitoring and control from the processing partition and localizing it within the control partition increases flexibility and improves cohesion within the control partition. The separation of processing and control also enables experimenting with and accommodating new QoS parameters without disrupting media processing. <p> Factoring out the QoS code and localizing it within this partition facilitates scaling with the number of QoS parameters. User interface code can be generated automatically by software tools and has to cover a large number of possible actions which cannot be determined in advance <ref> [10] </ref>. Because it has to handle relatively infrequent events generated by the processing partition or corresponding to user actions, performance is not the main issue. Rather, ease of programming and extensibility are essential requirements. <p> The processing partition is CPU intensive and consists of slave processes which perform frame encoding. Other examples include ActiveMovie [12], VuSystem <ref> [10] </ref> and the prototype from [11]. vI m p l e m e n t a t i o n n o t e s Inter-partition communication is bidirectional, and the exchange of information across the partition boundary is small compared to the traffic within the processing partition.
Reference: [11] <author> D.-A. Manolescu. </author> <title> Algebraic model and object-oriented ar chitecture for hyper-media documents. </title> <type> Master's thesis, </type> <institution> Uni versity of Illinois at Urbana-Champaign, </institution> <year> 1997. </year>
Reference-contexts: The processing partition is CPU intensive and consists of slave processes which perform frame encoding. Other examples include ActiveMovie [12], VuSystem [10] and the prototype from <ref> [11] </ref>. vI m p l e m e n t a t i o n n o t e s Inter-partition communication is bidirectional, and the exchange of information across the partition boundary is small compared to the traffic within the processing partition.
Reference: [12] <institution> Microsoft Corporation, </institution> <address> Seattle, WA. </address> <note> Active Movie Software Development Kit version 1.0. http://www.microsoft.com/devonly/tech/amov1doc/. </note>
Reference-contexts: The decoding time for a JPEG frame is within 5% of the time required by the IJG decoder. Similarly, the MPEG frame rate is at most 10% lower than the Berkeley player. This analysis shows that reusable, high-performance solutions are possible with today's technology. Other examples include ActiveMovie <ref> [12] </ref> and the Berkeley Continuous-Media Toolkit [7]. vI m p l e m e n t a t i o n n o t e s This section follows the guidelines from [15]. <p> Deep copies have individual descriptors and data components. To increase efficiency, they can be implemented as copy-on-write. The change of ownership is more difficult if the communicating modules reside across hardware boundaries. vE x a m p l e s Microsoft ActiveMovie <ref> [12] </ref>, one of the most recent media flow architectures, allows users to play digital movies and sound encoded in various formats. In ActiveMovie, payloads are either media samples or QoS data. Media data originates at the source and is passed downstream. <p> The processing partition is CPU intensive and consists of slave processes which perform frame encoding. Other examples include ActiveMovie <ref> [12] </ref>, VuSystem [10] and the prototype from [11]. vI m p l e m e n t a t i o n n o t e s Inter-partition communication is bidirectional, and the exchange of information across the partition boundary is small compared to the traffic within the processing partition.
Reference: [13] <author> M. Muhlhauser and J. Gecsey. </author> <title> Services, frameworks, and paradigms for distributed multimedia applications. </title> <journal> IEEE Multimedia, </journal> <volume> 3(3), </volume> <month> Fall </month> <year> 1996. </year>
Reference-contexts: Sometimes visual 1 In this context, module is any processing unit within the application domain. flow architecture. programming tools or scripting languages [7] assist the creation of module networks. Because the interaction mechanism between modules is fairly simple, media flow is suitable for multimedia frameworks <ref> [13] </ref>. vL i a b i l i t i e s Media flow is not a good choice for applications with dynamic control flow or many feedback loops. For instances where the overhead of inter-module communication is too high, a different architectural choice might be a better solution.
Reference: [14] <author> K. Nahrstedt and J. M. Smith. </author> <title> The QoS broker. </title> <journal> IEEE Multi media, </journal> <volume> 2(1), </volume> <month> Spring </month> <year> 1995. </year>
Reference-contexts: This is a user configurable clock that abstracts the time and encapsulates a mapping from real time to application time. The LTS schedules the continuous-media processing within the processing partition. QoS monitoring and management is performed by the QoS broker <ref> [14] </ref>. Factoring out the QoS code and localizing it within this partition facilitates scaling with the number of QoS parameters. User interface code can be generated automatically by software tools and has to cover a large number of possible actions which cannot be determined in advance [10].
Reference: [15] <author> E. J. Posnak, R. G. Lavender, and H. M. Vin. </author> <title> Adaptive pipeline: an object structural pattern for adaptive applica tions. </title> <booktitle> In The 3rd Pattern Languages of Programming con ference, </booktitle> <address> Monticello, IL, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Systems employing these patterns scale well in several dimensions: (1) media transformations, (2) number of processors, (3) number of data streams, (4) number of possible configurations, (5) media types, and (6) processing and communication requirements. We begin with the media flow architecture which is extremely suitable for continuous-media processing <ref> [15, 17] </ref>. In the payloads pattern, we describe a mechanism for encapsulating different types of informatione.g., qual ity of service (QoS) parameters, continuous-media data, event notificationswithin messages. The abstraction increases flexibility and ensures scalability with the number of streams and media types. <p> Filters without internal state can be replaced while the system is running. Different implementations of any stateless filter can be exchanged at runtime to adjust the resource cost and quality characteristics such that the QoS requirements are maintained <ref> [15] </ref>. Consequently, the dynamic composition of filters allows an application to (1) adjust the resource consumption of the system at runtime; and (2) adapt to different computing and communications environments as well as changes in resource availability. <p> Static composition provides the underlying application (e.g., compiler) with enough information to collapse a sequence of modules into a functionally equivalent primitive module, reducing the overhead of inter-module communication <ref> [15] </ref>. A good balance between the use of static and dynamic binding of modules allows for efficient implementations while maintaining a modular, configurable architecture. vE x a m p l e s The media-flow architecture is used by the Presentation Processing Engine (PPE) framework. <p> This analysis shows that reusable, high-performance solutions are possible with today's technology. Other examples include ActiveMovie [12] and the Berkeley Continuous-Media Toolkit [7]. vI m p l e m e n t a t i o n n o t e s This section follows the guidelines from <ref> [15] </ref>. Processing modules inherit an input interface from PushInput and an output interface from PushOutputthe Push prefix is explained in Section 3. PushInputFigure 2is an abstract class that determines the input data type. Subclasses implement the Put () method to process the input data and pass it downstream.
Reference: [16] <author> E. J. Posnak, R. G. Lavender, and H. M. Vin. </author> <title> Presenta tion processing mechanisms for adaptive applications. </title> <booktitle> In Proc. Multimedia Computing and Networking, </booktitle> <address> San Jose, CA, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: For example, JPEG, MPEG1 and MPEG2 decoders can be constructed by parameterizing the architecture with specific algorithms <ref> [16] </ref>. vB e n e f i t s The media flow architecture ensures scalability in several dimensions: number of processing modules, processors, data streams, possible configurations and media types; and processing requirements.
Reference: [17] <author> E. J. Posnak, R. G. Lavender, and H. M. Vin. </author> <title> An adaptive framework for developing multimedia software components. </title> <journal> Communications of the ACM, </journal> <volume> 40(10), </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: Systems employing these patterns scale well in several dimensions: (1) media transformations, (2) number of processors, (3) number of data streams, (4) number of possible configurations, (5) media types, and (6) processing and communication requirements. We begin with the media flow architecture which is extremely suitable for continuous-media processing <ref> [15, 17] </ref>. In the payloads pattern, we describe a mechanism for encapsulating different types of informatione.g., qual ity of service (QoS) parameters, continuous-media data, event notificationswithin messages. The abstraction increases flexibility and ensures scalability with the number of streams and media types. <p> It facilitates the rise of end-user programming, automation and software components and emphasizes reuse at the module level. Users that have knowledge only about the application domain create new applications by simply connecting modules, without performing any programming <ref> [10, 17] </ref>. Sometimes visual 1 In this context, module is any processing unit within the application domain. flow architecture. programming tools or scripting languages [7] assist the creation of module networks. <p> A good balance between the use of static and dynamic binding of modules allows for efficient implementations while maintaining a modular, configurable architecture. vE x a m p l e s The media-flow architecture is used by the Presentation Processing Engine (PPE) framework. Pos--nak et al <ref> [17] </ref> have used the PPE to build JPEG and MPEG players. They have reported both design and code reuse. When using the PPE framework, a media player plug-in for Netscape required a few lines of Tcl and little domain expertise. <p> Payloads are passed with one function call and the timing constraints are propagated through back-pressure. By temporarily refusing a payload, a downstream module slows down upstream processing. The mechanism is simple and does not require multi-threading. Other examples include the Presentation Processing Engine <ref> [17] </ref> and the Java Media Framework. vI m p l e m e n t a t i o n n o t e s Figure 2 shows a push mechanism in the context of media flow architectures. Computation is triggered by calling the Put () method of the source.
Reference: [18] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8):18971910, </volume> <month> October </month> <year> 1984. </year>
Reference-contexts: To prevent data loss, the downstream module employs buffers to queue the incoming payloads. However, buffers (1) require additional scheduling policies, (2) introduce unpredictable delays and (3) are not viable if the payloads have large memory footprints. The push protocol can also use buffers for flow control <ref> [18] </ref>. A high water mark limits the amount of payloads that can be stored in the buffer; the upstream module does not place data in the queue above this limit. When the queue exceeds its high water mark, the filter sets a flag and the upstream module stops sending data.
Reference: [19] <author> R. Steinmetz and K. Nahrstedt. </author> <title> Multimedia: Comput ing, Communications & Applications. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year> <note> ISBN 0-13-324435-0. </note>
Reference-contexts: Rather, ease of programming and extensibility are essential requirements. In media flow architectures, the control partition also arranges filters to operate cooperatively, without imposing centralized synchronization control. The processing partition contains the code that performs media data processing according to the typical re quirements for continuous-media applications <ref> [19] </ref>. This partition does not take into account any aspects of user interaction and the focus is only on performance (e.g., maintaining a set of QoS parameters, which are reported to the control partition). The code is usually subject to instrumentation and developers fine-tune the critical parts.
References-found: 19

