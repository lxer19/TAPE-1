URL: http://www.cs.wisc.edu/~cs640-1/papers/corbaOver.ps
Refering-URL: http://www.cs.wisc.edu/~cs640-1/740.syllabus.html
Root-URL: http://www.cs.wisc.edu
Email: vinoski@ch.hp.com  
Title: Distributed Object Computing With CORBA ORB Core Interface Definition Language Dynamic Invocation Interface Interface Repository
Author: Steve Vinoski 
Note: 1.0 Introduction The CORBA is composed of five major components:  those developed in C++.  
Address: 300 Apollo Drive Chelmsford, MA 01824  
Affiliation: Hewlett-Packard Company Distributed Computing Program  
Abstract: This paper was originally published in the July/August 1993 issue of C++ Report magazine. The Object Management Group (OMG) was formed in 1989 with the purpose of creating standards allowing for the interoperability and portability of distributed object-oriented (OO) applications. Unlike the Open Software Foundation (OSF), the OMG does not actually produce software, only specifications. These specifications are created using ideas and technology from OMG members who respond to Requests For Information (RFI) and Requests For Proposals (RFP) issued by the OMG. A strength of this approach is that most of the major players in the commercial distributed OO computing arena are among the several hundred companies that belong to the OMG. The OMG Object Management Architecture (OMA) attempts to define, at a high level of abstraction, the various facilities necessary for distributed OO computing. The core of the OMA is the Object Request Broker (ORB), a mechanism that provides transparency of object location, activation, and communication. In 1991 the OMG published revision 1.1 of the Common Object Request Broker Architecture (CORBA) specification, a concrete description of the interfaces and services that must be provided by compliant ORBs [1]. Since then, many OMG member companies have either started shipping or have announced plans to ship products based on the CORBA specification. 
Abstract-found: 1
Intro-found: 0
Reference: [1] <editor> The Common Object Request Broker: </editor> <title> Architecture and Specification, OMG TC Document Number 91.12.1, Revision 1.1, </title> <month> December 6, </month> <year> 1991. </year>
Reference-contexts: In 1991 the OMG published revision 1.1 of the Common Object Request Broker Architecture (CORBA) specification, a concrete description of the interfaces and services that must be provided by compliant ORBs <ref> [1] </ref>. Since then, many OMG member companies have either started shipping or have announced plans to ship products based on the CORBA specification.
Reference: [2] <institution> C++ Language Mapping Request For Proposals, OMG TC Document Number 92.12.11, </institution> <year> 1992. </year>
Reference-contexts: The next IDL language binding to be specified by CORBA will be C++. In December 1992 the OMG issued a RFP for C++ language bindings for IDL, and they expect to issue a final decision on such a binding in December 1993 <ref> [2] </ref>. The RFP states that responses are free to use any C++ features as defined in Stroustrups The C++ Programming Language, Second Edition (presumably referring to the reference manual portion of the book), including templates and exceptions [3].
Reference: [3] <author> Stroustrup, Bjarne. </author> <title> The C++ Programming Language, Second Edition, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: The RFP states that responses are free to use any C++ features as defined in Stroustrups The C++ Programming Language, Second Edition (presumably referring to the reference manual portion of the book), including templates and exceptions <ref> [3] </ref>. What might a C++ language mapping for CORBA IDL look like? Hewlett-Packard Company, IONA Technologies Ltd., and SunSoft, Inc. (a division of Sun Microsystems, Inc.) have jointly developed a CORBA IDL C++ mapping that attempts to make CORBA objects look as much like normal C++ objects as possible.
Reference: [4] <author> Don Vines and Zen Kishimoto, </author> <title> "Smalltalks Runtime Type Support For C++", </title> <type> C++ Report 5(1) </type> <pages> 44-52, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Our experiences with such an IDL-to-C++ mapping have shown the need to be able to typecast object references for base interfaces to those for derived interfaces (others have described similar findings <ref> [4] </ref>). This is ordinarily frowned upon for typical C++ programming, but for distributed programming it is sometimes a necessity because the real type of the object may be unknown in some parts of the system. Downcasting or narrowing object references can be done in several ways.
Reference: [5] <author> Gorlen, K., S. Orlow, and P. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Downcasting or narrowing object references can be done in several ways. An approach familiar to C++ users is to provide typesafe casting by augmenting objects with both a type identification field and member functions that 5 use it, as is done in Keith Gorlens NIH Class Library <ref> [5] </ref>. An alternative to providing a downcasting mechanism for surrogates might appear to be the run-time type identification (RTTI) mechanism recently voted into the C++ language by the ANSI X3J16 and ISO WG21 standardization committees [6]. The RTTI mechanism allows downcasting to be performed via the dynamic_cast&lt;T*&gt; operator.
Reference: [6] <author> Bjarne Stroustrup and Dmitry Lenkov, </author> <title> "Run-Time Type Identification for C++ (Revised yet again)", document X3J16/92-0121, </title> <institution> American National Standards Institute Accredited Standards Committee X3, </institution> <address> Washington, D.C., </address> <year> 1992. </year>
Reference-contexts: An alternative to providing a downcasting mechanism for surrogates might appear to be the run-time type identification (RTTI) mechanism recently voted into the C++ language by the ANSI X3J16 and ISO WG21 standardization committees <ref> [6] </ref>. The RTTI mechanism allows downcasting to be performed via the dynamic_cast&lt;T*&gt; operator.
Reference: [7] <author> Ball, Michael, </author> <title> "Inside Templates: Implementing C++ Strategies", </title> <type> C++ Report 4(7) </type> <pages> 36-40, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: There are several good reasons for this choice: the CORBA specification is intended to be language-independent; using a subset of C++ for IDL lessens the chances of CORBA being widely accepted in the distributed OO programming com munity C++ is known to be difficult to parse <ref> [7] </ref>; using a subset of C++ might ultimately limit the number of IDL compiler implementations available some features of C++, notably pointers, make marshaling and unmarshaling of data difficult any declarative subset of C++ chosen would most likely be different enough from normal C++ so as to be confusing to experienced
Reference: [8] <institution> Object Request Broker 2.0 Extensions Request For Information, OMG TC Document Number 92.12.10, </institution> <year> 1992. </year>
Reference-contexts: Subsequently, the OMG issued a RFI for ORB 2.0 extensions <ref> [8] </ref>. In particular, the OMG is looking for information on how to fill in portions of CORBA 1.1 that were intentionally left incomplete, such as parts of the specification of the Interface Repository.
References-found: 8

