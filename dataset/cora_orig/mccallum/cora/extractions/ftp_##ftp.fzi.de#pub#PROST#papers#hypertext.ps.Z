URL: ftp://ftp.fzi.de/pub/PROST/papers/hypertext.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Email: e-mail: rueping@fzi.de  
Title: Hypertext A Case Study of Formal Object-Oriented Software Development  
Author: Andreas Rping 
Address: Haid-und-Neu-Strae 10-14 D-76131 Karlsruhe  
Affiliation: Forschungszentrum Informatik (FZI) Bereich Programmstrukturen  
Abstract: Formal object-oriented software development integrates the techniques of object-orientation and formal methods and thus combines the advantages of both. This paper presents a hypertext system as a case study of formal object-oriented software development. We describe the development of a hypertext system, beginning with informal steps towards an object-oriented model and concluding with the application of formal methods. The case study covers object-oriented analysis and design, formal specification, consistency proof of the specification, implementation, and correctness proof of the implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Timothy Budd. </author> <title> An Introduction to Object-Oriented Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: We conclude with some evaluating remarks on our case study. 2 Analysis and Design We start with the requirement analysis and modelling of the hypertext system. Throughout these development stages, we apply Responsibility-Driven Design, the approach introduced by Rebecca Wirfs-Brock et al. (cf. <ref> [1] </ref>, [15]). 2.1 Requirement Specification The following is a brief requirement specification of our hypertext system - informal and as general as possible. A hypertext system is a collection of information units that are organized not sequentially, but in a graph-like structure.
Reference: [2] <author> C.A.R. Hoare. </author> <title> Proof of Correctness of Data Representations, </title> <journal> in Acta Informatica No. </journal> <volume> 1, </volume> <pages> pp. 270-281. </pages> <publisher> Springer Verlag, </publisher> <year> 1972. </year>
Reference-contexts: We demonstrate two different proof techniques when proving the following properties: Consistency Consistency of a specification means that the invariants hold after initialization and before and after the execution of a method. To prove consistency, we apply a technique based on weakest preconditions as described in <ref> [2] </ref>, [3], [7], and [11]. For our specification, consistency proofs can only be given module-wise, not class-wise. This is due to the fact that we have objects that are global within a module. Invariants can rely on such global objects. <p> It occurs in two different situations. First, conformance is the intended relationship if a class inherits from another. Second, conformance is required between a specification class and its implementation. We make again use of a verification technique based on weakest preconditions (cf. <ref> [2] </ref>, [3], [7], [11]).
Reference: [3] <author> E. W. Dijkstra (Ed.). </author> <title> Formal Development of Programs and Proofs. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We demonstrate two different proof techniques when proving the following properties: Consistency Consistency of a specification means that the invariants hold after initialization and before and after the execution of a method. To prove consistency, we apply a technique based on weakest preconditions as described in [2], <ref> [3] </ref>, [7], and [11]. For our specification, consistency proofs can only be given module-wise, not class-wise. This is due to the fact that we have objects that are global within a module. Invariants can rely on such global objects. <p> It occurs in two different situations. First, conformance is the intended relationship if a class inherits from another. Second, conformance is required between a specification class and its implementation. We make again use of a verification technique based on weakest preconditions (cf. [2], <ref> [3] </ref>, [7], [11]).
Reference: [4] <author> A. Goldberg, D. Robson. </author> <title> Smalltalk-80 The Language and its Implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We can group related classes and we can identify subclass / superclass relationships. As with many interactive software systems, grouping the candidate classes into the three categories Model, View, Controller seems appropriate, similar (although not equal) to a commonly used design pattern (cf. <ref> [4] </ref>). Model: Hypertext, Node, Link, Information, Text, Image The model includes all classes that provide the real data, in contrast to temporary information or data that is merely essential for the representation of the model. View: Representation All classes that deal with the representation of the model are view classes.
Reference: [5] <author> Danny B. Lange. </author> <title> A Formal Approach to Hypertext Using Post-Prototype Formal Specification, </title> <editor> in D. Bjrner, C.A.R. Hoare, H. Langmaack (Eds.), </editor> <booktitle> VDM 90 - VDM and Z - Formal Methods in Software Development, </booktitle> <pages> pp. 99-119. </pages> <booktitle> Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 428. </volume> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Verification leads to proofs of certain properties of a program such as consistency or semantically meaningful class relationships. In this paper we present a hypertext system as a case study of formal object-oriented software development. The example was originally presented in <ref> [5] </ref>. With this case study we demonstrate how the integration of object-orientation and formal methods combines the advantages of both. 2 Hypertext We begin the development of the hypertext system with a requirement analysis, followed by object-oriented modelling and design.
Reference: [6] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Attributes, Methods and Preconditions For each class the necessary attributes and methods are declared. A method declaration consists of a header and a body. The header defines the signature of a method and possibly a precondition (cf. <ref> [6] </ref>). The body contains specification statements. Specification statements A specification statement is a statement that is not required to be executable. Specification statements can be used to describe the desired result of a statement, for instance by means of a logical predicate. Specification statements can be non-deterministic.
Reference: [7] <author> Carroll Morgan. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: We demonstrate two different proof techniques when proving the following properties: Consistency Consistency of a specification means that the invariants hold after initialization and before and after the execution of a method. To prove consistency, we apply a technique based on weakest preconditions as described in [2], [3], <ref> [7] </ref>, and [11]. For our specification, consistency proofs can only be given module-wise, not class-wise. This is due to the fact that we have objects that are global within a module. Invariants can rely on such global objects. <p> It occurs in two different situations. First, conformance is the intended relationship if a class inherits from another. Second, conformance is required between a specification class and its implementation. We make again use of a verification technique based on weakest preconditions (cf. [2], [3], <ref> [7] </ref>, [11]).
Reference: [8] <author> Andreas Rping, Franz Weber, Walter Zimmer. </author> <title> Demonstrating Coherent Design - A Data Structure Catalogue, </title> <booktitle> in Proceedings of TOOLS USA 93 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall. To appear. </publisher>
Reference-contexts: Different kinds of classes are distinguished. The main distinction is between abstract classes for the specification and concrete classes for the implementation. For a more detailed discussion of different kinds of classes see <ref> [8] </ref> and [14]. Abstract classes specify behaviour, mainly by specification statements. No objects can be instantiated from an abstract class; however, the behaviour described by an abstract class can be inherited by other, possibly concrete, classes. Concrete classes implement the behaviour and the state space of their objects.
Reference: [9] <author> Andreas Rping. Coffer: </author> <title> Methodology and Language. </title> <type> Technical Report, </type> <institution> Forschungs-zentrum Informatik Karlsruhe. </institution> <note> To appear. 28 Hypertext </note>
Reference-contexts: Since we concentrate on the group Model, our specification will only consist of one module called Hypertext_Model to which all mentioned classes belong. 3.2 Specification Techniques The specification we give is written in Coffer (cf. <ref> [9] </ref>), a state-based, object-oriented language which is built upon the following specification techniques. Modules, Classes, and Instantiation Andreas Rping 13 A specification in Coffer consists of several modules which all contain one or more classes. Objects are global within a module; they are, however, not global within a whole system.
Reference: [10] <author> Markku Sakkinen. </author> <title> Disciplined Inheritance, </title> <editor> in Stephen Cook (Ed.), </editor> <booktitle> ECOOP 89 - European Conference on Object-Oriented Programming, </booktitle> <pages> pp. 39-56. </pages> <booktitle> British Computer Society Workshop Series. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: These bring about several methodological advantages. Object-orientation is considered to support in particular comprehensibility, correctness, extensibility, and reusability of software. However, a sound semantic basis for these mechanisms is required because they can then be used more precisely (cf. <ref> [10] </ref>). Formal methods cover various techniques that all exploit the advantages of formal semantics. These techniques include formal specification and verification. Formal specification allows for the precise description of a program or a part of it.
Reference: [11] <author> Emil Sekerinski. </author> <title> A Calculus for Predicative Programming, </title> <editor> in R. S. Bird, C. C. Morgan, J. C. P. Woodcock (Eds.), </editor> <booktitle> Mathematics of Program Construction. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 669. </volume> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: To prove consistency, we apply a technique based on weakest preconditions as described in [2], [3], [7], and <ref> [11] </ref>. For our specification, consistency proofs can only be given module-wise, not class-wise. This is due to the fact that we have objects that are global within a module. Invariants can rely on such global objects. <p> It occurs in two different situations. First, conformance is the intended relationship if a class inherits from another. Second, conformance is required between a specification class and its implementation. We make again use of a verification technique based on weakest preconditions (cf. [2], [3], [7], <ref> [11] </ref>).
Reference: [12] <author> Emil Sekerinski. </author> <title> A Behavioral View of Object Types. </title> <type> Technical Report 7-93, </type> <institution> Forschungs-zentrum Informatik Karlsruhe, </institution> <year> 1992. </year>
Reference-contexts: A class conforms to its superclass if an object of the superclass can always be replaced by an object of the subclass. For a more precise definition of subtyping and other semantic class relationships see <ref> [12] </ref> and [14]. Attributes, Methods and Preconditions For each class the necessary attributes and methods are declared. A method declaration consists of a header and a body. The header defines the signature of a method and possibly a precondition (cf. [6]). The body contains specification statements.
Reference: [13] <author> Clemens A. Szyperski. </author> <title> Import Is not Inheritance - Why We Need Both: Modules and Classes, </title> <editor> in Ole Lehrmann Madsen (Ed.), </editor> <booktitle> ECOOP 92 - European Conference on Object-Oriented Programming, </booktitle> <pages> pp. 19-32. </pages> <booktitle> Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 615. </volume> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: First, they are necessary to deal with object identities and second, conformance often holds only between modules and not between single classes. Furthermore, invariants often refer to objects of different classes and are thus better kept in a module than in a class (cf. <ref> [13] </ref>). Future work will also include the development of a more precise understanding of modules, their interfaces, and relationships between modules. Acknowledgements Several colleagues made valuable contributions to this paper.
Reference: [14] <author> Franz Weber. </author> <title> Getting Class Correctness and System Correctness Equivalent - How to Get Covariance Right, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 8 - Technology of Object-Oriented Languages and Systems, </booktitle> <pages> pp. 199-213. </pages> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Different kinds of classes are distinguished. The main distinction is between abstract classes for the specification and concrete classes for the implementation. For a more detailed discussion of different kinds of classes see [8] and <ref> [14] </ref>. Abstract classes specify behaviour, mainly by specification statements. No objects can be instantiated from an abstract class; however, the behaviour described by an abstract class can be inherited by other, possibly concrete, classes. Concrete classes implement the behaviour and the state space of their objects. <p> A class conforms to its superclass if an object of the superclass can always be replaced by an object of the subclass. For a more precise definition of subtyping and other semantic class relationships see [12] and <ref> [14] </ref>. Attributes, Methods and Preconditions For each class the necessary attributes and methods are declared. A method declaration consists of a header and a body. The header defines the signature of a method and possibly a precondition (cf. [6]). The body contains specification statements.
Reference: [15] <author> Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: We conclude with some evaluating remarks on our case study. 2 Analysis and Design We start with the requirement analysis and modelling of the hypertext system. Throughout these development stages, we apply Responsibility-Driven Design, the approach introduced by Rebecca Wirfs-Brock et al. (cf. [1], <ref> [15] </ref>). 2.1 Requirement Specification The following is a brief requirement specification of our hypertext system - informal and as general as possible. A hypertext system is a collection of information units that are organized not sequentially, but in a graph-like structure. <p> A first list of candidate classes can be derived from the requirement specification. Noun phrases are likely to become items in our model. Thus we obtain the following list from the above requirement specification. Some of these candidates can easily be discarded. We apply the following rules from <ref> [15] </ref>. Do not use more than one word for one concept. We can therefore discard Information Unit, Graph-Like Structure, and System, since Information, Graph, and Hypertext System will do. Furthermore, Hypertext System is renamed to simply Hypertext. Model the values of attributes of objects, but not the attributes themselves. <p> This includes the class name, the super and subclasses, and a brief informal description (cf. Figure 2). At later stages of the design we will add further information, such as responsibilities, collaborations, and the like. 2.3 Modelling the Hypertext System: Responsibilities In <ref> [15] </ref>, Rebecca Wirfs-Brock et al. state: Responsibilities are meant to convey a sense of the purpose of an object and its place in the system. The responsibilities of an object are all the services it provides for all of the contracts it supports. <p> Such an inheritance hierarchy is meant to provide us with a meaningful structure for our model and thus with a more global and precise understanding of our design. Rebecca Wirfs-Brock et al. (cf. <ref> [15] </ref>) recommend several tools that are helpful with the analysis of inheritance relationships: hierarchy graphs, Venn diagrams, contracts, collaborations graphs. In our updated model there are no subclass / superclass relationships between the classes we have set up. <p> Superclasses: - Subclasses: - Group: Controller communicate with the user To navigate through a hypertext or to change the contents of a hypertext, the user can interact with it. pass commands to the model Hypert., Node pass display changes to the view Representation Andreas Rping 9 to these requests (cf. <ref> [15] </ref>). Contracts are usually based on responsibilities that a class does not have for itself but that is needed for a collaboration to be fulfilled. nested boxes stand for sub and superclasses. An arrow between two classes represents a collaboration; the arrow ends in a semicircle which represents a contract. <p> Hence, we do not follow the approach by Rebecca Wirfs-Brock et al. concerning specifications. A formal specification of our hypertext system is presented in the next section. Implementation Software development concludes with an implementation. In <ref> [15] </ref>, several guidelines are presented on how to get an implementation from the design model. In contrast to this, we make an extended use of our formal specification when we give an implementation of the hypertext system.
References-found: 15

