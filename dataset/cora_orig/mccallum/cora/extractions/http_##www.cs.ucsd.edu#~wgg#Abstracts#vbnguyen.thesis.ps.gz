URL: http://www.cs.ucsd.edu/~wgg/Abstracts/vbnguyen.thesis.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/vbnguyen.thesis.html
Root-URL: http://www.cs.ucsd.edu
Title: Impact of Adding Customizibility On Software Architecture: A Case Study  
Author: Van Bich Nguyen Professor William G. Griswold, Chairperson Professor Larry Carter Professor Dean M. Tullsen 
Degree: A thesis submitted in partial satisfaction of the requirements for the degree Master of Science in Computer Science by  Committee in charge:  
Date: 1997  
Affiliation: UNIVERSITY OF CALIFORNIA, SAN DIEGO  
Abstract-found: 0
Intro-found: 1
Reference: [Bentley, 1986] <author> Bentley, J., </author> <title> editor (1986). Programming Pearls. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: The Tk tree widget provides a function that takes a node pointer and removes that node and its children | the rmLink function. 1 The idea of representing a problem in its input, output, and constraint format is taken from <ref> [Bentley, 1986] </ref>. 16 Figure II.2: Depth elision in Chen's paradigm with n=2. Dotted nodes are candidates of deletion. Shaded nodes are nodes at depth 2. Arcs are lines to connect function nodes to nodes at depth 2. His solution is intuitive and simple.
Reference: [Bowdidge, 1995] <author> Bowdidge, R. W. </author> <year> (1995). </year> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD thesis, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering. </institution> <note> Technical Report CS95-457. </note>
Reference-contexts: Programmers often need to browse through source code to learn about the system to scope the effects of their restructuring tasks before they can do the actual restructuring. Bowdidge's star diagram is a visualization tool to assist in understanding and restructuring programs <ref> [Bowdidge, 1995] </ref>. The star diagram builds a tree-like graphical representation of variable's definitions and uses in the software. Chen extended the original star diagram to work with large C programs; a major part of his work involved in improving the viewability of large programs [Chen, 1996]. <p> Bowdidge invented the star diagram concept to help programmers in performing their meaning-preserving restructuring tasks and to overcome the above limitations of text searching tools <ref> [Bowdidge, 1995] </ref>. The star diagram is a tree 3 like graphical view of a data structure. The root represents the variable or data structure being encapsulated. Children of the root are direct references of the root in the program. <p> The star diagram generated for the global variable current buffer in Emacs has 5172 nodes, and expands in twenty-six (26) 8.5x11 pages in height and three pages in width <ref> [Bowdidge, 1995] </ref>. Although depth elision on the star diagram of the current buffer variable reduces 50% in number of nodes and 34% in overall height [Chen, 1996], the star diagram's viewability can be further improved. <p> Chapter V Conclusion Software maintenance is an expensive and difficult process. One way to lower software maintenance cost is to restructure the existing system. The star diagram tool can be used to promote program understanding and manipulate the overall structure of a program <ref> [Bowdidge, 1995] </ref>. Thus, it eases the maintenance process, and reduces the overall cost. Chen extended the original star diagram tool to create a tool for planning a restructuring to work with large C programs [Chen, 1996].
Reference: [Brighton, 1993] <author> Brighton, A. </author> <year> (1993). </year> <note> Tktree widget. Copyright 1993. </note>
Reference-contexts: Visualized star diagram This component presents the star diagram in a tree-like graph using the Tk tree widget <ref> [Brighton, 1993] </ref>. It reads an internal star diagram to generate the corresponding Tk tree. To produce a tree-like graph appearance, it merges all identical function nodes into one node, and readjusts lines going from regular tree nodes to their new function node.
Reference: [Chen, 1996] <author> Chen, M. I. </author> <year> (1996). </year> <title> A tool for planning the restructuring of data abstractions in large systems. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering. </institution> <note> Technical Report CS96-472. </note>
Reference-contexts: The star diagram builds a tree-like graphical representation of variable's definitions and uses in the software. Chen extended the original star diagram to work with large C programs; a major part of his work involved in improving the viewability of large programs <ref> [Chen, 1996] </ref>. The new tool provides two elision mechanisms to reduce the size of the star diagram: depth elision and star arm trimming. Elision by depth significantly reduces the number of nodes, thus reducing width, and reduces the height of a star diagram. <p> Although depth elision on the star diagram of the current buffer variable reduces 50% in number of nodes and 34% in overall height <ref> [Chen, 1996] </ref>, the star diagram's viewability can be further improved. For instance, having file and function node elisions would be beneficial to the scalability of the star diagram when a variable belongs to many functions and files. <p> Because the star diagram tool is an interactive system, Chen needed to provide mappings from the visualization level (i.e., star diagram nodes) to its internal representation and its corresponding AST nodes. For example, programmers can view a star diagram node's corresponding source code <ref> [Chen, 1996] </ref>. This function requires three levels of mappings: (1) visualized star diagram node to its corresponding internal star diagram node, (2) internal star diagram node address to its corresponding AST nodes, and (3) AST nodes to the corresponding source code. <p> Thus, Chen's star diagram system was organized in a hybrid fashion (see figure II.1). The pipeline style architecture accommodates a simple and efficient star diagram generation engine as well as elision and trimming mechanisms <ref> [Chen, 1996] </ref>. The layered style was necessary for the mappings as described in the above paragraph. Chen's development stages guided his architecture. His architecture is described in detail in the following paragraphs. 13 Figure II.1: Chen's star diagram system. Boxes are components. <p> Once it reaches the root of the AST, one star arm or path of the star diagram has been completed. Similar computations from each new star arm are combined with existing star arms to create the "stacking" appearance of star diagram nodes <ref> [Chen, 1996] </ref>. This component also provides functions to map each internal star diagram node to its corresponding AST nodes. The function GenBySetOf takes a star node pointer, and gives a list of corresponding AST nodes. <p> Similarly, file nodes are handled the same way; function nodes are connected to their new file nodes. It adds surrounding boxes to tree nodes, and colors connecting lines to enhance visualization cues <ref> [Chen, 1996] </ref>. Information about each tree node such as the corresponding internal star diagram node's address, type, color, border, connecting lines, and parent node are stored using tags in the Tk widget. Tags are a simple Tk widget mechanism for storing a list of attributes of a canvas object. <p> Second, keep track of function nodes (i.e., querying all nodes of type function). Third, link back function nodes to their depth n nodes. Fourth, apply rmLink to depth n+1 nodes (see figure II.2). As he explained in <ref> [Chen, 1996] </ref>, this algorithm is also efficient as long as elision is not performed frequently. Traversing the AST to build the internal star diagram is more expensive than rebuilding the visualized star diagram. Therefore, it kept the internal star diagram unchanged, and regenerated the visualized star diagram. <p> For example, the depth of a node is a star node's position relative to the root node. A stacked node represents all nodes that have similar expressions, and the number of combined nodes is stored as its size <ref> [Chen, 1996] </ref>. As explained above, traversing and querying operations are efficient and easy to implement. In addition, the internal star diagram data is stable. <p> These procedures are based on Chen's label conventions defined in the label generator. His node label generator can be easily modified to customize the display of labels <ref> [Chen, 1996] </ref>. Thus, using label comparisons in our elision predicates is a quick and simple solution because querying function on label is already available, the label generator can be easily modified, and Tcl/Tk provides an efficient string matching mechanism. <p> Together with the star arm catalogue panel, star arm trimming is used as a planning mechanism (see section I.A.2). It was a separate functional task, thus different type of elision in Chen's system (see <ref> [Chen, 1996] </ref> for implementation details). In this section, we explain how we were able to combine trimming into our elision model. Trimming star arms By defining elision as a process of selective construction, we can also classify star arm trimming as a property-based elision. <p> IV.B.3 AST property-based elision Recall that stacked nodes represent more than one similar expression. The criterion to determine similar expressions is nodes that have the same labels <ref> [Chen, 1996] </ref>. Rules to generate star node's labels can be changed: programmers can modify the label generator to customize the display of labels in a C star diagram. For example, one might decide to combine all loop statements and generate 40 a general "iteration" label. <p> Thus, it eases the maintenance process, and reduces the overall cost. Chen extended the original star diagram tool to create a tool for planning a restructuring to work with large C programs <ref> [Chen, 1996] </ref>. One major part of Chen's work was to improve the viewability of a star diagram. His tool provided two user-controlled elision mechanisms to allow a programmer to scale the display of a star diagram: depth elision and star arm trimming.
Reference: [Garlan and Shaw, 1993] <author> Garlan, D. and Shaw, M. </author> <year> (1993). </year> <title> An introduction to software architecture. </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> volume 1, </volume> <pages> pages 1-39. </pages> <publisher> World Scientific, Singapore. </publisher>
Reference-contexts: The elision algorithm would be extremely complicated, thus difficult to modify when the elision set changes. We could not have a simple customizable layer for property-based elisions. In order to solve this problem, our first step was exploring our design space in order to identify the right architecture <ref> [Garlan and Shaw, 1993] </ref>. We took a different perspective on elision, and then reorganized the system to support our new elision paradigm. 21 22 III.A.1 New perspective on elision We noticed that the internal star diagram remains unchanged throughout a star diagram's lifetime. <p> It was also a natural way of building the tool in incremental development stages (see Section II.A.1). However, it does not offer the desired flexibility when the functional task grows larger or becomes more general. Thus, identifying the right architecture is essential <ref> [Garlan and Shaw, 1993] </ref>. The layer architecture helped us to utilize our system's functionality and build a more robust system.
Reference: [Griswold et al., 1996] <author> Griswold, W. G., Chen, M. I., Bowdidge, R. W., and Mor-genthaler, J. D. </author> <year> (1996). </year> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: Trimming star arms only reduces the height of a star diagram. Trimming star arms is also used as a planning mechanism. Bowdidge's and Chen's user studies suggest that providing more elisions is needed to make the star diagram more scalable <ref> [Griswold et al., 1996] </ref>. Their 1 2 user studies show that supporting function and file node elisions could produce a more compact layout. <p> A text searching tool such as grep helps programmers locate direct references of a data structure, but often includes irrelevant information, misses surrounding context, and misses cases such as indirect references <ref> [Griswold et al., 1996] </ref>. Bowdidge invented the star diagram concept to help programmers in performing their meaning-preserving restructuring tasks and to overcome the above limitations of text searching tools [Bowdidge, 1995]. The star diagram is a tree 3 like graphical view of a data structure. <p> Such restructuring decisions were time-consuming because specifying and performing a meaning-preserving transformation is expensive and should be delayed when uncertain. Third, support for a multiple-variable root node is essential. Abstract data types might have many components; in order to encapsulate them properly, they need to be viewed together <ref> [Griswold et al., 1996] </ref>. I.A.1 Viewability Chen's approach to improve viewability was to provide user-controlled elision mechanisms and record plans. It allowed programmers to hide uninteresting information and to focus on their restructuring tasks. <p> occurrences takes an AST node pointer; it traverses the AST to find all uses of the variable. getType occurrences also takes an AST node pointer; it traverses the AST to find all variables of the same type. getType occurrences is called when programmers choose to build a type-oriented star diagram <ref> [Griswold et al., 1996] </ref>. Otherwise, get occurrences is invoked. Internal star diagram This component generates a C star diagram tree for the selected root (s) using a C++ tree data structure representation. It uses either get occurrences or getType occurrences to populate a star diagram root set. <p> Our set of elision properties is based on the two categories of a node's properties (i.e., language constructs and star diagram attributes). It includes depth, file, function, statement, binary expression, unary 27 expression, stacked, and unstacked nodes. III.B.1 Motivations As mentioned in <ref> [Griswold et al., 1996] </ref>, file and function nodes take up a large amount of space in the diagram. Elision of file or function nodes produces a compact layout, thus greatly improving star diagram's viewability (see figures I.1 and III.3).
Reference: [Lawrence, 1989] <author> Lawrence, B. </author> <year> (1989). </year> <title> Omega [A complex, rogue-like game of dungeon exploration written and freely distributed by Lawrence Brothers.]. </title> <note> Copyright 1989. Available from Lawrence Brothers at brothers@paul.rutgers.edu. </note>
Reference-contexts: On the other hand, our tool might be more efficient because of the saving on time and space to construct the complete visualized star diagrams. We used two programs in our experiments. One was the Omega program, which has roughly 31,000 lines <ref> [Lawrence, 1989] </ref>. We selected the Objects global 32 33 variable, and applied a series of depth elisions: depth 1 to 10, with the number of nodes ranging from 160 to 283. The second program is GNU Emacs [Stallman, 1993]; Emacs has 127,000 lines of code.
Reference: [Lientz and Swanson, 1980] <author> Lientz, B. and Swanson, E. </author> <year> (1980). </year> <title> Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: Introduction Software readability and structure are degraded as it ages, and software maintenance is the most expensive phase in a software's life cycle <ref> [Lientz and Swanson, 1980] </ref>. Restructuring software is a much needed engineering task in maintaining a software system. It helps to improve software structure, thus lessening future maintenance cost.
Reference: [Morgenthaler and Griswold, 1995] <author> Morgenthaler, J. D. and Griswold, W. </author> <year> (1995). </year> <title> Program analysis for practical program restructuring. In Proceedings of the ICSE-17 Workshop on Program Transformations for Software Evolution. </title> <note> Proceedings available as Technical Report CS95-418,Department of Computer Science and Engineering, </note> <institution> University of California, </institution> <address> San Diego. 47 48 </address>
Reference-contexts: II.A Chen's Approach We describe Chen's solution to the elision problem in terms of his architecture and the characteristics of the elision problem itself. II.A.1 Architecture Chen's core work was to build star diagrams for large C programs. He used the AST engine implemented in C++ by Morgenthaler <ref> [Morgenthaler and Griswold, 1995] </ref>, and he chose Tcl/Tk as the graphical interface package to build his tool [Ousterhout, 1994]. Chen first built a C star diagram generator component to generate internal star diagrams.
Reference: [Oppermann and Simm, 1994] <author> Oppermann, R. and Simm, H. </author> <year> (1994). </year> <title> Adaptability: </title> <booktitle> User-initiated individualization. In Adaptive User Support: Ergonomic Design of Manually and Automatically Adaptable Software, </booktitle> <pages> pages 14-66. </pages> <publisher> Lawrence Erlbaum Associates, </publisher> <address> Hillsdale, NJ. </address>
Reference-contexts: Users can open more string entries if they have more than one 8 string expressions that they want to match. It is implemented as an adaptable elision function so that users can elide any type of nodes that is not included in the elision set <ref> [Oppermann and Simm, 1994] </ref>. We hypothesized that implementing this narrow set of elision features was simply a matter of extending Chen's elision paradigm. <p> For completeness, we provide stacked node elision; it is to remove nodes that represent more than one computation except for the root nodes. In order to have a flexible elision set, we want to have an adaptable elision so that programmers can tailor the elision to suit their needs <ref> [Oppermann and Simm, 1994] </ref>. We added a separate string elision mechanism that elides based on the label of nodes. Programmers can use this feature to elide any nodes whose labels match the specified string (see figure III.6). 28 Figure III.3: File and function node elisions on rooms array.
Reference: [Ousterhout, 1994] <author> Ousterhout, J. </author> <year> (1994). </year> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: II.A.1 Architecture Chen's core work was to build star diagrams for large C programs. He used the AST engine implemented in C++ by Morgenthaler [Morgenthaler and Griswold, 1995], and he chose Tcl/Tk as the graphical interface package to build his tool <ref> [Ousterhout, 1994] </ref>. Chen first built a C star diagram generator component to generate internal star diagrams. Then he implemented a visualized star diagram component to create the visualization representation of an internal star diagram. Chen's next major task was to implement depth elision and star arm 11 12 trimming. <p> Its elision predicate is STAR_getsize (currentNode) == 1. Language construct elisions. Since a node's label contains its language construct, elisions based on language construct are performed using label comparisons. We use the Tcl/Tk string matching mechanism to implement label comparisons <ref> [Ousterhout, 1994] </ref>. It is modeled after the file name pattern matching done by various UNIX shells. Each of the new language construct elision features such as file, function, statement, binary expression, and unary expression is implemented in different label comparison procedures.
Reference: [Parnas, 1972] <author> Parnas, D. L. </author> <year> (1972). </year> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058. </pages>
Reference-contexts: Data encapsulation is one useful restructuring activity; it helps to isolate code pertaining to a design decision into one module <ref> [Parnas, 1972] </ref>. However, data encapsulation can be a challenging task. Programmers often need to browse through source code eliminating unrelated information to find the data structure to be encapsulated and its relevant computations and to keep track of related information.
Reference: [Stallman, 1993] <author> Stallman, R. </author> <year> (1993). </year> <title> GNU Emacs (The extensible self-documenting text editor). Free Software Foundation, </title> <address> Cambridge, MA. </address> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: One of the examples that Chen and Bowdidge had used to test the star diagram tool is the GNU Emacs program <ref> [Stallman, 1993] </ref>. The star diagram generated for the global variable current buffer in Emacs has 5172 nodes, and expands in twenty-six (26) 8.5x11 pages in height and three pages in width [Bowdidge, 1995]. <p> One was the Omega program, which has roughly 31,000 lines [Lawrence, 1989]. We selected the Objects global 32 33 variable, and applied a series of depth elisions: depth 1 to 10, with the number of nodes ranging from 160 to 283. The second program is GNU Emacs <ref> [Stallman, 1993] </ref>; Emacs has 127,000 lines of code. We generated a star diagram for the current buffer data structure. We applied a series of depth elisions: depth 1 to 8, with the number of nodes ranging from 367 to 2605.
Reference: [Sullivan and Notkin, 1990] <author> Sullivan, K. J. and Notkin, D. </author> <year> (1990). </year> <title> Reconciling environment integration and component independence. </title> <booktitle> In Proceedings of the SIGSOFT '90 Fourth Symposium on Software Development Environments. </booktitle>
Reference-contexts: We would add another module to call the AST to build up information in the internal star diagram when needed. This module can be thought of as a mediator module to intervene between the internal star diagram and the AST modules <ref> [Sullivan and Notkin, 1990] </ref>. 42 In this chapter, we presented our tool's performance advantages on large C programs. We successfully eliminated the performance bottleneck in Chen's system (i.e., the regeneration of complete visualized star diagrams). We also presented a variety of possible extensions to our current star diagram system.
References-found: 14

