URL: ftp://ftp.cs.cornell.edu/pub/chandra/time.and.message.efficient.bari90.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/publications.html
Root-URL: 
Email: e-mail (chandra@cs.cornell.edu, sam@cs.cornell.edu)  
Title: Time and Message Efficient Reliable Broadcasts  
Author: Tushar Deepak Chandra Sam Toueg 
Address: Upson Hall,  Ithaca, New York 14853  
Affiliation: Department of Computer Science  Cornell University  
Abstract: This paper describes the first Reliable Broadcast algorithms that are simultaneously efficient in both time and messages. These algorithms tolerate crash and omission failures. Each Reliable Broadcast takes O(f) time and O(fn) messages, where f is the number of processes that actually fail during this broadcast and n is the total number of processes. In other words, each additional process that fails during a broadcast can increase the broadcast time by at most a constant, and the number of messages by at most O(n). The algorithm tolerant of crash failures requires f + 2 rounds. The one for general-omission failures requires 2f + 3 rounds.
Abstract-found: 1
Intro-found: 1
Reference: [AWH90] <author> Eugene Amdur, Sam Weber, and Vassos Hadzilacos. </author> <title> On the message com-plexity of binary byzantine agreement under crash failures. </title> <note> 1990. Submitted to Distributed Computing. </note>
Reference-contexts: For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur <ref> [Web89, AWH90, HH90] </ref>. In this paper, we present the first Reliable Broadcast algorithms that are both time and message efficient: each broadcast completes in O (f )-time with O (f n) messages.
Reference: [Bra82] <author> Gabriel Bracha. </author> <type> Personal communication. </type> <year> 1982. </year>
Reference-contexts: For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes). Some Reliable Broadcast algorithms were designed to minimise the number of messages rather than the message delivery time <ref> [Bra82, DS83, Web89] </ref>. For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur [Web89, AWH90, HH90]. <p> Some Reliable Broadcast algorithms were designed to minimise the number of messages rather than the message delivery time [Bra82, DS83, Web89]. For example, the algorithm in <ref> [Bra82] </ref> requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur [Web89, AWH90, HH90].
Reference: [CASD85] <author> Flaviu Cristian, Houtan Aghili, H. Raymond Strong, and Danny Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Proceedings of the Fifteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206, </pages> <month> June </month> <year> 1985. </year> <note> A revised version appears as IBM Research Laboratory Technical Report RJ5244 (April 1989). </note>
Reference-contexts: Most of the theoretical research on Reliable Broadcast (including the above algorithms) assumes that all processes have a priori knowledge of the initial time of each broadcast. In many systems, this information is not available: indeed, any process can spontaneously broadcast a message at any time <ref> [CASD85] </ref>. For such systems, we define the Spontaneous Reliable Broadcast problem, and present a solution that is tolerant of crash failures. The Reliable Broadcast problem does not impose any restriction on the decision of faulty processes. <p> Therefore, we must replace the eventual decision condition with: Uniform Decision: If any correct process decides, then all correct processes even <p>- tually decide. The resulting specification allows the correct processes to completely ignore a broadcast initiated by a faulty process. Similar specifications have been studied in <ref> [CM84, SGS84, CASD85, GT89] </ref>. 3. Assumption 3 is eliminated. In Algorithm 1b, the initiator of a broadcast chooses a sequence of future coordinators and includes this sequence in its initial broadcast 7 .
Reference: [CM84] <author> J. Chang and N. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: General-omission failures: A process may fail by halting or by omitting to send or receive messages. 3 Outline of Algorithms The algorithms in this paper use the rotating coordinator paradigm <ref> [Rei82, CM84] </ref>. A subset of t + 1 processes cyclically become coordinators for a constant number of rounds each. The sender is the first coordinator and its id is 1. <p> Therefore, we must replace the eventual decision condition with: Uniform Decision: If any correct process decides, then all correct processes even <p>- tually decide. The resulting specification allows the correct processes to completely ignore a broadcast initiated by a faulty process. Similar specifications have been studied in <ref> [CM84, SGS84, CASD85, GT89] </ref>. 3. Assumption 3 is eliminated. In Algorithm 1b, the initiator of a broadcast chooses a sequence of future coordinators and includes this sequence in its initial broadcast 7 .
Reference: [CT90] <author> Tushar Deepak Chandra and Sam Toueg. </author> <title> Time and message efficient reli-able broadcasts. </title> <type> Technical Report 90-1094, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: We can show that all correct processes eventually decide estimate p . Lemma 1.1: At round T 1, all processes q which did not crash received estimate p and set estimate q to estimate p . 5 The complete proof is given in <ref> [CT90] </ref>. Lemma 1.2: If c is a coordinator after p, and c sends estimate c , then estimate c = estimate p . Lemma 1.3: If coordinator c is correct, all processes which have not crashed decide by the end of round 3c.
Reference: [CW86] <author> Brian A. Coan and Jennifer L. Welch. </author> <title> Transaction commit in a realistic fault model. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 40-51, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Thus the Uniform Reliable Broadcast problem strengthens the agreement condition to: Uniform Agreement: If a process (correct or faulty) decides m, then all correct processes must also decide m. Uniform Reliable Broadcast algorithms can be used to solve many other important problems, such as the distributed commit problem <ref> [Ske82, CW86] </ref>. In fact, it is the Uniform Agreement requirement that ensures that either all processes commit or all abort [Had86]. Several of our algorithms actually solve the Uniform Reliable Broadcast problem. The rest of this paper is organised as follows. In Section 2 we describe the models of failure.
Reference: [DR85] <author> Danny Dolev and Rudiger Reischuk. </author> <title> Bounds on information exchange for Byzantine agreement. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 191-204, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes). <p> From Lemma 3.4, Algorithm 3 solves the Uniform Reliable Broadcast problem. 8 Lower bounds for general-omission failures Dolev et. al. showed that any Reliable Broadcast algorithm for general-omission failures requires t 2 2 messages in the worst case <ref> [DR85] </ref>.
Reference: [DRS86] <author> Danny Dolev, Rudiger Reischuk, and H. Raymond Strong. </author> <title> Early stopping in Byzantine agreement. </title> <type> Technical Report RJ5406, </type> <institution> IBM Research Laboratory, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: Algorithms tolerant of t faulty processes usually required O (t)-time for each broadcast. With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast <ref> [Ske82, DRS86] </ref>. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages [Had83, PT84, DR85, Per85, PT86, Ezh87].
Reference: [DS83] <author> C. Dwork and D. Skeen. </author> <title> The inherent cost of nonblocking commitment. </title> <booktitle> In Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-11, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes). Some Reliable Broadcast algorithms were designed to minimise the number of messages rather than the message delivery time <ref> [Bra82, DS83, Web89] </ref>. For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur [Web89, AWH90, HH90].
Reference: [Ezh87] <author> Paul D. Ezhilchelvan. </author> <title> Early stopping algorithms for distributed agreement un-der fail-stop, omission, and timing fault types. </title> <booktitle> In IEEE 1987 Sixth Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 201-212, </pages> <institution> Computing Laboratory, The university, Newcastle upon Tyne, </institution> <address> England, 1987. </address> <publisher> IEEE computer society press. </publisher>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes).
Reference: [GT89] <author> Ajei Gopal and Sam Toueg. </author> <title> Reliable broadcast in synchronous and asyn-chronous environments (preliminary version). </title> <editor> In J.-C. Bermond and M. Raynal, editors, </editor> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, volume 392 of Lecture Notes on Computer Science, </booktitle> <pages> pages 110-123. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: However, for "benign" failures such as omission failures (where processes do not change state arbitrarily or lie), it is desirable and feasible to place some restrictions on the decision of faulty processes. The Uniform Reliable Broadcast problem <ref> [Nei88, GT89] </ref> is the Reliable Broadcast problem with the additional requirement that all processes that reach a decision, including the faulty ones, decide on the same value. <p> Therefore, we must replace the eventual decision condition with: Uniform Decision: If any correct process decides, then all correct processes even <p>- tually decide. The resulting specification allows the correct processes to completely ignore a broadcast initiated by a faulty process. Similar specifications have been studied in <ref> [CM84, SGS84, CASD85, GT89] </ref>. 3. Assumption 3 is eliminated. In Algorithm 1b, the initiator of a broadcast chooses a sequence of future coordinators and includes this sequence in its initial broadcast 7 .
Reference: [Had83] <author> Vassos Hadzilacos. </author> <title> Byzantine agreement under restricted types of failures (not telling the truth is different from telling lies). </title> <type> Technical Report 18-83, </type> <institution> Department of Computer Science, Harvard University, </institution> <year> 1983. </year> <note> A revised version appears in Hadzilacos's Ph.D. dissertation [Had84]. </note>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes).
Reference: [Had84] <author> Vassos Hadzilacos. </author> <title> Issues of Fault Tolerance in Concurrent Computations. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <month> June </month> <year> 1984. </year> <note> Department of Computer Science Technical Report 11-84. </note>
Reference: [Had86] <author> Vassos Hadzilacos. </author> <title> On the relationship between the atomic commitment and consensus problems. </title> <booktitle> Workshop on Fault-Tolerant Distributed Computing, </booktitle> <address> March 17-19, 1986, Pacific Grove, CA. </address> <note> (Proceedings to be published in a vol-ume, edited by Brabara Simons, of the Springer-Verlag Series "Lecture Notes on Computer Science"), </note> <year> 1986. </year>
Reference-contexts: Uniform Reliable Broadcast algorithms can be used to solve many other important problems, such as the distributed commit problem [Ske82, CW86]. In fact, it is the Uniform Agreement requirement that ensures that either all processes commit or all abort <ref> [Had86] </ref>. Several of our algorithms actually solve the Uniform Reliable Broadcast problem. The rest of this paper is organised as follows. In Section 2 we describe the models of failure. In Section 3, we outline the central idea of our algorithms.
Reference: [HH90] <author> Vassos Hadzilacos and Joseph Y. Halpern. </author> <title> Message and bit-optimal protocol for byzantine agreement. </title> <note> 1990. To appear. </note>
Reference-contexts: For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur <ref> [Web89, AWH90, HH90] </ref>. In this paper, we present the first Reliable Broadcast algorithms that are both time and message efficient: each broadcast completes in O (f )-time with O (f n) messages.
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine gen-erals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Reliable Broadcast is a fundamental problem of fault-tolerant distributed computing. Informally, Reliable Broadcast requires that when a process broadcasts a message, all correct processes consistently decide on the value of that message. In particular, the following formulation of this problem has been extensively studied <ref> [PSL80, LSP82] </ref>. Validity: If a correct process broadcasts a message m, then all correct processes must eventually decide m. Agreement: If a correct process decides m, then all correct processes must also decide m.
Reference: [Nei88] <author> Gil Neiger. </author> <title> Techniques for Simplifying the Design of Distributed Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1988. </year> <note> Department of Computer Science Technical Report 88-933. </note>
Reference-contexts: However, for "benign" failures such as omission failures (where processes do not change state arbitrarily or lie), it is desirable and feasible to place some restrictions on the decision of faulty processes. The Uniform Reliable Broadcast problem <ref> [Nei88, GT89] </ref> is the Reliable Broadcast problem with the additional requirement that all processes that reach a decision, including the faulty ones, decide on the same value.
Reference: [NT90] <author> Gil Neiger and Sam Toueg. </author> <title> Automatically increasing the fault-tolerance of distributed algorithms. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 374-419, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The correct processes decide by round 4f + 4 after sending at most O (f n) messages. 7 Reliable Broadcast for General-Omission Failures Algorithm 2 tolerates any number of send-omission failures (i.e., for any t &lt; n). To tolerate general-omission failures we used a "translation" technique from <ref> [NT90] </ref> which requires n &gt; 2t. Thus, the resulting algorithm (Algorithm 3), tolerates up to b n1 2 c general-omission failures, and actually solves the Uniform Reliable Broadcast problem 8 . Informally, running algorithm 2 in a system with general-omission failures does not work for the following three reasons: 1. <p> The following result from <ref> [NT90] </ref> shows that Algorithm 3 is optimal in the number of failures that it tolerates. 9 The proof will be found in the complete version of the paper.
Reference: [Per85] <author> Kenneth J. Perry. </author> <title> Early Stopping Protocols for Fault-Tolerant Distributed Agreement. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> February </month> <year> 1985. </year> <note> Department of Computer Science Technical Report 85-662. </note>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes).
Reference: [PSL80] <author> M. Pease, R. Shostak, and Leslie Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: 1 Introduction Reliable Broadcast is a fundamental problem of fault-tolerant distributed computing. Informally, Reliable Broadcast requires that when a process broadcasts a message, all correct processes consistently decide on the value of that message. In particular, the following formulation of this problem has been extensively studied <ref> [PSL80, LSP82] </ref>. Validity: If a correct process broadcasts a message m, then all correct processes must eventually decide m. Agreement: If a correct process decides m, then all correct processes must also decide m.
Reference: [PT84] <author> Kenneth J. Perry and Sam Toueg. </author> <title> An authenticated Byzantine generals algo-rithm with early stopping. </title> <type> Technical Report 84-620, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> June </month> <year> 1984. </year>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes).
Reference: [PT86] <author> Kenneth J. Perry and Sam Toueg. </author> <title> Distributed agreement in the presence of processor and communication faults. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(3) </volume> <pages> 477-482, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast [Ske82, DRS86]. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages <ref> [Had83, PT84, DR85, Per85, PT86, Ezh87] </ref>. For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes).
Reference: [Rei82] <author> Rudiger Reischuk. </author> <title> A new solution for the Byzantine general's problem. </title> <type> Technical Report RJ 3673, </type> <institution> IBM Research Laboratory, </institution> <month> November </month> <year> 1982. </year>
Reference-contexts: General-omission failures: A process may fail by halting or by omitting to send or receive messages. 3 Outline of Algorithms The algorithms in this paper use the rotating coordinator paradigm <ref> [Rei82, CM84] </ref>. A subset of t + 1 processes cyclically become coordinators for a constant number of rounds each. The sender is the first coordinator and its id is 1.
Reference: [SGS84] <author> Fred B. Schneider, David Gries, and Richard D. Schlichting. </author> <title> Fault-tolerant broadcasts. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 4(1) </volume> <pages> 1-15, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Therefore, we must replace the eventual decision condition with: Uniform Decision: If any correct process decides, then all correct processes even <p>- tually decide. The resulting specification allows the correct processes to completely ignore a broadcast initiated by a faulty process. Similar specifications have been studied in <ref> [CM84, SGS84, CASD85, GT89] </ref>. 3. Assumption 3 is eliminated. In Algorithm 1b, the initiator of a broadcast chooses a sequence of future coordinators and includes this sequence in its initial broadcast 7 .
Reference: [Ske82] <author> Dale Skeen. </author> <title> Crash Recovery in a Distributed Database System. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Department of EECS, </institution> <year> 1982. </year>
Reference-contexts: Algorithms tolerant of t faulty processes usually required O (t)-time for each broadcast. With early-stopping algorithms, the broadcast time was later reduced to O (f ), where f is the number of processes that actually fail during the broadcast <ref> [Ske82, DRS86] </ref>. However, fl This work was supported by NSF grant number CCR-8901780. 1 early-stopping algorithms were still expensive in messages [Had83, PT84, DR85, Per85, PT86, Ezh87]. <p> Thus the Uniform Reliable Broadcast problem strengthens the agreement condition to: Uniform Agreement: If a process (correct or faulty) decides m, then all correct processes must also decide m. Uniform Reliable Broadcast algorithms can be used to solve many other important problems, such as the distributed commit problem <ref> [Ske82, CW86] </ref>. In fact, it is the Uniform Agreement requirement that ensures that either all processes commit or all abort [Had86]. Several of our algorithms actually solve the Uniform Reliable Broadcast problem. The rest of this paper is organised as follows. In Section 2 we describe the models of failure.
Reference: [Web89] <author> Samuel Weber. </author> <title> Bounds on the message complexity of Byzantine agreement. </title> <type> Master's thesis, </type> <institution> University of Toronto, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: For example, [PT86]'s early-stopping algorithm for general-omission failures requires only f +2 rounds 1 but requires O (f n 2 ) messages (where n is the total number of processes). Some Reliable Broadcast algorithms were designed to minimise the number of messages rather than the message delivery time <ref> [Bra82, DS83, Web89] </ref>. For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur [Web89, AWH90, HH90]. <p> For example, the algorithm in [Bra82] requires only O (n + t p t) messages, but takes O (t) rounds. Other algorithms were optimised for the failure-free case. These algorithms minimise the number of messages when no failures actually occur <ref> [Web89, AWH90, HH90] </ref>. In this paper, we present the first Reliable Broadcast algorithms that are both time and message efficient: each broadcast completes in O (f )-time with O (f n) messages.
References-found: 26

