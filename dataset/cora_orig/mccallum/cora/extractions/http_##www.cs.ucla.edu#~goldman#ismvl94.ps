URL: http://www.cs.ucla.edu/~goldman/ismvl94.ps
Refering-URL: http://www.cs.ucla.edu/~goldman/papers.html
Root-URL: http://www.cs.ucla.edu
Title: On the decomposition of real-valued functions 3rd International Workshop of Post-Binary VLSI Systems an event
Author: Timothy D. Ross Jeffrey A. Goldman David A. Gadd Michael J. Noviskey Mark L. Axtell 
Date: May 24, 1994  
Abstract: The decomposition of discrete (especially binary) functions has long been useful for developing theoretical properties of function representations and more recently as a design method for FPGAs. Because of its fundamental character, function decomposition is also of interest as an approach to computational learning and pattern finding in general. Within this "pattern finding" application of function decomposition, there are problems that are best modeled as a function whose inputs and outputs are from a continuum (especially the real numbers). We examine the decomposition process for such functions and elaborate on its applications.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert L. Ashenhurst. </author> <title> The decomposition of switching functions. </title> <booktitle> In Proceedings of the International Symposium on the Theory of Switching, </booktitle> <month> April </month> <year> 1957. </year>
Reference-contexts: The basic condition for whether or not there exist functions and F that can be composed to generate some function f, as in f (x; y; z) = F ((x; y); z); was determined in the work of R. L. Ashenhurst <ref> [1] </ref> and others. Based on this test for the existence of and F , a variety of algorithms are possible for logic design (see for example [4]). Although decomposition was based on the fundamental nature of function representation, it initially had little practical impact. <p> This might be done by using the mean, mode, or median of each row or any one of a variety of other methods. As an example of the decomposition of a real-valued function, suppose we begin with a function, f : f0; 1g n ! <ref> [0; 1] </ref>, where [0; 1] represents the real interval between 0 and 1, inclusive. Let f be the even parity function, i.e. the f (x) = 1 if and only if the input x contains an even number of 1's (see Table 5). <p> This might be done by using the mean, mode, or median of each row or any one of a variety of other methods. As an example of the decomposition of a real-valued function, suppose we begin with a function, f : f0; 1g n ! <ref> [0; 1] </ref>, where [0; 1] represents the real interval between 0 and 1, inclusive. Let f be the even parity function, i.e. the f (x) = 1 if and only if the input x contains an even number of 1's (see Table 5). <p> This can be demonstrated by first observing that F and exist for a given variable partition if the column multiplicity is less than or equal to the cardinality of 's codomain, this follows from a straight forward generalization of the basic decomposition condition <ref> [1] </ref> and the definition of cardinality. The domain of has the same cardinality as the total number of columns, in this case jR 2 j, or c. The column multiplicity is no greater than the total number of columns in a partition matrix; or, in this case, - c. <p> We are assuming, instead, that we are given a finite partial table 3 . We will again use an example to identify challenges posed by real-valued variables and explore some approaches to those challenges. Table 10 is a set of samples from a function of the form f : <ref> [0; 1] </ref> 2 ! [0; 1], defined as: f (x; y) = y if x 0:5 If we chose x as a column variable and y a row variable then the resulting partition matrix is shown in Table 11. <p> We will again use an example to identify challenges posed by real-valued variables and explore some approaches to those challenges. Table 10 is a set of samples from a function of the form f : <ref> [0; 1] </ref> 2 ! [0; 1], defined as: f (x; y) = y if x 0:5 If we chose x as a column variable and y a row variable then the resulting partition matrix is shown in Table 11.
Reference: [2] <author> Michael A. Breen, Timothy D. Ross, and Mark L. Axtell. </author> <title> Computing column multiplicity in function decomposition. </title> <booktitle> In Proceedings of Euro-DAC, </booktitle> <year> 1994. </year> <note> Submitted. </note>
Reference-contexts: With this renewed interest, and even before that, extensions have been made to allow the decomposition of multiple-valued functions [7, 18], functions with multiple outputs [19], functions with real-valued outputs <ref> [2] </ref>, partial functions, and functions represented with binary decision diagrams [10]. The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15]. The application of function decomposition to sequential representations has also been explored [5]. <p> However, in practical problems, noise or round-off could prevent decomposition of even the simplest problems. One approach to column comparison is to only require that two columns be "close" with respect to some measure, rather than identical. References <ref> [2] </ref>, our first consideration of real-valued decompositions, and [6, p.232] discuss several possible measures of column closeness, including when the real output of the function is interpreted as the probability that the intended output was 1.
Reference: [3] <author> Joseph Breuer. </author> <title> Introduction to the Theory of Sets. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1958. </year>
Reference-contexts: First we establish some notation. Two sets have the same cardinality if they can be put in a one-to-one relationship <ref> [3, p.13] </ref>. We use jAj for the cardinality of the set A. The cardinality of a countably infinite set is denoted @ o and the cardinality of a continuum (e.g. the real numbers, R) as c. <p> We use jAj for the cardinality of the set A. The cardinality of a countably infinite set is denoted @ o and the cardinality of a continuum (e.g. the real numbers, R) as c. Note that jRj = jR n j = c for any finite n (reference <ref> [3, p.52] </ref>). For the mapping f : X ! Y , X is the domain and Y the codomain of f . <p> Suppose the partition matrix is such that : R 2 ! R is one-to-one. This is possible since the domain and codomain have the same cardinality. If a function is one-to-one and reduces dimensionality, as in : R 2 ! R then that function can not be continuous (see <ref> [3, p.30] </ref>). A mapping f : X ! Y is said to be "k to 1" if k = max jfx 2 f 1 (y)gj; that is, the maximum number of points in X that map to a single point in Y .
Reference: [4] <author> H. Allen Curtis. </author> <title> A New Approach to The Design of Switching Circuits. </title> <address> D. </address> <publisher> Van Nostrand Company, </publisher> <address> Princeton, New Jersey, </address> <year> 1962. </year>
Reference-contexts: L. Ashenhurst [1] and others. Based on this test for the existence of and F , a variety of algorithms are possible for logic design (see for example <ref> [4] </ref>). Although decomposition was based on the fundamental nature of function representation, it initially had little practical impact. Decomposition's impact was limited by its computational intractability and the difficulty of forcing the component functions to be in a standard form, such as AND, OR, and NOT.
Reference: [5] <author> H. Allen Curtis. </author> <title> Use of decomposition theory in the solution of the state assignment problem of sequential machines. </title> <journal> Journal of Association Computing Machinery, </journal> <volume> 10 </volume> <pages> 386-411, </pages> <year> 1963. </year>
Reference-contexts: The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15]. The application of function decomposition to sequential representations has also been explored <ref> [5] </ref>. Function decomposition is emerging as a fundamental problem of computer science. This paper will attempt to expand the understanding of function decomposition by considering the problem of decomposing functions whose input variables include real numbers.
Reference: [6] <author> Pierre A. Devijver and Josef Kittler. </author> <title> Pattern Recognition: A Statistical Approach. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1982. </year>
Reference-contexts: However, in practical problems, noise or round-off could prevent decomposition of even the simplest problems. One approach to column comparison is to only require that two columns be "close" with respect to some measure, rather than identical. References [2], our first consideration of real-valued decompositions, and <ref> [6, p.232] </ref> discuss several possible measures of column closeness, including when the real output of the function is interpreted as the probability that the intended output was 1. Given a closeness measure, we still have the problem of defining the number and type of regions to cover the columns.
Reference: [7] <author> K. Y. Fang and A. S. Wojcik. </author> <title> Modular decomposition of combinational multiple-valued circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37, </volume> <year> 1988. </year>
Reference-contexts: In this pattern finding role, decomposition has application in computational learning, algorithm design, data compression, signal and image processing, as well as logic circuit design. With this renewed interest, and even before that, extensions have been made to allow the decomposition of multiple-valued functions <ref> [7, 18] </ref>, functions with multiple outputs [19], functions with real-valued outputs [2], partial functions, and functions represented with binary decision diagrams [10]. The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15].
Reference: [8] <author> John A. Hartigan. </author> <title> Clustering Algorithms. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: Given a closeness measure, we still have the problem of defining the number and type of regions to cover the columns. This is the classical "clustering" problem which has a variety of approaches, see for example <ref> [8] </ref>. Once a region of columns has been defined, we now need to create a representative column for that region. This might be done by using the mean, mode, or median of each row or any one of a variety of other methods.
Reference: [9] <author> Jack S. N. Jean, Kefu Xue, and Shailendra Goel. </author> <title> Pattern theory for character recognition. </title> <booktitle> In Proceedings of ICNN, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The algorithms for performing decompositions have been analyzed and several key sub-problems defined <ref> [9, 13, 15] </ref>. The application of function decomposition to sequential representations has also been explored [5]. Function decomposition is emerging as a fundamental problem of computer science. <p> However, we would probably want to take advantage of any structural information about the relationship in doing the decomposition. We do not address that here. 4 A similar problem arises even for binary inputs if the function is large and the samples sparse (refer ence <ref> [9] </ref>). 8 x y f (x; y) 0.17 0.58 0.58 0.36 0.69 0.69 0.51 0.90 0.10 0.64 0.41 0.59 0.82 0.57 0.43 Table 10: Random samples of a function with real-valued inputs. x 0.04 0.04 0.28 0.72 y 0.41 0.59 0.58 0.58 0.69 0.69 Table 11: Partition matrix for function with
Reference: [10] <author> Yung-Te Lai, Massoud Pedram, and Sarma B. K. Vrudhula. </author> <title> BDD based decomposition of logic functions with application to FPGA synthesis. </title> <booktitle> In Proceedings of Thirtieth 13 ACM/IEEE Design Automation Conference, </booktitle> <address> Washington D.C., 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: With this renewed interest, and even before that, extensions have been made to allow the decomposition of multiple-valued functions [7, 18], functions with multiple outputs [19], functions with real-valued outputs [2], partial functions, and functions represented with binary decision diagrams <ref> [10] </ref>. The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15]. The application of function decomposition to sequential representations has also been explored [5]. Function decomposition is emerging as a fundamental problem of computer science.
Reference: [11] <author> Yung-Te Lai, Massoud Pedram, and Sarma B. K. Vrudhula. FGMap: </author> <title> A technology mapping algorithm for look-up table type FPGAs based on function graphs. </title> <booktitle> In International Workshop on Logic Synthesis, Workshop Notes, </booktitle> <year> 1993. </year>
Reference-contexts: This interest is driven primarily by the need for a design methodology for the universal gates possible with FPGA fl Wright Lab, WL/AART-2 Bldg 22, 2690 C St Ste 1, WPAFB, OH 45433-7408, voice: (513) 255-3215, fax: (513) 476-4997, email: t.ross@ieee.org 1 technology (see for example <ref> [11, 14] </ref>). Interest has also been developed in the ability of function decomposition to act as a robust pattern finder [17]. In this pattern finding role, decomposition has application in computational learning, algorithm design, data compression, signal and image processing, as well as logic circuit design.
Reference: [12] <author> Gerald J. Montgomery and Keith C. Drake. </author> <title> Abductive reasoning networks. </title> <journal> Neurocom-puting An International Journal, </journal> <volume> 2(3) </volume> <pages> 97-104, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: It is especially important to handle real variables for problems that involve noise or where approximate solutions are sought. Although not as robust as we might hope for, there are existing approaches to pattern finding that perform well on many problems with real variables (e.g. Abductive Information Modeler 1 <ref> [12] </ref>) or with exclusively symbolic variables (e.g. C4.5 [16]). However, there is an especially strong need for a common framework that deals with both. 2 Background The basic approach to function decomposition is best conveyed by a simple example. Suppose we want to decompose the function in Table 1. <p> For some modeling strategies, we may also be interested in low error and low complexity of the representation. This idea is well developed within Computational Learning Theory, see especially <ref> [12] </ref>. We mentioned that columns have traditionally been considered candidates for the same region if there was no evidence to the contrary. An alternative approach is emerging here, one that may be more appropriate when there is a sparsity of samples.
Reference: [13] <author> Rajeev Murgai, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Using encoding for functional decomposition with application to look up table architectures. </title> <booktitle> In Second International ACM/SIGDA Workshop on Field-Programmable Gate Arrays, </booktitle> <year> 1994. </year>
Reference-contexts: The algorithms for performing decompositions have been analyzed and several key sub-problems defined <ref> [9, 13, 15] </ref>. The application of function decomposition to sequential representations has also been explored [5]. Function decomposition is emerging as a fundamental problem of computer science. <p> Finally, there is the problem of defining the sub-functions. The column matching within the partition matrix restricts how the sub-functions can be defined, but there remains an important degree-of-freedom in their definition. This is the encoding problem of <ref> [13] </ref>.
Reference: [14] <author> Rajeev Murgai, Narendra Shenoy, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Improved logic synthesis algorithms for table look up architectures. </title> <booktitle> In Proceeding of ICCAD, </booktitle> <year> 1993. </year>
Reference-contexts: This interest is driven primarily by the need for a design methodology for the universal gates possible with FPGA fl Wright Lab, WL/AART-2 Bldg 22, 2690 C St Ste 1, WPAFB, OH 45433-7408, voice: (513) 255-3215, fax: (513) 476-4997, email: t.ross@ieee.org 1 technology (see for example <ref> [11, 14] </ref>). Interest has also been developed in the ability of function decomposition to act as a robust pattern finder [17]. In this pattern finding role, decomposition has application in computational learning, algorithm design, data compression, signal and image processing, as well as logic circuit design.
Reference: [15] <author> M. A. Perkowski and J. E. Brown. </author> <title> A unified approach to designs implemented with multiplexers and to the decomposition of boolean functions. </title> <booktitle> In Proceedings of ASEE Anual Conference, </booktitle> <pages> pages 1610-1618, </pages> <year> 1988. </year>
Reference-contexts: The algorithms for performing decompositions have been analyzed and several key sub-problems defined <ref> [9, 13, 15] </ref>. The application of function decomposition to sequential representations has also been explored [5]. Function decomposition is emerging as a fundamental problem of computer science.
Reference: [16] <author> J. Ross Quinlan. C4.5: </author> <title> Programs for Machine Learning. </title> <publisher> Morgan Kaufmann, </publisher> <address> Palo Alto, California, </address> <year> 1993. </year>
Reference-contexts: Although not as robust as we might hope for, there are existing approaches to pattern finding that perform well on many problems with real variables (e.g. Abductive Information Modeler 1 [12]) or with exclusively symbolic variables (e.g. C4.5 <ref> [16] </ref>). However, there is an especially strong need for a common framework that deals with both. 2 Background The basic approach to function decomposition is best conveyed by a simple example. Suppose we want to decompose the function in Table 1.
Reference: [17] <author> Timothy D. Ross, Michael J. Noviskey, Timothy N. Taylor, and David A. Gadd. </author> <title> Pattern theory: An engineering paradigm for algorithm design. </title> <type> Final Technical Report WL-TR-91-1060, </type> <institution> Wright Laboratory, USAF, </institution> <address> WL/AART, WPAFB, OH 45433-6543, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Interest has also been developed in the ability of function decomposition to act as a robust pattern finder <ref> [17] </ref>. In this pattern finding role, decomposition has application in computational learning, algorithm design, data compression, signal and image processing, as well as logic circuit design.
Reference: [18] <author> Tsutomu Sasao. </author> <title> Multiple-valued decomposition of generalized boolean functions and the complexity of programmable logic arrays. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30:635-643, </volume> <year> 1981. </year>
Reference-contexts: In this pattern finding role, decomposition has application in computational learning, algorithm design, data compression, signal and image processing, as well as logic circuit design. With this renewed interest, and even before that, extensions have been made to allow the decomposition of multiple-valued functions <ref> [7, 18] </ref>, functions with multiple outputs [19], functions with real-valued outputs [2], partial functions, and functions represented with binary decision diagrams [10]. The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15].
Reference: [19] <author> Wei Wan and Marek A. Perkowski. </author> <title> A new approach to the decomposition of incompletely specified multi-output functions based on graph coloring and local transformations and its application to FPGA mapping. </title> <booktitle> In Proceedings of Euro-DAC, </booktitle> <pages> pages 230-235, </pages> <year> 1992. </year>
Reference-contexts: With this renewed interest, and even before that, extensions have been made to allow the decomposition of multiple-valued functions [7, 18], functions with multiple outputs <ref> [19] </ref>, functions with real-valued outputs [2], partial functions, and functions represented with binary decision diagrams [10]. The algorithms for performing decompositions have been analyzed and several key sub-problems defined [9, 13, 15]. The application of function decomposition to sequential representations has also been explored [5].
References-found: 19

