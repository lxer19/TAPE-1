URL: ftp://dirleton.csres.utexas.edu/pub/reports/056.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: (512) 322-9951  
Title: A Mechanically-Checked Correctness Proof of a Floating-Point Search Program  
Author: Matt Wilding 
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: #56 May, 1990  
Pubnum: Technical Report  
Abstract: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151 and by ONR Contract N00014-88-C-0454. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency, the Office of Naval Research, or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Barrett. </author> <title> "Formal Methods Applied to a Floating-Point Number System". </title> <journal> IEEE Transactions on Software Engineering 15 (May 1989), </journal> <pages> 611-621. </pages>
Reference-contexts: Much of the effort toward precisely specifying floating-point operations has been motivated by the desire to implement floating-point operations correctly. Researchers at Oxford University have formalized a floating-point system expressed using Z and Occam <ref> [1] </ref>. Their ultimate goal is to construct a floating-point processor that correctly implements the formal description of the floating-point system.
Reference: 2. <author> Bill Bevier. </author> <title> A Library for Hardware Verification. Internal Note 57, Computational Logic, </title> <publisher> Inc., </publisher> <month> June, </month> <year> 1988. </year> <note> Draft. </note>
Reference-contexts: Appendix D lists the development and proof of the FP searching example. 4 2. The Rational Library In this section we describe a rational number library that contains facts that facilitate automatic proofs about rationals using the PC-NQTHM theorem prover. It uses Bevier's hardware libraries <ref> [2] </ref> (as updated by Bevier and Wilding) that facilitate proofs about integers and natural numbers. The floating-point numbers are a subset of the rational numbers, and our later development of them will rely on the definition of rational numbers and the rational number operations contained in the subsection DEFINITIONS.
Reference: 3. <author> William R. Bevier, Warren A. Hunt, Jr., J Strother Moore, William D. Young. </author> <title> "An Approach to Systems Verification". </title> <note> Journal of Automated Reasoning 5 (November 1989). </note>
Reference-contexts: On another front, proofs about computers and computer programs have been mechanically checked. Boyer's and Moore's NQTHM prover has been used to prove the correctness of a microprocessor, compilers, and operating systems. <ref> [3, 4] </ref> The checked theorems often have convoluted proofs, but they have the important advantage that NQTHM-checked theorems are presumed to be very reliable. <p> The floating-point system model could actually be implemented. This entails writing a compiler for a portion of the logic that includes floating point operations. The target language of the compiler would probably 24 be Piton [16] so that the resulting code could be run on the verified stack. <ref> [3] </ref> The appeal of verifying a floating-point program down to the level of hardware is very strong. It appears that backward error analysis of floating-point programs [18] might benefit from algorithms that automate finding the consistency of sets of inequalities.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: On another front, proofs about computers and computer programs have been mechanically checked. Boyer's and Moore's NQTHM prover has been used to prove the correctness of a microprocessor, compilers, and operating systems. <ref> [3, 4] </ref> The checked theorems often have convoluted proofs, but they have the important advantage that NQTHM-checked theorems are presumed to be very reliable. <p> all the axioms true. fpp (x) (x = 0) or (x = 1) or (x = -1) fpminspace 1 fpminimum 1 fpmaximum 1 round-max 1 round-min 1 round (x) if |x| &lt; 1 0 1 3.3 What is a Floating-Point Program? The NQTHM logic will be used to express programs. <ref> [4] </ref> This report contains programs using infix notation to represent terms in the logic in order to assist readers unfamiliar with the logic's Lisp-like notation. Even so, the ultimate authority about what has been proved is in the proof script that has been checked by the theorem prover. <p> By induction on find-func-zero (justified by lemma 5) and lemmas 6 and 7, the correctness theorem holds. (find-func-zero-returns-a-zero,find-func-zero-returns-close-values) 5.2 An NQTHM Zero-Finding Program and Correctness Theorem The zero-finding program and its correctness proof have been formalized in the NQTHM logic. <ref> [4] </ref> The proof checker enhancement of the theorem prover [12] has accepted the program and its proof. Axiomatized functions were added using constrain events that have been proved to keep the prover state consistent. [5] The following events have been accepted by the theorem prover.
Reference: 5. <author> Robert S. Boyer, David M. Goldschlag, Matt Kaufmann, and J Strother Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <type> Tech. </type> <institution> Rept. 44, Computational Logic, Inc., Austin, Texas, </institution> <month> May, </month> <year> 1989. </year>
Reference-contexts: Numerals are assumed to be of type rational, &lt; is RLESSP, |x| means (RMAGNITUDE x), unary - means RNEG, and function application will be denoted f (args) rather than (f args). The axioms were introduced using the CONSTRAIN mechanism described in <ref> [5] </ref>. <p> Axiomatized functions were added using constrain events that have been proved to keep the prover state consistent. <ref> [5] </ref> The following events have been accepted by the theorem prover.
Reference: 6. <author> W. S. Brown. </author> <title> "A Simple but Realistic Model of Floating-Point Computation". </title> <journal> ACM Transactions on Mathematical Software 7, </journal> <month> 4 (December </month> <year> 1981). </year>
Reference-contexts: Several researchers have also proposed models of floating-point operations and used them to justify claims about sequences of floating point operations. <ref> [6, 8, 14, 17] </ref> These efforts work toward putting floating-point arithmetic on more-solid ground. Even so, the complexity of proofs using these systems, and the apparent gap between the floating-point axioms and "realistic" numerical programs has discouraged application of work in this area.
Reference: 7. <author> William J. Cody, Jr. and William Waite. </author> <title> Software Manual for the Elementary Functions. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1980. </year>
Reference-contexts: Also, any applications proved correct will be able to execute using the model. An application program that uses the enhanced floating-point formalization will be proved correct. The example that will probably be pursued is a correctness proof of a program that calculates the sine function. <ref> [7] </ref> The correctness theorem tightly bounds the forward error of the calculation. 6.2 Other Possible Work The planned work suggests several possible interesting detours. The floating-point system model could actually be implemented. This entails writing a compiler for a portion of the logic that includes floating point operations.
Reference: 8. <author> T.J. Dekker. </author> <title> Correctness Proof and Machine Arithmetic. In Performance Evaluation of Numerical Software, </title> <editor> Fosdick, Eds., </editor> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: Several researchers have also proposed models of floating-point operations and used them to justify claims about sequences of floating point operations. <ref> [6, 8, 14, 17] </ref> These efforts work toward putting floating-point arithmetic on more-solid ground. Even so, the complexity of proofs using these systems, and the apparent gap between the floating-point axioms and "realistic" numerical programs has discouraged application of work in this area.
Reference: 9. <editor> Gries, D. </editor> <booktitle> The Science of Computer Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 81. </pages>
Reference-contexts: The problem of wedding a model of floating-point operations with program proof rules was examined in Holm's PhD thesis. [10] Holm uses an axiomatization of floating-point operations and Dijkstra's WP calculus. <ref> [9] </ref> Holm develops enough mathematical machinery to prove some theorems about a searching program. While the searching program example may appear unambitious and though the presentation is quite clean, the proof is long and rather complex. On another front, proofs about computers and computer programs have been mechanically checked.
Reference: 10. <author> John Erick Holm. </author> <title> Floating-Point Arithmetic and Program Correctness Proofs. </title> <type> Ph.D. </type> <institution> Th., Cornell University, </institution> <year> 1980. </year>
Reference-contexts: Their ultimate goal is to construct a floating-point processor that correctly implements the formal description of the floating-point system. The problem of wedding a model of floating-point operations with program proof rules was examined in Holm's PhD thesis. <ref> [10] </ref> Holm uses an axiomatization of floating-point operations and Dijkstra's WP calculus. [9] Holm develops enough mathematical machinery to prove some theorems about a searching program. While the searching program example may appear unambitious and though the presentation is quite clean, the proof is long and rather complex. <p> A Floating-Point System Axiomatization In this section we present a set of axioms that describes the behavior of floating-point numbers. The axioms are formalized in the Boyer-Moore logic, and mechanically shown to be consistent. The axioms themselves are similar to sets proposed in previous FP work, especially <ref> [10] </ref>. 3.1 The Axioms Floating-point computation is modelled by axiomatizing some functions. The function FPP is axiomatized as a predicate that identifies floating-point values. The function ROUND is axiomatized to map any value to a floating-point value. FPMINIMUM is axiomatized to be the smallest non-zero positive floating-point value.
Reference: 11. <author> IEEE Standards Board. </author> <title> IEEE Standard for Binary Floating-Point Arithmetic. </title> <institution> ANSI/IEEE Std 754-1985, The Institute of Electrical and Electronics Engineers, </institution> <year> 1988. </year>
Reference-contexts: The enhanced floating-point system that will be constructed will be proved to have a model that encompasses a significant portion of the IEEE standard for floating-point arithmetic. <ref> [11] </ref> This will insure that the axioms describe a consistent system that is realistic. Also, any applications proved correct will be able to execute using the model. An application program that uses the enhanced floating-point formalization will be proved correct.
Reference: 12. <author> Matthew Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Technical Report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May, </month> <year> 1988. </year>
Reference-contexts: Nevertheless, to the author's knowledge no mechanically-checked proof about a floating-point program has ever before been constructed. PC-NQTHM, the Kaufmann Proof-Checker extension of the NQTHM prover, allows the user finer control of the direction of the prover. <ref> [12] </ref> It is particularly valuable when the underlying theory is immature, as is currently the case with the current development of rational number arithmetic and floating-point operations. Many of the theorems in this project were proved correct using the tools provided by this interactive enhancement. <p> By induction on find-func-zero (justified by lemma 5) and lemmas 6 and 7, the correctness theorem holds. (find-func-zero-returns-a-zero,find-func-zero-returns-close-values) 5.2 An NQTHM Zero-Finding Program and Correctness Theorem The zero-finding program and its correctness proof have been formalized in the NQTHM logic. [4] The proof checker enhancement of the theorem prover <ref> [12] </ref> has accepted the program and its proof. Axiomatized functions were added using constrain events that have been proved to keep the prover state consistent. [5] The following events have been accepted by the theorem prover. <p> Some of events use (RPLUS (SQUARE (RPLUS (RTIMES A R) (RPLUS (RTIMES B S) proof-checker instructions as hints to prover <ref> [12] </ref>. <p> Some of events use proof-checker instructions as hints to prover <ref> [12] </ref>. <p> Some of events use proof-checker instructions as hints to (fpp x)(numberp (numerator (fix-rational delta)))(not (equal (numerator (fix-rational delta)) 0)) the prover <ref> [12] </ref>.
Reference: 13. <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming. Volume 2/ Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: Advantages inherent in floating-point numbers were recognized early in the development of modern computers, and many early machines had floating-point capability. <ref> [13] </ref> Floating-point numbers seemed to make programming easier as operations on very small numbers and very large numbers had the same precision and could usually be handled with little concern about violating range restrictions. <p> Testing practices developed with an understanding of the implementation of floating-point programs are used by some programmers to give them increased confidence in their programs. [15] Knuth included analysis of floating-point programs in his programming recipes book. <ref> [13] </ref> One of the 2 techniques for analyzing floating-point arithmetic to which he refers is Wilkinson's "backward" error analysis. [18] Rather than bound the inexactness of floating-point operations by bounding the result, Wilkinson shows that it is often simpler to view the inexact result of floating-point operations as the exact result <p> Knuth observes that "many a serious mathematician has attempted to give rigorous analyses of a sequence of floating-point operations, but has found the task to be so formidable he has tried to content himself with plausibility arguments instead" <ref> [13] </ref>. The many details of a proof about floating-point programs are often 3 not of great interest, so the disadvantage of many machine-checked proofs - that the proof is obscure - is usually not relevant in this domain.
Reference: 14. <author> Richard Mansfield. </author> <title> "A Complete Axiomatization of Computer Arithmetic". </title> <booktitle> Mathematics of Computation 42, </booktitle> <month> 166 (April </month> <year> 1984). </year>
Reference-contexts: Several researchers have also proposed models of floating-point operations and used them to justify claims about sequences of floating point operations. <ref> [6, 8, 14, 17] </ref> These efforts work toward putting floating-point arithmetic on more-solid ground. Even so, the complexity of proofs using these systems, and the apparent gap between the floating-point axioms and "realistic" numerical programs has discouraged application of work in this area.
Reference: 15. <author> Webb Miller. </author> <title> The Engineering of Numerical Software. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1984. </year>
Reference-contexts: There has been much less work has been done to prove the correctness of floating-point programs. Testing practices developed with an understanding of the implementation of floating-point programs are used by some programmers to give them increased confidence in their programs. <ref> [15] </ref> Knuth included analysis of floating-point programs in his programming recipes book. [13] One of the 2 techniques for analyzing floating-point arithmetic to which he refers is Wilkinson's "backward" error analysis. [18] Rather than bound the inexactness of floating-point operations by bounding the result, Wilkinson shows that it is often simpler
Reference: 16. <author> J Strother Moore. PITON: </author> <title> A Verified Assembly Level Language. </title> <type> Technical Report 22, </type> <institution> Computational Logic, Inc., </institution> <year> 1988. </year>
Reference-contexts: The floating-point system model could actually be implemented. This entails writing a compiler for a portion of the logic that includes floating point operations. The target language of the compiler would probably 24 be Piton <ref> [16] </ref> so that the resulting code could be run on the verified stack. [3] The appeal of verifying a floating-point program down to the level of hardware is very strong.
Reference: 17. <author> B A Wichmann. </author> <title> "Towards a Formal Specification of Floating Point". </title> <note> Computer Journal 32 (December 1989). </note>
Reference-contexts: Several researchers have also proposed models of floating-point operations and used them to justify claims about sequences of floating point operations. <ref> [6, 8, 14, 17] </ref> These efforts work toward putting floating-point arithmetic on more-solid ground. Even so, the complexity of proofs using these systems, and the apparent gap between the floating-point axioms and "realistic" numerical programs has discouraged application of work in this area.
Reference: 18. <author> J. H. Wilkinson. </author> <title> Rounding Errors in Algebraic Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1963. </year> <title> Table of Contents </title>
Reference-contexts: of the implementation of floating-point programs are used by some programmers to give them increased confidence in their programs. [15] Knuth included analysis of floating-point programs in his programming recipes book. [13] One of the 2 techniques for analyzing floating-point arithmetic to which he refers is Wilkinson's "backward" error analysis. <ref> [18] </ref> Rather than bound the inexactness of floating-point operations by bounding the result, Wilkinson shows that it is often simpler to view the inexact result of floating-point operations as the exact result of perturbed arguments. <p> It appears that backward error analysis of floating-point programs <ref> [18] </ref> might benefit from algorithms that automate finding the consistency of sets of inequalities. Such a theorem prover might quickly verify the correctness of the statement of backward error theorems. This possibility will be further explored, and if it seems fruitful such a system will be built.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: Much of the effort toward precisely specifying floating-point operations has been motivated by the desire to implement floating-point operations correctly. Researchers at Oxford University have formalized a floating-point system expressed using Z and Occam <ref> [1] </ref>. Their ultimate goal is to construct a floating-point processor that correctly implements the formal description of the floating-point system.





References-found: 19

