URL: http://www.cs.wisc.edu/wpis/papers/fse94.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Speeding up Slicing  
Author: Thomas Reps, Susan Horwitz, Mooly Sagiv, and Genevieve Rosay 
Keyword: CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques programmer workbench; D.2.6 [Software Engineering]: Programming Environments; D.2.7 [Software Engineering]: Distribution and Maintenance enhancement, restructuring; E.1 [Data Structures] graphs General Terms: Algorithms, Performance Additional Key Words and Phrases: dynamic programming, dynamic transitive closure, ow-sensitive summary information, program debugging, program dependence graph, program slicing, realizable path  
Affiliation: University of Wisconsin-Madison  
Abstract: Program slicing is a fundamental operation for many software engineering tools. Currently, the most efficient algorithm for interprocedural slicing is one that uses a program representation called the system dependence graph. This paper defines a new algorithm for slicing with system dependence graphs that is asymptotically faster than the previous one. A preliminary experimental study indicates that the new algorithm is also significantly faster in practice, providing roughly a 6-fold speedup on examples of 348 to 757 lines. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Agrawal, H., </author> <title> On slicing programs with jump statements, </title> <booktitle> Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design and Implementation, </booktitle> <address> (Orlando, FL, </address> <month> June 22-24, </month> <year> 1992), </year> <journal> ACM SIGPLAN Notices 29(6) pp. </journal> <month> 302-312 (June </month> <year> 1994). </year>
Reference-contexts: Summing over all procedures in the program, the total cost of the algorithm is bounded by function ComputeSummaryEdges (G: SDG) returns set of edges declare PathEdge, SummaryEdge, WorkList: set of edges procedure Propagate (e: edge) begin <ref> [1] </ref> if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList
Reference: 2. <author> Ball, T. and Horwitz, S., </author> <title> Slicing programs with arbitrary control ow, pp. </title> <booktitle> 206-222 in Proceedings of the First International Workshop on Automated and Algorithmic Debugging, </booktitle> <address> (Linko .. ping, Sweden, </address> <month> May </month> <year> 1993), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 749, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1993). </address>
Reference-contexts: procedures in the program, the total cost of the algorithm is bounded by function ComputeSummaryEdges (G: SDG) returns set of edges declare PathEdge, SummaryEdge, WorkList: set of edges procedure Propagate (e: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin <ref> [2] </ref> PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case
Reference: 3. <author> Bannerjee, U., </author> <title> Speedup of ordinary programs, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> R-79-989, Dept. of Computer Science, University of Illi-nois, Urbana, </institution> <address> IL (October 1979). </address>
Reference-contexts: algorithm is bounded by function ComputeSummaryEdges (G: SDG) returns set of edges declare PathEdge, SummaryEdge, WorkList: set of edges procedure Propagate (e: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := <ref> [3] </ref> for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such
Reference: 4. <author> Bates, S. and Horwitz, S., </author> <title> Incremental program testing using program dependence graphs, pp. </title> <booktitle> 384-396 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Charleston, SC, </address> <month> January 10-13, </month> <year> 1993), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1993). </address>
Reference-contexts: (G: SDG) returns set of edges declare PathEdge, SummaryEdge, WorkList: set of edges procedure Propagate (e: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) <ref> [4] </ref> insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges
Reference: 5. <author> Binkley, D., </author> <title> Multi-procedure program integration, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> TR-1038, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: PathEdge, SummaryEdge, WorkList: set of edges procedure Propagate (e: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge <ref> [5] </ref> insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w)
Reference: 6. <author> Binkley, D., </author> <title> Using semantic differencing to reduce the cost of regression testing, </title> <booktitle> Proceedings of the 1992 Conference on Software Maintenance (Orlando, Flori da), </booktitle> <pages> pp. 41-50 (November 9-12, </pages> <year> 1992). </year>
Reference-contexts: Propagate (e: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList <ref> [6] </ref> od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case
Reference: 7. <author> Binkley, D., </author> <title> Interprocedural constant propagation using dependence graphs and a data-ow model, pp. </title> <booktitle> 374-388 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edinburgh, U.K., </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. </editor> <address> P.A. </address> <publisher> Fritzson, Springer-Verlag, </publisher> <address> New York, NY (1994). </address>
Reference-contexts: edge) begin [1] if e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od <ref> [7] </ref> while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices
Reference: 8. <author> Chase, D.R., Wegman, M., and Zadeck, F.K., </author> <title> Analysis of pointers and structures, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 296-310 (June </month> <year> 1990). </year>
Reference-contexts: e / PathEdge then insert e into PathEdge; insert e into WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do <ref> [8] </ref> select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for
Reference: 9. <author> Choi, J.-D. and Ferrante, J., </author> <title> Static slicing in the presence of GOTO statements, </title> <journal> ACM Letters on Pro graming Languages and Systems, </journal> <year> (1994). </year>
Reference-contexts: WorkList fi end begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList <ref> [9] </ref> switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn
Reference: 10. <author> Gallagher, K.B. and Lyle, J.R., </author> <title> Using program slicing in software maintenance, </title> <journal> IEEE Transactions on Software Engineering 17(8) pp. </journal> <month> 751-761 (August </month> <year> 1991). </year>
Reference-contexts: begin [2] PathEdge := ; SummaryEdge := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v <ref> [10] </ref> case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18]
Reference: 11. <author> Goff, G., Kennedy, K., and Tseng, C.-W., </author> <title> Practical dependence testing, </title> <booktitle> Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 15-29 (June </month> <year> 1991). </year>
Reference-contexts: := ; WorkList := [3] for each w FormalOutVertices (G) [4] insert (w fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : <ref> [11] </ref> for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in
Reference: 12. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference-contexts: fi w) into PathEdge [5] insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do <ref> [12] </ref> Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that
Reference: 13. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: insert (w fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) <ref> [13] </ref> od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do
Reference: 14. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: An example in which this produces an overly conservative slice is given in Figure 2. Interprocedural-slicing algorithms that solve the two problems illustrated above were given by Horwitz, Reps, and Binkley <ref> [14] </ref>, and by Hwang, Du, and Chou [16]. Hwang, Du, and Chou give no analysis of their algorithm's complexity; however, as we show in Appendix A, in the worst case the time used by their algorithm is exponential in the size of the program. <p> BACKGROUND: INTERPROCEDURAL SLICING USING SYSTEM DEPENDENCE GRAPHS 2.1. System Dependence Graphs System dependence graphs were defined in <ref> [14] </ref>. Due to space limitations we will not give a detailed definition here; the important ideas should be clear from the examples. A program's system dependence graph (SDG) is a collection of procedure dependence graphs (PDGs): one for each procedure. <p> SDG by call edges (which represent procedure calls, and run from a call vertex to an entry vertex) and by parameter-in and parameter-out edges (which represent parameter passing, and which run from an actual-in vertex to the corresponding formal-in vertex, and from a formal-out vertex to 1 As defined in <ref> [14] </ref>, procedure dependence graphs include four kinds of dependence edges: control, loop-independent ow, loop-carried ow, and def-order. Howev er, for slicing the distinction between loop-independent and loop-carried ow edges is irrelevant, and def-order edges are not used. <p> Previous work has investigated how to build dependence graphs for the features and constructs found in real-world programming languages. For example, previous work has addressed arrays [3,27,21,11,23,24], reference parameters <ref> [14] </ref>, pointers [20,12,8], and nonstructured control ow [2,9,1]. PDG: to compute the slice with respect to PDG vertex v, find all PDG vertices from which there is a path to v along control and/or ow edges [22]. <p> fi w) into WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od <ref> [14] </ref> end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate <p> COMPARISON WITH PREVIOUS WORK The cost of interprocedural slicing using the algorithm of Horwitz, Reps, and Binkley is dominated by the cost of computing summary edges via the HRB-summary algorithm (see <ref> [14] </ref>): O ((TotalSites E Params) + (TotalSites Sites 2 Params 4 The main result of this paper is a new algorithm for comput ing summary edges whose cost is bounded by O ((P E Params) + (TotalSites Params 3 Under the reasonable assumption that the total number of call sites in
Reference: 15. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 234-245 (June </month> <year> 1990). </year>
Reference-contexts: WorkList [6] od [7] while WorkList do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case <ref> [15] </ref> case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a)
Reference: 16. <author> Hwang, J.C., Du, M.W., and Chou, C.R., </author> <title> Finding program slices for recursive procedures, </title> <booktitle> in Proceedings of IEEE COMPSAC 88, </booktitle> <address> (Chicago, IL, </address> <month> Oct. </month> <pages> 3-7, </pages> <address> 1988), </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC (1988). </address>
Reference-contexts: An example in which this produces an overly conservative slice is given in Figure 2. Interprocedural-slicing algorithms that solve the two problems illustrated above were given by Horwitz, Reps, and Binkley [14], and by Hwang, Du, and Chou <ref> [16] </ref>. Hwang, Du, and Chou give no analysis of their algorithm's complexity; however, as we show in Appendix A, in the worst case the time used by their algorithm is exponential in the size of the program. By contrast, the Horwitz-Reps-Binkley algorithm is a polynomial-time algorithm. <p> do [8] select and remove an edge v fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : <ref> [16] </ref> for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end
Reference: 17. <author> Kernighan, B. and Plauger, P., </author> <title> Software Tools in Pascal, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1981). </address>
Reference-contexts: fi w from WorkList [9] switch v [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do <ref> [17] </ref> let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case [26] default : [27] for each x <p> variables, array variables, assignment statements, conditional statements, output statements, while loops, for loops, and procedures with value-result parameter passing): recdes is a recursive-descent parser for lists of assignment statements; calc is a simple arithmetic calculator; and format is a text-formatting program taken from Kernighan and Plauger's book on software tools <ref> [17] </ref>. The following table gives some statistics about the SDGs of the three test programs: SDG statistics P Sites TotalSites E Params Prog.
Reference: 18. <author> Lakhotia, A., </author> <title> Constructing call multigraphs using dependence graphs, pp. </title> <booktitle> 273-284 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages,(Charleston, </booktitle> <address> SC, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (1993). </address>
Reference-contexts: [10] case v ActualOutVertices (G) : [11] for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) <ref> [18] </ref> y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G)
Reference: 19. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: for each x such that x fi v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in <ref> [19] </ref> insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi
Reference: 20. <author> Larus, J.R. and Hilfinger, </author> <title> P.N., Detecting conicts between structure accesses, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 21-34 (July </month> <year> 1988). </year>
Reference-contexts: v (SummaryEdge ControlEdges (G)) do [12] Propagate (x fi w) [13] od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge <ref> [20] </ref> for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31]
Reference: 21. <author> Maydan, D.E., Hennessy, J.L., and Lam, </author> <title> M.S., Efficient and exact data dependence analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 1-14 (June </month> <year> 1991). </year>
Reference-contexts: od [14] end case [15] case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do <ref> [21] </ref> Propagate (x fi a) [22] od [24] od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure
Reference: 22. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: For example, previous work has addressed arrays [3,27,21,11,23,24], reference parameters [14], pointers [20,12,8], and nonstructured control ow [2,9,1]. PDG: to compute the slice with respect to PDG vertex v, find all PDG vertices from which there is a path to v along control and/or ow edges <ref> [22] </ref>. Interprocedural slices can also be obtained by solving a reachability problem on the SDG; however, the slices obtained using this approach will include the same extra components as illustrated in column 3 of Figure 2. This is because not all paths in the SDG correspond to possible execution paths. <p> case v FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) <ref> [22] </ref> od [24] od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure 6.) O ((P Params E)
Reference: 23. <author> Pugh, W., </author> <title> The omega test: a fast and pratical integer programming algorithm for dependence analysis, </title> <booktitle> in Supercomputing 1991, </booktitle> <month> (November </month> <year> 1991). </year>
Reference: 24. <author> Pugh, W. and Wonnacott, D., </author> <title> Eliminating false data dependences using the omega test, </title> <booktitle> Proceedings of the ACM SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> (San Francisco, CA, </address> <month> June 17-19, </month> <year> 1992), </year> <journal> ACM SIGPLAN Notices 27(7) pp. </journal> <month> 140-151 (July </month> <year> 1992). </year>
Reference-contexts: FormalInVertices (G) : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od <ref> [24] </ref> od [25] end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure 6.) O ((P Params E) + (TotalSites
Reference: 25. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data ow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: : [16] for each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od <ref> [25] </ref> end case [26] default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure 6.) O ((P Params E) + (TotalSites Params 3
Reference: 26. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: Authors' address: Computer Sciences Department; Univ. of Wisconsin; 1210 West Dayton Street; Madison, WI 53706; USA. Electronic mail: -reps, horwitz, sagiv, rosay-@cs.wisc.edu. who gav e algorithms for computing both intra- and inter-procedural slices <ref> [26] </ref>. However, two aspects of Weiser's interprocedural-slicing algorithm can cause it to include extra program components in a slice: 1. <p> each c Callers (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case <ref> [26] </ref> default : [27] for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure 6.) O ((P Params E) + (TotalSites Params 3 4.
Reference: 27. <author> Wolfe, M.J., </author> <title> Optimizing supercompilers for supercomputers, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> R-82-1105, Dept. of Computer Science, University of Illinois, Urbana, </institution> <address> IL (October 1982). </address>
Reference-contexts: (Proc (w)) do [17] let x = CorrespondingActualIn (c, v) [18] y = CorrespondingActualOut (c, w) in [19] insert x fi y into SummaryEdge [20] for each a such that y fi a PathEdge do [21] Propagate (x fi a) [22] od [24] od [25] end case [26] default : <ref> [27] </ref> for each x such that x fi v (FlowEdges (G) ControlEdges (G)) do [28] Propagate (x fi w) [29] od [30] end case [31] end switch [32] od [33] return (SummaryEdge) end (See also Figure 6.) O ((P Params E) + (TotalSites Params 3 4.
References-found: 27

