URL: http://www.cs.uni-bonn.de/III/lehre/vorlesungen/Softwaretechnologie/SS96/Material/EA/occam1.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/III/lehre/vorlesungen/Softwaretechnologie/SS96/HTML/literatur.html
Root-URL: http://cs.uni-bonn.de
Email: email: boerger@di.unipi.it  email: igor@uni-paderborn.de  email: dean@math.hr  
Title: 489 Occam: Specification and Compiler Correctness Part I: The Primary Model  
Author: Egon Borger a and Igor D urd -anovic b and Dean Rosenzweig c 
Keyword: Keyword Codes: C.1.0; C.2.4; D.3.1 Keywords: Processor Architectures, General, Distributed Systems; Software, Formal Definitions and Theory  
Address: Pisa, Cso Italia 40, I-56100 Pisa  17 Informatik, Warburgerstr. 100, D-33098 Paderborn  Zagreb, FSB, Salajeva 5, 41000 Zagreb, Croatia  
Affiliation: a Dipartimento di Informatica, Universita di  b University Paderborn, FB  c University of  
Abstract: We develop several simple operational models of Occam at different levels of abstraction, and relate them by relative correctness proofs, aiming at a transparent mathematical correctness proof for a general compilation scheme of Occam programs on the Transputer. Starting from a primary truly concurrent model of the language, we refine its salient concurrent features | communication, parallelism and alternation | to an abstract notion of processor, running a queue of processes, still close to the abstraction level of atomic Occam commands. The specification is effected within the framework of evolving algebras of Gurevich, relying on the theory of concurrency developed recently within that framework by Glavan and Rosenzweig. The model lends itself naturally to refinement down to the abstraction level of Transputer Instruction Set architecture, foreseen for a sequel to this paper. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.P. Bowen, He Jifeng, P.K. Pandaya, </author> <year> 1990, </year> <title> An Approach to Verifiable Compiling Specification and Prototyping, </title> <publisher> Springer Verlag, LNCS 456, </publisher> <pages> pp 45-59. </pages>
Reference-contexts: We undertake to complete such a proof in a sequel to this paper. Unlike formal studies of implementations of Occam sublanguages <ref> [1] </ref>, [12] based on "The laws of Occam Programming" [17], we interpret the Occam programs as they are without reducing them to normal form.
Reference: 2. <author> J.P. Bowen,1993, </author> <title> From Programs to Object Code and back again using Logic Programming: Compilation and Decompilation, in: </title> <journal> Journal of Software Maintenance: Research and Practice 5(4) </journal> <pages> 205-234. 508 </pages>
Reference-contexts: Note that we could have presented our rules in the form of Horn clauses and interpret them as "compiling" the described Occam constructs into Prolog; see <ref> [2] </ref> where the compiling specifications, obtained for the sequential sublanguage of Occam via "laws of Occam programming", are transformed into logic programs. Our proofs show the correctness of a compilation scheme. This is different from proving a concrete compiler to be correct, an approach investigated in [6].
Reference: 3. <author> E.Borger & D.Rosenzweig, </author> <year> 1994, </year> <title> A mathematical definition of Full Prolog, </title> <note> in: Science of Computer Programming (to appear). </note>
Reference-contexts: The concept has turned out to be a remarkably successful tool for formal specification of complex systems through hierarchies of abstraction levels, stepwise refined. The reader might look e.g. at simple but precise modeling of full fledged programming languages such as C [10] and Prolog <ref> [3] </ref> provided by evolving algebras at various levels of abstraction. In particular in [4] a formal specification of the Warren Abstract Machine has been derived | refining stepwise the formal Prolog specification of [3] | and used to prove the correctness of a general compilation scheme for Prolog programs on the <p> e.g. at simple but precise modeling of full fledged programming languages such as C [10] and Prolog <ref> [3] </ref> provided by evolving algebras at various levels of abstraction. In particular in [4] a formal specification of the Warren Abstract Machine has been derived | refining stepwise the formal Prolog specification of [3] | and used to prove the correctness of a general compilation scheme for Prolog programs on the WAM. <p> We only remind the reader that in the rules below, the updates are thought to be executed simultaneously. For comparison of the evolving algebra approach to SOS [16] see the introduction to <ref> [3] </ref>. 2. OCCAM | A TRULY CONCURRENT MODEL Our primary model of Occam is abstract, truly concurrent and machine-independent. Occam objects, expressions and their evaluation are represented abstractly.
Reference: 4. <author> E.Borger & D.Rosenzweig, </author> <year> 1994, </year> <title> The WAM|Definition and Compiler Correctness, in: Logic Programming: Formal Methods and Practical Applications, </title> <editor> C.Beierle, L.Plumer, eds., North-Holland, </editor> <booktitle> Series in Computer Science and Artificial Intelligence. </booktitle>
Reference-contexts: The reader might look e.g. at simple but precise modeling of full fledged programming languages such as C [10] and Prolog [3] provided by evolving algebras at various levels of abstraction. In particular in <ref> [4] </ref> a formal specification of the Warren Abstract Machine has been derived | refining stepwise the formal Prolog specification of [3] | and used to prove the correctness of a general compilation scheme for Prolog programs on the WAM. <p> This establishes the Main Theorem. 5. CONCLUSION The scope of the evolving algebra methodology is not exhausted by high-level descriptions, such as the one produced here for Occam. In <ref> [4] </ref> we have shown how such a description can be transformed (provably correctly) to a low level abstract machine like the WAM.
Reference: 5. <author> G.N. Buckley, A. Silberschatz, </author> <year> 1982, </year> <title> An Effective Implementation for the Generalized Input-Output Construct of CSP, </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, No. 2, </volume> <pages> pp. 223-235. </pages>
Reference-contexts: Our proofs show the correctness of a compilation scheme. This is different from proving a concrete compiler to be correct, an approach investigated in [6]. The framework developed here could also be used to recast and compare other proposals for a "correct" implementation of Hoare's CSP. One example is <ref> [5] </ref> where also output statements are allowed in the guards for alternative and iterative commands.
Reference: 6. <author> B. Buth et. al., </author> <year> 1992, </year> <title> Provably Correct Compiler Implementation, </title> <editor> in U. Karstens and P. Pfahler (eds.) </editor> <booktitle> Compiler Construction, </booktitle> <publisher> Springer Verlag, LNCS 641, </publisher> <pages> pp. 141-155. </pages>
Reference-contexts: Our proofs show the correctness of a compilation scheme. This is different from proving a concrete compiler to be correct, an approach investigated in <ref> [6] </ref>. The framework developed here could also be used to recast and compare other proposals for a "correct" implementation of Hoare's CSP. One example is [5] where also output statements are allowed in the guards for alternative and iterative commands.
Reference: 7. <author> P. Glavan & D. Rosenzweig, </author> <year> 1993, </year> <title> Communicating Evolving Algebras, </title> <booktitle> in: Computer Science Logic , Selected Papers from CSL'92 (eds. </booktitle> <editor> E. Borger, S. Martini, G.Jager, H.Kleine Buning, M. M. Richter), </editor> <publisher> Springer LNCS 702, </publisher> <pages> pp. 186-215. </pages>
Reference-contexts: Here we use the Glavan-Rosenzweig concurrency theory (developed in the meantime within the framework of 490 evolving algebras <ref> [7] </ref>) which allows us to extend the methodology to a mathematical correctness proof for a general compilation scheme of Occam programs on the Transputer [13], [14], [19], wrt a truly concurrent model of the language. <p> At each step a simple proof of correctness and completeness wrt to the basic model is given. For the benefit of a reader interested in models rather than proofs, we postpone the latter to Section 4 which presupposes the theory of <ref> [7] </ref>. The refinements are developed in Section 3. Each refinement comes by refining the signature and/or the rules and by relating correspondent runs of the two algebras. <p> end then count (father (x)) = 1 delete x count (x) if x sleeps ^ count (x) = 0 then count (x) : = 1 wakeup x Here `x sleeps' abbreviates mode (x) = sleeping and count (father (x)) = 1 stands for decrementing a distributed counter, as discussed in <ref> [7] </ref>. Different child-daemons can terminate independently. Since the effect of their execution consists in modifying the unique store (suppressed at this level of abstraction), no result needs to be explicitly communicated back to the father. <p> These assumptions are in no way necessary for our algebra to run | it could accommodate other notions of concurrent programming. Under the above assumptions, however, it is easy to see that the above Occam 0 -algebra enjoys the following independence property (for the notion of independence defined in <ref> [7] </ref> which roughly speaking says that two rules are independent if none of them modifies what the other uses). Independence Property. <p> wakeup reader (C); wakeup writer (C); clear C 497 Intuitively com (x; c; v; y; d; t) gets implemented as (in (x; c; v) j out (y; d; t)) chan (c) (see 4.1 for detailed arguments) 5 ; j here indicates independence, including arbitrariness of sequencing, rather than simultaneity (cf. <ref> [7] </ref>). Note that the Independence Property is preserved, and that it is the Channel Assumption which allows in and out to execute without asking whether reader resp. writer is nil . <p> as follows: enable (b; x; c) def = if eval (b; env (x)) ^ agent (c) = nil then agent (c) : = x disable (b; x; c) def = if eval (b; env (x)) ^ agent (c) = x then agent (c) : = nil Minding the notation from <ref> [7] </ref>, of R? and R! for, respectively, guards and updates of a rule R, we have the following new in/out rules: in idle (x; c; v) if x does c?v ^ (internal c ^ idle c) or external c then in (x; c; v)! out idle (x; c; t) if x <p> RELATING THE MODELS In this section we prove the theorems stated above, using the framework of <ref> [7] </ref>. We shall say that (possible) runs ae; oe are equivalent , ae oe, if haeiOE , hoeiOE for any formula OE. <p> Strong equivalence, ', is the smallest equivalence relation which puts any run together with all its sequentializations. Strongly equivalent runs are equivalent (see <ref> [7] </ref>). Under strong equivalence we forget rearrangements of actions allowed by independence. These notions are, of course, always to be understood as relative to a static algebra in which the runs considered are possible.
Reference: 8. <author> Ian Graham, </author> <year> 1990, </year> <title> The Transputer Handbook, </title> <publisher> Prentice Hall. </publisher>
Reference: 9. <author> Y.Gurevich, </author> <year> 1991, </year> <title> Evolving Algebras. A Tutorial Introduction, </title> <journal> EATCS Bulletin 43, </journal> <month> February </month> <year> 1991, </year> <pages> pp. 264-284. </pages>
Reference-contexts: 1. INTRODUCTION Gurevich <ref> [9] </ref> has introduced evolving algebras into semantics in order to study the dynamic and resource-bounded aspects of computation on their own terms. The concept has turned out to be a remarkably successful tool for formal specification of complex systems through hierarchies of abstraction levels, stepwise refined. <p> Note that communication in Occam is synchronous. In the primary model communication is effected in one blow, while waiting for a ready communicating partner is left implicit, as built into the evolving algebra execution mechanism <ref> [9] </ref>. Our primary model is thus a `purely high-level programmer's view', closer to the CSP background of Occam than to its Transputer implementation. <p> The refinements are proved correct and complete under the usual Occam assumptions on usage of channels. Thus we prove: Main Theorem. The sequential implementation Occam s of Occam 0 with time-slicing is correct and complete. Due to space limits, for the notion of evolving algebras we refer to <ref> [9] </ref>. The specification of Occam semantics can nevertheless be understood because evolving algebra rules can easily be read as 'pseudocode' over abstract data. We only remind the reader that in the rules below, the updates are thought to be executed simultaneously. <p> then write eval (t; env (y)) to x at v; proceed x; proceed y 3 The notion of `external' function is the evolving algebra way of describing an interface with the `outside world' | its values are to be considered as not determined by our rules or initial state (cf. <ref> [9] </ref> for discussion), but might be subject to change due to actions of the environment. 494 where c; d mean the binding of (channel) identifier c; d in env (x); env (y) respectively.
Reference: 10. <author> Y. Gurevich & J. K. Huggins, </author> <year> 1993, </year> <title> The Semantics of the C Programming Language, </title> <booktitle> in: Computer Science Logic , Selected Papers from CSL'92 (eds. </booktitle> <editor> E. Borger, S. Martini, G.Jager, H.Kleine Buning., M. M. Richter), </editor> <publisher> Springer LNCS 702, </publisher> <pages> pp. 274-308. </pages>
Reference-contexts: The concept has turned out to be a remarkably successful tool for formal specification of complex systems through hierarchies of abstraction levels, stepwise refined. The reader might look e.g. at simple but precise modeling of full fledged programming languages such as C <ref> [10] </ref> and Prolog [3] provided by evolving algebras at various levels of abstraction.
Reference: 11. <author> Y. Gurevich & L. Moss, </author> <year> 1990, </year> <title> Algebraic Operational Semantics and Occam, </title> <booktitle> in: CSL'89, 3d Workshop on Computer Science Logic (E. </booktitle> <editor> Borger, H. Kleine Buning, M.M. Richter, eds.), </editor> <publisher> Springer LNCS 440, </publisher> <pages> 176-192. </pages>
Reference-contexts: An implementation-wise programmer may thus find one of the following refinements to be closer to his intuition; of course they become more complex, resembling the Transputer implementation. 1 The description in <ref> [11] </ref> is parse tree based.
Reference: 12. <author> He Jifeng, J.P. Bowen, </author> <year> 1993, </year> <title> Specification, Verification and Prototyping of an Optimized Compiler, in: </title> <journal> Formal Aspects of Computing. </journal>
Reference-contexts: We undertake to complete such a proof in a sequel to this paper. Unlike formal studies of implementations of Occam sublanguages [1], <ref> [12] </ref> based on "The laws of Occam Programming" [17], we interpret the Occam programs as they are without reducing them to normal form.
Reference: 13. <author> Inmos, </author> <title> Transputer Implementation of Occam. In: Communication Process Architecture, </title> <publisher> Prentice Hall, note 21. </publisher>
Reference-contexts: Here we use the Glavan-Rosenzweig concurrency theory (developed in the meantime within the framework of 490 evolving algebras [7]) which allows us to extend the methodology to a mathematical correctness proof for a general compilation scheme of Occam programs on the Transputer <ref> [13] </ref>, [14], [19], wrt a truly concurrent model of the language. To justify fully the ultimate correctness claim, we start from a primary, high level, truly concurrent operational semantics for Occam.
Reference: 14. <author> Inmos, </author> <year> 1988, </year> <title> Transputer Instruction Set A compiler writer's guide, INMOS document 72 TRN 119 05, </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: Here we use the Glavan-Rosenzweig concurrency theory (developed in the meantime within the framework of 490 evolving algebras [7]) which allows us to extend the methodology to a mathematical correctness proof for a general compilation scheme of Occam programs on the Transputer [13], <ref> [14] </ref>, [19], wrt a truly concurrent model of the language. To justify fully the ultimate correctness claim, we start from a primary, high level, truly concurrent operational semantics for Occam.
Reference: 15. <author> I. Page, W. Luk, </author> <year> 1991, </year> <title> Compiling Occam into field-programmable gate arrays, </title> <booktitle> in FPGAs, Oxford Workshop on Field Programmable Logic and Applications, </booktitle> <publisher> Abingdon EE&CS Books, </publisher> <pages> pp 271-283. </pages>
Reference-contexts: To represent Occam dynamics, we introduce a universe DAEMON of agents (processes), which walk around the graph carrying their own environments, and may also be sleeping, as given by: loc : DAEMON ! NODE , env : DAEMON ! ENV , mode : DAEMON ! frunning, sleeping g. 2 In <ref> [15] </ref> slight variants of the above pictures are interpreted as compiling occam statements into field-programmable gate arrays. 493 The function loc represents the `program counter' of the daemon, the place he is just visiting in the flowchart. The function env represents the current environment of the daemon.
Reference: 16. <author> G. Plotkin, </author> <year> 1981, </year> <title> A structural approach to operational semantics, </title> <type> International Report, </type> <institution> CS Department, Aarhus University, DAIMI FN-19. </institution>
Reference-contexts: The specification of Occam semantics can nevertheless be understood because evolving algebra rules can easily be read as 'pseudocode' over abstract data. We only remind the reader that in the rules below, the updates are thought to be executed simultaneously. For comparison of the evolving algebra approach to SOS <ref> [16] </ref> see the introduction to [3]. 2. OCCAM | A TRULY CONCURRENT MODEL Our primary model of Occam is abstract, truly concurrent and machine-independent. Occam objects, expressions and their evaluation are represented abstractly.
Reference: 17. <author> A.W. Roscoe, C.A.R. Hoare, </author> <year> 1988, </year> <title> Laws of occam programming, </title> <booktitle> in Theoretical Computer Science, </booktitle> <volume> 60, </volume> <pages> pp 177-229. </pages>
Reference-contexts: We undertake to complete such a proof in a sequel to this paper. Unlike formal studies of implementations of Occam sublanguages [1], [12] based on "The laws of Occam Programming" <ref> [17] </ref>, we interpret the Occam programs as they are without reducing them to normal form.
Reference: 18. <author> D.Scott, </author> <title> Outline of a Mathematical Theory of Computation, </title> <type> Technical Monograph PRG-2, </type> <month> November </month> <year> 1970, </year> <title> Oxford University Comp.Lab., </title> <booktitle> Programming Res.Group, </booktitle> <pages> pp 1-24 </pages>
Reference: 19. <editor> D.A.P. Mitchell, et al, </editor> <year> 1990, </year> <title> Inside the Transputer, </title> <publisher> Blackwell Scientific Publications. </publisher> <address> PS. </address> <note> The present paper appeared in: </note> <editor> U. Montanari, E. - R.Olderog (Eds.), </editor> <booktitle> Proc. Procomet'94, IFIP TC 2 Working Conference on Programming Concepts, Methods and Calculi, </booktitle> <publisher> North-Holland 1994. </publisher>
Reference-contexts: Here we use the Glavan-Rosenzweig concurrency theory (developed in the meantime within the framework of 490 evolving algebras [7]) which allows us to extend the methodology to a mathematical correctness proof for a general compilation scheme of Occam programs on the Transputer [13], [14], <ref> [19] </ref>, wrt a truly concurrent model of the language. To justify fully the ultimate correctness claim, we start from a primary, high level, truly concurrent operational semantics for Occam. <p> ready C def = reader (C) 6= nil ^ writer (C) 6= nil idle C def = reader (C) = nil ^ writer (C) = nil clear C def = reader (C) : = nil ; writer (C) : = nil This corresponds to the description of `external channels' in <ref> [19] </ref>. in (x; c; v) if x does c?v then put x asleep at next (loc (x)) reader (c) : = x place (c) : = v c mode (x) : = input out (x; c; t) if x does c!t then put x asleep at next (loc (x)) writer (c)
References-found: 19

