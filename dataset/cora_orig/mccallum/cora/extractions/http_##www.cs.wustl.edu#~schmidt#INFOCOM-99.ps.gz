URL: http://www.cs.wustl.edu/~schmidt/INFOCOM-99.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/doc-center.html
Root-URL: http://www.cs.wustl.edu
Email: gokhale@research.bell-labs.com schmidt@cs.wustl.edu  
Title: Techniques for Optimizing CORBA Middleware for Distributed Embedded Systems  
Author: Aniruddha Gokhale Douglas C. Schmidt 
Keyword: KeywordsCommunication protocols and software, Real-time CORBA, minimal ORB footprint, performance, hand-held devices.  
Address: 600 Mountain Avenue One Brookings Drive Murray Hill, NJ 07974 St. Louis, MO 63130  
Affiliation: Bell Laboratories Dept. of Computer Science Lucent Technologies Washington University  
Abstract: This paper appeared in the proceedings of IEEE INFOCOM '99, New York, New York, March 2125th, 1999. AbstractThe distributed embedded systems industry is poised to leverage emerging real-time operating systems, such as Inferno, Windows CE, EPOC, and Palm OS to support mobile communication applications, such as electronic mail, Internet browsing, and network management. Ideally, these applications can be developed using standard middleware components like CORBA to improve their quality and reduce their cost and cycle time. However, stringent constraints on memory available in embedded systems imposes a severe limit on the footprint of CORBA middleware. This paper provides three contributions to the study and design of small footprint, embedded CORBA middleware. First, we describe the optimizations used to develop the protocol engine and CORBA IDL compiler provided by TAO, which is our real-time CORBA implementation. TAO's IDL compiler produces stubs that can use either compiled and/or interpretive marshaling. Second, we compare the performance and footprint of TAO IDL compiler-generated stubs and skeletons that use compiled and/or interpretive marshaling for a wide range of IDL data types. Third, we illustrate the benefits of the small footprint and efficiency of TAO IDL compiler-generated stubs and skeletons for CORBA Object Services implemented using TAO. Our results comparing the performance of the compiled and interpretive stubs and skeletons indicate that the interpretive stubs and skeletons perform between 75-100% of the compiled stubs and skeletons for a wide range of data types. However, the code size for the interpreted stubs and skeletons was between 26-45% and 50-80% of the compiled stubs and skeletons, respectively. These results indicate a positive step towards implementing high performance, small footprint middleware for distributed embedded systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Richard Comerford, </author> <title> Pocket Computers Ignite OS Battle, </title> <journal> IEEE Spectrum, </journal> <volume> vol. 35, no. 5, </volume> <pages> pp. 4348, </pages> <month> May </month> <year> 1998. </year>
Reference: [2] <author> G. Forman and J. Zahorhan, </author> <title> The Challenges of Mobile Computing, </title> <journal> IEEE Computer, </journal> <volume> vol. 27, no. 4, </volume> <pages> pp. 3847, </pages> <month> April </month> <year> 1994. </year>
Reference: [3] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <address> 2.2 edition, </address> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: However, since the SunSoft IIOP implementation did not have an IDL compiler each stub was hand-crafted. In contrast, the TAO IDL compiler automatically generates stubs that use interpretive (de)marshaling. B.2.b Interpreted skeletons. SunSoft IIOP skeletons use a Dynamic Skeleton Interface (DSI) <ref> [3] </ref> strategy to demarshal parameters. The basic (non-optimized) algorithm for an interpreted skeleton is shown in Figure 4. Each step is described below: 1. Create an NVList, which is a list of name/value pairs, to hold the parameters. 2.
Reference: [4] <author> Steve Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, no. 2, </volume> <month> February </month> <year> 1997. </year>
Reference: [5] <institution> Object Management Group, </institution> <note> Minimum CORBA Joint Revised Submission, OMG Document orbos/98-08-04 edition, </note> <month> August </month> <year> 1998. </year>
Reference: [6] <author> Douglas C. Schmidt, David L. Levine, and Sumedh Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, no. 4, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Table VI shows examples of standard CORBA Object Services, such as the Trading service and Naming service, as well as several services supported by TAO, such as a real-time Scheduling service <ref> [6] </ref>.
Reference: [7] <author> Aniruddha Gokhale and Douglas C. Schmidt, </author> <title> Measuring and Optimizing CORBA Latency and Scalability Over High-speed Networks, </title> <journal> Transactions on Computing, </journal> <volume> vol. 47, no. 4, </volume> <year> 1998. </year>
Reference-contexts: In addition, due to the intermediate stages, it is possible for Flick to map different IDLs (e.g., CORBA IDL, ONC RPC IDL, MIG IDL) to a variety of target languages such as C, C++. B. Related work on CORBA performance measurements: Our earlier benchmarking experiments [12], [19], <ref> [7] </ref> showed that the performance of first-generation CORBA middleware implementations was relatively poor, compared with lower-level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshaling. However, the results of earlier CORBA benchmarking experiments were restricted to measuring the performance of communication between homogeneous ORBs.
Reference: [8] <author> Timothy H. Harrison, David L. Levine, and Douglas C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997, </year> <note> ACM. </note>
Reference: [9] <author> Douglas C. Schmidt, Rajeev Bector, David Levine, Sumedh Mungee, and Guru Parulkar, </author> <title> An ORB Endsystem Architecture for Statically Scheduled Real-time Applications, </title> <booktitle> in Proceedings of the Workshop on Middleware for Real-Time Systems and Services, </booktitle> <address> San Francisco, CA, </address> <month> December </month> <year> 1997, </year> <note> IEEE. </note>
Reference: [10] <author> David Levine, Sergio Flores-Gaitan, and Douglas C. Schmidt, </author> <title> Measuring OS Support for Real-time CORBA ORBs, </title> <booktitle> in Proceedings of the 4 th Workshop on Object-oriented Real-time Dependable Systems, </booktitle> <address> Santa Bar-bara, CA, </address> <month> January </month> <year> 1999, </year> <note> IEEE. </note>
Reference: [11] <author> Douglas C. Schmidt, Sumedh Mungee, Sergio Flores-Gaitan, and Anirud-dha Gokhale, </author> <title> Software Architectures for Reducing Priority Inversion and Non-determinism in Real-time Object Request Brokers, </title> <journal> Journal of Real-time Systems, </journal> <note> To appear 1999. </note>
Reference: [12] <author> Aniruddha Gokhale and Douglas C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> Stanford, CA, </address> <month> August </month> <year> 1996, </year> <booktitle> ACM, </booktitle> <pages> pp. 306 317. </pages>
Reference-contexts: In addition, due to the intermediate stages, it is possible for Flick to map different IDLs (e.g., CORBA IDL, ONC RPC IDL, MIG IDL) to a variety of target languages such as C, C++. B. Related work on CORBA performance measurements: Our earlier benchmarking experiments <ref> [12] </ref>, [19], [7] showed that the performance of first-generation CORBA middleware implementations was relatively poor, compared with lower-level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshaling.
Reference: [13] <author> Aniruddha Gokhale and Douglas C. Schmidt, </author> <title> Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance, </title> <booktitle> in Hawaiian International Conference on System Sciences, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: As a consequence of using patterns, TAO's IDL compiler back-end can be recon-figured readily to produce stubs and skeletons that use either compiled and/or interpretive (de)marshaling. The interpretive stubs and skeletons produced by the back-end of TAO's IDL compiler integrate with TAO's highly optimized IIOP interpretive protocol engine <ref> [13] </ref>. The interpreted stubs and skeletons generated by TAO's IDL compiler are explained below. B.2.a Interpreted stubs. The interpreted stubs produced by TAO's IDL compiler use a table-driven technique to pass parameters to TAO's interpretive IIOP (de)marshaling engine. The basic structure of an interpretive stub is shown in Figure 3. <p> Fig. 4. Unoptimized Skeletons to allocate the parameters on the run-time stack of the skeleton. The heap allocated data structures are owned by the ORB and freed using an interpretive strategy similar to the interpretive (de)marshaling strategy <ref> [13] </ref>. The TAO IDL compiler, in contrast, produces an optimized version of these skeletons automatically. These optimizations include reducing the memory allocation overhead and reducing the size of the skeleton, as described in Section II-C. B.2.c Compiled stubs and skeletons. <p> Linux Performance stubs. This is due to a number of optimizations we developed for the TAO ORB core and its interpretive IIOP (de)marshaling engine <ref> [13] </ref>. As mentioned in Section III-D, these measurements include the effects of the OS, as well as the run-time costs of the operation implementations. These run-time operation implementation costs are more significant for the test struct seq case, where each sequence of structs has 9 variable-sized structs. <p> This design significantly enhances sequence (de)marshaling performance by allowing TAO to use compile-time knowledge of the sequence and its element type for decoding. Thus, there is no need to interpretively decode the sequence using expensive typecode traversals <ref> [13] </ref>. E.2 Comparing Code Size for Stubs and Skeletons This section describes the measurements of code size we did for the stubs and skeletons. As mentioned in Section III-B, we used the GNU binary utility called objdump and NT's dumpbin to measure the individual code sizes. <p> These tests do not explicitly measure the cost of marshaling for all the parameter passing modes. In addition, these tests were restricted to measuring the performance of compiled stubs and skeletons. Our earlier work <ref> [13] </ref> provides a detailed analysis and optimizations for an interpretive marshaling engine. However, that study did not compare interpretive and compiled marshaling. In addition, it did not comment upon the relative code sizes. V.
Reference: [14] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year> <month> 10 </month>
Reference-contexts: To create a complete CORBA IDL compiler for TAO, we developed a back-end for the OMG IDL-to-C++ mapping. TAO's IDL compiler back-end uses several design patterns <ref> [14] </ref>, such as Abstract Factory, Strategy, and Visitor. As a consequence of using patterns, TAO's IDL compiler back-end can be recon-figured readily to produce stubs and skeletons that use either compiled and/or interpretive (de)marshaling.
Reference: [15] <author> Phillip Hoschka and Christian Huitema, </author> <title> Automatic Generation of Optimized Code for Marshalling Routines, </title> <booktitle> in IFIP Conference of Upper Layer Protocols, Architectures and Applications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994, </address> <publisher> IFIP. </publisher>
Reference-contexts: Thus, in this scheme there is no necessity to decipher the type of the data to be marshaled at run-time. Instead, the type is known in advance, which can be used to marshal the data directly. Reference <ref> [15] </ref> describes the tradeoffs of using compiled and interpreted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. Reference [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. <p> Instead, the type is known in advance, which can be used to marshal the data directly. Reference <ref> [15] </ref> describes the tradeoffs of using compiled and interpreted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. Reference [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding [16]. Our TAO IDL compiler can also generate compiled stubs and skeletons.
Reference: [16] <author> International Organization for Standardization, </author> <title> Information processing systems Open Systems Interconnection Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1), </title> <month> May </month> <year> 1987. </year>
Reference-contexts: Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. Reference [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding <ref> [16] </ref>. Our TAO IDL compiler can also generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [17] and Flick [18], which is a flexible, optimizing IDL compiler.
Reference: [17] <author> Sean W. O'Malley, Todd A. Proebsting, and Allen B. Montz, </author> <title> USC: A Universal Stub Compiler, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> London, UK, </address> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: This work was done in the context of the ASN.1/BER encoding [16]. Our TAO IDL compiler can also generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC <ref> [17] </ref> and Flick [18], which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [18] <author> Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom, Flick: </author> <title> A Flexible, Optimizing IDL Compiler, </title> <booktitle> in Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1997, </year> <note> ACM. </note>
Reference-contexts: This work was done in the context of the ASN.1/BER encoding [16]. Our TAO IDL compiler can also generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [17] and Flick <ref> [18] </ref>, which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [19] <author> Aniruddha Gokhale and Douglas C. Schmidt, </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks, </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> London, England, </address> <month> November </month> <year> 1996, </year> <journal> IEEE, </journal> <pages> pp. 5056. </pages>
Reference-contexts: In addition, due to the intermediate stages, it is possible for Flick to map different IDLs (e.g., CORBA IDL, ONC RPC IDL, MIG IDL) to a variety of target languages such as C, C++. B. Related work on CORBA performance measurements: Our earlier benchmarking experiments [12], <ref> [19] </ref>, [7] showed that the performance of first-generation CORBA middleware implementations was relatively poor, compared with lower-level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshaling. However, the results of earlier CORBA benchmarking experiments were restricted to measuring the performance of communication between homogeneous ORBs.
References-found: 19

