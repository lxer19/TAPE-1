URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/survey.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Email: cds@adm.csc.ncsu.edu  
Title: A Survey of Combinatorial Gray Codes  
Author: Carla Savage 
Keyword: Gray codes, Hamilton cycles, acyclic orientations, binary strings, Boolean lattice, Cata-lan families, Cayley graphs, combinations, compositions, de Bruijn sequences, integer partitions, linear extensions, necklaces, permutations, restricted growth functions, set partitions, vertex-transitive graphs.  
Note: AMS Subject Classifications: 94B60, 68R, 05A, 05C (05A05, 05A17, 05A18, 05C25, 05C45, 05C38)  
Date: October 15, 1996  
Address: Box 8206 Raleigh NC 27695-8206  
Affiliation: Department of Computer Science North Carolina State University  
Abstract: The term combinatorial Gray code was introduced in 1980 to refer to any method for generating combinatorial objects so that successive objects differ in some pre-specified, small way. This notion generalizes the classical binary reflected Gray code scheme for listing n-bit binary numbers so that successive numbers differ in exactly one bit position, as well as work in the 1960's and 70's on minimal change listings for other combinatorial families, including permutations and combinations. The area of combinatorial Gray codes was popularized by Herbert Wilf in his invited address at the SIAM Discrete Mathematics Conference in 1988 and his subsequent SIAM monograph in which he posed some open problems and variations on the theme. This resulted in much recent activity in the area and most of the problems posed by Wilf are now solved. In this paper, we survey the area of combinatorial Gray codes, describe recent results, fl Research supported in part by the National Science Foundation Grants CCR8906500 and DMS9302505, the National Security Agency Grant No. MDA904-H-1025, and DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), a National Science Foundation Science and Technology Center, NSF-STC88-09648. variations, and trends, and highlight some open problems.
Abstract-found: 1
Intro-found: 1
Reference: [ABR90] <author> F. Annexstein, M. Baumslag, and A. L. Rosenberg. </author> <title> Group action graphs and parallel architectures. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(3) </volume> <pages> 544-569, </pages> <year> 1990. </year>
Reference-contexts: So, the de Bruijn graph contains cycles of all lengths m n. Results on de Bruijn cycles have been applied to random number generation in information theory [Gol64] and in computer architecture, where the de Bruijn graph is recognized as a bounded degree derivative of the shu*e-exchange network <ref> [ABR90] </ref>. Chung, Diaconis, and Graham generalized the notion of a de Bruijn sequence for binary numbers to universal cycles for other families of combinatorial objects [CDG92]. Universal cycles for combinations were studied by Hurlbert in [Hur90] and some interesting problems remain open.
Reference: [Als81] <author> B. R. Alspach. </author> <title> The search for long paths and cycles in vertex-transitive graphs and digraphs. </title> <booktitle> In Combinatorial Mathematics VIII (Springer Lecture Notes 884), </booktitle> <pages> pages 14-22. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Results on Hamilton cycles are surveyed in <ref> [Als81] </ref> for vertex transitive graphs and in [Gou91] for general graphs. A survey of Hamilton cycles in Cayley graphs can be found in [WG84] and in the recent update of Curran and Gallian [CG96]. We focus here on a few recent questions which arose in the context of Gray codes. <p> Additional information on Gray codes also appears in the survey of Squire [Squ94a]. In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see <ref> [Als81] </ref> for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, [WG84] and the recent update [CG96] for Cayley graphs, and [Sed77] for permutations. Acknowledgements I am grateful to Herb Wilf for collecting and sharing such an intriguing array of `Gray code' problems.
Reference: [ASD90] <author> D. J. Amalraj, N. Sundararajan, and G. Dhar. </author> <title> A data structure based on Gray code encoding for graphics and image processing. </title> <booktitle> Proceedings of the SPIE: International Society for Optical Engineering, </booktitle> <pages> pages 65-76, </pages> <year> 1990. </year> <month> 32 </month>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing <ref> [ASD90] </ref>, processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72].
Reference: [Bab79] <author> L. Babai. </author> <title> Long cycles in vertex-transitive graphs. </title> <journal> Journal of Graph Theory, </journal> <volume> 3 </volume> <pages> 301-304, </pages> <year> 1979. </year>
Reference-contexts: Is there at least a good lower bound on the length of a longest cycle in the middle two levels of the Boolean lattice? Since this graph is vertex-transitive, a result of Babai <ref> [Bab79] </ref> shows that there is a cycle of length at least (3N (k)) 1=2 , where N (k) is the total number of vertices in the middle two levels of B 2k+1 .
Reference: [Bee90] <author> J. Beer. </author> <title> Implementation of an algorithm to list Gray code sequences of partitions. </title> <type> Manuscript, </type> <institution> North Carolina State University, </institution> <year> 1990. </year>
Reference-contexts: It was then shown that the P and M forms could be recursively defined in terms of (smaller versions of) both forms, thereby yielding a doubly recursive construction of the partitions Gray code. The algorithm has been implemented <ref> [Bee90] </ref> and can be modified to run in time O (jP (n; k)j). This strategy has been applied to yield Gray codes for other families of integer partitions.
Reference: [BER76] <author> J. R. Bitner, G. Ehrlich, and E. M. Reingold. </author> <title> Efficient generation of the binary reflected Gray code. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 517-521, </pages> <year> 1976. </year>
Reference-contexts: codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> Since the first and last elements of L n also differ in one bit position, the code is in fact a cycle. It can be implemented efficiently as a loop-free algorithm <ref> [BER76] </ref>. Note that a binary Gray code can be viewed as a Hamilton cycle in the n-cube. In practice, Gray codes with certain additional properties may be desirable (see [GLN88] for a survey). <p> For the subclass of combinations ( k-subsets of an n-set for fixed k), several Gray codes have been surveyed in [Wil89]. As observed in <ref> [BER76] </ref>, a Gray code for combinations can be extracted from the binary reflected Gray code for n-bit numbers: delete from the binary reflected Gray code list all those elements corresponding to subsets which do not have exactly k elements.
Reference: [Boo65] <author> J. Boothroyd. </author> <title> Algorithm 6. </title> <journal> PERM. Computer Bulletin, </journal> <volume> 9(3):104, </volume> <year> 1965. </year>
Reference-contexts: Such a Gray code for permutations was shown to be possible in several papers, including <ref> [Boo65, Boo67, Hea63, Wel61] </ref>, which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions.
Reference: [Boo67] <author> J. Boothroyd. </author> <title> Permutation of the elements of a vector (Algorithm 29) and Fast permutation of the elements of a vector (Algorithm 30). </title> <journal> Computer Journal, </journal> <volume> 10 </volume> <pages> 310-312, </pages> <year> 1967. </year>
Reference-contexts: Such a Gray code for permutations was shown to be possible in several papers, including <ref> [Boo65, Boo67, Hea63, Wel61] </ref>, which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions.
Reference: [BS96] <author> G. S. Bhat and C. D. Savage. </author> <title> Balanced Gray codes. </title> <journal> Electronic Journal of Combinatorics, </journal> <volume> 3(R25), </volume> <year> 1996. </year>
Reference-contexts: For each n &gt; 1 there is a cyclic n-bit Gray code in which each bit position changes either a or a + 2 times <ref> [BS96] </ref>.
Reference: [BW84] <author> M. Buck and D. </author> <title> Wiedemann. Gray codes with restricted density. </title> <journal> Discrete Mathematics, </journal> <volume> 48 </volume> <pages> 163-171, </pages> <year> 1984. </year>
Reference-contexts: codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> However, this is not always possible: it was shown that k-subsets of an n-set can be generated by adjacent interchanges if (i) k=0, 1, n, or n 1 or (ii) n is even and k is odd. In all other cases, parity problems prevent adjacent interchange generation <ref> [BW84, EHR84, HR88, Rus88a] </ref>. It was shown by Chase [Cha89] and by a simpler construction in [Rus93] that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them.
Reference: [BW92] <author> G. Brightwell and P. Winkler. </author> <title> Counting linear extensions is #P-complete. </title> <booktitle> Order, </booktitle> <volume> 8 </volume> <pages> 225-242, </pages> <year> 1992. </year>
Reference-contexts: Even counting the number of linear extensions of a poset is an open problem for some specific posets, for example, the Boolean lattice [SK87]. Brightwell and Winkler have recently shown that the problem of counting the number of linear extensions of a given poset is #-P complete <ref> [BW92] </ref>. On the brighter side, Pruesse and Ruskey [PR94] have found a CAT algorithm for listing linear extensions so that successive extensions differ by one or two adjacent transpositions and Canfield and Williamson [CW95] have shown 26 how to make it loop-free.
Reference: [CCC92] <author> C. C. Chang, H. Y. Chen, and C. Y. Chen. </author> <title> Symbolic Gray codes as a data allocation scheme for two disc systems. </title> <journal> Computer Journal, </journal> <volume> 35(3) </volume> <pages> 299-305, </pages> <year> 1992. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval <ref> [CCC92] </ref>, and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72]. In recent variations on combinatorial Gray codes, generation problems have been considered in which the difference between successive objects, although fixed, is not required to be small.
Reference: [CDG92] <author> F. Chung, P. Diaconis, and R. Graham. </author> <title> Universal cycles for combinatorial structures. </title> <journal> Discrete Mathematics, </journal> <volume> 110 </volume> <pages> 43-60, </pages> <year> 1992. </year>
Reference-contexts: Chung, Diaconis, and Graham generalized the notion of a de Bruijn sequence for binary numbers to universal cycles for other families of combinatorial objects <ref> [CDG92] </ref>. Universal cycles for combinations were studied by Hurlbert in [Hur90] and some interesting problems remain open. <p> Order isomorphic means that for 1 i; j n, i &lt; j iff x t+i &lt; x t+j . As an example, the sequence 123415342154213541352435 is a universal cycle of order 4 with M = 5. In <ref> [CDG92] </ref>, the goal is to choose M as small as possible to guarantee the existence of a universal cycle. It is clear that M must satisfy M n + 1 for n &gt; 2. It is conjectured in [CDG92] that M = n + 1 for all n &gt; 2, although <p> In <ref> [CDG92] </ref>, the goal is to choose M as small as possible to guarantee the existence of a universal cycle. It is clear that M must satisfy M n + 1 for n &gt; 2. It is conjectured in [CDG92] that M = n + 1 for all n &gt; 2, although the best upper bound they were able to obtain was M n + 6. Even for n = 5 it is open whether M = 6 is sufficient.
Reference: [CG96] <author> S. J. Curran and J. A. Gallian. </author> <title> Hamiltonian cycles and paths in Cayley graphs and digraphs a survey, </title> <year> 1996. </year>
Reference-contexts: Results on Hamilton cycles are surveyed in [Als81] for vertex transitive graphs and in [Gou91] for general graphs. A survey of Hamilton cycles in Cayley graphs can be found in [WG84] and in the recent update of Curran and Gallian <ref> [CG96] </ref>. We focus here on a few recent questions which arose in the context of Gray codes. Suppose the group G is S n , the symmetric group of permutations of n symbols, and let 28 X be a generating set of S n . <p> In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, [WG84] and the recent update <ref> [CG96] </ref> for Cayley graphs, and [Sed77] for permutations. Acknowledgements I am grateful to Herb Wilf for collecting and sharing such an intriguing array of `Gray code' problems. His work, as well as his enthusiasm, has been inspiring.
Reference: [Cha70] <author> P. J. Chase. </author> <title> Algorithm 382: Combinations of M out of N objects. </title> <journal> Communications of the ACM, </journal> <volume> 13(6):368, </volume> <year> 1970. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase <ref> [Cha70] </ref>, Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> That is, if a k-set is represented as a sorted k-tuple of its elements, successive k-sets differ in only one position (see Figure 6 (b)). Eades and McKay have shown that such a listing is always possible. An earlier solution was reported by Chase in <ref> [Cha70] </ref>. Perhaps the most restrictive Gray code which has been proposed for combinations is to generate k-subsets of an n-set so that successive sets differ in exactly one element and this element has either increased or decreased by one.
Reference: [Cha89] <author> P. J. Chase. </author> <title> Combination generation and Graylex ordering. </title> <journal> Congressus Numerantium, </journal> <volume> 69 </volume> <pages> 215-242, </pages> <year> 1989. </year>
Reference-contexts: In all other cases, parity problems prevent adjacent interchange generation [BW84, EHR84, HR88, Rus88a]. It was shown by Chase <ref> [Cha89] </ref> and by a simpler construction in [Rus93] that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them.
Reference: [Coc88] <author> J. C. Cocke. </author> <title> Toroidal tilings from de Bruijn-good cyclic sequences. </title> <journal> Discrete Mathematics, </journal> <volume> 70 </volume> <pages> 209-210, </pages> <year> 1988. </year>
Reference-contexts: This result has been generalized for k-ary n-tuples [Fre82], for higher dimensions (de Bruijn tori) <ref> [Coc88, FFMS85] </ref>, and for k-ary tori [HI95]. It is known also, for any m satisfying n m 2 n , that there is a cyclic binary sequence of length m in which no n-tuple appears more than once [Yoe62].
Reference: [Com90] <author> R. C. Compton. </author> <title> Hamilton cycles in the Cayley graph of S n and a doubly adjacent Gray code. </title> <type> PhD thesis, </type> <institution> Department of Mathematics, University of California, </institution> <address> San Diego, </address> <year> 1990. </year>
Reference-contexts: The Johnson-Trotter scheme satisfies this requirement for n 3, but not for n 4. Such a listing was shown to be possible by Chris Compton in his Ph.D. thesis <ref> [Com90] </ref>. It might be hoped that this could result in a very efficient permutation generation algorithm: it would become unnecessary to decide which of the n 1 adjacent pairs to transpose, only whether the next transposition is to the left or right of the current one.
Reference: [CS90] <author> M. Chen and K. G. Shin. </author> <title> Subcube allocation and task migration in hypercube machines. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1146-1155, </pages> <year> 1990. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube <ref> [CS90] </ref>, hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72].
Reference: [CSW89] <author> J. H. Conway, N. J. A. Sloane, and A. R. Wilks. </author> <title> Gray codes for reflection groups. </title> <booktitle> Graphs and Combinatorics, </booktitle> <volume> 5 </volume> <pages> 315-325, </pages> <year> 1989. </year>
Reference-contexts: has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition [Rus92, PR91, Sta92, Wes93], and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection <ref> [CSW89] </ref>. <p> Conway, Sloane, and Wilks have a related result on Gray codes for reflection groups: if G is an irreducible Coxeter group (a group generated by geometric reflections) and if X is the canonical basis of reflections for the group, then C [G; X] is hamiltonian <ref> [CSW89] </ref>. This result makes use of the fact that in any set of three or more generators from this basis, 29 there is always some pair of generators which commute (the Coxeter diagram for the basis is a tree). <p> As noted in <ref> [CSW89] </ref>, since any reflection group R is a direct product of irreducible Coxeter groups G 1 fi G 2 fi : : : fi G k , with X i the canonical basis for G i , the Cayley graph of R with respect to the basis X 1 fi X
Reference: [Cum66] <author> R. L. Cummings. </author> <title> Hamilton circuits in tree graphs. </title> <journal> IEEE Trans. Circuit Theory, </journal> <volume> 13 </volume> <pages> 82-90, </pages> <year> 1966. </year>
Reference-contexts: sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge <ref> [HH72, Cum66] </ref> (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition [Rus92, PR91, Sta92, Wes93], and
Reference: [CW93] <author> R. C. Compton and S. G. Williamson. </author> <title> Doubly adjacent Gray codes for the Symmetric group: how to braid n strands. </title> <journal> Linear and Multilinear Algebra, </journal> <volume> 34 </volume> <pages> 237-293, </pages> <year> 1993. </year> <month> 33 </month>
Reference-contexts: However, in its current form, Compton's algorithm is not practical, and is quite complex, even with the simplifications in <ref> [CW93] </ref>. The problem of generating all permutations of a multiset by adjacent interchanges was introduced by Lehmer as the Motel Problem [Leh65]. He shows that, because of parity problems, this is not always possible. <p> Compton and Williamson were able to find a Hamilton cycle in this graph using their Gray code for generating permutations by doubly adjacent transpositions, described in Section 3 <ref> [CW93] </ref>. The results of [KL75, Sla78] were generalized in a different way in [RS93].
Reference: [CW95] <author> E. R. Canfield and S. G. Williamson. </author> <title> A loop-free algorithm for generating the linear extensions of a poset. </title> <booktitle> Order, </booktitle> <volume> 12 </volume> <pages> 1-18, </pages> <year> 1995. </year>
Reference-contexts: On the brighter side, Pruesse and Ruskey [PR94] have found a CAT algorithm for listing linear extensions so that successive extensions differ by one or two adjacent transpositions and Canfield and Williamson <ref> [CW95] </ref> have shown 26 how to make it loop-free. In [PR93], Pruesse and Ruskey consider antimatroids, of which posets are a special case.
Reference: [dB46] <author> N. G. de Bruijn. </author> <title> A combinatorial problem. </title> <journal> Proc. Nederl. Akad. Wetensch., </journal> <volume> 49 </volume> <pages> 758-764, </pages> <year> 1946. </year>
Reference-contexts: of order n corresponds to an Euler tour in the de Bruijn digraph whose vertices are the binary n-tuples, with one edge (x 1 : : : x n1 ) ! (x 2 : : : x n ) for every binary n-tuple x 1 : : : x n <ref> [dB46, Mar34] </ref>. This result has been generalized for k-ary n-tuples [Fre82], for higher dimensions (de Bruijn tori) [Coc88, FFMS85], and for k-ary tori [HI95].
Reference: [DH94] <author> P. Diaconis and S. Holmes. </author> <title> Gray codes for randomization procedures. </title> <journal> Statistics and Computing, </journal> <volume> 4 </volume> <pages> 287-302, </pages> <year> 1994. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics <ref> [DH94] </ref>, graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72].
Reference: [DKS94] <author> D. Duffus, H. A. Kierstead, and H. S. Snevily. </author> <title> An explicit 1-factorization in the middle of the Boolean lattice. </title> <journal> Journal of Combinatorial Theory Series A, </journal> <volume> 65(2) </volume> <pages> 334-342, </pages> <year> 1994. </year>
Reference-contexts: In [DSW88], it was shown that a Hamilton cycle in the middle two levels cannot be the union of two lexicographic matchings. However, other matchings may work and new matchings in the middle two levels have been defined <ref> [KT88, DKS94] </ref>. The largest value of k for which a Hamilton cycle is known to exist is k = 11 (n = 23.) See Figure 7 for an example when k = 3. This unpublished work was done by Moews and Reid using a computer search [MR].
Reference: [DQ87] <author> I. J. Dejter and J. Quintana. </author> <title> Long cycles in revolving door graphs. </title> <journal> Congressus Numer-antium, </journal> <volume> 60 </volume> <pages> 163-168, </pages> <year> 1987. </year>
Reference-contexts: A result of Dejter and Quintana gives a cycle of length (N (k) t ) where t = (log3)=(log4) 0:793 <ref> [DQ87] </ref>.
Reference: [DSW88] <author> D. Duffus, B. Sands, and R. Woodrow. </author> <title> Lexicographic matchings cannot form hamiltonian cycles. </title> <booktitle> Order, </booktitle> <volume> 5 </volume> <pages> 149-161, </pages> <year> 1988. </year>
Reference-contexts: Thus, either it has a Hamilton path, or it provides a counterexample to the Lovasz conjecture. One approach to this problem which has been considered is to try to form a Hamilton cycle as the union of two edge-disjoint matchings. In <ref> [DSW88] </ref>, it was shown that a Hamilton cycle in the middle two levels cannot be the union of two lexicographic matchings. However, other matchings may work and new matchings in the middle two levels have been defined [KT88, DKS94].
Reference: [Ehr73] <author> G. Ehrlich. </author> <title> Loopless algorithms for generating permutations, combinations, and other combinatorial configurations. </title> <journal> Journal of the ACM, </journal> <volume> 20 </volume> <pages> 500-513, </pages> <year> 1973. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich <ref> [Ehr73] </ref>, and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> If X is the multiset consisting of m i copies of element i for i = 1; : : : t, then C (s; m 1 ; : : : ; m t ) is the collection of s-element submultisets, or s-combinations of X. In <ref> [Ehr73] </ref>, Ehrlich provides a loopless algorithm to generate multiset combinations so that successive elements differ in only two positions, but not necessarily by just 1 in those positions. <p> Strict Gray codes for R (n) were considered in an early paper of Ehrlich where it was shown that for infinitely many values of n, they do not exist 20 <ref> [Ehr73] </ref>. <p> fa 1 : : : a n 2 R (n) j maxfa 1 ; : : : a n g = b 1g: The Ehrlich paper presents a loop-free algorithm for generating S b (n) in which successive partitions differ only in that two elements have moved to different blocks <ref> [Ehr73] </ref>. Ruskey describes a Gray code for R b (n) (and a CAT implementation) in which successive elements differ in only one position, but possibly by more than 1 in that position [Rus93]. <p> Good references for early work on Gray codes are <ref> [Ehr73] </ref> and [NW78]. For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey [Rus95]. Additional information on Gray codes also appears in the survey of Squire [Squ94a].
Reference: [EHR84] <author> P. Eades, M. Hickey, and R. C. </author> <title> Read. Some Hamilton paths and a minimal change algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 19-29, </pages> <year> 1984. </year>
Reference-contexts: codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> However, this is not always possible: it was shown that k-subsets of an n-set can be generated by adjacent interchanges if (i) k=0, 1, n, or n 1 or (ii) n is even and k is odd. In all other cases, parity problems prevent adjacent interchange generation <ref> [BW84, EHR84, HR88, Rus88a] </ref>. It was shown by Chase [Cha89] and by a simpler construction in [Rus93] that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them.
Reference: [EM84] <author> P. Eades and B. McKay. </author> <title> An algorithm for generating subsets of fixed size with a strong minimal change property. </title> <journal> Information Processing Letters, </journal> <volume> 19 </volume> <pages> 131-133, </pages> <year> 1984. </year>
Reference-contexts: codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> A more stringent requirement is to list all k-sets with the strong minimal change property <ref> [EM84] </ref>. That is, if a k-set is represented as a sorted k-tuple of its elements, successive k-sets differ in only one position (see Figure 6 (b)). Eades and McKay have shown that such a listing is always possible. An earlier solution was reported by Chase in [Cha70].
Reference: [EW85] <author> R. B. Eggleton and W. D. Wallis. </author> <title> Problem 1186: Solution I. </title> <journal> Mathematics Magazine, </journal> <volume> 58(2) </volume> <pages> 112-113, </pages> <year> 1985. </year>
Reference-contexts: This problem was posed independently in [Rab84, Wil89]. The existence of such a list when n 6= 3 was established in [Met85] using Jackson's theorem [Jac80] and a constructive solution was presented in <ref> [EW85] </ref>. A simpler construction, ascribed to Lynn Yarbrough, is discussed in [RS87]. Yarbrough's solution is illustrated in Figure 5 and works as follows.
Reference: [Fal88] <author> C. Faloutsos. </author> <title> Gray codes for partial match and range queries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1381-1393, </pages> <year> 1988. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing <ref> [Fal88] </ref>, computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72]. In recent variations on combinatorial Gray codes, generation problems have been considered in which the difference between successive objects, although fixed, is not required to be small.
Reference: [FFMS85] <author> C. T. Fan, S. M. Fan, S. L. Ma, and M. K. </author> <title> Sin. On de Bruijn arrays. </title> <address> Ars Combinatoria, 19A:205-213, </address> <year> 1985. </year>
Reference-contexts: This result has been generalized for k-ary n-tuples [Fre82], for higher dimensions (de Bruijn tori) <ref> [Coc88, FFMS85] </ref>, and for k-ary tori [HI95]. It is known also, for any m satisfying n m 2 n , that there is a cyclic binary sequence of length m in which no n-tuple appears more than once [Yoe62].
Reference: [FK86] <author> H. Fredricksen and I. J. Kessler. </author> <title> An algorithm for generating necklaces of beads in two colors. </title> <journal> Discrete Mathematics, </journal> <volume> 61 </volume> <pages> 181-188, </pages> <year> 1986. </year>
Reference-contexts: Wilf asked if it is possible to generate necklaces efficiently, possibly in constant time per necklace. A proposed solution, the FKM algorithm of Fredricksen, Kessler, and Maiorana, had no proven upper bound better than O (nk n ) <ref> [FK86, FM78] </ref>. In [WS90] a new algorithm was presented with time complexity O (nN n k ), where N n k is the number of n-bead necklaces in k colors.
Reference: [FL80] <author> T. I. Fenner and G. Loizou. </author> <title> A binary tree representation and related algorithms for generating integer partitions. </title> <journal> The Computer Journal, </journal> <volume> 23(4) </volume> <pages> 332-337, </pages> <year> 1980. </year>
Reference-contexts: Algorithms for generating integer partitions in standard orders such as lexicographic and antilexicographic were presented in <ref> [FL80] </ref> and [NW78]. The performance of the algorithms in [FL80] is analyzed in [FL81]. <p> Algorithms for generating integer partitions in standard orders such as lexicographic and antilexicographic were presented in <ref> [FL80] </ref> and [NW78]. The performance of the algorithms in [FL80] is analyzed in [FL81].
Reference: [FL81] <author> T. I. Fenner and G. Loizou. </author> <title> An analysis of two related loop-free algorithms for generating integer partitions. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 237-252, </pages> <year> 1981. </year>
Reference-contexts: Algorithms for generating integer partitions in standard orders such as lexicographic and antilexicographic were presented in [FL80] and [NW78]. The performance of the algorithms in [FL80] is analyzed in <ref> [FL81] </ref>.
Reference: [FM78] <author> H. Fredricksen and J. Maiorana. </author> <title> Necklaces of beads in k colors and k-ary de Bruijn sequences. </title> <journal> Discrete Mathematics, </journal> <volume> 23(3) </volume> <pages> 207-210, </pages> <year> 1978. </year>
Reference-contexts: Wilf asked if it is possible to generate necklaces efficiently, possibly in constant time per necklace. A proposed solution, the FKM algorithm of Fredricksen, Kessler, and Maiorana, had no proven upper bound better than O (nk n ) <ref> [FK86, FM78] </ref>. In [WS90] a new algorithm was presented with time complexity O (nN n k ), where N n k is the number of n-bead necklaces in k colors.
Reference: [FM93] <author> R. Feldman and P. Mysliwietz. </author> <title> The shu*e-exchange network has a hamiltonian path. </title> <type> Technical Report 116, </type> <institution> Fachbereich Mathematik-Informatik, Universitat-GH-Paderborn, </institution> <year> 1993. </year>
Reference-contexts: The underlying graph is the shu*e-exchange network and a Hamilton path would be a "Gray code" for binary strings respecting this adjacency criterion. The existence of a Hamilton path in the shu*e-exchange graph, a long-standing open problem, was recently established by Feldman and Mysliwietz <ref> [FM93] </ref>. In [Fre79], Fredman considers complexity issues involved in generating arbitrary subsets of the set of n-bit strings so that successive strings differ only in one bit.
Reference: [Fre79] <author> M. L. Fredman. </author> <title> Observations on the complexity of generating quasi-gray codes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 7(2) </volume> <pages> 134-146, </pages> <year> 1979. </year>
Reference-contexts: The underlying graph is the shu*e-exchange network and a Hamilton path would be a "Gray code" for binary strings respecting this adjacency criterion. The existence of a Hamilton path in the shu*e-exchange graph, a long-standing open problem, was recently established by Feldman and Mysliwietz [FM93]. In <ref> [Fre79] </ref>, Fredman considers complexity issues involved in generating arbitrary subsets of the set of n-bit strings so that successive strings differ only in one bit.
Reference: [Fre82] <author> H. Fredricksen. </author> <title> A survey of full length nonlinear shift register cycle algorithms. </title> <journal> SIAM Review, </journal> <volume> 24(2) </volume> <pages> 195-221, </pages> <year> 1982. </year> <month> 34 </month>
Reference-contexts: This result has been generalized for k-ary n-tuples <ref> [Fre82] </ref>, for higher dimensions (de Bruijn tori) [Coc88, FFMS85], and for k-ary tori [HI95]. It is known also, for any m satisfying n m 2 n , that there is a cyclic binary sequence of length m in which no n-tuple appears more than once [Yoe62].
Reference: [FT95] <author> S. Felsner and W. T. Trotter. </author> <title> Colorings of diagrams of interval orders and ff-sequences. </title> <journal> Discrete Mathematics, </journal> <volume> 144, </volume> <year> 1995. </year>
Reference-contexts: In a welcome breakthrough, Felsner and Trotter showed the existence of cycles of length at least 0:25N (k) <ref> [FT95] </ref>. The monotone Gray code, described in Section 1, contains as a subpath, a path in the middle two levels of length at least 0:5N (k) [SW95].
Reference: [Gar72] <author> Martin Gardner. </author> <title> Curious properties of the Gray code and how it can be used to solve puzzles. </title> <journal> Scientific American, </journal> <volume> 227(2) </volume> <pages> 106-109, </pages> <year> 1972. </year>
Reference-contexts: circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi <ref> [Gar72] </ref>. In recent variations on combinatorial Gray codes, generation problems have been considered in which the difference between successive objects, although fixed, is not required to be small.
Reference: [GG] <author> L. Goddyn and P. Grozdjak. </author> <type> Personal communication. </type>
Reference-contexts: sequence of 0's (or 1's) among all bit positions. (See Figure 1 (c) for an example from [GLN88] in which the gap is 4, which is best possible for n = 5.) Goddyn and Gvozdjak report a construction in which GAP (n)/n goes to 1 as n goes to infinity <ref> [GG] </ref>. Another variation, non-composite n-bit Gray codes, requires that no contiguous subsequence correspond to a path in any k-cube for 2 k n. Non-composite Gray codes have been constructed for all n [Ram90]. (See Figure 1 (d) for an example from [Ram90].) A new constraint is considered in [SW95].
Reference: [Gil58] <author> E. N. Gilbert. </author> <title> Gray codes and paths on the n-cube. </title> <journal> Bell Systems Technical Journal, </journal> <volume> 37 </volume> <pages> 815-826, </pages> <year> 1958. </year>
Reference-contexts: A common approach has been to try to generate the objects as a list in which successive elements differ only in a small way. The classic example is the binary reflected Gray code <ref> [Gil58, Gra53] </ref> which is a scheme for listing all n-bit binary numbers so that successive numbers differ in exactly one bit. The advantage anticipated by such an approach is two-fold. First, generation of successive objects might be faster. <p> The best known example is the binary reflected Gray code <ref> [Gil58, Gra53] </ref> which can be described as follows.
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability, a Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: A Hamilton cycle corresponds to a cyclic listing in which the first and last items also differ in the pre-specified way. But since the problem of determining whether a given graph has a Hamilton path or cycle is NP-complete <ref> [GJ79] </ref>, there is no efficient general algorithm for discovering combinatorial Gray codes. Frequently in Gray code problems, however, the associated graph possesses a great deal of symmetry. Specifically, it may belong to the class of vertex transitive graphs.
Reference: [GLN88] <author> L. Goddyn, G. M. Lawrence, and E. Nemeth. </author> <title> Gray codes with optimized run lengths. </title> <journal> Utilitas Mathematica, </journal> <volume> 34 </volume> <pages> 179-192, </pages> <year> 1988. </year>
Reference-contexts: It can be implemented efficiently as a loop-free algorithm [BER76]. Note that a binary Gray code can be viewed as a Hamilton cycle in the n-cube. In practice, Gray codes with certain additional properties may be desirable (see <ref> [GLN88] </ref> for a survey). For example, note that as the elements of L n are scanned, the lowest order (rightmost) bit changes 2 n1 times, whereas the highest order bit changes only twice, counting the return to the first element. <p> For each n &gt; 1 there is a cyclic n-bit Gray code in which each bit position changes either a or a + 2 times [BS96]. In other applications, the requirement is to maximize the gap in a Gray code, which is defined in <ref> [GLN88] </ref> to be the shortest maximal consecutive sequence of 0's (or 1's) among all bit positions. (See Figure 1 (c) for an example from [GLN88] in which the gap is 4, which is best possible for n = 5.) Goddyn and Gvozdjak report a construction in which GAP (n)/n goes to <p> In other applications, the requirement is to maximize the gap in a Gray code, which is defined in <ref> [GLN88] </ref> to be the shortest maximal consecutive sequence of 0's (or 1's) among all bit positions. (See Figure 1 (c) for an example from [GLN88] in which the gap is 4, which is best possible for n = 5.) Goddyn and Gvozdjak report a construction in which GAP (n)/n goes to 1 as n goes to infinity [GG].
Reference: [Gol64] <author> S. W. Golomb, </author> <title> editor. Digital Communications with Space Applications. </title> <publisher> Prentice Hall, </publisher> <year> 1964. </year>
Reference-contexts: So, the de Bruijn graph contains cycles of all lengths m n. Results on de Bruijn cycles have been applied to random number generation in information theory <ref> [Gol64] </ref> and in computer architecture, where the de Bruijn graph is recognized as a bounded degree derivative of the shu*e-exchange network [ABR90]. Chung, Diaconis, and Graham generalized the notion of a de Bruijn sequence for binary numbers to universal cycles for other families of combinatorial objects [CDG92].
Reference: [Gol93] <author> L. A. Goldberg. </author> <title> Efficient Algorithms for Listing Combinatorial Structures. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey [Rus95]. Additional information on Gray codes also appears in the survey of Squire [Squ94a]. In <ref> [Gol93] </ref>, Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, [WG84] and the recent update [CG96] for Cayley graphs, and [Sed77] for permutations.
Reference: [Gou91] <author> R. J. Gould. </author> <title> Updating the hamiltonian problem a survey. </title> <journal> Journal of Graph Theory, 15(2):121 -157, </journal> <year> 1991. </year>
Reference-contexts: Results on Hamilton cycles are surveyed in [Als81] for vertex transitive graphs and in <ref> [Gou91] </ref> for general graphs. A survey of Hamilton cycles in Cayley graphs can be found in [WG84] and in the recent update of Curran and Gallian [CG96]. We focus here on a few recent questions which arose in the context of Gray codes. <p> Additional information on Gray codes also appears in the survey of Squire [Squ94a]. In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, <ref> [Gou91] </ref> for hamiltonian cycles, [WG84] and the recent update [CG96] for Cayley graphs, and [Sed77] for permutations. Acknowledgements I am grateful to Herb Wilf for collecting and sharing such an intriguing array of `Gray code' problems. His work, as well as his enthusiasm, has been inspiring.
Reference: [GR87] <author> R. J. Gould and R. Roth. </author> <title> Cayley digraphs and (1; j; n) sequencings of the alternating group A n . Discrete Mathematics, </title> <booktitle> 66 </booktitle> <pages> 91-102, </pages> <year> 1987. </year>
Reference-contexts: This result was obtained earlier with a direct argument by Gould and Roth <ref> [GR87] </ref>. 30 12 Generalizations of de Bruijn Sequences A de Bruijn sequence of order n is a circular binary sequence of length 2 n in which every n-bit number appears as a contiguous subsequence.
Reference: [Gra53] <author> F. Gray. </author> <title> Pulse code communications. </title> <type> U.S. Patent 2632058, </type> <month> March </month> <year> 1953. </year>
Reference-contexts: A common approach has been to try to generate the objects as a list in which successive elements differ only in a small way. The classic example is the binary reflected Gray code <ref> [Gil58, Gra53] </ref> which is a scheme for listing all n-bit binary numbers so that successive numbers differ in exactly one bit. The advantage anticipated by such an approach is two-fold. First, generation of successive objects might be faster. <p> The term combinatorial Gray code first appeared in [JWW80] and is now used to refer to any method for generating combinatorial objects so that successive objects differ in some pre-specified, usually small, way. However, the origins of minimal change listings can be found in the early work of Gray <ref> [Gra53] </ref>, Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> The best known example is the binary reflected Gray code <ref> [Gil58, Gra53] </ref> which can be described as follows.
Reference: [Har71] <author> K. Harada. </author> <title> Generation of rosary permutations expressed in hamiltonian circuits. </title> <journal> Communications of the ACM, </journal> <volume> 14 </volume> <pages> 373-379, </pages> <year> 1971. </year>
Reference-contexts: Lisonek [Lis93] shows how to modify the necklace algorithm of [WS90] to generate bracelets. We know of no Gray code for bracelets and it is open whether it is possible to generate bracelets in constant amortized time. When beads have distinct colors, bracelets are the rosary permutations of <ref> [Har71, Rea72] </ref>. Define a new relation R on n-bead binary necklaces by xRy if some member of x becomes a member of y by changing a 0 to a 1 in one bit position.
Reference: [Hea63] <author> B. R. </author> <title> Heap. Permutations by interchanges. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 293-94, </pages> <year> 1963. </year>
Reference-contexts: Such a Gray code for permutations was shown to be possible in several papers, including <ref> [Boo65, Boo67, Hea63, Wel61] </ref>, which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions.
Reference: [Hea72] <author> F. G. Heath. </author> <title> Origins on the binary code. </title> <journal> Scientific Americal, </journal> <volume> 227(2) </volume> <pages> 76-83, </pages> <year> 1972. </year>
Reference-contexts: In his article on the origins of the binary Gray code, Heath describes a telegraph invented by Emile Baudot in 1878 which used the binary reflected Gray code <ref> [Hea72] </ref>. (According to Heath, Baudot received a gold medal for his telegraph at the Universal Exposition in Paris in 1978, as did Thomas Edison and Alexander Graham Bell.) Examples of combinatorial Gray codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by
Reference: [HH72] <author> C. A. Holzmann and F. Harary. </author> <title> On the tree graph of a matroid. </title> <journal> SIAM J. Appl. Math., </journal> <volume> 22(2) </volume> <pages> 187-193, </pages> <year> 1972. </year>
Reference-contexts: sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge <ref> [HH72, Cum66] </ref> (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition [Rus92, PR91, Sta92, Wes93], and
Reference: [HI95] <author> G. Hurlbert and G. Isaak. </author> <title> On the de Bruijn torus problem. </title> <journal> Journal of Combinatorial Theory Series A, </journal> <year> 1995. </year>
Reference-contexts: This result has been generalized for k-ary n-tuples [Fre82], for higher dimensions (de Bruijn tori) [Coc88, FFMS85], and for k-ary tori <ref> [HI95] </ref>. It is known also, for any m satisfying n m 2 n , that there is a cyclic binary sequence of length m in which no n-tuple appears more than once [Yoe62]. So, the de Bruijn graph contains cycles of all lengths m n.
Reference: [HR88] <author> T. Hough and F. Ruskey. </author> <title> An efficient implementation of the Eades, Hickey, Read adjacent interchange combination generation algorithm. </title> <journal> Journal of Combinatorial Mathematics and Combinatorial Computing, </journal> <volume> 4 </volume> <pages> 79-86, </pages> <year> 1988. </year>
Reference-contexts: However, this is not always possible: it was shown that k-subsets of an n-set can be generated by adjacent interchanges if (i) k=0, 1, n, or n 1 or (ii) n is even and k is odd. In all other cases, parity problems prevent adjacent interchange generation <ref> [BW84, EHR84, HR88, Rus88a] </ref>. It was shown by Chase [Cha89] and by a simpler construction in [Rus93] that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them.
Reference: [Hur90] <author> G. Hurlbert. </author> <title> Universal Cycles: On Beyond de Bruijn. </title> <type> PhD thesis, </type> <institution> Department of Mathematics, Rutgers University, </institution> <year> 1990. </year>
Reference-contexts: Chung, Diaconis, and Graham generalized the notion of a de Bruijn sequence for binary numbers to universal cycles for other families of combinatorial objects [CDG92]. Universal cycles for combinations were studied by Hurlbert in <ref> [Hur90] </ref> and some interesting problems remain open.
Reference: [Hur94] <author> G. Hurlbert. </author> <title> The antipodal layers problem. </title> <journal> Discrete Mathematics, </journal> <volume> 128 </volume> <pages> 237-243, </pages> <year> 1994. </year>
Reference-contexts: there a Hamilton path among the k-sets and n k sets of f1; : : :; ng for all n, where two sets are joined by an edge if and only if one is a subset of the other? Results for limited values of k and n are given in <ref> [Hur94] </ref> and [Sim]. A composition of n into k parts is a sequence (x 1 ; : : : ; x k ) of nonnegative integers whose sum is n. This is traditionally viewed as a placement of n balls into k boxes.
Reference: [Jac80] <author> B. Jackson. </author> <title> Hamilton cycles in regular 2-connected graphs. </title> <journal> Journal of Combinatorial Theory Series B, </journal> <volume> 29 </volume> <pages> 27-46, </pages> <year> 1980. </year>
Reference-contexts: This problem was posed independently in [Rab84, Wil89]. The existence of such a list when n 6= 3 was established in [Met85] using Jackson's theorem <ref> [Jac80] </ref> and a constructive solution was presented in [EW85]. A simpler construction, ascribed to Lynn Yarbrough, is discussed in [RS87]. Yarbrough's solution is illustrated in Figure 5 and works as follows.
Reference: [Joh63] <author> S. M. Johnson. </author> <title> Generation of permutations by adjacent transpositions. </title> <journal> Mathematics of Computation, </journal> <volume> 17 </volume> <pages> 282-285, </pages> <year> 1963. </year> <month> 35 </month>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson <ref> [Joh63] </ref>, 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> for his telegraph at the Universal Exposition in Paris in 1978, as did Thomas Edison and Alexander Graham Bell.) Examples of combinatorial Gray codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements <ref> [Joh63, Tro62] </ref>, (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing <p> Such a Gray code for permutations was shown to be possible in several papers, including [Boo65, Boo67, Hea63, Wel61], which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions. It was shown independently by Johnson <ref> [Joh63] </ref> and Trotter [Tro62] that it is possible to generate permutations by transpositions even if the two elements exchanged are required to be in adjacent positions.
Reference: [JW] <author> M. Jacobson and D. B. West. </author> <type> Personal communication. </type>
Reference-contexts: Jacobson and West have a simple construction for such a sequence of length 2n! <ref> [JW] </ref>. 13 Concluding Remarks This paper has included a sampling of Gray code results in several areas, particularly those which have appeared since the survey of Wilf [Wil89], in which many of these problems were posed. Good references for early work on Gray codes are [Ehr73] and [NW78].
Reference: [JWW80] <author> J. T. Joichi, Dennis E. White, and S. G. Williamson. </author> <title> Combinatorial Gray codes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(1) </volume> <pages> 130-141, </pages> <year> 1980. </year>
Reference-contexts: Finally, and perhaps one of the main attractions of the area, Gray codes typically involve elegant recursive constructions which provide new insights into the structure of combinatorial families. The term combinatorial Gray code first appeared in <ref> [JWW80] </ref> and is now used to refer to any method for generating combinatorial objects so that successive objects differ in some pre-specified, usually small, way. <p> For many Gray code problems, especially those involving permutations, the associated graph is a Cayley graph. Although many Gray code schemes seem to require strategies tailored to the problem at hand, a few general techniques and unifying structures have emerged. The paper <ref> [JWW80] </ref> considers families of combinatorial objects, whose size is defined by a recurrence of a particular form, and some general results are obtained about constructing Gray codes for these families. <p> It is natural to consider an extension of binary Gray codes to m-ary Gray codes. It was shown in <ref> [JWW80] </ref>, using a generalization of the binary reflected Gray code scheme, that it is always possible to list the Cartesian product of finite sets so that successive elements differ only in one coordinate.
Reference: [Kay76] <author> R. Kaye. </author> <title> A Gray code for set partitions. </title> <journal> Information Processing Letters, </journal> <volume> 5(6) </volume> <pages> 171-173, </pages> <year> 1976. </year>
Reference-contexts: The associated string for above is 0 0 1 2 1 1 0 1 3 2 2. For n = 4, the bijection is illustrated in the first two columns of Figure 9. In <ref> [Kay76] </ref>, Kaye gives a CAT implementation of a Gray code for S (n), attributed to Knuth in [Wil89]. This was another problem posed by Nijenhuis and Wilf in their book [NW78] (p. 292, problem 25) and solved by Knuth while reading the galleys.
Reference: [KL75] <author> V. L. Kompel'makher and V. A. Liskovets. </author> <title> Sequential generation of arrangements by means of a basis of transpositions. </title> <journal> Kibernetica, </journal> <volume> 3 </volume> <pages> 17-21, </pages> <year> 1975. </year>
Reference-contexts: Kompel'makher and Liskovets generalized this result to show that if X is any set of transpositions generating S n , then C [S n ; X] is hamiltonian <ref> [KL75] </ref>. Independently, and with a much simpler argument, Slater showed that these graphs have Hamilton paths [Sla78]. <p> Independently, and with a much simpler argument, Slater showed that these graphs have Hamilton paths [Sla78]. Tchuente [Tch82] extended the results of <ref> [KL75, Sla78] </ref> to show that the Cayley graph of S n , on any generating set X of transpositions, is not only hamiltonian, but Hamilton-laceable, that is, for any two vertices u; v of different parity there is a Hamilton path which starts at u and ends at v. <p> Compton and Williamson were able to find a Hamilton cycle in this graph using their Gray code for generating permutations by doubly adjacent transpositions, described in Section 3 [CW93]. The results of <ref> [KL75, Sla78] </ref> were generalized in a different way in [RS93].
Reference: [Kli82] <author> P. Klingsberg. </author> <title> A Gray code for compositions. </title> <journal> Journal of Algorithms, </journal> <volume> 3 </volume> <pages> 41-44, </pages> <year> 1982. </year>
Reference-contexts: Knuth solved this in 1974 while reading the galleys of the book and in <ref> [Kli82] </ref>, Klingsberg gives a CAT implementation of Knuth's Gray code. Combinations and compositions can be simultaneously generalized as follows.
Reference: [KR88] <author> C. W. Ko and F. Ruskey. </author> <title> Solution of some multi-dimensional lattice path parity difference recurrence relations. </title> <journal> Discrete Mathematics, </journal> <volume> 71 </volume> <pages> 47-56, </pages> <year> 1988. </year>
Reference-contexts: The problem is also open for posets whose Hasse diagram is a grid or tableau tilted ninety degrees [Rus]. Calculating the parity difference itself can be difficult and Ruskey [Rus] has several examples of posets for which the parity difference is unknown. (Some parity differences are calculated in <ref> [KR88] </ref>.) Recently, Stachowiak has shown that computing the parity difference is #P-complete [Sta]. Even counting the number of linear extensions of a poset is an open problem for some specific posets, for example, the Boolean lattice [SK87].
Reference: [KR92] <author> C. W. Ko and F. Ruskey. </author> <title> Generating permutations of a bag by interchanges. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 263-269, </pages> <year> 1992. </year>
Reference-contexts: He shows that, because of parity problems, this is not always possible. It becomes possible, however, if the interchanged elements are not required to be adjacent and Ko and Ruskey give a CAT algorithm to generate multiset permutations according to this criterion <ref> [KR92] </ref>. 4 Subsets, Combinations, and Compositions Since there is a bijection between the subsets of an n-element set (an n-set) and the n-bit binary numbers, any binary Gray code defines a Gray code for subsets: two binary numbers differing in one bit correspond to two subsets differing by the addition or
Reference: [KS74] <author> D. E. Knuth and J. Szwarcfiter. </author> <title> A structured program to generate all topological sorting arrangements. </title> <journal> Information Processing Letters, </journal> <volume> 2 </volume> <pages> 153-157, </pages> <year> 1974. </year>
Reference-contexts: The problem of efficiently generating all the linear extensions of a poset, in any order, has been studied in <ref> [KV83, KS74, VR81] </ref>. The area of Gray codes for linear extensions of a poset was introduced by Frank Ruskey in [Rus88b, PR91] as a setting in which to generalize the study of Gray codes for combinatorial objects.
Reference: [KT88] <author> H. A. Kierstead and W. T. Trotter. </author> <title> Explicit matchings in the middle levels of the Boolean lattice. </title> <booktitle> Order, </booktitle> <volume> 5 </volume> <pages> 163-171, </pages> <year> 1988. </year>
Reference-contexts: There are several open problems about paths between levels of the Hasse diagram of 14 the Boolean lattice, B n . The most notorious is the middle two levels problem which is attributed in <ref> [KT88] </ref> to Dejter, Erd-os, and Trotter and by others to Havel and Kelley. The middle two levels of B 2k+1 have the same number of elements and induce a bipartite, vertex transitive graph on the k- and k + 1- element subsets of [2k + 1]. <p> In [DSW88], it was shown that a Hamilton cycle in the middle two levels cannot be the union of two lexicographic matchings. However, other matchings may work and new matchings in the middle two levels have been defined <ref> [KT88, DKS94] </ref>. The largest value of k for which a Hamilton cycle is known to exist is k = 11 (n = 23.) See Figure 7 for an example when k = 3. This unpublished work was done by Moews and Reid using a computer search [MR].
Reference: [KV83] <author> A. D. Kalvin and Y. L. Varol. </author> <title> On the generation of all topological sortings. </title> <journal> Journal of Algorithms, </journal> <volume> 4 </volume> <pages> 150-162, </pages> <year> 1983. </year>
Reference-contexts: The problem of efficiently generating all the linear extensions of a poset, in any order, has been studied in <ref> [KV83, KS74, VR81] </ref>. The area of Gray codes for linear extensions of a poset was introduced by Frank Ruskey in [Rus88b, PR91] as a setting in which to generalize the study of Gray codes for combinatorial objects.
Reference: [Leh64] <author> D. H. Lehmer. </author> <title> The machine tools of combinatorics. </title> <editor> In E. Beckenbach, editor, </editor> <booktitle> Applied Combinatorial Mathematics, </booktitle> <pages> pages 5-31. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1964. </year>
Reference-contexts: Whereas early work in combinatorics focused on counting, by 1960, it was clear that with the aid of a computer it would be feasible to list the objects in combinatorial classes <ref> [Leh64] </ref>. However, in order for such a listing to be possible, even for objects of moderate size, combinatorial generation methods must be extremely efficient. A common approach has been to try to generate the objects as a list in which successive elements differ only in a small way.
Reference: [Leh65] <author> D. H. Lehmer. </author> <title> Permutation by adjacent interchanges. </title> <journal> American Mathematical Monthly, </journal> <volume> 72 </volume> <pages> 36-46, </pages> <year> 1965. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer <ref> [Leh65] </ref>, Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> However, in its current form, Compton's algorithm is not practical, and is quite complex, even with the simplifications in [CW93]. The problem of generating all permutations of a multiset by adjacent interchanges was introduced by Lehmer as the Motel Problem <ref> [Leh65] </ref>. He shows that, because of parity problems, this is not always possible.
Reference: [Lin86] <author> N. Linial. </author> <title> Hard enumeration problems in geometry and combinatorics. </title> <journal> SIAM Journal on Algebraic and Discrete Methods, </journal> <volume> 7(2) </volume> <pages> 331-335, </pages> <year> 1986. </year>
Reference-contexts: However, the square of AO (G) is hamiltonian for any G [PR95, SZ95, Squ94c], which means that acyclic orientations can be listed so that successive elements differ in the orientations of at most two edges. The problem of counting acyclic orientations is #P-complete <ref> [Lin86] </ref> and it is an open 27 question whether there is a CAT algorithm to generate them. The fastest listing algorithm known, due to Squire [Squ94b], requires O (n) average time per orientation, where n is the number of vertices of the graph.
Reference: [Lis93] <author> P. Lisonek. </author> <title> Generating bracelets, 1993. </title> <type> Preprint. </type>
Reference-contexts: To construct a slightly different set of objects, call two k-ary strings equivalent if one is a rotation or a reversal of the other. The equivalence classes under this relation are called bracelets. Lisonek <ref> [Lis93] </ref> shows how to modify the necklace algorithm of [WS90] to generate bracelets. We know of no Gray code for bracelets and it is open whether it is possible to generate bracelets in constant amortized time. When beads have distinct colors, bracelets are the rosary permutations of [Har71, Rea72].
Reference: [Los92] <author> R. M. Losee. </author> <title> A Gray code based ordering for documents on shelves: Classificaton for browsing and retrieval. </title> <journal> Journal of the American Society for Information Science, </journal> <volume> 43(4) </volume> <pages> 312-322, </pages> <year> 1992. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves <ref> [Los92] </ref>, data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72].
Reference: [Lov70] <author> L. Lovasz. </author> <title> Problem 11. In Combinatorial Structures and their Applications. </title> <publisher> Gorden and Breach, </publisher> <year> 1970. </year>
Reference-contexts: For example, permutations differing by adjacent transpositions give rise to a vertex transitive graph, as do k-subsets of an n-set differing by one element. It is a well-known open problem, due to Lovasz, whether every undirected, connected, vertex transitive graph has a Hamilton path <ref> [Lov70] </ref>. Thus, schemes for generating combinatorial Gray codes in many cases provide new examples of vertex transitive graphs with Hamilton paths or cycles, from which we hope to gain insight into the more general open questions. <p> It is an open question whether every Cayley graph is hamiltonian. (There are generating sets for which the Cayley digraph is not hamiltonian [Ran48].) This is a special case of the more general conjecture of Lovasz that every connected, undirected, vertex-transitive graph has a Hamilton path <ref> [Lov70] </ref>. Results on Hamilton cycles are surveyed in [Als81] for vertex transitive graphs and in [Gou91] for general graphs. A survey of Hamilton cycles in Cayley graphs can be found in [WG84] and in the recent update of Curran and Gallian [CG96].
Reference: [LRR93] <author> J. M. Lucas, D. Roelants van Baronaigien, and F. Ruskey. </author> <title> On rotations and the generation of binary trees. </title> <journal> Journal of Algorithms, </journal> <volume> 15(3) </volume> <pages> 343-366, </pages> <year> 1993. </year>
Reference-contexts: of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node <ref> [Luc87, LRR93] </ref>, (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing <p> A different minimal change criterion, focusing on binary trees, was considered in [Luc87] and <ref> [LRR93] </ref>: list all binary trees on n nodes so that consecutive trees differ only by a left or right rotation at a single node. The rotation operation is common in data structures where it is used to restructure binary search trees, while preserving the ordering properties. <p> The rotation operation is common in data structures where it is used to restructure binary search trees, while preserving the ordering properties. It was shown that such a Gray code is always possible and it can be generated efficiently <ref> [LRR93] </ref>. <p> So, the results of <ref> [Luc87, LRR93] </ref> also give a listing of all triangulations of a polygon so that successive triangulations differ only by the flip of a single diagonal. 8 Necklaces and Variations An n-bead, k-color necklace is an equivalence class of k-ary n-tuples under rotation.
Reference: [LS81] <author> J. E. Ludman and J. L. Sampson. </author> <title> A technique for generating Gray codes. </title> <journal> J. Statist. Plann. Inference, </journal> <volume> 5 </volume> <pages> 171-180, </pages> <year> 1981. </year>
Reference-contexts: For general n, balancing heuristics were suggested, but not proved, in <ref> [LS81, VS80, RC81] </ref>. Recently we have shown, using the Robinson-Cohn construction [RC81], that balanced Gray codes exist for all n in the following sense: Let a = b2 n =nc or b2 n =nc 1, so that a is even.
Reference: [Luc87] <author> J. Lucas. </author> <title> The rotation graph of binary trees is hamiltonian. </title> <journal> Journal of Algorithms, </journal> <volume> 8 </volume> <pages> 503-535, </pages> <year> 1987. </year>
Reference-contexts: of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node <ref> [Luc87, LRR93] </ref>, (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing <p> A different minimal change criterion, focusing on binary trees, was considered in <ref> [Luc87] </ref> and [LRR93]: list all binary trees on n nodes so that consecutive trees differ only by a left or right rotation at a single node. The rotation operation is common in data structures where it is used to restructure binary search trees, while preserving the ordering properties. <p> It was shown that such a Gray code is always possible and it can be generated efficiently [LRR93]. With a more intricate construction, Lucas was able to show that the associated graph was hamiltonian <ref> [Luc87] </ref>, giving a cyclic Gray code. 22 It so happens that under a particular bijection between binary trees with n nodes and the set of all triangulations of a labeled convex polygon with n + 2 vertices, rotation in a binary tree corresponds to the flip of a diagonal in the <p> So, the results of <ref> [Luc87, LRR93] </ref> also give a listing of all triangulations of a polygon so that successive triangulations differ only by the flip of a single diagonal. 8 Necklaces and Variations An n-bead, k-color necklace is an equivalence class of k-ary n-tuples under rotation.
Reference: [Lud81] <author> J. E. Ludman. </author> <title> Gray code generation for MPSK signals. </title> <journal> IEEE Transactions on Communications, </journal> <volume> COM-29:1519-1522, </volume> <year> 1981. </year> <month> 36 </month>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding <ref> [Lud81] </ref>, ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72].
Reference: [Mar34] <author> M. H. Martin. </author> <title> A problem in arrangements. </title> <journal> Bulletin of the American Mathematical Society, </journal> <volume> 40 </volume> <pages> 859-864, </pages> <year> 1934. </year>
Reference-contexts: of order n corresponds to an Euler tour in the de Bruijn digraph whose vertices are the binary n-tuples, with one edge (x 1 : : : x n1 ) ! (x 2 : : : x n ) for every binary n-tuple x 1 : : : x n <ref> [dB46, Mar34] </ref>. This result has been generalized for k-ary n-tuples [Fre82], for higher dimensions (de Bruijn tori) [Coc88, FFMS85], and for k-ary tori [HI95].
Reference: [Met85] <author> J. Metzger. </author> <title> Problem 1186. </title> <journal> Mathematics Magazine, </journal> <volume> 58 </volume> <pages> 113-114, </pages> <year> 1985. </year>
Reference-contexts: This problem was posed independently in [Rab84, Wil89]. The existence of such a list when n 6= 3 was established in <ref> [Met85] </ref> using Jackson's theorem [Jac80] and a constructive solution was presented in [EW85]. A simpler construction, ascribed to Lynn Yarbrough, is discussed in [RS87]. Yarbrough's solution is illustrated in Figure 5 and works as follows.
Reference: [MR] <author> D. Moews and M. Reid. </author> <title> Electronic mail communication (via J. </title> <publisher> Gallian). </publisher>
Reference-contexts: The largest value of k for which a Hamilton cycle is known to exist is k = 11 (n = 23.) See Figure 7 for an example when k = 3. This unpublished work was done by Moews and Reid using a computer search <ref> [MR] </ref>. To speed up the search, they used a necklace-based approach, gambling that there would be a Hamilton path through necklaces which could be lifted to a Hamilton cycle in the original graph.
Reference: [NW78] <author> A. Nijenhuis and H. S. Wilf. </author> <title> Combinatorial Algorithms for Computers and Calculators. </title> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: Secondly, for the application at hand, it is likely that combinatorial objects which differ in only a small way are associated with feasible solutions which differ by only a small computation. For example in <ref> [NW78] </ref>, Nijenhuis and Wilf show how to use a binary Gray code to speed up computation of the permanent. Aside from computational considerations, open questions in several areas of mathematics can be posed as Gray code problems. <p> However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf <ref> [NW78] </ref>, and in the work of campanologists [Whi83]. <p> codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent <ref> [NW78] </ref>, information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72]. In recent variations on combinatorial Gray codes, generation problems have been considered in which the difference between successive objects, although fixed, is not required to be small. <p> That which remains is a list of all k-subsets in which successive sets differ in exactly one element (see Figure 6 (a) and compare to Figure 1 (a)). The same list is generated by the revolving door algorithm in <ref> [NW78] </ref> and it can be described by a 13 a. Revolving Door b. Strong Minimal Change c. <p> A composition of n into k parts is a sequence (x 1 ; : : : ; x k ) of nonnegative integers whose sum is n. This is traditionally viewed as a placement of n balls into k boxes. Nijenhuis and Wilf asked in the first edition of <ref> [NW78] </ref> (p. 292, problem 34) whether it was possible to 16 a. P (7; 6) b. P 3 (17; 13) c. <p> Algorithms for generating integer partitions in standard orders such as lexicographic and antilexicographic were presented in [FL80] and <ref> [NW78] </ref>. The performance of the algorithms in [FL80] is analyzed in [FL81]. <p> For n = 4, the bijection is illustrated in the first two columns of Figure 9. In [Kay76], Kaye gives a CAT implementation of a Gray code for S (n), attributed to Knuth in [Wil89]. This was another problem posed by Nijenhuis and Wilf in their book <ref> [NW78] </ref> (p. 292, problem 25) and solved by Knuth while reading the galleys. In this Gray code, successive set partitions differ only in that one element moved to an adjacent block (Figure 9 (c).) However, the associated RG functions may differ in many positions. <p> Good references for early work on Gray codes are [Ehr73] and <ref> [NW78] </ref>. For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey [Rus95]. Additional information on Gray codes also appears in the survey of Squire [Squ94a].
Reference: [PR85] <author> A. Proskurowski and F. Ruskey. </author> <title> Binary tree Gray codes. </title> <journal> Journal of Algorithms, </journal> <volume> 6 </volume> <pages> 225-238, </pages> <year> 1985. </year>
Reference-contexts: The problem of generating all binary trees with a given number of nodes was considered in several early papers, including [RH77], [Zak80], and [Zer85]. However, Gray codes in the Catalan family were first considered in <ref> [PR85] </ref>, where binary trees were represented as strings of balanced parentheses. It was shown in [PR85] that strings of balanced parentheses could be listed so that consecutive strings differ only by the interchange of one left and one right parenthesis. For example `(()())(())' could follow `(()(())())'. <p> However, Gray codes in the Catalan family were first considered in <ref> [PR85] </ref>, where binary trees were represented as strings of balanced parentheses. It was shown in [PR85] that strings of balanced parentheses could be listed so that consecutive strings differ only by the interchange of one left and one right parenthesis. For example `(()())(())' could follow `(()(())())'.
Reference: [PR91] <author> G. Pruesse and F. Ruskey. </author> <title> Generating the linear extensions of certain posets by adjacent transpositions. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 4 </volume> <pages> 413-422, </pages> <year> 1991. </year>
Reference-contexts: by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition <ref> [Rus92, PR91, Sta92, Wes93] </ref>, and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection [CSW89]. <p> The problem of efficiently generating all the linear extensions of a poset, in any order, has been studied in [KV83, KS74, VR81]. The area of Gray codes for linear extensions of a poset was introduced by Frank Ruskey in <ref> [Rus88b, PR91] </ref> as a setting in which to generalize the study of Gray codes for combinatorial objects. <p> In many cases where it is known how to list linear extensions by transpositions, it is also possible to require adjacent transpositions, although possibly with a more complicated construction <ref> [PR91, RS93, Sta92, Wes93] </ref>.
Reference: [PR93] <author> G. Pruesse and F. Ruskey. </author> <title> Gray codes from antimatroids. </title> <booktitle> Order, </booktitle> <volume> 10 </volume> <pages> 239-252, </pages> <year> 1993. </year>
Reference-contexts: The conjecture is shown to be true for some special cases in [Rus92], including posets whose Hasse diagram consists of disjoint chains and for series parallel posets in <ref> [PR93] </ref>. The techniques which have been successful so far involve cutting and linking together listings for various subposets in rather intricate ways. <p> On the brighter side, Pruesse and Ruskey [PR94] have found a CAT algorithm for listing linear extensions so that successive extensions differ by one or two adjacent transpositions and Canfield and Williamson [CW95] have shown 26 how to make it loop-free. In <ref> [PR93] </ref>, Pruesse and Ruskey consider antimatroids, of which posets are a special case. Analogous to the case of linear extensions of a poset, they show that the sets of an antimatroid can be listed so that successive sets differ by at most two elements.
Reference: [PR94] <author> G. Pruesse and F. Ruskey. </author> <title> Generating linear extensions fast. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 </volume> <pages> 373-386, </pages> <year> 1994. </year>
Reference-contexts: First, generation of successive objects might be faster. Although for many combinatorial families, a straightforward lexicographic listing algorithm requires only constant average time per element, for other families, such as linear extensions, such performance has only been achieved by a Gray code approach <ref> [PR94] </ref>. Secondly, for the application at hand, it is likely that combinatorial objects which differ in only a small way are associated with feasible solutions which differ by only a small computation. <p> Brightwell and Winkler have recently shown that the problem of counting the number of linear extensions of a given poset is #-P complete [BW92]. On the brighter side, Pruesse and Ruskey <ref> [PR94] </ref> have found a CAT algorithm for listing linear extensions so that successive extensions differ by one or two adjacent transpositions and Canfield and Williamson [CW95] have shown 26 how to make it loop-free. In [PR93], Pruesse and Ruskey consider antimatroids, of which posets are a special case.
Reference: [PR95] <author> G. Pruesse and F. Ruskey. </author> <title> The prism of the acyclic orientation graph is hamiltonian. </title> <journal> Electronic Journal of Combinatorics, </journal> <volume> 2, </volume> <year> 1995. </year>
Reference-contexts: The problem appears to be difficult and it is even open whether AO (K m;n ) is hamiltonian when mn is odd. However, the square of AO (G) is hamiltonian for any G <ref> [PR95, SZ95, Squ94c] </ref>, which means that acyclic orientations can be listed so that successive elements differ in the orientations of at most two edges. The problem of counting acyclic orientations is #P-complete [Lin86] and it is an open 27 question whether there is a CAT algorithm to generate them. <p> In contrast to the situation for linear extensions and acyclic orientations, the square of AO R (G) is not necessarily hamiltonian. Counterexamples appear in [Squ94c] and <ref> [PR95] </ref>. 11 Cayley Graphs and Permutation Gray Codes Many Gray code problems for permutations are best discussed in the setting of Cayley graphs.
Reference: [Put89] <author> T. C. Putnam. </author> <title> A Gray code variant: sequencing permutations via fixed points. </title> <type> Manuscript, </type> <year> 1989. </year>
Reference-contexts: Given n and k satisfying n k 2, is it possible to list all permutations so that successive permutations differ in exactly k positions? This is shown to be possible, unless k = 3, in <ref> [Put89] </ref> and in [Sav90], where the listing is cyclic. It was shown further in [RS94a] that the k positions (in which successive permutations differ) could be required to be contiguous.
Reference: [Put90] <author> T. C. Putnam. </author> <title> Combinatorial Gray code and a generalization of the Johnson- Trotter algorithm to contiguous k-cycles. Manuscript, </title> <booktitle> 1990. Presented at the Fifth SIAM Conference on Discrete Mathematics, </booktitle> <address> Atlanta. </address>
Reference-contexts: It was shown further in [RS94a] that the k positions (in which successive permutations differ) could be required to be contiguous. Putnam claims in <ref> [Put90] </ref> that when k is even (odd) all permutations (even permutations) can be generated by k-cycles of elements in contiguous positions. (Putnam's k-cycles need not be of the form (i; i + 1; : : : ; i + k 1):) 12 An interesting question arose in connection with a problem
Reference: [Rab84] <author> S. Rabinowitz. </author> <title> Problem 1186. </title> <journal> Mathematics Magazine, </journal> <volume> 57:109, </volume> <year> 1984. </year>
Reference-contexts: A contrary approach to the problem is to require that permutations be listed so that each one differs from its predecessor in every position, that is, by a derangement. This problem was posed independently in <ref> [Rab84, Wil89] </ref>. The existence of such a list when n 6= 3 was established in [Met85] using Jackson's theorem [Jac80] and a constructive solution was presented in [EW85]. A simpler construction, ascribed to Lynn Yarbrough, is discussed in [RS87]. Yarbrough's solution is illustrated in Figure 5 and works as follows.
Reference: [Ram90] <author> M. Ramras. </author> <title> A new method of generating Hamilton cycles on the n-cube. </title> <journal> Discrete Mathematics, </journal> <volume> 85 </volume> <pages> 329-331, </pages> <year> 1990. </year>
Reference-contexts: Another variation, non-composite n-bit Gray codes, requires that no contiguous subsequence correspond to a path in any k-cube for 2 k n. Non-composite Gray codes have been constructed for all n <ref> [Ram90] </ref>. (See Figure 1 (d) for an example from [Ram90].) A new constraint is considered in [SW95]. Define the density of a binary string to be the number of 1's in the string. Clearly, no Gray code for binary strings can list them in non-decreasing order of density. <p> Another variation, non-composite n-bit Gray codes, requires that no contiguous subsequence correspond to a path in any k-cube for 2 k n. Non-composite Gray codes have been constructed for all n <ref> [Ram90] </ref>. (See Figure 1 (d) for an example from [Ram90].) A new constraint is considered in [SW95]. Define the density of a binary string to be the number of 1's in the string. Clearly, no Gray code for binary strings can list them in non-decreasing order of density. However, suppose the requirement is relaxed somewhat.
Reference: [Ran48] <author> R. A. Rankin. </author> <title> A campanological problem in group theory. </title> <booktitle> Proceedings of the Cambridge Philosophical Society, </booktitle> <volume> 44 </volume> <pages> 17-25, </pages> <year> 1948. </year>
Reference-contexts: C [G; X] is always vertex transitive and is connected if and only if X [ X 1 generates G. It is an open question whether every Cayley graph is hamiltonian. (There are generating sets for which the Cayley digraph is not hamiltonian <ref> [Ran48] </ref>.) This is a special case of the more general conjecture of Lovasz that every connected, undirected, vertex-transitive graph has a Hamilton path [Lov70]. Results on Hamilton cycles are surveyed in [Als81] for vertex transitive graphs and in [Gou91] for general graphs. <p> In perhaps the simplest nontrivial case, when S n is generated by three involutions, it is easy to show that if any two of the generators commute, then the Cayley graph is hamiltonian. (Cayley graphs arising in change ringing frequently have this property <ref> [Ran48, Whi83] </ref>.) However if no two of the three involutions commute, it is open whether the Cayley graph is hamiltonian.
Reference: [RC81] <author> J. Robinson and M. Cohn. </author> <title> Counting sequences. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30:17-23, </volume> <year> 1981. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing <ref> [RC81] </ref>, signal encoding [Lud81], ordering of documents on shelves [Los92], data compression [Ric86], statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72]. <p> For general n, balancing heuristics were suggested, but not proved, in <ref> [LS81, VS80, RC81] </ref>. Recently we have shown, using the Robinson-Cohn construction [RC81], that balanced Gray codes exist for all n in the following sense: Let a = b2 n =nc or b2 n =nc 1, so that a is even. <p> For general n, balancing heuristics were suggested, but not proved, in [LS81, VS80, RC81]. Recently we have shown, using the Robinson-Cohn construction <ref> [RC81] </ref>, that balanced Gray codes exist for all n in the following sense: Let a = b2 n =nc or b2 n =nc 1, so that a is even.
Reference: [Rea72] <author> R. C. </author> <title> Read. Note on the generation of rosary permutations. </title> <journal> Communications of the ACM, </journal> <volume> 15:775, </volume> <year> 1972. </year>
Reference-contexts: Lisonek [Lis93] shows how to modify the necklace algorithm of [WS90] to generate bracelets. We know of no Gray code for bracelets and it is open whether it is possible to generate bracelets in constant amortized time. When beads have distinct colors, bracelets are the rosary permutations of <ref> [Har71, Rea72] </ref>. Define a new relation R on n-bead binary necklaces by xRy if some member of x becomes a member of y by changing a 0 to a 1 in one bit position.
Reference: [RH77] <author> F. Ruskey and T. C. Hu. </author> <title> Generating binary trees lexicographically. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(4) </volume> <pages> 745-758, </pages> <year> 1977. </year>
Reference-contexts: However, the resulting lists may not look like Gray codes, since bijections need not preserve minimal changes between elements. The problem of generating all binary trees with a given number of nodes was considered in several early papers, including <ref> [RH77] </ref>, [Zak80], and [Zer85]. However, Gray codes in the Catalan family were first considered in [PR85], where binary trees were represented as strings of balanced parentheses.
Reference: [Ric86] <author> D. Richards. </author> <title> Data compression and Gray-code sorting. </title> <journal> Information Processing Letters, </journal> <volume> 22 </volume> <pages> 210-205, </pages> <year> 1986. </year>
Reference-contexts: Gray codes have found applications in such diverse areas as circuit testing [RC81], signal encoding [Lud81], ordering of documents on shelves [Los92], data compression <ref> [Ric86] </ref>, statistics [DH94], graphics and image processing [ASD90], processor allocation in the hypercube [CS90], hashing [Fal88], computing the permanent [NW78], information storage and retrieval [CCC92], and puzzles, such as the Chinese Rings and Towers of Hanoi [Gar72]. <p> It was shown in [JWW80], using a generalization of the binary reflected Gray code scheme, that it is always possible to list the Cartesian product of finite sets so that successive elements differ only in one coordinate. A similar result is obtained in <ref> [Ric86] </ref> where each coordinate i is allowed to assume values in some fixed range 0; : : : ; N i 1. Squire generalizes results on clean words to m-ary Gray codes [Squ96], but leaves open the case when m is odd.
Reference: [RP90] <author> F. Ruskey and A. Proskurowski. </author> <title> Generating binary trees by transpositions. </title> <journal> Journal of Algorithms, </journal> <volume> 11(1) </volume> <pages> 68-84, </pages> <year> 1990. </year>
Reference-contexts: It was shown in [PR85] that strings of balanced parentheses could be listed so that consecutive strings differ only by the interchange of one left and one right parenthesis. For example `(()())(())' could follow `(()(())())'. The same problem was considered in <ref> [RP90] </ref> with the additional restriction that only adjacent left and right parentheses could be interchanged. For example, now `(()())(())' could not follow `(()(())())', but could follow `((()))(())'. The result of [RP90] is that all balanced strings of n pairs of parentheses can be generated by adjacent interchanges if and only if <p> For example `(()())(())' could follow `(()(())())'. The same problem was considered in <ref> [RP90] </ref> with the additional restriction that only adjacent left and right parentheses could be interchanged. For example, now `(()())(())' could not follow `(()(())())', but could follow `((()))(())'. The result of [RP90] is that all balanced strings of n pairs of parentheses can be generated by adjacent interchanges if and only if n is even or n &lt; 5, and for these cases, a CAT algorithm is given.
Reference: [RS87] <author> D. F. Rall and P. J. Slater. </author> <title> Generating all permutations by graphical derangements. </title> <type> Unpublished manuscript, </type> <year> 1987. </year>
Reference-contexts: This problem was posed independently in [Rab84, Wil89]. The existence of such a list when n 6= 3 was established in [Met85] using Jackson's theorem [Jac80] and a constructive solution was presented in [EW85]. A simpler construction, ascribed to Lynn Yarbrough, is discussed in <ref> [RS87] </ref>. Yarbrough's solution is illustrated in Figure 5 and works as follows. Take each permutation on the Johnson-Trotter list for n 1, append an `n', and rotate the resulting permutation, one position at a time, through its n possible cyclic shifts.
Reference: [RS93] <author> F. Ruskey and C. D. Savage. </author> <title> Hamilton cycles which extend transposition matchings in Cayley graphs of S n . SIAM Journal on Discrete Mathematics, </title> <booktitle> 6(1) </booktitle> <pages> 152-166, </pages> <year> 1993. </year> <month> 37 </month>
Reference-contexts: In many cases where it is known how to list linear extensions by transpositions, it is also possible to require adjacent transpositions, although possibly with a more complicated construction <ref> [PR91, RS93, Sta92, Wes93] </ref>. <p> Compton and Williamson were able to find a Hamilton cycle in this graph using their Gray code for generating permutations by doubly adjacent transpositions, described in Section 3 [CW93]. The results of [KL75, Sla78] were generalized in a different way in <ref> [RS93] </ref>. <p> For example, letting X = f (1 2); (1 3); : : :; (1 n)g and o = (1 n), the result in <ref> [RS93] </ref> implies that the Cayley graph of A n with respect to the generating set X = f (1 2 n), (1 3 n), : : :, (1 n 1 n) g is hamiltonian.
Reference: [RS94a] <author> D. J. Rasmussen and C. D. Savage. </author> <title> Hamilton-connected derangement graphs on S n . Discrete Mathematics, </title> <booktitle> 133 </booktitle> <pages> 217-223, </pages> <year> 1994. </year>
Reference-contexts: Given n and k satisfying n k 2, is it possible to list all permutations so that successive permutations differ in exactly k positions? This is shown to be possible, unless k = 3, in [Put89] and in [Sav90], where the listing is cyclic. It was shown further in <ref> [RS94a] </ref> that the k positions (in which successive permutations differ) could be required to be contiguous.
Reference: [RS94b] <author> F. Ruskey and C. D. Savage. </author> <title> Gray codes for set partitions and restricted growth tails. </title> <journal> Australasian Journal of Combinatorics, </journal> <volume> 10 </volume> <pages> 85-96, </pages> <year> 1994. </year>
Reference-contexts: In the associated list of set partitions, this change corresponds to moving one element to an adjacent block in the partition, where the first and last blocks are considered adjacent (Figure 9 (e).) Ehrlich's results are generalized in <ref> [RS94b] </ref> to the set of restricted growth tails, T (n; k), which are strings of non-negative integers satisfying a 1 k and a i 1+maxfa 1 ; : : : ; a i1 ; k 1g. (These are a variation of the T (n; m) used in [Wil85] for ranking and <p> Ruskey describes a Gray code for R b (n) (and a CAT implementation) in which successive elements differ in only one position, but possibly by more than 1 in that position [Rus93]. It is shown in <ref> [RS94b] </ref> that in general, R b (n) does not have a strict Gray code, even under the relaxed criterion of Ehlich.
Reference: [RS95] <author> F. Ruskey and C. D. Savage. </author> <title> A Gray code for combinations of a multiset. </title> <journal> European Journal of Combinatorics, </journal> <note> 1995. to appear. </note>
Reference-contexts: In [Ehr73], Ehrlich provides a loopless algorithm to generate multiset combinations so that successive elements differ in only two positions, but not necessarily by just 1 in those positions. It is shown in <ref> [RS95] </ref> that a Gray code still exists when the two position can change by only 1, thereby generalizing Gray code results for both combinations and compositions. 5 Integer Partitions A partition of an integer n is a sequence of positive integers x 1 x 2 : : : x k satisfying
Reference: [RSW92] <author> F. Ruskey, C. D. Savage, and T. M. Y. Wang. </author> <title> Generating necklaces. </title> <journal> Journal of Algorithms, </journal> <volume> 13 </volume> <pages> 414-430, </pages> <year> 1992. </year>
Reference-contexts: Subsequently, a tight analysis of the original FKM algorithm showed that it could, in fact, be implemented to run in time O (N n k ), giving an optimal solution <ref> [RSW92] </ref>. Neither of the algorithms above gives a Gray code for necklaces.
Reference: [RSW95] <author> D. J. Rasmussen, C. D. Savage, and D. B. West. </author> <title> Gray code enumeration of families of integer partitions. </title> <journal> Journal of Combinatorial Theory Series A, </journal> <volume> 70(2) </volume> <pages> 201-229, </pages> <year> 1995. </year>
Reference-contexts: When ffi = 1, P ffi (n; k) is just P (n; k). When ffi = 2, the elements of P ffi (n; k) are the partitions of n into odd parts of size at most k. It is shown in <ref> [RSW95] </ref> that P ffi (n; k) can be listed so that between successive partitions, one part increases by ffi (or ffi ones may appear) and another part decreases by ffi (or ffi ones may 18 disappear.) (See Figure 8 (b).) The Gray code is max-min unless (n; k) = (4ffi + <p> Surprisingly, it is still possible to list D (n; k) in Gray code order: between successive partitions one part increases by two and one part decreases by two <ref> [RSW95] </ref>. (See Figure 8 (c).) The Gray code is max-min unless (n; k) is (9; 6) or (12; 6), in which cases a max-min Gray code is impossible.
Reference: [Rus] <author> F. Ruskey. </author> <title> private communication. </title>
Reference-contexts: The problem is also open for posets whose Hasse diagram is a grid or tableau tilted ninety degrees <ref> [Rus] </ref>. Calculating the parity difference itself can be difficult and Ruskey [Rus] has several examples of posets for which the parity difference is unknown. (Some parity differences are calculated in [KR88].) Recently, Stachowiak has shown that computing the parity difference is #P-complete [Sta]. <p> The problem is also open for posets whose Hasse diagram is a grid or tableau tilted ninety degrees <ref> [Rus] </ref>. Calculating the parity difference itself can be difficult and Ruskey [Rus] has several examples of posets for which the parity difference is unknown. (Some parity differences are calculated in [KR88].) Recently, Stachowiak has shown that computing the parity difference is #P-complete [Sta].
Reference: [Rus88a] <author> F. Ruskey. </author> <title> Adjacent interchange generation of combinations. </title> <journal> Journal of Algorithms, </journal> <volume> 9 </volume> <pages> 162-180, </pages> <year> 1988. </year>
Reference-contexts: codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements [Joh63, Tro62], (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element <ref> [BER76, BW84, EHR84, EM84, NW78, Rus88a] </ref>, (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of <p> However, this is not always possible: it was shown that k-subsets of an n-set can be generated by adjacent interchanges if (i) k=0, 1, n, or n 1 or (ii) n is even and k is odd. In all other cases, parity problems prevent adjacent interchange generation <ref> [BW84, EHR84, HR88, Rus88a] </ref>. It was shown by Chase [Cha89] and by a simpler construction in [Rus93] that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them.
Reference: [Rus88b] <author> F. Ruskey. </author> <title> Research problem 90. </title> <journal> Discrete Mathematics, </journal> <volume> 70 </volume> <pages> 111-112, </pages> <year> 1988. </year>
Reference-contexts: The problem of efficiently generating all the linear extensions of a poset, in any order, has been studied in [KV83, KS74, VR81]. The area of Gray codes for linear extensions of a poset was introduced by Frank Ruskey in <ref> [Rus88b, PR91] </ref> as a setting in which to generalize the study of Gray codes for combinatorial objects. <p> The vertices are the linear extensions of the poset, two vertices being joined by an edge if they differ by a transposition. The resulting graph is bipartite. In <ref> [Rus88b] </ref>, Ruskey makes the conjecture that whenever the parity difference is at most one, the graph of the poset has a Hamilton path.
Reference: [Rus92] <author> F. Ruskey. </author> <title> Generating linear extensions of posets by transpositions. </title> <journal> Journal of Combinatorial Theory Series B, </journal> <volume> 54 </volume> <pages> 77-101, </pages> <year> 1992. </year>
Reference-contexts: by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition <ref> [Rus92, PR91, Sta92, Wes93] </ref>, and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection [CSW89]. <p> The paper [JWW80] considers families of combinatorial objects, whose size is defined by a recurrence of a particular form, and some general results are obtained about constructing Gray codes for these families. Ruskey shows in <ref> [Rus92] </ref> that certain Gray code listing problems can be viewed as special cases of the problem of listing the linear extensions of an associated poset so that successive extensions differ by a transposition. <p> If the poset consists of a collection of disjoint chains, the linear extensions correspond to multiset permutations. Other examples are described in <ref> [Rus92] </ref>. 25 To study the existence of Gray codes, Ruskey constructs a transposition graph corre-sponding to a given poset. The vertices are the linear extensions of the poset, two vertices being joined by an edge if they differ by a transposition. The resulting graph is bipartite. <p> The resulting graph is bipartite. In [Rus88b], Ruskey makes the conjecture that whenever the parity difference is at most one, the graph of the poset has a Hamilton path. The conjecture is shown to be true for some special cases in <ref> [Rus92] </ref>, including posets whose Hasse diagram consists of disjoint chains and for series parallel posets in [PR93]. The techniques which have been successful so far involve cutting and linking together listings for various subposets in rather intricate ways.
Reference: [Rus93] <author> F. Ruskey. </author> <title> Simple combinatorial Gray codes constructed by reversing sublists. </title> <booktitle> In Proceedings, 4th ISAAC, Hong Kong, Lecture Notes in Computer Science, </booktitle> <volume> 762, </volume> <pages> pages 201-208. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In all other cases, parity problems prevent adjacent interchange generation [BW84, EHR84, HR88, Rus88a]. It was shown by Chase [Cha89] and by a simpler construction in <ref> [Rus93] </ref> that combinations can be generated so that successive elements differ either by an adjacent transposition or by the transposition of two bits that have a single `0' bit between them. <p> Ruskey describes a Gray code for R b (n) (and a CAT implementation) in which successive elements differ in only one position, but possibly by more than 1 in that position <ref> [Rus93] </ref>. It is shown in [RS94b] that in general, R b (n) does not have a strict Gray code, even under the relaxed criterion of Ehlich.
Reference: [Rus95] <author> F. Ruskey. </author> <title> Combinatorial Generation. </title> <note> 1995. Book in preparation. </note>
Reference-contexts: Ruskey notes in <ref> [Rus95] </ref> that a lexicographic listing of partitions in this ordered pairs representation has the property that successive elements of the list differ at most in the last three ordered pairs. <p> In this Gray code, successive set partitions differ only in that one element moved to an adjacent block (Figure 9 (c).) However, the associated RG functions may differ in many positions. Ruskey <ref> [Rus95] </ref> describes a modification of Knuth's algorithm in which one element moves to a block at most two away between successive partitions and the associated RG functions differ only in one position by at most two (Figure 9 (d).) Call a Gray code for RG functions strict if successive elements differ <p> Good references for early work on Gray codes are [Ehr73] and [NW78]. For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey <ref> [Rus95] </ref>. Additional information on Gray codes also appears in the survey of Squire [Squ94a]. In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard.
Reference: [RW94] <author> F. Ruskey and T. M. Y. Wang. </author> <title> Generating neckties: algorithms, Gray codes, and parity differences, 1994. </title> <type> Preprint. </type>
Reference-contexts: For this result, two neckties are adjacent if and only if they differ only in one position and in that position by 1 modulo k. Further results on neckties appear in <ref> [RW94] </ref>. 9 Linear Extension of Posets A partially ordered set (S; ) is a set S together with a binary relation on S which is reflexive, transitive, and antisymmetric.
Reference: [Sav89] <author> C. D. Savage. </author> <title> Gray code sequences of partitions. </title> <journal> Journal of Algorithms, </journal> <volume> 10(4) </volume> <pages> 577-595, </pages> <year> 1989. </year>
Reference-contexts: single node [Luc87, LRR93], (4) listing all spanning trees of a graph so that successive trees differ only by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one <ref> [Sav89] </ref>, (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition [Rus92, PR91, Sta92, Wes93], and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection [CSW89]. <p> In <ref> [Sav89] </ref>, it is shown constructively to be possible for all n. The result is a bit more general: for all n k 1, there is a way to list the set P (n; k), of all partitions of n into integers of size at most k, in Gray code order. <p> See Figure 8 (a) for a Gray code listing of P (7; 6). Exponents in the figure indicate the number of multiple copies. The approach in <ref> [Sav89] </ref>, was to decompose the partitions problem, P (n; k), into sub-problems of two forms, a `P ' form, which was the same form as the original problem, and a new `M ' form.
Reference: [Sav90] <author> C. D. Savage. </author> <title> Generating permutations with k-differences. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 3(4) </volume> <pages> 561-573, </pages> <year> 1990. </year>
Reference-contexts: Given n and k satisfying n k 2, is it possible to list all permutations so that successive permutations differ in exactly k positions? This is shown to be possible, unless k = 3, in [Put89] and in <ref> [Sav90] </ref>, where the listing is cyclic. It was shown further in [RS94a] that the k positions (in which successive permutations differ) could be required to be contiguous.
Reference: [Sav93] <author> C. D. Savage. </author> <title> Long cycles in the middle two levels of the Boolean lattice. </title> <address> Ars Combina-toria, 35-A:97-108, </address> <year> 1993. </year>
Reference-contexts: A result of Dejter and Quintana gives a cycle of length (N (k) t ) where t = (log3)=(log4) 0:793 [DQ87]. This was improved in <ref> [Sav93] </ref> to 15 4 6 7 1 2 6 2 4 7 1 4 6 1 3 5 1 4 7 1 6 7 2 5 7 3 4 6 3 5 6 1 2 7 5 6 7 2 3 5 3 4 5 3 5 7 1 5 7
Reference: [Sed77] <author> R. Sedgewick. </author> <title> Permutation generation methods. </title> <journal> Computing Surveys, </journal> <volume> 9(2) </volume> <pages> 137-164, </pages> <year> 1977. </year>
Reference-contexts: He calls these quasi-Gray codes and establishes bounds and trade-offs on the resources required to generate successors using a decision assignment tree model of computation. 3 Permutations Algorithms for generating all permutations of 1 2 : : : n, for a given integer n 1 were surveyed by Sedgewick in <ref> [Sed77] </ref>. <p> Such a Gray code for permutations was shown to be possible in several papers, including [Boo65, Boo67, Hea63, Wel61], which are described in <ref> [Sed77] </ref>. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions. It was shown independently by Johnson [Joh63] and Trotter [Tro62] that it is possible to generate permutations by transpositions even if the two elements exchanged are required to be in adjacent positions. <p> In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, [WG84] and the recent update [CG96] for Cayley graphs, and <ref> [Sed77] </ref> for permutations. Acknowledgements I am grateful to Herb Wilf for collecting and sharing such an intriguing array of `Gray code' problems. His work, as well as his enthusiasm, has been inspiring.
Reference: [Sim] <author> J. E. Simpson. </author> <title> Hamiltonian bipartite graphs. </title> <type> Preprint. </type>
Reference-contexts: Hamilton path among the k-sets and n k sets of f1; : : :; ng for all n, where two sets are joined by an edge if and only if one is a subset of the other? Results for limited values of k and n are given in [Hur94] and <ref> [Sim] </ref>. A composition of n into k parts is a sequence (x 1 ; : : : ; x k ) of nonnegative integers whose sum is n. This is traditionally viewed as a placement of n balls into k boxes.
Reference: [SK87] <author> J. Sha and D. J. Kleitman. </author> <title> The number of linear extensions of subset ordering. </title> <journal> Discrete Mathematics, </journal> <volume> 63 </volume> <pages> 271-279, </pages> <year> 1987. </year>
Reference-contexts: Even counting the number of linear extensions of a poset is an open problem for some specific posets, for example, the Boolean lattice <ref> [SK87] </ref>. Brightwell and Winkler have recently shown that the problem of counting the number of linear extensions of a given poset is #-P complete [BW92].
Reference: [Sla78] <author> P. J. Slater. </author> <title> Generating all permutations by graphical transpositions. </title> <journal> Ars Combinatoria, </journal> <volume> 5 </volume> <pages> 219-225, </pages> <year> 1978. </year>
Reference-contexts: Kompel'makher and Liskovets generalized this result to show that if X is any set of transpositions generating S n , then C [S n ; X] is hamiltonian [KL75]. Independently, and with a much simpler argument, Slater showed that these graphs have Hamilton paths <ref> [Sla78] </ref>. <p> Independently, and with a much simpler argument, Slater showed that these graphs have Hamilton paths [Sla78]. Tchuente [Tch82] extended the results of <ref> [KL75, Sla78] </ref> to show that the Cayley graph of S n , on any generating set X of transpositions, is not only hamiltonian, but Hamilton-laceable, that is, for any two vertices u; v of different parity there is a Hamilton path which starts at u and ends at v. <p> Compton and Williamson were able to find a Hamilton cycle in this graph using their Gray code for generating permutations by doubly adjacent transpositions, described in Section 3 [CW93]. The results of <ref> [KL75, Sla78] </ref> were generalized in a different way in [RS93].
Reference: [Squ94a] <author> M. B. Squire. </author> <title> Combinatorial Gray codes and efficient generation. </title> <type> Technical Report 94-17, </type> <institution> North Carolina State University, </institution> <year> 1994. </year>
Reference-contexts: Good references for early work on Gray codes are [Ehr73] and [NW78]. For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey [Rus95]. Additional information on Gray codes also appears in the survey of Squire <ref> [Squ94a] </ref>. In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, [WG84] and the recent update [CG96] for Cayley graphs, and [Sed77] for permutations.
Reference: [Squ94b] <author> M. B. Squire. </author> <title> Generating the acyclic orientations of a graph. </title> <note> Submitted to Journal of Algorithms, 1994. 38 </note>
Reference-contexts: The problem of counting acyclic orientations is #P-complete [Lin86] and it is an open 27 question whether there is a CAT algorithm to generate them. The fastest listing algorithm known, due to Squire <ref> [Squ94b] </ref>, requires O (n) average time per orientation, where n is the number of vertices of the graph. The linear extensions and acyclic orientations problems can be simultaneously generalized as follows.
Reference: [Squ94c] <author> M. B. Squire. </author> <title> Two new Gray codes for acyclic orientations. </title> <type> Technical Report 94-14, </type> <institution> North Carolina State University, </institution> <year> 1994. </year>
Reference-contexts: The problem appears to be difficult and it is even open whether AO (K m;n ) is hamiltonian when mn is odd. However, the square of AO (G) is hamiltonian for any G <ref> [PR95, SZ95, Squ94c] </ref>, which means that acyclic orientations can be listed so that successive elements differ in the orientations of at most two edges. The problem of counting acyclic orientations is #P-complete [Lin86] and it is an open 27 question whether there is a CAT algorithm to generate them. <p> In contrast to the situation for linear extensions and acyclic orientations, the square of AO R (G) is not necessarily hamiltonian. Counterexamples appear in <ref> [Squ94c] </ref> and [PR95]. 11 Cayley Graphs and Permutation Gray Codes Many Gray code problems for permutations are best discussed in the setting of Cayley graphs.
Reference: [Squ96] <author> M. B. Squire. </author> <title> Gray codes for A-free strings. </title> <journal> Electronic Journal of Combinatorics, </journal> <volume> 3(R17), </volume> <year> 1996. </year>
Reference-contexts: ! ! ! ! ! ! ! ! ! ! ! ! !j j j j ! ! ! ! ! ! ! ! ! ! @ @ 1,2,3,4,5 1,2,3 1,3,4 1,2,4 2,3,4 2,4,5 2,3,5 3,4,5 1,3,5 1,4,5 1,2,5 1 2 3 4 5 9 problems for infinitely many n <ref> [Squ96] </ref>. It is natural to consider an extension of binary Gray codes to m-ary Gray codes. <p> A similar result is obtained in [Ric86] where each coordinate i is allowed to assume values in some fixed range 0; : : : ; N i 1. Squire generalizes results on clean words to m-ary Gray codes <ref> [Squ96] </ref>, but leaves open the case when m is odd. Another listing problem for binary numbers, posed by Doug West, involves a change in the underlying graph.
Reference: [SSW93] <author> C. D. Savage, M. B. Squire, and D. B. West. </author> <title> Gray code results for acyclic orientations. </title> <journal> Congressus Numerantium, </journal> <volume> 96 </volume> <pages> 185-204, </pages> <year> 1993. </year>
Reference-contexts: The graph AO (G) is bipartite and is connected as long as G is simple. Edelman asked, whenever the partite sets have the same size, whether AO (G) is hamiltonian. It is shown in <ref> [SSW93] </ref> that the answer is yes for several classes of graphs, including trees, odd length cycles, complete graphs, odd ladder graphs, and chordal graphs.
Reference: [Sta] <author> G. Stachowiak. </author> <title> Finding parity difference by involutions. </title> <type> Preprint. </type>
Reference-contexts: Calculating the parity difference itself can be difficult and Ruskey [Rus] has several examples of posets for which the parity difference is unknown. (Some parity differences are calculated in [KR88].) Recently, Stachowiak has shown that computing the parity difference is #P-complete <ref> [Sta] </ref>. Even counting the number of linear extensions of a poset is an open problem for some specific posets, for example, the Boolean lattice [SK87]. Brightwell and Winkler have recently shown that the problem of counting the number of linear extensions of a given poset is #-P complete [BW92].
Reference: [Sta92] <author> G. Stachowiak. </author> <title> Hamilton paths in graphs of linear extensions for unions of posets. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 5 </volume> <pages> 199-206, </pages> <year> 1992. </year>
Reference-contexts: by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition <ref> [Rus92, PR91, Sta92, Wes93] </ref>, and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection [CSW89]. <p> In many cases where it is known how to list linear extensions by transpositions, it is also possible to require adjacent transpositions, although possibly with a more complicated construction <ref> [PR91, RS93, Sta92, Wes93] </ref>. <p> It has been shown that if the linear extensions of a poset Q, with jQj even, can be listed by adjacent transpositions, then so can the linear extensions of QjP , for any poset P <ref> [Sta92] </ref>, where QjP represents the union of posets P and Q with the additional relations fp q j p 2 P; q 2 qg. However, most problems in this area remain open.
Reference: [STT88] <author> D. D. Sleator, R. E. Tarjan, and W. P. Thurston. </author> <title> Rotation distance, triangulations, and hyperbolic geometry. </title> <journal> Journal of the American Mathematical Society, </journal> <volume> 1(3) </volume> <pages> 647-681, </pages> <year> 1988. </year>
Reference-contexts: of combinatorial objects, the size is counted by the Catalan numbers, defined for n 0 by C n = n + 1 2n ! These include binary trees on n vertices [SW86], well-formed sequences of 2n parentheses [SW86], and triangulations of a labeled convex polygon with n + 2 vertices <ref> [STT88] </ref>. Since bijections are known between most members of the Catalan family, a Gray code for one member of the family gives implicitly a listing scheme for every other member of the family. <p> a cyclic Gray code. 22 It so happens that under a particular bijection between binary trees with n nodes and the set of all triangulations of a labeled convex polygon with n + 2 vertices, rotation in a binary tree corresponds to the flip of a diagonal in the triangulation <ref> [STT88] </ref>. So, the results of [Luc87, LRR93] also give a listing of all triangulations of a polygon so that successive triangulations differ only by the flip of a single diagonal. 8 Necklaces and Variations An n-bead, k-color necklace is an equivalence class of k-ary n-tuples under rotation.
Reference: [SW86] <author> D. Stanton and D. White. </author> <title> Constructive Combinatorics. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The restricted growth functions (RG functions) of length n, denoted R (n), are those strings a 1 : : : a n of non-negative integers satisfying a 1 = 0 and a i 1 + maxfa 1 ; : : : ; a i1 g <ref> [SW86] </ref>. There is a well-known bijection between S (n) and R (n). <p> R (n) and T (n; k) when the parity difference is 0. 21 7 Catalan Families In several families of combinatorial objects, the size is counted by the Catalan numbers, defined for n 0 by C n = n + 1 2n ! These include binary trees on n vertices <ref> [SW86] </ref>, well-formed sequences of 2n parentheses [SW86], and triangulations of a labeled convex polygon with n + 2 vertices [STT88]. <p> when the parity difference is 0. 21 7 Catalan Families In several families of combinatorial objects, the size is counted by the Catalan numbers, defined for n 0 by C n = n + 1 2n ! These include binary trees on n vertices <ref> [SW86] </ref>, well-formed sequences of 2n parentheses [SW86], and triangulations of a labeled convex polygon with n + 2 vertices [STT88]. Since bijections are known between most members of the Catalan family, a Gray code for one member of the family gives implicitly a listing scheme for every other member of the family.
Reference: [SW95] <author> C. D. Savage and P. Winkler. </author> <title> Monotone Gray codes and the middle two levels problem. </title> <journal> Journal of Combinatorial Theory Series A, </journal> <volume> 70(2) </volume> <pages> 230-248, </pages> <year> 1995. </year>
Reference-contexts: Another variation, non-composite n-bit Gray codes, requires that no contiguous subsequence correspond to a path in any k-cube for 2 k n. Non-composite Gray codes have been constructed for all n [Ram90]. (See Figure 1 (d) for an example from [Ram90].) A new constraint is considered in <ref> [SW95] </ref>. Define the density of a binary string to be the number of 1's in the string. Clearly, no Gray code for binary strings can list them in non-decreasing order of density. However, suppose the requirement is relaxed somewhat. <p> It is shown in <ref> [SW95] </ref> that monotone Gray codes can be constructed for all n. An example for n = 5 is shown in Figure 2. <p> between levels i and i + 1 must precede edges between levels j and j + 1 if i &lt; j (Figure 3.) Monotone Gray codes have applications to the theory of interconnection networks, providing an embedding of the hypercube into a linear array which minimizes dilation in both directions <ref> [SW95] </ref>. In Section 4 we discuss their relationship to the middle two levels problem. Fix a binary string ff and let B (n; ff) be the set of clean words for ff, i.e., the n-bit strings which do not contain ff as a contiguous substring. <p> In a welcome breakthrough, Felsner and Trotter showed the existence of cycles of length at least 0:25N (k) [FT95]. The monotone Gray code, described in Section 1, contains as a subpath, a path in the middle two levels of length at least 0:5N (k) <ref> [SW95] </ref>. In [SW95], this was strengthened to get `nearly Hamilton' cycles in the following sense: for every * &gt; 0, there is an h 1 so that if a Hamilton cycle exists in the middle two levels of B 2k+1 for 1 k h, then there is a cycle of length <p> In a welcome breakthrough, Felsner and Trotter showed the existence of cycles of length at least 0:25N (k) [FT95]. The monotone Gray code, described in Section 1, contains as a subpath, a path in the middle two levels of length at least 0:5N (k) <ref> [SW95] </ref>. In [SW95], this was strengthened to get `nearly Hamilton' cycles in the following sense: for every * &gt; 0, there is an h 1 so that if a Hamilton cycle exists in the middle two levels of B 2k+1 for 1 k h, then there is a cycle of length at least
Reference: [SZ95] <author> C. D. Savage and C. Q. Zhang. </author> <title> A note on the connectivity of acyclic orientations graphs, 1995. </title> <type> Preprint. </type>
Reference-contexts: The problem appears to be difficult and it is even open whether AO (K m;n ) is hamiltonian when mn is odd. However, the square of AO (G) is hamiltonian for any G <ref> [PR95, SZ95, Squ94c] </ref>, which means that acyclic orientations can be listed so that successive elements differ in the orientations of at most two edges. The problem of counting acyclic orientations is #P-complete [Lin86] and it is an open 27 question whether there is a CAT algorithm to generate them.
Reference: [Tch82] <author> M. Tchuente. </author> <title> Generation of permutations by graphical exchanges. </title> <journal> Ars Combinatoria, </journal> <volume> 14 </volume> <pages> 115-122, </pages> <year> 1982. </year>
Reference-contexts: Kompel'makher and Liskovets generalized this result to show that if X is any set of transpositions generating S n , then C [S n ; X] is hamiltonian [KL75]. Independently, and with a much simpler argument, Slater showed that these graphs have Hamilton paths [Sla78]. Tchuente <ref> [Tch82] </ref> extended the results of [KL75, Sla78] to show that the Cayley graph of S n , on any generating set X of transpositions, is not only hamiltonian, but Hamilton-laceable, that is, for any two vertices u; v of different parity there is a Hamilton path which starts at u and
Reference: [Tro62] <author> H. F. Trotter. </author> <title> PERM (Algorithm 115). </title> <journal> Communications of the ACM, </journal> <volume> 5(8) </volume> <pages> 434-435, </pages> <year> 1962. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter <ref> [Tro62] </ref>, Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> for his telegraph at the Universal Exposition in Paris in 1978, as did Thomas Edison and Alexander Graham Bell.) Examples of combinatorial Gray codes include (1) listing all permutations of 1 : : : n so that consecutive permutations differ only by the swap of one pair of adjacent elements <ref> [Joh63, Tro62] </ref>, (2) listing all k-element subsets of an n-element set in such a way that consecutive sets differ by exactly one element [BER76, BW84, EHR84, EM84, NW78, Rus88a], (3) listing all binary trees so that consecutive trees differ only by a rotation at a single node [Luc87, LRR93], (4) listing <p> Such a Gray code for permutations was shown to be possible in several papers, including [Boo65, Boo67, Hea63, Wel61], which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions. It was shown independently by Johnson [Joh63] and Trotter <ref> [Tro62] </ref> that it is possible to generate permutations by transpositions even if the two elements exchanged are required to be in adjacent positions.
Reference: [VR81] <author> Y. L. Varol and D. Rotem. </author> <title> An algorithm to generate all topological sorting arrangements. </title> <journal> Computer Journal, </journal> <volume> 24 </volume> <pages> 83-84, </pages> <year> 1981. </year>
Reference-contexts: The problem of efficiently generating all the linear extensions of a poset, in any order, has been studied in <ref> [KV83, KS74, VR81] </ref>. The area of Gray codes for linear extensions of a poset was introduced by Frank Ruskey in [Rus88b, PR91] as a setting in which to generalize the study of Gray codes for combinatorial objects.
Reference: [VS80] <author> V. E. Vickers and J. Silverman. </author> <title> A technique for generating specialized Gray codes. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-29:329-331, </volume> <year> 1980. </year>
Reference-contexts: In certain applications, it is necessary that the number of bit changes be more uniformly distributed among the bit positions, i.e., a balanced Gray code is required. (See Figure 1 (b) for an example from <ref> [VS80] </ref>.) Uniformly balanced Gray codes were shown to exist for n a power of two by Wagner and West [WW91]. For general n, balancing heuristics were suggested, but not proved, in [LS81, VS80, RC81]. <p> For general n, balancing heuristics were suggested, but not proved, in <ref> [LS81, VS80, RC81] </ref>. Recently we have shown, using the Robinson-Cohn construction [RC81], that balanced Gray codes exist for all n in the following sense: Let a = b2 n =nc or b2 n =nc 1, so that a is even.
Reference: [Wan93] <author> T. M. Y. Wang. </author> <title> A note on Gray codes for neckties, 1993. </title> <type> Preprint. </type>
Reference-contexts: is an equivalence class of k-ary n-tuples under reversal. 24 7 beads, 4 ones 9 beads, 3 ones 8 beads, 4 ones 0001111 000000111 00001111 0011011 000010011 00100111 0011101 000100101 00101101 000011001 00110101 000001101 00011011 If a necktie is identified with the lexicographically smallest element in its equivalence class, Wang <ref> [Wan93] </ref> shows that for n 3, a Gray code exists if and only if either n or k is odd. For this result, two neckties are adjacent if and only if they differ only in one position and in that position by 1 modulo k.
Reference: [Wan94] <author> T. M. Y. Wang. </author> <title> A Gray Code for Necklaces of Fixed Density. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, North Carolina State University, </institution> <year> 1994. </year>
Reference-contexts: However, in the case of necklaces with a fixed number of 1's, Wang showed, with a very intricate construction, how to construct a Gray code in which successive necklace representatives differ only by the swap of a 0 and a 1 <ref> [Wan94, WS94] </ref> (Figure 11.) It remains open whether necklaces with a fixed number of 1's can be generated in constant amortized time, either by a modification the FKM algorithm, by a Gray code, or by any other method.
Reference: [Wel61] <author> M. B. Wells. </author> <title> Generation of permutations by transposition. </title> <journal> Mathematics of Computation, </journal> <volume> 15 </volume> <pages> 192-195, </pages> <year> 1961. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells <ref> [Wel61] </ref>, Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists [Whi83]. <p> Such a Gray code for permutations was shown to be possible in several papers, including <ref> [Boo65, Boo67, Hea63, Wel61] </ref>, which are described in [Sed77]. One disadvantage of these algorithms is that the elements exchanged are not necessarily in adjacent positions.
Reference: [Wes93] <author> D. B. West. </author> <title> Generating linear extensions by adjacent transpositions. </title> <journal> Journal of Combinatorial Theory Series B, </journal> <volume> 57 </volume> <pages> 58-64, </pages> <year> 1993. </year>
Reference-contexts: by a single edge [HH72, Cum66] (5) listing all partitions of an integer n so that in successive partitions, one part has increased by one and one part has decreased by one [Sav89], (6) listing the linear extensions of certain posets so that successive elements differ only by a transposition <ref> [Rus92, PR91, Sta92, Wes93] </ref>, and (7) listing the elements of a Coxeter group so that successive elements differ by a reflection [CSW89]. <p> In many cases where it is known how to list linear extensions by transpositions, it is also possible to require adjacent transpositions, although possibly with a more complicated construction <ref> [PR91, RS93, Sta92, Wes93] </ref>.
Reference: [WG84] <author> D. Witte and J. A. Gallian. </author> <title> A survey - hamiltonian cycles in Cayley graphs. </title> <journal> Discrete Mathematics, </journal> <volume> 51 </volume> <pages> 293-304, </pages> <year> 1984. </year>
Reference-contexts: Results on Hamilton cycles are surveyed in [Als81] for vertex transitive graphs and in [Gou91] for general graphs. A survey of Hamilton cycles in Cayley graphs can be found in <ref> [WG84] </ref> and in the recent update of Curran and Gallian [CG96]. We focus here on a few recent questions which arose in the context of Gray codes. <p> Additional information on Gray codes also appears in the survey of Squire [Squ94a]. In [Gol93], Goldberg considers generating combinatorial structures for which achieving even polynomial delay is hard. For surveys on related material, see [Als81] for long cycles in vertex transitive graphs, [Gou91] for hamiltonian cycles, <ref> [WG84] </ref> and the recent update [CG96] for Cayley graphs, and [Sed77] for permutations. Acknowledgements I am grateful to Herb Wilf for collecting and sharing such an intriguing array of `Gray code' problems. His work, as well as his enthusiasm, has been inspiring.
Reference: [Whi83] <author> A. T. White. </author> <title> Ringing the changes. </title> <journal> Math. Proc. Camb. Phil. Soc., </journal> <volume> 94 </volume> <pages> 203-215, </pages> <year> 1983. </year>
Reference-contexts: However, the origins of minimal change listings can be found in the early work of Gray [Gra53], Wells [Wel61], Trotter [Tro62], Johnson [Joh63], 2 Lehmer [Leh65], Chase [Cha70], Ehrlich [Ehr73], and Nijenhuis and Wilf [NW78], and in the work of campanologists <ref> [Whi83] </ref>. <p> In perhaps the simplest nontrivial case, when S n is generated by three involutions, it is easy to show that if any two of the generators commute, then the Cayley graph is hamiltonian. (Cayley graphs arising in change ringing frequently have this property <ref> [Ran48, Whi83] </ref>.) However if no two of the three involutions commute, it is open whether the Cayley graph is hamiltonian.
Reference: [Wil85] <author> S. G. </author> <type> Williamson. </type> <institution> Combinatorics for Computer Science. Computer Science Press, </institution> <year> 1985. </year>
Reference-contexts: are generalized in [RS94b] to the set of restricted growth tails, T (n; k), which are strings of non-negative integers satisfying a 1 k and a i 1+maxfa 1 ; : : : ; a i1 ; k 1g. (These are a variation of the T (n; m) used in <ref> [Wil85] </ref> for ranking and unranking set partitions.) Note that T (n; 0) = R (n). Because of parity problems, for all k there are infinitely many values of n for which T (n; k) has no strict Gray code, that is, one in which only one position changes by 1.
Reference: [Wil88] <author> H. S. Wilf. </author> <title> Generalized Gray codes. </title> <note> In SIAM Conference on Discrete Mathematics, 1988. Invited talk. </note>
Reference-contexts: Wilf asked the following question regarding a Gray code for integer partitions in the standard representation = (x 1 ; x 2 ; : : :; x k ) <ref> [Wil88] </ref>: Is there a way to list the partitions of an integer n in such a way that consecutive partitions on the list differ only in that one part has increased by 1 and one part has decreased by 1? (A part of size 1 may decrease to 0 or a <p> As a candidate counterexample, Wilf suggested the group of permutations generated by the two cycles (1 2) and (1 2 3 : : : n) <ref> [Wil88] </ref>. Compton and Williamson were able to find a Hamilton cycle in this graph using their Gray code for generating permutations by doubly adjacent transpositions, described in Section 3 [CW93]. The results of [KL75, Sla78] were generalized in a different way in [RS93].
Reference: [Wil89] <author> H. S. Wilf. </author> <title> Combinatorial Algorithms: An Update. </title> <publisher> SIAM, </publisher> <year> 1989. </year> <month> 39 </month>
Reference-contexts: An example is the problem of listing all permutations of 1 : : : n so that consecutive permutations differ in every location <ref> [Wil89] </ref>. <p> years, the recent spurt of activity can be traced to the invited address of Herbert Wilf at the 4 SIAM Conference on Discrete Mathematics in San Francisco in June 1988, Generalized Gray Codes, in which Wilf described some results and open problems. (These are also reported in his SIAM monograph <ref> [Wil89] </ref>.) All of the open problems on Gray codes posed by Wilf in [Wil89] have now been solved, as well as several related problems, and it is our intention here to follow up on this work. <p> of Herbert Wilf at the 4 SIAM Conference on Discrete Mathematics in San Francisco in June 1988, Generalized Gray Codes, in which Wilf described some results and open problems. (These are also reported in his SIAM monograph <ref> [Wil89] </ref>.) All of the open problems on Gray codes posed by Wilf in [Wil89] have now been solved, as well as several related problems, and it is our intention here to follow up on this work. <p> A contrary approach to the problem is to require that permutations be listed so that each one differs from its predecessor in every position, that is, by a derangement. This problem was posed independently in <ref> [Rab84, Wil89] </ref>. The existence of such a list when n 6= 3 was established in [Met85] using Jackson's theorem [Jac80] and a constructive solution was presented in [EW85]. A simpler construction, ascribed to Lynn Yarbrough, is discussed in [RS87]. Yarbrough's solution is illustrated in Figure 5 and works as follows. <p> For the subclass of combinations ( k-subsets of an n-set for fixed k), several Gray codes have been surveyed in <ref> [Wil89] </ref>. As observed in [BER76], a Gray code for combinations can be extracted from the binary reflected Gray code for n-bit numbers: delete from the binary reflected Gray code list all those elements corresponding to subsets which do not have exactly k elements. <p> For n = 4, the bijection is illustrated in the first two columns of Figure 9. In [Kay76], Kaye gives a CAT implementation of a Gray code for S (n), attributed to Knuth in <ref> [Wil89] </ref>. This was another problem posed by Nijenhuis and Wilf in their book [NW78] (p. 292, problem 25) and solved by Knuth while reading the galleys. <p> Jacobson and West have a simple construction for such a sequence of length 2n! [JW]. 13 Concluding Remarks This paper has included a sampling of Gray code results in several areas, particularly those which have appeared since the survey of Wilf <ref> [Wil89] </ref>, in which many of these problems were posed. Good references for early work on Gray codes are [Ehr73] and [NW78]. For a comprehensive treatment of Gray codes and other topics in combinatorial generation, we look forward to the book in preparation by Ruskey [Rus95].
Reference: [WS90] <author> T. M. Y. Wang and C. D. Savage. </author> <title> A new algorithm for generating necklaces. </title> <booktitle> In Pro--ceedings, Twenty-Eighth Annual Allerton Conference on Communication, Control, and Computing, </booktitle> <pages> pages 72-81, </pages> <year> 1990. </year>
Reference-contexts: Wilf asked if it is possible to generate necklaces efficiently, possibly in constant time per necklace. A proposed solution, the FKM algorithm of Fredricksen, Kessler, and Maiorana, had no proven upper bound better than O (nk n ) [FK86, FM78]. In <ref> [WS90] </ref> a new algorithm was presented with time complexity O (nN n k ), where N n k is the number of n-bead necklaces in k colors. <p> To construct a slightly different set of objects, call two k-ary strings equivalent if one is a rotation or a reversal of the other. The equivalence classes under this relation are called bracelets. Lisonek [Lis93] shows how to modify the necklace algorithm of <ref> [WS90] </ref> to generate bracelets. We know of no Gray code for bracelets and it is open whether it is possible to generate bracelets in constant amortized time. When beads have distinct colors, bracelets are the rosary permutations of [Har71, Rea72].
Reference: [WS94] <author> T. M. Y. Wang and C. D. Savage. </author> <title> Gray codes for necklaces of fixed density, 1994. </title> <type> Preprint. </type>
Reference-contexts: However, in the case of necklaces with a fixed number of 1's, Wang showed, with a very intricate construction, how to construct a Gray code in which successive necklace representatives differ only by the swap of a 0 and a 1 <ref> [Wan94, WS94] </ref> (Figure 11.) It remains open whether necklaces with a fixed number of 1's can be generated in constant amortized time, either by a modification the FKM algorithm, by a Gray code, or by any other method.
Reference: [WW91] <author> D. G. Wagner and J. West. </author> <title> Construction of uniform Gray codes. </title> <journal> Congressus Numeran-tium, </journal> <volume> 80 </volume> <pages> 217-223, </pages> <year> 1991. </year>
Reference-contexts: is necessary that the number of bit changes be more uniformly distributed among the bit positions, i.e., a balanced Gray code is required. (See Figure 1 (b) for an example from [VS80].) Uniformly balanced Gray codes were shown to exist for n a power of two by Wagner and West <ref> [WW91] </ref>. For general n, balancing heuristics were suggested, but not proved, in [LS81, VS80, RC81].
Reference: [Yoe62] <author> M. Yoeli. </author> <title> Binary ring sequences. </title> <journal> American Mathematical Monthly, </journal> <volume> 69 </volume> <pages> 852-855, </pages> <year> 1962. </year>
Reference-contexts: It is known also, for any m satisfying n m 2 n , that there is a cyclic binary sequence of length m in which no n-tuple appears more than once <ref> [Yoe62] </ref>. So, the de Bruijn graph contains cycles of all lengths m n. Results on de Bruijn cycles have been applied to random number generation in information theory [Gol64] and in computer architecture, where the de Bruijn graph is recognized as a bounded degree derivative of the shu*e-exchange network [ABR90].
Reference: [Yos87] <author> N. Yoshimura. </author> <title> Ranking and unranking algorithms for trees and other combinatorial objects. </title> <type> PhD thesis, </type> <institution> Computer and Information Science, University of Pennsylvania, </institution> <year> 1987. </year>
Reference-contexts: in that one part has increased by 1 and one part has decreased by 1? (A part of size 1 may decrease to 0 or a `part' of size 0 may increase to 1.) Yoshimura demonstrated that this was possible for integers n = 1; : : : ; 12 <ref> [Yos87] </ref>. In [Sav89], it is shown constructively to be possible for all n.
Reference: [Zak80] <author> S. Zaks. </author> <title> Lexicographic generation of ordered trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 10 </volume> <pages> 63-82, </pages> <year> 1980. </year>
Reference-contexts: However, the resulting lists may not look like Gray codes, since bijections need not preserve minimal changes between elements. The problem of generating all binary trees with a given number of nodes was considered in several early papers, including [RH77], <ref> [Zak80] </ref>, and [Zer85]. However, Gray codes in the Catalan family were first considered in [PR85], where binary trees were represented as strings of balanced parentheses.
Reference: [Zer85] <author> D. Zerling. </author> <title> Generating binary trees using rotations. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 694-701, </pages> <year> 1985. </year>
Reference-contexts: However, the resulting lists may not look like Gray codes, since bijections need not preserve minimal changes between elements. The problem of generating all binary trees with a given number of nodes was considered in several early papers, including [RH77], [Zak80], and <ref> [Zer85] </ref>. However, Gray codes in the Catalan family were first considered in [PR85], where binary trees were represented as strings of balanced parentheses.
References-found: 153

