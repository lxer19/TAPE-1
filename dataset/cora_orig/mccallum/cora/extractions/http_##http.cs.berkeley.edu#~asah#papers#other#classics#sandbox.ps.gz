URL: http://http.cs.berkeley.edu/~asah/papers/other/classics/sandbox.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/classics/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Efficient Software-Based Fault Isolation  
Author: Robert Wahbe Steven Lucco Thomas E. Anderson Susan L. Graham 
Note: To appear in the Proceedings of the Symposium on Operating System Principles, 1993.  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division University of California  
Abstract: One way to provide fault isolation among cooperating software modules is to place each in its own address space. However, for tightly-coupled modules, this solution incurs prohibitive context switch overhead. In this paper, we present a software approach to implementing fault isolation within a single address space. Our approach has two parts. First, we load the code and data for a distrusted module into its own fault domain, a logically separate portion of the application's address space. Second, we modify the object code of a distrusted module to prevent it from writing or jumping to an address outside its fault domain. Both these software operations are portable and programming language independent. Our approach poses a tradeoff relative to hardware fault isolation: substantially faster communication between fault domains, at a cost of slightly increased execution time for distrusted modules. We demonstrate that for frequently communicating modules, implementing fault isolation in software rather than hardware can substantially improve end-to-end application performance. This work was supported in part by the National Science Foundation (CDA-8722788), Defense Advanced Research Projects Agency (DARPA) under grant MDA972-92-J-1028 and contracts DABT63-92-C-0026 and N00600-93-C-2481, the Digital Equipment Corporation (the Systems Research Center and the External Research Program), and the AT&T Foundation. Anderson was also supported by a National Science Foundation Young Investigator Award. The content of the paper does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD74] <author> T.L. Adam, K.M. Chandy, and J.R. Dickson. </author> <title> A comparison of list schedules for parallel processing systems. </title> <journal> Communications of the ACM, </journal> <volume> 17(12) </volume> <pages> 685-690, </pages> <month> December </month> <year> 1974. </year>
Reference-contexts: Our current prototype applies loop invariant code motion and instruction scheduling optimizations <ref> [ASU86, ACD74] </ref>. In addition to these conventional techniques, we employ a number of optimizations specialized to software encapsulation. We can reduce the overhead of software encapsulation mechanisms by avoiding arithmetic that computes target addresses.
Reference: [ALBL91] <author> Thomas Anderson, Henry Levy, Brian Ber-shad, and Edward Lazowska. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the 4th International Confer--ence on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Unfortunately, there is a high performance cost to providing fault isolation through separate address spaces. Transferring control across protection boundaries is expensive, and does not necessarily scale with improvements in a processor's integer performance <ref> [ALBL91] </ref>. A cross-address-space RPC requires at least: a trap into the operating system kernel, copying each argument from the caller to the callee, saving and restoring registers, switching hardware address spaces (on many machines, flushing the translation lookaside buffer), and a trap back to user level. <p> These operations must be repeated upon RPC return. The execution time overhead of an RPC, even with a highly optimized implementation, will often be two to three orders of magnitude greater than the execution time overhead of a normal procedure call <ref> [BALL90, ALBL91] </ref>. The goal of our work is to make fault isolation cheap enough that system developers can ignore its performance effect in choosing which modules to place in separate fault domains. <p> In this graph, h = 0:043 (encapsulation overhead on the dec-mips and dec-alpha). versus number of fault domain crossings per millisecond on the dec-mips. The hardware minimum crossing number is taken from a cross-architectural study of context switch times <ref> [ALBL91] </ref>. The Ultrix 4.2 context switch time is as reported in the last column of Table 2. on hardware fault isolation are ultimately limited by the minimal hardware cost of taking two kernel traps and two hardware context switches. <p> It was estimated that 25% of the cost of an LRPC on the Firefly (which does not have tags) was due to TLB misses [BALL90]. Address space tags do not, however, reduce the cost of register management or system calls, operations which are not scaling with integer performance <ref> [ALBL91] </ref>. An important advantage of software-based fault isolation is that it does not rely on specialized architectural features such as address space tags. Restrictive programming languages can also be used to provide fault isolation.
Reference: [Ass91] <institution> Administrator: National Computer Graphics Association. </institution> <note> SPEC Newsletter, 3(4), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: is the performance impact of using software enforced fault isolation on an end-user application? We discuss each of these questions in turn. 5.1 Encapsulation Overhead We measured the execution time overhead of sand-boxing a wide range of C programs, including the C spec92 benchmarks and several of the Splash benchmarks <ref> [Ass91, SWG91] </ref>. We treated each benchmark as if it were a distrusted module, sandboxing all of its code. Column 1 of Table 1 reports overhead on the dec-mips, column 6 reports overhead on the dec-alpha.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: Our current prototype applies loop invariant code motion and instruction scheduling optimizations <ref> [ASU86, ACD74] </ref>. In addition to these conventional techniques, we employ a number of optimizations specialized to software encapsulation. We can reduce the overhead of software encapsulation mechanisms by avoiding arithmetic that computes target addresses.
Reference: [BALL90] <author> Brian Bershad, Thomas Anderson, Edward La-zowska, and Henry Levy. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: These operations must be repeated upon RPC return. The execution time overhead of an RPC, even with a highly optimized implementation, will often be two to three orders of magnitude greater than the execution time overhead of a normal procedure call <ref> [BALL90, ALBL91] </ref>. The goal of our work is to make fault isolation cheap enough that system developers can ignore its performance effect in choosing which modules to place in separate fault domains. <p> The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d . <p> Tags allow more than one address space to share the TLB; otherwise the TLB must be flushed on each context switch. It was estimated that 25% of the cost of an LRPC on the Firefly (which does not have tags) was due to TLB misses <ref> [BALL90] </ref>. Address space tags do not, however, reduce the cost of register management or system calls, operations which are not scaling with integer performance [ALBL91]. An important advantage of software-based fault isolation is that it does not rely on specialized architectural features such as address space tags.
Reference: [BALL91] <author> Brian Bershad, Thomas Anderson, Edward La-zowska, and Henry Levy. </author> <title> User-Level Interpro-cess Communication for Shared-Memory Multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2), </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: The arguments are marshalled into a message, the kernel copies the message to the target address space, and finally the callee must de-marshall the arguments. By having the caller and callee communicate via a shared buffer, LRPC also uses only a single copy to pass data between domains <ref> [BALL91] </ref>. The stubs are also responsible for managing machine state. On each cross-domain call any registers that are both used in the future by the caller and potentially modified by the callee must be protected. <p> The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [Ber93] <author> Brian Bershad, </author> <month> August </month> <year> 1993. </year> <title> Private Communication. </title>
Reference-contexts: Operating systems with highly optimized RPC implementations have reduced the cost of cross-address-space RPC to within roughly two orders of magnitude of local procedure calls. On Mach 3.0, cross-address-space RPC on a 25Mhz DECstation 5000/200 is 314 times more expensive than a local procedure call <ref> [Ber93] </ref>. The Spring operating system, running on a 40Mhz SPARCstation2, delivers cross-address-space RPC that is 73 times more expensive than a local leaf procedure call [HK93].
Reference: [BL92] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing. </title> <booktitle> In Proceedings of the Conference on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <year> 1992. </year>
Reference-contexts: All overheads are computed as the additional execution time divided by the original program's execution time. On the dec-mips, we used the program measurement tools pixie and qpt to calculate the number of additional instructions executed due to sandbox-ing <ref> [Dig, BL92] </ref>. Column 4 of Table 1 reports this data as a percentage of original program instruction counts. The data in Table 1 appears to contain a number of anomalies.
Reference: [Bla90] <author> David Black. </author> <title> Scheduling Support for Concur-rency and Parallelism in the Mach Operating System. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [BN84] <author> Andrew Birrell and Bruce Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> Febru-ary </month> <year> 1984. </year>
Reference-contexts: As with postgres, faults in extension modules can render any of these systems unreliable. One way to provide fault isolation among cooperating software modules is to place each in its own address space. Using Remote Procedure Call (RPC) <ref> [BN84] </ref>, modules in separate address spaces can call into each other through a normal procedure call interface. Hardware page tables prevent the code in one address space from corrupting the contents of another. Unfortunately, there is a high performance cost to providing fault isolation through separate address spaces.
Reference: [Cla92] <author> J.D. Clark. </author> <title> Window Programmer' Guide To OLE/DDE. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: More generally, several systems have added extension code into the operating system, for example, the BSD network packet filter [MRA87, MJ93], application-specific virtual memory management [HC92], and Active Messages [vCGS92]. Among industry systems, Microsoft's Object Linking and Embedding system <ref> [Cla92] </ref> can link together independently developed software modules. Also, the Quark Xpress desktop publishing system [Dys92] is structured to support incorporation of Email: frwahbe, lucco, tea, grahamg@cs.berkeley.edu 1 general-purpose third party code. As with postgres, faults in extension modules can render any of these systems unreliable.
Reference: [DG71] <author> L. P. Deutsch and C. A. Grant. </author> <title> A flexible measurement tool for software systems. </title> <booktitle> In IFIP Congress, </booktitle> <year> 1971. </year>
Reference-contexts: In contrast, our techniques are language independent. Deutsch and Grant built a system that allowed user-defined measurement modules to be dynamically loaded into the operating system and executed directly on the processor <ref> [DG71] </ref>. The module format was a stylized native object code designed to make it easier to statically verify that the code did not violate protection boundaries. An interpreter can also provide failure isolation.
Reference: [Dig] <institution> Digital Equipment Corporation. </institution> <note> Ultrix v4.2 Pixie Manual Page. </note>
Reference-contexts: All overheads are computed as the additional execution time divided by the original program's execution time. On the dec-mips, we used the program measurement tools pixie and qpt to calculate the number of additional instructions executed due to sandbox-ing <ref> [Dig, BL92] </ref>. Column 4 of Table 1 reports this data as a percentage of original program instruction counts. The data in Table 1 appears to contain a number of anomalies.
Reference: [Dys92] <author> Peter Dyson. </author> <title> Xtensions for Xpress: Modular Software for Custom Systems. Seybold Report on Desktop Publishing, </title> <booktitle> 6(10) </booktitle> <pages> 1-21, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Among industry systems, Microsoft's Object Linking and Embedding system [Cla92] can link together independently developed software modules. Also, the Quark Xpress desktop publishing system <ref> [Dys92] </ref> is structured to support incorporation of Email: frwahbe, lucco, tea, grahamg@cs.berkeley.edu 1 general-purpose third party code. As with postgres, faults in extension modules can render any of these systems unreliable. One way to provide fault isolation among cooperating software modules is to place each in its own address space. <p> A user-level example is the Quark Xpress desktop publishing system. One can purchase third party software that will extend this system to perform functions unforeseen by its original designers <ref> [Dys92] </ref>. At the same time, this extensibility has caused Quark a number of problems. Because of the lack of efficient fault domains on the personal computers where Quark Xpress runs, extension modules can corrupt Quark's internal data structures.
Reference: [FP93] <author> Kevin Fall and Joseph Pasquale. </author> <title> Exploiting in-kernel data paths to improve I/O throughput and CPU a vailability. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 327-333, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Another example is user-programmable high performance I/O systems. If data is arriving on an I/O channel at a high enough rate, performance will be degraded substantially if control has to be transferred to user level to manipulate the incoming data <ref> [FP93] </ref>. Similarly, Active Messages provide high performance message handling in distributed-memory multiprocessors [vCGS92]. Typically, the message handlers are application-specific, but unless the network controller can be accessed from user level [Thi92], the message handlers must be compiled into the kernel for reasonable performance.
Reference: [HC92] <author> Keiran Harty and David Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: An example is micro-kernel design; parts of the operating system are implemented as user-level servers that can be easily modified or replaced. More generally, several systems have added extension code into the operating system, for example, the BSD network packet filter [MRA87, MJ93], application-specific virtual memory management <ref> [HC92] </ref>, and Active Messages [vCGS92]. Among industry systems, Microsoft's Object Linking and Embedding system [Cla92] can link together independently developed software modules. Also, the Quark Xpress desktop publishing system [Dys92] is structured to support incorporation of Email: frwahbe, lucco, tea, grahamg@cs.berkeley.edu 1 general-purpose third party code.
Reference: [HK93] <author> Graham Hamilton and Panos Kougiouris. </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: On Mach 3.0, cross-address-space RPC on a 25Mhz DECstation 5000/200 is 314 times more expensive than a local procedure call [Ber93]. The Spring operating system, running on a 40Mhz SPARCstation2, delivers cross-address-space RPC that is 73 times more expensive than a local leaf procedure call <ref> [HK93] </ref>. <p> The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [HKM + 88] <author> J. Howard, M. Kazar, S. Menees, D. Nichols, M. Satyanarayanan, R. Sidebotham, and M. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-82, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Unfortunately, it is too expensive to forward every file system operation to user level, so typically new file system implementations are added directly into the kernel. (The Andrew file system is largely implemented at user level, but it maintains a kernel cache for performance <ref> [HKM + 88] </ref>.) Epoch's tertiary storage file system [Web93] is one example of operating system kernel code developed by a third party vendor. Another example is user-programmable high performance I/O systems.
Reference: [Int86] <institution> Intel Corporation, Santa Clara, California. </institution> <note> Intel 80386 Programmer's Reference Manual, </note> <year> 1986. </year>
Reference-contexts: This capability is useful during software development. We can reduce runtime overhead still further, at the cost of providing no information about the source of faults. 2 For architectures with limited register sets, such as the 80386 <ref> [Int86] </ref>, it is possible to encapsulate a module using no reserved registers by restricting control flow within a fault domain. dedicated-reg ( target address Move target address into dedicated register. scratch-reg ( (dedicated-reg&gt;>shift-reg) Right-shift address to get segment identifier. scratch-reg is not a dedicated register. shift-reg is a dedicated register. compare
Reference: [JRT85] <author> Michael B. Jones, Richard F. Rashid, and Mary R. Thompson. Matchmaker: </author> <title> An interface specification language for distributed processing. </title> <booktitle> In Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 225-235, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: For each pair of fault domains a customized call and return stub is created for each exported procedure. Currently, the stubs are generated by hand rather than using a stub generator <ref> [JRT85] </ref>. The stubs run unprotected outside of both the caller and callee domain. The stubs are responsible for copying cross-domain arguments between domains and managing machine state. Because the stubs are trusted, we are able to copy call arguments directly to the target domain.
Reference: [Kar89] <author> Paul A. Karger. </author> <title> Using Registers to Optimize Cross-Domain Call Performance. </title> <booktitle> In Proceedings of the 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 194-204, </pages> <month> April 3-6 </month> <year> 1989. </year>
Reference-contexts: As an optimization, if the callee domain contains no instructions that modify a preserved register we can avoid saving it. Karger uses a trusted linker to perform this kind of optimization between address spaces <ref> [Kar89] </ref>. In addition to saving and restoring registers, the stubs must switch the execution stack, establish the correct register context for the software encapsulation technique being used, and validate all dedicated registers.
Reference: [Kle86] <author> Steven R. Kleiman. Vnodes: </author> <title> An Architecture for Multiple File System Types in SUN UNIX. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Conference, </booktitle> <pages> pages 238-247, </pages> <year> 1986. </year>
Reference-contexts: The operating systems community has focused considerable attention on supporting kernel extensibility. For example, the UNIX vnode interface is designed to make it easy to add a new file system into UNIX <ref> [Kle86] </ref>.
Reference: [LB92] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report 1083, </type> <institution> University of Wisconsin-Madison, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: An alternative, called binary patching, alleviates these problems. When the fault domain is loaded, the system can encapsulate the module by directly modifying the object code. Unfortunately, practical and robust binary patching, resulting in efficient code, is not currently possible <ref> [LB92] </ref>. Tools which translate one binary format to another have been built, but these tools rely on compiler-specific idioms to distinguish code from data and use processor emulation to handle unknown indirect jumps [SCK + 93].
Reference: [McF89] <author> Scott McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> In Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 183-191, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: We conjecture that the observed variations are caused by instruction cache mapping conflicts. Software encapsulation changes the mapping of instructions to cache lines, hence changing the number of instruction cache conflicts. A number of researchers have investigated minimizing instruction cache conflicts to reduce execution time <ref> [McF89, PH90, Sam88] </ref>. One researcher reported a 20% performance gain by simply changing the order in which the object files were linked [PH90]. Samples and Hilfinger report significantly improved instruction cache miss rates by rearranging only 3% to 8% of an application's basic blocks [Sam88].
Reference: [MJ93] <author> Steven McCanne and Van Jacobsen. </author> <title> The BSD Packet Filter: A New Architecture for User-Level Packet Capture. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: An example is micro-kernel design; parts of the operating system are implemented as user-level servers that can be easily modified or replaced. More generally, several systems have added extension code into the operating system, for example, the BSD network packet filter <ref> [MRA87, MJ93] </ref>, application-specific virtual memory management [HC92], and Active Messages [vCGS92]. Among industry systems, Microsoft's Object Linking and Embedding system [Cla92] can link together independently developed software modules.
Reference: [MRA87] <author> J. C. Mogul, R. F. Rashid, and M. J. Ac-cetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Symposium on Operating System Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: An example is micro-kernel design; parts of the operating system are implemented as user-level servers that can be easily modified or replaced. More generally, several systems have added extension code into the operating system, for example, the BSD network packet filter <ref> [MRA87, MJ93] </ref>, application-specific virtual memory management [HC92], and Active Messages [vCGS92]. Among industry systems, Microsoft's Object Linking and Embedding system [Cla92] can link together independently developed software modules.
Reference: [PH90] <author> Karl Pettis and Robert C. Hansen. </author> <title> Profile guided code positioning. </title> <booktitle> In Proceedings of the Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 16-27, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <note> Appeared as SIGPLAN NOTICES 25(6). </note>
Reference-contexts: We conjecture that the observed variations are caused by instruction cache mapping conflicts. Software encapsulation changes the mapping of instructions to cache lines, hence changing the number of instruction cache conflicts. A number of researchers have investigated minimizing instruction cache conflicts to reduce execution time <ref> [McF89, PH90, Sam88] </ref>. One researcher reported a 20% performance gain by simply changing the order in which the object files were linked [PH90]. Samples and Hilfinger report significantly improved instruction cache miss rates by rearranging only 3% to 8% of an application's basic blocks [Sam88]. <p> A number of researchers have investigated minimizing instruction cache conflicts to reduce execution time [McF89, PH90, Sam88]. One researcher reported a 20% performance gain by simply changing the order in which the object files were linked <ref> [PH90] </ref>. Samples and Hilfinger report significantly improved instruction cache miss rates by rearranging only 3% to 8% of an application's basic blocks [Sam88]. Beyond this effect, there were statistically significant differences among programs. On average, programs which contained a significant percentage of floating point operations incurred less overhead.
Reference: [RDH + 80] <author> David D. Redell, Yogen K. Dalal, Thomas R. Horsley, Hugh C. Lauer, William C. Lynch, Paul R. McJones, Hal G. Murray, and Stephen C. Purcell. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Restrictive programming languages can also be used to provide fault isolation. Pilot requires all kernel, user, and library code to be written in Mesa, a strongly typed language; all code then shares a single address space <ref> [RDH + 80] </ref>. The main disadvantage of relying on strong typing is that it severely restricts the choice of programming languages, ruling out conventional languages like C, C++, and assembly.
Reference: [Sam88] <author> A. </author> <title> Dain Samples. Code reorganization for instruction caches. </title> <type> Technical Report UCB/CSD 88/447, </type> <institution> University of California, Berkeley, </institution> <month> Oc-tober </month> <year> 1988. </year>
Reference-contexts: We conjecture that the observed variations are caused by instruction cache mapping conflicts. Software encapsulation changes the mapping of instructions to cache lines, hence changing the number of instruction cache conflicts. A number of researchers have investigated minimizing instruction cache conflicts to reduce execution time <ref> [McF89, PH90, Sam88] </ref>. One researcher reported a 20% performance gain by simply changing the order in which the object files were linked [PH90]. Samples and Hilfinger report significantly improved instruction cache miss rates by rearranging only 3% to 8% of an application's basic blocks [Sam88]. <p> One researcher reported a 20% performance gain by simply changing the order in which the object files were linked [PH90]. Samples and Hilfinger report significantly improved instruction cache miss rates by rearranging only 3% to 8% of an application's basic blocks <ref> [Sam88] </ref>. Beyond this effect, there were statistically significant differences among programs. On average, programs which contained a significant percentage of floating point operations incurred less overhead. On the dec-mips the mean overhead for floating point intensive benchmarks is 2.5%, compared to a mean of 5.6% for the remaining benchmarks.
Reference: [SB90] <author> Michael Schroeder and Michael Burrows. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 1-17, </pages> <month> Febru-ary </month> <year> 1990. </year>
Reference-contexts: The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [SCK + 93] <author> Richard L. Sites, Anton Chernoff, Matthew B. Kirk, Maurice P. Marks, and Scott G. Robin-son. </author> <title> Binary translation. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 69-81, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Unfortunately, practical and robust binary patching, resulting in efficient code, is not currently possible [LB92]. Tools which translate one binary format to another have been built, but these tools rely on compiler-specific idioms to distinguish code from data and use processor emulation to handle unknown indirect jumps <ref> [SCK + 93] </ref>. For software encapsulation, the main challenge is to transform the code so that it uses a subset of the registers, leav RPC. ing registers available for dedicated use.
Reference: [SFGM93] <author> M. Stonebraker, J. Frew, K. Gardels, and J. Meridith. </author> <title> The Sequoia 2000 Benchmark. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: the relative cost of cross-fault-domain RPC by an order of magnitude over these systems. 5.3 Using Fault Domains in postgres To capture the effect of our system on application performance, we added software enforced fault domains to the postgres database management system, and measured postgres running the Sequoia 2000 benchmark <ref> [SFGM93] </ref>. The Sequoia 2000 benchmark Cross Fault-Domain RPC Platform Caller Save Save C Pipes Save Integer Integer+Float Procedure Registers Registers Registers Call dec-mips 1.11s 1.81s 2.83s 0.10s 204.72s dec-alpha 0.75s 1.35s 1.80s 0.06s 227.88s Table 2: Cross-fault-domain crossing times.
Reference: [Sto87] <author> Michael Stonebraker. </author> <title> Extensibility in POST-GRES. </title> <journal> IEEE Database Engineering, </journal> <month> Septem-ber </month> <year> 1987. </year>
Reference-contexts: Such fault isolation services also facilitate software development by helping to identify sources of system failure. For example, the postgres database manager includes an extensible type system <ref> [Sto87] </ref>. Using this facility, postgres queries can refer to general-purpose code that defines constructors, destructors, and predicates for user-defined data types such as geometric objects. Without fault isolation, any query that uses extension code could interfere with an unrelated query or corrupt the database.
Reference: [Sto88] <author> Michael Stonebraker. </author> <title> Inclusion of new types in relational data base systems. </title> <editor> In Michael Stone-braker, editor, </editor> <booktitle> Readings in Database Systems, </booktitle> <pages> pages 480-487. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1988. </year>
Reference-contexts: To support these kinds of non-traditional queries, postgres provides a user-extensible type system. Currently, user-defined types are written in conventional programming languages, such as C, and dynamically loaded into the database manager. This has long been recognized to be a serious safety problem <ref> [Sto88] </ref>. Four of the eleven queries in the Sequoia 2000 benchmark make use of user-defined polygon data types. We measured these four queries using both unprotected dynamic linking and software-enforced fault isolation. Since the postgres code is trusted, we only sand-boxed the dynamically loaded user code.
Reference: [SWG91] <author> J. P. Singh, W. Weber, and A. Gupta. </author> <title> Splash: Stanford parallel applications for shared-memory. </title> <type> Technical Report CSL-TR-91-469, </type> <institution> Stanford, </institution> <year> 1991. </year>
Reference-contexts: is the performance impact of using software enforced fault isolation on an end-user application? We discuss each of these questions in turn. 5.1 Encapsulation Overhead We measured the execution time overhead of sand-boxing a wide range of C programs, including the C spec92 benchmarks and several of the Splash benchmarks <ref> [Ass91, SWG91] </ref>. We treated each benchmark as if it were a distrusted module, sandboxing all of its code. Column 1 of Table 1 reports overhead on the dec-mips, column 6 reports overhead on the dec-alpha.
Reference: [TA88] <author> Shin-Yuan Tzou and David P. Anderson. </author> <title> A Performance Evaluation of the DASH Message-Passing System. </title> <type> Technical Report UCB/CSD 88/452, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [Thi92] <author> Thinking Machines Corporation. </author> <title> CM-5 Network Interface Programmer's Guide, </title> <year> 1992. </year>
Reference-contexts: Similarly, Active Messages provide high performance message handling in distributed-memory multiprocessors [vCGS92]. Typically, the message handlers are application-specific, but unless the network controller can be accessed from user level <ref> [Thi92] </ref>, the message handlers must be compiled into the kernel for reasonable performance. A user-level example is the Quark Xpress desktop publishing system. One can purchase third party software that will extend this system to perform functions unforeseen by its original designers [Dys92].
Reference: [vCGS92] <author> T. von Eicken, D. Culler, S. Goldstein, and K. Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Computer Architecture, </booktitle> <year> 1992. </year>
Reference-contexts: More generally, several systems have added extension code into the operating system, for example, the BSD network packet filter [MRA87, MJ93], application-specific virtual memory management [HC92], and Active Messages <ref> [vCGS92] </ref>. Among industry systems, Microsoft's Object Linking and Embedding system [Cla92] can link together independently developed software modules. Also, the Quark Xpress desktop publishing system [Dys92] is structured to support incorporation of Email: frwahbe, lucco, tea, grahamg@cs.berkeley.edu 1 general-purpose third party code. <p> If data is arriving on an I/O channel at a high enough rate, performance will be degraded substantially if control has to be transferred to user level to manipulate the incoming data [FP93]. Similarly, Active Messages provide high performance message handling in distributed-memory multiprocessors <ref> [vCGS92] </ref>. Typically, the message handlers are application-specific, but unless the network controller can be accessed from user level [Thi92], the message handlers must be compiled into the kernel for reasonable performance. A user-level example is the Quark Xpress desktop publishing system.
Reference: [vvST88] <author> Robbert van Renesse, Hans van Staveren, and Andrew S. Tanenbaum. </author> <title> Performance of the World's Fastest Distributed Operating System. </title> <journal> Operating Systems Review, </journal> <volume> 22(4) </volume> <pages> 25-34, </pages> <month> Octo-ber </month> <year> 1988. </year>
Reference-contexts: The graph illustrates the relative performance stability of the software solution. This stability allows system developers to ignore the performance effect of fault isolation in choosing which modules to place in separate fault domains. 6 Related Work Many systems have considered ways of optimizing RPC performance <ref> [vvST88, TA88, Bla90, SB90, HK93, BALL90, BALL91] </ref>. Traditional RPC systems based (t c ). The Y axis represents the relative RPC crossing speed (r). The curve represents the break even point: (1r)t c = ht d .
Reference: [Web93] <author> Neil Webber. </author> <title> Operating System Support for Portable Filesystem Extensions. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: is too expensive to forward every file system operation to user level, so typically new file system implementations are added directly into the kernel. (The Andrew file system is largely implemented at user level, but it maintains a kernel cache for performance [HKM + 88].) Epoch's tertiary storage file system <ref> [Web93] </ref> is one example of operating system kernel code developed by a third party vendor. Another example is user-programmable high performance I/O systems.
Reference: [YBA93] <author> Curtis Yarvin, Richard Bukowski, and Thomas Anderson. Anonymous RPC: </author> <title> Low Latency Protection in a 64-Bit Address Space. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Our approach allows code written in any programming language to be safely encapsulated (or rejected if it is not safe), and then executed at near full speed by the operating system. Anonymous RPC exploits 64-bit address spaces to provide low latency RPC and probabilistic fault isolation <ref> [YBA93] </ref>. Logically independent domains are placed at random locations in the same hardware address space. Calls between domains are anonymous, that is, they do not reveal the location of the caller or the callee to either side.
References-found: 41

