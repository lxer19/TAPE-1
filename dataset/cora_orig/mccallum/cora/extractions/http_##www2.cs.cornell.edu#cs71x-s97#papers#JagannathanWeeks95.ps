URL: http://www2.cs.cornell.edu/cs71x-s97/papers/JagannathanWeeks95.ps
Refering-URL: http://www2.cs.cornell.edu/cs71x-s97/cs719bib.htm
Root-URL: http://www.cs.brown.edu/
Title: A Unified Treatment of Flow Analysis in Higher-Order Languages framework makes explicit use of flow
Author: Suresh Jagannathan Stephen Weeks 
Note: The  
Abstract: We describe a framework for flow analysis in higher-order languages. It is both a synthesis and extension of earlier work in this area, most notably [20, 22]. We develop several instantiations of the framework, and prove their running-time complexity. In addition, we use the simplest instantiation to demonstrate the equivalence of a 0CFA style analysis[20] and the set-based analysis of [8]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The exact semantics of a program P is specified by a set of exact states State and a transition function !, both specific to P . The semantics works directly over the source language; there is no transformation to an intermediate form such as continuation-passing style <ref> [1] </ref>. The semantics explicitly constructs an exact flow graph. For each expression e that is evaluated, a node is added to the graph to the store the value of e. <p> Stefanescu and Zhou [22] present an equational framework for the control-flow problem. Their equations have a strong correspondence with the subset constraints of [8] and with the edges of our abstract state. In their work, a program in the source language is closure converted <ref> [1] </ref> before being analyzed. In the context of our analysis, this transformation corresponds to the restriction of binding environments to constant functions since there are in effect no free variables found within a function after closure conversion.
Reference: [2] <author> Francois Bourdoncle. </author> <title> Abstract Debugging of Higher-Order Imperative Languages. </title> <booktitle> In ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 46-55, </pages> <year> 1993. </year>
Reference-contexts: Optimizations such as unboxing, function specialization, type recovery, safety and liveness analysis, debugging <ref> [2] </ref>, and global register analysis are all important components in an optimizing compiler toolbox and programming environment. Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability.
Reference: [3] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., <ref> [3, 7, 10, 9, 11] </ref>); below, we compare three relevant approaches with the contributions presented here. Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics.
Reference: [4] <editor> William Clinger and Jonathan Rees, editors. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The flow analysis problem for higher-order programming languages such as Scheme <ref> [4] </ref> or ML [13] is concerned with tracking data and control flow in the presence of first-class (anonymous) procedures, rich data abstractions (e.g., lists, records, tuples, etc), and references.
Reference: [5] <author> Patrick Cousot. </author> <title> Semantic Foundations of Program Analysis. In Program Flow Analysis: </title> <booktitle> Theory and Foundation, </booktitle> <pages> pages 303-342. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: To appear in the Proceedings of the 22 nd Annual ACM Symposium on Principles of Programming Languages, 1995. In this paper, we present a framework based on an abstract interpretation <ref> [6, 5] </ref> of an operational semantics. Section 2 first defines an untyped, higher-order, call-by-value language extended with recursion, conditionals, and references. Section 3 defines an exact semantics that formalizes the notion of flow graph. <p> We assume that each subexpression occurrence in a program has been assigned a unique label l drawn from an infinite set Label. We indicate a labeled expression as either e l or [e] l . 3 Exact Semantics Our framework is based on an abstract interpretation <ref> [6, 5] </ref> of an operational semantics. The exact semantics of a program P is specified by a set of exact states State and a transition function !, both specific to P . <p> Note that h1's contour is h3; 0i; the 3 corresponds to the label of g's call site. The 0 corresponds to the label of the outermost application. The return value of this call (2) flows from he16; [h1,y1,z1]i to he3; [f0,g0]i. 4 Abstract Semantics The abstract semantics <ref> [5, 6] </ref> for a program P is given by a set of abstract states d State and an abstract transition function b T : d State ! d State, both specific to P . The definition of d State appears in Figure 8.
Reference: [6] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: a Unified Lattice Model for Static Analysis of Programs by Construction of Approximation of Fixpoints. </title> <booktitle> In ACM 4 th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: To appear in the Proceedings of the 22 nd Annual ACM Symposium on Principles of Programming Languages, 1995. In this paper, we present a framework based on an abstract interpretation <ref> [6, 5] </ref> of an operational semantics. Section 2 first defines an untyped, higher-order, call-by-value language extended with recursion, conditionals, and references. Section 3 defines an exact semantics that formalizes the notion of flow graph. <p> We assume that each subexpression occurrence in a program has been assigned a unique label l drawn from an infinite set Label. We indicate a labeled expression as either e l or [e] l . 3 Exact Semantics Our framework is based on an abstract interpretation <ref> [6, 5] </ref> of an operational semantics. The exact semantics of a program P is specified by a set of exact states State and a transition function !, both specific to P . <p> Note that h1's contour is h3; 0i; the 3 corresponds to the label of g's call site. The 0 corresponds to the label of the outermost application. The return value of this call (2) flows from he16; [h1,y1,z1]i to he3; [f0,g0]i. 4 Abstract Semantics The abstract semantics <ref> [5, 6] </ref> for a program P is given by a set of abstract states d State and an abstract transition function b T : d State ! d State, both specific to P . The definition of d State appears in Figure 8.
Reference: [7] <author> Alain Deutsch. </author> <title> On Determining Lifetime and Aliasing of Dynamically Allocated Data in Higher-Order Functional Specifications. </title> <booktitle> In 17 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., <ref> [3, 7, 10, 9, 11] </ref>); below, we compare three relevant approaches with the contributions presented here. Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics.
Reference: [8] <author> Nevin Heintze. </author> <title> Set-Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <year> 1994. </year>
Reference-contexts: The abstract semantics manipulates flow graphs which approximate those constructed by the exact semantics. An approximation is based on a finite partition of the nodes in the exact flow graph. Section 5 considers the coarsest possible partition and relates it to set-based analysis <ref> [8] </ref>, an analysis that is also capable of capturing control-flow information. Section 6 describes a direct implementation of the abstract semantics. We argue that the representation of the abstract state in terms of a flow graph enables such an implementation to be efficient. <p> It is based on ignoring inter-variable dependencies. We summarize the relevant technical parts of <ref> [8] </ref> in the remainder of this section. The set-based analysis of a program P is defined via a judgement of the form E ` e ; V where E is a set environment and V is a set of constraint values. The definition appears in Figure 14 2 . <p> However, <ref> [8] </ref> proves that it is possible to use regular tree grammars to represent the sets defined by set-based analysis. In this section, we show that a similar theorem applies to the states computed by the 0CFA instantiation of the abstract semantics. <p> Finally, improving the accuracy of a 0CFA instantiation of the analysis without introducing exponential complexity is problematic; our framework offers a more general notion of abstraction that permits the expression of a hierarchy of polynomial-time abstractions which reflect progressively improved accuracy. 13 Set-based analysis <ref> [8] </ref> refers to an operational semantics which ignores all inter-variable dependencies that occur in a program. Because the semantics is tightly tied to this notion, it is not clear how to express a more precise analysis within the framework. <p> Set-based analysis has a simple and intuitive characterization; devising equally simply descriptions of other instantiations of our semantics is a topic for future work. In order to develop a more precise analysis, <ref> [8] </ref> describes a polyvariant extension of the algorithm for computing set-based analysis. The extension uses information from a monovariant prepass in order to duplicate certain functions. The result of the extended algorithm can be interpreted as a monovariant analysis on a new program which is fi-equivalent to the original program. <p> For example, it can not express the polynomial-1CFA analysis (Section 7) which copies bindings from one contour to another. Stefanescu and Zhou [22] present an equational framework for the control-flow problem. Their equations have a strong correspondence with the subset constraints of <ref> [8] </ref> and with the edges of our abstract state. In their work, a program in the source language is closure converted [1] before being analyzed.
Reference: [9] <author> Paul Hudak and Jonathan Young. </author> <title> A Collecting Interpretation of Expressions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 269-290, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Section 2 first defines an untyped, higher-order, call-by-value language extended with recursion, conditionals, and references. Section 3 defines an exact semantics that formalizes the notion of flow graph. The semantics is similar to a collecting interpretation <ref> [9] </ref> insofar as a flow graph records the history of a computation; however, a flow graph also contains additional dependence information corresponding to the movement of data values. Section 4 presents a parameterized abstract semantics that is capable of expressing a range of analyses with different cost/accuracy tradeoffs. <p> Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., <ref> [3, 7, 10, 9, 11] </ref>); below, we compare three relevant approaches with the contributions presented here. Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics.
Reference: [10] <author> Williams Ludwell Harrison III. </author> <title> The Interprocedural Analysis and Automatic Parallelization of Scheme Programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: We write l:hl 1 ; : : : ; l m i to append call-site l onto hl 1 ; : : : ; l m i, yielding hl; l 1 ; : : : ; l m i. Abstractions using call-site information have been proposed elsewhere <ref> [10, 20, 18] </ref>. Our semantics, however, is not closely tied to this particular contour representation; in In Section 8, we present an alternative and discuss its implications. 3.2 Exact Transition Function The definition of ! for the functional core of the language appears in Figure 3. <p> Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., <ref> [3, 7, 10, 9, 11] </ref>); below, we compare three relevant approaches with the contributions presented here. Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics.
Reference: [11] <author> Neil Jones and Stephen Muchnick. </author> <title> Flow Analysis and Optimization of Lisp-like Structures. </title> <booktitle> In 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Many of these analyses require efficient, sophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., <ref> [3, 7, 10, 9, 11] </ref>); below, we compare three relevant approaches with the contributions presented here. Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics.
Reference: [12] <author> Richard Kelsey and Jonathan Rees. </author> <title> Scheme48 Progress Report. </title> <booktitle> Lisp and Symbolic Computation, </booktitle> <year> 1994. </year>
Reference-contexts: Assuming the code in the inner loop is O (1), the worst-case running time of the algorithm is the product of the number of edges and the number of abstract values. The current implementation is approximately 1500 lines of Scheme code. It is written in Scheme 48 <ref> [12] </ref>, and makes extensive use of the Scheme 48 module system. The implementation is parameterized in exactly the same way as the abstract semantics. To construct a complete abstract interpreter, one must specify an "abstraction" module which defines operations for manipulating abstract contours and abstract binding environments.
Reference: [13] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The flow analysis problem for higher-order programming languages such as Scheme [4] or ML <ref> [13] </ref> is concerned with tracking data and control flow in the presence of first-class (anonymous) procedures, rich data abstractions (e.g., lists, records, tuples, etc), and references.
Reference: [14] <author> Jens Palsberg and Michael Schwartzbach. </author> <title> Safety Analysis versus Type Inference. </title> <journal> Information and Computation, </journal> <note> to appear. </note>
Reference-contexts: In the context of these languages, an effective control-flow analyzer can enable a number of important optimizations such as lifetime and escape analysis [15], type recovery [19], safety analysis <ref> [14] </ref> efficient closure analysis [17], constant folding, and code hoisting. There is a spectrum of control-flow analyses that can be implemented for these languages. For example, an exact control-flow analyzer is simply an interpreter that preserves all information generated during the evaluation of a program.
Reference: [15] <author> Young Gil Park and Benjamin Goldberg. </author> <title> Escape Analysis on Lists. </title> <booktitle> In Proceedings of the SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-127, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In the context of these languages, an effective control-flow analyzer can enable a number of important optimizations such as lifetime and escape analysis <ref> [15] </ref>, type recovery [19], safety analysis [14] efficient closure analysis [17], constant folding, and code hoisting. There is a spectrum of control-flow analyses that can be implemented for these languages.
Reference: [16] <author> Amr Sabry and Matthias Felleisen. </author> <title> Is Continuation Passing Useful for Data Flow Analysis. </title> <booktitle> In ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Shivers [20] presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics. The analysis must first translate source expressions to CPS terms; this translation affects the results computed by the analysis <ref> [16] </ref>. Deriving an efficient implementation from the semantics is unintuitive and requires deviating from the semantic specification (e.g., the time-stamp approximation [21]). The choice of a denotational semantics makes it difficult in general to understand the complexity of implementations directly derived from the analysis.
Reference: [17] <author> Zhong Shao and Andrew Appel. </author> <title> Space-Efficient Closure Representations. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <year> 1994. </year>
Reference-contexts: In the context of these languages, an effective control-flow analyzer can enable a number of important optimizations such as lifetime and escape analysis [15], type recovery [19], safety analysis [14] efficient closure analysis <ref> [17] </ref>, constant folding, and code hoisting. There is a spectrum of control-flow analyses that can be implemented for these languages. For example, an exact control-flow analyzer is simply an interpreter that preserves all information generated during the evaluation of a program.
Reference: [18] <author> Micha Sharir and Amir Pneuli. </author> <title> Two Approaches to Interprocedural Dataflow Analysis, </title> <address> pages 189-235. </address> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: We write l:hl 1 ; : : : ; l m i to append call-site l onto hl 1 ; : : : ; l m i, yielding hl; l 1 ; : : : ; l m i. Abstractions using call-site information have been proposed elsewhere <ref> [10, 20, 18] </ref>. Our semantics, however, is not closely tied to this particular contour representation; in In Section 8, we present an alternative and discuss its implications. 3.2 Exact Transition Function The definition of ! for the functional core of the language appears in Figure 3.
Reference: [19] <author> Olin Shivers. </author> <title> Data-flow Analysis and Type Recovery in Scheme. </title> <booktitle> In Topics in Advanced Language Implementation. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In the context of these languages, an effective control-flow analyzer can enable a number of important optimizations such as lifetime and escape analysis [15], type recovery <ref> [19] </ref>, safety analysis [14] efficient closure analysis [17], constant folding, and code hoisting. There is a spectrum of control-flow analyses that can be implemented for these languages. For example, an exact control-flow analyzer is simply an interpreter that preserves all information generated during the evaluation of a program.
Reference: [20] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: We write l:hl 1 ; : : : ; l m i to append call-site l onto hl 1 ; : : : ; l m i, yielding hl; l 1 ; : : : ; l m i. Abstractions using call-site information have been proposed elsewhere <ref> [10, 20, 18] </ref>. Our semantics, however, is not closely tied to this particular contour representation; in In Section 8, we present an alternative and discuss its implications. 3.2 Exact Transition Function The definition of ! for the functional core of the language appears in Figure 3. <p> We believe that the ideas presented here provide exactly this capability. There have been a number of previous efforts that rigorously address the control-flow analysis problem for high-level programming languages (e.g., [3, 7, 10, 9, 11]); below, we compare three relevant approaches with the contributions presented here. Shivers <ref> [20] </ref> presents a general model for control-flow analysis in Scheme via abstract interpretation of a de-notational semantics. The analysis must first translate source expressions to CPS terms; this translation affects the results computed by the analysis [16].
Reference: [21] <author> Olin Shivers. </author> <title> The Semantics of Scheme Control-Flow Analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 190-198, </pages> <year> 1991. </year>
Reference-contexts: 0CFA and Set Based Analysis 5.1 0CFA In this section, we consider the following instantiation of the semantics: d Contour = f0g ff cn (cn) = 0 ff b (b) = x:0 d extend ( b b; x; bcn) = y:0 This version of the semantics is commonly called 0CFA <ref> [21] </ref>. With the above definitions, abstract contours and binding environments convey no information and can be removed from the abstract semantics. Figure 12 shows the simplified definition of d State. Each subexpres sion and variable of the program corresponds to a single node in the graph. <p> Under such an analysis, the graph for our sample program would associate four contours for x correspond ing to all of f's possible call histories. 11 12 By allowing d BindingEnv to contain non-constant func-tions, we derive an exponential-time analysis that is related to the 1CFA analysis described in <ref> [21] </ref>. Whereas in polynomial-time 1CFA all free variables in an abstract closure are mapped to a single call-site, the exponential-time 1CFA relaxes this constraint and associates a variable in an abstract closure with the call-site at which it was bound. <p> The analysis must first translate source expressions to CPS terms; this translation affects the results computed by the analysis [16]. Deriving an efficient implementation from the semantics is unintuitive and requires deviating from the semantic specification (e.g., the time-stamp approximation <ref> [21] </ref>). The choice of a denotational semantics makes it difficult in general to understand the complexity of implementations directly derived from the analysis.
Reference: [22] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An Equational Framework for the Flow Analysis of Higher-Order Functional Programs. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 318-327, </pages> <year> 1994. </year>
Reference-contexts: Like the exact semantics, the abstract semantics explicitly manipulates a flow graph. Intuitively, an abstract flow graph is constructed by (finitely) partitioning the nodes in the exact graph <ref> [22] </ref>. The values stored in the nodes of one partition are represented by the set of abstract values in the single abstract node corresponding to the partition. As in the exact semantics, a directed edge represents the flow of values from one node to another. <p> For example, it can not express the polynomial-1CFA analysis (Section 7) which copies bindings from one contour to another. Stefanescu and Zhou <ref> [22] </ref> present an equational framework for the control-flow problem. Their equations have a strong correspondence with the subset constraints of [8] and with the edges of our abstract state. In their work, a program in the source language is closure converted [1] before being analyzed.
Reference: [23] <author> Yuli Zhou, </author> <month> June </month> <year> 1994. </year> <type> Personal Communication. 14 </type>
Reference-contexts: A natural attempt to formulate a 1CFA style analysis in their framework gives a polynomial time approximation <ref> [23] </ref> similar to the one we describe in Section 7. It appears impossible to express other analyses in their framework, e.g., the exponential 1CFA analysis and the analysis of Section 8, which is not call string based.
References-found: 23

