URL: http://www.cs.wustl.edu/cs/playground/papers/wucs-93-29.ps
Refering-URL: http://www.cs.wustl.edu/cs/playground/papers/wucs-93-29-abstract.html
Root-URL: http://www.cs.wustl.edu
Title: The Programmers' Playground: I/O Abstraction for Heterogeneous Distributed Systems  
Author: Kenneth J. Goldman, Michael D. Anderson and Bala Swaminathan 
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Date: June 1993  revised 2/94)  
Pubnum: WUCS-93-29  (supersedes WUCS-92-32,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Ahuja, N. Carriero, and D. Gelernter. </author> <title> Linda and friends. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 26-34, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace <ref> [1, 31] </ref>, shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind
Reference: [2] <author> M.J. Bach. </author> <title> The Design of the UNIX Operating System. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: However, it is natural to ask why existing models fail to satisfy these needs. Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams <ref> [2, 29, 25] </ref>, remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p
Reference: [3] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: We are working on new algorithms for causal and logically synchronous ordering of data transmission, building on [4, 11] for example, but exploiting the connection information available in the connection manager. The concurrency control assumptions in I/O abstraction differ from those of classical concur-rency control theory <ref> [3] </ref>. In a sense, we have a "continuous read" semantics that may have interesting implications for concurrency control algorithms. We expect that useful techniques for the verification of Playground programs will be developed on the basis of commonalities between the I/O automaton model and I/O abstraction.
Reference: [4] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Research questions remain in data transmission ordering, concurrency control, and program verification. We are working on new algorithms for causal and logically synchronous ordering of data transmission, building on <ref> [4, 11] </ref> for example, but exploiting the connection information available in the connection manager. The concurrency control assumptions in I/O abstraction differ from those of classical concur-rency control theory [3]. In a sense, we have a "continuous read" semantics that may have interesting implications for concurrency control algorithms.
Reference: [5] <author> A.D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call <ref> [5, 20, 35] </ref>, shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p
Reference: [6] <author> Jerome R. Cox, Jr., Mike Gaddis, and Jonathan S. Turner. </author> <title> Project Zeus: Design of a broadband network and its application on a university campus. </title> <journal> IEEE Network, </journal> <pages> pages 20-30, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Logical connections that have arbitrary fan-out could be handled with multicast connections in the network. As a testbed for this work, we plan to use the high speed packet-switched network that is being deployed on the Washington University campus <ref> [6] </ref>. The network, called Zeus, is based on fast packet switching technology that has been developed at Washington University over the past several years and is designed to support port interfaces at up to 2.4 Gb/s.
Reference: [7] <author> William J. Dally and Andrew A. Chien. </author> <title> Object-oriented concurrent programming in cst. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Object-Based Concurrent Programming, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects <ref> [7, 8, 14] </ref>, 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind bind bind p COMMUNICATION:
Reference: [8] <author> Partha Dasgupta, Richard J. LeBlanc, Jr., and Umakishore Ramachandran. </author> <title> The Clouds distributed operating system. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 34-44, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects <ref> [7, 8, 14] </ref>, 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind bind bind p COMMUNICATION:
Reference: [9] <author> G. A. Geist and V. S. Sunderam. </author> <title> The PVM system: Supercomputer level concurrent computation on a heterogeneous network of workstations. </title> <booktitle> In Sixth Annual Distributed-Memory Computer Conference, </booktitle> <pages> pages 258-261, </pages> <year> 1991. </year>
Reference-contexts: Coordination languages can be implemented directly on top of each supported operating system and programming language, or for ease of portability, they may be implemented on top of a uniform set of system level communication constructs for heterogeneous distributed systems, such as the Mercury system [19] or PVM <ref> [9] </ref>. Communication: Having implicit communication means that the programmer need not think about when to initiate communication. Communication occurs as a byproduct of computation. In the message-passing model, communication is inherently explicit (sends and receives). For dataflow, the implicit communication category is not applicable, since dataflow modules are not autonomous.
Reference: [10] <author> David Gelernter and Nicholas Carriero. </author> <title> Coordination languages and their significance. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 97-107, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Providing end-user configuration is a central goal of our research. Most of the models do not directly support end-user configuration, but in many cases reconfiguration is possible through additional coordination languages that change binding tables dynamically (noted by "bind" in the table). Coordination languages <ref> [10] </ref> separate communication from computation in order to offer programmers a uniform communication abstraction that is independent of a particular programming language or operating system.
Reference: [11] <author> Kenneth J. Goldman. </author> <title> Highly concurrent logically synchronous multicast. </title> <journal> Distributed Computing, </journal> <volume> 6(4) </volume> <pages> 189-207, </pages> <year> 1991. </year> <booktitle> Earlier version in proceedings of the 3rd International Workshop on Distributed Algorithms, </booktitle> <address> Nice, France, </address> <note> Sprinter-Verlag LNCS 392. </note>
Reference-contexts: Research questions remain in data transmission ordering, concurrency control, and program verification. We are working on new algorithms for causal and logically synchronous ordering of data transmission, building on <ref> [4, 11] </ref> for example, but exploiting the connection information available in the connection manager. The concurrency control assumptions in I/O abstraction differ from those of classical concur-rency control theory [3]. In a sense, we have a "continuous read" semantics that may have interesting implications for concurrency control algorithms.
Reference: [12] <author> Michael M. Gorlick and Rami R. Razouk. </author> <title> Using weaves for software construction and analysis. </title> <booktitle> In Proceedings of the 13th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind bind bind p COMMUNICATION: implicit p p p p p direct p p p p p bidirectional p p p p p p p multiway p bind groups p p p p continuous streams p p p and dataflow <ref> [12, 33] </ref>. The rest of this section discusses the importance of these properties to our goals and explains the comparisons made in the table. Three high-level remarks about the table are in order.
Reference: [13] <author> Brent Hailpern and Gail E. Kaiser. </author> <title> Dynamic reconfiguration in an object-based programming language with distributed shared data. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 73-80, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: PROFIT [15] provides a mixture of data sharing and RPC communication through facets with data and procedure slots that are bound to slots in other facets during compilation. Extensions to PROFIT enable dynamic binding of slots in special cases <ref> [13] </ref>. Coordination languages can be implemented directly on top of each supported operating system and programming language, or for ease of portability, they may be implemented on top of a uniform set of system level communication constructs for heterogeneous distributed systems, such as the Mercury system [19] or PVM [9].
Reference: [14] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects <ref> [7, 8, 14] </ref>, 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind bind bind p COMMUNICATION:
Reference: [15] <author> Gail E. Kaiser and Brent Hailpern. </author> <title> An object-based programming model for shared data. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(2) </volume> <pages> 201-264, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In Polylith [27, 28], a configuration is expressed using "module interconnection constructs" that establish procedure call bindings among modules in a distributed system. CONCERT [36] provides a uniform communication abstraction by extending several procedural programming languages to support the Hermes [32] distributed process model. PROFIT <ref> [15] </ref> provides a mixture of data sharing and RPC communication through facets with data and procedure slots that are bound to slots in other facets during compilation. Extensions to PROFIT enable dynamic binding of slots in special cases [13].
Reference: [16] <author> Jeff Kramer and Jeff Magee. </author> <title> The evolving philosophers problem. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(11) </volume> <pages> 1293-1306, </pages> <month> November </month> <year> 1990. </year> <month> 23 </month>
Reference-contexts: The separation of computation from communication permits local reasoning about functional components in terms of well-defined interfaces and allows systems to be designed by assembling collections of individually verified functional components. There are many examples. Darwin <ref> [16, 23, 17] </ref> is a coordination language for managing message-passing connections 3 For example, in a Playground application configured so that some presentation entries lack logical connections, dead code elimination techniques could be used to optimize away the computation of unused values 16 between process "ports" in a dynamic system.
Reference: [17] <author> Jeff Kramer, Jeff Magee, and Morris Sloman. </author> <title> Configuring distributed systems. </title> <booktitle> In Proceedings of the 5th ACM SIGOPS European Workshop, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: The separation of computation from communication permits local reasoning about functional components in terms of well-defined interfaces and allows systems to be designed by assembling collections of individually verified functional components. There are many examples. Darwin <ref> [16, 23, 17] </ref> is a coordination language for managing message-passing connections 3 For example, in a Playground application configured so that some presentation entries lack logical connections, dead code elimination techniques could be used to optimize away the computation of unused values 16 between process "ports" in a dynamic system.
Reference: [18] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory <ref> [18] </ref>, shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p
Reference: [19] <author> B. Liskov, T. Bloom, D. Gifford, R. Scheifler, and W. Weihl. </author> <title> Communication in the Mercury system. </title> <booktitle> In Hawaii International Conference on System Sciences, </booktitle> <pages> pages 178-187, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Coordination languages can be implemented directly on top of each supported operating system and programming language, or for ease of portability, they may be implemented on top of a uniform set of system level communication constructs for heterogeneous distributed systems, such as the Mercury system <ref> [19] </ref> or PVM [9]. Communication: Having implicit communication means that the programmer need not think about when to initiate communication. Communication occurs as a byproduct of computation. In the message-passing model, communication is inherently explicit (sends and receives).
Reference: [20] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust, distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call <ref> [5, 20, 35] </ref>, shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p
Reference: [21] <author> David C. Luckham, James Vera, Doug Bryan, Larry Augustin, and Frank Belz. </author> <title> Partial order-ings of event sets and their application to prototyping concurrent, timed systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 21(3), </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: These connections define the communication pattern of 2 Rapide <ref> [21] </ref>, a rapid prototyping language for concurrent systems based on partially ordered event sets, is an example of another system that supports this distinction. 8 the system.
Reference: [22] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to Input/Output Automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3), </volume> <year> 1989. </year>
Reference-contexts: Communication is declared separately as high-level relationships among the state components of different modules. The I/O abstraction programming model has its roots in the formal I/O automaton model of Lynch and Tuttle <ref> [22] </ref>. An I/O automaton is a state machine with a signature consisting of a set of input actions and a set of locally controlled actions (divided into output actions and internal 5 actions).
Reference: [23] <author> Jeff Magee, Naranker Dulay, and Jeff Kramer. </author> <title> Structuring parallel and distributed programs. </title> <booktitle> In Proceedings of the International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 102-117, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The separation of computation from communication permits local reasoning about functional components in terms of well-defined interfaces and allows systems to be designed by assembling collections of individually verified functional components. There are many examples. Darwin <ref> [16, 23, 17] </ref> is a coordination language for managing message-passing connections 3 For example, in a Playground application configured so that some presentation entries lack logical connections, dead code elimination techniques could be used to optimize away the computation of unused values 16 between process "ports" in a dynamic system.
Reference: [24] <author> J. Postel. </author> <title> User datagram protocol. </title> <type> Technical Report RFC 768, </type> <institution> USC Information Sciences Institute, </institution> <month> August </month> <year> 1980. </year>
Reference-contexts: However, it is natural to ask why existing models fail to satisfy these needs. Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams <ref> [24] </ref>, streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p
Reference: [25] <author> J. Postel. </author> <title> Transmission control protocol: Darpa internet program protocol specification. </title> <type> Technical Report RFC 793, </type> <month> September </month> <year> 1981. </year>
Reference-contexts: However, it is natural to ask why existing models fail to satisfy these needs. Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams <ref> [2, 29, 25] </ref>, remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p
Reference: [26] <author> Dick Pountain. </author> <title> A Tutorial Introduction to Occam Programming. INMOS, </title> <publisher> Limited, </publisher> <month> March </month> <year> 1986. </year>
Reference: [27] <author> James M. Purtilo and Christine R. Hofmeister. </author> <title> Dynamic reconfiguration of distributed pro-grams. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 560-571, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Processes are expressed in a separate computation language that allows ports to be declared for interconnection within Darwin. In Polylith <ref> [27, 28] </ref>, a configuration is expressed using "module interconnection constructs" that establish procedure call bindings among modules in a distributed system. CONCERT [36] provides a uniform communication abstraction by extending several procedural programming languages to support the Hermes [32] distributed process model.
Reference: [28] <author> James M. Purtilo and Pankaj Jalote. </author> <title> An environment for prototyping distributed applications. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 588-594, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Processes are expressed in a separate computation language that allows ports to be declared for interconnection within Darwin. In Polylith <ref> [27, 28] </ref>, a configuration is expressed using "module interconnection constructs" that establish procedure call bindings among modules in a distributed system. CONCERT [36] provides a uniform communication abstraction by extending several procedural programming languages to support the Hermes [32] distributed process model.
Reference: [29] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: However, it is natural to ask why existing models fail to satisfy these needs. Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams <ref> [2, 29, 25] </ref>, remote procedure call [5, 20, 35], shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p
Reference: [30] <author> Gruia-Catalin Roman and Kenneth C. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> IEEE Computer, </journal> <volume> 22(10) </volume> <pages> 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: One declares direct high-level logical connections among the state components of individual modules, as opposed to directing communication within the control flow of the module. The use of declarative relationships between program states has been advocated for the visualization of concurrent programs <ref> [30] </ref>. Here, we advocate it for interprocess communication in general. Declaring high-level relationships among the state components of software modules makes implicit communication possible.
Reference: [31] <author> Gruia-Catalin Roman and H. Conrad Cunningham. </author> <title> A shared dataspace model of concurrency | language and programming implications. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 270-279, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call [5, 20, 35], shared memory [18], shared dataspace <ref> [1, 31] </ref>, shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind
Reference: [32] <author> R.E. Strom, D.F. Bacon, A.P. Goldberg, A. Lowry, D.M. Yellin, and S. Yemini. </author> <title> Hermes: A Language for Distributed Computing. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: In Polylith [27, 28], a configuration is expressed using "module interconnection constructs" that establish procedure call bindings among modules in a distributed system. CONCERT [36] provides a uniform communication abstraction by extending several procedural programming languages to support the Hermes <ref> [32] </ref> distributed process model. PROFIT [15] provides a mixture of data sharing and RPC communication through facets with data and procedure slots that are bound to slots in other facets during compilation. Extensions to PROFIT enable dynamic binding of slots in special cases [13].
Reference: [33] <author> P. A. Suhler, J. Biswas, K. M. Korner, and J. C. Browne. TDFL: </author> <title> A task-level dataflow language. </title> <journal> Journal of Distributed and Parallel Programming, </journal> <volume> 9 </volume> <pages> 103-115, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: bind open p CONFIGURATION: connection-oriented p p p user-configurable p bind bind bind p COMMUNICATION: implicit p p p p p direct p p p p p bidirectional p p p p p p p multiway p bind groups p p p p continuous streams p p p and dataflow <ref> [12, 33] </ref>. The rest of this section discusses the importance of these properties to our goals and explains the comparisons made in the table. Three high-level remarks about the table are in order.
Reference: [34] <author> Bala Swaminathan and Kenneth J. Goldman. </author> <title> Dynamic reconfiguration with I/O abstraction. </title> <type> Technical Report WUCS-93-21, </type> <institution> Washington University in St. Louis, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The Zeus network will allow us to implement multimedia applications that communicate using real-time digital video and audio, as well as discrete data. Natural directions for further development include writing veneers to support more program 21 ming languages, implementing process migration <ref> [34] </ref>, as well as extending the protection mech-anism to support authentication, encryption and connection-based accounting services. Research questions remain in data transmission ordering, concurrency control, and program verification.
Reference: [35] <author> J. White. </author> <title> A high-level framework for network-based resource sharing. </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <pages> pages 561-570, </pages> <year> 1976. </year>
Reference-contexts: Figure 5 summarizes the key properties of I/O abstraction that relate to our research goals and indicates their presence in the following communication models (listed here with some example implementations): datagrams [24], streams [2, 29, 25], remote procedure call <ref> [5, 20, 35] </ref>, shared memory [18], shared dataspace [1, 31], shared objects [7, 8, 14], 14 I/O message-passing shared data abstraction datagrams streams RPC memory dataspace objects dataflow PROGRAM MODULES: active (autonomous) p p p p p p p reactive p p p p p abstract environment p bind open p
Reference: [36] <author> Shaula A. Yemini, German S. Goldszmidt, Alexander D. Stoyenko, and Langdon W. Beeck. </author> <title> CONCERT: A high-level-language approach to heterogeneous distributed systems. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 162-171, </pages> <year> 1989. </year>
Reference-contexts: Processes are expressed in a separate computation language that allows ports to be declared for interconnection within Darwin. In Polylith [27, 28], a configuration is expressed using "module interconnection constructs" that establish procedure call bindings among modules in a distributed system. CONCERT <ref> [36] </ref> provides a uniform communication abstraction by extending several procedural programming languages to support the Hermes [32] distributed process model. PROFIT [15] provides a mixture of data sharing and RPC communication through facets with data and procedure slots that are bound to slots in other facets during compilation.
References-found: 36

