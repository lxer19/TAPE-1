URL: http://www.daimi.aau.dk/~andrzej/papers/LC.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: andrzej+@cs.cmu.edu  
Title: Linear Continuations  
Author: Andrzej Filinski 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We present a functional interpretation of classical linear logic based on the concept of linear continuations. Unlike their non-linear counterparts, such continuations lead to a model of control that does not inherently impose any particular evaluation strategy. Instead, such additional structure is expressed by admitting closely controlled copying and discarding of continuations. We also emphasize the importance of classicality in obtaining computationally appealing categorical models of linear logic and propose a simple "coreflective subcategory" interpretation of the modality "!". 
Abstract-found: 1
Intro-found: 1
Reference: [Abr90] <author> Samson Abramsky. </author> <title> Computational interpretations of linear logic. </title> <institution> Imperial College Research Report DOC 90/20, Department of Computing, Imperial College of Science, Technology and Medicine, </institution> <address> London, UK, </address> <year> 1990. </year>
Reference-contexts: Both categorical and more pragmatic computational interpretations of linear logic as a functional program 8 ming language, e.g., [Hol88] have focused on the intu--itionistic subset, with the understanding that the classical version was intimately linked with parallelism and communication; more recent work <ref> [Abr90] </ref> reinforces this dichotomy. However, while its potential for parallel evaluation is indeed exciting, it seems that classical LL can also give us a better understanding of control flow in traditional, sequential languages than either in-tuitionistic or intuitionistic linear logic.
Reference: [AJ89] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, Texas, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: This suggests that continuation-passing style is much more than an ad-hoc syntactic restriction on non-linear terms; rather, it is in a sense the "real meaning" of CBV 7 terms, and thus a very natural intermediate represen-tation for compilation <ref> [Ste78, AJ89] </ref>, semantic analysis [Shi91], or partial evaluation [CD91]. The linear framework can easily encompass trivial functions (i.e., functions that always terminate and do not escape) as values of type :(A B ? ). Also, CBV continuations are necessarily strict by virtue of their types.
Reference: [Bar79] <author> Michael Barr. </author> <title> *-Autonomous Categories. </title> <booktitle> Number 752 in Lecture Notes in Mathematics. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: To this end, we will consider the very natural categorical characterization of classicality in terms of dualizing objects, due to Marti-Oliet and Meseguer [MOM90, MOM91]. Despite its apparent simplicity, it is actually slightly stronger than the interpretation based on *-autonomous categories <ref> [Bar79] </ref> outlined by Seely [See89]. For any object C in an SMCC, there exists a natural (in A) transformation A ! (A ( C) ( C; we can think of it as the function a A : k A (C : k a.
Reference: [CD91] <author> Charles Consel and Olivier Danvy. </author> <title> For a better support of static data flow. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming and Computer Architecture, number 523 in Lecture Notes in Computer Science, </booktitle> <pages> pages 496-519, </pages> <address> Cambridge, Massachusetts, </address> <month> August </month> <year> 1991. </year> <month> 9 </month>
Reference-contexts: This suggests that continuation-passing style is much more than an ad-hoc syntactic restriction on non-linear terms; rather, it is in a sense the "real meaning" of CBV 7 terms, and thus a very natural intermediate represen-tation for compilation [Ste78, AJ89], semantic analysis [Shi91], or partial evaluation <ref> [CD91] </ref>. The linear framework can easily encompass trivial functions (i.e., functions that always terminate and do not escape) as values of type :(A B ? ). Also, CBV continuations are necessarily strict by virtue of their types.
Reference: [DF90] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstract--ing control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: By changing the codomain of continuations from ? to an information-carrying type, it seems possible to represent a wide variety of additional computational structure, such as side effects and backtracking, in a way complementary to the computational mon-ads of [Mog89]. Some preliminary results in this direction are reported in <ref> [DF90] </ref>, but the topic is far from explored. Acknowledgments I wish to thank Olivier Danvy, Timothy Griffin, Robert Harper, Narciso Marti-Oliet, Chetan Murthy, Benjamin Pierce, and John Reynolds for their insightful comments and helpful suggestions on various drafts of this paper.
Reference: [DHM91] <author> Bruce F. Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Modulo syntactic differences, languages of this kind include (the functional subsets of) Scheme [RC86] and recent versions of Standard ML of New Jersey <ref> [DHM91] </ref>.
Reference: [FFKD87] <author> Matthias Felleisen, Daniel P. Friedman, Eu-gene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: us that "when a continuation k is applied to D E (i.e., when D E is evaluated in a context represented by k), that continuation will be captured by D and passed to E as an argument." Seen in this way, D closely resembles Scheme's call/cc [RC86], the C-operator of <ref> [FFKD87] </ref>, or the version of C considered in [Gri90] (where the idea of double-negation elimination as a control operator was first presented, but in a non-linear setting). <p> However, while its potential for parallel evaluation is indeed exciting, it seems that classical LL can also give us a better understanding of control flow in traditional, sequential languages than either in-tuitionistic or intuitionistic linear logic. From another direction, syntactic theories such as the "continuation calculi" of <ref> [FFKD87] </ref> have been proposed as a tool for formal reasoning about call/cc-like control operators. The striking connection between such operators and classical logic was later pointed out by Griffin [Gri90], and very convincingly related to Friedman's A-translation and CPS transformations by Murthy [Mur91].
Reference: [Fil89a] <author> Andrzej Filinski. </author> <title> Declarative continuations: An investigation of duality in programming language semantics. </title> <editor> In David H. Pitt et al., editors, </editor> <booktitle> Category Theory and Computer Science, number 389 in Lecture Notes in Computer Science, </booktitle> <pages> pages 224-249, </pages> <address> Manchester, UK, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: We will consider call-by-value (CBV) and call-by-name (CBN) evaluation of a simple language with product, coprod-uct, exponential and "co-exponential" types (the last-mentioned seem to arise naturally in categorical models of first-class continuations <ref> [Fil89a] </ref>). <p> Finally, some work independently motivated by the symmetry between values and continuations is reported in <ref> [Fil89a, Fil89b] </ref>. In retrospect, the kind of duality considered there mirrors the CBV/CBN negations of section 4, rather than the underlying "pure" linear negation, leading to a somewhat ad-hoc axiomatization.
Reference: [Fil89b] <author> Andrzej Filinski. </author> <title> Declarative continuations and categorical duality. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of Copenhagen, </institution> <month> August </month> <year> 1989. </year> <type> DIKU Report 89/11. </type>
Reference-contexts: Let us first consider the "pure CBN" language <ref> [Fil89b] </ref>, obtained as the exact mirror image of CBV. Here, an expression E : B with free variable x : A is represented by a linear morphism ![[A]] ! [[B]] (or ![[A]] [[B]] ? ! ?). <p> Finally, some work independently motivated by the symmetry between values and continuations is reported in <ref> [Fil89a, Fil89b] </ref>. In retrospect, the kind of duality considered there mirrors the CBV/CBN negations of section 4, rather than the underlying "pure" linear negation, leading to a somewhat ad-hoc axiomatization.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction In recent years, there has been considerable interest in applications of Girard's Linear Logic (LL) <ref> [Gir87] </ref> to programming language design and implementation. <p> We thus really need the additional restrictions imposed by linearity to obtain non-degenerate categories with dualizing objects. For example, the category Cohl of coherent spaces and linear maps <ref> [Gir87] </ref> (which has independent semantic interest) is actually a classical SMCC [See89, MOM90]. <p> In particular, we have [[bool]] = ?bool = ?(1 1 ) = ?(!&gt; !&gt;) = [[1 q 1]] so booleans are definable as expected. 5 Comparison with Related Work Naturally, this paper builds on Girard's fundamental work on Linear Logic <ref> [Gir87] </ref>. The question/answer symmetry mentioned there is interpreted here as a duality between values and continuations, seen as the two extreme cases of linear functions. The interpretation of modality-free classical LL as a linear category [See89, MOM90] appears to be commonly accepted.
Reference: [GL87] <author> Jean-Yves Girard and Yves Lafont. </author> <title> Linear logic and lazy computation. </title> <booktitle> In Proceedings of TAP-SOFT '87, number 250 in Lecture Notes in Computer Science, </booktitle> <pages> pages 52-66, </pages> <address> Pisa, Italy, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Except for the ? (which accounts for possible non-termination), this is identical to the usual encoding of intuitionistic "or" in LL <ref> [GL87] </ref>. In particular, we have [[bool]] = ?bool = ?(1 1 ) = ?(!&gt; !&gt;) = [[1 q 1]] so booleans are definable as expected. 5 Comparison with Related Work Naturally, this paper builds on Girard's fundamental work on Linear Logic [Gir87]. <p> The interpretation of modality-free classical LL as a linear category [See89, MOM90] appears to be commonly accepted. However, the proposed categorical view of "!"-types as cofree coalgebras <ref> [GL87] </ref> seems oriented towards the intuitionistic subset of LL only. The additional structure of classical LL, notably the availability of "?"-types for representing terms that do not necessarily evaluate to proper values should allow for conceptually, as well as computationally, simpler models.
Reference: [Gri90] <author> Timothy G. Griffin. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 47-58, </pages> <address> San Francisco, Cal-ifornia, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: to D E (i.e., when D E is evaluated in a context represented by k), that continuation will be captured by D and passed to E as an argument." Seen in this way, D closely resembles Scheme's call/cc [RC86], the C-operator of [FFKD87], or the version of C considered in <ref> [Gri90] </ref> (where the idea of double-negation elimination as a control operator was first presented, but in a non-linear setting). <p> From another direction, syntactic theories such as the "continuation calculi" of [FFKD87] have been proposed as a tool for formal reasoning about call/cc-like control operators. The striking connection between such operators and classical logic was later pointed out by Griffin <ref> [Gri90] </ref>, and very convincingly related to Friedman's A-translation and CPS transformations by Murthy [Mur91]. There is hope that an analysis in terms of (classical) linearity will also make it possible to derive such results semantically, supplementing the current understanding of CPS-translation as an essentially syntactic concept.
Reference: [Hol88] <author> Soren Holmstrom. </author> <title> A linear functional language. </title> <editor> In Thomas Johnsson, Simon Peyton Jones, and Kent Karlsson, editors, </editor> <booktitle> Proceedings of the Workshop on Implementation of Lazy Functional Languages, </booktitle> <pages> pages 13-32, </pages> <address> Aspenas, Sweden, </address> <month> September </month> <year> 1988. </year> <note> Chalmers University PMG Report 53. </note>
Reference-contexts: A striking consequence of this "resource-consciousness" is that the otherwise problematic negation can be made an involution, i.e., "not not A" and A can be identified, without loss of constructivity. The advantages of making linearity explicit in functional languages have been convincingly argued before <ref> [Laf88a, Hol88, Wad90] </ref>. The primary benefits cited are that a linear framework can naturally express single-threadedness (hence transparent destructive updates), and reduce or even eliminate the need for garbage collection. This stands in contrast to deducing such information after the fact by program analysis techniques such as abstract interpretation. <p> Both categorical and more pragmatic computational interpretations of linear logic as a functional program 8 ming language, e.g., <ref> [Hol88] </ref> have focused on the intu--itionistic subset, with the understanding that the classical version was intimately linked with parallelism and communication; more recent work [Abr90] reinforces this dichotomy.
Reference: [HP90] <author> Hagen Huwig and Axel Poigne. </author> <title> A note on inconsistencies caused by fixpoints in a cartesian closed category. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 101-112, </pages> <year> 1990. </year>
Reference-contexts: However, the behavior of A + B is not what we would expect it is "too lazy." In fact, there is no way to add proper coprod-ucts to a language where every function has a fixpoint <ref> [HP90] </ref>, but just as for lazy products in CBV, we can define the more conventional eager coproducts A q B := [0 A] + [0 B] with the interpretation [[A q B]] = ?![[A]] ?![[B]] = ?(![[A]] ![[B]]) which make it possible to evaluate a coproduct-typed datum until its injection tag
Reference: [Laf88a] <author> Yves Lafont. </author> <title> The linear abstract machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 157-180, </pages> <year> 1988. </year>
Reference-contexts: A striking consequence of this "resource-consciousness" is that the otherwise problematic negation can be made an involution, i.e., "not not A" and A can be identified, without loss of constructivity. The advantages of making linearity explicit in functional languages have been convincingly argued before <ref> [Laf88a, Hol88, Wad90] </ref>. The primary benefits cited are that a linear framework can naturally express single-threadedness (hence transparent destructive updates), and reduce or even eliminate the need for garbage collection. This stands in contrast to deducing such information after the fact by program analysis techniques such as abstract interpretation. <p> The crucial property of such a linear -calculus is that data must be used exactly once, leading naturally to variable patterns in - abstractions <ref> [Laf88a] </ref>. <p> For general computation, we need a way to express non-linear uses of data, such as Girard's modal operators "!" and "?". Unfortunately, their semantic 4 properties are not nearly as well understood as the pure linear fragment; in particular, the proposed categorical interpretation of "!" <ref> [Laf88a] </ref> is often considered somewhat controversial (e.g., [See89]). One reason for these problems may be that in the in-tuitionistic fragment of LL, "!" is forced to perform two rather unrelated functions: expressing copyabil-ity/discardability of data and suspending potentially non-terminating computations. <p> To formalize this distinction, we must first make precise what it means to copy or discard a value. As usual, category theory provides a tool in the form of comonoids . The details can be found in [Mac71] or <ref> [Laf88a] </ref>; here, we will just state the key concepts: Definition 4 A (co-)commutative comonoid in a symmetric monoidal category C consists of an object A and two morphisms d : A ! 1 and c : A ! A A satisfying the following equations (written out in applicative notation with a
Reference: [Laf88b] <author> Yves Lafont. </author> <title> Logiques, Categories et Machines. </title> <type> PhD thesis, </type> <institution> Universite de Paris VII, Paris, France, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: Thus, evaluation of a ?A-typed term may never return, or it may return multiple times to the same point with different values. At least the non-returning aspect is common to all programming languages with the possibility of infinite loops, even "intuitionistic linear" ones like Lafont's LIVE <ref> [Laf88b] </ref>: a linear function which "loops forever" has in a sense broken its promise to apply the return continuation it is passed. We can say that such functions are not linear in their output, even if their input is only used once.
Reference: [LS86] <author> Joachim Lambek and Philip J. Scott. </author> <title> Introduction to Higher Order Categorical Logic, </title> <booktitle> volume 7 of Cambridge Studies in Advanced Mathematics. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: The reader unfamiliar with category theory should probably consult the appendix for an introduction to the terminology used. 2.1 Tensor products and linear expo nentials The usual categorical presentations of typed -calculi build on the concept of cartesian closure <ref> [LS86] </ref>, often supplemented with rich additional structure to express refinements like polymorphism or dependent types. But at the very core of all such systems remains the in-tuitionistic principle that all available data at a given point can be used any number of times, and possibly not at all. <p> Unfortunately, it is fairly easy to show (e.g., <ref> [LS86, p. 67] </ref>; the observation is usually credited to Joyal) that a CCC cannot have a dualizing object unless it is a preorder, i.e., contains at most one morphism between any two objects. We thus really need the additional restrictions imposed by linearity to obtain non-degenerate categories with dualizing objects.
Reference: [Mac71] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: with a distinguished object 1 ("unit"), a bifunctor : C fi C ! C ("tensor product"), and natural isomorphisms delr A : A 1 ! A assl A;B;C : A (B C) ! (A B) C exch A;B : A B ! B A satisfying the Mac Lane-Kelly coherence conditions <ref> [Mac71] </ref>. (The coherence conditions formalize the expected relations among the "structural isomorphisms" above. <p> To formalize this distinction, we must first make precise what it means to copy or discard a value. As usual, category theory provides a tool in the form of comonoids . The details can be found in <ref> [Mac71] </ref> or [Laf88a]; here, we will just state the key concepts: Definition 4 A (co-)commutative comonoid in a symmetric monoidal category C consists of an object A and two morphisms d : A ! 1 and c : A ! A A satisfying the following equations (written out in applicative notation <p> ; a 2 )=c (a) in = a let (a 21 ; a 22 )=c (a 2 ) in = let (a 11 ; a 12 )=c (a 1 ) in let (a 1 ; a 2 )=c (a) in = (a 1 ; a 2 ) These equations ensure <ref> [Mac71] </ref> that for a given co-monoid (A,d,c), there exists a unique "structural mor-phism" (i.e., one built out of c's, d's, and the isomor phisms of definition 1) A ! A n (= A n A) for every n 0.
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Pacific Grove, California, </address> <month> June </month> <year> 1989. </year> <note> IEEE. </note>
Reference-contexts: By changing the codomain of continuations from ? to an information-carrying type, it seems possible to represent a wide variety of additional computational structure, such as side effects and backtracking, in a way complementary to the computational mon-ads of <ref> [Mog89] </ref>. Some preliminary results in this direction are reported in [DF90], but the topic is far from explored. Acknowledgments I wish to thank Olivier Danvy, Timothy Griffin, Robert Harper, Narciso Marti-Oliet, Chetan Murthy, Benjamin Pierce, and John Reynolds for their insightful comments and helpful suggestions on various drafts of this paper.
Reference: [MOM90] <author> Narciso Marti-Oliet and Jose Meseguer. </author> <title> Duality in closed and linear categories. </title> <type> Technical Report SRI-CSL-90-01, </type> <institution> SRI International, </institution> <address> Menlo Park, California, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: To this end, we will consider the very natural categorical characterization of classicality in terms of dualizing objects, due to Marti-Oliet and Meseguer <ref> [MOM90, MOM91] </ref>. Despite its apparent simplicity, it is actually slightly stronger than the interpretation based on *-autonomous categories [Bar79] outlined by Seely [See89]. <p> We thus really need the additional restrictions imposed by linearity to obtain non-degenerate categories with dualizing objects. For example, the category Cohl of coherent spaces and linear maps [Gir87] (which has independent semantic interest) is actually a classical SMCC <ref> [See89, MOM90] </ref>. <p> The question/answer symmetry mentioned there is interpreted here as a duality between values and continuations, seen as the two extreme cases of linear functions. The interpretation of modality-free classical LL as a linear category <ref> [See89, MOM90] </ref> appears to be commonly accepted. However, the proposed categorical view of "!"-types as cofree coalgebras [GL87] seems oriented towards the intuitionistic subset of LL only.
Reference: [MOM91] <author> Narciso Marti-Oliet and Jose Meseguer. </author> <title> From Petri nets to linear logic. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1, </volume> <year> 1991. </year>
Reference-contexts: To this end, we will consider the very natural categorical characterization of classicality in terms of dualizing objects, due to Marti-Oliet and Meseguer <ref> [MOM90, MOM91] </ref>. Despite its apparent simplicity, it is actually slightly stronger than the interpretation based on *-autonomous categories [Bar79] outlined by Seely [See89].
Reference: [Mur91] <author> Chetan R. Murthy. </author> <title> An evaluation semantics for classical proofs. </title> <booktitle> In Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: The striking connection between such operators and classical logic was later pointed out by Griffin [Gri90], and very convincingly related to Friedman's A-translation and CPS transformations by Murthy <ref> [Mur91] </ref>. There is hope that an analysis in terms of (classical) linearity will also make it possible to derive such results semantically, supplementing the current understanding of CPS-translation as an essentially syntactic concept.
Reference: [Nis91] <author> Shin-ya Nishizaki. </author> <title> Programs with continuations and linear logic. </title> <booktitle> In International Conference on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 513-531, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: There is hope that an analysis in terms of (classical) linearity will also make it possible to derive such results semantically, supplementing the current understanding of CPS-translation as an essentially syntactic concept. A recent paper <ref> [Nis91] </ref> notes a connection between classical LL and Scheme-like languages, and presents a somewhat involved translation from typed -terms with call=cc to Girard's "proof nets" for LL.
Reference: [Plo75] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: This means that a CBV term can have multiple free variables, each of which it may use any number of times, as usual. The actual translation on CBV -terms is essentially a typed and uncurried version the well-known continuation-passing transform (e.g., <ref> [Plo75] </ref>), but the key observation here is that the resulting terms are linear! In particular, we can simply use fl -s in the translation to express multiple uses of data in the original terms because all the values involved are cartesian (?, representing the type of final answers, is not cartesian
Reference: [RC86] <editor> Jonathan Rees and William Clinger (editors). </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> Decem-ber </month> <year> 1986. </year>
Reference-contexts: = E k, tells us that "when a continuation k is applied to D E (i.e., when D E is evaluated in a context represented by k), that continuation will be captured by D and passed to E as an argument." Seen in this way, D closely resembles Scheme's call/cc <ref> [RC86] </ref>, the C-operator of [FFKD87], or the version of C considered in [Gri90] (where the idea of double-negation elimination as a control operator was first presented, but in a non-linear setting). <p> Modulo syntactic differences, languages of this kind include (the functional subsets of) Scheme <ref> [RC86] </ref> and recent versions of Standard ML of New Jersey [DHM91].
Reference: [Rey83] <author> John C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 513-523. </pages> <publisher> IFIP, </publisher> <year> 1983. </year>
Reference-contexts: The striking similarity between the isomorphisms (A ( ?) ( ? = A in linear categories and 8C: (A ! C) ! C = A in parametric models of the second-order polymorphic -calculus <ref> [Rey83] </ref> seems to be more than a coincidence; a formal connection would be an important result. * The general CPS transform.
Reference: [See89] <author> Robert A. G. Seely. </author> <title> Linear logic, </title> <editor> *-autonomous categories and cofree coalgebras. In John W. Gray and Andre Scedrov, editors, </editor> <booktitle> Proceedings of the AMS-IMS-SIAM Joint Conference on Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics, </booktitle> <pages> pages 371-382, </pages> <address> Boulder, Colorado, </address> <year> 1989. </year> <journal> American Mathematical Society. </journal> <volume> 10 </volume>
Reference-contexts: To this end, we will consider the very natural categorical characterization of classicality in terms of dualizing objects, due to Marti-Oliet and Meseguer [MOM90, MOM91]. Despite its apparent simplicity, it is actually slightly stronger than the interpretation based on *-autonomous categories [Bar79] outlined by Seely <ref> [See89] </ref>. For any object C in an SMCC, there exists a natural (in A) transformation A ! (A ( C) ( C; we can think of it as the function a A : k A (C : k a. <p> We thus really need the additional restrictions imposed by linearity to obtain non-degenerate categories with dualizing objects. For example, the category Cohl of coherent spaces and linear maps [Gir87] (which has independent semantic interest) is actually a classical SMCC <ref> [See89, MOM90] </ref>. <p> Unfortunately, their semantic 4 properties are not nearly as well understood as the pure linear fragment; in particular, the proposed categorical interpretation of "!" [Laf88a] is often considered somewhat controversial (e.g., <ref> [See89] </ref>). One reason for these problems may be that in the in-tuitionistic fragment of LL, "!" is forced to perform two rather unrelated functions: expressing copyabil-ity/discardability of data and suspending potentially non-terminating computations. <p> The question/answer symmetry mentioned there is interpreted here as a duality between values and continuations, seen as the two extreme cases of linear functions. The interpretation of modality-free classical LL as a linear category <ref> [See89, MOM90] </ref> appears to be commonly accepted. However, the proposed categorical view of "!"-types as cofree coalgebras [GL87] seems oriented towards the intuitionistic subset of LL only.
Reference: [Shi91] <author> Olin Shivers. </author> <title> The semantics of Scheme control--flow analysis. </title> <booktitle> In Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 190-198, </pages> <address> New Haven, Con-necticut, </address> <month> June </month> <year> 1991. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No. </volume> <pages> 9. </pages>
Reference-contexts: This suggests that continuation-passing style is much more than an ad-hoc syntactic restriction on non-linear terms; rather, it is in a sense the "real meaning" of CBV 7 terms, and thus a very natural intermediate represen-tation for compilation [Ste78, AJ89], semantic analysis <ref> [Shi91] </ref>, or partial evaluation [CD91]. The linear framework can easily encompass trivial functions (i.e., functions that always terminate and do not escape) as values of type :(A B ? ). Also, CBV continuations are necessarily strict by virtue of their types.
Reference: [Ste78] <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> Artficial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: This suggests that continuation-passing style is much more than an ad-hoc syntactic restriction on non-linear terms; rather, it is in a sense the "real meaning" of CBV 7 terms, and thus a very natural intermediate represen-tation for compilation <ref> [Ste78, AJ89] </ref>, semantic analysis [Shi91], or partial evaluation [CD91]. The linear framework can easily encompass trivial functions (i.e., functions that always terminate and do not escape) as values of type :(A B ? ). Also, CBV continuations are necessarily strict by virtue of their types.
Reference: [Wad90] <editor> Philip Wadler. </editor> <booktitle> Linear types can change the world! In Proceedings of IFIP TC2 Working Conference on Programming Concepts and Methods, </booktitle> <pages> pages 546-566, </pages> <address> Sea Galilee, Israel, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: A striking consequence of this "resource-consciousness" is that the otherwise problematic negation can be made an involution, i.e., "not not A" and A can be identified, without loss of constructivity. The advantages of making linearity explicit in functional languages have been convincingly argued before <ref> [Laf88a, Hol88, Wad90] </ref>. The primary benefits cited are that a linear framework can naturally express single-threadedness (hence transparent destructive updates), and reduce or even eliminate the need for garbage collection. This stands in contrast to deducing such information after the fact by program analysis techniques such as abstract interpretation.
Reference: [Wan80] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <address> Stanford, California, </address> <month> August </month> <year> 1980. </year>
Reference-contexts: This property may even provide a link between "true" parallelism and continuation-based multiprogramming <ref> [Wan80] </ref>. In the latter, a call/cc-like operator is essentially used to implement a coroutine facility, where captured continuations are never applied twice. Each "thread of control" makes independent progress without backtracking, and first-class continuations are used only to multiplex them onto a single processor.
References-found: 31

