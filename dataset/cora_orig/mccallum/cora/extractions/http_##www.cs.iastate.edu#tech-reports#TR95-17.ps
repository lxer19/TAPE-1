URL: http://www.cs.iastate.edu/tech-reports/TR95-17.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Evaluating Larch/C++ as a Specification Language: A Case Study Using the Microsoft Foundation Class Library  
Author: David M. Egle 
Keyword: Larch/C++, interface specification, MFC, class library, software engineering, object-oriented programming.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: TR #95-17 July 1995  This work was supported in part by NSF Grant number CCR-9503168.  
Abstract: 1994 CR Categories: D.1.5 [Programming Techniques] Object-oriented Programming; D.2.2 [Software Engineering] Tools and Techniques | modules and interfaces; D.3.2 [Programming Languages] Language Classifications | object-oriented languages; D.3.3 [Programming Languages] Language Constructs | Abstract data types, modules, packages; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | logics of programs, pre- and post-conditions, specification techniques; c fl David M. Egle, 1995. Copies may be made for any educational purpose whatever, provided this copyright notice appears on the copy.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A quick overview of Larch/C++. </title> <type> Technical Report 93-18a, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> June </month> <year> 1994. </year> <journal> Appears in the Journal of Object-Oriented Programming, </journal> <volume> 7(6) </volume> <pages> 39-49, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: This aspect of Larch/C++ builds on the work of C.A.R. Hoare on axiomatic semantics and correctness of data representations [6]. Larch/C++ is not intended to completely replace informal English documentation, but adds to it by providing clarity and conciseness. For more on the details of Larch/C++, see <ref> [1, 7] </ref>. 3.2 Anatomy of a Function Specification In Larch/C++, the behavior of a function is specified using a precondition and postcondition. Syntactically, the interface of a function specification is the same as that of the corresponding C++ function definition. <p> However, the size is actually 5. The array elements array <ref> [1] </ref>, array [2], and array [3] have all been assigned NULL automatically. However, there is no mention of this assignment in the informal specification of InsertAt. A similar situation can occur using SetAtGrow. In this case, the user should be forewarned that these assignments occur automatically. <p> In the future, Larch/C++ will be integrated into C++ specification and programming in the following way. From the interface specification module (.lcc), Larch/C++ will generate a C++ header file for the class (.h) and part of the implementation file (.C) <ref> [1] </ref>. The actual header file for the class may need additional information added to it, but most of it can be obtained by including the .lh file.
Reference: [2] <author> Microsoft Corporation. </author> <title> Class Libraries Reference. </title> <publisher> Microsoft Corporation, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: This group of classes can be used for storing sets and sequences of homogeneous objects such as CString and CObject. However, a collection of pointers to CObjects could be heterogeneous due to subtyping. Included with the class software is the Microsoft Class Libraries Reference <ref> [2] </ref>. By specifying these classes more formally than the reference manual, one can compare Larch/C++ to existing documentation and evaluate the advantages and disadvantages of the specification language. <p> className (ck) || A"," ||baseClassName (ck) || A")",ck)) /" not (usesMacro (A"IMPLEMENT_SERIAL (" || className (ck) || A"," || baseClassName (ck) || A"," || wSchemaNum (ck) || A")",ck)); ensures informally "diagnostic information of the object is dumped" "to dc"; 15 The functions new and delete provided by the class CObject <ref> [2, p. 475] </ref> are designed to reclaim memory storage space, a concept not built-in to in Larch/C++. <p> Thus, a new list object was modeled abstractly as a tuple created by the MSArray trait function create. 5 Analysis of the Specification Throughout the specification process, many ambiguities and inconsistencies were discovered in the documentation for the MFC Library <ref> [2] </ref>. This section reveals some of them. 5.1 Ambiguities in MFC Documentation Revealed The main advantage of formal specification is the elimination of ambiguities that would otherwise be present in informal specifications. Consider the CO-bArray class member functions InsertAt [2, pp. 456-457] and SetAtGrow [2, pp. 460-461]. <p> This section reveals some of them. 5.1 Ambiguities in MFC Documentation Revealed The main advantage of formal specification is the elimination of ambiguities that would otherwise be present in informal specifications. Consider the CO-bArray class member functions InsertAt <ref> [2, pp. 456-457] </ref> and SetAtGrow [2, pp. 460-461]. Both of these functions allow the user to assign a pointer 17 to a CObject to a given index of the array. From the documentation, the parameter nIndex is allowed to be greater than the current upper bound of the array. <p> This section reveals some of them. 5.1 Ambiguities in MFC Documentation Revealed The main advantage of formal specification is the elimination of ambiguities that would otherwise be present in informal specifications. Consider the CO-bArray class member functions InsertAt [2, pp. 456-457] and SetAtGrow <ref> [2, pp. 460-461] </ref>. Both of these functions allow the user to assign a pointer 17 to a CObject to a given index of the array. From the documentation, the parameter nIndex is allowed to be greater than the current upper bound of the array. <p> However, the size is actually 5. The array elements array [1], array <ref> [2] </ref>, and array [3] have all been assigned NULL automatically. However, there is no mention of this assignment in the informal specification of InsertAt. A similar situation can occur using SetAtGrow. In this case, the user should be forewarned that these assignments occur automatically. <p> All that is required now is the examination of the trait function insert at (see Appendix A, MSArray). Note that the trait function insert at actually "builds" up the new array value from the old array value. The documentation of CObList functions InsertBefore and InsertAfter <ref> [2, pp. 491-492] </ref> also falls victim to this type of ambiguity. Below is the interface for the function InsertBefore, which indicates there are two parameters to the function: position and newElement. (The function InsertAfter is set up similarly). <p> However, for the function InsertAt, nIndex is merely supposed to be an integer index that may be greater than GetUpperBound () <ref> [2, p. 457] </ref>. <p> than 0? Since this parameter has been explained for other functions, is the absence of such an explanation supposed to mean any value of nIndex is allowed? In fact, for the documentation of the [] operator, all that is mentioned is that the subscript nIndex not be "out of bounds" <ref> [2, p. 457] </ref>, or the "Debug" version of the library "asserts". A more precise way to state this would be to clearly write the constraints on nIndex. A similar parameter clarification should be added to the documentation of the Add function of CObArray [2, pp. 453]. <p> A more precise way to state this would be to clearly write the constraints on nIndex. A similar parameter clarification should be added to the documentation of the Add function of CObArray <ref> [2, pp. 453] </ref>. Since no restriction on the value of newElement is made, and since a value of NULL for newElement is allowed for all other assignment operations, the user might expect to be able to invoke the function Add with such an assignment.
Reference: [3] <author> Ralph E. Johnson & Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 29-30, 35, </pages> <year> 1988. </year>
Reference-contexts: A study conducted by the National Bureau of Standards estimated that 60 to 85 percent of the total cost of software is due to maintenance <ref> [3] </ref>. This is because mistakes not found during operational testing 1 Microsoft is a registered trademark of Microsoft Corporation 4 may need to be fixed at the customer's site, which means every customer becomes a special consideration. Developers need to build application software quickly and efficiently. <p> However, the size is actually 5. The array elements array [1], array [2], and array <ref> [3] </ref> have all been assigned NULL automatically. However, there is no mention of this assignment in the informal specification of InsertAt. A similar situation can occur using SetAtGrow. In this case, the user should be forewarned that these assignments occur automatically.
Reference: [4] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(5), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: The Larch approach to specification technique is two-tiered, with each specification having a component on each tier. The two tiers are the the Larch Shared Language (LSL), responsible for defining the underlying abstractions, and a Larch interface language, used to specify the state transformations <ref> [4] </ref>. Two examples of Larch interface languages are Larch/CLU, which specifies CLU program modules, and Larch/C++, which specifies C++ program modules. An interface specification language, by definition, is designed to specify the behavior of specific constructs in the programming language.
Reference: [5] <author> Michael D. Haverdink. </author> <title> Formal design of SPECS-C++: A model-based specification language for C++ classes. </title> <type> Master's thesis, </type> <institution> Iowa State University, </institution> <year> 1994. </year>
Reference-contexts: Unlike SPECS-C++, another C++ class specification technique which declares abstract functions within a class specification <ref> [5] </ref>, trait functions are declared in a module other than the actual specification interface module. This enforces the two-tiered approach to Larch style specification languages [10].
Reference: [6] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: Larch/C++ specifies C++ classes by describing the abstract values of instances of the class and the behavior of the operations of the class when invoked. This aspect of Larch/C++ builds on the work of C.A.R. Hoare on axiomatic semantics and correctness of data representations <ref> [6] </ref>. Larch/C++ is not intended to completely replace informal English documentation, but adds to it by providing clarity and conciseness. For more on the details of Larch/C++, see [1, 7]. 3.2 Anatomy of a Function Specification In Larch/C++, the behavior of a function is specified using a precondition and postcondition.
Reference: [7] <author> Gary T. Leavens and Yoonsik Cheon. </author> <note> Larch/C++ Reference Manual. Available by anonymous ftp from ftp.cs.iastate.edu., </note> <year> 1995. </year>
Reference-contexts: This aspect of Larch/C++ builds on the work of C.A.R. Hoare on axiomatic semantics and correctness of data representations [6]. Larch/C++ is not intended to completely replace informal English documentation, but adds to it by providing clarity and conciseness. For more on the details of Larch/C++, see <ref> [1, 7] </ref>. 3.2 Anatomy of a Function Specification In Larch/C++, the behavior of a function is specified using a precondition and postcondition. Syntactically, the interface of a function specification is the same as that of the corresponding C++ function definition. <p> The abstract values of objects of the class (cx and cy) are given by the trait functions defined in CSizeTrait. Trait functions describe the behavior of functions defined in the interface module by precisely describing the abstract values <ref> [7, p. 3] </ref>. The connection is made by the uses clause. (A class can use more than one trait). The simulates clause states how the abstract values of a class, such as CSize, can be interpreted as abstract values of the derived class, in this case tagSize. <p> The mathematical abstractions are only used in writing assertions, and are not to be considered executable functions that can be used in programs <ref> [7] </ref>. Below is the trait defined for use with the CSize interface specification. <p> Note that in Larch/C++, the abstract value of a structure declared in the C++ is a fixed-length tuple with corresponding fields and sorts. For each struct declared in C++, the trait defining its abstract model is implicitly used in any interface specification module where the declaration is made <ref> [7, pp. 175-177] </ref>. Since the CSize struct actually inherits from tagSize, the tagSize trait is included in the CSize trait. <p> Since the CSize struct actually inherits from tagSize, the tagSize trait is included in the CSize trait. The trait function totagSize is used to map a CSize value to a tagSize value (see <ref> [7] </ref> for reasons). 4 The Interface Specifications The MFC Library contains numerous classes that implement many of the most widely used data structures in imperative programming. Among the most fundamental data structures are arrays and linked lists. <p> Larch/C++ models a function that throws an exception by making the result of the function the normal result (specified by result), or an exception result, written thrown (T), where T is the exception's type <ref> [7, p. 91] </ref> . The resulting function specification contains two specification cases, one specifying the post-condition when sufficient memory is available, and one for specifying the post-condition when insufficient memory exists.
Reference: [8] <author> Enzo Schiano. </author> <title> New kit helps C developers move to MFC. Microsoft Developer Network News, </title> <address> 6(3):6, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Recent research performed by G. Bhalla & Associates, an independent national research firm, indicates that MFC is the most widely used class library among developers who use class libraries <ref> [8] </ref>. The survey was conducted by examining developers in the United States, and showed that 58 percent of C/C++ developers use a class library and that three times as many developers used the MFC Library as any other class library.
Reference: [9] <author> Donald C. Gause & Gerald M. Weinberg. </author> <title> Exploring Requirements: Quality Before Design. </title> <publisher> Dorset House, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: Such techniques could also aid in proving code is designed and implemented accurately and precisely with respect to the requirements. For example, within the English language, there is often more than one way to interpret a single statement. This is shown through the following example taken from <ref> [9] </ref>. Three subjects were given the following problem statement. Construct a means for protecting a small group of human beings from the hostile elements of their environment. When they had finished constructing their shelter, they examined each other's results and were amazed at the differences.
Reference: [10] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year> <month> 57 </month>
Reference-contexts: Unlike SPECS-C++, another C++ class specification technique which declares abstract functions within a class specification [5], trait functions are declared in a module other than the actual specification interface module. This enforces the two-tiered approach to Larch style specification languages <ref> [10] </ref>.
References-found: 10

