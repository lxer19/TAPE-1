URL: file://ftp.di.unipi.it/pub/Papers/meo/BotSem94tr.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: isa@zenone.unipd.it  massimo@hilbert.math.unipd.it  meo@di.unipi.it  
Title: A Bottom-up Semantics for Constructive Negation 1  
Author: Annalisa Bossi Massimo Fabris Maria Chiara Meo 
Address: Via Belzoni 7, 35131 Padova, Italy  Via Belzoni 7, 35131 Padova, Italy  Pisa, Corso Italia 40, 56125 Pisa, Italy,  
Affiliation: Dipartimento di Matematica Pura ed Applicata Universita di Padova,  Dipartimento di Matematica Pura ed Applicata Universita di Padova,  Dipartimento di Informatica Universita di  
Abstract: The constructive negation rule has been introduced by Chan [5, 6] to overcome the main drawbacks of the negation-as-failure rule: the unsoundness of floundering programs and, consequently, the inability of providing answers for non-ground negative queries. In this paper we define a bottom-up semantics for constructive negation which we prove sound and complete with respect to the three-valued completion of the program. The semantics describes answers as well as undefined computations for both positive and negative queries. Its construction closely follows the basic idea of constructive negation whereby answers to a negative query are obtained by negating a frontier of the computation tree for the corresponding positive query. Therefore, the proposed semantics can be considered as a natural base for reasoning on the operational semantics for constructive negation defined in the literature. Moreover, we show how the semantics can be effectively used to perform a bottom-up computation of the answers of a normal query. AMS Subject Classification (1991): 68N17, 68Q55. CR Subject Classification (1991): D.1.6, D.3.1, F.3.2, F.4.1, I.2.3. Keywords and Phrases: logic programming, semantics. Note: A preliminary short version of this paper appeared in [2]. Part of this work has been carried out while the third author was visiting CWI, Amsterdam. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> A New Fixpoint Semantics for Prolog. </title> <editor> In D. Warren, editor, </editor> <booktitle> Proceeding of the Tenth Int. Conf. on Logic Programming, ICLP'93, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. <p> An atom is of the form p (t 1 ; : : : ; t n ) where p is an n-ary symbol in B and t i 2 t ( [ V ), i 2 <ref> [1; n] </ref>. A literal is either an atom or the negation of an atom. A constraint is a well formed formula over the alphabets C and . <p> ~ t 1 ); : : : ; q n ( ~ t n ); :r 1 (~s 1 ); : : : ; :r m (~s m ): be a clause in P and C (I) = f 9 ~ X c 2 A j for any i 2 <ref> [1; n] </ref> and for any j 2 [1; m]; there exist c i 2 Q i 2 I + [ I b+ ; such that either Q i = q i ( ~ X i ) or Q i = d d j 2 R j 2 I [ I ? <p> ; q n ( ~ t n ); :r 1 (~s 1 ); : : : ; :r m (~s m ): be a clause in P and C (I) = f 9 ~ X c 2 A j for any i 2 [1; n] and for any j 2 <ref> [1; m] </ref>; there exist c i 2 Q i 2 I + [ I b+ ; such that either Q i = q i ( ~ X i ) or Q i = d d j 2 R j 2 I [ I ? ; such that either R j = <p> The failure set of G wrt I, F G (I) is defined as F G (I) = fc j c = c 0 ^ c i where i 2 <ref> [1; n] </ref>; and c i 2 S :L i (I)g The next lemma shows that we may extend Definition 4.10 to interpretations. Lemma 4.11 Let I and J be representatives of uncertain interpretations such that I J and let G be a query. <p> We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in <ref> [8, 1] </ref>) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in [5, 22].
Reference: [2] <author> A. Bossi, M. Fabris, and M. C. Meo. </author> <title> A Bottom-up Semantics for Constructive Negation. </title> <editor> In P. Van Hentenryck, editor, </editor> <booktitle> Proceeding of the Eleventh Int. Conf. on Logic Programming, ICLP'94, </booktitle> <pages> pages 520-534. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference: [3] <author> A. Bottoni, G. Levi. </author> <title> Computing in the Completion. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proceeding of the Eight Italian Conf. on Logic Programming, </booktitle> <pages> pages 375-389. </pages> <publisher> Mediterranean Press, </publisher> <year> 1993. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
Reference: [4] <author> A. Bottoni, G. Levi. </author> <title> The Inverse of Fitting's Functional. </title> <editor> In G. Gottlob, A. Leitsch and D. Mundici, editors, </editor> <booktitle> Proceeding Third Kurt Godel Colloquium, Computational and Proof Theory, KGC'93, </booktitle> <pages> pages 132-143. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
Reference: [5] <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 111-125. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Its main drawback is that computing by negation as failure, actually means testing by negation as failure, that is no answers are produced except for the yes/no ones. To overcome this limitation Chan <ref> [5, 6] </ref> introduced the constructive negation rule which subsumes negation as failure and extends it by allowing non-ground negative subgoals to bind variables in the same way as positive ones. <p> We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in [8, 1]) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in <ref> [5, 22] </ref>.
Reference: [6] <author> D. Chan. </author> <title> An Extension of Constructive Negation and its Application in Coroutining. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 477-493. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Its main drawback is that computing by negation as failure, actually means testing by negation as failure, that is no answers are produced except for the yes/no ones. To overcome this limitation Chan <ref> [5, 6] </ref> introduced the constructive negation rule which subsumes negation as failure and extends it by allowing non-ground negative subgoals to bind variables in the same way as positive ones. <p> A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself <p> Another extension of <ref> [6, 25] </ref> is that not only literals can be selected but also some negated formula. Both previous rules are defined in details and in fact Chan has already implemented its rule in the Sepia Prolog compiler.
Reference: [7] <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: A domain theory axiomatizes the particular domain D on which we wish to compute. We do not make any assumption on . Rather we require that the domain theory T contains the standard theory CET , given in <ref> [7] </ref> to axiomatize unification. Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols.
Reference: [8] <author> G. Delzanno and M. Martelli. </author> <title> A bottom-up characterization of finite success. </title> <type> Technical Report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. <p> We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in <ref> [8, 1] </ref>) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in [5, 22]. <p> B 1 )) ^ : : : ^ (:9 ~ X n _ :9 ~ X ( n ^ ~ B n )) 2 This property follows by the fact that if we deal with definite programs, the functional is equivalent to the one proposed by Delzanno and Martelli in <ref> [8] </ref>. 12 we can see that computing the disjunctive form of the right hand side and adding every disjunct as a son of the query :G in its derivation tree is correct and complete.
Reference: [9] <editor> G. Delzanno and M. Martelli. S-semantica per modellare insiemi di soluzioni. In S. Costantini, editor, </editor> <booktitle> Proc. Seventh Italian Conference on Logic Programming, </booktitle> <pages> pages 191-205, </pages> <year> 1992. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in <ref> [8, 9, 1] </ref> for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in.
Reference: [10] <author> W. Drabent. </author> <title> SLS-resolution without floundering. </title> <editor> In L. M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. of the Workshop on Logic Programming and Non-monotonic reasoning, </booktitle> <pages> pages 82-98, </pages> <year> 1993. </year>
Reference-contexts: He gave a new operational schema and proved its soundness and completeness with respect to the three-valued completion of the program. Recently, Drabent <ref> [11, 10] </ref> proposed a method for deriving (constrained) answers for (constrained) normal queries in normal programs called SLDFA-resolution, an extension of SLDNF-resolution. The basic notions of SLDFA-resolution are SLDFA-refutation and finitely failed SLDFA-tree; they are mutually defined as the corresponding notions of SLDNF-resolution. <p> Moreover, subqueries can become really very complex, and the method seem to produce a lot of redundant solutions. The method of Chan shares the same problems. A solution to these drawbacks might be found in the approach recently proposed by Drabent <ref> [11, 10] </ref> for arbitrary normal programs. It is based on the construction of failed trees. If finitely failed trees are concerned then it is sound and complete wrt Clark completion in 3-valued logic.
Reference: [11] <author> W. Drabent. </author> <title> What is Failure? An Approach to Constructive Negation. </title> <journal> Acta Informatica, </journal> <note> 1993. To appear. </note>
Reference-contexts: He gave a new operational schema and proved its soundness and completeness with respect to the three-valued completion of the program. Recently, Drabent <ref> [11, 10] </ref> proposed a method for deriving (constrained) answers for (constrained) normal queries in normal programs called SLDFA-resolution, an extension of SLDNF-resolution. The basic notions of SLDFA-resolution are SLDFA-refutation and finitely failed SLDFA-tree; they are mutually defined as the corresponding notions of SLDNF-resolution. <p> Moreover, subqueries can become really very complex, and the method seem to produce a lot of redundant solutions. The method of Chan shares the same problems. A solution to these drawbacks might be found in the approach recently proposed by Drabent <ref> [11, 10] </ref> for arbitrary normal programs. It is based on the construction of failed trees. If finitely failed trees are concerned then it is sound and complete wrt Clark completion in 3-valued logic.
Reference: [12] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: On the other hand, the uncertain negative atom can be obtained by negating the success and asserting the divergence. The semantics is obtained by iterating an operator P which maps uncertain interpretations to uncertain interpretations. Our construction agrees with Fitting's P operator <ref> [12] </ref> in the sense that at each iteration step there is a one-to-one correspondence between the solutions represented by the uncertain interpretation and the three-valued interpretation constructed by Fitting's operator. <p> The next proposition shows soundness and completeness of the Fitting's operator. Let hI ' i be the partial interpretation associated to I ' , namely hI ' i = [I + ][[I ], and P be the operator defined by Fitting <ref> [12] </ref>. P is a monotonic operator on the set of partial interpretation, ordered by set inclusion. We prove that, for any finite k, there is a one-to-one correspondence between h P " k i and P " k . <p> We prove that, for any finite k, there is a one-to-one correspondence between h P " k i and P " k . Proposition 4.4 Let P be a normal program and P be Fitting's operator <ref> [12] </ref>.
Reference: [13] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Comparisons between Drabent's method and those defined by Chan and Stuckey suggest that the first may have practical advantages over the other two. In this paper we follow a semantical approach to constructive negation. We develop a semantics in the style of <ref> [13] </ref>: we construct a denotation which directly characterizes the program behavior on all most general atomic queries (positive or negative) and contains enough information to represent the program behavior on all queries. We consider CLP normal programs as defined by [16].
Reference: [14] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: We consider CLP normal programs as defined by [16]. Our denotations (uncertain interpretations) extend both those defined in [8, 9, 1] for the semantics of definite programs, and those in <ref> [14] </ref> for modeling answer constraints in CLP normal programs. They contain four kinds of objects which represent the four different computational aspects of a program we are interested in. Three of them have a logical reading in the three-valued completion of the program. <p> Finally, if ~ is an equivalence relation defined on a set S and S 2 S, we denote by S ~ the equivalence class in S=~ which contains S. 4 3 Uncertain interpretations We extend the notion of -interpretation as introduced in <ref> [14] </ref> in order to provide three-valued models of the completion of a CLP normal program.
Reference: [15] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: A structure D over the alphabets C and , consists of a non empty set (D) and any interpretation of each function and predicate symbol according to its arity. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. A domain theory T corresponding to the structure D is a first-order consistent theory containing only predicate symbols from C , such that for any constraint c with F V (c) = ;, D j= c iff T j= c.
Reference: [16] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical Report, </type> <institution> Department of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year> <month> 15 </month>
Reference-contexts: We develop a semantics in the style of [13]: we construct a denotation which directly characterizes the program behavior on all most general atomic queries (positive or negative) and contains enough information to represent the program behavior on all queries. We consider CLP normal programs as defined by <ref> [16] </ref>. Our denotations (uncertain interpretations) extend both those defined in [8, 9, 1] for the semantics of definite programs, and those in [14] for modeling answer constraints in CLP normal programs. <p> We dedicate special attention to Drabent's work and those properties of SLDFA-resolution captured by our semantics. Some proofs are deferred to the appendix. 2 Preliminaries We assume the reader is familiar with the basic concept of logic programming. We recall the basic CLP concepts as defined in <ref> [16] </ref> and [20]. A first order language is defined on a function symbols set denoted by , a predicate symbols set denoted by and a collection of variables denoted by V . <p> We also use the standard notation f" ff = f" ff (?), where ? is the bottom element of the lattice. Definition 2.1 (CLP normal programs) <ref> [16] </ref> A normal program is a finite set of clauses of 3 the form H c 2 ~ L: where c is a constraint, H (the head) is an atom and ~ L (the body) is a (possibly empty) conjunction of literals. <p> A structure D over the alphabets C and , consists of a non empty set (D) and any interpretation of each function and predicate symbol according to its arity. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. A domain theory T corresponding to the structure D is a first-order consistent theory containing only predicate symbols from C , such that for any constraint c with F V (c) = ;, D j= c iff T j= c. <p> We also introduce the following [ ] operator on constrained atoms, which returns the set of "domain instances". Definition 2.3 <ref> [16] </ref> The set of "domain instances" [c 2 p ( ~ X)] of a constrained atom c 2 p ( ~ X) is defined as [c 2 p ( ~ X)] = fp ( ~ X) j is a solution of cg: Let S be a set of constrained atoms.
Reference: [17] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: First of all, a partial interpretation, as defined in <ref> [17] </ref>, is any total function F from the set of all ground atoms into ft; f ; ug, where ft; f ; ug are interpreted as true, false and undefined. <p> Proposition 4.4 Let P be a normal program and P be Fitting's operator [12]. Then h P " k i = P " k ; for any finite k: Using our terminology, Theorem 6 of [24] (which is a generalization of Theorem 6.3 in <ref> [17] </ref> for languages other than those with infinitely many function symbols of all arities) can be stated for CLP as follows. The notation T ^ P fl j= 3 S shows that the sentence S is a three-valued logical consequence of the theory T ^ P fl .
Reference: [18] <author> D. Lugiez. </author> <title> A Deduction Procedure for First Order Programs. </title> <booktitle> In Proc. of Sixth International Conf. on Logic Programming, Lisbon, </booktitle> <pages> pages 585-599, </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
Reference: [19] <author> P. Mancarella, S. Martini, and D. Pedreschi. </author> <title> Complete Logic Programs with Domain Closure Axiom. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 263-276, </pages> <year> 1988. </year>
Reference-contexts: Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols. Informally the axiom DCA <ref> [19] </ref> ensures that in the interpretation domain of any model of the theory, every object is a value of a non-variable term. A valuation is a mapping from the variables to D. The notion of valuation is extended in the obvious way to terms and constraints.
Reference: [20] <author> M.J. Maher. </author> <title> Logic Semantics for a Class of Committed-Choice Programs. </title> <booktitle> In Proc. of Fourth International Conf. on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: We dedicate special attention to Drabent's work and those properties of SLDFA-resolution captured by our semantics. Some proofs are deferred to the appendix. 2 Preliminaries We assume the reader is familiar with the basic concept of logic programming. We recall the basic CLP concepts as defined in [16] and <ref> [20] </ref>. A first order language is defined on a function symbols set denoted by , a predicate symbols set denoted by and a collection of variables denoted by V . <p> Moreover we require that for every constraint c either T j= 9c or T j= :9c (namely, T is satisfaction complete <ref> [20] </ref>). A domain theory axiomatizes the particular domain D on which we wish to compute. We do not make any assumption on . Rather we require that the domain theory T contains the standard theory CET , given in [7] to axiomatize unification.
Reference: [21] <author> J. A. </author> <title> Plaza. Fully Declarative Logic Programming. </title> <booktitle> In Programming Language Implementation and Logic Programming, Proceedings 1992, </booktitle> <pages> pages 415-427, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <note> LNCS 631. </note>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
Reference: [22] <author> T. Przymusinsky. </author> <title> On Constructive Negation in Logic Programming. </title> <booktitle> In Proc. North American Conference on Logic Programming, Addendum. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We shall give the intuition that [[P ]] CN captures and models computational features (like termination properties or answer substitutions as in [8, 1]) of some operational semantics for constructive negation recently proposed. First we consider the operational semantics defined in <ref> [5, 22] </ref>.
Reference: [23] <author> T. Sato, and F. Motoyoshi. </author> <title> A Complete Top-down Interpreter for First Order Logic Programs. </title> <booktitle> In Logic Programming, Proc. of the 1991 International Symposium, </booktitle> <pages> pages 35-53, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
Reference: [24] <author> J. C. Shepherdson. </author> <title> Language and equality theory in logic programming. </title> <type> Technical Report PM-91-02, </type> <institution> School of Mathematics, University of Bristol, </institution> <year> 1991. </year>
Reference-contexts: Proposition 4.4 Let P be a normal program and P be Fitting's operator [12]. Then h P " k i = P " k ; for any finite k: Using our terminology, Theorem 6 of <ref> [24] </ref> (which is a generalization of Theorem 6.3 in [17] for languages other than those with infinitely many function symbols of all arities) can be stated for CLP as follows. <p> In the following, given the structure D, we denote by T the theory corresponding to D. Theorem 4.5 (correctness and completeness of P ) <ref> [24] </ref> Let P be a normal program over the structure D and let S be a sentence. Then the following are equivalent: 1) T ^P fl j= 3 S; 2) S has truth value true in P " k , for a finite k.
Reference: [25] <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The basic idea which is formalized by SLD-CNF resolution is that, to handle a negative subgoal, one first considers its positive version and then negates all its answers. Answers to negative goals are described by first-order formulas which are interpreted in CET, the equality theory defined by Clark. Stuckey <ref> [25] </ref> pointed out how constraint logic programming provides a much more natural setting for describing constructive negation and described a setting for constructive negation for constraint logic programming over arbitrary structures. <p> There are obvious analogies between P and A P , the non-ground (constrained) version of P defined by Stuckey in <ref> [25] </ref>. The main difference is that instead of deriving information on success and failure we derive information on success and divergent computations. Note that our information is richer than the former. <p> The extension of a partial interpretation to ground constraints and to ground formulas is defined in <ref> [25] </ref>, by the following rules. * Let c be a ground constraint. c is true in F iff T j= c and c is false in F iff T j= :c. * We assume the usual strong three-valued interpretation of the symbols ^; _; :; 8; 9; !, and following Kunen, <p> Similar theorems were proved for constructive negation in <ref> [25] </ref>. Theorem 4.14 (correctness) Let P be a normal program over the structure D and G : c 0 2L 1 ; : : :; L m be a query. <p> A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself <p> Another extension of <ref> [6, 25] </ref> is that not only literals can be selected but also some negated formula. Both previous rules are defined in details and in fact Chan has already implemented its rule in the Sepia Prolog compiler.
Reference: [26] <author> M. Wallace. </author> <title> Negation by Constraints: a Sound and Efficient Implementation of Negation in Deductive Databases. </title> <booktitle> In Proc. 1987 Symposium on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pages 253-263, </pages> <month> August </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: A second group of methods has been proposed to deal also with infinite trees and it can be understood as using the completion of a program instead of the program itself. The basic concept of <ref> [26, 18, 6, 25, 23, 21, 3, 4] </ref> is, roughly speaking, that in a derivation step for :p ( ~ t) the completed definition of the predicate p is used: :p ( ~ t) can be replaced by the negated right hand side of the completed definition of the predicate itself
References-found: 26

