URL: http://www.cs.wustl.edu/~schmidt/C++-report-col5.ps.gz
Refering-URL: http://www.acl.lanl.gov/CORBA/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: schmidt@cs.wustl.edu vinoski@ch.hp.com  
Title: Object Interconnections Comparing Alternative Programming Techniques for Multi-threaded Servers (Column 5)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the February 1996 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 Chelmsford, MA 01824  
Affiliation: Department of Computer Science Hewlett-Packard Company Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The following are several common ways to avoid blocking in single-threaded servers: * Reactive event dispatchers: one approach is to develop an event dispatcher (such as the object-oriented Reactor framework described in <ref> [1] </ref>). Reactive dispatching is commonly used to manage multiple input devices in single-threaded user-interface frameworks. In these frameworks, the main event dispatcher detects an incoming event, de-multiplexes the event to the appropriate handler object, and dispatches an application-specific callback method to handle the event. <p> The main program creates a passive-mode listener socket (which accepts connections from clients) and then calls svc run to perform the main quote server's event loop: int main (int argc, char *argv []) - u_short port /* Port to listen for connections. */ = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 10000; /* Create a passive-mode listener endpoint. */ HANDLE listener = create_server_endpoint (port); /* The event loop for the main thread. */ svc_run (listener); /* NOTREACHED */ - The svc run function waits in an event loop for connection requests to arrive from clients. <p> new QUOTE_HANDLER (db_, lock_); - private: Quote_Database &db_; // Reference to database RW_Mutex lock_; // Serialize access to database. - The main function uses the components defined above to implement the quote server: int main (int argc, char *argv []) - u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 10000; // Factory that produces Quote_Handlers. Quote_Acceptor acceptor (port, quote_db); // Single-threaded event loop that dispatches all // events in the Quote_Acceptor::handle_input () // method. for (;;) acceptor.handle_input (); /* NOTREACHED */ - After the Quote Acceptor factory has been created the application goes into an event loop. <p> The impl is ready and run methods are public interfaces to the CORBA event loop. In a single-threaded ORB, these methods typically use the Reactor pattern <ref> [1] </ref> to wait for CORBA method requests to arrive from multiple clients. The processing of these requests within the server is driven by upcalls dispatched by impl is ready or run. These upcalls invoke the get quote method of the My Quoter object implementation supplied by the server programmer.
Reference: [2] <author> A. Banerji and D. L. Cohn, </author> <title> Shared Objects and Vtbl Placement for C++ , Journal of C Language and Translation, </title> <journal> vol. </journal> <volume> 6, </volume> <pages> pp. 44-60, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Moreover, it may not be possible to exert fine-grain control over the scheduling behavior and priority of processes. In addition, processes that share C++ objects in shared memory segments must make non-portable assumptions about the placement of virtual table pointers <ref> [2] </ref>. * Preemptive multi-threading: When used correctly, preemptive multi-threading provides a more elegant, and potentially more efficient, means to overcome the limitations with the other concurrent processing techniques described above. A thread is a single sequence of execution steps performed in the context of a process.
Reference: [3] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In addition to its own instruction pointer, a thread contains other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. A preemptive multi-threading operating system (such as Solaris 2.x <ref> [3] </ref> and Windows NT [4]) or library (such as the POSIX pthreads library [5] available with DCE) uses a clock-driven scheduler to ensure that each thread of control executes for a particular period of time. <p> In general, multi-threaded servers require more sophisticated synchronization strategies than single-threaded servers. To illustrate how to alleviate unnecessary complexity, we present and evaluate a number of strategies and tactics necessary to build robust and efficient thread-per-request servers. We first examine a simple solution using C and Solaris threads <ref> [3] </ref>. We then describe how using C++ wrappers for threads helps reduce the complexity and improves the portability and robustness of the C solution. Finally, we present a solution that illustrates the thread-per-request concurrency model implemented using two multi-threaded versions of CORBA (HP ORB Plus and MT-Orbix [6]).
Reference: [4] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: In addition to its own instruction pointer, a thread contains other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. A preemptive multi-threading operating system (such as Solaris 2.x [3] and Windows NT <ref> [4] </ref>) or library (such as the POSIX pthreads library [5] available with DCE) uses a clock-driven scheduler to ensure that each thread of control executes for a particular period of time. When a thread's time period has elapsed it is preempted to allow other threads to run.
Reference: [5] <author> IEEE, </author> <title> Threads Extension for Portable Operating Systems (Draft 10), </title> <month> February </month> <year> 1996. </year>
Reference-contexts: A preemptive multi-threading operating system (such as Solaris 2.x [3] and Windows NT [4]) or library (such as the POSIX pthreads library <ref> [5] </ref> available with DCE) uses a clock-driven scheduler to ensure that each thread of control executes for a particular period of time. When a thread's time period has elapsed it is preempted to allow other threads to run.
Reference: [6] <author> C. Horn, </author> <title> The Orbix Architecture, </title> <type> tech. rep., </type> <institution> IONA Technologies, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: We then describe how using C++ wrappers for threads helps reduce the complexity and improves the portability and robustness of the C solution. Finally, we present a solution that illustrates the thread-per-request concurrency model implemented using two multi-threaded versions of CORBA (HP ORB Plus and MT-Orbix <ref> [6] </ref>). Our next column will show examples of the other concurrency models. A word of caution: the multi-threading techniques we discuss in this column aren't standardized throughout the industry. Therefore, some of the code we show is not directly reusable across all OS platforms.
Reference: [7] <author> R. C. Martin, </author> <title> The Open-Closed Principle, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: These dependencies make it hard to reuse existing code <ref> [7] </ref>. * Lack of robustness: in a large program, instrumenting all the code with mutex locks can be tedious and error-prone. In particular, failing to release a mutex can lead to deadlock or resource failures.
Reference: [8] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: C++ wrappers encapsulate lower-level OS interfaces such as sockets, multi-threading, and synchronization with type-safe, object-oriented interfaces. The IPC SAP <ref> [8] </ref>, Acceptor [9], and Thread [10] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit [11]. <p> with the SOCK Stream wrapper for TCP stream sockets available in the SOCK SAP class category from the ACE IPC SAP class library: typedef Quote_Handler &lt;SOCK_Stream&gt; QUOTE_HANDLER; SOCK SAP contains a set of C++ classes that shields appli cations from tedious and error-prone details of programming at the socket level <ref> [8] </ref>. 3.1.2 The Quote Acceptor Class Next we'll show the Quote Acceptor class. This class is a factory that implements the strategy for passively initializ ing a Quote Handler.
Reference: [9] <author> D. C. Schmidt, </author> <title> Design Patterns for Initializing Network Services: Introducing the Acceptor and Connector Patterns, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> November/December </month> <year> 1995. </year>
Reference-contexts: C++ wrappers encapsulate lower-level OS interfaces such as sockets, multi-threading, and synchronization with type-safe, object-oriented interfaces. The IPC SAP [8], Acceptor <ref> [9] </ref>, and Thread [10] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit [11]. <p> This class is a factory that implements the strategy for passively initializ ing a Quote Handler. The Quote Acceptor supplies concrete template arguments for the following implementa tion of the Acceptor pattern <ref> [9] </ref>: template &lt;class SVC_HANDLER, // Service handler class PEER_ACCEPTOR&gt; // Passive conn. mech. class Acceptor - public: // Initialize a passive-mode connection factory.
Reference: [10] <author> D. C. Schmidt, </author> <title> An OO Encapsulation of Lightweight OS Concurrency Mechanisms in the ACE Toolkit, </title> <type> Tech. Rep. </type> <institution> WUCS-95-31, Washington University, St. Louis, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: C++ wrappers encapsulate lower-level OS interfaces such as sockets, multi-threading, and synchronization with type-safe, object-oriented interfaces. The IPC SAP [8], Acceptor [9], and Thread <ref> [10] </ref> C++ wrappers shown below are part of the ACE object-oriented network programming toolkit [11].
Reference: [11] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: C++ wrappers encapsulate lower-level OS interfaces such as sockets, multi-threading, and synchronization with type-safe, object-oriented interfaces. The IPC SAP [8], Acceptor [9], and Thread [10] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit <ref> [11] </ref>.
Reference: [12] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Using the concurrency model in this example, each Quote Handler runs in a separate thread of control. Quote Acceptor: this class is a factory <ref> [12] </ref> that implements the strategy for passively initializing a Quote Handler. This involves assembling the resources necessary to create a new Quote Handler object, accepting the connection into this object, and activating the Quote Handler by calling its open method. <p> The only extra C++ code we have to write is called a ThreadFilter. Each incoming CORBA request is passed through the chain of filters before being dispatched to its target object implementation. Filters are an MT-Orbix extension to CORBA that implement the Chain of Responsibility pattern <ref> [12] </ref>. Orbix uses this pattern to decouple (1) the demultiplexing of CORBA requests (e.g., generated by the client-side get quote proxy) to their associated target object (e.g., my quoter) from (2) the eventual dispatching of the upcall method implementation (e.g., My Quoter::get quote). <p> Since CORBA makes no mention of threads, it remains to be seen whether the OMG ORB Task Force will take it upon itself to address this issue as a CORBA portability problem. Clearly, in the short term we could use techniques like the Adapter pattern <ref> [12] </ref> and reusable C++ toolkits like ACE to make our object implementations relatively portable across different OS platforms and different ORBs. * Non-C++ Exception Handling: Both the HP ORB Plus and MT-Orbix implementations currently use Environment parameters to convey exception information rather than C++ exceptions.
Reference: [13] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, 2 nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Read Guard employs a C++ idiom (first described in <ref> [13] </ref>) that uses the constructor to acquire a resource automatically when an object of the class is created and uses the destructor to release the resource automatically when it goes out of scope.
Reference: [14] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: DOC frameworks allow application developers to focus on solving their domain problems, rather than worrying about network programming details. In the following section we describe several ways to implement thread-per-request servers using CORBA. 4 The Multi-threaded CORBA Solu tion The CORBA 2.0 specification <ref> [14] </ref> does not prescribe a con-currency model. Therefore, a CORBA-conformant ORB need not provide multi-threading capabilities. However, commercially-available ORBs are increasingly providing support for multi-threading.
Reference: [15] <author> H. Mueller, </author> <title> Patterns for Handling Exception Handling Successfully, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> Jan. </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: Read_Guard&lt;RW_Mutex&gt; m (lock_); if (value == -1) throw Stock::Invalid_Stock (); // ... Coding defensively with idioms like the Read Guard is essential to protect programs from hazardous side-effects of C++ exceptions <ref> [15] </ref>. 5 Evaluating the Thread-per-Request Concurrency Model All the servers shown above were designed using a thread-per-request concurrency model. This is a fairly straightforward model to design and implement. However, it is probably the wrong concurrency model for the task of retrieving stock quotes.
References-found: 15

