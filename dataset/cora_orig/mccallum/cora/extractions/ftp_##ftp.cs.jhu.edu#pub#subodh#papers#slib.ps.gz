URL: ftp://ftp.cs.jhu.edu/pub/subodh/papers/slib.ps.gz
Refering-URL: http://www.cs.jhu.edu/~subodh/research/render.html
Root-URL: http://www.cs.jhu.edu
Email: subodh@cs.jhu.edu  
Title: sLIB: A Comprehensive Renderer for Parametric Surface-Models  
Author: Subodh Kumar 
Affiliation: Johns Hopkins University  
Abstract: We present sLIB: a library for interactive rendering of models with trimmed NURBS surfaces. sLIB provides users with the ability to configure the rendering pipeline based on the available hardware, i.e, the number of processors and the quality of the graphics board. sLIB includes a suite of algorithms, some of which have been presented before. It is based on dynamic triangulation of groups of surface primitives. The five major components of sLIB are surface pre-processing, pipeline management, visibility computation, tessellation, and triangle rendering. The pipeline manager monitors the performance of the CPUs and the graphics board to tune the system for performance improvement. We have successfully used sLIB to obtain faster rendering rates than has been achieved before. sLIB scales well with both the hardware and the data size. In addition, sLIB provides a flexible framework for designing and testing surface rendering algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [3di97] <institution> Ibm 3d interaction accelerator, </institution> <year> 1997. </year> <note> http://www.research.ibm.com/3dix/description00.html. </note>
Reference-contexts: It turned out to be too rigid and did not provide enough freedom to configure the pipeline the way we sometimes needed. We believe that our system is first of its kind for rendering large surface models. Good systems <ref> [Per97, 3di97, VIS97] </ref> for efficient rendering management are available, but none are designed for dynamic surface tessellation, nor are they flexible enough to allow the types of experiments we are interested in.
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pages 385397, </pages> <year> 1991. </year>
Reference-contexts: Moreover, it seems unnatural that in order to render surfaces, we first generate a large number of triangles and then find a way to reduce the count. On the other hand, efficient techniques for dynamic surface tessellation <ref> [RHD89, AES91, KML96, KMZH97] </ref> have made it possible to approximate surfaces with a small number of triangles in the first place. Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches [XV96, Hop97]. <p> Ray tracing, pixel level subdivision and scan-line based algorithms have been used in the past to render surfaces. However, none of these are quite efficient on current graphics systems. In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces <ref> [RHD89, AES91, LC93, PR95, KML96] </ref>. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used [KMZH97].
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality Engine Graphics. </title> <booktitle> In Proc. ACM SIGGRAPH, </booktitle> <pages> pages 109116, </pages> <year> 1993. </year>
Reference-contexts: With the exception of [KMZH97], most other surface rendering systems are known to be more than a hundred times slower than sLIB . In addition, these systems <ref> [Ake93, DN93, Pea97] </ref> are little more than a collection of functions for evaluating properties of NURBS surfaces and for triangulating them; they do not form a comprehensive rendering system. Compared to the performance of [KMZH97], sLIB achieves a speed-up of about 1.5-2.5.
Reference: [BDK98] <author> G. Barequet, C. Duncan, and S. Kumar. RSVP: </author> <title> A geometric toolkit for controlled repair of solid models. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 4(2):162177, </volume> <year> 1998. </year>
Reference-contexts: Before we construct the surface hierarchy we derive adjacencies between surface patches. We do this using an extension of the scheme proposed in <ref> [BDK98] </ref>. If boundary control polygons p 1 and p 2 , respectively, of patches P 1 and P 2 match exactly, we draw an edge between P 1 and P 2 in the adjacency graph. If curves do not match exactly, we use the adjacency score [BDK98] (based on relative distances <p> the scheme proposed in <ref> [BDK98] </ref>. If boundary control polygons p 1 and p 2 , respectively, of patches P 1 and P 2 match exactly, we draw an edge between P 1 and P 2 in the adjacency graph. If curves do not match exactly, we use the adjacency score [BDK98] (based on relative distances to neighboring boundary curves) to assign adjacencies. The surface hierarchy is constructed in a bottom-up fashion. At each level, i, we use a technique similar to [KMZH97] to construct fsuper-surface (i)g: we grow super-surfaces (i1) into larger super-surfaces (i).
Reference: [Bro96] <author> F. Brooks. </author> <title> Newport news shipbuilding company interview re ship design process. </title> <type> Technical Report TR96-002, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1996. </year> <title> Restricted Circulation. </title>
Reference-contexts: 1 Introduction Non-Uniform Rational B-Spline (NURBS) surfaces are routinely used to design geometric models like automobiles, submarines, airplanes, etc. Often these surfaces are approximated by triangles for efficient display on current graphics systems. A one-time static tessellation of many real-world models usually requires the generation of millions of triangles <ref> [Bro96] </ref>. Most Current graphics systems are not able to render these many triangles at interactive speeds, i.e., more than 10 times a second. A number of surface simplification schemes have recently been proposed [CVMe96, GH97, Hop97] that speed up polygonal rendering.
Reference: [CVMe96] <author> J. Cohen, A. Varshney, D. Manocha, and G. Turk et al. </author> <title> Simplification envelopes. </title> <booktitle> In Proc. ACM SIGGRAPH, </booktitle> <pages> pages 119128, </pages> <year> 1996. </year>
Reference-contexts: A one-time static tessellation of many real-world models usually requires the generation of millions of triangles [Bro96]. Most Current graphics systems are not able to render these many triangles at interactive speeds, i.e., more than 10 times a second. A number of surface simplification schemes have recently been proposed <ref> [CVMe96, GH97, Hop97] </ref> that speed up polygonal rendering. However, they often require management of large amounts of data and are still unable to generate more detail than the initial tessellation. <p> Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm [KMZH97] presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs <ref> [CVMe96] </ref> of the triangulation. At rendering time, the appropriate level is displayed for each super-surface based on its distance from the viewer. If the highest level of detail of a super-surface is insufficient, each Bezier patch of the super-surface is triangulated separately.
Reference: [DGHM93] <author> T. DeRose, R. Goldman, H. Hagen, and S. Mann. </author> <title> Functional composition algorithm via blossoming. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 12(2):113135, </volume> <year> 1993. </year>
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proc. ACM SIG-GRAPH, </booktitle> <pages> pages 101108, </pages> <year> 1993. </year>
Reference-contexts: With the exception of [KMZH97], most other surface rendering systems are known to be more than a hundred times slower than sLIB . In addition, these systems <ref> [Ake93, DN93, Pea97] </ref> are little more than a collection of functions for evaluating properties of NURBS surfaces and for triangulating them; they do not form a comprehensive rendering system. Compared to the performance of [KMZH97], sLIB achieves a speed-up of about 1.5-2.5.
Reference: [Far93] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year>
Reference-contexts: is often not possible to find an exact rational parametrization of these curves in the domains of the corresponding intersecting surfaces. (Currently, sLIB does not include any facility for constructing approximate Bezier curves from the piece-wise linear representation.) We subdivide NURBS curves and surfaces into Bezier form using knot insertion <ref> [Far93] </ref>. Additionally, each Bezier trimming curve is also subdivided at patch boundaries. (a) (b) tessellation (dashed lines) of a single super-surface in its domain. Domains of its constituent patches are marked with solid lines. (b) shows four adjacent super-surfaces and their constituent patches. Special points are marked in bold. <p> We refer to such object-space data merely as surface properties. We will later detail the specific properties we precompute when we describe how those properties are used. We refer to the volume of the bounding box (e.g., of a pseudo-Gauss map) as its magnitude. We subdivide <ref> [Far93] </ref> each complex Bezier surface.
Reference: [GH97] <author> M. Garland and P. Heckbert. </author> <title> Surface simplification using quadric error metrics. </title> <booktitle> In Proc. ACM SIG-GRAPH, </booktitle> <pages> pages 209216, </pages> <year> 1997. </year>
Reference-contexts: A one-time static tessellation of many real-world models usually requires the generation of millions of triangles [Bro96]. Most Current graphics systems are not able to render these many triangles at interactive speeds, i.e., more than 10 times a second. A number of surface simplification schemes have recently been proposed <ref> [CVMe96, GH97, Hop97] </ref> that speed up polygonal rendering. However, they often require management of large amounts of data and are still unable to generate more detail than the initial tessellation.
Reference: [Hop97] <author> H. Hoppe. </author> <title> View dependent refinement of prograssive meshes. </title> <booktitle> In Proc. ACM SIGGRAPH, </booktitle> <year> 1997. </year>
Reference-contexts: A one-time static tessellation of many real-world models usually requires the generation of millions of triangles [Bro96]. Most Current graphics systems are not able to render these many triangles at interactive speeds, i.e., more than 10 times a second. A number of surface simplification schemes have recently been proposed <ref> [CVMe96, GH97, Hop97] </ref> that speed up polygonal rendering. However, they often require management of large amounts of data and are still unable to generate more detail than the initial tessellation. <p> Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches <ref> [XV96, Hop97] </ref>. The dynamic tessellation approach also promises to be more scalable and efficient, in general. While the model sizes will continue to grow, the representation for the model-subset that must be processed every frame need not grow linearly.
Reference: [KCM96] <author> S. Kumar, C. Chang, and D. Manocha. </author> <title> Scalable algorithms for interactive visualization of curved surfaces. </title> <booktitle> In Supercomputing, </booktitle> <address> Pittsburgh, PA, </address> <year> 1996. </year>
Reference-contexts: It is entirely possible that the rendering module is directly hooked to the visibility module and it discards all triangles of a hidden patch. sLIB also has inbuilt support for multi-processors systems and manages load distribution. We use the lock-free synchronization scheme of <ref> [KCM96] </ref> to reduce the number of system calls needed for mutual exclusion by appropriately ordering our read-write operations. sLIB consists of five main components: Surface preprocessing: As a part of preprocessing, a hierarchical representation of the model is generated, adjacencies between surfaces are computed, and surface properties like maximum magnitudes of <p> Note that in our current implementation, Surface Tree is actually a forest with a few tens of trees. Load balancing is easily achieved by starting with an equitable distribution of these trees, followed by work stealing as proposed in <ref> [KCM96] </ref>. 4.2 Dynamic control While our scheme has all the mechanism for dynamic configuration of the pipeline, currently only simple changes are made: 1. Scheduling priority of a bottlenecked autonomous thread may be increased 2.
Reference: [KM96] <author> S. Kumar and D. Manocha. </author> <title> Hierarchical visibility culling for spline models. </title> <booktitle> In Proc. Graphics Interface, </booktitle> <pages> pages 142150, </pages> <address> Toronto, Canada, </address> <year> 1996. </year>
Reference-contexts: Not all primitives need be at the same level for a frame. For example, one primitive could be a single Bezier patch, while another is a super-surface (a collection of patches). sLIB includes a variety of view-frustum and back-patch <ref> [KM96] </ref> culling routines. Different types of bounding box hierarchies are available and one (or more) of them may be activated. Additionally, the application program may plug in its own visibility processor. <p> We start with the details of super-surface construction and the hierarchical model representation in Section 2. We 2 present a brief overview of the tessellation and visibility algorithms by <ref> [KML96, KM96] </ref> in Section 3 and describe our improvements. Section 4 describes the pipeline management. Section 5 discusses our system implementation and analyzes its performance.
Reference: [KML96] <author> S. Kumar, D. Manocha, and A. Lastra. </author> <title> Interactive display of large NURBS models. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 2(4):323336, </volume> <month> Dec </month> <year> 1996. </year>
Reference-contexts: Moreover, it seems unnatural that in order to render surfaces, we first generate a large number of triangles and then find a way to reduce the count. On the other hand, efficient techniques for dynamic surface tessellation <ref> [RHD89, AES91, KML96, KMZH97] </ref> have made it possible to approximate surfaces with a small number of triangles in the first place. Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches [XV96, Hop97]. <p> Ray tracing, pixel level subdivision and scan-line based algorithms have been used in the past to render surfaces. However, none of these are quite efficient on current graphics systems. In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces <ref> [RHD89, AES91, LC93, PR95, KML96] </ref>. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used [KMZH97]. <p> As a result, we are able to perform simplification of a small number of surfaces directly, as opposed to that of a potentially large number of polygons. 1.3 Main contributions In the experience of the Kumar et al. <ref> [KML96, KMZH97] </ref>, their prototype implementation was not easily extensible. Separate copies of the code were made for testing specific algorithms, with each copy taking on its own path. The result was a tree of separate codes. <p> We start with the details of super-surface construction and the hierarchical model representation in Section 2. We 2 present a brief overview of the tessellation and visibility algorithms by <ref> [KML96, KM96] </ref> in Section 3 and describe our improvements. Section 4 describes the pipeline management. Section 5 discusses our system implementation and analyzes its performance. <p> These are exactly the domain corners of super-surfaces as marked in Fig. 3 (b). 3 Surface Processing This section presents our algorithmic improvements to <ref> [KML96, KMZH97] </ref>. Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm [KMZH97] presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs [CVMe96] of the triangulation. <p> These are exactly the domain corners of super-surfaces as marked in Fig. 3 (b). 3 Surface Processing This section presents our algorithmic improvements to <ref> [KML96, KMZH97] </ref>. Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm [KMZH97] presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs [CVMe96] of the triangulation. <p> If the highest level of detail of a super-surface is insufficient, each Bezier patch of the super-surface is triangulated separately. Extra processing is re quired to prevent cracks between super-surfaces at different levels of detail. 3 Incremental tessellation and rendering of Bezier patches is dis- cussed in <ref> [KML96] </ref>. In brief, they 1. Perform view-frustum and back-face culling. Using the bounding volume of a Bezier patch, F, [KML96] computes the back-space, an open cone S B (see Fig. 4). If N = F u fi F v is contained in S B , F is back-facing. <p> Extra processing is re quired to prevent cracks between super-surfaces at different levels of detail. 3 Incremental tessellation and rendering of Bezier patches is dis- cussed in <ref> [KML96] </ref>. In brief, they 1. Perform view-frustum and back-face culling. Using the bounding volume of a Bezier patch, F, [KML96] computes the back-space, an open cone S B (see Fig. 4). If N = F u fi F v is contained in S B , F is back-facing. Note that it uses bounding volumes for both F and N. <p> Since we compute adjacencies, we can simplify the common boundary curve separately and use the simplified version on both adjacent patches, thus avoiding cracks. We perform this simplification by deleting points on the curve as long as each resulting curve segment is less than in length, where <ref> [KML96] </ref> is a user controlled bound on the maximum triangle-edge length. A problem with this approach is that resulting trimming polygon may be self-intersecting. In order to avoid this, we select special points on the curve that cannot be deleted.
Reference: [KMZH97] <author> S. Kumar, D. Manocha, H. Zhang, and K. Hoff. </author> <title> Accelerated walkthrough of large spline models. </title> <booktitle> In Proc. Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 91 101, </pages> <address> Providence, RI, </address> <year> 1997. </year>
Reference-contexts: Moreover, it seems unnatural that in order to render surfaces, we first generate a large number of triangles and then find a way to reduce the count. On the other hand, efficient techniques for dynamic surface tessellation <ref> [RHD89, AES91, KML96, KMZH97] </ref> have made it possible to approximate surfaces with a small number of triangles in the first place. Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches [XV96, Hop97]. <p> While the model sizes will continue to grow, the representation for the model-subset that must be processed every frame need not grow linearly. In other words, more information may be compressed in a small number of higher-order primitives like surfaces and super-surfaces <ref> [KMZH97] </ref>. We present sLIB , a library for efficient rendering of parametric surfaces. We will often refer to sLIB as a system, since it incorporates all components of a surface rendering system except the user interface. <p> In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces [RHD89, AES91, LC93, PR95, KML96]. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used <ref> [KMZH97] </ref>. We borrow the terminology of super-surfaces from [KMZH97], but our notion of super-surface is different it represents a dynamically chosen collection of patches, rather than a static cluster. <p> A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used <ref> [KMZH97] </ref>. We borrow the terminology of super-surfaces from [KMZH97], but our notion of super-surface is different it represents a dynamically chosen collection of patches, rather than a static cluster. In addition, we tessellate super-surfaces at rendering time and treat them as first class primitives, thus obtaining a finer control on the triangulation generated each frame. <p> As a result, we are able to perform simplification of a small number of surfaces directly, as opposed to that of a potentially large number of polygons. 1.3 Main contributions In the experience of the Kumar et al. <ref> [KML96, KMZH97] </ref>, their prototype implementation was not easily extensible. Separate copies of the code were made for testing specific algorithms, with each copy taking on its own path. The result was a tree of separate codes. <p> If curves do not match exactly, we use the adjacency score [BDK98] (based on relative distances to neighboring boundary curves) to assign adjacencies. The surface hierarchy is constructed in a bottom-up fashion. At each level, i, we use a technique similar to <ref> [KMZH97] </ref> to construct fsuper-surface (i)g: we grow super-surfaces (i1) into larger super-surfaces (i). <p> These are exactly the domain corners of super-surfaces as marked in Fig. 3 (b). 3 Surface Processing This section presents our algorithmic improvements to <ref> [KML96, KMZH97] </ref>. Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm [KMZH97] presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs [CVMe96] of the triangulation. <p> These are exactly the domain corners of super-surfaces as marked in Fig. 3 (b). 3 Surface Processing This section presents our algorithmic improvements to <ref> [KML96, KMZH97] </ref>. Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm [KMZH97] presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs [CVMe96] of the triangulation. <p> These are exactly the domain corners of super-surfaces as marked in Fig. 3 (b). 3 Surface Processing This section presents our algorithmic improvements to [KML96, KMZH97]. Our system is, in part, based on [KML96, KMZH97], hence we start with its brief overview: 3.1 Previous algorithm <ref> [KMZH97] </ref> presents a technique to combine adjacent Bezier patches into super-surfaces. They triangulate each super-surface and generate various LODs [CVMe96] of the triangulation. At rendering time, the appropriate level is displayed for each super-surface based on its distance from the viewer. <p> The scaling factor is the maximum ratio between any unit vector in B F , and its projection on-screen. <ref> [KMZH97] </ref> notes that a profile of the code shows that up to 30% of the CPU time is spent in computing s F at rendering time. We show later, how to reduce this time. 3. <p> This implies that re-testing is not required as long as the movement of eye point (i.e. jE i+1 E i j) is less than d v = jNj . Note that m F and the maximum value of jNj are pre-computed properties of primitives. 3.5 Trimming curve processing <ref> [KMZH97] </ref> performs a sampling of all trimming curves to obtain a piecewise linear representation. However, if the trimming curves are already specified in a highly tessellated form, it is difficult to reduce the number of points on the trimming curves without introducing cracks in the triangulation. <p> It is the `responsibility' of each data structure to provide concurrency control for simultaneous reads and writes. To implement the asynchronous rendering scheme of <ref> [KMZH97] </ref>, we merely disable the concurrency control and allow T and R to maintain consistency by their order of accesses to L 2 . <p> Good systems [Per97, 3di97, VIS97] for efficient rendering management are available, but none are designed for dynamic surface tessellation, nor are they flexible enough to allow the types of experiments we are interested in. With the exception of <ref> [KMZH97] </ref>, most other surface rendering systems are known to be more than a hundred times slower than sLIB . <p> In addition, these systems [Ake93, DN93, Pea97] are little more than a collection of functions for evaluating properties of NURBS surfaces and for triangulating them; they do not form a comprehensive rendering system. Compared to the performance of <ref> [KMZH97] </ref>, sLIB achieves a speed-up of about 1.5-2.5. Approximately 40% of this improvement may be attributed to the fractional condition scheme and 20% to our improved visibility algorithm. Most of the rest of the improvement comes from using parametric super-surfaces. <p> Most of the rest of the improvement comes from using parametric super-surfaces. Note that the tessellations produced by using our parametrically constructed super-surfaces also satisfy quality constraints not satisfied by the static LODs of <ref> [KMZH97] </ref>. To test the performance of our system, we rendered a variety of Bezier surface models on several SGI platforms, as shown in Table 1. Fortunately a polygonal form of the submarine model was also available to compare our approach to direct polygonal rendering.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed NURB surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Ray tracing, pixel level subdivision and scan-line based algorithms have been used in the past to render surfaces. However, none of these are quite efficient on current graphics systems. In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces <ref> [RHD89, AES91, LC93, PR95, KML96] </ref>. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used [KMZH97].
Reference: [NCG91] <institution> Initial graphics exchange specification (iges) version 5.1. National Computer Graphics Association, </institution> <year> 1991. </year>
Reference-contexts: Section 4 describes the pipeline management. Section 5 discusses our system implementation and analyzes its performance. Finally, conclusions are presented in Section 6. 2 Model Representation We assume that the input is specified as an unordered list of triangular Bezier or NURBS surface patches (as in an iges <ref> [NCG91] </ref> file). Optionally, each surface patch may include trimming curves specified in Bezier, NURBS, or piece-wise linear forms. While representing smooth curves as polygonal chains is contrary to our design philosophy, many real-world models do maintain a dense sampling of the trimming curves.
Reference: [Pea97] <author> L. Piegl and W. Tiller et al. Nlib, </author> <title> an object-based user-oriented nurbs library (a companion to the nurbs book), </title> <note> 1997. (Also see, NuGraphs system at http://www.okino.com/nrs/nrs.htm). </note>
Reference-contexts: With the exception of [KMZH97], most other surface rendering systems are known to be more than a hundred times slower than sLIB . In addition, these systems <ref> [Ake93, DN93, Pea97] </ref> are little more than a collection of functions for evaluating properties of NURBS surfaces and for triangulating them; they do not form a comprehensive rendering system. Compared to the performance of [KMZH97], sLIB achieves a speed-up of about 1.5-2.5.
Reference: [Per97] <author> Iris performer, </author> <year> 1997. </year> <note> http://www.sgi.com/Technology/Performer/technical.html. </note>
Reference-contexts: It turned out to be too rigid and did not provide enough freedom to configure the pipeline the way we sometimes needed. We believe that our system is first of its kind for rendering large surface models. Good systems <ref> [Per97, 3di97, VIS97] </ref> for efficient rendering management are available, but none are designed for dynamic surface tessellation, nor are they flexible enough to allow the types of experiments we are interested in.
Reference: [PR95] <author> L. Piegl and A. Richard. </author> <title> Tessellating trimmed NURBS surfaces. </title> <booktitle> Computer Aided Geometric Design, </booktitle> <address> 27(1):1626, </address> <year> 1995. </year>
Reference-contexts: Ray tracing, pixel level subdivision and scan-line based algorithms have been used in the past to render surfaces. However, none of these are quite efficient on current graphics systems. In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces <ref> [RHD89, AES91, LC93, PR95, KML96] </ref>. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used [KMZH97].
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> ACM Computer Graphics, 23(3):107117, 1989. (SIGGRAPH Proceedings). </booktitle>
Reference-contexts: Moreover, it seems unnatural that in order to render surfaces, we first generate a large number of triangles and then find a way to reduce the count. On the other hand, efficient techniques for dynamic surface tessellation <ref> [RHD89, AES91, KML96, KMZH97] </ref> have made it possible to approximate surfaces with a small number of triangles in the first place. Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches [XV96, Hop97]. <p> Ray tracing, pixel level subdivision and scan-line based algorithms have been used in the past to render surfaces. However, none of these are quite efficient on current graphics systems. In order to exploit fast triangle rendering hardware, recent research has focussed on generating polygonal approximations of surfaces <ref> [RHD89, AES91, LC93, PR95, KML96] </ref>. A combination of on-line tessellation (for high-detail objects) and off-line tessellation combined with multiple levels of detail (for low-detail objects) has also been used [KMZH97].
Reference: [VIS97] <institution> Hewlett-packard visualize graphics, </institution> <year> 1997. </year> <note> http://www.hp.com/wsg/products/grfx/grfxhome.html. </note>
Reference-contexts: It turned out to be too rigid and did not provide enough freedom to configure the pipeline the way we sometimes needed. We believe that our system is first of its kind for rendering large surface models. Good systems <ref> [Per97, 3di97, VIS97] </ref> for efficient rendering management are available, but none are designed for dynamic surface tessellation, nor are they flexible enough to allow the types of experiments we are interested in.
Reference: [XV96] <author> J. Xia and A. Varshney. </author> <title> A dynamic view-dependent simplification for polygonal models. </title> <booktitle> In Proc. IEEE Visualization, </booktitle> <pages> pages 327334, </pages> <address> San Fransisco, CA, </address> <year> 1996. </year> <month> 8 </month>
Reference-contexts: Furthermore, the surface representation provides much finer control on the update of detail as compared to purely polygonal approaches <ref> [XV96, Hop97] </ref>. The dynamic tessellation approach also promises to be more scalable and efficient, in general. While the model sizes will continue to grow, the representation for the model-subset that must be processed every frame need not grow linearly.
References-found: 23

