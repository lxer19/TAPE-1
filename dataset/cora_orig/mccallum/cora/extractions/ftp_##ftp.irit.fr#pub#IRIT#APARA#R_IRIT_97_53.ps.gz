URL: ftp://ftp.irit.fr/pub/IRIT/APARA/R_IRIT_97_53.ps.gz
Refering-URL: http://www.irit.fr/ACTIVITES/EQ_APARA/publi_equipe.html
Root-URL: 
Title: RAPPORT  High level synthesis of a coprocessor for Grbner basis computations  
Author: INTERNE Tanguy Risset and Yannick Saouter 
Pubnum: N- 97-53-R  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F.J. Mac Williams and N.J.A. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> Amsterdam: North-Holland, </publisher> <year> 1977. </year>
Reference: [2] <author> B. </author> <title> Buchberger. An algorithm for finding a basis for the residue class ring of a zero-dimensional polynomial ideal. </title> <type> PhD thesis, </type> <institution> Math. Inst. University of Innsbruck, Austria, </institution> <year> 1965. </year>
Reference-contexts: 1 Introduction Grobner basis were introduced by Bruno Buchberger <ref> [2] </ref> in 1965 in the context of computations in residue classes of polynomial rings. This concept has many applications in symbolic computations [3, 4], but also in computational non-linear geometry, in automatic geometry proving and in modeling theory (see [5] for a survey of references). <p> Grobner basis, given a set of generators F = ff 1 ; :::; f t g A f0g of the ideal (F ), are computed by the Buchberger's algorithm whose correctness proof is to be found in <ref> [2] </ref>: Algorithm A Input: F , . * Initialization: Set G = F and B = fff 1 ; f 2 g j f 1 ; f 2 2 F; f 1 6= f 2 g. * Step 1: If B = ;, then Stop. * Step 2: Choose ff 1
Reference: [3] <author> M. Sweedler. </author> <title> Using Grobner bases to determine the algebraic and transcendental nature of field extensions: return of the killer tag variables. </title> <booktitle> In Proc. 10th International Symposium, AAECC-10, </booktitle> <pages> pages 66-75, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Grobner basis were introduced by Bruno Buchberger [2] in 1965 in the context of computations in residue classes of polynomial rings. This concept has many applications in symbolic computations <ref> [3, 4] </ref>, but also in computational non-linear geometry, in automatic geometry proving and in modeling theory (see [5] for a survey of references). However those fields do not require real-time application and thus dedicated hardware is not necessary.
Reference: [4] <author> B. </author> <title> Buchberger. A survey on the method of Grobner bases for solving problems in connection with systems of multivariate polynomials. </title> <booktitle> In Proc. 2nd Int. Symp. on Symbolic and Algebraic Computation by Computers, </booktitle> <pages> pages 7-1-7-15, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Grobner basis were introduced by Bruno Buchberger [2] in 1965 in the context of computations in residue classes of polynomial rings. This concept has many applications in symbolic computations <ref> [3, 4] </ref>, but also in computational non-linear geometry, in automatic geometry proving and in modeling theory (see [5] for a survey of references). However those fields do not require real-time application and thus dedicated hardware is not necessary. <p> If the relation F ! is confluent then F is said to be a Grobner basis of (F ). The reader will referred again to <ref> [4, p B23] </ref> to have a proof of the fact that any ideal of multivariate polynomial has Grobner basis. An important property is the following one: Theorem 2.1 Let F = ff 1 ; :::; f t g A f0g be a Grobner basis of the ideal (F ).
Reference: [5] <author> Yannick Saouter Tanguy Risset. </author> <title> A linear systolic array for the computation of grobner basis. </title> <type> Technical Report Internal Publication 1069, </type> <institution> IRISA, Rennes, France, </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction Grobner basis were introduced by Bruno Buchberger [2] in 1965 in the context of computations in residue classes of polynomial rings. This concept has many applications in symbolic computations [3, 4], but also in computational non-linear geometry, in automatic geometry proving and in modeling theory (see <ref> [5] </ref> for a survey of references). However those fields do not require real-time application and thus dedicated hardware is not necessary. Grobner basis have also applications in robotics [6, 7], but the power of computation needed to fit real-time constraints is far away from what is possible in current technology. <p> This, of course, simplify the implementation of the operateurs of the Galois field: Xor for the addition and And for the multiplication. The version of this architecture extended to K = GF (p n ) has been study in <ref> [5] </ref>, and the principles are quite similar (the problem of deriving efficient operators for computations in Galois fields has already been studied and some regular [12, 14] and irregular [15] architecturesg have been proposed). We will describe an architecture for GF (2)[X; Y ]. <p> These two coefficients are added in the last cell of the array which is connected to the host. The internal architecture of this array is precisely described in <ref> [5] </ref>. Note that one communication channel on figure 1 actually stands for three channels (for , x and y). Hence the multiplier of the first cell represent two integer adder (adding the powers for x and y) and one Galois multiplier which is implemented with an And.
Reference: [6] <author> S. Losch. </author> <title> Parallel redundant manipulator based on open and closed normal Assur chains. </title> <editor> In J-P. Merlet and B. Ravani, editors, </editor> <booktitle> Computational Kinematics, </booktitle> <pages> pages 251-260. </pages> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference-contexts: However those fields do not require real-time application and thus dedicated hardware is not necessary. Grobner basis have also applications in robotics <ref> [6, 7] </ref>, but the power of computation needed to fit real-time constraints is far away from what is possible in current technology.
Reference: [7] <author> D. Lazard. </author> <title> Stewart platforms and Grobner basis. In Proc. of Advance in Robot Kinematics, </title> <year> 1992. </year>
Reference-contexts: However those fields do not require real-time application and thus dedicated hardware is not necessary. Grobner basis have also applications in robotics <ref> [6, 7] </ref>, but the power of computation needed to fit real-time constraints is far away from what is possible in current technology.
Reference: [8] <author> S.M. Jennings. </author> <title> A Grobner basis view of the Welch-Berlekamp algorithm for Reed-Solomon codes. </title> <journal> IEE Proceedings Communications, </journal> <volume> 142(6) </volume> <pages> 349-351, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Grobner basis have also applications in robotics [6, 7], but the power of computation needed to fit real-time constraints is far away from what is possible in current technology. In recent years, several applications of Grobner basis have appeared in the field of decoding error-correcting codes (Reed-Solomon codes <ref> [8] </ref>, BCH and quadratic residue codes [9], abelian codes [10]). We present in this article a linear systolic array for implementation of Grobner basis algorithms at real-time speed. In section 2, we introduce the context of Grobner basis and the Buchberger's algorithm.
Reference: [9] <author> X. Chen, I.S. Reed, T. </author> <title> Helleseth, and T.K. Truong. Use of Grobner bases to decode binary cyclic codes up to the true minimum distance. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 40(5) </volume> <pages> 1654-1661, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: In recent years, several applications of Grobner basis have appeared in the field of decoding error-correcting codes (Reed-Solomon codes [8], BCH and quadratic residue codes <ref> [9] </ref>, abelian codes [10]). We present in this article a linear systolic array for implementation of Grobner basis algorithms at real-time speed. In section 2, we introduce the context of Grobner basis and the Buchberger's algorithm. In section 3, we precise the choices for the implementation.
Reference: [10] <author> H. Chabanne. </author> <title> Permutation decoding of abelian codes. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 38(6) </volume> <pages> 1826-1829, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In recent years, several applications of Grobner basis have appeared in the field of decoding error-correcting codes (Reed-Solomon codes [8], BCH and quadratic residue codes [9], abelian codes <ref> [10] </ref>). We present in this article a linear systolic array for implementation of Grobner basis algorithms at real-time speed. In section 2, we introduce the context of Grobner basis and the Buchberger's algorithm. In section 3, we precise the choices for the implementation. <p> The layout of an array of 5 cells is represented on figure 2. 6 A case study: Chabanne's decoding of Jensen code In this section, we present the performances of Chabanne's decoding algorithm for two-dimensional codes <ref> [10] </ref>. Institut de Recherche en Informatique de Toulouse High level synthesis of a co-processor for Grobner basis computations 9 6.1 Principles of the decoding We illustrate here the use of the circuit by an example. We consider Cha-banne's decoding for Jensen's code of article [10]. <p> Chabanne's decoding algorithm for two-dimensional codes <ref> [10] </ref>. Institut de Recherche en Informatique de Toulouse High level synthesis of a co-processor for Grobner basis computations 9 6.1 Principles of the decoding We illustrate here the use of the circuit by an example. We consider Cha-banne's decoding for Jensen's code of article [10]. This code is a binary bivariate code whose words are 45 bits large. These words are made from 17 bits of user information together with 28 redundancy bits (see [20]). <p> (computed by MuPAD [21]) is composed of the 4 following polynomials: p 1 = X 3 + 1 +1 +Y 2 + Y + 1 +Y + 1 The principle of Chabanne's decoding algorithm is the following one (the exact proof of correctness of this decoding scheme is described in <ref> [10] </ref>). If the message m is received, one converts it into a bivariate polynomial M over fX; Y g. <p> Thus we recover the error committed during transmission. As pointed out in article <ref> [10] </ref>, this method enables to erase most of the errors up to the correction power of the binary code. However, depending on the ordering of terms used, some errors may resist.
Reference: [11] <author> L. Robbiano. </author> <title> The Curves Seminar at Queens's Volume V. </title> <institution> Queen's University, </institution> <year> 1988. </year> <title> Institut de Recherche en Informatique de Toulouse High level synthesis of a co-processor for Grobner basis computations 13 </title>
Reference-contexts: In section 6, we tackle a practical decoding example and show a case study where hardware implementation is useful. 2 Definitions and theorems In this section we briefly present the notions about Grobner basis in rings of multivariate polynomials. We refer the reader to <ref> [11] </ref> for a full course on the subject. Let K [X 1 ; X 2 ; :::; X n ] be the ring of polynomials with n indeterminates and coefficients over the field K.
Reference: [12] <author> A. Poli and L. </author> <title> Huguet. Error correcting codes: Theory and applications. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: number of polynomials generated by Buchberger's algorithm, we will show how to implement the basic operations of reduction and of computation of the S-polynomial in a linear systolic array. 3 Using Grobner basis for error correcting codes Grobner basis are used in multi-variable codes (semi simple codes, abelian codes, see <ref> [12] </ref> for a survey). <p> The version of this architecture extended to K = GF (p n ) has been study in [5], and the principles are quite similar (the problem of deriving efficient operators for computations in Galois fields has already been studied and some regular <ref> [12, 14] </ref> and irregular [15] architecturesg have been proposed). We will describe an architecture for GF (2)[X; Y ]. <p> Here, I is generated by: g = X 2 :Y 12 + X 2 :Y 5 + X 2 :Y 3 + X 2 + X:Y 10 + X:Y 9 + X:Y 6 + X + Y 14 + Y 13 as may be computed by Reed's formula <ref> [12] </ref>, when given the 28 zeroes of the code.
Reference: [13] <author> R.J. Mac Eliece. </author> <title> Finite Fields for Computer Scientists and Engineers. </title> <publisher> Kluwer, </publisher> <year> 1987. </year>
Reference-contexts: These codes manipulate elements of K [X 1 ; : : : ; X n ]=I where K is a finite field (or Galois field, GF (p n ) see <ref> [13] </ref>), and I is an ideal of K [X 1 ; : : : ; X n ]. The reduction operator and the computation of the S-polynomial are very often used when computing in K [X 1 ; : : : ; X n ]=I.
Reference: [14] <author> C.S. Yeh, </author> <title> I.S. Reed, and T.K. Truong. Systolic multipliers for finite fields GF(2 m ). IEEE Trans. </title> <booktitle> Comp., </booktitle> <address> C-33(4):357-360, </address> <year> 1984. </year>
Reference-contexts: The version of this architecture extended to K = GF (p n ) has been study in [5], and the principles are quite similar (the problem of deriving efficient operators for computations in Galois fields has already been studied and some regular <ref> [12, 14] </ref> and irregular [15] architecturesg have been proposed). We will describe an architecture for GF (2)[X; Y ].
Reference: [15] <author> H. Brunner, A. Curiger, and M. </author> <title> Hofstetter. </title> <journal> On computing multiplicative inverses in GF(2 m ). IEEE Trans. Comp., </journal> <volume> 48(8) </volume> <pages> 1010-1015, </pages> <year> 1993. </year>
Reference-contexts: The version of this architecture extended to K = GF (p n ) has been study in [5], and the principles are quite similar (the problem of deriving efficient operators for computations in Galois fields has already been studied and some regular [12, 14] and irregular <ref> [15] </ref> architecturesg have been proposed). We will describe an architecture for GF (2)[X; Y ].
Reference: [16] <author> H.T. Kung. </author> <title> Why systolic architectures? Computer, </title> <booktitle> 15(1) </booktitle> <pages> 37-46, </pages> <year> 1982. </year>
Reference-contexts: This model is synchronous, communications with the host are known statically <ref> [16] </ref>. The array is unidirectional (all communication channels go in the same direction), thus the algorithm can be partitioned and completed in several passes if the array is not big enough (LPGS partitioning [17]). Finally, this model can be implemented either in asic or fpga technology. <p> Finally, note that these algorithms might directly be implemented with FIFO files, but we choose a systolic design, since most of data exchanges with the host are known statically <ref> [16] </ref>. 4 The systolic array 4.1 Architecture The systolic array (see figure 1) is composed of three types of processors (or cells). The first and the last cell are special ones and will be dedicated to the steps 1, 1' and 2 of the algorithm B.
Reference: [17] <author> D.I. Moldovan and J.A.B. Fortes. </author> <title> Partitioning and mapping algorithms into fixed-size systolic arrays. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(1) </volume> <pages> 1-12, </pages> <month> jan </month> <year> 1986. </year>
Reference-contexts: This model is synchronous, communications with the host are known statically [16]. The array is unidirectional (all communication channels go in the same direction), thus the algorithm can be partitioned and completed in several passes if the array is not big enough (LPGS partitioning <ref> [17] </ref>). Finally, this model can be implemented either in asic or fpga technology. We have choosen to represent a polynomial as a linked list of triplets ( i ; x i ; y i ), where i is boolean and x i , y i are integers.
Reference: [18] <author> D. K. Wilde. </author> <title> The Alpha language. </title> <type> Research Report 999, </type> <institution> IRISA, Campus de Beaulieu, </institution> <address> 35042 Rennes Cedex, France, </address> <month> Jan </month> <year> 1994. </year>
Reference-contexts: This section explains how we have used the Alpha tool as a help for the designer. 5.1 Methodology The methodology we have used is the following one: first we described the array with the Alpha language <ref> [18, 19] </ref> which allow high level description, then we simulated it at the functional level. Then we automatically translated this specification into vhdl code which can be synthesized by commercial tools.
Reference: [19] <author> P. Le Moenner, L. Perraudeau, S. Rajopadhye, T. Risset, and P. </author> <title> Quinton. Generating regular arithmetic circuits with AlpHard. </title> <booktitle> In Massively Parallel Computing Systems (MPCS'96), </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: This section explains how we have used the Alpha tool as a help for the designer. 5.1 Methodology The methodology we have used is the following one: first we described the array with the Alpha language <ref> [18, 19] </ref> which allow high level description, then we simulated it at the functional level. Then we automatically translated this specification into vhdl code which can be synthesized by commercial tools.
Reference: [20] <author> J.M. Jensen. </author> <title> The concatenated structure of cyclic and abelian codes. </title> <journal> IEEE Tr. Inform. Theory, </journal> <volume> IT-31:788-793, </volume> <year> 1985. </year>
Reference-contexts: We consider Cha-banne's decoding for Jensen's code of article [10]. This code is a binary bivariate code whose words are 45 bits large. These words are made from 17 bits of user information together with 28 redundancy bits (see <ref> [20] </ref>). Code-words are binary chains representing coefficient of polynomials in an ideal I of A = GF (2)[X; Y ]=(X 3 + 1; Y 15 + 1).
Reference: [21] <author> The MuPAD Group (Benno Fuchssteiner et al.). </author> <title> MuPAD User's Manual. </title> <publisher> John Wiley and sons, </publisher> <address> Chichester, New York, first edition, </address> <month> March </month> <year> 1996. </year> <institution> Rapport de Recherche n-97-53-R </institution>
Reference-contexts: The Grobner base of the ideal I (computed by MuPAD <ref> [21] </ref>) is composed of the 4 following polynomials: p 1 = X 3 + 1 +1 +Y 2 + Y + 1 +Y + 1 The principle of Chabanne's decoding algorithm is the following one (the exact proof of correctness of this decoding scheme is described in [10]).
References-found: 21

