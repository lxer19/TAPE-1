URL: http://www.cs.ucsd.edu/~calder/papers/MICRO-95-Branch.ps.Z
Refering-URL: http://www.cs.ucsd.edu/~calder/papers.html
Root-URL: http://www.cs.ucsd.edu
Email: calder,grunwald@cs.colorado.edu emer@vssad.hlo.dec.com  
Title: System Level Perspective on Branch Architecture Performance  
Author: Brad Calder Dirk Grunwald Joel Emer 
Address: Campus Box 430 77 Reed Road (HLO2-3/J3) Boulder, CO 80302-0430 Hudson, MA 01749  
Affiliation: Department of Computer Science Digital Semiconductor University of Colorado,  
Note: A  
Abstract: This paper appeared in the 28th Intl. Symp. on Microarchitecture Abstract Accurate instruction fetch and branch prediction is increasingly important on today's wide-issue architectures. Fetch prediction is the process of determining the next instruction to request from the memory subsystem. Branch prediction is the process of predicting the likely out-come of branch instructions. Many branch and fetch prediction architectures have been proposed, from simple static techniques to more sophisticated hardware designs. All these previous studies compare differing branch prediction architectures in terms of misprediction rates, branch penalties, or an idealized cycles per instruction. This paper provides a system-level performance comparison of several branch architectures using a full pipeline-level architectural simulator. The performance of various branch architectures is reported using execution time and cycles-per-instruction. For the programs we measured, our simulations show that having no branch prediction increases the execution time by 27%. By comparison, a highly accurate 512 entry branch target buffer architecture has an increased execution time of 1.5% when compared to an architecture with perfect branch prediction. We also show that the most commonly used branch performance metrics, branch misprediction rates and the branch execution penalty, are highly correlated with program performance and are suitable metrics for architectural studies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian N. Bershad, Dennis Lee, Theodore H. Romer, and J. Bradley Chen. </author> <title> Avoiding conflict misses dynamically in large direct-mapped caches. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 158-170, </pages> <address> San Jose, California, </address> <year> 1994. </year>
Reference-contexts: The layout of pages in memory will cause cache conflicts in the physically indexed 2nd level cache and those penalties can be significant <ref> [1, 6] </ref>. For instance, the percent of cycles increased by 27% for tomcatv and decreased 10% for gzip when the virtual and physical mappings were identical.
Reference: [2] <author> Brad Calder and Dirk Grunwald. </author> <title> Fast & accurate instruction fetch and branch prediction. </title> <booktitle> In 21st Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 2-11. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: All of the BTB designs we simulated only update the BTB with taken branch addresses. This was shown to be more effective for both the coupled and decoupled architectures because the BTB is not filled with fall-through addresses that are easily calculated <ref> [2, 12] </ref>. Therefore, on a BTB miss for the coupled design, the branch is predicted as not taken. The other static prediction alternative is to predict the branch using the BTFNT scheme on a BTB miss.
Reference: [3] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing branch costs via branch alignment. </title> <booktitle> In 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 242-251. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: In our studies we have found that statically predicting the branches as not-taken performs better than BTFNT in this case, especially when compiler transformations are used to make the fall through path the most likely executed path <ref> [3] </ref>. 4 Branch Architecture Performance Throughout this section, the reader should be aware of the limitations of our study, and should not draw inferences beyond the systems we model. In particular, the Alpha AXP 21064 is a statically scheduled, dual-issue processor.
Reference: [4] <author> Brad Calder and Dirk Grunwald. </author> <title> Next cache line and set prediction. </title> <booktitle> In 22nd Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 287-296. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: For future architectures to be viable, they must achieve similar (or better) performance for cheaper hardware costs and make no sacrifice in cycle time <ref> [4] </ref>. Table 4 lets us directly compare the performance of decoupled GAg and coupled PAs architectures with equivalent BTB sizes.
Reference: [5] <institution> Digital Equipment Corperation, Maynard, </institution> <address> Mass. </address> <note> DECchip 21064 Microprocessor: Hardware Reference Manual, Oc-tober 1992. </note>
Reference-contexts: There is a 512KByte second-level, unified direct-mapped cache with five cycle latency and access time. Main memory has a 24 cycle latency and 30 cycle access time. More information about the AXP 21064 can be found in the processor reference manual <ref> [5] </ref>.
Reference: [6] <author> R. Kessler and M. Hill. </author> <title> Page placement algorithms for large direct-mapped real-index caches. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 338-359, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The layout of pages in memory will cause cache conflicts in the physically indexed 2nd level cache and those penalties can be significant <ref> [1, 6] </ref>. For instance, the percent of cycles increased by 27% for tomcatv and decreased 10% for gzip when the virtual and physical mappings were identical.
Reference: [7] <author> Johnny K. F. Lee and Alan Jay Smith. </author> <title> Branch prediction strategies and branch target buffer design. </title> <journal> IEEE Computer, </journal> <volume> 21(7) </volume> <pages> 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: His method used the exclusive-or of the global history register and the branch address as the index into the PHT (PHT-GAg). Branch target buffers (BTB) have been used as a mechanism for branch and instruction fetch prediction, effectively predicting the behavior of a branch <ref> [7, 9, 12, 17] </ref>. The In-tel Pentium is an example of a modern architecture using a BTB it has a 256-entry BTB organized as a four-way associative cache. Only branches that are taken are entered into the BTB. <p> The BTB-2Bit architecture models the architecture used in the Pentium, where each BTB entry contains a two-bit saturating counter to predict the direction of a conditional branch <ref> [7] </ref>. The Intel P6 architecture adds to this design by increasing the BTB to a 512 entry 4-way associative design and replaces the 2-bit counters with 4-bit history registers. Perfect All branches are correctly predicted, so there are no mispredict nor any misfetch penalties. No-Pred No Branch Prediction.
Reference: [8] <author> Scott McFarling. </author> <title> Combining branch predictors. </title> <address> TN 36, DEC-WRL, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The register is used as an index into the pattern history table (PHT), much as the program counter is used for a direct-mapped PHT. This provides contextual information and correlation about particular patterns of branches. For the GAg method that we model, we use a variant described by McFarling <ref> [8] </ref>. His method used the exclusive-or of the global history register and the branch address as the index into the PHT (PHT-GAg). Branch target buffers (BTB) have been used as a mechanism for branch and instruction fetch prediction, effectively predicting the behavior of a branch [7, 9, 12, 17].
Reference: [9] <author> Scott McFarling and John Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In 13th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 396-403. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: His method used the exclusive-or of the global history register and the branch address as the index into the PHT (PHT-GAg). Branch target buffers (BTB) have been used as a mechanism for branch and instruction fetch prediction, effectively predicting the behavior of a branch <ref> [7, 9, 12, 17] </ref>. The In-tel Pentium is an example of a modern architecture using a BTB it has a 256-entry BTB organized as a four-way associative cache. Only branches that are taken are entered into the BTB.
Reference: [10] <author> Ravi Nair. </author> <title> Optimal 2-bit branch predictors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(5) </volume> <pages> 698-702, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Thus, the BTFNT rule is used the first time the branch is encountered, and a dynamic one-bit predictor is used thereafter. Two-bit up-down saturating counters have been shown to effectively predict the direction of conditional branches and to outperform 1-bit branch predictors <ref> [10, 13] </ref>. The pattern history table (PHT) branch architecture is an example of an architecture using two-bit saturating up-down counters. It contains a table of two-bit counters used to predict the direction for conditional branches.
Reference: [11] <author> S.-T. Pan, K. So, and J. T. Rahmeh. </author> <title> Improving the accuracy of dynamic branch prediction using branch correlation. </title> <booktitle> In Fifth International Conference on Architectural Support for Programming Languagesand Operating Systems, </booktitle> <pages> pages 76-84, </pages> <address> Boston, Mass., </address> <month> October </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: It contains a table of two-bit counters used to predict the direction for conditional branches. In the direct mapped PHT architecture (PHT-Direct), the branch address is used to directly index into the pattern history table to find the two-bit counter to use when predicting the branch. Pan et al. <ref> [11] </ref> and Yeh and Patt [16, 18] investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch. The degenerate method (GAg) of Pan et al. [11] uses a global history <p> Pan et al. <ref> [11] </ref> and Yeh and Patt [16, 18] investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch. The degenerate method (GAg) of Pan et al. [11] uses a global history register to record the branch correlation.
Reference: [12] <author> Chris Perleberg and Alan Jay Smith. </author> <title> Branch target buffer design and optimization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(4) </volume> <pages> 396-412, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: His method used the exclusive-or of the global history register and the branch address as the index into the PHT (PHT-GAg). Branch target buffers (BTB) have been used as a mechanism for branch and instruction fetch prediction, effectively predicting the behavior of a branch <ref> [7, 9, 12, 17] </ref>. The In-tel Pentium is an example of a modern architecture using a BTB it has a 256-entry BTB organized as a four-way associative cache. Only branches that are taken are entered into the BTB. <p> All of the BTB designs we simulated only update the BTB with taken branch addresses. This was shown to be more effective for both the coupled and decoupled architectures because the BTB is not filled with fall-through addresses that are easily calculated <ref> [2, 12] </ref>. Therefore, on a BTB miss for the coupled design, the branch is predicted as not taken. The other static prediction alternative is to predict the branch using the BTFNT scheme on a BTB miss.
Reference: [13] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In 8th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 135-148. </pages> <publisher> ACM, </publisher> <year> 1981. </year>
Reference-contexts: Thus, the BTFNT rule is used the first time the branch is encountered, and a dynamic one-bit predictor is used thereafter. Two-bit up-down saturating counters have been shown to effectively predict the direction of conditional branches and to outperform 1-bit branch predictors <ref> [10, 13] </ref>. The pattern history table (PHT) branch architecture is an example of an architecture using two-bit saturating up-down counters. It contains a table of two-bit counters used to predict the direction for conditional branches.
Reference: [14] <author> S. Peter Song, Marvin Denman, and Joe Chang. </author> <title> The Pow-erPC 604 RISC microprocessor. </title> <journal> IEEE Micro, </journal> <volume> 14(5) </volume> <pages> 8-17, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The BTB-GAg is an example of a decoupled design, where the branch prediction information is not associated with the BTB and is used for all conditional branches, including those not recorded in the BTB. This design is used in the PowerPC 604 <ref> [14] </ref>. The PowerPC 604 has a 64-entry fully associative BTB that holds the target address of the most recently taken branches, and uses a separate 512 entry PHT to predict the direction of conditional branches. We simulated a number of configurations of these architectures.
Reference: [15] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In 1994 Programming Language Design and Implementation, </booktitle> <pages> pages 196-205. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Zippy is a direct-execution simulator; the program being measured is executed, and events generated by the program execution are fed to an event-driven simulator. The version of Zippy we used in this study used the ATOM instrumentation system <ref> [15] </ref> to instrument the applications. A considerable amount of analysis can be performed during the instrumentation phase. For example, interlocks and dependence between instructions can be computed statically.
Reference: [16] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> Alternative implementations of two-level adaptive branch predictions. </title> <booktitle> In 19th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 124-134, </pages> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: In the direct mapped PHT architecture (PHT-Direct), the branch address is used to directly index into the pattern history table to find the two-bit counter to use when predicting the branch. Pan et al. [11] and Yeh and Patt <ref> [16, 18] </ref> investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch.
Reference: [17] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A comprehensive instruction fetch mechanism for a processor supporting speculative execution. </title> <booktitle> In 25th International Symposium on Microar-chitecture, </booktitle> <pages> pages 129-139, </pages> <address> Portland, Or, </address> <month> December </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: We record the percentage of misfetched branches (%MfB) and the percentage of mispredicted branches (%MpB). It is often difficult to understand how these metrics interact and how they influence processor performance. Yeh & Patt <ref> [17] </ref> defined a formula to combine these branch penalties called the branch execution penalty: BEP = %MfB fi misfetch penalty + %MpB fi mispred penalty 100 which reflects the average penalty suffered by a branch due to misfetch and misprediction. <p> His method used the exclusive-or of the global history register and the branch address as the index into the PHT (PHT-GAg). Branch target buffers (BTB) have been used as a mechanism for branch and instruction fetch prediction, effectively predicting the behavior of a branch <ref> [7, 9, 12, 17] </ref>. The In-tel Pentium is an example of a modern architecture using a BTB it has a 256-entry BTB organized as a four-way associative cache. Only branches that are taken are entered into the BTB. <p> Infinite BTB's An infinite BTB that only suffers from misprediction and cold-starts misses. We simulated this model for both the PAs and GAg (XOR) conditional branch prediction schemes. Table 3: Architectures Simulated The BTB-PAs architecture models the architecture proposed by Yeh et al <ref> [17] </ref>, where each BTB entry contains a 6-bit history register. This history register is used as the lower bits of an index into a PHT when predicting conditional branches. The upper bits of the index are the lower bits of the branch address.
Reference: [18] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In 20th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 257-266, </pages> <address> San Diego, CA, </address> <month> May </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: In the direct mapped PHT architecture (PHT-Direct), the branch address is used to directly index into the pattern history table to find the two-bit counter to use when predicting the branch. Pan et al. [11] and Yeh and Patt <ref> [16, 18] </ref> investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch.
References-found: 18

