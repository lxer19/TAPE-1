URL: http://www.csl.sri.com/~munoz/Papers/pbs.ps.gz
Refering-URL: http://www.csl.sri.com/~munoz/publis.html
Root-URL: 
Email: Email: munoz@csl.sri.com  
Phone: Tel: +1 (650) 859-2784, Fax: +1 (650) 859-2844  
Title: Supporting the B-method in PVS: An Approach to the Abstract Machine Notation in Type Theory  
Author: Cesar Mu~noz 
Address: 333 Ravenswood Avenue Menlo Park, CA 94025, USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: The B-method is a state-oriented formal method for software development. It provides a uniform language, namely the Abstract Machine Notation, to specify, design, and implement systems. The underlying logic of the method is a set theory with a first-order predicate calculus. On the other hand, PVS is a specification language integrated with a theorem prover. The logical framework of PVS is a higher-order logic with a type system. PVS does not come with a particular built-in software construction methodology. In this paper we show how the abstract machine notation can be embedded in PVS. The contributions of this work point in two directions. In one sense, the PVS system is enhanced with a methodology for software development and a notation for specifications (those of B), and in the other sense, the abstract machine notation is enriched with a full-typed specification language and a powerful theorem prover (those of PVS). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-R. </author> <title> Abrial. The B method for large software. specification, design and coding (abstract). </title> <editor> In Soren Prehn and Hans Toetenel, editors, </editor> <booktitle> Proceedings of Formal Software Development Methods (VDM '91), volume 552 of LNCS, </booktitle> <pages> pages 398-405, </pages> <address> Berlin, Germany, </address> <month> October </month> <year> 1991. </year> <note> Springer. 6 </note>
Reference-contexts: In this paper we are interested in two formalisms: the B method [2] and the PVS system [13]. The B method originated in Abrial's work <ref> [1] </ref> in the 1980's and continues to be developed by industrial and academic working groups. fl This research was supported by National Science Foundation grant CCR-9509931. It provides a uniform language to specify, design, and implement systems. Commercial tools supporting the method are available.
Reference: [2] <author> J.-R. </author> <title> Abrial. The B-Book Assigning programs to meanings. </title> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: In [8], a group of researchers in formal methods pointed out how the integration of different languages becomes necessary in order to handle different aspects of a system. In this paper we are interested in two formalisms: the B method <ref> [2] </ref> and the PVS system [13]. The B method originated in Abrial's work [1] in the 1980's and continues to be developed by industrial and academic working groups. fl This research was supported by National Science Foundation grant CCR-9509931. It provides a uniform language to specify, design, and implement systems. <p> For example, C.H. Pratten presents in [14] a tool that generates a PVS representation of abstract machine proof obligations. This translation conforms the standard semantics of B given in <ref> [2] </ref>. S. Agerholm presents in [3] a method for translating VDM-SL specifications to PVS. This embedding is said to be shallow, since it transforms VDM-SL constructs in similar PVS constructs, thus the semantics of the VDM-SL specifications is not preserved. S. Maharaj and J. <p> In one sense, the PVS system is enhanced with a methodology for software development from the formal specification to the implementation, and in the other sense, the abstract machine notation is enriched with a full-typed specification language and a powerful theorem prover. We have rewritten several examples particularly from <ref> [10, 2, 4] </ref>. The results obtained are satisfactory according to our expectations: trivial conditions are discharged automatically by the type checker and most of the proof obligations can be solved by using the decision procedures provided by the theorem prover.
Reference: [3] <author> S. Agerholm. </author> <title> Translating specifications in VDM-SL to PVS. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 1125 </volume> <pages> 1-16, </pages> <year> 1996. </year>
Reference-contexts: In particular the proof obligations guarantee that the initial state satisfy the invariant and that the invariant is preserved by the operations. A similar approach to this one has been explored before in the case of the embedding of VDM-SL specifications in PVS <ref> [3, 11] </ref>, and in a re-working of a Z specification in PVS [15]. No proof obligations are generated about the existence of parameters, sets and constants satisfying the machine constraints, and we assume this fact as an axiom. However, we plan to support this feature in the future. <p> For example, C.H. Pratten presents in [14] a tool that generates a PVS representation of abstract machine proof obligations. This translation conforms the standard semantics of B given in [2]. S. Agerholm presents in <ref> [3] </ref> a method for translating VDM-SL specifications to PVS. This embedding is said to be shallow, since it transforms VDM-SL constructs in similar PVS constructs, thus the semantics of the VDM-SL specifications is not preserved. S. Maharaj and J.
Reference: [4] <author> Teesside B-Resource. </author> <title> Examples and case studies using AMN and B. </title> <note> Electronically available at http://www-scm.tees.ac.uk/bresource/welcome.html. </note>
Reference-contexts: In one sense, the PVS system is enhanced with a methodology for software development from the formal specification to the implementation, and in the other sense, the abstract machine notation is enriched with a full-typed specification language and a powerful theorem prover. We have rewritten several examples particularly from <ref> [10, 2, 4] </ref>. The results obtained are satisfactory according to our expectations: trivial conditions are discharged automatically by the type checker and most of the proof obligations can be solved by using the decision procedures provided by the theorem prover.
Reference: [5] <author> J. Bicarregui et al. </author> <title> Formal methods into practice: case studies in the application of the B method. </title> <journal> IEEE Proceedings on Software Engineering, </journal> <volume> 144(2), </volume> <year> 1997. </year>
Reference-contexts: If r is a binary relation, dom (r) and ran (r) stand respectively for the domain and range of r, and !x.P is the universal quantification of x in P. 3 Weakness of B A number of case studies developed in B are reported in <ref> [5] </ref>. They range over diverse kinds of applications and they study different aspects of the software development. This work has served as the start point of our approach.
Reference: [6] <author> J. Bicarregui and B. Ritchie. </author> <title> Invariants, frames and postconditions: a comparison of the VDM and B notations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 79-89, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Although they have the same expressiveness than before-after predicates, they encourage to write algorithmic specifications. For some complex operations a before-after predicate could be more convenient. The same remark has been drawn by J. Bi carregui and B. Ritchie in <ref> [6] </ref>. * A limited support to data types. In particular, record types are absent in the B notation. * Proof obligations usually deal with type conditions that could be easily solved by a type checker. * B imposes a very rigid discipline.
Reference: [7] <author> P. Chartier. </author> <title> Formalisation of B in Isabelle/HOL. </title> <booktitle> To appear in the proceedings of the Second B International Conference, </booktitle> <address> Montpellier, France, </address> <month> April </month> <year> 1998, 1998. </year>
Reference-contexts: For example, M.J.C. Gordon proposes in [12] an embedding of a simple imperative programming language and the Hoare logic in HOL (a general specification language and theorem prover) and more recently P. Chartier formalizes the abstract machine notation of B in Isabelle/HOL <ref> [7] </ref>. These deep embedding allow to prove meta-theoretical properties of the specifications, but the proof of properties for a particular specification requires a painful codification. One of the aims of this approach is the formalization of tools like proof obligation generators or proof-checkers.
Reference: [8] <author> E.M. Clarke, J.M. Wing, et al. </author> <title> Formal methods: state of the art and future directions. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4) </volume> <pages> 626-643, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In this context, several methods, notations and tools, each one emphasizing some aspects of the software development, concur in the goal to produce safe systems. In <ref> [8] </ref>, a group of researchers in formal methods pointed out how the integration of different languages becomes necessary in order to handle different aspects of a system. In this paper we are interested in two formalisms: the B method [2] and the PVS system [13].
Reference: [9] <author> J. Dick. </author> <title> Abstract machine notation - BNF definition of the ASCII syntax. </title> <note> Electronically available at http://www-scm.tees.ac.uk/bresource/welcome.html. This work is copyrighted by B-Core (UK) Ltd., </note> <year> 1995. </year>
Reference-contexts: Acknowledgments I'm very grateful to the members of the Formal Methods Group of the Computer Science Laboratory at SRI for their useful comments about this work, and in particular to N. Shankar, J. Rushby, P. Habermehl and H. Sadi. In <ref> [9] </ref>, J. Dick describes a complete BNF for the abstract machine notation grammar. Dick's work was an excellent guide to define the BNF for the grammar of PVS machines.
Reference: [10] <author> K. Lano and H. Haughton. </author> <title> Specification in B. </title> <publisher> Imperial College Press, </publisher> <year> 1996. </year>
Reference-contexts: In one sense, the PVS system is enhanced with a methodology for software development from the formal specification to the implementation, and in the other sense, the abstract machine notation is enriched with a full-typed specification language and a powerful theorem prover. We have rewritten several examples particularly from <ref> [10, 2, 4] </ref>. The results obtained are satisfactory according to our expectations: trivial conditions are discharged automatically by the type checker and most of the proof obligations can be solved by using the decision procedures provided by the theorem prover.
Reference: [11] <author> S. Maharaj and J. Bicarregui. </author> <title> On the verification of VDM specification and refinement with PVS. </title> <booktitle> In 12th IEEE International Conference on Automated Software Engineering: ASE '97, </booktitle> <pages> pages 280-289, </pages> <address> Incline Village, NV, </address> <month> November </month> <year> 1997. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: In particular the proof obligations guarantee that the initial state satisfy the invariant and that the invariant is preserved by the operations. A similar approach to this one has been explored before in the case of the embedding of VDM-SL specifications in PVS <ref> [3, 11] </ref>, and in a re-working of a Z specification in PVS [15]. No proof obligations are generated about the existence of parameters, sets and constants satisfying the machine constraints, and we assume this fact as an axiom. However, we plan to support this feature in the future. <p> S. Agerholm presents in [3] a method for translating VDM-SL specifications to PVS. This embedding is said to be shallow, since it transforms VDM-SL constructs in similar PVS constructs, thus the semantics of the VDM-SL specifications is not preserved. S. Maharaj and J. Bicarregui propose in <ref> [11] </ref> an extension of this approach in order to support refinements. In the case of Z, D.W.J. Stringer-Calvert, S. Stepney and I. Wand present in [15] a re-reworking of a Z specification using the higher-order logic and type system of PVS. <p> The interpretation of invariants, pre-conditions and post-conditions that we describe here, is very close to that proposed in these works, and in particular in Agerholm's work. The approach that we have taken to validate refinements is different to this one proposed in <ref> [11] </ref>. In that work, the proof obligations about the soundness of the refinement are not handled by the type system (as it is in our case), but they are seen as conjectures in the theory.
Reference: [12] <author> M.J.C. Gordon. </author> <title> Mechanizing programming logics in higher-order logic. </title> <editor> In G.M. Birtwistle and P.A. Sub-rahmanyam, editors, </editor> <booktitle> Current Trends in Hardware Verification and Automatic Theorem Proving (Proceedings of the Workshop on Hardware Verification), </booktitle> <pages> pages 387-439, </pages> <address> Banff, Canada, 1988. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: It is also possible to exploit the specification language of the proof checker in order to formalize the semantics of the method. For example, M.J.C. Gordon proposes in <ref> [12] </ref> an embedding of a simple imperative programming language and the Hoare logic in HOL (a general specification language and theorem prover) and more recently P. Chartier formalizes the abstract machine notation of B in Isabelle/HOL [7].
Reference: [13] <author> S. Owre, J.M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 607, </volume> <year> 1992. </year>
Reference-contexts: In [8], a group of researchers in formal methods pointed out how the integration of different languages becomes necessary in order to handle different aspects of a system. In this paper we are interested in two formalisms: the B method [2] and the PVS system <ref> [13] </ref>. The B method originated in Abrial's work [1] in the 1980's and continues to be developed by industrial and academic working groups. fl This research was supported by National Science Foundation grant CCR-9509931. It provides a uniform language to specify, design, and implement systems.
Reference: [14] <author> C.H. Pratten. </author> <title> An introduction to proving AMN specifications with PVS and the AMN-PROOF tool. </title> <editor> In Henri HABRIAS, editor, </editor> <booktitle> Proc. Z Twenty Years on What is its Future, </booktitle> <pages> pages 149-165. </pages> <address> IRIN-IUT de Nantes, </address> <month> Octo-ber </month> <year> 1995. </year>
Reference-contexts: A first approach is to assist the validation process of specifications in these notations by means of a powerful general theorem prover as PVS. For example, C.H. Pratten presents in <ref> [14] </ref> a tool that generates a PVS representation of abstract machine proof obligations. This translation conforms the standard semantics of B given in [2]. S. Agerholm presents in [3] a method for translating VDM-SL specifications to PVS.
Reference: [15] <author> D.W.J. Stringer-Calvert, S. Stepney, and I. Wand. </author> <title> Using PVS to prove a Z refinement: A case study. </title> <booktitle> In Formal Methods Europe FME '97, volume 1313 of Lecture Notes in Computer Science, </booktitle> <pages> pages 573-588, </pages> <address> Graz, Austria, </address> <month> September </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: A similar approach to this one has been explored before in the case of the embedding of VDM-SL specifications in PVS [3, 11], and in a re-working of a Z specification in PVS <ref> [15] </ref>. No proof obligations are generated about the existence of parameters, sets and constants satisfying the machine constraints, and we assume this fact as an axiom. However, we plan to support this feature in the future. Certain kind of compositions are supported by using the importing mechanism of PVS. <p> S. Maharaj and J. Bicarregui propose in [11] an extension of this approach in order to support refinements. In the case of Z, D.W.J. Stringer-Calvert, S. Stepney and I. Wand present in <ref> [15] </ref> a re-reworking of a Z specification using the higher-order logic and type system of PVS. The interpretation of invariants, pre-conditions and post-conditions that we describe here, is very close to that proposed in these works, and in particular in Agerholm's work.
Reference: [16] <author> J. Vitt and J. Hooman. </author> <title> Assertional specification and verification using PVS of the steam boiler control system. </title> <editor> In Jean-Raymond Abrial, Egon Boerger, and Hans Langmaack, editors, </editor> <title> Formal Methods for Industrial Applications: Specifying and Programming the Steam Boiler Control, </title> <booktitle> volume 1165 of Lecture Notes in Computer Science, </booktitle> <pages> pages 453-472. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
References-found: 16

