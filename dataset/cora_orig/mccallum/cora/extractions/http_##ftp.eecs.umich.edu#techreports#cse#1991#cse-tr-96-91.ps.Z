URL: http://ftp.eecs.umich.edu/techreports/cse/1991/cse-tr-96-91.ps.Z
Refering-URL: http://ftp.eecs.umich.edu/techreports/cse/1991/
Root-URL: http://www.eecs.umich.edu
Title: A Concurrency Control Protocol for Nested Transactions  
Author: Ming-Ling Lo and C. V. Ravishankar 
Address: Michigan-Ann Arbor Ann Arbor, MI 48109-2122  
Affiliation: Computer Sciences Division University of  
Abstract: Nested transactions provide fine grain atomicity, efficient recovery control, and structural modularity. In distributed environments, they provide a natural and semantically clean way of modeling computations. However, the characteristics of nested transactions are sufficiently different from those of traditional single-level transactions that concurrency control for nested transactions needs to be reconsidered in order to exploit all their advantages. In this paper, we explore a new concurrency control method for nested transactions, and introduces the notion of a request list for the purpose. Our objectives are to provide shorter transaction turn-around times and better system throughput. These goals are accomplished by exploiting intra-transaction concurrency and by reducing the time a transaction has to wait for consistent data states. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Reed, </author> <title> "Implementing atomic object on decentralized data," </title> <journal> ACM, TOCS, </journal> <month> Feb </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Non-determinism is a primary difficulty in distributed computing. Transaction systems <ref> [1] </ref> have been successfully used to cope with some aspects of this problem since they provide atomicity, recoverability, and, in most cases, serializability. However, the traditional transaction model is not appropriate for all of the computations.
Reference: [2] <author> J. Moss, </author> <title> "Nested transactions: An approach to reliable distributed computing," </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Most notably, it has been criticized as too heavy-weight because of the all-or-nothing commit and abort protocol, and that under some circumstances, such as when there are communication or invocation relationships between transactions, their behavior is still hard to grasp. Nested transactions <ref> [2] </ref> are a preferred model for long or complex transactions since they offer fine grain fault atomicity, more efficient recovery control and structural modularity. <p> Top-level commit is also called external commit. In single-level transaction system, an operation is either visible to all the other transactions, or is invisible. For nested transactions, however, because of their hierarchical structure, the visibility problem becomes complicated. According to the semantics of nested transactions <ref> [2] </ref>, the following visibility principle for commitment of operations should be observed: 1. Top-level commit is visible to every operation. That is, an operation from a committed top-level transaction is considered committed by all the other operations in the system. 2. <p> Concurrency control protocols for nested transactions must enforce the visibility of internal commits. For locking methods, shadow copies can be used to enforce correct visibility <ref> [2] </ref>. This approach, however, involves the costs of copying and inheriting the shadows. <p> We then focus on the reduction of the three major costs in the history mechanisms: cost of observers, that of mutators, and that of retries. The result is a control protocol that can potentially explore concurrency better than pure locking <ref> [2, 8] </ref> and pure timestamp ordering [9].
Reference: [3] <author> B. Liskov and R. Schiefer, </author> <title> "Guardians and actions: Linguistic support for robust, distributed programs," </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, No. 3, </volume> <pages> pp. 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: This is basically the way Argus <ref> [3] </ref> handles its intra-transaction concurrency control. However, this improvement is still unsatisfactory for the following reasons: 1. <p> Even when the serialization ordering requirements are available, performance is still unsatisfactory if two subtransactions of relation SS are executed sequentially. 3 History Mechanism for Single-level Transactions The abstraction of history has been used [4] to support the implementation of atomic objects <ref> [3, 5] </ref> and designed to meet the demand of systems with long transactions or with localized concurrency bottlenecks (hot-spots). It provides the basis for our concurrency control mechanism for nested transactions. Long transactions can be caused by human interactions or other I/O activities (communicating over long-haul networks) within computations.
Reference: [4] <author> T. Ng, </author> <title> "Using history to implement atomic objects," </title> <journal> ACM, TOCS, </journal> <month> Nov </month> <year> 1989. </year>
Reference-contexts: For example, it may depend on the parameters of invocation calls. 3. Even when the serialization ordering requirements are available, performance is still unsatisfactory if two subtransactions of relation SS are executed sequentially. 3 History Mechanism for Single-level Transactions The abstraction of history has been used <ref> [4] </ref> to support the implementation of atomic objects [3, 5] and designed to meet the demand of systems with long transactions or with localized concurrency bottlenecks (hot-spots). It provides the basis for our concurrency control mechanism for nested transactions. <p> 1 and t 2 is yet unknown, we 7 assume the serialization order between them could either be (t 1 ; t 2 ) or (t 2 ; t 1 ), or that one of the operations might be aborted. 3.2 Possible Serialized Sequences The notion of possible serialized sequences <ref> [4] </ref> is a central idea used in the history mechanism to synchronize operations on the same data object. A possible serialized sequence of a history is defined as a sequence of transitions including all the committed transitions and preserving all precedence relations in O. <p> The ordering of the operations within the sequence reflects the serialization ordering of these operations. Operation x appears before operation y in T if and only if x should be serialized before y. * C is the set of all committed operations on D. As in the history mechanism <ref> [4] </ref> operations are classified into observers and mutators. If an operation both changes the objects state of data object and retrieves information form it, it assumes the roles of a both mutator and an observer. <p> When a mutator is committed or aborted, all epoch serialized after this mutator must adjust their candidate states accordingly. If all mutators before an epoch has committed, the set of candidate states associated with this epoch is a singleton. The main difference between the history mechanism <ref> [4] </ref> and request list is that the ordering between two operations in a history may be unknown, while that of two operation in a request list is always known. <p> The transaction may also choose to abort the observer after some number of retries. Retry is a serious problem for the original history mechanism, as stated in <ref> [4] </ref>. First, there is an overhead of communication between the transaction site and the data object 20 site, when a operation is rejected by the data object and retried by the transaction later.
Reference: [5] <author> W. Weihl and B.Liskov, </author> <title> "Implementation of resilient, atomic data types," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 7, no. 2, </volume> <pages> pp. 244-269, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Even when the serialization ordering requirements are available, performance is still unsatisfactory if two subtransactions of relation SS are executed sequentially. 3 History Mechanism for Single-level Transactions The abstraction of history has been used [4] to support the implementation of atomic objects <ref> [3, 5] </ref> and designed to meet the demand of systems with long transactions or with localized concurrency bottlenecks (hot-spots). It provides the basis for our concurrency control mechanism for nested transactions. Long transactions can be caused by human interactions or other I/O activities (communicating over long-haul networks) within computations.
Reference: [6] <author> W. Cellary, E. Gelenbe, and T. Morzy, </author> <title> "Concurrency control in distributed database systems, </title> <address> chap 1-7 and chap 11-12," </address> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: We discuss some of these issues below. 6.1 Performance Failures One of the main issues here is deadlock. Deadlock can never occur across two nested transactions in our model, because timestamp ordering is used to order two nested transaction and timestamp ordering is free from deadlock <ref> [6, 7] </ref>. Deadlock can not occur for subtransactions within the same nested transaction either because a serial precedence number is assigned to the subtransactions in the current algorithm. Cyclic retry cannot occur either. It cannot occur across two nested transactions since timestamp ordering is used.
Reference: [7] <author> C. Papadimitriou, </author> <title> "Database concurrency control," </title> <publisher> Computer science press, </publisher> <year> 1990. </year>
Reference-contexts: We discuss some of these issues below. 6.1 Performance Failures One of the main issues here is deadlock. Deadlock can never occur across two nested transactions in our model, because timestamp ordering is used to order two nested transaction and timestamp ordering is free from deadlock <ref> [6, 7] </ref>. Deadlock can not occur for subtransactions within the same nested transaction either because a serial precedence number is assigned to the subtransactions in the current algorithm. Cyclic retry cannot occur either. It cannot occur across two nested transactions since timestamp ordering is used.
Reference: [8] <author> A. Fekete and et al, </author> <title> "Nested transactions and read/rrite locking," </title> <booktitle> Proceeding 6th Symp. on principles of database systems, </booktitle> <pages> pp. 97-111, </pages> <year> 1987. </year>
Reference-contexts: We then focus on the reduction of the three major costs in the history mechanisms: cost of observers, that of mutators, and that of retries. The result is a control protocol that can potentially explore concurrency better than pure locking <ref> [2, 8] </ref> and pure timestamp ordering [9].
Reference: [9] <author> J. Aspnes and et al, </author> <title> "A theory of timestamp-based concurrency control for nested transactions," </title> <booktitle> Proceedings 14th international conference on very large data bases, </booktitle> <year> 1988. </year> <month> 25 </month>
Reference-contexts: We then focus on the reduction of the three major costs in the history mechanisms: cost of observers, that of mutators, and that of retries. The result is a control protocol that can potentially explore concurrency better than pure locking [2, 8] and pure timestamp ordering <ref> [9] </ref>.
References-found: 9

