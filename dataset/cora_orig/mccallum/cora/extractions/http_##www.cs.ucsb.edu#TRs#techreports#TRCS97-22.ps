URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS97-22.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: http://www.cs.ucsb.edu/oocsb  
Title: Introduction to the SUIF 2.0 Compiler System  
Author: Holger Kienle and Urs Holzle 
Date: December 10, 1997  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Pubnum: Technical Report TRCS97-22  
Abstract-found: 0
Intro-found: 0
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Similarly, the upper and lower bounds for an array type 20 and the offset for a field in a group type can be omitted. SUIF distinguishes between structural equivalence and name equivalence of types <ref> [ASU86] </ref>. Name equivalence is used for group types 21 and enumerations (enumerated type). These types have names (like symbols). All other types use structural equivalence and hence have no name.
Reference: [CD93] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In contrast, SUIF 1.0 assumes that the field offsets are known. * Its interpretation framework allows any piece of SUIF code to be evaluated by providing an interpreter class for each dialect. This functionality might be useful for constant folding and partial evaluation <ref> [CD93] </ref>. Furthermore, the interpreter code serves as the exact definition of what a dialect means. 29 * SUIF 2.0 passes can be composed in memory; SUIF 1.0 required file I/O in order to sequentially execute passes.
Reference: [CFRW91] <author> R. Cytron, J. Ferrante, B. K. Rosen, and M. N. Wegman. </author> <title> Efficiently computing static single assignment form and the control dependency graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Instructions for arrays are almost analogous to group types, with the only difference that an index must be given instead of a field symbol. * The ssa phi instruction represents the SSA operator <ref> [CFRW91] </ref>.
Reference: [DCI + 97] <author> A. Duncan, B. Cocosel, C. Iancu, H. Kienle, R. Rugina, U. Holzle, and M. Rinard. OSUIF: </author> <title> SUIF with objects. </title> <booktitle> Proceedings of the Second SUIF Compiler Workshop, </booktitle> <pages> pages 1-7, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: One way to achieve this is to use semantic properties. Note that SUIF 2.0 does not extend the functionality of SUIF 1.0 towards non-imperative languages, but provides far better support for implementing those extensions. Object SUIF (OSUIF) <ref> [DCI + 97] </ref>, which is currently developed at UCSB, is such an extension for object-oriented languages.
Reference: [GHJV94] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns | Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: necessary) or nil if the forwarded object is not in memory. 7 References to objects that are out-of-memory and in the same zio are first initialized to nil and "backpatched" as soon as the object is in memory. 9 The zot level also introduces the interface for the visitor pattern <ref> [GHJV94] </ref> (see figure 1). The zot visitor is implemented with the class zot visitor. A visitor class contains methods to visit all SUIF IR constructs that the library defines. The default implementation is to do nothing. A visitor can be customized by subclassing from it.
Reference: [GJ87] <author> Carlo Ghezzi and Medhi Jazayeri. </author> <title> Programming Language Concepts. </title> <publisher> John Wiley & Sons, </publisher> <year> 1987. </year>
Reference-contexts: If so, the existing type is returned; otherwise, a new type is constructed. 19 Such a type corresponds to a function prototype with empty parameter list in K&R C. 20 This does not mean that SUIF supports dynamic arrays (like Ada and Java) or flexible arrays (like APL and CLU) <ref> [GJ87] </ref>. A subsequent pass must specify at least the lower bound before code can be generated for an array. 21 Note that SUIF's notion of type equivalence for group types resembles Pascal records, but differs from C structs. 17 18 Furthermore, the suif library defines concrete instructions (see figure 5).
Reference: [KH97] <author> Holger Kienle and Urs Holzle. j2s: </author> <title> A SUIF Java compiler. </title> <booktitle> Proceedings of the Second SUIF Compiler Workshop, </booktitle> <pages> pages 8-15, </pages> <month> August </month> <year> 1997. </year> <note> Also available as Technical Report TRCS97-16, </note> <institution> Department of Computer Science, University of California Santa Barbara. </institution>
Reference-contexts: The manual is basically a fleshed-out version of the SUIF 2.0 tutorial given by Chris Wilson at the Second SUIF Compiler Workshop [Wil97c]. It also contains some insights into SUIF 2.0 that we gained while implementing a Java front end for SUIF 2.0 <ref> [KH97] </ref>. Many thanks to Chris Wilson for patiently answering all our questions concerning SUIF 2.0. 2 We don't expect that the reader is familiar with the SUIF 1.0 compiler system, but knowing SUIF 1.0 might be beneficial.
Reference: [Str97] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1997. </year>
Reference-contexts: The sty library is not compiler-specific, but designed for interfaces between modules. It makes extensive use of C++ templates. The question why SUIF 2.0 does not make use of the C++ Standard Template Library (STL) <ref> [Str97] </ref> comes naturally to mind. At design time, STL was not widely available. Furthermore, STL uses exceptions, but many C++ compilers have trouble supporting them. <p> Standard SUIF requires that an incomplete group type is empty (i.e., it does not contain any fields). 18 Incomplete group types in standard SUIF correspond to forward declarations in C++ <ref> [Str97] </ref>.
Reference: [Wil97a] <author> Chris Wilson. </author> <title> Private email communication, </title> <month> August </month> <year> 1997. </year>
Reference-contexts: Certainly everybody will agree that zot sounds a whole lot better than "thingy." The last library name, suif, turns out to stand for precisely what its name suggests, namely the topmost library of the SUIF 2.0 system|pretty disappointing, huh? <ref> [Wil97a] </ref>. 4 ments, etc. This library is explained in more detail in section 5. 5. The suif library defines concrete SUIF IR constructs, for example, classes for integer types, arithmetic instructions, control flow statements, etc. This library is explained in more detail in section 6.
Reference: [Wil97b] <author> Chris Wilson. </author> <title> Private email communication, </title> <month> November </month> <year> 1997. </year>
Reference-contexts: Hence, every zot object can be represented as either a forwarder or a nfzot. The generic forwarder class has not been implemented because there seems to be no application that requires to subclass from forwarder <ref> [Wil97b] </ref>. Typically, a user will extend azot or a class that inherits from azot. The zref class is a more convenient wrapper for an object reference that can either be a forwarder or a "normal" zot object.
Reference: [Wil97c] <author> Chris Wilson. </author> <title> Suif 2.0 tutorial. Given at the Second SUIF Compiler Workshop, </title> <month> August </month> <year> 1997. </year> <month> 26 </month>
Reference-contexts: statements class hierarchy . . . . . . . . . . . . . . . . 21 8 SUIF 2.0 value blocks class hierarchy . . . . . . . . . . . . . . . . 22 9 SUIF 2.0 ownership graph example <ref> [Wil97c] </ref> . . . . . . . . . . . . 23 2 1 Purpose of this Manual This manual is intended to give a brief overview of the new SUIF 2.0 compiler system 1 . <p> It is not meant to be a detailed description of the interface. The manual is basically a fleshed-out version of the SUIF 2.0 tutorial given by Chris Wilson at the Second SUIF Compiler Workshop <ref> [Wil97c] </ref>. It also contains some insights into SUIF 2.0 that we gained while implementing a Java front end for SUIF 2.0 [KH97]. <p> At design time, STL was not widely available. Furthermore, STL uses exceptions, but many C++ compilers have trouble supporting them. There are other|more subjective|reasons, for example, STL makes extensive use of standard operator overloading, whereas SUIF seldom uses it. 5 <ref> [Wil97c] </ref> 4 The zot Library This library is used in the SUIF system to model a flexible extensibility scheme that makes it possible to put new kinds of objects into the preexisting hierarchy of SUIF constructs.
References-found: 11

