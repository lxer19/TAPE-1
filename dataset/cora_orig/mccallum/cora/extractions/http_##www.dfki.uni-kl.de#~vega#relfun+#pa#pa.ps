URL: http://www.dfki.uni-kl.de/~vega/relfun+/pa/pa.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Indexing PROLOG Procedures into DAGs by Heuristic Classification a COMMON LISP listing of the main
Author: Michael Sintek 
Note: The paper includes  
Date: May 5, 1994  
Address: Postfach 2080 67608 Kaiserslautern Germany  
Affiliation: DFKI  
Abstract: This paper first gives an overview of standard PROLOG indexing and then shows, in a step-by-step manner, how it can be improved by slightly extending the WAM indexing instruction set to allow indexing on multiple arguments. Heuristics are described that overcome the difficulty of computing the indexing WAM code. In order to become independent from a concrete WAM instruction set, an abstract graphical representation based on DAGs (called DAXes) is introduced. The ideas described in this paper were first presented at the Workshop "Sprachen fur KI-Anwendungen, Konzepte - Methoden Implementierun-gen" 1992 in Bad Honnef [SS92]. This paper is part of a collaborative work together with Werner Stein [Ste92]. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [AK90] <author> Hassan At-Kaci. </author> <title> The WAM: A (Real) Tutorial. </title> <type> Report 5, </type> <institution> Digital, Paris Research Laboratory, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: For more details on the WAM, refer to [War83], [GLLO85], <ref> [AK90] </ref>, and [Nys85]. <p> The main difference between database and PROLOG indexing is that the former handles a set of items while the latter deals with a (textually ordered) sequence of items (since PROLOG clauses are tried from top to bottom). The standard PROLOG indexing method described in [War83], [GLLO85], and <ref> [AK90] </ref> uses the first argument of each procedure for indexing. In the less example, the first clause has to be tried only if the first argument is the constant 0 or a free variable. <p> 2 1 get_constant 0, X1 proceed 2 allocate 0 get_structure s/1, X1 % less (s ( unify_variable X3 % M), get_structure s/1, X2 % s ( unify_variable X4 % N)) :- put_value X3, X1 % put_value X4, X2 call less/2, 0 % less (M, N). deallocate proceed Hassan At-Kaci in <ref> [AK90] </ref> called this the three-level-indexing scheme: level WAM instructions I discrimination on type switch on term (constant, structure, list, empty list, and variable) II discrimination on value switch on constant (only for constants and structures) switch on structure III enumeration of clauses try, retry, trust If the first argument of a
Reference: [BBB + 89] <editor> H. Benker, J. Beacco, S. Bescos, M. Dorochevsky, Th. Jeffre, A. Pohlmann, J. Noye, B. Poterie, A. Sexton, J.C. Syre, O. Thibault, and G. Watzlawik. KCM: </editor> <booktitle> A Knowledge Crunching Machine. </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: two examples of section 4, less and f, are used. 9.1 less less (0,N). % clause 1 less (s (M), s (N)) :- less (M, N). % clause 2 2 thus an extension of the standard WAM switching instructions is needed on the concrete level: either (as in the KCM <ref> [BBB + 89] </ref>) add an additional argument to all three switching instructions, or (as in our approach) add one new instruction (set index number n; see appendix B) to change the value of an index register (IX) which is looked up by the switch instructions 9.2 f 12 fail fail .
Reference: [BEHK91] <author> Harold Boley, Klaus Elsbernd, Hans-Guenther Hein, and Thomas Krause. </author> <title> RFM Manual: Compiling RELFUN into the Relational/Functional Machine. Document D-91-03, </title> <institution> DFKI GmbH, </institution> <year> 1991. </year>
Reference-contexts: One of the most important features of the RELFUN compiler is a special language between the RELFUN language and the low-level WAM code. This language, called "classified clauses", was developed by Harold Boley and Thomas Krause <ref> [BEHK91, Kra90, Kra91] </ref> and is based on a tagged PROLOG-in-LISP syntax, extended with global and local information. The right place to collect all indexing information which is necessary for our indexing scheme is this intermediate language.
Reference: [BHH + 91] <author> Harold Boley, Philipp Hanschke, Martin Harm, Knut Hinkelmann, Thomas Labisch, Manfred Meyer, Jorg Muller, Thomas Oltzen, Michael Sintek, Werner Stein, and Frank Steinle. CAD2NC: </author> <title> A Declarative Lathe-Workplanning Model Transforming CAD-like Geometries into Abstract NC Programs. DFKI Document D-91-15, </title> <publisher> DFKI, </publisher> <address> P.O. Box 2080, 67608 Kaiserslautern, Germany, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: 1. the first benchmark is the well known naive reverse benchmark 2. the second benchmark (dnf) is the complete program from section 11 and appendix B 3. the third test is the NET DATALOG benchmark; NET is an automatically generated (from a constraint net) tool-selection program for an NC-program generator <ref> [BHH + 91] </ref>; its task is to select a cutting tool for turning a given workpiece on a CNC-lathe machine Since the --WAM was conceived as a didactic prototype written in higher-level LISP, not as a PROLOG product, the absolute values are not yet competitive with well known production PROLOGs.
Reference: [Bol90] <author> Harold Boley. </author> <title> A Relational/Functional Language and Its Compilation into the WAM. </title> <type> SEKI Report SR-90-05, </type> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Still, in that case only the header code for the index tree has to be reorganized; the old clauses themselves need not to be recompiled. 12.3 Compiling Higher Order PROLOG Extensions In <ref> [Bol90] </ref> Harold Boley described how to reduce higher-order RELFUN clauses to constant-operator clauses. The second-order characteristics of the constant-operator fact transitive (ancestor). is dependent on ancestor's use as a first-order relation: 31 12.3 Compiling Higher Order PROLOG Extensions Rel (A,C) :- transitive (Rel), Rel (A,B), Rel (B,C). <p> The MN- and MV-Algorithms overcome this problem by looking at all arguments (see section 11.2). 17 a more efficient alternative to this transformation is implemented as part of RELFUN's compilation laboratory 32 Part IV Indexing in RELFUN 13 The RELFUN Implementation Structure Although RELFUN provides both relational and functional clauses <ref> [Bol90] </ref>, for the purpose of indexing it can be regarded as a kind of PROLOG since indexing affects the clause head and perhaps some body premises ("guards"), but never the (functional) foot. The compilation task is divided into several horizontal 18 and vertical 19 compilation steps.
Reference: [Cla85] <author> J. Clancey, W. </author> <title> Heuristic Classification. </title> <journal> Artificial Intelligence, </journal> <volume> 27 </volume> <pages> 289-350, </pages> <year> 1985. </year>
Reference-contexts: In <ref> [Cla85] </ref> heuristic classification has been identified as a widespread problem solving method.
Reference: [GLLO85] <author> John Gabriel, Tim Lindholm, E. L. Lusk, and R.A. Overbeek. </author> <title> A Tutorial on the Warren Abstract Machine for Computational Logic. </title> <type> Report ANL-84-84, </type> <institution> Argonne National Laboratory, Argonne, Illinois 60439, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: For more details on the WAM, refer to [War83], <ref> [GLLO85] </ref>, [AK90], and [Nys85]. <p> The main difference between database and PROLOG indexing is that the former handles a set of items while the latter deals with a (textually ordered) sequence of items (since PROLOG clauses are tried from top to bottom). The standard PROLOG indexing method described in [War83], <ref> [GLLO85] </ref>, and [AK90] uses the first argument of each procedure for indexing. In the less example, the first clause has to be tried only if the first argument is the constant 0 or a free variable.
Reference: [Hei89] <author> Hans-Gunther Hein. </author> <title> Adding WAM-Instructions to support Valued Clauses for the Relational/Functional Language RELFUN. </title> <note> SEKI Working Paper SWP-90-02, </note> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Our emulator is based on the --WAM ([Nys85]), a LISP implementation of the WAM ([War83]), good for rapid prototyping and experimental extensions. It was changed for handling RELFUN's functional extensions by Hans-Gunther Hein (see <ref> [Hei89] </ref>). 14 Compilation Phases 14.1 A Classifier with Indexing Heuristics The result of the MV-Algorithm that enriches the classified clauses by heuristic indexing information is described by the following EBNF: classified-procedure ::= (proc &lt;name&gt;/<n> ; &lt;n&gt; is the arity &lt;number-of-clauses&gt; &lt;indexing&gt; &lt;classified-clause-1&gt; ... &lt;classified-clause-n&gt; ) indexing ::= (indexing [ &lt;iblock&gt; ]
Reference: [Hei93] <author> Hans-Gunter Hein. </author> <title> Propagation Techniques in WAM-based Architectures | The FIDO-III Approach. </title> <note> DFKI Technical Memo TM-93-04, </note> <institution> DFKI GmbH, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: C.1 Benchmark Results 46 benchmark name target hardware time nrev : well known naive reverse benchmark 6 lines arity of procedures: 2-3 SUN 4 125 MB RAM (Lucid) no indexing 13 sec 125 MB RAM (Lucid) indexing 7 sec tool from Hans-Gunther Hein (see <ref> [Hei93] </ref>) 105 lines arity of procedures: 2-3 IVORY LISP-BOARD (Symbolics) no indexing 84 sec IVORY LISP-BOARD (Symbolics) indexing 24 sec 125 MB RAM (Lucid) no indexing 425 sec 125 MB RAM (Lucid) indexing 120 sec (author: Frank Steinle) 312 lines arity of procedures 2-3 IVORY LISP-BOARD (Symbolics) no indexing 288 sec
Reference: [HM89] <author> Timothy Hickey and Shyam Mudambi. </author> <title> Global Compilation of Prolog. </title> <journal> Journal of Logic Programming, </journal> <volume> 7 </volume> <pages> 193-230, </pages> <year> 1989. </year> <note> REFERENCES 64 </note>
Reference-contexts: They are field encoding, superimposed coding with embedded position and variables, and superimposed coding with external variables <ref> [HM89] </ref>. All these are based on the principle of n-in-m-coding which is described in the next section. 10.1.1 m-in-n-Coding In this method the value of an attribute is compressed into a binary word of width n with a fixed number of m bits set to 1. <p> For this reason the index code and the clause code become scattered over the program code. In section 4 standard WAM indexing was explained. A much more complex indexing mechanism, complete indexing, is introduced in the next section. 10.2.1 Complete Indexing In <ref> [HM89] </ref> Timothy Hickey and Shyam Mudambi present several indexing techniques based on the WAM. The first one (complete indexing) uses global information (like modes) to perform indexing. First of all the program is transformed, creating new special code for each mode that might occur for a procedure call.
Reference: [Kra90] <author> Thomas Krause. Klassifizierte relational/funktionale Klauseln: </author> <title> Eine deklarative Zwischensprache zur Generierung von Register-optimierten WAM-Instruktionen. </title> <note> SEKI Working Paper SWP-90-04, </note> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> Mai </month> <year> 1990. </year>
Reference-contexts: One of the most important features of the RELFUN compiler is a special language between the RELFUN language and the low-level WAM code. This language, called "classified clauses", was developed by Harold Boley and Thomas Krause <ref> [BEHK91, Kra90, Kra91] </ref> and is based on a tagged PROLOG-in-LISP syntax, extended with global and local information. The right place to collect all indexing information which is necessary for our indexing scheme is this intermediate language.
Reference: [Kra91] <institution> Thomas Krause. Globale Datenfluanalyse und horizontale Compilation der relational-funktionalen Sprache RELFUN. Diplomarbeit, DFKI D-91-08, Universitat Kaiserslautern, FB Informatik, </institution> <address> Postfach 3049, D-6750 Kaiserslautern, </address> <month> Marz </month> <year> 1991. </year>
Reference-contexts: One of the most important features of the RELFUN compiler is a special language between the RELFUN language and the low-level WAM code. This language, called "classified clauses", was developed by Harold Boley and Thomas Krause <ref> [BEHK91, Kra90, Kra91] </ref> and is based on a tagged PROLOG-in-LISP syntax, extended with global and local information. The right place to collect all indexing information which is necessary for our indexing scheme is this intermediate language.
Reference: [Nys85] <author> Sven Olof Nystrtm. </author> <title> NyWam A WAM Emulator Written in LISP. </title> <year> 1985. </year>
Reference-contexts: For more details on the WAM, refer to [War83], [GLLO85], [AK90], and <ref> [Nys85] </ref>.
Reference: [SS92] <author> Werner Stein and Michael Sintek. </author> <title> A Generalized Intelligent Indexing Method. </title> <booktitle> In Workshop "Sprachen fur KI-Anwendungen, Konzepte - Methoden - Implementierungen" in Bad Honnef, </booktitle> <pages> 12/92-1. </pages> <institution> Institute of Applied Mathematics and Computer Science, University of Munster, </institution> <month> May </month> <year> 1992. </year>
Reference: [Ste92] <author> Werner Stein. </author> <title> Indexing Principles for Relational Languages Applied to PROLOG Code Generation. </title> <type> Technical Report Document D-92-22, </type> <institution> DFKI GmbH, </institution> <year> 1992. </year>
Reference-contexts: . . . . . . 1,2 const 1 else3 4 1 2 5 6 13 Part III Extensions of the Standard PROLOG Indexing 10 Looking at Other Approaches In this section we provide an overview of several indexing schemes which is a slightly revised version of section 6 in <ref> [Ste92] </ref>. They can be distinguished into hardware oriented and software oriented approaches. The hardware oriented approaches are based on database techniques. A hash-function returns, for a given query, a set of clauses as potential matches. <p> or/2 ) (2) 4 norm ( or/2 ) 10 and/2 and or/2 of the hash table are presented here in the opposite order of earlier exam ples, which if of course immaterial 11 in future DAXes layout will occasionally enforce copying; in our implementation, identical sub-DAXes are always shared (see <ref> [Ste92] </ref>) 23 11.2 Using More Than One Argument (MBN, MDN, and MN) Note that the or/2 case of the struct 1 node points (`down') to the type 2 node (`depth') under the assumption that the second query argument may further index the or/2-sub-procedure. <p> This pruning is performed by the pruning algorithm explained in <ref> [Ste92] </ref> 16 . <p> for elements not occurring in any hash table For further details and an example, refer to appendices B and D. 14.2 A Code Generator with Indexing Heuristics Code generation, the second part of our implementation, is working below the level of the classified clauses and is described in detail in <ref> [Ste92] </ref>.
Reference: [War83] <author> David H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: For more details on the WAM, refer to <ref> [War83] </ref>, [GLLO85], [AK90], and [Nys85]. <p> The main difference between database and PROLOG indexing is that the former handles a set of items while the latter deals with a (textually ordered) sequence of items (since PROLOG clauses are tried from top to bottom). The standard PROLOG indexing method described in <ref> [War83] </ref>, [GLLO85], and [AK90] uses the first argument of each procedure for indexing. In the less example, the first clause has to be tried only if the first argument is the constant 0 or a free variable.
References-found: 17

