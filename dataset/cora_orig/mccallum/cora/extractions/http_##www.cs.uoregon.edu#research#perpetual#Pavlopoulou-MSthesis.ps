URL: http://www.cs.uoregon.edu/research/perpetual/Pavlopoulou-MSthesis.ps
Refering-URL: http://www.cs.uoregon.edu/research/perpetual/Residual-java.html
Root-URL: http://www.cs.uoregon.edu
Title: RESIDUAL COVERAGE MONITORING OF JAVA PROGRAMS  
Author: by Christina Pavlopoulou 
Degree: A Thesis Submitted to the Faculty of  In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: August 1997  
Affiliation: Purdue University  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 33 BIBLIOGRAPHY </institution>
Reference: [BL96] <author> T. Ball and J. Larus. </author> <title> Efficient path profiling. </title> <booktitle> In Proc. MICRO-29. IEEE, </booktitle> <year> 1996. </year>
Reference-contexts: Similarly, one can instrument only the definition if the reference post-dominates the definition and all the paths between them are definition-free. Again experimentation is needed to determine the usefulness of the approach. Another more complicated approach can be based on the path profiling algorithm described by Ball and Larus <ref> [BL96] </ref>. Essentially, the algorithm identifies distinct paths with distinct states and encodes them as integers from 0 to n 1. Minimal 1 In a rooted, directed graph G , node p pre-dominates node q if every path from the root of G to q passes through p.
Reference: [Lee97a] <author> H. Lee. </author> <title> Bit: A tool for instrumenting java bytecodes. </title> <booktitle> In Proc. </booktitle> <address> USITS, </address> <year> 1997. </year>
Reference: [Lee97b] <author> H. Lee. </author> <title> Bit: Bytecode instrumenting tool. </title> <type> Master's thesis, </type> <institution> University of Colorado, </institution> <year> 1997. </year>
Reference-contexts: Furthermore, Bytecode Instrumenting Tool (BIT) ([Lee97a], <ref> [Lee97b] </ref>) is a tool for instrumenting Java bytecodes which was developed independently of this system.
Reference: [LvH85] <author> D. Luckham and F. von Henke. </author> <title> An overview of Anna, a specification language for Ada. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 9-22, </pages> <year> 1985. </year>
Reference-contexts: The most closely related area is assertion-based testing which also uses the run-time information of instrumented programs to decide whether they conform to the desired behavior as described with a specification language. Systems implementing this technique include Anna <ref> [LvH85] </ref>, TSL [Ros91], APP [Ros95], Nana, [Mak], ADL [SH94]. Anna (ANNotated Ada) is a language extension to Ada to include facilities for formal specification of intended program behavior.
Reference: [LY96] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Update these arrays. Output line information. 2.3 Class File Format This section to describes briefly those aspects of the class file format that are critical for understanding the main implementation issues. For more details the reader can refer to <ref> [LY96] </ref>.
Reference: [Mak] <author> P. J. Maker. </author> <title> Gnu Nana: improving support for assertions and logging in c and c++ (web page). </title> <address> http://www.cs.ntu.edu.au/homepages/pjm/nana-home/. </address>
Reference-contexts: The most closely related area is assertion-based testing which also uses the run-time information of instrumented programs to decide whether they conform to the desired behavior as described with a specification language. Systems implementing this technique include Anna [LvH85], TSL [Ros91], APP [Ros95], Nana, <ref> [Mak] </ref>, ADL [SH94]. Anna (ANNotated Ada) is a language extension to Ada to include facilities for formal specification of intended program behavior. The user inserts annotations in the source program which are just comments for Ada but obey the syntactic and semantic rules of Anna.
Reference: [Ros91] <author> D. Rosenblum. </author> <title> Specifying concurrent systems with TSL. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 52-61, </pages> <year> 1991. </year>
Reference-contexts: The most closely related area is assertion-based testing which also uses the run-time information of instrumented programs to decide whether they conform to the desired behavior as described with a specification language. Systems implementing this technique include Anna [LvH85], TSL <ref> [Ros91] </ref>, APP [Ros95], Nana, [Mak], ADL [SH94]. Anna (ANNotated Ada) is a language extension to Ada to include facilities for formal specification of intended program behavior. The user inserts annotations in the source program which are just comments for Ada but obey the syntactic and semantic rules of Anna.
Reference: [Ros95] <author> D. Rosenblum. </author> <title> Towards a method of programming with assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(1) </volume> <pages> 19-31, </pages> <year> 1995. </year>
Reference-contexts: The most closely related area is assertion-based testing which also uses the run-time information of instrumented programs to decide whether they conform to the desired behavior as described with a specification language. Systems implementing this technique include Anna [LvH85], TSL [Ros91], APP <ref> [Ros95] </ref>, Nana, [Mak], ADL [SH94]. Anna (ANNotated Ada) is a language extension to Ada to include facilities for formal specification of intended program behavior. The user inserts annotations in the source program which are just comments for Ada but obey the syntactic and semantic rules of Anna.
Reference: [RW85] <author> S. Rapps and E. J. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(4) </volume> <pages> 367-375, </pages> <year> 1985. </year>
Reference-contexts: However, some test coverage criteria involve sub-paths rather than individual points. The best known of these is data flow coverage testing, in which execution of particular "definition use" pairs (what compiler writers know as "reaching definitions") is monitored. The interested reader may refer to <ref> [RW85] </ref> for definitions and an in-depth discussion of data flow testing. We consider again whether the run-time performance impact of test coverage monitoring can be made insignificant.
Reference: [SH94] <author> S. Sankar and R. Hayes. </author> <title> Specifying and testing software components using ADL. </title> <type> Technical Report SMLI TR-94-23, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The most closely related area is assertion-based testing which also uses the run-time information of instrumented programs to decide whether they conform to the desired behavior as described with a specification language. Systems implementing this technique include Anna [LvH85], TSL [Ros91], APP [Ros95], Nana, [Mak], ADL <ref> [SH94] </ref>. Anna (ANNotated Ada) is a language extension to Ada to include facilities for formal specification of intended program behavior. The user inserts annotations in the source program which are just comments for Ada but obey the syntactic and semantic rules of Anna.
Reference: [SL86] <author> D. Rosenblum S. Sankar and D. Luckham. </author> <title> Concurrent runtime checking of annotated Ada programs. </title> <booktitle> In Proceedings of the 6th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 10-35. </pages> <booktitle> Springer-Verlag-Lecture Notes in Computer Science, </booktitle> <volume> 241, </volume> <year> 1986. </year>
Reference: [SU86] <author> A. Aho R. Sethi and J. Ullman. </author> <booktitle> Compilers: Principles Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> APPENDICES 34 </note>
Reference-contexts: RESIDUAL TESTING WITH SELECTIVE MONITORING For a first proof of concept we limit the problem to selective monitoring of block coverage, i.e. which basic blocks of the user application have been executed under a test case. A basic block <ref> [SU86] </ref> is a sequence of instructions in which flow of control enters at the beginning and leaves at the end without halt or possibility of branching except at the end. <p> The main idea is sketched below and is adapted from <ref> [SU86] </ref>: 1. Scan the byte code array to determine which byte codes can be the leaders, i.e. the first byte codes of the basic blocks.
References-found: 13

