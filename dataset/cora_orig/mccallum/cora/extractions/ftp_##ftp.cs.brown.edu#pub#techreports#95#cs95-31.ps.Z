URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-31.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-31.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ole Agesen, Lars Bak, Craig Chambers, Bay-Wei Chang, Urs Holzle, John Maloney, Randall B. Smith, David Ungar, and Mario Wolczko, </author> <title> The SELF 3.0 Programmers Reference Manual, Sun Microsys-tems, </title> <publisher> Inc., </publisher> <address> Mountain View, California, USA. </address>
Reference-contexts: Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: <ref> [7, 1, 1, 2, 6, 7, 8] </ref> [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: [:7, 1, 2, 6, 7, 8:] [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: [7, 1, 1, 2, 6, 7, 8] [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: <ref> [:7, 1, 2, 6, 7, 8:] </ref> [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. Example: if (@x == UNDEF) ...; B.2. Storage Classes 157 B.2 Storage Classes Local Variable Format: $&lt;identifier&gt; Example: $foo // A local variable called foo.
Reference: [2] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: The t_uses_interface links followed by EITraversal form a spanning tree in the graph. Relative to the spanning tree, the t_uses_interface links in the underlying graph can be classified into tree edges, forward edges, back edges, and cross edges <ref> [2] </ref>: (i) If &lt;x, y&gt; is a tree edge, then y has not been visited when x is visited. EITraversal will visit y (line 13) and append y.INF into EI (D,x) before appending x.INF at line 14. Therefore, y.INF will appear before x.INF. <p> But this is contradictory to our precondition that there is no path of t_uses_interface links from y to x. Therefore, &lt;x, y&gt; cannot be a back edge. (iv) If &lt;x, y&gt; is a cross edge, then according to Lemma 5.6 of <ref> [2] </ref>, we know that the visiting of y is already completed when x is visited. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: <ref> [7, 1, 1, 2, 6, 7, 8] </ref> [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: [:7, 1, 2, 6, 7, 8:] [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: [7, 1, 1, 2, 6, 7, 8] [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: <ref> [:7, 1, 2, 6, 7, 8:] </ref> [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. Example: if (@x == UNDEF) ...; B.2. Storage Classes 157 B.2 Storage Classes Local Variable Format: $&lt;identifier&gt; Example: $foo // A local variable called foo. <p> 3 / 4 // Division 3 % 4 // Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, <p> Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. <p> $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: [2, 3, 9][2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. <ref> [ 2] </ref>[3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. <p> &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The <p> abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is <ref> [2, 3, 9, 3, 0, 3] </ref>. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. <p> 9. [ 2][3] // Return UNDEF. <ref> [2, 3, 9] </ref>[0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is <ref> [2, 9] </ref>. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. <p> B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is [:2, 3, 5, 4:] [:4, 5, 2:] + [:9:] // The result is <ref> [: 4, 5, 2, 9:] </ref> Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, 2:] - [:2:] // The result is [:4, 5:]
Reference: [3] <author> Larry Allen, Gary Fernandez, Kenneth Kane, David Leblang, Debra Minard, and John Posner, Clear-Case MultiSite: </author> <title> Supporting Geographically-Distributed Software Development, </title> <booktitle> in Proceedings of the Fifth International Workshop on Software Configuration Management, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: 3 / 4 // Division 3 % 4 // Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, <p> Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. <p> &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The <p> abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + <ref> [3, 0, 3] </ref> // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is <ref> [2, 3, 9, 3, 0, 3] </ref>. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. <p> 9. [ 2][3] // Return UNDEF. <ref> [2, 3, 9] </ref>[0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - <ref> [3] </ref> // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. <p> Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: <ref> [:2, 3, 5:] </ref> + [:4, 5:] // The result is [:2, 3, 5, 4:] [:4, 5, 2:] + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] <p> Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is <ref> [:2, 3, 5, 4:] </ref> [:4, 5, 2:] + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <p> <expression>; // Set attribute Examples: @attr = good; @attr = UNDEF; // Unset an attribute @parent = &lt;prototype&gt;; // Set parent Foreach /* 2nd argument will be evaluated only once. */ Format: foreach (&lt;id&gt;, <integer>) &lt;statement&gt; Example: foreach ($I, 30) Print ($I); Format: foreach (&lt;id&gt;, <list>) &lt;statement&gt; Example: foreach ($I, <ref> [3, 4, 5] </ref>) Print ($I); Format: foreach (&lt;id&gt;, <set>) &lt;statement&gt; Example: B.6.
Reference: [4] <author> Atria Software, Inc., </author> <title> ClearCase Product Summary, Atria Software, </title> <publisher> Inc., </publisher> <address> 24 Prime Park Way, Natick, MA 01760, </address> <year> 1995. </year>
Reference-contexts: B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is [:2, 3, 5, 4:] [:4, 5, 2:] + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: <ref> [:3, 4, 5:] </ref> * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, 2:] - [:2:] // The result is [:4, 5:] Membership Format: &lt;set&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a <p> <expression>; // Set attribute Examples: @attr = good; @attr = UNDEF; // Unset an attribute @parent = &lt;prototype&gt;; // Set parent Foreach /* 2nd argument will be evaluated only once. */ Format: foreach (&lt;id&gt;, <integer>) &lt;statement&gt; Example: foreach ($I, 30) Print ($I); Format: foreach (&lt;id&gt;, <list>) &lt;statement&gt; Example: foreach ($I, <ref> [3, 4, 5] </ref>) Print ($I); Format: foreach (&lt;id&gt;, <set>) &lt;statement&gt; Example: B.6.
Reference: [5] <institution> Atria Software, Inc., ClearCase Architecture and Database, Atria Software, Inc., </institution> <address> 24 Prime Park Way, Natick, MA 01760, </address> <month> August </month> <year> 1993 </year>
Reference-contexts: Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is <ref> [:2, 3, 5, 4:] </ref> [:4, 5, 2:] + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <p> Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is [:2, 3, 5, 4:] <ref> [:4, 5, 2:] </ref> + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, <p> B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. Integer Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is [:2, 3, 5, 4:] [:4, 5, 2:] + [:9:] // The result is <ref> [: 4, 5, 2, 9:] </ref> Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, 2:] - [:2:] // The result is [:4, 5:] <p> Operators 159 Example: [:2, 3, 5:] + [:4, 5:] // The result is [:2, 3, 5, 4:] <ref> [:4, 5, 2:] </ref> + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, 2:] - [:2:] // The result is [:4, 5:] Membership Format: &lt;set&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <set>. <p> 4:] <ref> [:4, 5, 2:] </ref> + [:9:] // The result is [: 4, 5, 2, 9:] Intersection Format: &lt;set&gt; * <set> Example: [:3, 4, 5:] * [:2, 0, 6:] // The result is [: :]. [:4, 5, 2:] *[:2:] // The result is [:2:] Set Difference Format: &lt;set&gt; - <set> Example: [:4, 5, 2:] - [:2:] // The result is [:4, 5:] Membership Format: &lt;set&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <set>. <p> <expression>; // Set attribute Examples: @attr = good; @attr = UNDEF; // Unset an attribute @parent = &lt;prototype&gt;; // Set parent Foreach /* 2nd argument will be evaluated only once. */ Format: foreach (&lt;id&gt;, <integer>) &lt;statement&gt; Example: foreach ($I, 30) Print ($I); Format: foreach (&lt;id&gt;, <list>) &lt;statement&gt; Example: foreach ($I, <ref> [3, 4, 5] </ref>) Print ($I); Format: foreach (&lt;id&gt;, <set>) &lt;statement&gt; Example: B.6.
Reference: [6] <author> Naser S. Barghouti, </author> <title> Supporting Cooperation in the MARVEL Process-Centered SDE, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 21-31, </pages> <month> December </month> <year> 1992. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 17, No. 5, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: MARVEL <ref> [6] </ref> sets the goal of supporting cooperative programming as to reduce the interference between programmers. It uses forward and backward chaining of rules to facilitate communication between programmers, and uses a two-phase locking to detect interference. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: <ref> [7, 1, 1, 2, 6, 7, 8] </ref> [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: [:7, 1, 2, 6, 7, 8:] [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: [7, 1, 1, 2, 6, 7, 8] [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: <ref> [:7, 1, 2, 6, 7, 8:] </ref> [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. Example: if (@x == UNDEF) ...; B.2. Storage Classes 157 B.2 Storage Classes Local Variable Format: $&lt;identifier&gt; Example: $foo // A local variable called foo.
Reference: [7] <author> J. G. P. Barnes, </author> <title> An Overview of Ada, </title> <journal> in Software Practice and Experience, </journal> <volume> Vol. 10, </volume> <pages> pp. 851-887, </pages> <year> 1980. </year>
Reference-contexts: CaseWare [19] uses an object-oriented build facility that stores the information about how to build a particular type of object in the object type definition itself, rather than in an external makefile. Also, the build context information is placed in objects. Ada Programming Support Environments In Ada <ref> [7] </ref>, since packages and subprograms are units of source code as well as units for compilation, the gap between handling system building and managing source code is smaller than in other languages. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: <ref> [7, 1, 1, 2, 6, 7, 8] </ref> [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: [:7, 1, 2, 6, 7, 8:] [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. <p> Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: [7, 1, 1, 2, 6, 7, 8] [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: <ref> [:7, 1, 2, 6, 7, 8:] </ref> [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned. Example: if (@x == UNDEF) ...; B.2. Storage Classes 157 B.2 Storage Classes Local Variable Format: $&lt;identifier&gt; Example: $foo // A local variable called foo.
Reference: [8] <author> N. Belkhair and J. Estublier, </author> <title> Experience with a Data Base of Programs, </title> <booktitle> in Proceedings of the 2nd ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 84-91, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Format 6: SELF Example: SELF // self. B.1.2 Structured Data Types Lists Format: [ &lt;value 1&gt;, <value 2>, ..., <value n] Example: <ref> [7, 1, 1, 2, 6, 7, 8] </ref> [ ] // Empty list. Sets Format: [: &lt;value 1&gt;, <value 2>, ..., <value n> :] Example: [:7, 1, 2, 6, 7, 8:] [::] // Empty set. B.1.3 Undefined Attribute If an attribute is undefined, the value UNDEF is returned.
Reference: [9] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio L. Melo, Adele2: </author> <title> A Support to Large Software Development Process, </title> <booktitle> in Proceedings of the First International Conference on the Software Process, </booktitle> <pages> pp. 159-170, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66]. Several process-centered environments, including Arcadia [79], MARVEL [47], OZ [10], Adele2 <ref> [9] </ref>, and Darwin [60], are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable. <p> 3 / 4 // Division 3 % 4 // Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, <p> Modulus 158 Appendix B: VERSE Comparison Examples: $i == $j $i &gt; $j $i &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. <p> &lt; $j B.4.5 String Operators String Concatenation Format: &lt;string&gt; + <string> Example: abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The <p> abc + cde // The result is abccde B.4.6 List Operators Selection Format: &lt;list&gt;[<integer>] Examples: <ref> [2, 3, 9] </ref>[2] // Return the second element, 3. [2, 3, 9][-1] // Return the last element, 9. [ 2][3] // Return UNDEF. [2, 3, 9][0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is <ref> [2, 3, 9, 3, 0, 3] </ref>. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. <p> 9. [ 2][3] // Return UNDEF. <ref> [2, 3, 9] </ref>[0] // Return UNDEF. Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is [2, 9]. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4. <p> Append Format: &lt;list&gt; + <list> Example: [2, 3, 9] + [3, 0, 3] // The result is [2, 3, 9, 3, 0, 3]. Removal Format: &lt;list1&gt; - <list2> // Elements in list2 may not appear in list1; Example: [2, 3, 9] - [3] // The result is <ref> [2, 9] </ref>. Membership Format: &lt;list&gt;.member (<element>) // Return TRUE if &lt;element&gt; is a member of <list>. B.4.7 Set Operators Union Format: &lt;set&gt; + <set> B.4.
Reference: [10] <author> Israel Z. Ben-Shaul and Gail E. Kaiser, </author> <title> A Paradigm for Decentralized Process Modeling and its Realization in the OZ Environment, </title> <booktitle> in Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pp. 179-188, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year> <note> 180 Bibliography </note>
Reference-contexts: Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66]. Several process-centered environments, including Arcadia [79], MARVEL [47], OZ <ref> [10] </ref>, Adele2 [9], and Darwin [60], are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable.
Reference: [11] <author> Jon Bentley, </author> <title> Programming Pearls, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 29, No. 5, </volume> <pages> pp. 364-369, </pages> <month> May </month> <year> 1986, </year> <journal> and Vol. </journal> <volume> 29, No. 6, </volume> <pages> pp. 471-483, </pages> <month> June </month> <year> 1986, </year>
Reference: [12] <author> Brian Berliner, CVS II: </author> <title> Parallelizing Software Development, </title> <publisher> Prisma, Inc., </publisher> <address> 5465 Mark Dabling Blvd, Colorado Springs, CO 80918. </address>
Reference-contexts: Another concern is the merging of files. Since file merging is a difficult problem that cannot be automated easily, programmers intervention is required in most cases. CVS CVS <ref> [12] </ref> is a front end to RCS. It extends the notion of revision control from a collection of files in a single directory to a hierarchical collection of directions consisting of revision controlled files. CVS keeps a single copy of the master sources called the source repository. <p> Comparison 37 have to make sure that we are using the current version of the makefile. If we do not get the correct version of makefile, the building will fail. 3.7 Comparison We conclude this chapter by comparing POEM with several existing configuration management systems, RCS, MAKE, CVS <ref> [12] </ref>, DSEE, SHAPE, ClearCase, TeamWare and Vesta [52]. RCS and MAKE represent early version control and system building tools. They complement each other and are usually used together. CVS is a more advanced version control tool based on RCS.
Reference: [13] <author> Gerard Boudier, Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> An Overview of PCTE and PCTE+, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 248-257, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 13, No. 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 2, </volume> <month> February </month> <year> 1989. </year>
Reference: [14] <author> Mark R. Brown and John R. Ellis, </author> <title> Bridges: Tools to Extend the Vesta Configuration Management System, </title> <note> DEC System Research Center Research Report No. 108, </note> <month> June </month> <year> 1993. </year>
Reference: [15] <author> P. Brown, </author> <title> Integrated Hypertext and Program Understanding Tools, </title> <journal> in IBM System Journal, </journal> <volume> Vol. 30, No. 3, </volume> <pages> pp. 363-392, </pages> <year> 1991. </year>
Reference-contexts: ClearCase and SHAPE also rely on this mechanism. 2.3 Organization of Software Artifacts The lack of associations between related software artifacts in traditional environments has long been recognized. A popular approach to this problem is to use hypertext. ISEA <ref> [15] </ref> automatically creates hyperlinks between program analysis data and hypertext documentation. Kiosk [22] uses hypertext in selecting reusable software components from software libraries. HyperWeb [33] uses hypermedia to help programmers on understanding and maintaining software. Conversation-Builder [44] also uses hypertext to describe shared objects in collaborative software development.
Reference: [16] <author> Todd Brunhoff and Jim Fulton, </author> <title> Imake C Preprocessor Interface to the Make Utility, Tektronix and MIT Project Athena, </title> <address> Cambridge, MA. </address>
Reference-contexts: However, handling libraries in MAKE is cumbersome, and mimicking the structure of an arbitrary program using at-structured libraries is difficult. There are several tools that simplify the writing of makefiles. The implicit rules of MAKE issue appropriate compilation commands according to the file name extension of source files. IMAKE <ref> [16] </ref> allows users to specify system models at a higher level by supporting a set of macros that expand into rules for makefiles. Makedepend [17] parses source programs to generate dependencies used by MAKE. However, these tools simplify only the specification of compilation rules, not that of the linking rules.
Reference: [17] <author> Todd Brunhoff and Jim Fulton, </author> <title> Makedpend - Create Dependencies in Makefiles, Tektronix and MIT Project Athena, </title> <address> Cambridge, MA. </address>
Reference-contexts: The implicit rules of MAKE issue appropriate compilation commands according to the file name extension of source files. IMAKE [16] allows users to specify system models at a higher level by supporting a set of macros that expand into rules for makefiles. Makedepend <ref> [17] </ref> parses source programs to generate dependencies used by MAKE. However, these tools simplify only the specification of compilation rules, not that of the linking rules. Users still have to specify which object files and which libraries should be linked into a specific executable file.
Reference: [18] <author> John N. Buxton and Larry E. Druffel, </author> <title> Requirements for An Ada Programming Support Environment: Rationale for STONEMAN, </title> <booktitle> in Proceedings of COMPSAC 80, </booktitle> <pages> pp. 66-72, </pages> <year> 1980. </year>
Reference-contexts: In addition, an Ada environment is responsible for deciding which units need to be recompiled based on the logical relations between them <ref> [18] </ref>. However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [61] presents one such mechanism. <p> As illustrated in Figure 4-18, traditional UNIX programming environments manage configuration with tools like MAKE and RCS that operate on files and directories. STONEMAN <ref> [18] </ref> envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. In the ECMA [25] Toaster Model, low-level configuration management is supported by a database, but higher-level activities are still carried out by separate tools.
Reference: [19] <author> Martin R. Cagan, </author> <title> Software Configuration Management Redefined, </title> <publisher> CaseWare, Inc., </publisher> <address> 108 Pacifica, Irv-ine, CA 92718, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Derived objects are not directly managed by programmers, but occasionally users still need to address them indirectly via some functions. In Vesta, derived objects are passed along as the result of building functions and are not directly managed by users. CaseWare <ref> [19] </ref> uses an object-oriented build facility that stores the information about how to build a particular type of object in the object type definition itself, rather than in an external makefile. Also, the build context information is placed in objects.
Reference: [20] <author> Sheng-Yang Chiu and Roy Levin, </author> <title> The Vesta Repository: A File System Extension for Software Development, </title> <note> DEC System Research Center Research Report No. 106, </note> <month> June </month> <year> 1993. </year>
Reference: [21] <author> W. Courington, </author> <title> The Network Software Environment, </title> <type> Technical Report Sun FE 197-0, </type> <institution> Sun Microsys-tems Inc., </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: Interfaces, realizations, is_realized relations and depends_on relations together form an acyclic graph. When building a specific version of the system, only one realization is selected for each interface. NSE and TeamWare The Network Software Environment (NSE) <ref> [21] </ref> from Sun Soft uses a database that manages the UNIX directory structure and derived files in addition to the source code. NSE supports cooperative programming via environments that represent workspaces. Workspaces support nested transactions with a protocol for merging and updating files between a child and a parent workspace.
Reference: [22] <author> Michael L. Creech, Dennis F. Freeze and Martin L. Griss, </author> <title> Using Hypertext in Selecting Reusable Software Components, </title> <booktitle> in Hypertext '91 Proceedings, </booktitle> <pages> pp. 25-38, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: A popular approach to this problem is to use hypertext. ISEA [15] automatically creates hyperlinks between program analysis data and hypertext documentation. Kiosk <ref> [22] </ref> uses hypertext in selecting reusable software components from software libraries. HyperWeb [33] uses hypermedia to help programmers on understanding and maintaining software. Conversation-Builder [44] also uses hypertext to describe shared objects in collaborative software development.
Reference: [23] <author> Susan Dart, </author> <title> Concepts in Configuration Management Systems, </title> <booktitle> in Proceedings of the 3rd International Workshop on Software Configuration Management (Peter Feiler, </booktitle> <publisher> ed.), </publisher> <pages> pp. 1-18, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Developers operate on configurations rather than individual components, and a change is performed in a transaction. Aide-de-Camp (ADC) uses the change set model. It groups related modifications to different components as a logical change. Dart analyzed and compared the concepts and functionality supported by different configuration management systems <ref> [23] </ref>. She observed that most concepts in configuration management can be seen as extensions to, or generalizations of, other concepts. She also noticed that it is hard to extract clear concepts from existing configuration management systems because there is no commonality in terminology.
Reference: [24] <author> Mark Dowson, </author> <title> ISTAR An Integrated Project Support Environment, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 27-33, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Gandalf [38], the first project to apply this notion in programming environments, proposed a module concept in which a set of versions implement a single interface. Adele [27] describes the relation between interfaces and implementations as an AND/OR graph. ISTAR <ref> [24] </ref> uses a contractual approach, in which every activity in the software process has the character of a contract. It also defines formal channels of communication between tasks. 2.6 Programming Environments and Object-Oriented Technologies Our framework is based on the object-oriented paradigm [85].
Reference: [25] <author> ECMA, </author> <title> A Reference Model for Frameworks of Software Engineering Environments (Version 2). ECMA Report Number TR/55 (Version 2), </title> <type> NIST Report Number SP 500-201, </type> <month> December </month> <year> 1991. </year>
Reference-contexts: As illustrated in Figure 4-18, traditional UNIX programming environments manage configuration with tools like MAKE and RCS that operate on files and directories. STONEMAN [18] envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. In the ECMA <ref> [25] </ref> Toaster Model, low-level configuration management is supported by a database, but higher-level activities are still carried out by separate tools. In contrast, configuration management in our framework is carried out by the operations of software units, instead of tools that are separated from the data repository.
Reference: [26] <author> J. Estublier, S. Ghoul, and S. Krakowiak, </author> <title> Preliminary Experience with a Configuration Control System for Modular Programs, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Bibliography 181 Symposium on Practical Software Develpment Environment, </booktitle> <pages> pp. 149-156, </pages> <month> April </month> <year> 1984. </year>
Reference: [27] <author> Jacky Estublier, </author> <title> A Configuration Manager: The Adele Data Base of Programs, </title> <booktitle> in Workshop on Software Engineering Environments for Programming-in-the-Large, </booktitle> <month> June </month> <year> 1985. </year>
Reference-contexts: Gandalf [38], the first project to apply this notion in programming environments, proposed a module concept in which a set of versions implement a single interface. Adele <ref> [27] </ref> describes the relation between interfaces and implementations as an AND/OR graph. ISTAR [24] uses a contractual approach, in which every activity in the software process has the character of a contract.
Reference: [28] <author> Jacky Estublier and Jean-Marie Favre, </author> <title> Structuring Large Versioned Software Products, </title> <booktitle> in Proceedings of IEEE COMPSAC 89, </booktitle> <pages> pp. 404-411, </pages> <month> September </month> <year> 1989. </year>
Reference: [29] <author> Jacky Estublier, Noureddine Belkhatir, Mohamed A. Nacer, and Walcelio L. Melo, </author> <title> Process-centered SEE and Adele, </title> <booktitle> in Proceedings of the 5th international Workshop on Computer-Aided Software Engineering (CASE 92), </booktitle> <pages> pp. </pages> <month> 156-165 July </month> <year> 1992. </year>
Reference: [30] <author> Jacky Estublier and Rubby Casallas, </author> <title> The Adele Configuration Manager, in Configuration Management (W. </title> <editor> F. Tichy, ed.), </editor> <publisher> John Wiley & Son Ltd., </publisher> <year> 1994. </year>
Reference: [31] <author> Peter H. Feiler, </author> <title> Configuration Management Models in Commercial Environments, </title> <type> Technical Report CMU/SEI-91-TR-7, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Configuration Management Systems 17 thread of DSEE allows programmers to choose versions by specifying version selection rules. SHAPE and ClearCase also supply similar functionality. Configuration Management Models and Concepts Feiler classified the models of configuration management systems into checkout/checkin model, composition model, long transaction model, and change set model <ref> [31] </ref>. According to this classification, SCCS, RCS, and MAKE represent the traditional checkout/checkin model, in which repository management and system building are quite independent. DSEE, SHAPE, and Adele use the composition model.
Reference: [32] <author> Stuart I. Feldman, </author> <title> Make a Program for Maintaining Computer Programs, </title> <journal> in Software Practice & Experience, </journal> <volume> 9(4), </volume> <pages> pp. 255-265, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: For example, if A.c and M.c both include the header file A.h and A.h is modified, then we have to recompile both of A.c and M.c and link the object files again. The system-building process has been automated by tools like MAKE <ref> [32] </ref>. In the example above, we can describe the dependencies between source files in a makefile. <p> Some of the systems discussed here are very large and have rich sets of features covering different research areas. Because they are difficult to compare as a whole, we discuss their individual features in different sections instead of giving general descriptions. 2.1 Configuration Management Systems MAKE MAKE <ref> [32] </ref> and its descendents are the most commonly used system building tools. MAKE keeps track of the relationships among files of a program, and issues the commands needed to make the files consistent after changes are made. <p> Some more advanced features are mentioned in the following chapters, and some less important features are omitted entirely. In order to make clear the differences between our framework and existing approaches, we compare POEM with other configuration management systems in this tour. We choose MAKE <ref> [32] </ref> as the basis for comparing system building features, because it is the most commonly used system building tool in current programming environments. Moreover, most more advanced configuration management systems, like ClearCase [4][5], TeamWare [78] and SHAPE [58], also base their system building mechanism on MAKE-like tools.
Reference: [33] <author> James C. Ferrans, David W. Hurst, Michael A. Sennett, Burton M. Covnot, Wenguang Ji, Peter Kajka, and Wei Ouyang, HyperWeb: </author> <title> A Framework for Hypermedia-Based Environments, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 1-10, </pages> <month> December </month> <year> 1992. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 17, No. 5, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: A popular approach to this problem is to use hypertext. ISEA [15] automatically creates hyperlinks between program analysis data and hypertext documentation. Kiosk [22] uses hypertext in selecting reusable software components from software libraries. HyperWeb <ref> [33] </ref> uses hypermedia to help programmers on understanding and maintaining software. Conversation-Builder [44] also uses hypertext to describe shared objects in collaborative software development. The hypertext approach has the exibility to establish links between any two arbitrary software artifacts.
Reference: [34] <author> Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> The Object Management System of PCTE as a Software Engineering Database Management System, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 12-15, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Because of the success and popularity of the object-oriented technology, people have been trying to apply it in building software development environments. RPDE [40][65] uses objects to implement internal components of a programming environment, especially the abstract syntax tree. PCTE <ref> [34] </ref> supports an object base as the basis for software development environments. Render and Campbell describe an object-oriented model of configuration management that represents most software entities as objects [71]. But objects in that model are rather passive and low-level.
Reference: [35] <author> David Garlan, Linxi Cai, and Robert L. Nord, </author> <title> A transformational Approach to Generating Application-Specific Environments, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 68-77, </pages> <booktitle> Decem-ber 1992. Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 17, No. 5, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: An editor generator takes a description of the language that is to be manipulated and produces as output a syntax-sensitive editor for the language. JASON, as discussed earlier, lets users tailor the behavior of a generic configuration management system. Garlan <ref> [35] </ref> proposed a transformational approach to generating application-specific environments. Process-centered environments support facilities to generate software environments with highly customized software process policies. Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66].
Reference: [36] <author> William G. Griswold and David Notkin, </author> <title> Automated Assistance for Program Restructuring, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> Vol. 2, No. 3, </volume> <pages> pp. 228-269, </pages> <month> July </month> <year> 1993. </year>
Reference: [37] <author> William G. Griswold, </author> <title> Direct Update of Data Flow Representations for a Meaning-Preserving Program Restructuring Tool, </title> <booktitle> in Proceesdings of the First ACM SIGSOFT Symposium on the Foundation of Software Engineering, </booktitle> <pages> pp. 42-55, </pages> <month> December, </month> <year> 1993. </year>
Reference: [38] <author> A. Nico Habermann and David Notkin, </author> <title> Gandalf: Software Development Environments, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. 12, No. 12, pp.1117-1127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Gandalf <ref> [38] </ref> facilitates semiautomatic generation of a set of related software-development environments by supplying a generation environment to the designers. An editor generator takes a description of the language that is to be manipulated and produces as output a syntax-sensitive editor for the language. <p> Programming languages like Ada, Modula-2, and Modula-3 directly support this idea at the language level. Parnas suggested using information hiding as the basic criterion to decompose systems into modules, so that software will be more exible and more comprehensible [67]. Gandalf <ref> [38] </ref>, the first project to apply this notion in programming environments, proposed a module concept in which a set of versions implement a single interface. Adele [27] describes the relation between interfaces and implementations as an AND/OR graph.
Reference: [39] <author> Christine B. Hanna and Roy Levin, </author> <title> The Vesta Language for Configuration Management, </title> <note> DEC System Research Center Research Report No. 107, </note> <month> June </month> <year> 1993. </year>
Reference: [40] <author> William H. Harrison, John Shilling, and Peter Sweeney, </author> <title> Good News, Bad News: Experience Building 182 Bibliography a Software Development Environment Using the Object-Oriented Paradigm, </title> <booktitle> in ACM OOPSLA '89 Proceedings, </booktitle> <pages> pp. 85-94, </pages> <month> October, </month> <year> 1989. </year>
Reference: [41] <author> Hewlett-Packard Company, </author> <title> Exploring HP SoftBench: a Beginners Guide, </title> <publisher> Hewlett-Packard Company, </publisher> <address> Ft. Collins, Colorado, </address> <year> 1989. </year>
Reference: [42] <author> Susan Horwitz, </author> <title> Identifying the Semantics and Textual Differences Between Two Versions of a Program, </title> <booktitle> in Proceedings of the ACM SIGPLAN90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 234-245, </pages> <month> June </month> <year> 1990. </year>
Reference: [43] <author> Scott E. Hudson and Roger King, </author> <title> The Cactis Project: Database Support for Software Environments, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, No. 6, </volume> <pages> pp. 709-719, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Most tools are built on top of objects instead of implemented as operations of objects. The Attributed File System of SHAPE enable users to associate attributes with files. Several advanced environments, including Adele [9][29], MARVEL [47], Darwin [60], and Arcadia [79], use objects for data integration. Cactis <ref> [43] </ref> is an object-oriented database designed to support software environments. Rumbaugh [73] proposed a framework to control the propagation of operations between 2.7. Program Restructuring 21 objects. The propagation policy is based on attributes associated with relations. Our framework also relies on the propagation of operations to handle composite objects.
Reference: [44] <author> Simon M. Kaplan, William J. Tolone, Alan M. Carroll, Douglas P. Bogia and Celsina Bignoli, </author> <title> Supporting Collaborative Software Development with ConversationBuilder, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 11-20, </pages> <month> December </month> <year> 1992. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 17, No. 5, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: It uses forward and backward chaining of rules to facilitate communication between programmers, and uses a two-phase locking to detect interference. When detected, interference is resolved according to some consistency constraints defined in the process model. ConversationBuilder <ref> [44] </ref> supports collaborative software development with a hypertext system. Coordination is supported according to protocols specified by users. A good version control system is a simple, inexpensive but effective tool to help cooperative programming. By using stable versions created by other programmers, a programmer can avoid interference from other programmers. <p> A popular approach to this problem is to use hypertext. ISEA [15] automatically creates hyperlinks between program analysis data and hypertext documentation. Kiosk [22] uses hypertext in selecting reusable software components from software libraries. HyperWeb [33] uses hypermedia to help programmers on understanding and maintaining software. Conversation-Builder <ref> [44] </ref> also uses hypertext to describe shared objects in collaborative software development. The hypertext approach has the exibility to establish links between any two arbitrary software artifacts.
Reference: [45] <author> Randy H. Katz, </author> <title> Toward a Unified Framework for Version Modeling in Engineering Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 22, No. 4, </volume> <pages> pp. 375-408, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Zdonik describes an object-oriented database system that includes a built-in version control mechanism [92]. PCTE [13][81] supports an versioned object base for constructing software engineering environments. Katz surveys version modeling in engineering databases and proposes a unified framework <ref> [45] </ref>. The configuration 2.1. Configuration Management Systems 17 thread of DSEE allows programmers to choose versions by specifying version selection rules. SHAPE and ClearCase also supply similar functionality.
Reference: [46] <author> Setrag N. Khoshafian and George P. Copeland, </author> <title> Object Identity, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <pages> pp. 406-415, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: It is up to the implementation to define the actual meaning of equality between source code fragments. An identity is the property of an object that distinguishes it from all other objects <ref> [46] </ref>. The identity of an object should remain invariant across all possible modification of the objects value. In our model, the only major object to be discussed is the software unit, and we will be concerned with the identities of software units only. <p> In Object-Store, which is used for the current implementation of our model, identities can be represented as the address of persistent objects. However, all these approaches may have their own drawbacks, as discussed in <ref> [46] </ref>. Derived objects are the result of applying translators, like compilers and linkers, on other software objects. As with source code fragments, the only operation we need on derived objects is the testing of equivalence.
Reference: [47] <author> Gail E. Kaiser and Peter H. Feiler, </author> <title> Intelligent Assistance for Software Development and Maintenance, </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1988. </year>
Reference-contexts: Process-centered environments support facilities to generate software environments with highly customized software process policies. Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66]. Several process-centered environments, including Arcadia [79], MARVEL <ref> [47] </ref>, OZ [10], Adele2 [9], and Darwin [60], are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable. <p> But objects in that model are rather passive and low-level. Most tools are built on top of objects instead of implemented as operations of objects. The Attributed File System of SHAPE enable users to associate attributes with files. Several advanced environments, including Adele [9][29], MARVEL <ref> [47] </ref>, Darwin [60], and Arcadia [79], use objects for data integration. Cactis [43] is an object-oriented database designed to support software environments. Rumbaugh [73] proposed a framework to control the propagation of operations between 2.7. Program Restructuring 21 objects. The propagation policy is based on attributes associated with relations.
Reference: [48] <author> Donald E. Knuth, </author> <title> Literate Programming, </title> <journal> The Computer Journal, </journal> <volume> Vol. 27, No. 2, </volume> <pages> pp. 97-111, </pages> <year> 1984. </year>
Reference: [49] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinred, </author> <title> The ObjectStore Database System, </title> <journal> in Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <pages> pp. 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Using the script language we provide, programmers can incorporate new tools into POEM or customize POEM to meet their special needs. The implementation of POEM involves about 8,000 lines of C++ code on top of Motif, ObjectStore <ref> [49] </ref>, YACC, and LEX, and about 1,000 lines of code in the script language of POEM. Considering the rich functionality POEM supplies, the implementation is rather easy. This is pos 1.5. Thesis Outline 9 sible because our model is rather simple and because we utilize many existing tools. <p> Currently we are using an object-oriented User Object File System Layer Interface Says Obj Ver Build Sys Obj Ver Build Sys Obj Ver Build X1 Y1 C D work area A work area B Library X Library Y Layer 124 Chapter 6: Implementation Issues database system called ObjectStore <ref> [49] </ref> to implement this layer. ObjectStore is basically an extension of the C++ language that supports persistent objects, allows multiple clients to work on the same database simultaneously in a distributed environment, and supports transaction facilities to serialize the operations on objects. <p> The syntax of VERSE is based on C, but also borrows some features from SELF [1][84] and the DML of ObjectStore <ref> [49] </ref>. There are also some features that are unique to VERSE. B.1 Data Types VERSE supports four atomic data types and two structured data types. The four atomic types are integers, boolean values, strings, and links. The two structured types are lists and sets.
Reference: [50] <author> Ronald Lange and Robert W. Schwanke, </author> <title> Software Architecture Analysis: A Case Study, </title> <booktitle> in Proceedings of the 3rd International Workshop on Software Configuration Management, </booktitle> <pages> pp. 19-28, </pages> <month> June, </month> <year> 1991. </year>
Reference-contexts: The specific version of each component from which a given version of the final product is built is called the configuration of that version of the final product. Configuration management (CM) is the discipline of controlling the evolution of software systems <ref> [50] </ref>. It is the art of identifying, organizing, and controlling changes made to a software system developed by a programming team. Its goal is to maximize productivity and quality in software development and maintenance. Among the activities of configuration management, system building and version control play central roles.
Reference: [51] <author> David B. Leblang and Robert P. Chase, Jr., </author> <title> Computer-Aided Software Engineering in a Distributed Workstation Environment, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 19, No. 5, </volume> <pages> pp. 104-113, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: RCS retains the best features of SCCS, but offers a simpler user interface, exible selection rules, inte 2.1. Configuration Management Systems 13 gration with MAKE and improved identification. DSEE and ClearCase Apollos Domain Software Engineering Environment (DSEE) <ref> [51] </ref> provides source code control, system building management, release control, advice management, task management, and user-defined dependency tracking with automatic notification. Users of DSEE specify configuration threads that select components to be used in building a product. The selection can be based on certain characteristics, equivalencies, or compatibilities. <p> Automatic Handling of Derived Objects Several systems are designed to manage system building at a higher level. Cedar [80] and DSEE <ref> [51] </ref> use source-oriented system models. Derived objects are not directly managed by programmers, but occasionally users still need to address them indirectly via some functions. In Vesta, derived objects are passed along as the result of building functions and are not directly managed by users. <p> This will definitely cause trouble. Some more advanced configuration management systems, like DSEE <ref> [51] </ref>, SHAPE, and ClearCase, have better support for cooperative programming than MAKE and RCS. Users of those systems can set up version selection rules to choose versions of files for their private workspaces. This makes version selection in large projects much simpler. However, the two problems discussed above still remain. <p> An advantage of using workareas instead of workspaces is that we can handle the sharing of software artifacts between programmers more naturally. Two programmers who use the same version of a subsystem automatically share all the source objects and derived objects of that subsystem. In DSEE <ref> [51] </ref> and SHAPE [58], the sharing of derived objects is handled by more complicated mechanisms. 4.1. Basic Concepts 51 4.1.4 Classes of Software Units Different kinds of software units need different data attributes and different implementation of their operations.
Reference: [52] <author> Roy Levin and Paul R. McJones, </author> <title> The Vesta Approach to Precise Configuration of Large Software Systems, </title> <note> DEC System Research Center Research Report No. 105, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: If we do not get the correct version of makefile, the building will fail. 3.7 Comparison We conclude this chapter by comparing POEM with several existing configuration management systems, RCS, MAKE, CVS [12], DSEE, SHAPE, ClearCase, TeamWare and Vesta <ref> [52] </ref>. RCS and MAKE represent early version control and system building tools. They complement each other and are usually used together. CVS is a more advanced version control tool based on RCS. CVS is also paired with MAKE because it does not support system building mechanisms.
Reference: [53] <author> Henry Lieberman, </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object Oriented Languages, </title> <booktitle> in ACM OOPSLA '86, </booktitle> <pages> pp. 214-223, </pages> <month> September, </month> <year> 1986. </year>
Reference-contexts: The basic idea is that while each object defines its own attributes, it can also delegate 126 Chapter 6: Implementation Issues to other objects the responsibility of responding messages that do not match any locally defined attributes. As pointed out by Lieberman <ref> [53] </ref>, the delegation mechanism is powerful enough to simulate the classes and inheritance that are used in most object-oriented systems. The extra power of delegation is that an instance may share data and behavior with the object it delegates to while having its own local modifications.
Reference: [54] <author> Yi-Jing Lin and Steven P. Reiss, </author> <title> An Object-Oriented Approach to Designing Programming Environments, </title> <type> Technical Report CS-93-38, </type> <institution> Department of Computer Science, Brown University, </institution> <month> September </month> <year> 1993. </year>
Reference: [55] <author> Yi-Jing Lin, </author> <title> VERSE - The DML of POEM, </title> <institution> Department of Computer Science, Brown University, </institution> <month> February, </month> <year> 1995. </year> <note> Bibliography 183 </note>
Reference-contexts: Appendix B explains the syntax of VERSE, Appendix C gives an example of defining a class with VERSE. A more detailed explanation of VERSE is also available as <ref> [55] </ref>. 6.4 Versioning by Delegation In POEM, we use a new technique based on delegation to handle the versions of software units. Similar to other existing version control systems, we save space by storing only the differences between versions.
Reference: [56] <author> Yi-Jing Lin and Steven P. Reiss, </author> <title> Configuration Management in terms of Modules, </title> <booktitle> in Proceedings of the Fifth International Workshop on Software Configuration Management, </booktitle> <month> April </month> <year> 1995. </year>
Reference: [57] <author> Yi-Jing Lin and Steven P. Reiss, </author> <title> Configuration Management with Logical Structures, </title> <type> Technical Report CS-95-23, </type> <institution> Department of Computer Science, Brown University, </institution> <month> August </month> <year> 1995. </year>
Reference: [58] <author> Axel Mahler and Andreas Lampen, </author> <title> An Integrated Toolset for Engineering Software Configurations, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 191-200, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 13, No. 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: A major difference between ClearCase and DSEE is that ClearCase uses conventional makefiles instead of proprietary system models. Doing so increases ClearCases compatibility with other existing tools, but also makes the management of system building less organized. SHAPE SHAPE <ref> [58] </ref> integrates a dedicated version control system and a enhanced MAKE program on the basis of a common object model. Its object model comprises multiple versions of software objects as well as conventional file system objects. <p> We choose MAKE [32] as the basis for comparing system building features, because it is the most commonly used system building tool in current programming environments. Moreover, most more advanced configuration management systems, like ClearCase [4][5], TeamWare [78] and SHAPE <ref> [58] </ref>, also base their system building mechanism on MAKE-like tools. For similar reasons, we choose RCS [82] and SCCS [72] as the basis for comparing version control features. But as there is more variety in version control mechanisms, we also discuss other advanced systems when they support important features. <p> An advantage of using workareas instead of workspaces is that we can handle the sharing of software artifacts between programmers more naturally. Two programmers who use the same version of a subsystem automatically share all the source objects and derived objects of that subsystem. In DSEE [51] and SHAPE <ref> [58] </ref>, the sharing of derived objects is handled by more complicated mechanisms. 4.1. Basic Concepts 51 4.1.4 Classes of Software Units Different kinds of software units need different data attributes and different implementation of their operations.
Reference: [59] <author> Scott Meyers and Steven P. Reiss, </author> <title> An Empirical Study of Multiple-View Software Development, </title> <booktitle> in Proceedings of the Fifth ACM SIGSOFT Symposium on Software Development Environments (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 47-57, </pages> <month> December </month> <year> 1992. </year>
Reference: [60] <author> Naftaly H. Minsky and David Rozenshtein, </author> <title> A Software Development Environment for Law-Governed Systems, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 65-75, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 13, No. 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66]. Several process-centered environments, including Arcadia [79], MARVEL [47], OZ [10], Adele2 [9], and Darwin <ref> [60] </ref>, are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable. But while most process-centered environments use imperative or rule-based process programs, our approach has a strong object-oriented avor. <p> But objects in that model are rather passive and low-level. Most tools are built on top of objects instead of implemented as operations of objects. The Attributed File System of SHAPE enable users to associate attributes with files. Several advanced environments, including Adele [9][29], MARVEL [47], Darwin <ref> [60] </ref>, and Arcadia [79], use objects for data integration. Cactis [43] is an object-oriented database designed to support software environments. Rumbaugh [73] proposed a framework to control the propagation of operations between 2.7. Program Restructuring 21 objects. The propagation policy is based on attributes associated with relations.
Reference: [61] <author> Thomas M. Morgan, </author> <title> Configuration Management and Version Control in the Rational Programming Environment, </title> <booktitle> in Ada in Industry Proceedings of the Ada-Europe International Conference, </booktitle> <pages> pp. 17-28, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC <ref> [61] </ref> presents one such mechanism. Version Control in Terms of Objects Version control in terms of objects is studied in the area of software development environments as well as in the area of computer-aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism [92].
Reference: [62] <author> H. A. Muller, S. R. Tilley, M. A. Orgun, B. D. Corrie, and N. H. Madhavji, </author> <title> A Reverse Engineering Environment Based on Spatial and Visual Software Interconnection Models, </title> <booktitle> in Proceedings of the Fifth ACM SIGSOFT Symposium on Software Development Environments (Herbert Weber, </booktitle> <publisher> ed.), </publisher> <pages> pp. 88-98, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Using this information, we can reorganize an existing software system into software units that represent individual functions and classes. There are already some tools that can extract the source model rather efficiently. For example, FIELD extract this information by using language-specific parsers. Rigi <ref> [62] </ref> uses spatial and visual information inherent in graphical representation of software systems to extract system abstractions and design information.
Reference: [63] <author> Gail C. Murphy and David Notkin, </author> <title> Lightweight Source Model Extraction, </title> <booktitle> in Proceedings of the Fifth ACM SIGSOFT Symposium on the Foundation of Software Engineering, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: There are already some tools that can extract the source model rather efficiently. For example, FIELD extract this information by using language-specific parsers. Rigi [62] uses spatial and visual information inherent in graphical representation of software systems to extract system abstractions and design information. Murphy and Notkin described in <ref> [63] </ref> a lightweight source model extractor based on lexical analysis. 148 Chapter 7: Conclusion 149 Appendix A Makefiles for the Example in Chapter 3 In chapter 3 we showed an example of developing POEM under POEM itself.
Reference: [64] <author> William F. Opdyke, </author> <title> Refactoring Object-Oriented Frameworks, </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, Illinois, USA, </institution> <year> 1992. </year>
Reference-contexts: Griswold and Notkin [36][37] presented a set of automatable transformations and studied their impact on structures. They also described a model to building meaning-preserving restructuring transformations and a tool for restructuring Scheme programs. Opdyke <ref> [64] </ref> defines a set of restructuring operations for object-oriented programs. Our framework shares interest with these tools in that we want to make software restructuring easier, but we do not try to automate the restructuring of the source code itself.
Reference: [65] <author> Harold Ossher and William Harrison, </author> <title> Support for Change in RPDE3, </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (Richard Taylor, </booktitle> <publisher> ed.), </publisher> <pages> pp. 218-228, </pages> <month> December </month> <year> 1990. </year>
Reference: [66] <author> Leon Osterweil, </author> <title> Software Processes Are Software Too, </title> <booktitle> in Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pp. 2-13, </pages> <address> Monterey CA, </address> <month> March-April </month> <year> 1987. </year>
Reference-contexts: Process-centered environments support facilities to generate software environments with highly customized software process policies. Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs <ref> [66] </ref>. Several process-centered environments, including Arcadia [79], MARVEL [47], OZ [10], Adele2 [9], and Darwin [60], are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable. <p> Our approach applies the principles of modularization and encapsulation in configuration management. It is well known that modularization and encapsulation are very useful in managing source programs. Similarly, they can help us greatly in handling configurations. As pointed out by Osterweil <ref> [66] </ref>, software processes can be considered as special programs that are enacted by both human and computers. The data used by these special programs are software artifacts like source code, derived objects, system models, documentation, version history files, etc. <p> Second, our approach applies the principles of modularization and encapsulation to configuration management. It is well known that modularization and encapsulation are very useful in managing source programs. Similarly, they can help greatly in handling configuration management. As pointed out by Osterweil <ref> [66] </ref>, software processes can be considered special programs that are enacted by both human and computers. The data used by these special programs are software artifacts like source code, derived objects, system models, documentation, version history files, etc.
Reference: [67] <author> D. L. Parnas, </author> <title> On the Criteria To Be Used in Decomposing Systems into Modules, </title> <journal> in Communications of the ACM, pp. </journal> <volume> 1053-1058, Vol. 15, No. 12, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: Programming languages like Ada, Modula-2, and Modula-3 directly support this idea at the language level. Parnas suggested using information hiding as the basic criterion to decompose systems into modules, so that software will be more exible and more comprehensible <ref> [67] </ref>. Gandalf [38], the first project to apply this notion in programming environments, proposed a module concept in which a set of versions implement a single interface. Adele [27] describes the relation between interfaces and implementations as an AND/OR graph.
Reference: [68] <author> PROCASE Corporation, SMARTsystem, </author> <title> Technical Overview, </title> <publisher> PROCASE Corporation, </publisher> <address> 3130 De La Cruz Boulevard, Suite 100, Santa Clara, CA 95054, </address> <year> 1989. </year>
Reference-contexts: It also lets programmers navigate in a program according to the logical relations among modules. Users can move to a certain module by clicking the mouse on the corresponding icon. However, they cannot edit the structure of a program by editing these diagrams directly. The editor of SMARTsystem <ref> [68] </ref> supports a filer mechanism that allows users to hide irrelevant code when editing source files. Donald Knuth proposed the literate programming approach to writing more easily understood and maintained programs, and developed an environment called WEB to support his view [11][48].
Reference: [69] <author> Steven P. Reiss, </author> <title> Connecting Tools Using Message Passing in the FIELD Program Development Envi 184 Bibliography ronment, </title> <journal> IEEE Software, </journal> <pages> pp. 57-67, </pages> <month> July </month> <year> 1990. </year>
Reference: [70] <author> Steven P. Reiss, </author> <title> The FIELD Programming Environment: A Friendly Integrated Environment for Learning and Development, </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> Massachusetts, USA, </address> <year> 1995. </year>
Reference: [71] <author> Hal Render and Roy Campbell, </author> <title> An Object-Oriented Model of Software Configuration Management, </title> <booktitle> in ACM Proceedings of the 3rd International Workshop on Software Configuration Management, </booktitle> <pages> pp. 127-139, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: RPDE [40][65] uses objects to implement internal components of a programming environment, especially the abstract syntax tree. PCTE [34] supports an object base as the basis for software development environments. Render and Campbell describe an object-oriented model of configuration management that represents most software entities as objects <ref> [71] </ref>. But objects in that model are rather passive and low-level. Most tools are built on top of objects instead of implemented as operations of objects. The Attributed File System of SHAPE enable users to associate attributes with files.
Reference: [72] <author> Marc J. Rochkind, </author> <title> The Source Code Control System, </title> <journal> IEEE Transactions on Software Engineering, pp. </journal> <volume> 364-370, Vol. 1 No. 4, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: We may also want to create versions of A.c that use different algorithms, deal with different operating systems, or meet different requirements. The version-control process has been automated by tools like SCCS <ref> [72] </ref> and RCS [82], which support mechanisms to store, retrieve, and identify versions of files. Those tools also reduce their space consumption by storing only the differences between versions. A good support for version control and system building is vital to software reuse, cooperative programming, and software maintenance. <p> Besides, since the output of makedepend contains dependencies on system header files that are seldom modified, system building processes based on the output of makedepend are usually slower than those based on handwritten makefiles. SCCS Source Code Control System (SCCS) <ref> [72] </ref>, one of the earliest tools for version control, maintains different versions of files without unnecessary code duplication. It controls system updates by ensuring that no part of the system can be updated by more than one programmer at any one time. <p> Moreover, most more advanced configuration management systems, like ClearCase [4][5], TeamWare [78] and SHAPE [58], also base their system building mechanism on MAKE-like tools. For similar reasons, we choose RCS [82] and SCCS <ref> [72] </ref> as the basis for comparing version control features. But as there is more variety in version control mechanisms, we also discuss other advanced systems when they support important features. The current implementation of POEM runs on top of the X window system.
Reference: [73] <author> James Rumbaugh, </author> <title> Controlling Propagation of Operations Using Attributes on Relations, </title> <booktitle> ACM OOP-SLA '88 Proceedings, </booktitle> <pages> pp. 285-296, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: The Attributed File System of SHAPE enable users to associate attributes with files. Several advanced environments, including Adele [9][29], MARVEL [47], Darwin [60], and Arcadia [79], use objects for data integration. Cactis [43] is an object-oriented database designed to support software environments. Rumbaugh <ref> [73] </ref> proposed a framework to control the propagation of operations between 2.7. Program Restructuring 21 objects. The propagation policy is based on attributes associated with relations. Our framework also relies on the propagation of operations to handle composite objects.
Reference: [74] <author> Ian Simmonds, </author> <title> Configuration Management in the PACT Software Engineering Environment, </title> <booktitle> in Proceedings of the 2nd International Workshop on Software Configuration Management (Peter H. Feiler, </booktitle> <publisher> ed.), </publisher> <pages> pp. 118-121, </pages> <month> October, </month> <year> 1989. </year>
Reference: [75] <institution> Software Maintenance & Development Systems, Inc., </institution> <month> Aide-de-Camp, </month> <title> Product Overview, Software Maintenance & Development Systems, </title> <publisher> Inc., </publisher> <address> 200 Baker Avenue, Suite 300, Concord, Massachusetts 01742, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: About file merging, the author of CVS argues that simultaneous editing of the same file is rare in practice and that most merging conictions can be solved easily. Aide-de-Camp Aide-de-Camp (ADC) <ref> [75] </ref> provides an entity-relationship database to store file attributes and relationship among files, and a set of commands to manage logical changes made on system configurations.
Reference: [76] <author> Lynn Andrea Stein, </author> <title> Delegation is Inheritance, </title> <booktitle> in ACM OOPSLA '87, </booktitle> <pages> pp. 138-146, </pages> <month> October </month> <year> 1987. </year>
Reference: [77] <author> Lynn Andrea Stein, Henry Lieberman, and David Ungar, </author> <title> A Shared View of Sharing: The Treaty of Orlando, Concepts, Applications and Databases (Kim and Lochovsky, </title> <booktitle> eds.), </booktitle> <pages> pp. 31-48, </pages> <publisher> Addison Wes-ley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference: [78] <author> Sun Microsystems, Inc., </author> <title> SPARCworks/TeamWare Solutions Guide, Sun Microsystems, </title> <publisher> Inc., </publisher> <address> 2550 Garcia Ave., Mountain View, CA, 94043-1100, USA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: NSE supports cooperative programming via environments that represent workspaces. Workspaces support nested transactions with a protocol for merging and updating files between a child and a parent workspace. TeamWare <ref> [78] </ref> is the successor of NSE. It includes graphical tools for version control (VerTool), workspace and directory management (CodeMgrTool), source file configuration archiving (FreezePtTool), project build acceleration (PMake), and automatic file merging (File-Merge). <p> We choose MAKE [32] as the basis for comparing system building features, because it is the most commonly used system building tool in current programming environments. Moreover, most more advanced configuration management systems, like ClearCase [4][5], TeamWare <ref> [78] </ref> and SHAPE [58], also base their system building mechanism on MAKE-like tools. For similar reasons, we choose RCS [82] and SCCS [72] as the basis for comparing version control features.
Reference: [79] <author> Richard N. Taylor, Frank C. Belz, Lori A. Clarke, Leon Osterweil, Richard W. Selby, Jack C. Wileden, Alexander L. Wolf, and Michael Young, </author> <title> Foundations for the Arcadia Environment Architecture, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 1-13, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIG-SOFT Software Engineering Notes, </booktitle> <volume> Vol. 13, No. 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Process-centered environments support facilities to generate software environments with highly customized software process policies. Osterweil argues that software processes are software too, and software environments is best viewed as a vehicle for the specification, compilation, and execution of process programs [66]. Several process-centered environments, including Arcadia <ref> [79] </ref>, MARVEL [47], OZ [10], Adele2 [9], and Darwin [60], are built to validate this view. Our framework shares interests with these process-centered environments in that we want 20 Chapter 2: Related Work to make programming environments themselves programmable. <p> Most tools are built on top of objects instead of implemented as operations of objects. The Attributed File System of SHAPE enable users to associate attributes with files. Several advanced environments, including Adele [9][29], MARVEL [47], Darwin [60], and Arcadia <ref> [79] </ref>, use objects for data integration. Cactis [43] is an object-oriented database designed to support software environments. Rumbaugh [73] proposed a framework to control the propagation of operations between 2.7. Program Restructuring 21 objects. The propagation policy is based on attributes associated with relations.
Reference: [80] <author> Warren Teitelman, </author> <title> A Tour Through Cedar, </title> <booktitle> in IEEE Software, </booktitle> <pages> pp. 44-73, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Automatic Handling of Derived Objects Several systems are designed to manage system building at a higher level. Cedar <ref> [80] </ref> and DSEE [51] use source-oriented system models. Derived objects are not directly managed by programmers, but occasionally users still need to address them indirectly via some functions. In Vesta, derived objects are passed along as the result of building functions and are not directly managed by users.
Reference: [81] <author> Ian Thomas, </author> <title> Tool Integration in the Pact Environment, </title> <booktitle> in Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pp. 13-22, </pages> <year> 1989. </year>
Reference: [82] <author> Walter F. Tichy, </author> <title> RCS A System for Version Control, </title> <journal> Software Practice & Experience, </journal> <volume> Vol. . 15, No. 7, </volume> <pages> pp. 637-654, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: We may also want to create versions of A.c that use different algorithms, deal with different operating systems, or meet different requirements. The version-control process has been automated by tools like SCCS [72] and RCS <ref> [82] </ref>, which support mechanisms to store, retrieve, and identify versions of files. Those tools also reduce their space consumption by storing only the differences between versions. A good support for version control and system building is vital to software reuse, cooperative programming, and software maintenance. <p> It controls system updates by ensuring that no part of the system can be updated by more than one programmer at any one time. It also records information about who made the change, when and where it was made, and why. The Revision Control System (RCS) <ref> [82] </ref> automates the storing, retrieval, logging and identification of revisions and provides selection mechanisms for composing configurations. RCS retains the best features of SCCS, but offers a simpler user interface, exible selection rules, inte 2.1. Configuration Management Systems 13 gration with MAKE and improved identification. <p> Moreover, most more advanced configuration management systems, like ClearCase [4][5], TeamWare [78] and SHAPE [58], also base their system building mechanism on MAKE-like tools. For similar reasons, we choose RCS <ref> [82] </ref> and SCCS [72] as the basis for comparing version control features. But as there is more variety in version control mechanisms, we also discuss other advanced systems when they support important features. The current implementation of POEM runs on top of the X window system.
Reference: [83] <author> Douglas Wiebe, </author> <title> Generic Software Configuration Management: Theory and Design, </title> <type> Technical Report 90-07-03, </type> <institution> Computer Science Department, University of Washington, </institution> <address> Seattle, WA 98195, </address> <year> 1990. </year>
Reference-contexts: She observed that most concepts in configuration management can be seen as extensions to, or generalizations of, other concepts. She also noticed that it is hard to extract clear concepts from existing configuration management systems because there is no commonality in terminology. JASON Wiebe <ref> [83] </ref> proposed a generic SCM approach that lets users make decisions on the basic software configuration management (SCM) issues, and thereby tailor the behavior of the generic SCM system. A mathematical model of the generic SCM approach is supplied, and a particular generic SCM system called JASON is implemented.
Reference: [84] <author> David Ungar and Randall B. Smith, </author> <title> Self: The Power of Simplicity, </title> <booktitle> in ACM OOPSLA '87, </booktitle> <month> October Bibliography 185 </month> <year> 1987. </year>
Reference-contexts: This is similar to the handling of the SELF variable in the SELF language <ref> [84] </ref>. An advantage of using delegation is that we can save space by sharing data attributes between classes and software units. The data attributes defined on classes serve as the default values for those on the software units.
Reference: [85] <author> Peter Wegner, </author> <title> Concepts and Paradigms of Object-Oriented Programming, </title> <journal> OOPS Messenger, </journal> <volume> Vol. 1, No. 1, </volume> <pages> pp. 7-87, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: ISTAR [24] uses a contractual approach, in which every activity in the software process has the character of a contract. It also defines formal channels of communication between tasks. 2.6 Programming Environments and Object-Oriented Technologies Our framework is based on the object-oriented paradigm <ref> [85] </ref>. Because of the success and popularity of the object-oriented technology, people have been trying to apply it in building software development environments. RPDE [40][65] uses objects to implement internal components of a programming environment, especially the abstract syntax tree.
Reference: [86] <author> Bernhard Westfechtel, </author> <title> Structure-Oriented Merging of Revisions of Software Documents, </title> <booktitle> in Proceedings of the 3rd International Workshop on Software Configuration Management, </booktitle> <pages> pp. 68-79, </pages> <month> June </month> <year> 1991. </year>
Reference: [87] <author> David Whitgift, </author> <title> Methods and Tools for Software Configuration Management, </title> <booktitle> Wiley Series in Software Engineering Practice, </booktitle> <publisher> John Wiley & Sons Ltd. </publisher> <address> England, </address> <year> 1991. </year>
Reference-contexts: For example, a program which is to run on several operating systems needs one version variant for each target operating system. Versions may also be created to meet varying user requirements, to fix bugs in released software, or to help testing and debugging <ref> [87] </ref>. Managing variants of software items that do not contain any versioned component is straightforward. In existing configuration management systems, variants of a file are usually implemented as version branches. In our framework, too, we can similarly implement variants of a software unit as its version branches.
Reference: [88] <author> Jurgen F. H. Winkler, </author> <title> Language Constructs and Library Support for Families of Large Ada Programs, </title> <booktitle> in Proceedings of the Workshop on Software Engineering Environments for Programming-in-the-Large, </booktitle> <pages> pp. 17-28, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Besides, according to our current experience, the four kinds of links we have are enough to handle most, if not all, programming styles. 4.6.5 Variants and Conditional Links Variants are alternative implementations of a logical module arising from the need for one software artifact to meet conicting requirements <ref> [88] </ref>. For example, a program which is to run on several operating systems needs one version variant for each target operating system. Versions may also be created to meet varying user requirements, to fix bugs in released software, or to help testing and debugging [87].
Reference: [89] <author> Wuu Yang, Susan Horwitz, and Thomas Reps, </author> <title> A Program Integration Algorithm that Accommodates Semantics-Preserving Transformations, </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Practical Softwarwe Development Environments, </booktitle> <pages> pp. 133-143, </pages> <month> November </month> <year> 1990. </year>
Reference: [90] <author> Wuu Yang, Susan Horwitz, and Thomas Reps, </author> <title> A New Program Integration Algorithm, </title> <institution> TR-899, Computer Sciences Department, University of Wisconsin, Madison, </institution> <month> December </month> <year> 1989. </year>
Reference: [91] <author> Wuu Yang, </author> <title> Semantics-based Program Integration, </title> <institution> TR-962, Computer Sciences Department, University of Wisconsin, Madison, </institution> <month> August </month> <year> 1990. </year>
Reference: [92] <author> Stanley B. Zdonik, </author> <title> Version Management in an Object-Oriented Database, in Advanced Programming Environments (R. Conradi, </title> <editor> T. M. Didriksen, and D. H. Wanvik, </editor> <booktitle> eds.), </booktitle> <pages> pp. 405-422, </pages> <year> 1986. </year>
Reference-contexts: Version Control in Terms of Objects Version control in terms of objects is studied in the area of software development environments as well as in the area of computer-aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism <ref> [92] </ref>. PCTE [13][81] supports an versioned object base for constructing software engineering environments. Katz surveys version modeling in engineering databases and proposes a unified framework [45]. The configuration 2.1. Configuration Management Systems 17 thread of DSEE allows programmers to choose versions by specifying version selection rules.
Reference: [93] <editor> Stanley B. Zdonik and David Maier (eds). </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Palo Alto, CA, </address> <year> 1990. </year>
Reference-contexts: For example, if y.ID is a member of x.TUI, then there is a t_uses_interface link from x to y. An important characteristic of object-oriented systems is the complex states of objects <ref> [93] </ref>. The state of an object depends not only on its own data attributes but also on the objects it refers to. It is usually meaningless to discuss the state of an isolated object, or to discuss the links of a single software unit without considering other software units.
References-found: 93

