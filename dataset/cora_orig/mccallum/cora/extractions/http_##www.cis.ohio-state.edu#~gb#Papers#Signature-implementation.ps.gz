URL: http://www.cis.ohio-state.edu/~gb/Papers/Signature-implementation.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~gb/Papers/Signature-implementation.html
Root-URL: 
Email: gb@cs.purdue.edu russo@cs.purdue.edu  
Title: Implementing Signatures for C  
Author: Gerald Baumgartner Vincent F. Russo 
Date: August 11, 1995  
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Pubnum: Technical Report CSD-TR-95-025  
Abstract: We outline the design and detail the implementation of a language extension for abstracting types and for decoupling subtyping and inheritance in C ++ . This extension gives the user more of the flexibility of dynamic typing while retaining the efficiency and security of static typing. After a brief discussion of syntax and semantics of this language extension and examples of its use, we present and analyze the cost of three different implementation techniques: a preprocessor to a C ++ compiler, an implementation in the front end of a C ++ compiler, and a low-level implementation with back end support. Finally, we discuss the lessons we learned for future programming language design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proceedings of the OOPSLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 161-168, </pages> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 25(10), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I <ref> [1] </ref>. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language. <p> It is simple to use the display list. For example, int main () - displayList [0] = new OpenLookCircle; displayList <ref> [1] </ref> = new MotifSquare; // ... displayList [0]-&gt;display (); // invokes OpenLookCircle::display displayList [1]-&gt;display (); // invokes MotifSquare::display return 0; - where OpenLookCircle is a subclass of OpenLookObject and MotifSquare is a subclass of MotifObject.
Reference: [2] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Signatures: A language extension for improving type abstraction and subtype polymorphism in C ++ . Software Practice & Experience, </title> <booktitle> 25(8) </booktitle> <pages> 863-889, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Since the primary intent of this paper is to detail these implementation techniques, the motivation and language specification are of necessity brief. The reader interested in a more detailed motivation and complete syntax and semantics is referred to <ref> [2] </ref>. 2 Motivation Using inheritance as a subtyping mechanism suffers from three specific problems: fl Submitted to ACM Transactions on Programming Languages and Systems. 1 1. <p> We use an example from computer algebra <ref> [3, 2] </ref> to demonstrate this problem. Consider the abstract type GeneralMatrix with subtypes NegativeDefiniteMatrix and Orthogonal-Matrix. Both subtypes have functions that are not present in general matrices, e.g., the function inverse (). <p> For information on those constructs, as well as for more details on the semantics of signatures, see <ref> [2] </ref>. 4 3.2 Signature Pointers and References Since a signature declaration only describes an abstract type, it does not give enough information to create an implementation for that type. <p> By using inheritance of signatures, as defined in <ref> [2] </ref>, we can simplify the definition of the latter two signatures. <p> To see where this type of solution breaks down, consider adding another type, Stack, with member functions push and pop. With signatures it is simple to define a Stack signature and whenever assigning a DoublyLinkedList use a view <ref> [2] </ref> to rename enqueueHead to push and dequeueHead to pop. With the multiple inheritance based solution, it would be necessary either to introduce a new multiply inherited abstract class that implements push and pop by delegating to enqueueHead and dequeueHead, or to alter DoublyLinkedList to implement push and pop directly.
Reference: [3] <author> Gerald Baumgartner and Ryan D. Stansifer. </author> <title> A proposal to study type systems for computer algebra. </title> <type> RISC-Linz Report 90-87.0, </type> <institution> Research Institute for Symbolic Computation, University of Linz, Linz, Austria, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: We use an example from computer algebra <ref> [3, 2] </ref> to demonstrate this problem. Consider the abstract type GeneralMatrix with subtypes NegativeDefiniteMatrix and Orthogonal-Matrix. Both subtypes have functions that are not present in general matrices, e.g., the function inverse ().
Reference: [4] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald <ref> [4] </ref>, type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [5] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proceedings of the OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 24(10), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: The solution is to factor out the implementation aspect of classes into prototypical objects [16] or to factor out the type aspect into interfaces <ref> [5, 8] </ref>. 2.2 Retroactive Type Abstraction Another practical example [14] illustrates the need to introduce type abstractions of existing class hierarchies. Summarizing their presentation, suppose we have two libraries containing hierarchies of classes for X-Window display objects. One hierarchy is rooted at OpenLookObject and the other at MotifObject.
Reference: [6] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, David B. MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1984. </year> <booktitle> Proceedings of the International Symposium on the Semantics of Data Types, Sophia-Antipolis, </booktitle> <address> France, </address> <month> 27-29 June </month> <year> 1984. </year>
Reference-contexts: = NULL); // since the default value is ignored T * C::f (D *, E *, int = 0); // since the 3rd argument has a default value T * C::f (D *, E *) throw (X); // since S::f allows any exception Note that conformance is defined using contravariance <ref> [6] </ref> of the argument types of member functions and covariance of the result types. This makes subtyping based on signatures more flexible than the subtype relationship defined by class inheritance. Unlike elsewhere in C ++ , exception specifications are considered part of the type of member functions.
Reference: [7] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-43, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 <ref> [7] </ref>, abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [8] <author> William R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <booktitle> In Proceedings of the OOPSLA '92 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-15, </pages> <address> Vancouver, Canada, </address> <month> 18-22 October </month> <year> 1992. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 27(10), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: The solution is to factor out the implementation aspect of classes into prototypical objects [16] or to factor out the type aspect into interfaces <ref> [5, 8] </ref>. 2.2 Retroactive Type Abstraction Another practical example [14] illustrates the need to introduce type abstractions of existing class hierarchies. Summarizing their presentation, suppose we have two libraries containing hierarchies of classes for X-Window display objects. One hierarchy is rooted at OpenLookObject and the other at MotifObject.
Reference: [9] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, California, </address> <month> 17-19 January </month> <year> 1990. </year> <institution> Association for Computing Machinery. </institution> <month> 27 </month>
Reference-contexts: A doubly ended queue is implemented naturally as a doubly linked list. A trivial implementation of queue would be to copy the doubly ended queue implementation through inheritance and remove, or ignore, the additional operations. In <ref> [9] </ref>, it is argued that in order for a type system to be sound it should not be possible to use inheritance for subtyping purposes and also allow the removal of operations.
Reference: [10] <author> James Donahue and Alan Demers. </author> <title> Data types are values. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 426-445, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: A signature declaration defines an abstract type by specifying the member functions that any implementation of the abstract type needs to have. The signature language construct is related to types in Russell <ref> [10] </ref>, ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1].
Reference: [11] <author> Paul Hudak (ed.), Simon Peyton Jones (ed.), Philip Wadler (ed.), Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell: A non-strict, purely functional language, version 1.2. </title> <journal> ACM SIGPLAN Notices, 27(5):Section R, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: A signature declaration defines an abstract type by specifying the member functions that any implementation of the abstract type needs to have. The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes <ref> [11] </ref>, definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1].
Reference: [12] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: In the absence of a more complex type hierarchy, the type T in the above example could have been defined as an abstract class, i.e., a class containing only pure virtual member function declarations <ref> [12] </ref>. The behavior of both implementations would be similar except that classes implementing the abstract class's interface need to explicitly code that fact by inheriting from the abstract class. When using signatures to specify abstract types, this relationship is, instead, inferred by the compiler. <p> If several member functions of C conform to one member function of S, we find the one that conforms best using a variant of C ++ 's algorithm for finding the function declaration that best matches the call of an overloaded function <ref> [12] </ref>. To apply C ++ 's overload resolution algorithm, the signature member function is treated as a class member function in a function call.
Reference: [13] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: Since permutation matrices are positive definite, this would violate the type hierarchy. The alternative of having a separate class SparseNegativeDefiniteMatrix is not satisfying either since it causes code replications. Similar arguments have been given in the literature to show that the collection class hierarchy of Smalltalk-80 <ref> [13] </ref> is not appropriate as a basis for subtyping. While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility.
Reference: [14] <author> Elana D. Granston and Vincent F. Russo. </author> <booktitle> Signature-based polymorphism for C ++ . In Proceedings of the 1991 USENIX C ++ Conference, </booktitle> <pages> pages 65-79, </pages> <address> Washington, D.C., 22-25 April 1991. </address> <publisher> USENIX Association. </publisher>
Reference-contexts: The solution is to factor out the implementation aspect of classes into prototypical objects [16] or to factor out the type aspect into interfaces [5, 8]. 2.2 Retroactive Type Abstraction Another practical example <ref> [14] </ref> illustrates the need to introduce type abstractions of existing class hierarchies. Summarizing their presentation, suppose we have two libraries containing hierarchies of classes for X-Window display objects. One hierarchy is rooted at OpenLookObject and the other at MotifObject. <p> This cannot be done without recompiling all existing source files. Signatures, therefore, improve C ++ 's capabilities for reusing existing code. 2 The additional features of signature inheritance, the sigof construct (as in <ref> [14] </ref>), views, and opaque types are left out since they only affect the type checking phase of the compiler. <p> A signature member function call is now translated into branching to the thunk, which then adjusts the this pointer and branches to the class member function or performs a virtual function call. Such an implementation was proposed in <ref> [14] </ref>. The same idea is used in some compilers for implementing a virtual member function call. Each thunk only contains the code necessary to call one specific class member function. It is not necessary to test any flags, we can just branch to the thunk directly. <p> In the thunk implementation described in <ref> [14] </ref>, copying of signature table entries is avoided by having the optr of the LHS signature pointer point to the RHS signature pointer instead of pointing to the object. This makes assignment more efficient but requires multiple indirections in a signature member function call. <p> This makes assignment more efficient but requires multiple indirections in a signature member function call. Furthermore, to allow assigning a local signature pointer to a non-local signature pointer, the solution in <ref> [14] </ref> has to be corrected and signature pointers have to be heap allocated. There is one final detail in assigning a signature pointer to another signature pointer.
Reference: [15] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: The Scientific Computation System. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1992. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom <ref> [15] </ref> and its predecessor Scratchpad II [22, 23], and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [16] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An exemplar based Smalltalk. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 322-330, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. The solution is to factor out the implementation aspect of classes into prototypical objects <ref> [16] </ref> or to factor out the type aspect into interfaces [5, 8]. 2.2 Retroactive Type Abstraction Another practical example [14] illustrates the need to introduce type abstractions of existing class hierarchies. Summarizing their presentation, suppose we have two libraries containing hierarchies of classes for X-Window display objects.
Reference: [17] <author> David B. MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <month> October </month> <year> 1985. </year>
Reference-contexts: A signature declaration defines an abstract type by specifying the member functions that any implementation of the abstract type needs to have. The signature language construct is related to types in Russell [10], ML's signatures <ref> [17, 18] </ref>, Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1].
Reference: [18] <author> David B. MacQueen. </author> <title> An implementation of Standard ML modules. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 212-223, </pages> <address> Snowbird, Utah, </address> <month> 25-27 July </month> <year> 1988. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: A signature declaration defines an abstract type by specifying the member functions that any implementation of the abstract type needs to have. The signature language construct is related to types in Russell [10], ML's signatures <ref> [17, 18] </ref>, Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1].
Reference: [19] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 9-16, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl <ref> [19] </ref>, categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [20] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-45, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: An example similar to one in <ref> [20] </ref> illustrates this point. Consider two abstract types Queue and DEQueue (doubly ended queue). The abstract type DEQueue provides the same operations as Queue as well as two additional operations for enqueuing at the head and for dequeuing from the tail of the queue.
Reference: [21] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <address> Cambridge, Mas-sachusetts, </address> <month> 14 June </month> <year> 1995. </year> <title> Available as part of the GCC-2.7.0 distribution. </title>
Reference-contexts: This method has been implemented in the GNU C ++ compiler <ref> [21] </ref> as a modification of GCC's C ++ front end, cc1plus. The same techniques are equally applicable to AT&T's cfront, or other C ++ compilers. <p> However, by translating signatures to the level of abstraction of C code instead of C ++ code, we are able to produce more efficient code. Although the description of the compiler front-end implementation relies on details of how the GNU G ++ compiler <ref> [21] </ref> compiles C ++ classes, the same ideas can be used in other compilers as well. In the preprocessor-based implementation, there are two main sources of inefficiency.
Reference: [22] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> The type inference and coercion facilities in the Scratchpad II interpreter. </title> <booktitle> In Proceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 56-63, </pages> <address> St. Paul, Minnesota, </address> <month> 24-26 June </month> <year> 1987. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 22(7), </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II <ref> [22, 23] </ref>, and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [23] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II type system: Domains and subdomains. </title> <editor> In Alfonso M. Miola, editor, </editor> <booktitle> Computing Tools for Scientific Problem Solving, </booktitle> <pages> pages 63-82. </pages> <publisher> Academic Press, </publisher> <address> London, Great Britain, </address> <year> 1990. </year>
Reference-contexts: The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 [24], interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II <ref> [22, 23] </ref>, and types in POOL-I [1]. To associate an implementation with a signature type, we introduce the notion of a signature pointer into the language.
Reference: [24] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg, Germany, </address> <year> 1985. </year> <month> 28 </month>
Reference-contexts: A signature declaration defines an abstract type by specifying the member functions that any implementation of the abstract type needs to have. The signature language construct is related to types in Russell [10], ML's signatures [17, 18], Haskell's type classes [11], definition modules in Modula-2 <ref> [24] </ref>, interface modules in Modula-3 [7], abstract types in Emerald [4], type modules in Trellis/Owl [19], categories in Axiom [15] and its predecessor Scratchpad II [22, 23], and types in POOL-I [1].
References-found: 24

