URL: http://www.cs.cornell.edu/home/migod/papers/icse16-hci.ps
Refering-URL: http://www.cs.cornell.edu/home/migod/papersIndex.html
Root-URL: 
Email: e-mail: fmigod, holt, spirosg@turing.toronto.edu  
Title: Prototyping a Visual Formalism for System Modelling  
Author: Michael W. Godfrey, Richard C. Holt, and Spiros Mancoridis 
Address: 10 King's College Road Toronto, Ontario M5S 1A4 CANADA  
Affiliation: Department of Computer Science University of Toronto  
Abstract: Formal, visual approaches to system modelling are a promising research sub-area of configuration management. A visual notation for configuring software systems, called ConForm [God93], has been designed, formally specified in the Z language, and a prototype is currently being implemented. This paper outlines the design of ConForm, and details experience gained in transforming the formal specification into a prototype.
Abstract-found: 1
Intro-found: 1
Reference: [Bow92] <author> Jonathan P. Bowen. </author> <title> "X: Why Z?". </title> <journal> Computer Graphics Forum, </journal> <note> II(4), Octo ber 1992. </note>
Reference-contexts: We also noted that although textual specification languages such as Z have been used by others to specify graphical programs <ref> [Bow92] </ref>, we did not consider it worthwhile to formally specify the graphical interface portion of our system. We did, however, find it very helpful to formally specify the (textual) back-end of ConForm.
Reference: [Dar92] <author> Susan A. </author> <title> Dart. "The Past, Present and Future of Configuration Manage ment". </title> <type> Technical Report CMU/SEI-92TR-8, </type> <institution> Carnegie-Mellon University, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Finally, system building is the activity of assembling system components into an executable program to run on some target computer system. Configuration management systems, as surveyed by Feiler [Fei91] and Dart <ref> [Dar92] </ref>, have successfully attacked many of the problems associated with version control, access control, and system building. Most of these systems, however, do not feature system modelling notations that can express configurations conveniently and intuitively.
Reference: [DK76] <author> Frank DeRemer and Hans H. Kron. </author> <title> "Programming-in-the-Large Versus Programming-in-the-Small". </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-2(2), </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: In their foundational paper on MILs, DeRemer and Kron use the term programming-in-the-large to denote the activities involved in specifying how versions of software entities are composed into large software systems <ref> [DK76] </ref>; they use a MIL as their system modelling notation. Garlan and Shaw's definition of software architecture includes "element composition", an idea analogous to system modelling [GS93].
Reference: [Fei91] <author> Peter H. Feiler. </author> <title> "Configuration Management Models in Commercial Environ ments". </title> <type> Technical Report CMU/SEI-91-TR-7, </type> <institution> Carnegie-Mellon University, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: System modelling involves specifying how versions of atomic source code elements are interrelated and composed into large software systems. Finally, system building is the activity of assembling system components into an executable program to run on some target computer system. Configuration management systems, as surveyed by Feiler <ref> [Fei91] </ref> and Dart [Dar92], have successfully attacked many of the problems associated with version control, access control, and system building. Most of these systems, however, do not feature system modelling notations that can express configurations conveniently and intuitively.
Reference: [God93] <author> Michael W. Godfrey. </author> <title> "Visual Formalisms for Configuration Management". </title> <booktitle> In Proc. of CASCON '93, </booktitle> <address> Toronto, </address> <month> October </month> <year> 1993. </year>
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> "An Introduction to Software Architecture". </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> 1, </volume> <year> 1993. </year>
Reference-contexts: Garlan and Shaw's definition of software architecture includes "element composition", an idea analogous to system modelling <ref> [GS93] </ref>. Schwanke et al. consider a software architecture description to be the set of allowed connections between software system components [SAP89], while Perry and Wolf have a similar (but more elaborate) model [PW92]. Our research emphasizes the system modelling sub-area of configuration management.
Reference: [Har92] <author> David Harel. </author> <title> "Biting the Silver Bullet". </title> <journal> IEEE Computer, </journal> <volume> 25(1), </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: For simplicity, these components are henceforth referred to 1 In a recent paper, Harel addressed the need for visual notations for the specification of large software systems <ref> [Har92] </ref>. Although Harel uses the term "system modelling", his application area is limited to reactive systems. as module definitions, or just modules. A module is represented visually as a box with a thin border.
Reference: [Hol93] <author> Richard C. Holt. </author> <title> Turing Reference Manual. </title> <publisher> Holt Software Associates, </publisher> <address> Toronto, </address> <year> 1993. </year>
Reference-contexts: It is interesting to note that experience with the GUI-level representation also led to much greater insight into the nature of ConForm, and this resulted in some redesign of the back-end. 4 OOT is an object-oriented programming language similar to Modula3 and C++ <ref> [Hol93, MHG94] </ref>. 5 Metamorphic programming is similar to the idea of refinement/reification familiar to users of Z and similar specification languages [Jon90, Mor90]. However, refine-ment/reification emphasizes the formal mapping of an abstract representation of a program component to a more concrete one.
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall International, </publisher> <address> second edition, </address> <year> 1990. </year>
Reference-contexts: much greater insight into the nature of ConForm, and this resulted in some redesign of the back-end. 4 OOT is an object-oriented programming language similar to Modula3 and C++ [Hol93, MHG94]. 5 Metamorphic programming is similar to the idea of refinement/reification familiar to users of Z and similar specification languages <ref> [Jon90, Mor90] </ref>. However, refine-ment/reification emphasizes the formal mapping of an abstract representation of a program component to a more concrete one.
Reference: [MHG94] <author> Spiros Mancoridis, Richard C. Holt, and Michael W. Godfrey. </author> <title> "Tools for Software Engineering Education". </title> <booktitle> In Proc. of the ICSE-16 Workshop on Software Engineering Education, </booktitle> <address> Sorrento, Italy, </address> <month> April </month> <year> 1994. </year> <note> Proceedings published as Technical Report 94/6, </note> <institution> Dept. of Computing, Imperial College, </institution> <address> London, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: It is interesting to note that experience with the GUI-level representation also led to much greater insight into the nature of ConForm, and this resulted in some redesign of the back-end. 4 OOT is an object-oriented programming language similar to Modula3 and C++ <ref> [Hol93, MHG94] </ref>. 5 Metamorphic programming is similar to the idea of refinement/reification familiar to users of Z and similar specification languages [Jon90, Mor90]. However, refine-ment/reification emphasizes the formal mapping of an abstract representation of a program component to a more concrete one.
Reference: [Moo93] <author> Marc Moorcroft. </author> <title> "GUILT | A GUI Library for Turing". Private circulation, </title> <year> 1993. </year>
Reference-contexts: We were satisfied that formally specifying the back-end had been worthwhile. Despite this success, we were less certain as to the benefits of formally specifying the graphical front-end using Z. The graphical interface was to be built using a new library, GUILT <ref> [Moo93] </ref>. There were two major concerns. First, GUILT was written in a highly object-oriented style, and we were mindful of our problems with using Z to model object-oriented features of the back-end.
Reference: [Mor90] <author> Carroll Morgan. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall Interna tional, </publisher> <year> 1990. </year>
Reference-contexts: much greater insight into the nature of ConForm, and this resulted in some redesign of the back-end. 4 OOT is an object-oriented programming language similar to Modula3 and C++ [Hol93, MHG94]. 5 Metamorphic programming is similar to the idea of refinement/reification familiar to users of Z and similar specification languages <ref> [Jon90, Mor90] </ref>. However, refine-ment/reification emphasizes the formal mapping of an abstract representation of a program component to a more concrete one.
Reference: [PHG91] <author> David A. Penny, Richard C. Holt, and Michael W. Godfrey. </author> <title> "Formal Spec ification in Metamorphic Programming". </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91: Formal Software Development Methods | Proc. of the 4th International Symposium of VDM Europe, </booktitle> <month> October </month> <year> 1991. </year> <note> Proceedings published as Springer-Verlag Lecture Notes in Computer Science no. 551. </note>
Reference-contexts: Furthermore, since Abstur is a superset of OOT, a full implementation can be constructed from the prototype by gradually replacing inefficient abstract components with efficient concrete ones. We have referred to this approach elsewhere as metamorphic programming <ref> [PHG91] </ref>: a system under construction undergoes a continuous metamorphosis across development stages. 5 Using Abstur as the prototyping language had many advantages. <p> Finally, we were pleased with the use of Abstur as the prototyping language. Using a prototyping language that is close in spirit to the specification language and is also notationally related to the final implementation language greatly lessened the "semantic gaps" <ref> [PHG91] </ref> that developers often encounter when moving between development stages. The quick feedback allowed for the detection of errors and design flaws early in the development cycle, and it was easier to make the required changes in the specification and the prototype.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> "Foundations for the Study of Software Architectures". </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Garlan and Shaw's definition of software architecture includes "element composition", an idea analogous to system modelling [GS93]. Schwanke et al. consider a software architecture description to be the set of allowed connections between software system components [SAP89], while Perry and Wolf have a similar (but more elaborate) model <ref> [PW92] </ref>. Our research emphasizes the system modelling sub-area of configuration management. In particular, we are interested notations that are visual and formally defined.
Reference: [SAP89] <author> Robert W. Schwanke, R. Z. Altucher, and M. A. Platoff. </author> <title> "Discovering, Vi sualizing, and Controlling Software Structure". </title> <booktitle> In Proc. of the Fifth International Workshop on Software Specification and Design, </booktitle> <address> Pittsburgh, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Garlan and Shaw's definition of software architecture includes "element composition", an idea analogous to system modelling [GS93]. Schwanke et al. consider a software architecture description to be the set of allowed connections between software system components <ref> [SAP89] </ref>, while Perry and Wolf have a similar (but more elaborate) model [PW92]. Our research emphasizes the system modelling sub-area of configuration management. In particular, we are interested notations that are visual and formally defined.
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall Interna tional, </publisher> <address> second edition, </address> <year> 1992. </year>
Reference-contexts: Our notation for system modelling, called ConForm (Configuration Formalism), is both visual and formally defined. The formal definition of the semantics of ConForm is written using the Z formal specification language <ref> [Spi92] </ref>; an abridged version of the specification is presented in the appendix. The next section of this paper gives a brief overview of ConForm, together with a short example. Then, the development goals of ConForm are discussed. Next, experiences gained in designing, specifying and prototyping ConForm are detailed. <p> Another goal was to investigate the use of formal specification in developing a GUI-based application. Most well-known specification notations, such as Z <ref> [Spi92] </ref>, are inherently textual.
References-found: 16

