URL: http://www.cs.purdue.edu/research/cse/publications/theses/ttd.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/ttd/resume.html
Root-URL: http://www.cs.purdue.edu
Title: A SOFTWARE ARCHITECTURE OF COLLABORATING AGENTS FOR SOLVING PDES  
Degree: A Thesis Submitted to the Faculty of Purdue University by Tzvetan Todorov Drashansky In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: January 1995  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Rice, J. R., </author> <title> "Processing PDE Interface Conditions", </title> <institution> Dept. Comp. Sci., Purdue University, TR-94-041, </institution> <year> 1994. </year>
Reference-contexts: The main issue to address in this method is how to obtain a global solution out of the local solutions. One possible approach to satisfy the interface conditions is described in <ref> [1] </ref>. We first discretize the subdomains independently and form a local linear system. Since we use the interface conditions for grid points close to the interface, the linear system contains unknowns from the neighboring domain. <p> Since we may want to apply also the direct method discussed in <ref> [1] </ref> and, for added flexibility and reusability of the calculations, we would like to find the polynomial P (x; y) in a form that does not depend on the specific data (U i = U (x i ; y i ) and G i ) of the interpolation (problem) points. <p> In this section we suggest ways to take advantage of those opportunities. 2.3.1 Parallelism for Direct Solvers The solution algorithm for direct solvers described in <ref> [1] </ref> is a straightforward implementation of the main idea which does not allow extensive use of the inherent parallelism. <p> To explain our approach, we use the same problem and the same approximation and discretization schemes as in <ref> [1] </ref>. The main difference is that now we assume that both solvers have the correspondence between the row indices of the shared terms in the two domains (as opposed to the case before, when only the right-hand side domain solver was required to have them). <p> One can easily alter the discretization algorithms to achieve that by adding the mirror image of the steps performed in <ref> [1] </ref> in order to supply the 30 PDEs and interface conditions. The blocks, top to bottom, correspond to equations (2.6) to (2.9). right domain solver with the correspondence of the row indices. <p> Figure 2.3 presents schematically the solvers' configurations and the mathematical structures after the discretization has been performed. u PDE v PDE M 1 u = m 1 = M 2 v + m 2 (2.7) Bv = g (2.9) 31 As is pointed out in <ref> [1] </ref>, the v solver for the right-hand side domain can not use those terms in M 2 and N 2 whose corresponding terms in M 1 and N 1 have been used to eliminate some equations in the left domain (i.e., have contained pivot elements). <p> Note that the terms used as pivots by the other solver must not be eliminated (so that the factorization process in the other domain is not affected), much like the approach in <ref> [1] </ref> when we could not eliminate in the right domain the terms used as pivots by the left domain. The messages of the type eliminate q,r,m can be grouped in a large message which is sent after the elimination is done. <p> The pseudocode describes the actions of either of the two solvers; the actions which are identical or very similar to the original algorithm presented in <ref> [1] </ref> are not given in detail. INITIALIZATION Do the initialization described in [1] and also P = fg R = f1 : : : Jg Determine who changes the pivot in case of collision FACTORIZATION For k = 1 to I Choose a pivot p from R If the other solver <p> The pseudocode describes the actions of either of the two solvers; the actions which are identical or very similar to the original algorithm presented in <ref> [1] </ref> are not given in detail. INITIALIZATION Do the initialization described in [1] and also P = fg R = f1 : : : Jg Determine who changes the pivot in case of collision FACTORIZATION For k = 1 to I Choose a pivot p from R If the other solver has not finished yet Receive p other (the index corresponding to the
Reference: 2. <author> Drashansky, T. T. and J. R. Rice, </author> <title> "Processing PDE Interface Conditions | II", </title> <institution> Dept. Comp. Sci., Purdue University, TR-94-066, </institution> <year> 1994. </year>
Reference-contexts: The change is small compared to the other domain decomposition methods but still larger than that required by the next method and 8 the solvers are still too dependent on each other. A parallel variant of this algorithm proposed in <ref> [2] </ref> is given in Chapter 2. A (probably) more useful approach is outlined below. The description follows closely the one in [2]. More details can be found in [3,16]. <p> A parallel variant of this algorithm proposed in <ref> [2] </ref> is given in Chapter 2. A (probably) more useful approach is outlined below. The description follows closely the one in [2]. More details can be found in [3,16]. We do not discuss here the important mathematical questions of the convergence of the method, the behaviour of the solution in crosspoints of the interfaces, etc. <p> Figures 2.1 and 2.2 illustrate possible inaccuracies caused by the relative positions of the provided points and the point of interest. More discussion of this issue can be found in <ref> [2] </ref>. 23 Three points determine a + bx + cx 2 and second order accuracy is obtained at X. (B) Five points determine a + bx + cx 2 + dy + ey 2 and first order accuracy is obtained. (C) Three points determine a + dy + ey 2 and
Reference: 3. <author> Mu, Mo and J. R. Rice, </author> <title> "Modeling with Collaborating PDE Solvers | Theory and Practice", </title> <institution> Dept. Comp. Sci., Purdue University, TR-94-056, </institution> <year> 1994. </year>
Reference-contexts: For example, the engine simulation as shown in Fig. 1.2 is estimated to require 100 million variables and the answer (the data set allowing the display of the accurate solution at any point) is 20 gigabytes in size. The problem contains about 10,000 subdomains with 35,000 interfaces <ref> [3] </ref>. Therefore, we need specific software for solving each multiple-domain PDE problem and it is not feasible to build it with the traditional software development technologies. <p> More details can be found in [3,16]. We do not discuss here the important mathematical questions of the convergence of the method, the behaviour of the solution in crosspoints of the interfaces, etc. Some material on these questions can be found in <ref> [3] </ref>. 1.1.4 Interface Relaxation Technique This method uses the physical world relations among the parts of the model and follows the natural way the modeled event or process evolves. The local phenomenon in each subdomain obeys a local physical law modeled by a PDE.
Reference: 4. <author> Houstis, E. N. and J. R. Rice, </author> <title> "Parallel ELLPACK: A development and Problem Solving Environment for High Performance Computing Machines", Programming Environments for High Level Scientific Problem Solving, </title> <publisher> North Holland, </publisher> <pages> pp. 229-243, </pages> <year> 1992. </year> <note> 5. </note> <author> de Boor, C. </author> <title> "Polynomial Interpolation in Several Variables", </title> <booktitle> Studies in Computer Science (J. </booktitle> <editor> R. Rice and R. A. DeMillo, eds.), </editor> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: It also can make use of an available parallel computer. The graphical and symbol user interfaces allow quick definition of the problem and the entire solution process takes considerably less time and expert knowledge than needed for developing software for the particular problem. The computational intelligence available in //ELLPACK <ref> [4] </ref> further transfers the burden of the expert decisions from the user to the solver. To conclude, there are general purpose solvers available for solving PDE problems on a single domain 3 with efficiency and accuracy close to the optimal. <p> In particular, the user need not know or care about the ways the interaction between the agents is organized and implemented. 47 Most of the parameter values above can be derived by the agents (if the software behind the solvers allows it) | there are examples in the literature <ref> [4] </ref> where a solver can deduce and suggest some of the solution parameters for a PDE if it is provided with an appropriate data base and decision strategies.
Reference: 6. <author> Wooldridge, M. and N. Jennings, </author> <title> "Intelligent Agents: </title> <journal> Theory and Practice", </journal> <note> submitted to Knowledge Engineering Review, </note> <year> 1994. </year>
Reference-contexts: There is no universally accepted definition of an agent and the corresponding paradigm; some authors [6,7] distinguish between a "weak" and a "strong" notion of agents. Our discussion here is close to the weak notion of the concept in <ref> [6] </ref>. 1.2.1 The Concept of an Agent An agent usually denotes a software or hardware based computer system that posseses the following properties [6]. * Autonomy: Agents operate without the direct intervention of humans or others, and have some kind of control over their actions and internal state. * Social ability: <p> Our discussion here is close to the weak notion of the concept in <ref> [6] </ref>. 1.2.1 The Concept of an Agent An agent usually denotes a software or hardware based computer system that posseses the following properties [6]. * Autonomy: Agents operate without the direct intervention of humans or others, and have some kind of control over their actions and internal state. * Social ability: Agents interact with other agents (and possibly humans) via some kind of agent-communication language. * Reactivity: Agents perceive their environment (which may be <p> In general, an agent architecture <ref> [6] </ref> consists of particular methodology for building agents, communication system for the agents, and the rules for placing and executing agents.
Reference: 7. <author> Shoham, Y. </author> <title> "Agent-Orinted Programming", </title> <journal> Artificial Intelligence, </journal> <volume> v.60(1), </volume> <pages> pp. 51-92, </pages> <year> 1993. </year>
Reference: 8. <author> Varga, L. Z., et al, </author> <title> "Integrating Intelligent Systems into a Cooperating Community for Electricity Distribution Management", </title> <journal> International Journal of Expert Systems with Applications, </journal> <volume> v.7(4), </volume> <year> 1994. </year> <month> 61 </month>
Reference: 9. <author> Schlimmer, J. C. and L. A. Hermens, </author> <title> "Software Agents: Completing Patterns and Constructing User Interfaces", </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> v.1, </volume> <pages> pp. 61-89, </pages> <year> 1993. </year>
Reference: 10. <author> Finin, T., J. Weber et al, </author> <title> "Draft Specification of the KQML Agent-Communication Language", DARPA Knowledge Sharing Initiative, External Interfaces Working Group, </title> <year> 1993. </year>
Reference: 11. <institution> National Instruments Corporation, LabView User Manual, Austin, Texas, </institution> <year> 1992. </year>
Reference: 12. <author> McWriter J. D. and G. J. Nutt, "Escalante: </author> <title> An Environment for the Rapid Construction of Visual Languages Applications", </title> <booktitle> Proc. 1994 IEEE Symposium Visual Languages, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <pages> pp. 15-22, </pages> <year> 1994. </year>
Reference: 13. <author> Repenning, A., Agentsheets: </author> <title> A Tool for Building Domain-Oriented Dynamic, Visual Environments, </title> <institution> Dept. Comp. Sci., Univ. Colorado at Boulder, </institution> <type> Ph.D. dissertation, </type> <year> 1993. </year>
Reference: 14. <author> McCartney T. P. and K. J. Goldman, </author> <title> "Visual Specification of Interprocess and Intraprocess Communication", </title> <booktitle> Proc. 1994 IEEE Symposium Visual Languages, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <pages> pp. 80-88, </pages> <year> 1994. </year>
Reference: 15. <author> Lynch, R. E., </author> <title> "Hodie Approximation of Boundary Conditions", in Iterative Methods for Large Linear Systems (D. </title> <editor> Kincaid and L. Hayes, eds.), </editor> <publisher> Academic Press, </publisher> <pages> pp. 135-147, </pages> <year> 1990. </year>
Reference-contexts: + cx 2 + dy + ey 2 and first order accuracy is obtained. (C) Three points determine a + dy + ey 2 and only zero order accuracy is obtained. 24 Therefore, we decided to investigate different approximation methods from the ordinary polynomial interpolation, in particular the Hodie methods <ref> [15] </ref>. The approximation algorithms described below use variations and extensions of the interpolation scheme for multidimensional spaces described in [5]. 2.2.1 The Interpolation Problem Let us first state formally the interpolation problem we are trying to solve. It can be formulated as follows.
Reference: 16. <author> McFaddin, S. and J. R. Rice, "RELAX: </author> <title> A Platform for Software Relaxation", in Expert Systems for Scientific Computing (Houstis, </title> <editor> Rice, and Vichnevetsky, eds.), </editor> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1992. </year> <note> 17. </note> <author> de Boor, C. and A. Ron, </author> <title> "Computational Aspects of Polynomial Interpolation in Several Variables", </title> <journal> Math. Comp. </journal> <volume> v.58, </volume> <pages> pp. 705-727, </pages> <year> 1992. </year>
Reference: 18. <editor> Agha, G., Wegner, P., Yonezawa, A., editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1993. </year> <month> 62 </month>
Reference: 19. <author> Genesereth, M. R., and Ketchpel, S. P., </author> <title> "Software Agents", </title> <journal> Comm. ACM, v.37(7), </journal> <volume> pp.48-53, </volume> <year> 1994. </year>
Reference-contexts: An agent-based system usually makes extensive use of the concurrency | agents can be viewed as concurrently executed software processes, communicating with their peers <ref> [19] </ref>. Agents can migrate from one computing unit to another without changing their goals and behaviour; an agent should never execute an action that is in conflict with its goals.
Reference: 20. <author> Rice, J. R. and R. F. Boisvert, </author> <title> Solving Elliptic Problems Using ELLPACK, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference: 21. <author> Finin, T., et al, </author> <title> "A Language and Protocol to Support Intelligent Agent Interoperability", </title> <booktitle> Proc. CE&CALC'92 Conference, </booktitle> <address> Washington, </address> <year> 1992. </year>
Reference: 22. <author> Finin, T., et al, </author> <title> "KQML as an Agent Communication Language", </title> <booktitle> Proc. III Intl.Conf. on Information and Knowledge Management, </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference: 23. <editor> Hayes-Roth, B., et al, "Guardian. </editor> <title> A Prototype Intelligent Agent for Intensive-care Monitoring", </title> <booktitle> Artif. Intell. Med., v.4(2), </booktitle> <pages> pp. 165-185, </pages> <year> 1992. </year>
Reference: 24. <author> Genesereth, M. R. and R. E. Fikes, </author> <title> "Knowledge Interchange Format, Ver. 3.0 Reference Manual", </title> <institution> Comp. Sci. Dept., Stanford University, </institution> <year> 1992. </year>
Reference-contexts: These are some of the reasons for the development of a draft standard for a inter-agent communication language called KQML (Knowledge Query and Manipulation Language) [10,21,22]. It can be considered complimentary to other domain content representation schemes as KIF (Knowledge Interchange Format) <ref> [24] </ref>. KQML is a language for transmitting object-oriented types of data, and it can be used to communicate attitudes about information, such as querying, stating, believing, achieving, subscribing, and offering. KQML supports communication between asynchronous and autonomous software objects (usually agents).
Reference: 25. <author> Gross, M. D., "Stretch-A-Sketch: </author> <title> A Dynamic Diagrammer", </title> <booktitle> Proc. 1994 IEEE Symposium Visual Languages, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <pages> pp. 232-239, </pages> <year> 1994. </year>
Reference: 26. <author> Schiffer, S. and J. H. Frohlich, </author> <title> "Concepts and Architecture of Vista | A Mul-tiparadigm Programming Environment", </title> <booktitle> Proc. 1994 IEEE Symposium Visual Languages, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <pages> pp. 40-48, </pages> <year> 1994. </year>
Reference: 27. <author> Weerawarana, S., </author> <title> Problem Solving Environments for Partial Differential Equation Based Applications, </title> <type> Ph.D. dissertation, </type> <institution> Dept. Comp. Sci., Purdue University, </institution> <year> 1994. </year>
Reference-contexts: Fig. 3.3 suggests an adequate abstraction of the system architecture from the user's point of view. There is a global communication medium which is used by all objects | computing agents, instantiator, templates. We call it a software bus <ref> [27] </ref>. The agent instantiator communicates with the user through the user builder interface (see the next subsection for more discussion on the user interfaces) and uses the software bus to communicate with the templates in order to instantiate various agents.
References-found: 25

