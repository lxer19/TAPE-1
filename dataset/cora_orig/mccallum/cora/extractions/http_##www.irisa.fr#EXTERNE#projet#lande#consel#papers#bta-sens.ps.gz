URL: http://www.irisa.fr/EXTERNE/projet/lande/consel/papers/bta-sens.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/pe-97/
Root-URL: 
Email: hornof@irisa.fr  noye@emn.fr  
Title: Accurate Binding-Time Analysis For Imperative Languages: Flow, Context, and Return Sensitivity sensitivity. A different binding-time
Author: Luke Hornof Jacques Noye 
Note: Flow  
Address: 35042 Rennes Cedex, France  4 rue Alfred Kastler 44070 Nantes Cedex 03, France  
Affiliation: Irisa Campus Universitaire de Beaulieu  Ecole des Mines de Nantes  
Abstract: Since a binding-time analysis determines how an off-line partial evaluator will specialize a program, the accuracy of the binding-time information directly determines the degree of specialization. We have designed and implemented a binding-time analysis for an imperative language, and integrated it into our partial evaluator for C, called Tempo [9]. This binding-time analysis includes a number of new features, not available in any existing partial evaluator for an imperative language, which are critical when specializing existing programs such as operating system components [24, 25]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: = 2, y = 3) int d; void f (int x, int y, int *p) f x = x + 3; x = x + y; 3 The Binding-Time Analysis We shall make the above-mentioned ideas precise by describing our binding-time analysis using a data-flow analysis framework (see, for instance, <ref> [1, 20] </ref>) on the subset of C described in Fig. 4. For the sake of conciseness, this subset contains only a limited number of expressions and statements; further details on the intra-procedural aspects of the analysis can be found in [18].
Reference: [2] <author> L.O. Andersen. </author> <title> Self-applicable C program specialization. </title> <booktitle> In Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 54-61, </pages> <address> San Francisco, CA, USA, </address> <month> June </month> <year> 1992. </year> <institution> Yale University, Hew Haven, CT, USA. </institution> <note> Technical Report YALEU/DCS/RR-909. </note>
Reference-contexts: This is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages <ref> [2, 3, 4, 19, 26] </ref> as well as for functional languages [8, 17, 19, 29]. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program.
Reference: [3] <author> L.O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> DIKU Technical Report 94/19. </type>
Reference-contexts: This is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages <ref> [2, 3, 4, 19, 26] </ref> as well as for functional languages [8, 17, 19, 29]. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program.
Reference: [4] <author> R. Baier, R. Gluck, and R. Zochling. </author> <title> Partial evaluation of numerical programs in Fortran. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 119-132. </pages> <note> Technical Report 94/9, </note> <institution> University of Melbourne, Australia, </institution> <year> 1994. </year>
Reference-contexts: This is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages <ref> [2, 3, 4, 19, 26] </ref> as well as for functional languages [8, 17, 19, 29]. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program.
Reference: [5] <author> J. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: Since the number of locations defined by a given program is finite, these contexts are finite. We assume that the non-local locations used and defined by a function are computed in another pre-processing phase, similar to inter-procedural summary information <ref> [5] </ref>. Note that this phase must follow (or be combined with) alias analysis. When, as a right-hand side (left-hand side) expression, a pointer potentially points to several locations, all these lo cations must be considered used (defined).
Reference: [6] <author> D. Batory, S. Vivek, J. Thomas, S. Dasari, B. Geraci, and M. Sirkin. </author> <title> The GenVoca model of software-system generators. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 89-94, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: (s) = ret-in (s) return s : out (s) = fg return s exp e : out (s) = fg id f (formals) body s : ret-in (s) = fg out (f ) = f (loc; lookup (ret-out (s); loc)) j loc 2 def-non-locals (f )g translate specifications into applications <ref> [6, 7, 30] </ref>. Tempo plays a key role in the approach presented in [30], in which a specific application is generated by combining and instantiating generic components. This approach involves defining an abstract machine and a micro-language interpreter, both of which contain interpretation overhead which is eliminated by partial evaluation.
Reference: [7] <author> J. Bell, F. Bellegarde, J. Hook, R. B. Kieburtz, A. Ko-tov, J. Lewis, L. McKinney, D. P. Oliva, T. Sheard, L. Tong, L. Walton, and T. Zhou. </author> <title> Software design for reliability and reuse: A proof-of-concept demonstration. </title> <booktitle> In Proceeding of TRI-Ada, </booktitle> <pages> pages 396-404, </pages> <year> 1994. </year>
Reference-contexts: (s) = ret-in (s) return s : out (s) = fg return s exp e : out (s) = fg id f (formals) body s : ret-in (s) = fg out (f ) = f (loc; lookup (ret-out (s); loc)) j loc 2 def-non-locals (f )g translate specifications into applications <ref> [6, 7, 30] </ref>. Tempo plays a key role in the approach presented in [30], in which a specific application is generated by combining and instantiating generic components. This approach involves defining an abstract machine and a micro-language interpreter, both of which contain interpretation overhead which is eliminated by partial evaluation.
Reference: [8] <author> C. Consel. </author> <title> Polyvariant binding-time analysis for applicative languages. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993, </year> <pages> pages 66-77. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages [2, 3, 4, 19, 26] as well as for functional languages <ref> [8, 17, 19, 29] </ref>. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program. <p> If a parameter or non-local variable is dynamic at any call site, it will be considered dynamic at every call site. On the other hand, there are a number of existing binding-time analyses for functional languages which are context sensitive, more commonly referred to as polyvariant <ref> [8, 17, 29] </ref>. However, a context-sensitive binding-time analysis for an imperative language is more complicated since contexts must include the binding-times of the non-local variables that are read by a function and the state must be updated with respect to non-local variables that are written.
Reference: [9] <author> C. Consel, L. Hornof, F. Noel, J. Noye, and E.N. Volan-schi. </author> <title> A uniform approach for compile-time and run-time specialization. </title> <editor> In O. Danvy, R. Gluck, and P. Thie-mann, editors, </editor> <title> Partial Evaluation, </title> <booktitle> International Seminar, Dagstuhl Castle, number 1110 in Lecture Notes in Computer Science, </booktitle> <pages> pages 54-72, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Automatic program specialization is emerging as a key software engineering concept which allows software to be generic without sacrificing performance. The motivation for our work on Tempo <ref> [9] </ref>, a partial evaluator for C, is to demonstrate that partial evaluation can provide a realistic basis To appear in the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, June 1997, Amsterdam. for automatic program specialization. <p> The analysis deals with a wide subset of C, including in particular multiple returns, pointers, and structures. As a result, significant existing applications can be handled without major rewriting. The results of the analysis are used to drive both Tempo's compile-time and run-time specializer <ref> [9, 10] </ref>. We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code [24, 25, 31].
Reference: [10] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Conference Record of the 23 rd Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <pages> pages 145-156, </pages> <address> St. Petersburg Beach, FL, USA, Jan-uary 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The analysis deals with a wide subset of C, including in particular multiple returns, pointers, and structures. As a result, significant existing applications can be handled without major rewriting. The results of the analysis are used to drive both Tempo's compile-time and run-time specializer <ref> [9, 10] </ref>. We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code [24, 25, 31]. <p> Functions such as Fast Fourier Transform, cubic spline interpolation, and image dithering have been specialized, producing significant speedups. In addition to compile-time specialization, these functions were also specialized at run time, using Tempo's automatic, template-based run-time specializer <ref> [10] </ref>. Compared with operating systems or application generation programs, these functions are rather small|all consisting of less under 100 lines of code.
Reference: [11] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. In Partial Evaluation 10 and Semantics-Based Program Manipulation, </title> <address> pages 44--46, Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year> <note> ACM Press. Invited paper. </note>
Reference-contexts: Indeed, this is an area where the conflict between generality (an operating system must, by definition, deal with a wide variety of situations) and performance is especially acute. It is therefore not surprising that many opportunities for applying partial evaluation to operating systems code have been identified <ref> [11, 12, 28] </ref>. However, we have discovered that existing partial-evaluation technology is not sufficiently advanced to effectively specialize the corresponding programs. This is due to a lack of accuracy of binding-time analyses in dealing with typical features of imperative programs, such as pointers, aliases, and side-effecting functions.
Reference: [12] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Making production OS kernel adaptive: Incremental specialization in practice. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute of Science & Technology, </institution> <year> 1994. </year>
Reference-contexts: Indeed, this is an area where the conflict between generality (an operating system must, by definition, deal with a wide variety of situations) and performance is especially acute. It is therefore not surprising that many opportunities for applying partial evaluation to operating systems code have been identified <ref> [11, 12, 28] </ref>. However, we have discovered that existing partial-evaluation technology is not sufficiently advanced to effectively specialize the corresponding programs. This is due to a lack of accuracy of binding-time analyses in dealing with typical features of imperative programs, such as pointers, aliases, and side-effecting functions.
Reference: [13] <author> R. Cytron, Ferrante J., B.K. Rosen, M.N. Wegman, and F.K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <booktitle> In ACM Transactions on Programming Languages and Systems, </booktitle> <pages> pages 451-490, </pages> <year> 1991. </year>
Reference-contexts: In this paper we have obtained flow sensitivity by writing an analysis which is flow sensitive; an alternative approach would be to use a flow-insensitive analysis on an intermediate program flow representation which explicitly encodes flow dependencies, such as Single Static Assignment (SSA) <ref> [13] </ref>. For example, a binding-time analysis has been described for a simple imperative language, which obtains flow-sensitivity by using a Program Representation Graph, a representation which contains some of the features of SSA [14].
Reference: [14] <author> M. Das, T. Reps, and P. Van Hentenryck. </author> <title> Semantic foundations of binding-time analysis for imperative programs. </title> <booktitle> In ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 100-110, </pages> <address> La Jolla, CA, USA, 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: For example, a binding-time analysis has been described for a simple imperative language, which obtains flow-sensitivity by using a Program Representation Graph, a representation which contains some of the features of SSA <ref> [14] </ref>. The focus of this work is on providing formal semantics and proving safety conditions of binding-time analyses in order to establish a semantic foundation, and therefore implementation or application issues were not considered.
Reference: [15] <author> Y. Futamura. </author> <title> Program evaluation and generalized partial computation. </title> <booktitle> In International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 1-8, </pages> <year> 1988. </year>
Reference-contexts: If it is, then by explicitly adding an assignment in the truth branch of the conditional and copying the statements which use x into both branches, the statements in the truth branch can be specialized with respect to this common value for x. This example of generalized partial computation <ref> [15, 16] </ref> has proven useful both with the Sun RPC as well as with application generation. This binding-time improvement is possible because the binding-time analysis is flow sensitive.
Reference: [16] <author> Y. Futamura and K. Nogi. </author> <title> Generalized partial computation. </title> <editor> In D. Bjtrner, A.P. Ershov, and N.D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 133-151. </pages> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: If it is, then by explicitly adding an assignment in the truth branch of the conditional and copying the statements which use x into both branches, the statements in the truth branch can be specialized with respect to this common value for x. This example of generalized partial computation <ref> [15, 16] </ref> has proven useful both with the Sun RPC as well as with application generation. This binding-time improvement is possible because the binding-time analysis is flow sensitive.
Reference: [17] <author> F. Henglein and C. Mossin. </author> <title> Polymorphic binding-time analysis. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Programming Languages and Systems | ESOP'94. 5th European Symposium on Programming, Edinburgh, U.K., April 1994 (Lecture Notes in Computer Science, </booktitle> <volume> vol. 788), </volume> <pages> pages 287-301. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages [2, 3, 4, 19, 26] as well as for functional languages <ref> [8, 17, 19, 29] </ref>. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program. <p> If a parameter or non-local variable is dynamic at any call site, it will be considered dynamic at every call site. On the other hand, there are a number of existing binding-time analyses for functional languages which are context sensitive, more commonly referred to as polyvariant <ref> [8, 17, 29] </ref>. However, a context-sensitive binding-time analysis for an imperative language is more complicated since contexts must include the binding-times of the non-local variables that are read by a function and the state must be updated with respect to non-local variables that are written.
Reference: [18] <author> L. Hornof, J. Noye, and C. Consel. </author> <title> Accurate partial evaluation of realistic programs via use sensitivity. </title> <note> Publication interne 1064, </note> <institution> Irisa, Rennes, France, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: We have found that flow, context, return, and use sensitivity are necessary in a binding-time analysis in order to successfully specialize systems programs. Use sensitivity is addressed in <ref> [18] </ref>. The basic idea is that, at specialization time, the value of a variable is allowed to be computed in certain contexts even if the variable identifier is residualized in others. <p> For the sake of conciseness, this subset contains only a limited number of expressions and statements; further details on the intra-procedural aspects of the analysis can be found in <ref> [18] </ref>. Note also that non-void function calls are assumed to assign their return value directly to an identifier, which can then be used in subsequent calculations. This strategy simplifies the analysis without restricting its applicability.
Reference: [19] <author> N.D. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: This is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages <ref> [2, 3, 4, 19, 26] </ref> as well as for functional languages [8, 17, 19, 29]. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program. <p> is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages [2, 3, 4, 19, 26] as well as for functional languages <ref> [8, 17, 19, 29] </ref>. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program.
Reference: [20] <author> T.J. Marlowe and B.G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Informatica, </journal> <volume> 28(2) </volume> <pages> 121-163, </pages> <month> Decem-ber </month> <year> 1990. </year>
Reference-contexts: = 2, y = 3) int d; void f (int x, int y, int *p) f x = x + 3; x = x + y; 3 The Binding-Time Analysis We shall make the above-mentioned ideas precise by describing our binding-time analysis using a data-flow analysis framework (see, for instance, <ref> [1, 20] </ref>) on the subset of C described in Fig. 4. For the sake of conciseness, this subset contains only a limited number of expressions and statements; further details on the intra-procedural aspects of the analysis can be found in [18].
Reference: [21] <author> Sun Microsystem. NFS: </author> <title> Network file system protocol specification. </title> <type> RFC 1094, </type> <institution> Sun Microsystem, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: This binding-time improvement is possible because the binding-time analysis is flow sensitive. The second example shows how return sensitivity is crucial to specialize the excerpt of the Sun RPC client code <ref> [21] </ref> shown in Fig. 10. The initial function Xdr bytes () contains code which encodes data in the client buffer by making a call to Xdr u int () and checking the return value for a success or failure.
Reference: [22] <author> B. Moura. </author> <title> Bridging the Gap between Functional and Imperative Languages. </title> <type> PhD thesis, </type> <institution> University of Rennes I, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Return sensitivity is not applicable for functional languages since pure functions have a return value but do not contain side-effects. A different approach for obtaining effective specialization of imperative programs has been proposed <ref> [22, 23] </ref>. Instead of directly treating an imperative program, the original source program is transformed into a functional representation. An existing partial evaluator for a functional language is then used to specialize the program, after which the residual program is transformed back into the original imperative language.
Reference: [23] <author> B. Moura, C. Consel, and J. Lawall. </author> <title> Bridging the gap between functional and imperative languages. </title> <institution> Rapport de recherche, Inria, Rennes, France, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Return sensitivity is not applicable for functional languages since pure functions have a return value but do not contain side-effects. A different approach for obtaining effective specialization of imperative programs has been proposed <ref> [22, 23] </ref>. Instead of directly treating an imperative program, the original source program is transformed into a functional representation. An existing partial evaluator for a functional language is then used to specialize the program, after which the residual program is transformed back into the original imperative language.
Reference: [24] <author> G. Muller, R. Marlet, E.N. Volanschi, C. Consel, C. Pu, and A. Goel. </author> <title> Fast, optimized Sun RPC using automatic program specialization. </title> <note> Publication interne 1094, </note> <institution> Irisa, Rennes, France, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: As a result, significant existing applications can be handled without major rewriting. The results of the analysis are used to drive both Tempo's compile-time and run-time specializer [9, 10]. We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code <ref> [24, 25, 31] </ref>. It has also been applied successfully to many other application domains such as domain-specific language interpreters [30], and, in the context of run-time specialization, scientific programming and image processing [27]. <p> Previous work has shown that specializing operating system components with respect to system states that are likely to occur can produce significant speedups [28]. To validate this assertion, Tempo has been used to specialize the Sun Remote Procedure Call (RPC) <ref> [24, 25] </ref>. As is common for system components, Sun RPC is generic and structured in layers. Therefore, once a given remote procedure call is fixed, the interpretive overhead can be eliminated.
Reference: [25] <author> G. Muller, E.N. Volanschi, and R. Marlet. </author> <title> Scaling up partial evaluation for optimizing a commercial RPC protocol. </title> <booktitle> In ACM SIGPLAN Conference on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> June </month> <year> 1997. </year> <note> ACM Press. To appear. </note>
Reference-contexts: As a result, significant existing applications can be handled without major rewriting. The results of the analysis are used to drive both Tempo's compile-time and run-time specializer [9, 10]. We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code <ref> [24, 25, 31] </ref>. It has also been applied successfully to many other application domains such as domain-specific language interpreters [30], and, in the context of run-time specialization, scientific programming and image processing [27]. <p> Previous work has shown that specializing operating system components with respect to system states that are likely to occur can produce significant speedups [28]. To validate this assertion, Tempo has been used to specialize the Sun Remote Procedure Call (RPC) <ref> [24, 25] </ref>. As is common for system components, Sun RPC is generic and structured in layers. Therefore, once a given remote procedure call is fixed, the interpretive overhead can be eliminated.
Reference: [26] <author> V. Nirkhe and W. Pugh. </author> <title> Partial evaluation and high-level imperative programming languages with applications in hard real-time systems. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <pages> pages 269-280, </pages> <address> Albuquerque, New Mexico, USA, Jan-uary 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages <ref> [2, 3, 4, 19, 26] </ref> as well as for functional languages [8, 17, 19, 29]. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program.
Reference: [27] <author> F. Noel, L. Hornof, C. Consel, and J. Lawall. </author> <title> Automatic, template-based run-time specialization : Implementation and experimental study. </title> <institution> Rapport de recherche 1065, Irisa, Rennes, France, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: It has also been applied successfully to many other application domains such as domain-specific language interpreters [30], and, in the context of run-time specialization, scientific programming and image processing <ref> [27] </ref>. In the next section, Sect. 2, we explain flow, context, and return sensitivity and show how they improve the precision of the binding-time analysis. The details of the analysis are then presented in Sect. 3. Existing applications on which this analysis is being applied are given in Sect. 4. <p> In this study, the abstract machine implementation consists of about 1000 lines of code, while the interpretor is roughly 4000 lines. As well, scientific algorithms and image processing functions have been specialized by Tempo <ref> [27] </ref>. Functions such as Fast Fourier Transform, cubic spline interpolation, and image dithering have been specialized, producing significant speedups. In addition to compile-time specialization, these functions were also specialized at run time, using Tempo's automatic, template-based run-time specializer [10].
Reference: [28] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 1995 ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 314-324, </pages> <address> Copper Mountain Resort, CO, USA, </address> <month> December </month> <year> 1995. </year> <title> ACM Operating Systems Reviews, </title> <publisher> 29(5),ACM Press. </publisher>
Reference-contexts: Indeed, this is an area where the conflict between generality (an operating system must, by definition, deal with a wide variety of situations) and performance is especially acute. It is therefore not surprising that many opportunities for applying partial evaluation to operating systems code have been identified <ref> [11, 12, 28] </ref>. However, we have discovered that existing partial-evaluation technology is not sufficiently advanced to effectively specialize the corresponding programs. This is due to a lack of accuracy of binding-time analyses in dealing with typical features of imperative programs, such as pointers, aliases, and side-effecting functions. <p> Specializing systems code has been the main target for which Tempo and its analyses have been designed. Previous work has shown that specializing operating system components with respect to system states that are likely to occur can produce significant speedups <ref> [28] </ref>. To validate this assertion, Tempo has been used to specialize the Sun Remote Procedure Call (RPC) [24, 25]. As is common for system components, Sun RPC is generic and structured in layers. Therefore, once a given remote procedure call is fixed, the interpretive overhead can be eliminated.
Reference: [29] <author> B. Rytz and M. Gengler. </author> <title> A polyvariant binding time analysis. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> San Francisco, Califor-nia, </address> <note> June 1992 (Technical Report YALEU/DCS/RR-909), pages 21-28. </note> <institution> New Haven, CT: Yale University, </institution> <year> 1992. </year>
Reference-contexts: is due to the fact that return sensitivity allows static return values to be propagated interprocedurally, despite the fact that functions contain dynamic side-effects. 5 Related Work There are a number of existing off-line partial evaluators for imperative languages [2, 3, 4, 19, 26] as well as for functional languages <ref> [8, 17, 19, 29] </ref>. All existing imperative binding-time analyses are flow-insensitive; that is, one single description of the binding-time state is maintained for an entire program. <p> If a parameter or non-local variable is dynamic at any call site, it will be considered dynamic at every call site. On the other hand, there are a number of existing binding-time analyses for functional languages which are context sensitive, more commonly referred to as polyvariant <ref> [8, 17, 29] </ref>. However, a context-sensitive binding-time analysis for an imperative language is more complicated since contexts must include the binding-times of the non-local variables that are read by a function and the state must be updated with respect to non-local variables that are written.
Reference: [30] <author> S. Thibault and C. Consel. </author> <title> A framework of application generator design. </title> <institution> Rapport de recherche RR-3005, Inria, Rennes, France, </institution> <month> December </month> <year> 1996. </year> <note> To appear in ACM SIGSOFT Symposium on Software Reusability (SSR'97). </note>
Reference-contexts: We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code [24, 25, 31]. It has also been applied successfully to many other application domains such as domain-specific language interpreters <ref> [30] </ref>, and, in the context of run-time specialization, scientific programming and image processing [27]. In the next section, Sect. 2, we explain flow, context, and return sensitivity and show how they improve the precision of the binding-time analysis. The details of the analysis are then presented in Sect. 3. <p> (s) = ret-in (s) return s : out (s) = fg return s exp e : out (s) = fg id f (formals) body s : ret-in (s) = fg out (f ) = f (loc; lookup (ret-out (s); loc)) j loc 2 def-non-locals (f )g translate specifications into applications <ref> [6, 7, 30] </ref>. Tempo plays a key role in the approach presented in [30], in which a specific application is generated by combining and instantiating generic components. This approach involves defining an abstract machine and a micro-language interpreter, both of which contain interpretation overhead which is eliminated by partial evaluation. <p> Tempo plays a key role in the approach presented in <ref> [30] </ref>, in which a specific application is generated by combining and instantiating generic components. This approach involves defining an abstract machine and a micro-language interpreter, both of which contain interpretation overhead which is eliminated by partial evaluation.
Reference: [31] <author> E.N. Volanschi, G. Muller, C. Consel, L. Hornof, J. Noye, and C. Pu. </author> <title> A uniform automatic approach to copy elimination in system extensions via program specialization. </title> <institution> Rapport de recherche 2903, Inria, Rennes, France, </institution> <month> June </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: As a result, significant existing applications can be handled without major rewriting. The results of the analysis are used to drive both Tempo's compile-time and run-time specializer [9, 10]. We have found that, with this extra precision obtained by our analysis, we are able to effectively specialize systems code <ref> [24, 25, 31] </ref>. It has also been applied successfully to many other application domains such as domain-specific language interpreters [30], and, in the context of run-time specialization, scientific programming and image processing [27].
References-found: 31

