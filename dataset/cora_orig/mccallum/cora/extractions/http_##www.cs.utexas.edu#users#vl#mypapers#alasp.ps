URL: http://www.cs.utexas.edu/users/vl/mypapers/alasp.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/
Root-URL: http://www.cs.utexas.edu
Title: Action Languages, Answer Sets and Planning  
Author: Vladimir Lifschitz 
Address: Austin  
Affiliation: University of Texas at  
Abstract: This is a discussion of some of the achievements and challenges related to representing actions and the design of planners from the perspective of logic programming. We talk about recent work on action languages and translating them into logic programming, on representing possible histories of an action domain by answer sets, on efficient implementations of the answer set semantics and their use for generating plans, and on causal logic and its relation to planning algorithms. Recent progress in these areas may lead to the creation of planners which are based on the ideas of logic programming and combine the use of expressive action description languages with efficient computa tional procedures.
Abstract-found: 1
Intro-found: 1
Reference: [ Clark, 1978 ] <author> Keith Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: The computational method for causal theories proposed in [ McCain and Turner, 1997 ] , called literal completion, is an elaboration of the completion method from <ref> [ Clark, 1978 ] </ref> proposed as a semantics for negation as failure. Theorems relating causal theories to logic programs can be found in [ Geffner, 1990 ] and [ Turner, 1998 ] .
Reference: [ Denecker and De Schreye, 1993 ] <author> Mark Denecker and Danny De Schreye. </author> <title> Representing incomplete knowledge in abductive logic programming. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1993 Int'l Symposium, </booktitle> <pages> pages 147-163, </pages> <year> 1993. </year>
Reference-contexts: It only asserts that a literal which is a consequence of the program|that is to say, which belongs to all its answer sets|is true in the corresponding action domain. Alternative translations from action languages to logic programming proposed in <ref> [ Denecker and De Schreye, 1993 ] </ref> , [ Dung, 1993 ] and [ Turner, 1997 ] show that there may exist a close relationship between possible histories of an action domain (paths in its transition diagram) on the one hand, and individual answer sets for a logic program on the
Reference: [ Dimopoulos et al., 1997 ] <author> Yannis Dimopoulos, Bernhard Nebel, and Jana Koehler. </author> <title> Encoding planning problems in non-monotonic logic programs. </title> <booktitle> In Proc. </booktitle> <address> ECP-97, </address> <year> 1997. </year>
Reference-contexts: Yet another possibility is to use the implementation of default logic developed at the University of Kentucky (http://www.cs.engr.uky.edu/~lpnmr/DeReS.html). 6 Causal Reasoning The methods for encoding action domains in logic programming proposed in [ Subrahmanian and Zaniolo, 1995 ] and <ref> [ Dimopoulos et al., 1997 ] </ref> are not applicable in the presence of static causal dependencies. Consequently, as discussed in the introduction, they cannot be used when plans may include actions with indirect effects. <p> essential for the soundness of the translation relative to the semantics of C. 9 Planning for Domains Described in C Now we can go back to the issue raised at the beginning of Section 6: the need to extend the planning method from [ Subrahmanian and Zaniolo, 1995 ] and <ref> [ Dimopoulos et al., 1997 ] </ref> to action domains described using both dynamic and static causal dependencies. Recall that the translation defined in the previous section gives a logic program whose answer sets represent the edges of the transition diagram for a given set of C propositions.
Reference: [ Dung, 1993 ] <author> Phan Minh Dung. </author> <title> Representing actions in logic programming and its applications in database updates. </title> <booktitle> In Logic Programming: Proceedings of the Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 222-238, </pages> <year> 1993. </year>
Reference-contexts: It only asserts that a literal which is a consequence of the program|that is to say, which belongs to all its answer sets|is true in the corresponding action domain. Alternative translations from action languages to logic programming proposed in [ Denecker and De Schreye, 1993 ] , <ref> [ Dung, 1993 ] </ref> and [ Turner, 1997 ] show that there may exist a close relationship between possible histories of an action domain (paths in its transition diagram) on the one hand, and individual answer sets for a logic program on the other.
Reference: [ Eiter et al., 1998 ] <author> Thomas Eiter, Nicola Leone, Cristinel Mateis, Gerald Pfeifer, and Francesco Scarcello. </author> <title> The kr system dlv: Progress report, comparisons and benchmarks. </title> <editor> In Anthony Cohn, Lenhart Schubert, and Stuart Shapiro, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 406-417, </pages> <year> 1998. </year>
Reference-contexts: They report that, for careful and compact encodings of planning problems, the performance of their method is comparable to that of efficient general-purpose planners. One other system that can apparently be used for planning in a similar way is dlv, the implementation of disjunctive logic programming described in <ref> [ Eiter et al., 1998 ] </ref> . The home pages of smodels and dlv can be accessed through the Library of Logic Programming Systems and Test Cases (http://www.uni-koblenz.de/ag-ki/LP/lp systems.html).
Reference: [ Geffner, 1990 ] <author> Hector Geffner. </author> <title> Causal theories for nonmonotonic reasoning. </title> <booktitle> In Proc. AAAI-90, </booktitle> <pages> pages 524-530, </pages> <year> 1990. </year>
Reference-contexts: The theory we concentrate on in this section is proposed in [ McCain and Turner, 1997 ] and generalized in [ Lifschitz, 1997 ] . Some of its roots are found in <ref> [ Geffner, 1990 ] </ref> and [ Lin, 1995 ] . In this theory, we distinguish between claiming that a proposition is true and making the stronger assertion that there is a cause for it to be true. <p> The computational method for causal theories proposed in [ McCain and Turner, 1997 ] , called literal completion, is an elaboration of the completion method from [ Clark, 1978 ] proposed as a semantics for negation as failure. Theorems relating causal theories to logic programs can be found in <ref> [ Geffner, 1990 ] </ref> and [ Turner, 1998 ] . The causal calculator is a system, written at the University of Texas, that can perform reasoning about actions and planning for domains described by causal theories.
Reference: [ Gelfond and Lifschitz, 1991 ] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: In this sense, Prolog programs are similar to complete theories. The issue of representing actions by logic programs in the absence of complete information was addressed in [ Gelfond and Lifschitz, 1993 ] using "extended" logic programs introduced in <ref> [ Gelfond and Lifschitz, 1991 ] </ref> . In addition to the negation as failure operator not , an extended program can use the second negation symbol :, taken from the vocabulary of classical logic.
Reference: [ Gelfond and Lifschitz, 1993 ] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Representing action and change by logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 17 </volume> <pages> 301-322, </pages> <year> 1993. </year>
Reference-contexts: In this sense, Prolog programs are similar to complete theories. The issue of representing actions by logic programs in the absence of complete information was addressed in <ref> [ Gelfond and Lifschitz, 1993 ] </ref> using "extended" logic programs introduced in [ Gelfond and Lifschitz, 1991 ] . In addition to the negation as failure operator not , an extended program can use the second negation symbol :, taken from the vocabulary of classical logic. <p> The method for representing actions in logic programming proposed in <ref> [ Gelfond and Lifschitz, 1993 ] </ref> is described there in a more systematic way: by defining a translation from an "action language" A into the language of extended logic programs. <p> In this sense, the semantics of A incorporates a solution to (a simple special case of) the frame problem. The main theorem of <ref> [ Gelfond and Lifschitz, 1993 ] </ref> shows that the translation from A into the language of logic programming proposed in that paper is sound with respect to the semantics of A. 4 Answer Sets and Histories The set of consequences of an extended logic program is defined as the intersection of
Reference: [ Giunchiglia and Lifschitz, 1998 ] <author> Enrico Giunchiglia and Vladimir Lifschitz. </author> <title> An action language based on causal explanation: </title> <note> Preliminary report. In Proc. AAAI-98, 1998. To appear. </note>
Reference-contexts: The causal calculator is written in Prolog. Some information on its perfromance can be found in [ McCain and Turner, 1998 ] . 9 7 Action Language C In <ref> [ Giunchiglia and Lifschitz, 1998 ] </ref> , ideas of causal logic are applied to the design of an action language that is considerably more expressive than A. <p> Results relating C to causal logic <ref> [ Giunchiglia and Lifschitz, 1998 ] </ref> and causal logic to logic programming [ Turner, 1998 ] imply that the answer sets for the program formed in this way from a set of static and dynamic laws are in a 1-1 correspondence with the edges of the transition diagram corresponding to this
Reference: [ Green, 1969 ] <author> Cordell Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proc. IJCAI, </booktitle> <pages> pages 219-240, </pages> <year> 1969. </year> <month> 18 </month>
Reference: [ Hanks and McDermott, 1987 ] <author> Steve Hanks and Drew McDermott. </author> <title> Non--monotonic logic and temporal projection. </title> <journal> Artificial Intelligence, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: This set may be incomplete|it may include, for instance, literals (2), but neither atoms (3) nor their negations. 3 Action Language A Many authors who write about representing action domains explain their ideas by showing how they apply to specific examples, such as the Yale Shooting scenario from <ref> [ Hanks and McDermott, 1987 ] </ref> and its enhancements, or various versions of the blocks world.
Reference: [ Kautz and Selman, 1992 ] <author> Henry Kautz and Bart Selman. </author> <title> Planning as sat-isfiability. </title> <booktitle> In Proc. ECAI-92, </booktitle> <pages> pages 359-363, </pages> <year> 1992. </year>
Reference-contexts: This method is similar to what is known as satisfiability planning <ref> [ Kautz and Selman, 1992 ] </ref> |treating a planning problem as the problem of finding an interpretation satisfying a set of propositional formulas.
Reference: [ Kautz and Selman, 1996 ] <author> Henry Kautz and Bart Selman. </author> <title> Pushing the envelope: planning, propositional logic and stochastic search. </title> <booktitle> In Proc. AAAI-96, </booktitle> <pages> pages 1194-1201, </pages> <year> 1996. </year>
Reference-contexts: Satisfiability planning has been successfully applied to some of the planning problems that are known to lead to serious computational difficulties in traditional planners <ref> [ Kautz and Selman, 1996 ] </ref> . The Subrahmanian|Zaniolo proposal is different in that they suggest using propositional logic programs under the answer set semantics instead of propositional theories.
Reference: [ Lifschitz, 1997 ] <author> Vladimir Lifschitz. </author> <title> On the logic of causal explanation. </title> <journal> Artificial Intelligence, </journal> <volume> 96 </volume> <pages> 451-465, </pages> <year> 1997. </year>
Reference-contexts: To see how this limitation can be lifted, we need to consider some of the recent work on causal reasoning. The theory we concentrate on in this section is proposed in [ McCain and Turner, 1997 ] and generalized in <ref> [ Lifschitz, 1997 ] </ref> . Some of its roots are found in [ Geffner, 1990 ] and [ Lin, 1995 ] . In this theory, we distinguish between claiming that a proposition is true and making the stronger assertion that there is a cause for it to be true.
Reference: [ Lin, 1995 ] <author> Fangzhen Lin. </author> <title> Embracing causality in specifying the indirect effects of actions. </title> <booktitle> In Proc. IJCAI-95, </booktitle> <pages> pages 1985-1991, </pages> <year> 1995. </year>
Reference-contexts: The theory we concentrate on in this section is proposed in [ McCain and Turner, 1997 ] and generalized in [ Lifschitz, 1997 ] . Some of its roots are found in [ Geffner, 1990 ] and <ref> [ Lin, 1995 ] </ref> . In this theory, we distinguish between claiming that a proposition is true and making the stronger assertion that there is a cause for it to be true. <p> to the semantics of C, propositions (13) and (14) represent the transition diagram shown in Figure 2. 11 L1 L2 As an example of the use of static laws in C, consider a suitcase with two latches (Figure 3) which is spring-loaded: it is open whenever both latches are up <ref> [ Lin, 1995 ] </ref> .
Reference: [ McCain and Turner, 1997 ] <author> Norman McCain and Hudson Turner. </author> <title> Causal theories of action and change. </title> <booktitle> In Proc. AAAI-97, </booktitle> <pages> pages 460-465, </pages> <year> 1997. </year>
Reference-contexts: Consequently, as discussed in the introduction, they cannot be used when plans may include actions with indirect effects. To see how this limitation can be lifted, we need to consider some of the recent work on causal reasoning. The theory we concentrate on in this section is proposed in <ref> [ McCain and Turner, 1997 ] </ref> and generalized in [ Lifschitz, 1997 ] . Some of its roots are found in [ Geffner, 1990 ] and [ Lin, 1995 ] . <p> Even though causal theories and logic programs have somewhat different properties, there exists a close relationship between them, and this relationship played an important role in the development of causal logic. The computational method for causal theories proposed in <ref> [ McCain and Turner, 1997 ] </ref> , called literal completion, is an elaboration of the completion method from [ Clark, 1978 ] proposed as a semantics for negation as failure.
Reference: [ McCain and Turner, 1998 ] <author> Norman McCain and Hudson Turner. </author> <title> Satisfi-ability planning with causal theories. </title> <editor> In Anthony Cohn, Lenhart Schu-bert, and Stuart Shapiro, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 212-223, </pages> <year> 1998. </year>
Reference-contexts: It uses the process of literal completion to reduce these tasks to propositional reasoning problems, which are submitted to a propositional solver. The causal calculator is written in Prolog. Some information on its perfromance can be found in <ref> [ McCain and Turner, 1998 ] </ref> . 9 7 Action Language C In [ Giunchiglia and Lifschitz, 1998 ] , ideas of causal logic are applied to the design of an action language that is considerably more expressive than A.
Reference: [ McCarthy, 1959 ] <author> John McCarthy. </author> <title> Programs with common sense. </title> <booktitle> In Proc. Teddington Conference on the Mechanization of Thought Processes, </booktitle> <pages> pages 75-91, </pages> <address> London, </address> <year> 1959. </year> <editor> Her Majesty's Stationery Office. Reproduced in [ McCarthy, </editor> <year> 1990 </year> ] . 
Reference: [ McCarthy, 1990 ] <author> John McCarthy. </author> <title> Formalizing Common Sense: Papers by John McCarthy. </title> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1990. </year>
Reference: [ Niemela and Simons, 1996 ] <author> Ilkka Niemela and Patrik Simons. </author> <title> Efficient implementation of the well-founded and stable model semantics. </title> <booktitle> In Proc. Joint Int'l Conf. and Symp. on Logic Programming, </booktitle> <pages> pages 289-303, </pages> <year> 1996. </year>
Reference-contexts: One such system, called smodels, is described in <ref> [ Niemela and Simons, 1996 ] </ref> . The current version of the system does not handle programs with classical negation, so that any answer set it computes is a set of atoms.
Reference: [ Reiter, 1980 ] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference: [ Simons, 1997 ] <author> Patrik Simons. </author> <title> Towards constraint satisfaction through logic programs and the stable model semantics. </title> <type> Technical Report 47, </type> <institution> Helsinki University of Technology, </institution> <year> 1997. </year> <month> 19 </month>
Reference-contexts: It treats a logic program as a constraint on a set of atoms, and generates the sets that satisfy this constraint. When smodels is used to solve propositional satisfiability problems encoded in the language of logic programming, its performance is comparable to the performance of efficient propositional solvers <ref> [ Simons, 1997 ] </ref> . The availability of this system made it possible for Dimopoulos, Nebel and Koehler [1997] to conduct planning experiments using a method similar to the one proposed in [ Subrahmanian and Zaniolo, 1995 ] .
Reference: [ Subrahmanian and Zaniolo, 1995 ] <author> V.S. Subrahmanian and Carlo Zaniolo. </author> <title> Relating stable models and AI planning domains. </title> <booktitle> In Proc. </booktitle> <address> ICLP-95, </address> <year> 1995. </year>
Reference-contexts: Using logic programs is an attractive idea because encoding action domains in logic programming may be easier than encoding them in classical propositional logic. 5 Computing Answer Sets To implement the planning method from <ref> [ Subrahmanian and Zaniolo, 1995 ] </ref> , we need an efficient system for computing answer sets. One such system, called smodels, is described in [ Niemela and Simons, 1996 ] . <p> The availability of this system made it possible for Dimopoulos, Nebel and Koehler [1997] to conduct planning experiments using a method similar to the one proposed in <ref> [ Subrahmanian and Zaniolo, 1995 ] </ref> . They report that, for careful and compact encodings of planning problems, the performance of their method is comparable to that of efficient general-purpose planners. <p> Yet another possibility is to use the implementation of default logic developed at the University of Kentucky (http://www.cs.engr.uky.edu/~lpnmr/DeReS.html). 6 Causal Reasoning The methods for encoding action domains in logic programming proposed in <ref> [ Subrahmanian and Zaniolo, 1995 ] </ref> and [ Dimopoulos et al., 1997 ] are not applicable in the presence of static causal dependencies. Consequently, as discussed in the introduction, they cannot be used when plans may include actions with indirect effects. <p> the translation of a static law is essential for the soundness of the translation relative to the semantics of C. 9 Planning for Domains Described in C Now we can go back to the issue raised at the beginning of Section 6: the need to extend the planning method from <ref> [ Subrahmanian and Zaniolo, 1995 ] </ref> and [ Dimopoulos et al., 1997 ] to action domains described using both dynamic and static causal dependencies.
Reference: [ Turner, 1997 ] <author> Hudson Turner. </author> <title> Representing actions in logic programs and default theories: a situation calculus approach. </title> <journal> Journal of Logic Programming, </journal> <volume> 31 </volume> <pages> 245-298, </pages> <year> 1997. </year>
Reference-contexts: Alternative translations from action languages to logic programming proposed in [ Denecker and De Schreye, 1993 ] , [ Dung, 1993 ] and <ref> [ Turner, 1997 ] </ref> show that there may exist a close relationship between possible histories of an action domain (paths in its transition diagram) on the one hand, and individual answer sets for a logic program on the other.
Reference: [ Turner, 1998 ] <author> Hudson Turner. </author> <title> A logic of universal causation. </title> <journal> Artificial Intelligence, </journal> <note> 1998. To appear. 20 </note>
Reference-contexts: Theorems relating causal theories to logic programs can be found in [ Geffner, 1990 ] and <ref> [ Turner, 1998 ] </ref> . The causal calculator is a system, written at the University of Texas, that can perform reasoning about actions and planning for domains described by causal theories. <p> Results relating C to causal logic [ Giunchiglia and Lifschitz, 1998 ] and causal logic to logic programming <ref> [ Turner, 1998 ] </ref> imply that the answer sets for the program formed in this way from a set of static and dynamic laws are in a 1-1 correspondence with the edges of the transition diagram corresponding to this set.
References-found: 25

