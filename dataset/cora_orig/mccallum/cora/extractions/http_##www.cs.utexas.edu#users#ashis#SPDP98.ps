URL: http://www.cs.utexas.edu/users/ashis/SPDP98.ps
Refering-URL: http://www.cs.utexas.edu/users/ashis/papers.html
Root-URL: http://www.cs.utexas.edu
Email: ashis@cs.utexas.edu  garg@ece.utexas.edu  
Title: Predicate Control for Active Debugging of Distributed Programs  
Author: Ashis Tarafdar Vijay K. Garg 
Address: Austin, TX 78712-1188, USA  Austin, TX 78712-1084, USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  Department of Electrical and Computer Engineering The University of Texas at Austin  
Abstract: Existing approaches to debugging distributed systems involve a cycle of passive observation followed by computation replaying. We propose predicate control as an active approach to debugging such systems. The predicate control approach involves a cycle of observation followed by controlled replaying of computations, based on observation. We formalize the predicate control problem for both offline and on-line scenarios. We prove that off-line predicate control for general boolean predicates is NP-hard. However, we provide an efficient solution for off-line predicate control for the class of disjunctive predicates. We further solve on-line predicate control for disjunctive predicates under certain restrictions on the system. Lastly, we demonstrate how both off-line and on-line predicate control facilitate distributed debugging by allowing the programmer to control computations to maintain global safety properties. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 4. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Since then, detection algorithms have been designed for many different classes of bugs such as: race conditions [11], predicates on single global states <ref> [1] </ref>, predicates based on sequences of global states [5]. Research in replaying trace computations have focussed on reducing the size of the trace by determining which events are necessary for successful replaying [9].
Reference: [2] <author> S. Bulgannawar and N. H. Vaidya. </author> <title> A distributed k-mutual exclusion algorithm. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 153160. </pages> <publisher> IEEE, </publisher> <year> 1995. </year>
Reference-contexts: pending := f alse; k := j; scapegoat := true; send (ack; C k ); Definitions: init (i) true for one i and false for others C set of all controllers select (Z) arbitrary element of non-empty set Z The k-mutual exclusion problem (a recent study may be found in <ref> [2] </ref>) is a generalization of the traditional mutual exclusion problem where at most k processes can be in the critical section at the same time. For k = n 1, this specifies that at all times, at least one process must not be in the critical section.
Reference: [3] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1):6375, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: Research in distributed debugging has focussed on two problems: detecting bugs in a distributed computation and replaying a traced distributed computation. Research in the detection of bugs mainly differs in the types of bugs specified. The seminal work in this area is the global snapshot algorithm <ref> [3] </ref> which is used to detect stable bugs (which re main true once they become true). Since then, detection algorithms have been designed for many different classes of bugs such as: race conditions [11], predicates on single global states [1], predicates based on sequences of global states [5].
Reference: [4] <author> V. K. Garg and B. Waldecker. </author> <title> Detection of strong unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 7(12):13231333, </volume> <month> De-cember </month> <year> 1996. </year>
Reference-contexts: So, if we have an overlapping set of false-intervals, then every global sequence must contain a global state in which B is false, and no satisfying control strategy exists. This is stated in the following result from <ref> [4] </ref>: Lemma 2 In a deposet, (S 1 ; : : : ; S n ; ;; ), with causal precedence (S; !): if 9I 1 ; : : : ; I n : overlap (I 1 ; : : : ; I n ) then there is no global sequence <p> The thicker intervals in the process executions indicate intervals when the servers weren't available for service. The system should have been designed to ensure that one server was available at all times. So we run a predicate detection algorithm on C 1 (such as that in <ref> [4] </ref>) to detect bug 1 : all the servers are unavailable. We detect two consistent global states G and H, as shown in the diagram, where bug 1 is possible. <p> We run the predicate detection algorithm in <ref> [4] </ref> to detect that bug 2 is indeed possible in C 2 . We now impose the required safety predicate that e must happen before f and control C 2 using our off-line algorithm. The resulting computation C 3 in Figure 4 (c) is found to be satisfactory.
Reference: [5] <author> M. Hurfin, N. Plouzeau, and M. Raynal. </author> <title> Detecting atomic sequences of predicates in distributed computations. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 3242. </pages> <address> ACM/ONR, </address> <year> 1993. </year>
Reference-contexts: Since then, detection algorithms have been designed for many different classes of bugs such as: race conditions [11], predicates on single global states [1], predicates based on sequences of global states <ref> [5] </ref>. Research in replaying trace computations have focussed on reducing the size of the trace by determining which events are necessary for successful replaying [9]. Our approach focusses on adding a control mechanism to the debugging process to allow computations to be run under safety constraints.
Reference: [6] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: We say s ; t (s remotely precedes t) if the message sent in the event after s is received in the event before t. Given these relations, the causally precedes (happened before) relation <ref> [6] </ref>, !, is defined as the transitive closure of the union of im and ;. Note that ! is an irreflexive partial-order over states in all processes.
Reference: [7] <author> A. Maggiolo-Schettini, H. Wedde, and J. Winkowski. </author> <title> Modeling a solution for a control problem in distributed systems by restrictions. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 13(1):6183, </address> <month> January </month> <year> 1981. </year>
Reference-contexts: Our approach focusses on adding a control mechanism to the debugging process to allow computations to be run under safety constraints. We are aware of two previous studies of controlling distributed systems to maintain classes of global predicates. One study <ref> [7] </ref> allows global properties within the class of conditional elementary restrictions [7]. <p> We are aware of two previous studies of controlling distributed systems to maintain classes of global predicates. One study <ref> [7] </ref> allows global properties within the class of conditional elementary restrictions [7]. Unlike our model of a distributed system, their model uses an off-line specification of pair-wise mutually exclusive states and does not use causality. [13] studies the on-line maintenance of a class of global predicates based on ensuring that a sum expression on local variables does not exceed a threshold.
Reference: [8] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <booktitle> In Parallel and Distributed Algorithms: Proc. of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 215226. </pages> <publisher> Elsevier Science Publishers B. V. (North Holland), </publisher> <year> 1989. </year>
Reference-contexts: It has been established that (G; ) is a lat tice <ref> [8] </ref>. A global state, G, is said to be consistent if 8x; y 2 G : xky. A consistent global state captures the notion of a global state that could possibly occur in the distributed computation.
Reference: [9] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Optimal tracing and replay for debugging message-passing programs. </title> <journal> The Journal of Supercomputing, </journal> <volume> 8(4):371388, </volume> <year> 1995. </year>
Reference-contexts: Research in replaying trace computations have focussed on reducing the size of the trace by determining which events are necessary for successful replaying <ref> [9] </ref>. Our approach focusses on adding a control mechanism to the debugging process to allow computations to be run under safety constraints. We are aware of two previous studies of controlling distributed systems to maintain classes of global predicates.
Reference: [10] <author> M. Singhal. </author> <title> A taxonomy of distributed mutual exclusion. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18:94101, </volume> <year> 1993. </year>
Reference-contexts: If we define the false-intervals to be critical sections, our problem becomes equivalent to (n1)-mutual exclusion. Our distributed control strategy, therefore, also solves the (n 1)-mutual exclusion problem. Evaluation We follow the general guidelines in <ref> [10] </ref> for evaluating mutual-exclusion algorithms. Since only the critical sections of the scapegoat cause any overhead and the remaining critical section entries do not, we measure the overhead over n critical section entries.
Reference: [11] <author> K. Tai. </author> <title> Race analysis of traces of asynchronous message-passing programs. </title> <booktitle> In Proceedings of the 17th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 261 268. </pages> <publisher> IEEE, </publisher> <year> 1997. </year>
Reference-contexts: The seminal work in this area is the global snapshot algorithm [3] which is used to detect stable bugs (which re main true once they become true). Since then, detection algorithms have been designed for many different classes of bugs such as: race conditions <ref> [11] </ref>, predicates on single global states [1], predicates based on sequences of global states [5]. Research in replaying trace computations have focussed on reducing the size of the trace by determining which events are necessary for successful replaying [9].
Reference: [12] <author> A. Tarafdar and V. K. Garg. </author> <title> Predicate control for active debugging of distributed programs. </title> <type> Technical Report ECE-PDS-1998-002, </type> <institution> Parallel and Distributed Systems Laboratory, ECE Dept. University of Texas at Austin, </institution> <year> 1998. </year> <note> available at http://maple.ece.utexas.edu as technical report TR-PDS-1998-002. </note>
Reference-contexts: Conversely, given a satisfying global sequence, we can construct a satisfying control strategy that would only allow that sequence as a possible run. Therefore, the problem of detecting if a satisfying control strategy exists is equivalent to SGSD. A detailed proof of this fact may be found in <ref> [12] </ref>. This equivalence indicates that: Theorem 1 Off-line predicate control is NP-hard. 5. Off-line Disjunctive Predicate Control Since predicate control is NP-hard in general, we restrict our attention to the class of disjunctive predicates. <p> We attempt to find such a pair of false and true intervals in L2 - L4. We are guaranteed to find an overlapping set of false intervals if no such pair can be found (for the proof of this fact, refer to <ref> [12] </ref>). So by Lemma 2, we can safely exit at L3 with No Controller Exists. Once we have found such a pair, we update our output chain by executing procedure AddControl () in L14 - L18. Normally, a tuple, g [k 0 ] C ; next (k), will be output. <p> Once this is done, we remember this iteration's true interval in the variable k (at L10) and repeat the loop. Once we exit the loop, we output the last C ; tuple to finish the chain and exit with the chain as output. We refer the reader to <ref> [12] </ref> for the proof of correctness of this algorithm and we merely state: Theorem 2 The algorithm in Figure 2 terminates and correctly solves the off-line predicate control problem for disjunctive predicates. <p> Since each control message corresponds to a one-way, two-process synchronization (the receives are blocking), we have O (np) such synchronizations. 6. On-line Disjunctive Predicate Control Unfortunately, we find that the problem is impossible to solve for non-trivial (i.e. n 2) disjunctive predicates. The proof for this <ref> [12] </ref> constructs a counter-example scenario that forces any control strategy to deadlock. Theorem 3 The On-Line Predicate Control Problem for non-trivial (n 2) Disjunctive Predicates is impossible to solve. <p> The scapegoat simply requests any other process to take on the role. Since A1 and A2 ensure that it would eventually become true there will be no deadlocks. The details of the proof of correctness may be found in <ref> [12] </ref>.
Reference: [13] <author> A. I. Tomlinson and V. K. Garg. </author> <title> Maintaining global assertions on distributed sytems. </title> <booktitle> In Computer Systems and Education, </booktitle> <pages> pages 257272. </pages> <publisher> Tata McGraw-Hill Publishing Company Limited, </publisher> <year> 1994. </year> <month> 7 </month>
Reference-contexts: One study [7] allows global properties within the class of conditional elementary restrictions [7]. Unlike our model of a distributed system, their model uses an off-line specification of pair-wise mutually exclusive states and does not use causality. <ref> [13] </ref> studies the on-line maintenance of a class of global predicates based on ensuring that a sum expression on local variables does not exceed a threshold. In contrast to these approaches, our focus will be on general global boolean predicates and the class of disjunctive predicates.
References-found: 13

