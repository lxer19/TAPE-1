URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings/kleist.ps.gz
Refering-URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: fkleist,mahans,bjens,hansg@iesd.auc.dk  
Phone: 9220  
Title: Inferring Effect Types in an Applicative Language with Asynchronous Concurrency Keywords: Type inference, process calculi,
Author: Josva Kleist Martin Hansen Bo Jensen Hans Huttel 
Date: December 21, 1994  
Address: Fredrik Bajersvej 7E  Denmark  
Affiliation: Department of Mathematics and Computer Science Aalborg University  Aalborg  
Abstract-found: 0
Intro-found: 1
Reference: [Ber93] <author> Bernard Berthomieu. </author> <title> Programming with Behaviors in an ML framework. The Syntax and Semantics of LCS, </title> <month> April </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In recent years, a number of concurrent programming languages have been based around applicative languages. Best known are CML [Rep92], Facile [GMP89] and LCS <ref> [Ber93] </ref>, all extensions of Standard ML [MTH90]. One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs.
Reference: [BD94] <institution> Dominique Bolignano and Mourad Debabi A Semantic Theory for Concurrent ML Proceedings of Theoretical Aspects of Computer Software (TACS `94), </institution> <address> pages 766-785, </address> <publisher> Springer LNCS 789. </publisher>
Reference-contexts: Nielson and Nielson have proposed a monomorphic effect type discipline for CML [NN93]. Here the effect of executing a CML expression was a process calculus term. In [Tho93] Thomsen proposed a very different effect polymorphic effect type discipline for the Facile language, and independently, in <ref> [BD94] </ref> Bolignano and Debabi gave a very similar type discipline for a subset of Concurrent ML here, the effect of a program is the sort of the program, i.e. the set of communication channels used and all causality is absent.
Reference: [GB82] <author> David Gelernter and Arthur J. Bernstein. </author> <title> Distributed Communication via Global Buffer. </title> <booktitle> ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 10-18, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: In this paper we consider inda, a concurrent applicative language based on a rather different concurrency paradigm, namely the Linda concept of Gelernter and Bernstein <ref> [GB82] </ref>, and give a type system where effects are described by expressions in a process calculus. <p> Should one use subtyping or effect polymorphism? We argue that a combination is needed. We give a sound type reconstruction algorithm based around our idea. Proofs of all results stated in the paper are found in [KJH94]. 1 2 inda inda adds the Linda concept of <ref> [GB82] </ref> to an applied call-by-value -calculus. Linda is based on the notion of a tuple space, a shared memory visible to all processes. A tuple space is a multiset of tuples a tuple consists either of data or evaluating subprocesses.
Reference: [GMP89] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> Facile: A Symmetric Integration of Concurrent and Functional Programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction In recent years, a number of concurrent programming languages have been based around applicative languages. Best known are CML [Rep92], Facile <ref> [GMP89] </ref> and LCS [Ber93], all extensions of Standard ML [MTH90]. One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs.
Reference: [Hen88] <author> Matthew Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The rules at the sequential level are shown in Table 6. Note that as the choice in '+' does not depend on the communication capabilities of a behaviour, '+' is the internal choice of <ref> [Hen88] </ref> rather than the '+' of CCS [Mil89]. [act] a [idle] fi " - fi [term] " " - ~ [choice] 1 fi 1 + fi 2 " - fi 1 [choice] 2 fi 1 + fi 2 " - fi 2 fi 1 1 m - fi 0 [seq] 2
Reference: [KJH94] <author> Josva Kleist, Bo Jensen, and Martin Hansen. </author> <title> Effect Type Systems for Concurrent Functional Languages with Linda Primitives, </title> <month> January </month> <year> 1994. </year> <note> Student Report | Aalborg University. </note>
Reference-contexts: Should one use subtyping or effect polymorphism? We argue that a combination is needed. We give a sound type reconstruction algorithm based around our idea. Proofs of all results stated in the paper are found in <ref> [KJH94] </ref>. 1 2 inda inda adds the Linda concept of [GB82] to an applied call-by-value -calculus. Linda is based on the notion of a tuple space, a shared memory visible to all processes. A tuple space is a multiset of tuples a tuple consists either of data or evaluating subprocesses. <p> The type schemes of the constants are given by the function TypeOf (Table 5). 1 For simplicity we have excluded some rules needed to handle wildcards, see <ref> [KJH94] </ref> [const] ` c : t &" if t TypeOf (c) [var] ` x : t &" if t (x) ` e : t 1 &fi 1 if t 1 t 2 and fi 1 fi 2 ` e : t &fi if x62flF V fl (e) [x 7! t 1 <p> The full details of U are described in <ref> [KJH94] </ref>. The type reconstruction algorithm is sound: Theorem 4.5 If ` e is closed and (fi; t; fi) = W fi (; e) then fi ` e : t &fi 4.5 Semantics of Bexp We can also give an operational semantics for the behaviour expressions. <p> The argument and unification problems also occur in other concurrent functional languages such as CML, Facile and LCS, and the ideas from the type inference algorithm for behaviour types presented here could prove fruitful in these languages. In <ref> [KJH94] </ref> we give another, sort-based effect type system. Compared to behaviours, sorts are less descriptive and do not capture the causality of the Linda primitives but only state which expressions are input and output.
Reference: [Luc87] <author> J.M. Lucassen. </author> <title> Type and Effects: Towards an Integration of Functional and Imperative Programming, 1987. </title> <type> PhD thesis, </type> <institution> Laboratory of Computer Science, MIT. </institution>
Reference-contexts: Best known are CML [Rep92], Facile [GMP89] and LCS [Ber93], all extensions of Standard ML [MTH90]. One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs. Recently, the effect type discipline proposed by Lucassen <ref> [Luc87] </ref> and Talpin and Jouvelot [TJ92] has attracted a lot of interest as a possible means of capturing these non-applicative aspects, the idea being to associate with an expression not only its type but also the side effects of its evaluation.
Reference: [Mil78] <author> Robin Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction In recent years, a number of concurrent programming languages have been based around applicative languages. Best known are CML [Rep92], Facile [GMP89] and LCS [Ber93], all extensions of Standard ML [MTH90]. One would of course want to extend the type inference paradigm of Standard ML <ref> [Mil78] </ref> to cope with the new concurrency constructs. <p> The type system has the property that the type is preserved during evaluation. Theorem 4.4 (Local Preservation) If `e : t &fi and e " - e 0 then `e 0 : t &fi. 4.4 A type reconstruction algorithm Our type reconstruction algorithm T extends the standards ideas of <ref> [Mil78] </ref> we get a type-behaviour pair using the behaviour reconstruction algorithm W fi : T (e) = (t; fi) where (fi; t; fi) = W fi (nil; e) Here nil is the empty type environment and fi is a substitution on type and behaviour variables found by an auxiliary unification algorithm
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The rules at the sequential level are shown in Table 6. Note that as the choice in '+' does not depend on the communication capabilities of a behaviour, '+' is the internal choice of [Hen88] rather than the '+' of CCS <ref> [Mil89] </ref>. [act] a [idle] fi " - fi [term] " " - ~ [choice] 1 fi 1 + fi 2 " - fi 1 [choice] 2 fi 1 + fi 2 " - fi 2 fi 1 1 m - fi 0 [seq] 2 m - ~ [rec] bfi " - <p> An important difference from the behaviour semantics in [NN93] is that we do not use the ordering of behaviours in the semantics. Instead, the ordering can be recovered from our semantics by a simulation ordering in the sense of <ref> [Mil89] </ref>. We use fi m =) fi 0 to specify that fi can evaluate to fi 0 using exactly one m-transition and zero or more "-transitions, i.e. m " -fl m - " -fl .
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In recent years, a number of concurrent programming languages have been based around applicative languages. Best known are CML [Rep92], Facile [GMP89] and LCS [Ber93], all extensions of Standard ML <ref> [MTH90] </ref>. One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs.
Reference: [NN93] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> From CML to Process Algebras. </title> <type> Technical report, </type> <institution> Computer Science Department - Aarhus University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Nielson and Nielson have proposed a monomorphic effect type discipline for CML <ref> [NN93] </ref>. Here the effect of executing a CML expression was a process calculus term. <p> The ype of an expression is t &, t being the ordinary type and the effect of the expression, denoting the communication capabilities of the expression; inspired by work of Nielson and Nielson <ref> [NN93, NN94] </ref>, effects are terms from a process calculus and can be given an operational semantics, giving us a tool to show that the behavioural effect of an expression is indeed sensible. <p> A region identifier should be thought of as being associated with occurrences of makeps. Regions are given by: where i 2 RegId denotes the region identifiers, r 2 RegVar denotes region variables and '[' denotes the union of regions. 4.1 Determining the behaviour of a function In <ref> [NN93] </ref> subtyping was used to give behaviour types to CML in a monomorphic setting where the programmer has to state the type of the arguments to functions; whereas polymorphism was employed in [NN94]. To see which solution is the most appropriate consider the following two problems. <p> Corollary 4.8 If ` e : t &fi and e l - e 0 and ` e 0 : t &fi 0 then there exists m l such that m; fi 0 fi. An important difference from the behaviour semantics in <ref> [NN93] </ref> is that we do not use the ordering of behaviours in the semantics. Instead, the ordering can be recovered from our semantics by a simulation ordering in the sense of [Mil89].
Reference: [NN94] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-Order Concurrent Programs with Finite Communication Topology. </title> <note> To appear in ACM SIGPLAN-SIGACT, </note> <year> 1994. </year>
Reference-contexts: The ype of an expression is t &, t being the ordinary type and the effect of the expression, denoting the communication capabilities of the expression; inspired by work of Nielson and Nielson <ref> [NN93, NN94] </ref>, effects are terms from a process calculus and can be given an operational semantics, giving us a tool to show that the behavioural effect of an expression is indeed sensible. <p> denotes region variables and '[' denotes the union of regions. 4.1 Determining the behaviour of a function In [NN93] subtyping was used to give behaviour types to CML in a monomorphic setting where the programmer has to state the type of the arguments to functions; whereas polymorphism was employed in <ref> [NN94] </ref>. To see which solution is the most appropriate consider the following two problems. The Argument Problem The argument problem arises from the fact that functions bind behaviour.
Reference: [Rep92] <author> John H. Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction In recent years, a number of concurrent programming languages have been based around applicative languages. Best known are CML <ref> [Rep92] </ref>, Facile [GMP89] and LCS [Ber93], all extensions of Standard ML [MTH90]. One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs. <p> Sequential Evaluation The semantics of the sequential evaluation is based on the notion of evaluation contexts of <ref> [Rep92] </ref>: E ::= [ ] j E e j v E j let x = E in e j if E then e 1 else e 2 Any inda expression is a completed evaluation context E [e] containing the subexpression e to be evaluated; the definition of E ensures call-by-value semantics,
Reference: [Rey89] <author> John C. Reynolds. </author> <title> Syntactic Control of Interference | Part 2. </title> <booktitle> Automata Languages and Programming, 16th International Colloquium (ICALP '89), </booktitle> <pages> pages 704-722, </pages> <publisher> Springer LNCS 372. </publisher>
Reference: [Tho93] <author> Bent Thomsen. </author> <title> Polymorphic Sort and Types for Concurrent Functional Programs. </title> <type> Technical report, </type> <institution> European Computer-Industry Research Centre, </institution> <month> June 93. ECRC-93-10. </month>
Reference-contexts: Nielson and Nielson have proposed a monomorphic effect type discipline for CML [NN93]. Here the effect of executing a CML expression was a process calculus term. In <ref> [Tho93] </ref> Thomsen proposed a very different effect polymorphic effect type discipline for the Facile language, and independently, in [BD94] Bolignano and Debabi gave a very similar type discipline for a subset of Concurrent ML here, the effect of a program is the sort of the program, i.e. the set of communication
Reference: [TJ92] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The Type and Effect Discipline. </title> <editor> In Anne Copeland, editor, </editor> <booktitle> Proceedings Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-173. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: One would of course want to extend the type inference paradigm of Standard ML [Mil78] to cope with the new concurrency constructs. Recently, the effect type discipline proposed by Lucassen [Luc87] and Talpin and Jouvelot <ref> [TJ92] </ref> has attracted a lot of interest as a possible means of capturing these non-applicative aspects, the idea being to associate with an expression not only its type but also the side effects of its evaluation. Nielson and Nielson have proposed a monomorphic effect type discipline for CML [NN93].
References-found: 16

