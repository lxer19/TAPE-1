URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1091/CS-TR-92-1091.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1091/
Root-URL: http://www.cs.wisc.edu
Title: Constructing Control Flow From Control Dependence  
Author: THOMAS BALL and SUSAN HORWITZ 
Address: Wisconsin Madison  
Affiliation: University of  
Abstract: Control dependences characterize how the predicates in a program govern the execution of other statements and predicates. Control dependences are defined in terms of a program's control-flow graph; given a control-flow graph G, a corresponding control dependence graph, CDG(G), can be constructed. This paper addresses the inverse problem: we define an algorithm that, given a control dependence graph C, finds a corresponding control-flow graph G (i.e., a graph G such that CDG(G) is isomorphic to C), or determines that no such control-flow graph exists. We call this process CDG-reconstitution. CDG-reconstitution is a necessary part of systems that use and transform program dependence graphs (graphs that combine data dependences and control dependences) as the basis for discovering and performing code transformations. For example, parallelizing or vectorizing compilers as well as program integration tools may construct the program dependence graph(s) of a program (or set of programs) and then manipulate them in various ways to form a new graph. Reconstitution is needed as a final step to find a corresponding program for this graph. Such a process must respect the data and control dependences of the graphwe concentrate on the reconstitution problems caused by control dependences. Our research provides two important advances over existing CDG-reconstitution algorithms. First, while previous algorithms handle only acyclic CDGs, our CDG-reconstitution algorithm correctly handles both acyclic and cyclic control dependence graphs. Second, our algorithm provides an improvement in efficiency over existing algorithms. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, J.E. Hopcroft, and J. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1974). </address>
Reference-contexts: The algorithm performs three main steps. In line <ref> [1] </ref> the function ComputeGoodOrder is called. <p> R-feasible: add a second test after line [3] that checks whether the CFG G is in the restricted class, returning FAIL if it is not. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function ReconstituteCDG (C : CDG) : CFG or FAIL Order : set of ordered pairs of vertices G : CFG begin <ref> [1] </ref> Order := ComputeGoodOrder (C) if Order = FAIL then return (FAIL) fi [2] G := ConstructCFG (C, Order) [3] if not Isomorphic (CDG (G),C) then return (FAIL) fi return (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The next three subsections present each of these three steps in greater detail. <p> PROOF. The proof is straightforward and is left to the reader. ` To determine when the condition in the above lemma holds, a LOW numbering, similar to that used to determine the biconnected components of undirected graphs <ref> [1, pg. 179] </ref>, is defined for each v in C: LOW [v] = MIN ( -#v -#a | $ a fi b FE such that v is a proper ancestor of b - -#a | $ b fi a BE such that v is an ancestor of b - -#lca (a,b) <p> creates the edge set of the CFG: iiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs iiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii <ref> [1] </ref> DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi <p> DFS is initially invoked (line <ref> [1] </ref>) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line [2]). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]).
Reference: 2. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Equivalently, G is reducible if any depth-first search of G identifies the same set of backedges. Roughly stated, reducibility restricts loops to be single-entry. Other equivalent characterizations of reducibility are given in <ref> [2] </ref>. - 4 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh T T F p b EXIT ENTRY T F T r T F ENTRY q a c EXIT r F T T F c ENTRY q p r T F C1 b T T p T T r d ENTRY hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh least one backedge), no vertex <p> The Difficulty of CDG Reconstitution The CDG factors out the postdomination information that is present in the CFG; while the children of a given predicate vertex in a CDG are unordered, in the CFG these vertices are totally ordered by the hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 Natural loops are defined in <ref> [2] </ref>. See the Appendix for a more detailed description of this restricted class of CFGs. - 5 - postdomination relation. The main problem of CDG-reconstitution is to recover an acceptable postdomi-nation order solely from the examination of the CDG (i.e., one that will produce a corresponding CFG). <p> In line <ref> [2] </ref> the function Con-structCFG is called to construct CFG G. The test in line [3] checks whether the CDG of G is isomorphic to C. This test is necessary because ComputeGoodOrder may not fail on some infeasible CDGs. <p> G is in the restricted class, returning FAIL if it is not. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function ReconstituteCDG (C : CDG) : CFG or FAIL Order : set of ordered pairs of vertices G : CFG begin [1] Order := ComputeGoodOrder (C) if Order = FAIL then return (FAIL) fi <ref> [2] </ref> G := ConstructCFG (C, Order) [3] if not Isomorphic (CDG (G),C) then return (FAIL) fi return (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The next three subsections present each of these three steps in greater detail. The final subsection gives a complete example of the reconstitution algorithm. <p> set of the CFG: iiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs iiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) <ref> [2] </ref> add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] <p> DFS is initially invoked (line [1]) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line <ref> [2] </ref>). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line [4]). <p> Although, theoretically, the CDG-reconstitution algorithm presented here works only for CDGs of CFGs in the restricted class, in practice, we believe that a simple CFG transformation will make this algorithm applicable to the CDGs of any reducible CFG. Given a reducible CFG, natural loop analysis <ref> [2] </ref> can be used to identify the nested loops in the graph. Those loops that cannot be expressed as while loops (loops containing a vertex that postdominates the loop entry) can be rewritten in terms of a while loop (that has the postdomination property) and specially marked.
Reference: 3. <author> B. Baker, </author> <title> An Algorithm for Structuring Flow Graphs, </title> <editor> J. </editor> <booktitle> ACM 24(1) pp. </booktitle> <address> 98-120 New York, NY, </address> <month> (January </month> <year> 1977). </year>
Reference-contexts: A CFG or CDG may be annotated with information about the syntactic structures from which it was originally derived in order to recover the syntax later, or a structuring algorithm such as that of <ref> [3] </ref> may be employed to produce a program from a CFG. 2.3. <p> In line [2] the function Con-structCFG is called to construct CFG G. The test in line <ref> [3] </ref> checks whether the CDG of G is isomorphic to C. This test is necessary because ComputeGoodOrder may not fail on some infeasible CDGs. <p> It is easy to modify the algorithm so that it succeeds iff the CDG is R-feasible: add a second test after line <ref> [3] </ref> that checks whether the CFG G is in the restricted class, returning FAIL if it is not. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function ReconstituteCDG (C : CDG) : CFG or FAIL Order : set of ordered pairs of vertices G : CFG begin [1] Order := ComputeGoodOrder (C) if Order = <p> returning FAIL if it is not. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function ReconstituteCDG (C : CDG) : CFG or FAIL Order : set of ordered pairs of vertices G : CFG begin [1] Order := ComputeGoodOrder (C) if Order = FAIL then return (FAIL) fi [2] G := ConstructCFG (C, Order) <ref> [3] </ref> if not Isomorphic (CDG (G),C) then return (FAIL) fi return (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The next three subsections present each of these three steps in greater detail. The final subsection gives a complete example of the reconstitution algorithm. <p> The depth-first search to generate the edges of the CFG takes O (E) time. 3.3. Final Isomorphism Test Once step <ref> [3] </ref> of function ReconstituteCDG (Figure 2) is reached, a CFG G has been constructed. If C is R-feasible then G corresponds to C. <p> iiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT <ref> [3] </ref> add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] <p> DFS is initially invoked (line [1]) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line [2]). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line <ref> [3] </ref>). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line [4]). The edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F).
Reference: 4. <author> T. Ball, S. Horwitz, and T. Reps, </author> <title> Correctness of an algorithm for reconstituting a program from a dependence graph, </title> <type> Technical Report #947, </type> <institution> Computer Sciences Department, University of Wisconsin - Madison, Madison, </institution> <address> WI (July 1990). </address>
Reference-contexts: = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 <ref> [4] </ref> DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi <p> The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line <ref> [4] </ref>). The edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F). Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdomina tor of 4 in the call DFS (4,5) (line [6]). <p> FUTURE WORK 6.1. Data Dependences and PDG-reconstitution CDG-reconstitution is a component of PDG-reconstitution. In PDG-reconstitution, data dependences (as well as control dependences) determine an order between vertices. We have described and proved correct an algorithm for PDG-reconstitution for PDGs in which the underlying CDG is a tree <ref> [4] </ref>. A data dependence from vertex v to w will determine an order between the ancestors of v and w in the CDG that are children of the least-common ancestor of v and w. <p> In a CDG that is a general graph, the same general principle holds (by ignoring the backedges in the CDG, the least-common ancestor relation is well-defined). We believe that the algorithm in <ref> [4] </ref>, incorporated with the techniques described in this paper, will easily extend to PDGs with complex control dependence. The complexity of PDG-reconstitution depends on the types of data dependences represented in the PDG. In the PDGs considered in [4], data dependences include loop-independent and loop-carried flow - 18 - edges, and <p> We believe that the algorithm in <ref> [4] </ref>, incorporated with the techniques described in this paper, will easily extend to PDGs with complex control dependence. The complexity of PDG-reconstitution depends on the types of data dependences represented in the PDG. In the PDGs considered in [4], data dependences include loop-independent and loop-carried flow - 18 - edges, and def-order edges (which are similar to output dependences), but not anti-dependences.
Reference: 5. <author> W. Baxter and H. R. Bauer, III, </author> <title> The Program Dependence Graph and Vectorization, </title> <booktitle> Proceedings of the Sixteenth ACM Principles of Programming Languages Symposium, </booktitle> <pages> pp. 1-11 (January 11-13, </pages> <year> 1989). </year>
Reference-contexts: a rich set of control constructs. (2) Program-dependence graph reconstitution is also potentially useful in optimizing, vectorizing, or parallelizing compilers that perform source-to-source transformations by computing the program dependence graph of a program, performing transformations on this graph, and finally, finding a source program that corresponds to the transformed graph <ref> [5, 10] </ref>. Previously, [9, 11] have addressed the CDG-reconstitution problem, culminating in the results of [20], which addresses the issue of CDG-reconstitution in a formal framework. However, in this work, CDG-reconstitution is formalized only for acyclic CDGs (i.e., the control dependence graphs of loop-free programs). <p> (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) <ref> [5] </ref> add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS
Reference: 6. <author> R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and K. Zadeck, </author> <title> An efficient method of computing static single assignment form, pp. </title> <booktitle> 25-35 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: Control dependences are defined in terms of a program's control-flow graph; given a control-flow graph G, a corresponding control dependence graph, CDG (G), can be constructed using the methods of <ref> [6, 7, 10] </ref>. This paper addresses the inverse problem: we define an algorithm that, given a control dependence graph C, finds a corresponding control-flow graph G (i.e., a graph G such that CDG (G) is isomorphic to C), or determines that no such control-flow graph exists. <p> CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 <ref> [6] </ref> DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c <p> The edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F). Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdomina tor of 4 in the call DFS (4,5) (line <ref> [6] </ref>). Because 4 is a statement vertex, the edge 4 fi 5 is added (line [7]). At this point, we return to process CLIST (1,T) in the active call DFS (1,5). 4. RELATED WORK As discussed in the Introduction, the most important previous work on CDG-reconstitution is that of [20].
Reference: 7. <author> R. Cytron, J. Ferrante, and V. Sarkar, </author> <title> Compact Representations for Control Dependence, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (SIGPLAN Notices) 25(6)(June 20-22, </booktitle> <year> 1990). </year> <month> - 19 </month> - 
Reference-contexts: Control dependences are defined in terms of a program's control-flow graph; given a control-flow graph G, a corresponding control dependence graph, CDG (G), can be constructed using the methods of <ref> [6, 7, 10] </ref>. This paper addresses the inverse problem: we define an algorithm that, given a control dependence graph C, finds a corresponding control-flow graph G (i.e., a graph G such that CDG (G) is isomorphic to C), or determines that no such control-flow graph exists. <p> () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) <ref> [7] </ref> add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c <p> Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdomina tor of 4 in the call DFS (4,5) (line [6]). Because 4 is a statement vertex, the edge 4 fi 5 is added (line <ref> [7] </ref>). At this point, we return to process CLIST (1,T) in the active call DFS (1,5). 4. RELATED WORK As discussed in the Introduction, the most important previous work on CDG-reconstitution is that of [20].
Reference: 8. <author> D.E. Denning and P.J. Denning, </author> <title> Certification of programs for secure information flow, </title> <journal> Commun. of the ACM 20(7) pp. </journal> <month> 504-513 (July </month> <year> 1977). </year>
Reference-contexts: 1. INTRODUCTION Control dependences were introduced in <ref> [8, 10] </ref> to characterize how the predicates in a program govern the execution of other statements and predicates. <p> c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 <ref> [8] </ref> add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c
Reference: 9. <author> J. Ferrante and M. Mace, </author> <title> On linearizing parallel code, pp. </title> <booktitle> 179-189 in Conference Record of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (New Orleans, LA, </address> <month> January 14-16, </month> <year> 1985), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1985). </address>
Reference-contexts: Previously, <ref> [9, 11] </ref> have addressed the CDG-reconstitution problem, culminating in the results of [20], which addresses the issue of CDG-reconstitution in a formal framework. However, in this work, CDG-reconstitution is formalized only for acyclic CDGs (i.e., the control dependence graphs of loop-free programs). <p> c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 <ref> [9] </ref> DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall
Reference: 10. <author> J. Ferrante, K. Ottenstein, and J. Warren, </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(5) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: 1. INTRODUCTION Control dependences were introduced in <ref> [8, 10] </ref> to characterize how the predicates in a program govern the execution of other statements and predicates. <p> Control dependences are defined in terms of a program's control-flow graph; given a control-flow graph G, a corresponding control dependence graph, CDG (G), can be constructed using the methods of <ref> [6, 7, 10] </ref>. This paper addresses the inverse problem: we define an algorithm that, given a control dependence graph C, finds a corresponding control-flow graph G (i.e., a graph G such that CDG (G) is isomorphic to C), or determines that no such control-flow graph exists. <p> a rich set of control constructs. (2) Program-dependence graph reconstitution is also potentially useful in optimizing, vectorizing, or parallelizing compilers that perform source-to-source transformations by computing the program dependence graph of a program, performing transformations on this graph, and finally, finding a source program that corresponds to the transformed graph <ref> [5, 10] </ref>. Previously, [9, 11] have addressed the CDG-reconstitution problem, culminating in the results of [20], which addresses the issue of CDG-reconstitution in a formal framework. However, in this work, CDG-reconstitution is formalized only for acyclic CDGs (i.e., the control dependence graphs of loop-free programs). <p> Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) <ref> [10] </ref> add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall that the second
Reference: 11. <author> J. Ferrante, M. Mace, and B. Simons, </author> <title> Generating Sequential Code From Parallel Code, </title> <booktitle> Proceedings of the ACM 1988 International Conference on Supercomputing, </booktitle> <pages> pp. </pages> <month> 582-592 (July </month> <year> 1988). </year>
Reference-contexts: Previously, <ref> [9, 11] </ref> have addressed the CDG-reconstitution problem, culminating in the results of [20], which addresses the issue of CDG-reconstitution in a formal framework. However, in this work, CDG-reconstitution is formalized only for acyclic CDGs (i.e., the control dependence graphs of loop-free programs). <p> [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 <ref> [11] </ref> add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall that the second vertex in the call to DFS is
Reference: 12. <author> D. Harel and R. E. Tarjan, </author> <title> Fast Algorithms for Finding Nearest Common Ancestors, </title> <journal> SIAM Journal of Computing 13(2)Society for Industrial and Applied Mathematics, </journal> <month> (May </month> <year> 1984). </year>
Reference-contexts: Each operation done during the computation of LOW is a constant time operation, given that the least common ancestor of each cross edge has been computed beforehand. An algorithm for computing least common ancestors in trees by Harel and Tarjan <ref> [12] </ref> takes O (N+M) time, where N is the number of vertices in the tree and M is the number of queries (in this case M = |CE|). 3.2. <p> [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 <ref> [12] </ref> DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall that the second vertex in the call to DFS is always the immediate postdominator of the first.
Reference: 13. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) <ref> [13] </ref> add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall that the second vertex in the call to DFS is always the immediate postdominator of the first. <p> The equivalence property for program dependence graphs that correspond to programs written with only while loops, sequencing, and conditionals has been shown using a variety of frameworks <ref> [13, 15-17, 19] </ref>., However, to our knowledge, no one has extended the equivalence property for program dependence graphs with more complex control dependence. Such a property would provide a semantic justification for a reconstitution algorithm. 6.3.
Reference: 14. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: Reconstitution of program dependence graphs is used in several areas: (1) The program-integration algorithms of <ref> [14, 18, 22] </ref> combine portions of several program dependence graphs to form a merged graph. <p> (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 <ref> [14] </ref> DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c Recall that the second vertex in the call to DFS is always the immediate postdominator of the first. <p> Maintaining Program Syntax The CDG-reconstitution process described in this paper is independent of the source language and its syntaxthe product of reconstitution is a control-flow graph rather than program text. In some applications that manipulate PDGs, such as program integration <ref> [14] </ref>, it is desirable for the output program to resemble the input programs (when possible). In these cases, it is useful to annotate the PDG with information about the source program (syntax) from which it was derived. These annotations can be used by reconstitution to recreate the desired syntactic structure.
Reference: 15. <author> G. Ramalingam and T. Reps, </author> <title> Semantics of Program Representation Graphs, </title> <type> Technical Report #900, </type> <institution> University of Wisconsin, </institution> <note> Madison (December 1989). </note>
Reference: 16. <author> T. Reps and W. Yang, </author> <title> The semantics of program slicing, </title> <type> Technical Report #777, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, </institution> <address> WI (June 1988). </address>
Reference: 17. <author> T. Reps and W. Yang, </author> <title> The semantics of program slicing and program integration, </title> <booktitle> in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference: 18. <author> T. Reps, </author> <title> Algebraic Properties of Program Integration, </title> <booktitle> Proceedings of the 3rd European Symposium on Programming (Copenhagen, </booktitle> <address> Denmark, </address> <month> May 15-18, </month> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science 432Springer-Verlag, </booktitle> <year> (1990). </year>
Reference-contexts: Reconstitution of program dependence graphs is used in several areas: (1) The program-integration algorithms of <ref> [14, 18, 22] </ref> combine portions of several program dependence graphs to form a merged graph.
Reference: 19. <author> R. P. Selke, </author> <title> A Rewriting Semantics for Program Dependence Graphs, </title> <booktitle> Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages (Austin, </booktitle> <address> TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <year> 1989), </year> <pages> pp. 12-24 ACM, </pages> <year> (1989). </year>
Reference-contexts: The equivalence property for program dependence graphs that correspond to programs written with only while loops, sequencing, and conditionals has been shown using a variety of frameworks <ref> [13, 15-17, 19] </ref>., However, to our knowledge, no one has extended the equivalence property for program dependence graphs with more complex control dependence. Such a property would provide a semantic justification for a reconstitution algorithm. 6.3.
Reference: 20. <author> B. Simons, B. Alpern, and J. Ferrante, </author> <title> A Foundation for Sequentializing Parallel Code, </title> <booktitle> Proceedings of the Symposium on Parallel Algorithms and Architectures, </booktitle> <month> (July </month> <year> 1990). </year>
Reference-contexts: Previously, [9, 11] have addressed the CDG-reconstitution problem, culminating in the results of <ref> [20] </ref>, which addresses the issue of CDG-reconstitution in a formal framework. However, in this work, CDG-reconstitution is formalized only for acyclic CDGs (i.e., the control dependence graphs of loop-free programs). An extension to handle cycles is mentioned briefly, but is incomplete and contains some errors. <p> An extension to handle cycles is mentioned briefly, but is incomplete and contains some errors. Our research provides two important advances. First, we define a single CDG-reconstitution algorithm that correctly handles both acyclic and cyclic control dependence graphs. Second, our algorithm provides an improvement in efficiency: in <ref> [20] </ref>, the authors present an O (NE) (where N and E are the number of vertices and edges, respectively, in the control dependence graph) algorithm for CDG-reconstitution when the control dependence graph is known beforehand to be feasible (i.e., there is some corresponding control-flow graph) and an O (N 2 E) <p> This restriction greatly simplifies the process of reconstitution and allows for an efficient algorithm, while still providing an important improvement over the algorithm of <ref> [20] </ref>, which handles an even more restricted class of control dependence graphs. The main problem of CDG-reconstitution is to totally order the children of each predicate vertex in a way that is consistent with the postdomination ordering in a corresponding control-flow graph, if one exists. <p> As discussed in Section 2.3, CDGs that are trees can be processed in linear time. However, the above algorithm will examine O (N 2 ) pairs. This time bound can be improved if we assume, as done in <ref> [20] </ref>, that regions already have been identified in the input CDG. Regions partition the vertex set of a CDG, grouping vertices with common sets of control parents. Regions are identified in BF (C) rather than in C. <p> Because 4 is a statement vertex, the edge 4 fi 5 is added (line [7]). At this point, we return to process CLIST (1,T) in the active call DFS (1,5). 4. RELATED WORK As discussed in the Introduction, the most important previous work on CDG-reconstitution is that of <ref> [20] </ref>. In this section we discuss the similarities and differences between that work and the work presented here. The major difference between our work and that of [20] is in the treatment of loops. In [20], CDG reconstitution is formalized only for control dependence DAGs as opposed to general cyclic CDGs. <p> RELATED WORK As discussed in the Introduction, the most important previous work on CDG-reconstitution is that of <ref> [20] </ref>. In this section we discuss the similarities and differences between that work and the work presented here. The major difference between our work and that of [20] is in the treatment of loops. In [20], CDG reconstitution is formalized only for control dependence DAGs as opposed to general cyclic CDGs. An extension to handle cycles is mentioned briefly, but is incomplete and contains some errors, which are corrected in our CDG-reconstitution algorithm. <p> As discussed in the Introduction, the most important previous work on CDG-reconstitution is that of <ref> [20] </ref>. In this section we discuss the similarities and differences between that work and the work presented here. The major difference between our work and that of [20] is in the treatment of loops. In [20], CDG reconstitution is formalized only for control dependence DAGs as opposed to general cyclic CDGs. An extension to handle cycles is mentioned briefly, but is incomplete and contains some errors, which are corrected in our CDG-reconstitution algorithm. For example, in the control dependence DAG representa tion of [20], CDG C1 <p> In <ref> [20] </ref>, CDG reconstitution is formalized only for control dependence DAGs as opposed to general cyclic CDGs. An extension to handle cycles is mentioned briefly, but is incomplete and contains some errors, which are corrected in our CDG-reconstitution algorithm. For example, in the control dependence DAG representa tion of [20], CDG C1 of Figure 1 would not include the backedge from c to p. The graph would be aug mented by marking c as an exit vertex of the loop headed by p and marking p as a loop entry. However, the ordering rules of [20] do not force c <p> DAG representa tion of <ref> [20] </ref>, CDG C1 of Figure 1 would not include the backedge from c to p. The graph would be aug mented by marking c as an exit vertex of the loop headed by p and marking p as a loop entry. However, the ordering rules of [20] do not force c to postdominate q, which it must; exit vertices must always post dominate other vertices with the same control dependence parents. - 16 - Considering CDG C1 of Figure 1 again, according to [20], p should be treated as a special forall vertex. <p> However, the ordering rules of <ref> [20] </ref> do not force c to postdominate q, which it must; exit vertices must always post dominate other vertices with the same control dependence parents. - 16 - Considering CDG C1 of Figure 1 again, according to [20], p should be treated as a special forall vertex. According to their ordering rules, if a forall vertex and a statement vertex have a common control parent, the forall vertex must follow the statement vertex in every corresponding CFG. <p> Forcing p to follow d would be a problem if there were a flow dependence from a to d, requiring that d follow p. Another difference between our approach and that of <ref> [20] </ref> is that they present two separate algorithms, one to test feasibility and the other to produce a corresponding CFG for a given feasible CDG, while we define a single algorithm that either produces a corresponding CFG, or determines that the given CDG is infeasible. <p> Their feasibility-testing algorithm is O (N 2 E), and their CDG-reconstitution algorithm is O (NE). Our (single) algorithm is O (NE). Two aspects of the work of <ref> [20] </ref> that appear different but that are actually only superficially so, have to do with the class of CDGs that can be handled. Both the algorithm presented in this paper and the algorithms of [20] handle restricted classes of feasible CDGs. In [20] these restrictions are defined directly in terms of <p> Our (single) algorithm is O (NE). Two aspects of the work of <ref> [20] </ref> that appear different but that are actually only superficially so, have to do with the class of CDGs that can be handled. Both the algorithm presented in this paper and the algorithms of [20] handle restricted classes of feasible CDGs. In [20] these restrictions are defined directly in terms of properties of the CDGs. In contrast, we define the restrictions indirectly by saying that we handle only those CDGs that correspond to a restricted class of CFGs. <p> Two aspects of the work of <ref> [20] </ref> that appear different but that are actually only superficially so, have to do with the class of CDGs that can be handled. Both the algorithm presented in this paper and the algorithms of [20] handle restricted classes of feasible CDGs. In [20] these restrictions are defined directly in terms of properties of the CDGs. In contrast, we define the restrictions indirectly by saying that we handle only those CDGs that correspond to a restricted class of CFGs. Our algorithm handles a superset of the CDGs considered in [20]. <p> In <ref> [20] </ref> these restrictions are defined directly in terms of properties of the CDGs. In contrast, we define the restrictions indirectly by saying that we handle only those CDGs that correspond to a restricted class of CFGs. Our algorithm handles a superset of the CDGs considered in [20]. Another aspect of the question of what CDGs are handled has to do with region vertices (also called forall vertices), which are assumed in [20] to have been added to the CDG (region vertices are added to a CDG to gather all vertices with the same set of control conditions <p> Our algorithm handles a superset of the CDGs considered in <ref> [20] </ref>. Another aspect of the question of what CDGs are handled has to do with region vertices (also called forall vertices), which are assumed in [20] to have been added to the CDG (region vertices are added to a CDG to gather all vertices with the same set of control conditions together). As discussed in Section 3.1.3, our algorithm is easily extended to handle CDGs with regions. 5.
Reference: 21. <author> R. Tarjan, </author> <title> Testing Flow Graph Reducibility, </title> <booktitle> Proceedings of the 5th ACM Symposium on Theory of Computing, </booktitle> <pages> pp. </pages> <month> 96-107 </month> <year> (1973). </year>
Reference-contexts: If C is R-feasible, the resulting order will be a good order. We now consider the running time of this algorithm. Step (1) requires linear time since checking for reducibility is a linear-time operation <ref> [21] </ref>, as is depth-first search and computing DomReach (C). Step (2) considers every (a,b) pair in C (possibly O (N 2 ) of them) in turn. To compute whether or not property OrderFixed holds for an (a,b) pair, the following three operations are needed: g Membership in DomReach (C).


Reference: 1. <institution> All edges from (G-H) to H go to v. </institution>
Reference-contexts: The algorithm performs three main steps. In line <ref> [1] </ref> the function ComputeGoodOrder is called. <p> R-feasible: add a second test after line [3] that checks whether the CFG G is in the restricted class, returning FAIL if it is not. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function ReconstituteCDG (C : CDG) : CFG or FAIL Order : set of ordered pairs of vertices G : CFG begin <ref> [1] </ref> Order := ComputeGoodOrder (C) if Order = FAIL then return (FAIL) fi [2] G := ConstructCFG (C, Order) [3] if not Isomorphic (CDG (G),C) then return (FAIL) fi return (G) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The next three subsections present each of these three steps in greater detail. <p> PROOF. The proof is straightforward and is left to the reader. ` To determine when the condition in the above lemma holds, a LOW numbering, similar to that used to determine the biconnected components of undirected graphs <ref> [1, pg. 179] </ref>, is defined for each v in C: LOW [v] = MIN ( -#v -#a | $ a fi b FE such that v is a proper ancestor of b - -#a | $ b fi a BE such that v is an ancestor of b - -#lca (a,b) <p> creates the edge set of the CFG: iiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs iiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii <ref> [1] </ref> DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi <p> DFS is initially invoked (line <ref> [1] </ref>) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line [2]). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]).



Reference: 4. <author> The Restricted Class of CFGs The R-feasible CDGs are defined as the CDGs of a restricted class of CFGs. </author> <title> We use the concept of a natural loop in a CFG to define this class of CFGs. DEFINITION. The natural loop of a backedge v fi w is defined as nat-loop(v fi w) = - w - - x | there is a w-free path from x to v -. DEFINITION. The natural loop of a loop entry w, denoted nat-loop(w), is the union of all nat-loop(v fi w), where v fi w is a backedge. </title>
Reference-contexts: = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c iiiiiiiiiiiiiiiiiiiiiiiiiiiii Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiii [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 <ref> [4] </ref> DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi <p> The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line <ref> [4] </ref>). The edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F). Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdomina tor of 4 in the call DFS (4,5) (line [6]). <p> FUTURE WORK 6.1. Data Dependences and PDG-reconstitution CDG-reconstitution is a component of PDG-reconstitution. In PDG-reconstitution, data dependences (as well as control dependences) determine an order between vertices. We have described and proved correct an algorithm for PDG-reconstitution for PDGs in which the underlying CDG is a tree <ref> [4] </ref>. A data dependence from vertex v to w will determine an order between the ancestors of v and w in the CDG that are children of the least-common ancestor of v and w. <p> In a CDG that is a general graph, the same general principle holds (by ignoring the backedges in the CDG, the least-common ancestor relation is well-defined). We believe that the algorithm in <ref> [4] </ref>, incorporated with the techniques described in this paper, will easily extend to PDGs with complex control dependence. The complexity of PDG-reconstitution depends on the types of data dependences represented in the PDG. In the PDGs considered in [4], data dependences include loop-independent and loop-carried flow - 18 - edges, and <p> We believe that the algorithm in <ref> [4] </ref>, incorporated with the techniques described in this paper, will easily extend to PDGs with complex control dependence. The complexity of PDG-reconstitution depends on the types of data dependences represented in the PDG. In the PDGs considered in [4], data dependences include loop-independent and loop-carried flow - 18 - edges, and def-order edges (which are similar to output dependences), but not anti-dependences.
References-found: 23

