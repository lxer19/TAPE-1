URL: http://www.cse.ogi.edu/~walton/proposal.ps
Refering-URL: http://www.cse.ogi.edu/~walton/walton.html
Root-URL: http://www.cse.ogi.edu
Title: From Domain Analysis to Domain-Specific Languages  
Author: Lisa Walton 
Degree: A Thesis Proposal  
Note: Revision 1:5  
Date: October 22, 1998  
Abstract-found: 0
Intro-found: 1
Reference: [APD91] <author> G. Arango and R. Prieto-Diaz. </author> <title> Domain Analysis Concepts and Research Directions. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes [Pro93, Gom90, KSC90a, PD91]. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies <ref> [APD91, WPD92] </ref>. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages. A domain analysis is often part of a larger domain engineering effort.
Reference: [Cam89] <author> Grady Campbell. </author> <title> Abstraction-based reuse repositories. </title> <type> Technical Report REUSE-REPOSITORIES-89041-N, </type> <institution> Software Productivity Consortium Services Corporation, </institution> <address> 2214 Rock Hill Road, Herndon, Virginia 22070, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Incorporating key concepts such as iterative processes [Hum89] and abstraction-based reuse <ref> [Cam89] </ref>, Synthesis defines and integrates two activities: Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 4 * Application Engineering an iterative activity for the design and development of a product that satisfies specified customer requirements. * Domain Engineering an iterative activity for the design and development of a product family and
Reference: [Cle88] <author> J. Craig Cleaveland. </author> <title> Building application generators. </title> <journal> IEEE Software, </journal> <volume> 5(4) </volume> <pages> 25-33, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: DSLs are particularly effective when supported by application generators. Application generators are like compilers in that they map specifications to executable programs <ref> [Cle88] </ref>, but unlike them in that the input specifications are typically very high-level, special purpose abstractions from a very narrow application domain [Kru92].
Reference: [CVM97] <author> Koen Claessen, Ton Vullinghs, and Erik Meijer. </author> <title> Structuring graphical paradigms in TkGofer. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 251-262, </pages> <address> Amsterdam, The Netherlands, </address> <month> 9-11 June </month> <year> 1997. </year>
Reference: [Dij72] <author> E. W. Dijkstra. </author> <title> Notes on Structured Programming. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: One effective way of identifying opportunities for reuse in an application domain is to look for program families [JFW90]. A program family <ref> [Dij72, Par78] </ref> is a set of programs that are sufficiently similar that it is worthwhile to understand the common properties of the set before considering the special properties of individual instances.
Reference: [Gom90] <author> H. </author> <title> A Gomaa. Domain requirements analysis and specification method. </title> <type> Technical report, </type> <institution> George Mason University, </institution> <month> February </month> <year> 1990. </year> <institution> Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 8 </institution>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes <ref> [Pro93, Gom90, KSC90a, PD91] </ref>. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies [APD91, WPD92]. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages.
Reference: [GP96] <author> A. Gargaro and A. S. Peterson. </author> <title> Transitioning a model-based software engineering architectural style to ada 95. </title> <type> Technical Report CMU/SEI-96-TR-017 / ADA317090, </type> <institution> Software Engineering Institute, </institution> <year> 1996. </year>
Reference-contexts: Domain Engineering (DE) is the discipline of defining, identifying, creating, and evolving reusable assets in an application domain. Reusable assets include processes, products, and tools intended to assist application engineers in developing and maintaining software. Some methods, such as Draco [Nei83], aim to create a DSL. Others <ref> [GP96, Sim95, KSC90b] </ref>, aim to create libraries of reusable components or domain-specific software architectures rather than DSLs.
Reference: [HM96] <author> Graham Hutton and Erik Meijer. </author> <title> Monadic combinator parsers. </title> <type> Technical report, </type> <institution> University of Nottingham, </institution> <year> 1996. </year> <month> NOTTCS-TR-96-4. </month>
Reference-contexts: Small and usually declarative, DSLs are expressive over one or both of the following * Distinguishing characteristics of a family of applications. For example, recursive descent parsers are a family whose members differ according to what parsing actions they perform. Parser combinators <ref> [HM96] </ref> are a language expressive over parsing actions such as sequencing and choice used to specify recursive descent parsers in Haskell. * Key domain abstractions. For example, in the compiler application domain the notion of a language grammar is a key abstraction. <p> Its semantics is captured by an interpreter in Haskell. Prototyping (for Haskell hackers) is quite easy. DSELs gain all of the advantages of the embedding language (e.g. they can exploit Haskell's control structures and type system), and many of them, such as the parser combinators <ref> [HM96] </ref>, are quite useful. One disadvantage of DSELs is that it can be hard to prove properties about them since the distinction between what is in the DSEL and what is in the embedding language (here, Haskell) can be fuzzy.
Reference: [Hud96] <author> Paul Hudak. </author> <title> Building domain-specific embedded languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4es):196, </volume> <month> December </month> <year> 1996. </year>
Reference-contexts: It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs <ref> [Hud96] </ref>, and Amphion [LPPU94]. One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions. <p> While this work is promising, there does not yet exist a sufficient body of examples to determine if they truly succeeded. 3.6 Domain-Specific Embedded Languages (DSELs) In his 1996 position paper <ref> [Hud96] </ref>, Hudak describes a DSEL in Haskell to be a higher-order algebraic structure, a first class value that has the look and feel of syntax. Its semantics is captured by an interpreter in Haskell. Prototyping (for Haskell hackers) is quite easy.
Reference: [Hum89] <author> Watts S. Humphrey. </author> <title> Managing the Software Process. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: Incorporating key concepts such as iterative processes <ref> [Hum89] </ref> and abstraction-based reuse [Cam89], Synthesis defines and integrates two activities: Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 4 * Application Engineering an iterative activity for the design and development of a product that satisfies specified customer requirements. * Domain Engineering an iterative activity for the design and development of
Reference: [JFW90] <author> Grady H. Campbell Jr., Stuart R. Faulk, and David M. Weiss. </author> <title> Introduction to synthesis. </title> <type> Technical Report INTRO SYNTHESIS PROCESS- 90019-N, </type> <institution> Software Productivity Consortium, </institution> <year> 1990. </year>
Reference-contexts: One effective way of identifying opportunities for reuse in an application domain is to look for program families <ref> [JFW90] </ref>. A program family [Dij72, Par78] is a set of programs that are sufficiently similar that it is worthwhile to understand the common properties of the set before considering the special properties of individual instances. <p> Another difference is that the process for creating the DSL and Draco input products (such as the language analyzer or parser) is not well defined. 3.2 Family-Orientated Abstraction, Specification, and Translation (FAST) FAST evolved from Synthesis <ref> [JFW90] </ref>, a methodology for constructing software systems as instances of a family of systems that have similar descriptions.
Reference: [KMB + 96] <author> Richard B. Kieburtz, Laura McKinney, Jeffrey Bell, James Hook, Alex Kotov, Jef-frey Lewis, Dino Oliva, Tim Sheard, Ira Smith, and Lisa Walton. </author> <title> A software engineering experiment in software component generation. </title> <booktitle> In Proceedings of 18th International Conference on Software Engineering, </booktitle> <pages> pages 542-552. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Alternatively, there could be an ongoing feedback process as the tools mature. The important aspect is to have a defined mechanism for evaluating the usefulness and reliability of the tools. Empirical evidence suggests that DSLs can significantly improve the productivity of software developers <ref> [Wei97, KMB + 96] </ref> and also the usability and reliability of development tools [KMB + 96]. <p> The important aspect is to have a defined mechanism for evaluating the usefulness and reliability of the tools. Empirical evidence suggests that DSLs can significantly improve the productivity of software developers [Wei97, KMB + 96] and also the usability and reliability of development tools <ref> [KMB + 96] </ref>. <p> For experts not familiar with functional languages, learning to use a DSEL can be difficult and time consuming. It took a PacSoft member one week to train test subjects in the use of the MSL language <ref> [KMB + 96] </ref>. Had our solution been an embedded language in ML, we would have had to train them to be ML programers which would have taken considerably longer. DSELs can incorporate many of the language design techniques advocated in SDA, such as modular denotational semantics. <p> In a live subject experiment <ref> [KMB + 96] </ref>, the hypothesis that our reuse via languages approach was an improvement over the Software Engineering Institute's (SEI) reuse-via-libraries approach [PLR89] was conclusively demonstrated. Substantially complete, this case study reflects the complete application of the method to a small, but real example.
Reference: [Knu] <author> Donald Knuth. </author> <title> Literate programming. from T E Xdistribution. </title>
Reference-contexts: ASF-SDF includes a specification development environment consisting of a syntax directed editor that can perform context-sensitive analysis of specifications (similar to type checking) to provide immediate error checking of specifications. It also supports literate specifications [VV95] in the literate programming approach advocated by Knuth <ref> [Knu] </ref>. ASF-SDF is a DSL for defining context-free syntax for arbitrary (context-free) languages. It is a first-order language, however, and abstractions requiring higher orderness (such as monads) are not expressible in it.
Reference: [Kru92] <author> C. Kruegar. </author> <title> Software reuse. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(2) </volume> <pages> 131-183, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: DSLs are particularly effective when supported by application generators. Application generators are like compilers in that they map specifications to executable programs [Cle88], but unlike them in that the input specifications are typically very high-level, special purpose abstractions from a very narrow application domain <ref> [Kru92] </ref>.
Reference: [KSC90a] <author> K. Kang and et al. S. Cohen. </author> <title> Feature-oriented domain analysis (foda) feasibility study. </title> <type> Technical Report CMU/SEI-90-TR-21, </type> <institution> Software Engineering Institute, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes <ref> [Pro93, Gom90, KSC90a, PD91] </ref>. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies [APD91, WPD92]. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages.
Reference: [KSC90b] <author> K. Kang and et al. S. Cohen. </author> <title> Feature-oriented domain analysis (foda) feasibility study. </title> <type> Technical Report CMU/SEI-90-TR-21, </type> <institution> Software Engineering Institute, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Domain Engineering (DE) is the discipline of defining, identifying, creating, and evolving reusable assets in an application domain. Reusable assets include processes, products, and tools intended to assist application engineers in developing and maintaining software. Some methods, such as Draco [Nei83], aim to create a DSL. Others <ref> [GP96, Sim95, KSC90b] </ref>, aim to create libraries of reusable components or domain-specific software architectures rather than DSLs.
Reference: [LH96] <author> S. Liang and P. Hudak. </author> <title> Modular denotational semantics for compiler construction. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1058:219-??, </address> <year> 1996. </year>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics <ref> [Mog90, SLJ95, LH96] </ref> and metaprogramming [TBS98]. It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs [Hud96], and Amphion [LPPU94]. <p> It is actually a DSL for designing programming languages. Actions represent computations, and are built compositionally from primitive action combinators. Unlike the modular monadic semantics <ref> [SLJ95, LH96] </ref> currently preferred by SDA, action semantics have a very readable notation allowing even novice users to have an intuitive understanding of the meaning of existing specifications. Additionally, there is a large body of real examples demonstrating the utility of action semantics as a DSL for programming language design.
Reference: [LPPU94] <author> M. Lowry, A. Philpot, T. Pressburger, and I. Underwood. Amphion: </author> <title> Automatic programming for scientific subroutine libraries. </title> <booktitle> In 8th International Symposium on Methodologies for Intelligent Systems, </booktitle> <pages> pages 326-335, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs [Hud96], and Amphion <ref> [LPPU94] </ref>. One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions. <p> The subprocess of going from a CA to an application engineering tool and environment are less well defined, and it is here that SDA provides some support. The results of combining FAST with SDA are described in Widen's thesis [Wid98]. 3.3 Amphion The Amphion <ref> [LPPU94] </ref> project utilizes formal specifications and automated deductive synthesis to allow non-programmers to effectively utilize scientific libraries. A domain theory is created for each domain that relates the problem area to library operations.
Reference: [LW95] <author> R. Lai and D. Weiss. </author> <title> A formal model of the fast process. </title> <type> Technical Report BL0112650-950707-30TM, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1995. </year>
Reference-contexts: Others [GP96, Sim95, KSC90b], aim to create libraries of reusable components or domain-specific software architectures rather than DSLs. While it is possible that SDA could be used to supplement these kinds of methods, it is more likely to support methods such as FAST <ref> [LW95] </ref> which requires a DSL product but is not prescriptive as to which language design process is used. One thing that distinguishes SDA from most other DE approaches is that it has an established method for going from DAs to DSLs.
Reference: [MLC98] <author> John Matthews, John Launchbury, and Byron Cook. </author> <title> Microprocessor specification in hawk. </title> <booktitle> In 1998 IEEE Computer Society International Conference on Computer Languages, </booktitle> <month> May </month> <year> 1998. </year> <institution> Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 9 </institution>
Reference: [Mog90] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report LFCS-90-113, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics <ref> [Mog90, SLJ95, LH96] </ref> and metaprogramming [TBS98]. It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs [Hud96], and Amphion [LPPU94].
Reference: [Mos92] <author> Peter D. Mosses. </author> <title> Action Semantics. </title> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics [Mog90, SLJ95, LH96] and metaprogramming [TBS98]. It competes with other language design technologies such as Action Semantics <ref> [Mos92] </ref>, ASF+SDF [vDHK], DSELs [Hud96], and Amphion [LPPU94]. One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions.
Reference: [Nei83] <author> J. Neighbors. </author> <title> The draco approach to constructing software from reusable components. </title> <booktitle> Workshop on Reusability in Programming, </booktitle> <month> September </month> <year> 1983. </year>
Reference-contexts: Domain Engineering (DE) is the discipline of defining, identifying, creating, and evolving reusable assets in an application domain. Reusable assets include processes, products, and tools intended to assist application engineers in developing and maintaining software. Some methods, such as Draco <ref> [Nei83] </ref>, aim to create a DSL. Others [GP96, Sim95, KSC90b], aim to create libraries of reusable components or domain-specific software architectures rather than DSLs. <p> One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions. We examine other differences, both positive and negative, below. 3.1 Draco The Draco <ref> [Nei83] </ref> approach for achieving domain-specific reuse is one of the oldest domain engineering approaches. It is essentially a tool-supported process for going from a domain description to an environment for analyzing and specifying components.
Reference: [Nei89] <author> James M. Neighbors. </author> <title> Draco: A method for engineering reusable software systems. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability Concepts and Models, </booktitle> <volume> volume I, chapter 12, </volume> <pages> pages 295-319. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [Par78] <author> David L. Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions in Software Engineering, </journal> <month> March </month> <year> 1978. </year>
Reference-contexts: One effective way of identifying opportunities for reuse in an application domain is to look for program families [JFW90]. A program family <ref> [Dij72, Par78] </ref> is a set of programs that are sufficiently similar that it is worthwhile to understand the common properties of the set before considering the special properties of individual instances.
Reference: [PD91] <author> R. Prieto-Diaz. </author> <title> Reuse library process model. </title> <type> Technical Report AD-B157091, </type> <institution> IBM CDRL 03041-002, STARS, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes <ref> [Pro93, Gom90, KSC90a, PD91] </ref>. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies [APD91, WPD92]. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages.
Reference: [PLR89] <author> Charles Plinta, Kenneth Lee, and Michael Rissman. </author> <title> A model solution for C 3 I message translation and validation. </title> <type> Technical Report CMU/SEI-89-TR-12 ESD-89-TR-20, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: In a live subject experiment [KMB + 96], the hypothesis that our reuse via languages approach was an improvement over the Software Engineering Institute's (SEI) reuse-via-libraries approach <ref> [PLR89] </ref> was conclusively demonstrated. Substantially complete, this case study reflects the complete application of the method to a small, but real example.
Reference: [Pro93] <author> DISA/CIM Software Reuse Program. </author> <title> Domain analysis and design process, </title> <type> version 1. Technical Report 1222-04-210/30.1, </type> <institution> DISA Center for Information Management, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes <ref> [Pro93, Gom90, KSC90a, PD91] </ref>. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies [APD91, WPD92]. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages.
Reference: [Sim95] <author> Mark A. Simos. </author> <title> Organization domain modeling (odm): Formalizing the core domain modeling life cycle. </title> <booktitle> ACM SIGSOFT Symposium on Software Reusability, </booktitle> <month> July </month> <year> 1995. </year>
Reference-contexts: Domain Engineering (DE) is the discipline of defining, identifying, creating, and evolving reusable assets in an application domain. Reusable assets include processes, products, and tools intended to assist application engineers in developing and maintaining software. Some methods, such as Draco [Nei83], aim to create a DSL. Others <ref> [GP96, Sim95, KSC90b] </ref>, aim to create libraries of reusable components or domain-specific software architectures rather than DSLs.
Reference: [SLJ95] <author> Paul Hudak Sheng Liang and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Proceedings of the 22nd ACM-SIGACT Symposium on the Principles of Programming Langauges, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics <ref> [Mog90, SLJ95, LH96] </ref> and metaprogramming [TBS98]. It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs [Hud96], and Amphion [LPPU94]. <p> It is actually a DSL for designing programming languages. Actions represent computations, and are built compositionally from primitive action combinators. Unlike the modular monadic semantics <ref> [SLJ95, LH96] </ref> currently preferred by SDA, action semantics have a very readable notation allowing even novice users to have an intuitive understanding of the meaning of existing specifications. Additionally, there is a large body of real examples demonstrating the utility of action semantics as a DSL for programming language design.
Reference: [TBS98] <author> Walid Taha, Zine-El-Abidine Benaissa, and Tim Sheard. </author> <title> Multi-stage programming: Axiomatization and type-safety. </title> <booktitle> 25th International Colloquium on Automata, Languages, and Programming, </booktitle> <month> July </month> <year> 1998. </year>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics [Mog90, SLJ95, LH96] and metaprogramming <ref> [TBS98] </ref>. It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF [vDHK], DSELs [Hud96], and Amphion [LPPU94]. One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions.
Reference: [vD94] <author> Arie van Deursen. </author> <title> Executable Language Definitions. Illc dissertation series, </title> <publisher> CWI, </publisher> <address> P.O. Box, 94079, 1090 GB Amsterdam, </address> <year> 1994. </year>
Reference-contexts: This is not possible with languages implemented in taction semantics. There is, however, an action semantic description (ASD) tool implemented in ASF-SDF that provides some checking of action semantic specifications <ref> [vD94] </ref>. Recently an attempt to combine modular monadic semantics and action semantics to get the best of both worlds was attempted [WH97b, Wan97].
Reference: [vDHK] <editor> Arie van Deursen, Jan Heering, and Paul Klint. </editor> <publisher> World Scientific Publishing Co. Pte. Ltd. </publisher>
Reference-contexts: SDA is supported by a rich assortment of tools and techniques developed by the functional programming and formal methods communities to support language design, including for example, modular monadic semantics [Mog90, SLJ95, LH96] and metaprogramming [TBS98]. It competes with other language design technologies such as Action Semantics [Mos92], ASF+SDF <ref> [vDHK] </ref>, DSELs [Hud96], and Amphion [LPPU94]. One primary feature that distinguishes SDA from other language design methods is that it specifically includes a domain analysis subprocess for discovering and modeling important domain abstractions. <p> However, this tool is theorem prover instead of a semantics-based interpreter. Other differences are that the method requires the existence of an extensive and well-understood library of scientific operations, and that there is no well-defined method for defining the language or the the libraries. 3.4 ASF-SDF ASF-SDF <ref> [vDHK] </ref> is an algebraic specification formalism used to define algebras, which are a set of values accompanied by a set of functions operating on these values. Relationships between operations (specified by function symbols) and values (specified as constants) are called equalities.
Reference: [VV95] <author> M. G. J. Van den Brand and E. </author> <title> Visser. </title> <booktitle> The ASF+SDF meta-environment: Documentation tools for free! Lecture Notes in Computer Science, </booktitle> <address> 915:803-??, </address> <year> 1995. </year>
Reference-contexts: ASF-SDF includes a specification development environment consisting of a syntax directed editor that can perform context-sensitive analysis of specifications (similar to type checking) to provide immediate error checking of specifications. It also supports literate specifications <ref> [VV95] </ref> in the literate programming approach advocated by Knuth [Knu]. ASF-SDF is a DSL for defining context-free syntax for arbitrary (context-free) languages. It is a first-order language, however, and abstractions requiring higher orderness (such as monads) are not expressible in it.
Reference: [Wal96] <author> Lisa Walton. </author> <title> Lucent experience report. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, 1996. Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 10 </institution>
Reference: [Wal97] <author> Lisa Walton. </author> <title> The semantics of message specification language MSL. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <year> 1997. </year>
Reference-contexts: A complete case study for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself [WH94] and Widen [WH97c]) was followed [WH97a], a language definition [WH94], a semantics for a core subset of MSL <ref> [Wal97] </ref>, and a proof of the appropriate isomorphism property [Wal98] that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design methods as a supplement to Lucent's Family-oriented abstraction, specification, and translation (FAST) method.
Reference: [Wal98] <author> Lisa A. Walton. </author> <title> Correctness proofs for parser/unparser generators. </title> <note> in preparation, </note> <year> 1998. </year>
Reference-contexts: for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself [WH94] and Widen [WH97c]) was followed [WH97a], a language definition [WH94], a semantics for a core subset of MSL [Wal97], and a proof of the appropriate isomorphism property <ref> [Wal98] </ref> that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design methods as a supplement to Lucent's Family-oriented abstraction, specification, and translation (FAST) method.
Reference: [Wan97] <author> Keith Wansbrough. </author> <title> A modular monadic action semantics. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, Univ. of Auckland, </institution> <month> February </month> <year> 1997. </year> <note> http://www.dcs.gla.ac.uk/~keithw/thesis. </note>
Reference-contexts: There is, however, an action semantic description (ASD) tool implemented in ASF-SDF that provides some checking of action semantic specifications [vD94]. Recently an attempt to combine modular monadic semantics and action semantics to get the best of both worlds was attempted <ref> [WH97b, Wan97] </ref>.
Reference: [Wei97] <author> David Weiss. </author> <title> Creating domain-specific languages: The fast process. </title> <booktitle> In First ACM Workshop on Domain-Specific Languages. </booktitle> <editor> S. Kamin, editor, </editor> <year> 1997. </year>
Reference-contexts: Alternatively, there could be an ongoing feedback process as the tools mature. The important aspect is to have a defined mechanism for evaluating the usefulness and reliability of the tools. Empirical evidence suggests that DSLs can significantly improve the productivity of software developers <ref> [Wei97, KMB + 96] </ref> and also the usability and reliability of development tools [KMB + 96].
Reference: [WH94] <author> Lisa Walton and James Hook. </author> <title> A definition of MSL, a domain-specific design language for message translation and validation. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: In addition, the following tools were built MSL Translator, Test Case Generator, Experiment Environment, application generator. A complete case study for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself <ref> [WH94] </ref> and Widen [WH97c]) was followed [WH97a], a language definition [WH94], a semantics for a core subset of MSL [Wal97], and a proof of the appropriate isomorphism property [Wal98] that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design <p> A complete case study for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself <ref> [WH94] </ref> and Widen [WH97c]) was followed [WH97a], a language definition [WH94], a semantics for a core subset of MSL [Wal97], and a proof of the appropriate isomorphism property [Wal98] that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design methods as a supplement to Lucent's Family-oriented abstraction, specification, and
Reference: [WH95a] <author> Lisa Walton and James Hook. </author> <title> Creating and verifying domain-specific design languages. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Ore-gon Graduate Institute, </institution> <month> August </month> <year> 1995. </year> <note> Internal technical memo. </note>
Reference: [WH95b] <author> Lisa Walton and James Hook. </author> <title> Design automation: Making formal methods relevant, April 1995. </title> <booktitle> Presented at ICSE-17 Workshop on Formal Methods Application in Software Engineering Practice. </booktitle>
Reference: [WH95c] <author> Lisa Walton and James Hook. </author> <title> Message specification language (MSL): A domain specific design language for message translation and validation. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> Jan-uary </month> <year> 1995. </year>
Reference: [WH95d] <author> Lisa Walton and James Hook. </author> <title> Message specification language (MSL): Reference manual. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Ore-gon Graduate Institute, </institution> <month> January </month> <year> 1995. </year>
Reference: [WH95e] <author> Lisa Walton and James Hook. </author> <title> Msl compiler tool documentation, </title> <month> January </month> <year> 1995. </year> <title> In Collected Tool Documentation for MTV Generator (CDRL 002.7). </title>
Reference: [WH96] <author> L. Walton and J. Hook. </author> <title> On understanding a commonality analysis. </title> <booktitle> In Proceedings of the OOPSLA'96 Workshop on Domain Analysis: Processes and Results, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Ultimately, we would like to see SDA adopted by software development organizations as part of their institutional software engineering practices. 2.1 My Contribution to SDA My primary contributions to refining and evolving the SDA method are as follows: * A process for creating our internal domain analysis <ref> [WH96, WH97a] </ref> (item 1 above). * A description of the models (item 2 above) developed from a DA that are required for input to the language design process. <p> Some anecdotal evidence as to the usefulness of the analysis and modeling aspects of the method has been collected and presented in workshop papers <ref> [WH96] </ref>. Furthermore, there is evidence that we were able to improve Lucent's own internal method training activities. Currently, they are discovering flaws in their tools and representations that would have been discovered had our technology been used.
Reference: [WH97a] <author> Lisa Walton and James Hook. </author> <title> The design of message specification language MSL. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <year> 1997. </year> <note> ftp://cse.ogi.edu/pub/pacsoft/papers/msl rev.ps. </note>
Reference-contexts: Ultimately, we would like to see SDA adopted by software development organizations as part of their institutional software engineering practices. 2.1 My Contribution to SDA My primary contributions to refining and evolving the SDA method are as follows: * A process for creating our internal domain analysis <ref> [WH96, WH97a] </ref> (item 1 above). * A description of the models (item 2 above) developed from a DA that are required for input to the language design process. <p> In addition, the following tools were built MSL Translator, Test Case Generator, Experiment Environment, application generator. A complete case study for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself [WH94] and Widen [WH97c]) was followed <ref> [WH97a] </ref>, a language definition [WH94], a semantics for a core subset of MSL [Wal97], and a proof of the appropriate isomorphism property [Wal98] that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design methods as a supplement to Lucent's
Reference: [WH97b] <author> Keith Wansbrough and John Hamer. </author> <title> A modular monadic action semantics. </title> <booktitle> In Conference on Domain-Specific Languages, </booktitle> <pages> pages 157-170. </pages> <booktitle> The USENIX Association, </booktitle> <year> 1997. </year> <note> http://www.dcs.gla.ac.uk/~keithw/thesis. Id: proposal.tex,v 1.5 1998/10/20 15:17:16 walton Exp walton 11 </note>
Reference-contexts: There is, however, an action semantic description (ASD) tool implemented in ASF-SDF that provides some checking of action semantic specifications [vD94]. Recently an attempt to combine modular monadic semantics and action semantics to get the best of both worlds was attempted <ref> [WH97b, Wan97] </ref>.
Reference: [WH97c] <author> Tanya Widen and James Hook. </author> <title> Software design automation: Language design in the context of domain engineering. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <year> 1997. </year> <month> ftp://cse.ogi.edu/pub/pacsoft/papers/SDA.ps. </month>
Reference-contexts: In addition, the following tools were built MSL Translator, Test Case Generator, Experiment Environment, application generator. A complete case study for the MTV project should be completed by Christmas, including an account of how closely the language design process (documented by myself [WH94] and Widen <ref> [WH97c] </ref>) was followed [WH97a], a language definition [WH94], a semantics for a core subset of MSL [Wal97], and a proof of the appropriate isomorphism property [Wal98] that holds over the core subset. 4.2 5ESS Telephone Switches The Lucent collaboration seeks to demonstrate the utility of PacSoft's language design methods as a
Reference: [Wid98] <author> Tanya Widen. </author> <title> Formal language design in the context of domain engineering. </title> <type> Master's thesis, </type> <institution> Oregon Graduate Institute, </institution> <month> June </month> <year> 1998. </year>
Reference-contexts: The subprocess of going from a CA to an application engineering tool and environment are less well defined, and it is here that SDA provides some support. The results of combining FAST with SDA are described in Widen's thesis <ref> [Wid98] </ref>. 3.3 Amphion The Amphion [LPPU94] project utilizes formal specifications and automated deductive synthesis to allow non-programmers to effectively utilize scientific libraries. A domain theory is created for each domain that relates the problem area to library operations. <p> Currently, they are discovering flaws in their tools and representations that would have been discovered had our technology been used. The results are contained in the following artifacts: * Evaluation of the integration of SDA/FAST <ref> [Wid98] </ref> * Domain Analysis for Switch Maintenance Configuration Control (technical report) * SM/CC domain models (technical report) * Switch Specification Tool (switch specification prototype tool) Currently, Shulman and I are working on a language for specifying static switch configurations.
Reference: [WIK + 96] <author> James R. Wilson, David M. Dikel (Principal Investigator), David Kane, Dr. Mar-cia Carlyn, Carol Terry, Elizabeth Cavanaugh (EDS), and David Johnson. </author> <title> Software reuse benchmarking study: Learning from industry and government leaders. </title> <type> Technical report, </type> <institution> Applied Expertise, Inc, </institution> <month> January </month> <year> 1996. </year> <note> http://dii-sw.ncr.disa.mil/ReuseIC/lessons/benchmark. </note>
Reference-contexts: It has been repeatedly demonstrated that organizations that effectively apply software reuse achieve key strategic and competitive advantages in terms of reduced cost, faster product delivery, improved interoperability and lowered defects <ref> [WIK + 96] </ref>. One effective way of identifying opportunities for reuse in an application domain is to look for program families [JFW90].
Reference: [WPD92] <author> S. Wartik and R. Prieto-Diaz. </author> <title> Criteria for comparing domain analysis approaches. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: There are many published approaches to DA, including a range of informal and formal methods and processes [Pro93, Gom90, KSC90a, PD91]. More recently researchers and practitioners have attempted systematic comparisons of DA methods and technologies <ref> [APD91, WPD92] </ref>. What most approaches lack (and SDA strives to provide) is a well-defined method to convert expert knowledge to useful artifacts, such as application generators or executable specification languages. A domain analysis is often part of a larger domain engineering effort.
References-found: 52

