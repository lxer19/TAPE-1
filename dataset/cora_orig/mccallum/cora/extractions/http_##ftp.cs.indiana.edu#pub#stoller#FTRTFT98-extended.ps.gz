URL: http://ftp.cs.indiana.edu/pub/stoller/FTRTFT98-extended.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: stoller@cs.indiana.edu  
Phone: Fax: 812-855-4829  2  
Title: Automated Stream-Based Analysis of Fault-Tolerance  
Author: Scott D. Stoller and Fred B. Schneider 
Web: Web: www.cs.indiana.edu/~stoller/  
Address: Bloomington, IN 47405, USA  Ithaca, NY 14853, USA  
Affiliation: 1 Computer Science Dept., Indiana University,  Dept. of Computer Science, Cornell University,  
Abstract: A rigorous, automated approach to analyzing fault-tolerance of distributed systems is presented. The method is based on a stream model of computation. One novel feature is incorporating approximation mechanisms into the stream model; another is performing the analysis with respect to changes to system behavior due to failures. Two applications are described: the Oral Messages algorithm of Lamport, Shostak, and Pease, and a recent protocol for fault-tolerant moving agents. 
Abstract-found: 1
Intro-found: 1
Reference: [AH87] <editor> Samson Abramsky and Chris Hankin. </editor> <title> An introduction to abstract interpretation. </title> <editor> In Samson Abramsky and Chris Hankin, editors, </editor> <title> Abstract Interpretation of Declarative Languages, chapter 1. </title> <publisher> Ellis-Horwood, </publisher> <year> 1987. </year>
Reference-contexts: This paper explores a specialized approach to analysis of fault-tolerance properties for distributed systems. Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) models of networks of processes [Kah74,Bro87,Bro90] and abstract interpretation of programs <ref> [AH87] </ref>. An important feature of our approach is its emphasis on communication (rather than state), consistent with the thesis that distributed systems have natural descriptions in terms of communication. In stream-processing models, each component of a system is represented by an input-output function describing its input/output behavior. <p> Exact computation of all possible sequences of messages that might be sent is generally infeasible. To help make automated analysis feasible, our framework supports flexible and powerful approximations, or abstractions, as they are called in the literature on abstract interpretation <ref> [AH87] </ref> and program refinement [KMP94]. Traditionally, Automated Stream-Based Analysis of Fault-Tolerance 3 stream-processing models are used as mathematical semantics and incorporate no approximations.
Reference: [BD92] <author> Manfred Broy and Claus Dendorfer. </author> <title> Modelling operating system structures by timed stream processing functions. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 1-21, </pages> <year> 1992. </year>
Reference: [Bro87] <author> Manfred Broy. </author> <title> Semantics of finite and infinite networks of concurrent communicating agents. </title> <journal> Distributed Computing, </journal> <volume> 2(1) </volume> <pages> 13-31, </pages> <year> 1987. </year>
Reference: [Bro90] <author> Manfred Broy. </author> <title> Functional specification of time sensitive communicating systems. </title> <booktitle> In Proceedings of the REX Workshop on Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>

Reference: [CGL94] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: However, most people who design and validate fault-tolerant systems are not experts in mathematical logic. Proof techniques designed specifically for verification of fault-tolerance (e.g., [CdR93,PJ94,Sch94]) facilitate construction of these proofs but still require logical expertise of the user. Automated verification techniques, such as temporal-logic model-checking <ref> [CGL94] </ref> and automata- and process-based analyses [Hol91,Kur94,CS96], have made great progress in the last decade. These techniques are based on exhaustive exploration of finite state-spaces. <p> A fuller discussion of related and future work can also be found there. Here, we briefly describe some related work not mentioned above. Clarke, Grumberg, and Long <ref> [CGL94] </ref> developed a method for using abstractions with temporal-logic model-checking. In Kurshan's automata-based methodology, approximations are embodied in reductions between verifications [Kur94]. Relationships between values can be captured using parameterized families of reductions; this is analogous to the "symbolic abstractions" of [CGL94]. <p> Clarke, Grumberg, and Long <ref> [CGL94] </ref> developed a method for using abstractions with temporal-logic model-checking. In Kurshan's automata-based methodology, approximations are embodied in reductions between verifications [Kur94]. Relationships between values can be captured using parameterized families of reductions; this is analogous to the "symbolic abstractions" of [CGL94]. For problems involving related values (e.g., X, F (X), and G (F (X)), where F and G are function symbols, as in Section 5), the family of reductions must introduce an "abstract" value representing each of these values.
Reference: [CS96] <author> Rance Cleaveland and Steve Sims. </author> <title> The NCSU Concurrency Workbench. </title> <editor> In R. Alur and T. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification (CAV '96), volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 394-397. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [DB92] <author> Ben L. Di Vito and Ricky W. Butler. </author> <title> Provable transient recovery for frame-based, fault-tolerant computing systems. </title> <booktitle> In Proc. 13th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 275-278. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference: [Kah74] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing 74: Proceedings of the IFIP Congress 74, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference: [KMP94] <author> Yonit Kesten, Zohar Manna, and Amir Pnueli. </author> <title> Temporal verification of simulation and refinement. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozen-berg, editors, </editor> <booktitle> Proc. REX School/Symposium, volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 273-346. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Exact computation of all possible sequences of messages that might be sent is generally infeasible. To help make automated analysis feasible, our framework supports flexible and powerful approximations, or abstractions, as they are called in the literature on abstract interpretation [AH87] and program refinement <ref> [KMP94] </ref>. Traditionally, Automated Stream-Based Analysis of Fault-Tolerance 3 stream-processing models are used as mathematical semantics and incorporate no approximations. The approximations in our framework enable compact representation of the highly non-deterministic behavior characteristic of severe failures and support abstraction from irrelevant aspects of a system's failure-free behavior.
Reference: [Kur94] <author> Robert P. Kurshan. </author> <title> Computer-aided verification of coordinating processes: the automata-theoretic approach. </title> <publisher> Princeton Univesity Press, </publisher> <year> 1994. </year>
Reference-contexts: A fuller discussion of related and future work can also be found there. Here, we briefly describe some related work not mentioned above. Clarke, Grumberg, and Long [CGL94] developed a method for using abstractions with temporal-logic model-checking. In Kurshan's automata-based methodology, approximations are embodied in reductions between verifications <ref> [Kur94] </ref>. Relationships between values can be captured using parameterized families of reductions; this is analogous to the "symbolic abstractions" of [CGL94].
Reference: [LJ92] <author> Zhiming Liu and Mathai Joseph. </author> <title> Transformation of programs for fault-tolerance. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4 </volume> <pages> 442-469, </pages> <year> 1992. </year>
Reference: [LM94] <author> Leslie Lamport and Stephan Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, For 20 Scott D. Stoller and Fred B. </editor> <title> Schneider mal Techniques in Real-Time and Fault-Tolerant Systems, </title> <booktitle> volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-76. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In this section, the perturbational method is used to analyze a classic solution to this problem, namely, the Oral Messages algorithm [LSP82]. Analyzing an algorithm that has been proved correct using other approaches (e.g., a proof of correctness for n = 3 appears in <ref> [LM94] </ref>) facilitates use of that algorithm as a benchmark for comparison of different verification methods. Automated Stream-Based Analysis of Fault-Tolerance 15 The Oral Messages algorithm relies on the following assumptions about the underlying communication mechanism: Integrity: Every message that is sent is delivered correctly.
Reference: [LR94] <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an interactive consistency algorithm for the draper ftp architecture under a hybrid fault model. </title> <booktitle> In Proc. 9th Annual Conference on Computer Assurance, </booktitle> <year> 1994. </year>
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: This paper describes an analysis method and automated tool for step (3) with applications to the Oral Messages algorithm <ref> [LSP82] </ref> for Byzantine Agreement and a protocol for fault-tolerant moving agents [MvRSS96,Sto97]. Automated analysis methods address an important need, because informal arguments do not supply the desired level of assurance for critical systems, and practitioners often lack the background needed to construct formal proofs. <p> The latter requirements can be verified separately, using whatever methods are appropriate, while our method is used to analyze fault-tolerance, using coarse approximations of aspects of the system that are not directly relevant to its fault-tolerance. In Section 5, the perturbational method is applied to the Oral Messages algorithm <ref> [LSP82] </ref> for Byzantine Agreement 4 Scott D. Stoller and Fred B. Schneider Both analysis methods are implemented in a prototype tool, called CRAFT, that provides a collection of types and functions and a Tk-based graphical interface to facilitate entry of systems and inspection of analysis results. <p> failure-free behavior of the component; the perturbation formulas and new ms-atoms in the output poset f (fail )(in) reflect the effects of the failure fail and the effects of the perturbation formulas and new ms-atoms in the input poset in. 5 Analysis of Oral Messages Algorithm Byzantine agreement, defined in <ref> [LSP82] </ref>, is a classic problem in fault-tolerance. Algorithms for Byzantine agreement, or the closely related problem of interactive consistency, are important in high-assurance systems [LR94,ORSvH95]. <p> The goal is for the commander to disseminate a command to the lieutenants, who act on (or "decide on", in the terminology of <ref> [LSP82] </ref>) this command. In our formulation, a lieutenant L i acts on a command by sending a message containing that command to its army A i . <p> In this section, the perturbational method is used to analyze a classic solution to this problem, namely, the Oral Messages algorithm <ref> [LSP82] </ref>. Analyzing an algorithm that has been proved correct using other approaches (e.g., a proof of correctness for n = 3 appears in [LM94]) facilitates use of that algorithm as a benchmark for comparison of different verification methods.
Reference: [MvRSS96] <author> Yaron Minsky, Robbert van Renesse, Fred B. Schneider, and Scott D. Stoller. </author> <title> Cryptographic support for fault-tolerant distributed computing. </title> <booktitle> In Proc. Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 109-114. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: Message or-derings are approximated using partial (instead of total) orders. Section 3 applies the analysis to a protocol for fault-tolerant moving agents <ref> [MvRSS96] </ref>. In the perturbational method, described in Section 4, the effects of failures are represented as perturbations to the failure-free outputs of a component. The fixed-point analysis propagates these perturbations to determine their effect on the subsequent execution of the system. <p> We consider here a protocol in which digital signatures are used by the consolidator to reliably determine validity (a protocol based on shared secrets is described in <ref> [MvRSS96] </ref>). We assume digital signatures are implemented using public-key cryptography and that each component knows its own private key and the public key of every other component.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference: [PJ94] <author> Doron Peled and Mathai Joseph. </author> <title> A compositional framework for fault-tolerance by specification transformation. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 128(1-2):99-125, </address> <year> 1994. </year>
Reference: [Sch94] <author> Henk Schepers. </author> <title> A trace-based compositional proof theory for fault tolerant distributed systems. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 128(1-2):127-157, </address> <year> 1994. </year>
Reference: [SS97] <author> Scott D. Stoller and Fred B. Schneider. </author> <title> Automated analysis of fault-tolerance in distributed systems. </title> <editor> In Rance Cleaveland and Daniel Jackson, editors, </editor> <booktitle> Proc. First ACM SIGPLAN Workshop on Automated Analysis of Software, </booktitle> <pages> pages 33-44, </pages> <address> Paris, France, </address> <month> 14 January </month> <year> 1997. </year>
Reference-contexts: The symbolic values in multiplicities are not needed for the examples in this paper but are useful for efficient analysis of systems with crash failures <ref> [SS97] </ref>. Abstract multiplicities are analogous to superscripts in regular expressions. To promote the resemblance, we assume AVal contains the following: 1, denoting f1g; ?, denoting f0; 1g; +, denoting the set of positive natural numbers; and fl, 6 Scott D. Stoller and Fred B.
Reference: [Sto97] <author> Scott D. Stoller. </author> <title> A Method and Tool for Analyzing Fault-Tolerance in Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: We have used CRAFT to analyze the moving agent protocol and the Oral Messages algorithm. The design and use of CRAFT are described in <ref> [Sto97] </ref>. This paper focuses on the two applications mentioned above. A more formal presentation of our analysis methods, including a semantics and a proof of soundness with respect to that semantics, appear in [Sto97]. A fuller discussion of related and future work can also be found there. <p> The design and use of CRAFT are described in <ref> [Sto97] </ref>. This paper focuses on the two applications mentioned above. A more formal presentation of our analysis methods, including a semantics and a proof of soundness with respect to that semantics, appear in [Sto97]. A fuller discussion of related and future work can also be found there. Here, we briefly describe some related work not mentioned above. Clarke, Grumberg, and Long [CGL94] developed a method for using abstractions with temporal-logic model-checking. In Kurshan's automata-based methodology, approximations are embodied in reductions between verifications [Kur94]. <p> Each variable is is local to a single component, whose outputs in a given execution determine the value represented by that variable. Making each variable local to a single component enables independent verification that each input-output function faithfully represents the behavior of the corresponding process (as described in <ref> [Sto97] </ref>). We also include in SVal a special wildcard symbol " ", which is used when a value is not known to have any interesting relationships to other values. Different occurrences of the wildcard in a MFG do not necessarily represent the same concrete value. <p> The behavior of a system nf in failure scenario fs is represented by the MFG lfp (step nf ;fs ), if it exists, where lfp indicates the least fixed-point, and the partial ordering on MFG, defined in <ref> [Sto97] </ref>, corresponds informally to the prefix ordering on sequences. This fixed-point might not exist; one reason, roughly, is that MFGs do not have canonical forms [Sto97]. <p> by the MFG lfp (step nf ;fs ), if it exists, where lfp indicates the least fixed-point, and the partial ordering on MFG, defined in <ref> [Sto97] </ref>, corresponds informally to the prefix ordering on sequences. This fixed-point might not exist; one reason, roughly, is that MFGs do not have canonical forms [Sto97]. The tool searches for a fixed-point by starting with the "empty" MFG (x : Name: y : Name: h;; ;i) and repeatedly applying step nf ;fs . If the fixed-point does not exist, this procedure diverges. 1 Fault-Tolerance Requirements. <p> revised protocol is shown in its output, so the value in its outputs is a set of three possibilities; specifically, the value is (ms j fifMsgg) 2 Val , where ms j = fm2 1;j ; m2 2;j ; m2 3;j g: Detailed input-output functions for this protocol appear in <ref> [Sto97] </ref>. 3.1 Analysis Results To determine whether the above protocol satisfies MA-FTR, an MFG representing the protocol's behavior is computed for each failure scenario in which a minority of the replicas of each service used by the moving agent fail and any number of replicas of each service not used by <p> We take N (C) = fL 1 ; : : : ; L n g N (A i ) = fL i g: Input-output functions for the Oral Messages algorithm appear in <ref> [Sto97] </ref>; here we describe them informally. The Oral Messages algorithm is essentially a recursive application of majority voting; the recursion is on the number of processes.
References-found: 21

