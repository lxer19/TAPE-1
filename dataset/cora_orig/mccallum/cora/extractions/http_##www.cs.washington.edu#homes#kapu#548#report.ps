URL: http://www.cs.washington.edu/homes/kapu/548/report.ps
Refering-URL: http://www.cs.washington.edu/homes/kapu/548/project.html
Root-URL: 
Title: Predicated Execution on Alpha Architecture  
Author: David Christianson Omid Madani Kari Pulli 
Date: March 13, 1995  
Abstract: This report describes experiments of using conditional moves on Alpha architectures of different instruction issue widths. Six SPEC92 benchmark programs were compiled with the Multiflow compiler and simulated with an Alpha simulator. We observed that the use of conditional moves can speed programs up when used carefully. The expected speedups are modest, however. Their usability didnt't seem to change across different superscalar widths, either.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Fischer, J. Ellis, </author> <title> "Parallel Processing: A Smart Compiler and a Dumb Machine", </title> <booktitle> Proc. ACM SIGPLAN '84 Symp. Compiler Construction, SIGPLAN Notices 19(6) </booktitle> <pages> 37-47, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: After the results we present our conclusions. In the last section we present a critique and possible future work. An appendix describes the SPEC92 benchmarks that we used in our experiments. 2 Testing environment 2.1 Multiflow compiler The Multiflow compiler [4] was originally designed to run on a VLIW <ref> [1] </ref> (Very Long Instruction Word) architecture. Superscalar architectures can be thought of as generalizations of VLIW, and as VLIW machines didn't take off the Multiflow compiler was retargeted to DEC's Alpha series machines. The Multiflow compiler uses trace scheduling to find and exploit instruction-level parallelism beyond basic blocks of code.
Reference: [2] <author> S. Freudenberger, T. Gross, P. Lowney, </author> <title> "Avoidance and Suppression of Compensation Code in a Trace Scheduling Compiler", </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1156-1214, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: If an operation is moved across basic block boundaries, one or more compensation copies may be required in the off-trace code. Through techniques such as avoidance (restricting code motion) and suppression (detecting redundant copies) the average code size increases can be kept at 6% <ref> [2] </ref>. The compiler is very nice for performing measurements since it has a large set of input options that allow the user quite precisely to tell which methods to use or exclude when compiling the code.
Reference: [3] <author> J. Hennessy, D. Patterson, </author> <title> Computer Architecture A Quantitative Approach, 2nd Ed., </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction 1.1 Motivation The idea behind predicated or conditional execution of instructions is that there are instructions that refer to conditions which are evaluated as part of the instruction execution <ref> [3] </ref>. The main attraction of predicated execution is the avoidance of branches. Since branches cause bubbles in the CPU pipeline they are expensive, and in superscalar architectures bubbles waste even more instruction slots. Predicated execution allows simple branches to be totally eliminated.
Reference: [4] <author> P. Lowney, S. Freudenberger, T. Karzes, W. Lichtenstein, R. Nix, J. O'Donnel, J. Ruttenberg, </author> <title> "The Multiflow Trace Scheduling Compiler", </title> <journal> The Journal of Supercomputing, </journal> <volume> 7, </volume> <pages> 51-142, </pages> <year> 1993. </year>
Reference-contexts: After the results we present our conclusions. In the last section we present a critique and possible future work. An appendix describes the SPEC92 benchmarks that we used in our experiments. 2 Testing environment 2.1 Multiflow compiler The Multiflow compiler <ref> [4] </ref> was originally designed to run on a VLIW [1] (Very Long Instruction Word) architecture. Superscalar architectures can be thought of as generalizations of VLIW, and as VLIW machines didn't take off the Multiflow compiler was retargeted to DEC's Alpha series machines.
Reference: [5] <author> D. Tullsen, S. Eggers, H. Levy, </author> <title> "Simultaneous Multithreading: Maximizing On-Chip Parallelism", </title> <booktitle> to appear in in ISCA (International Symposium on Computer Architecture), </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Also, the compilations often take a long time. However, it seems that when it compiles something, it compiles it correctly. 2.2 A simulator for the Alpha architecture Dean Tullsen has created a simulator for experimenting with simultaneous multithreading on DEC Alpha AXP 21164 <ref> [5] </ref>. The simulator uses emulation-based instruction-level simulation. The simulator models the execution pipelines, the memory hierarchy, the TLBs, and the branch prediction logic of the Alpha. Features that differ from Alpha include increased single-stream parallelism, improved branch prediction, higher bandwidth caches, wider superscalar execution, and multithreaded execution.
References-found: 5

