URL: http://www.cs.cornell.edu/Info/People/crary/papers/ho-subtype-impl.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Foundations for the Implementation of Higher-Order Subtyping  
Author: Karl Craryy 
Affiliation: Department of Computer Science Cornell University  
Abstract: We show how to implement a calculus with higher-order subtyping and subkinding by replacing uses of implicit sub-sumption with explicit coercions. To ensure this can be done, a polymorphic function is adjusted to take, as an additional argument, a proof that its type constructor argument has the desired kind. Such a proof is extracted from the derivation of a kinding judgement and may in turn require proof coercions, which are extracted from subkinding judgements. This technique is formalized as a type-directed translation from a calculus of higher-order subtyping to a subtyping-free calculus. This translation generalizes an existing result for second-order subtyping calculi (such as F ). We also discuss two interpretations of subtyping, one that views it as type inclusion and another that views it as the existence of a well-behaved coercion, and we show, by a type-theoretic construction, that our translation is the minimum consequence of shifting from the inclusion interpretation to the coercion-existence interpretation. This construction shows that the translation is the natural one, and it also provides a framework for extending the translation to richer type systems. Finally, we show how the two interpretations can be reconciled in a common semantics. It is then easy to show the coherence of the translation relative to that semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Stuart Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <booktitle> In Second IEEE Symposium of Logic in Computer Science, </booktitle> <pages> pages 215-221, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: We begin by supposing that we are given a value-respecting partial equivalence relation (VPER, defined below) semantics built over some evaluation function <ref> [21, 1, 2] </ref>, and that we are given a set of coercions operating on that semantics' primitive types. We will then build a new VPER semantics that incorporates those coercions. A partial equivalence relation (PER) is a symmetric and transitive relation.
Reference: [2] <author> Stuart Allen. </author> <title> A Non-Type-Theoretic Semantics for Type-Theoretic Language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1987. </year>
Reference-contexts: We begin by supposing that we are given a value-respecting partial equivalence relation (VPER, defined below) semantics built over some evaluation function <ref> [21, 1, 2] </ref>, and that we are given a set of coercions operating on that semantics' primitive types. We will then build a new VPER semantics that incorporates those coercions. A partial equivalence relation (PER) is a symmetric and transitive relation.
Reference: [3] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: A proof of this kind-ing relationship would be such a coercion. The translation extracts such a proof from the derivation of t 1 t 2 in a manner reminiscent of the extraction of programs from constructive proofs <ref> [3] </ref>. The additional proof variables shown above (e.g., ^ff, ^fl) ensure that proofs are available at the leaves of the derivation. As an aside, we can see here the potential for a computational inefficiency.
Reference: [4] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: to t , but we have no idea what it is. (The reader familiar with constructive logic may notice a parallel between this difficulty and the problem of extracting programs from non-constructive proofs; we will see later that indeed the solution results from making kinding proofs constructive.) Breazu-Tannen et al. <ref> [4] </ref>, hereafter referred to as BCGS, showed how to solve this problem in the second-order case for languages such as Fun [12] and F [11, 10]. The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. <p> The necessary restriction can easily be implemented syntactically by adding a type of coercions which can only be built with specified combinators, as in the BCGS system of variant types. 6 Related Work In the seminal paper on subtyping as coercion-existence <ref> [4] </ref>, BCGS developed the use of coercions to eliminate subsump-tion in the second-order case. Their focus was on making a wider array of semantic techniques available to model sub-typing calculi.
Reference: [5] <author> Val Breazu-Tannen, Carl A. Gunter, and Andre Sce-drov. </author> <title> Computing with coercions. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 44-60, </pages> <year> 1990. </year>
Reference-contexts: Coercions resulting from the latter do nothing of computational interest except ap ply primitive coercions resulting from the former <ref> [5] </ref>, so we will give the construction of the new semantics for primitive types and allow its extension to type constructors to be interleaved with it. We construct the new semantics by induction on the sub-typing order resulting from our set of coercions. <p> Curien and Ghelli [18] developed another technique for showing the syntactic coherence of a similar second-order translation by proof rewriting. Breazu-Tannen, Gunter and Scedrov <ref> [5] </ref> gave an operational semantics to a first-order special case (without polymorphism, bounded quantification or subtyp-ing on primitive types) and showed that the translation in that case did not observably affect the computation.
Reference: [6] <author> Kim B. Bruce and Giuseppe Longo. </author> <title> A modest model of records, inheritance, and bounded quantification. </title> <journal> Information and Computation, </journal> <volume> 87 </volume> <pages> 196-240, </pages> <year> 1991. </year>
Reference-contexts: Breazu-Tannen, Gunter and Scedrov [5] gave an operational semantics to a first-order special case (without polymorphism, bounded quantification or subtyp-ing on primitive types) and showed that the translation in that case did not observably affect the computation. Bruce and Longo <ref> [6] </ref> developed a model of subtyping and bounded quantification that interprets types as PERs, but interprets an element of type t as an equivalence class of ' t , not as a member of Dom (' t ).
Reference: [7] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Fifteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <address> San Diego, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Thus, the class of type constructors contains types and higher-order type constructors with which types can be built. The kind class, which gives the "types" of type constructors, is the most novel. It contains the power kind <ref> [7] </ref> and dependent product and sum kinds. When t is a type, the power kind P (t ) contains all types that are subtypes of t . Since every type is a subtype of Top, the kind of all types, Type, is defined as P (Top).
Reference: [8] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished Manuscript, </type> <year> 1990. </year>
Reference-contexts: The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest [9], F ! <ref> [8, 28] </ref> and K [16]. Instead of taking a coercion as an extra argument, as in BCGS, polymorphic functions take a higher-order kinding proof. <p> Related work is discussed in Section 6 and brief concluding remarks appear in Section 7. 2 Source and Target Calculi The Source We begin by giving the definition of our source calculus. In the literature, this calculus is closest to Quest [9], F ! <ref> [8] </ref> and K [16]. The syntax rules appear in Figure 1. The source consists of three syntactic classes: kinds, type constructors (often referred to briefly as "constructors") and terms. A fourth syntactic class, contexts, is used to assign meaning to free variables in the typing rules. <p> That generalized translation is put to practical use in the KML compiler [15]. We also claim, without elaboration, that the construction shows how to generalize the translation to Cardelli's formulation of F ! with monotone kinds <ref> [8] </ref>. We also hope that the reconciliation of Section 5 can be used to manage complexity in formalized mathematics. In informal mathematics, a structure in algebra or analysis is often used as a substructure of another, implicitly using iso-morphism.
Reference: [9] <author> Luca Cardelli. </author> <title> Typeful programming. In Formal Description of Programming Concepts. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest <ref> [9] </ref>, F ! [8, 28] and K [16]. Instead of taking a coercion as an extra argument, as in BCGS, polymorphic functions take a higher-order kinding proof. <p> Related work is discussed in Section 6 and brief concluding remarks appear in Section 7. 2 Source and Target Calculi The Source We begin by giving the definition of our source calculus. In the literature, this calculus is closest to Quest <ref> [9] </ref>, F ! [8] and K [16]. The syntax rules appear in Figure 1. The source consists of three syntactic classes: kinds, type constructors (often referred to briefly as "constructors") and terms. A fourth syntactic class, contexts, is used to assign meaning to free variables in the typing rules.
Reference: [10] <author> Luca Cardelli. </author> <title> An implementation of F &lt;: </title> . <note> SRC Research Report 97, </note> <institution> Digital Equipment Corporation, Sys tems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: and the problem of extracting programs from non-constructive proofs; we will see later that indeed the solution results from making kinding proofs constructive.) Breazu-Tannen et al. [4], hereafter referred to as BCGS, showed how to solve this problem in the second-order case for languages such as Fun [12] and F <ref> [11, 10] </ref>. The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest [9], F ! [8, 28] and K [16].
Reference: [11] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with sub-typing. </title> <booktitle> In Theoretical Aspects of Computer Software 1991, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 750-770, </pages> <address> Sendai, Japan, 1991. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: and the problem of extracting programs from non-constructive proofs; we will see later that indeed the solution results from making kinding proofs constructive.) Breazu-Tannen et al. [4], hereafter referred to as BCGS, showed how to solve this problem in the second-order case for languages such as Fun [12] and F <ref> [11, 10] </ref>. The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest [9], F ! [8, 28] and K [16].
Reference: [12] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: To have acceptable performance, the compiler must determine the proper coercions statically, at compile-time. This can easily be done in an (explicitly typed) programming language with first-class functions, records, and even parametric polymorphism, but becomes complicated with the introduction of bounded quantification <ref> [12] </ref>. Consider the bounded polymorphic function flfft: x:ff: f (x) where f has type t ! t 0 . With ff unknown, it is not possible to determine the coercion for x from type ff to type t . <p> between this difficulty and the problem of extracting programs from non-constructive proofs; we will see later that indeed the solution results from making kinding proofs constructive.) Breazu-Tannen et al. [4], hereafter referred to as BCGS, showed how to solve this problem in the second-order case for languages such as Fun <ref> [12] </ref> and F [11, 10]. The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument.
Reference: [13] <author> R.L. Constable, S.F. Allen, H.M. Bromley, W.R. Cleaveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mendler, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: The construction begins by building the kinds of our source calculus in the type theory of Nuprl <ref> [13] </ref> (although any sufficiently rich type theory will suffice) using the in-clusionary interpretation of subtyping that t 1 t 2 exactly when all members of t 1 are members of t 2 . We then reinterpret subtyping using coercion-existence and make the necessary changes to our construction to maintain constructivity. <p> Thus if e 2 fz : S j P [z]g, then P [e] is true (inhabited), but the inhabitant of P [e] is inaccessible and cannot be used for computation. Additional details are available in Constable [14] and Constable et al. <ref> [13] </ref>. Under our current interpretation of subtyping (t 1 t 2 iff x:x 2 t 1 !t 2 ), the computational content of a subtyping proposition is always the identity function, which, although suppressed by the set type in the power kind definition, can trivially be reconstructed.
Reference: [14] <author> Robert L. Constable. </author> <title> Constructive mathematics as a programming logic I: Some principles of theory. </title> <booktitle> In Topics in the Theory of Computation, volume 24 of Annals of Discrete Mathematics, </booktitle> <pages> pages 21-37. </pages> <publisher> Elsevier, </publisher> <year> 1985. </year> <booktitle> Selected papers of the International Conference on Foundations of Computation Theory 1983. </booktitle>
Reference-contexts: Thus if e 2 fz : S j P [z]g, then P [e] is true (inhabited), but the inhabitant of P [e] is inaccessible and cannot be used for computation. Additional details are available in Constable <ref> [14] </ref> and Constable et al. [13].
Reference: [15] <author> Karl Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year> <month> 7 </month>
Reference-contexts: We formalize the technique by giving a translation of programs from a source calculus into a subsumption-free target calculus. This translation is used in the compiler for the KML programming language <ref> [15] </ref>. We also give a type-theoretic construction that explains the translation as a construction of the source calculus that maintains constructivity while changing the interpretation of subtyping from one based on type inclusion to one based on the existence of semantics-preserving coercions. <p> The type-theoretic construction also gives a framework for working out generalizations to more expressive type systems. In particular, the translation easily generalizes to the dependent record kinds of K [16]. That generalized translation is put to practical use in the KML compiler <ref> [15] </ref>. We also claim, without elaboration, that the construction shows how to generalize the translation to Cardelli's formulation of F ! with monotone kinds [8]. We also hope that the reconciliation of Section 5 can be used to manage complexity in formalized mathematics.
Reference: [16] <author> Karl Crary. </author> <title> A unified framework for modules and ob-jects and its application to programming language design. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest [9], F ! [8, 28] and K <ref> [16] </ref>. Instead of taking a coercion as an extra argument, as in BCGS, polymorphic functions take a higher-order kinding proof. In the second-order case, this kinding proof turns out to be a simple coercion, so the higher-order solution proves to be a generalization of the second-order one. <p> Related work is discussed in Section 6 and brief concluding remarks appear in Section 7. 2 Source and Target Calculi The Source We begin by giving the definition of our source calculus. In the literature, this calculus is closest to Quest [9], F ! [8] and K <ref> [16] </ref>. The syntax rules appear in Figure 1. The source consists of three syntactic classes: kinds, type constructors (often referred to briefly as "constructors") and terms. A fourth syntactic class, contexts, is used to assign meaning to free variables in the typing rules. <p> The type-theoretic construction also gives a framework for working out generalizations to more expressive type systems. In particular, the translation easily generalizes to the dependent record kinds of K <ref> [16] </ref>. That generalized translation is put to practical use in the KML compiler [15]. We also claim, without elaboration, that the construction shows how to generalize the translation to Cardelli's formulation of F ! with monotone kinds [8].
Reference: [17] <author> Karl Crary. </author> <title> Semantic reconciliation of subtyping by inclusion and coercion. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1997. </year> <month> Forthcoming. </month>
Reference-contexts: Since there is insufficient space in this paper to give a mathematically rigorous presentation of this semantics, here we simply outline the most salient points; a formal treatment appears in Crary <ref> [17] </ref>. We begin by supposing that we are given a value-respecting partial equivalence relation (VPER, defined below) semantics built over some evaluation function [21, 1, 2], and that we are given a set of coercions operating on that semantics' primitive types.
Reference: [18] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption. </title> <booktitle> In Fifteenth Colloquium on Trees in Algebra and Programming, volume 431 of Lecture Notes in Computer Science, </booktitle> <pages> pages 132-146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The translation presented in this paper is the generalization of their translation to higher-order subtyping; in particular, the coercions used in BCGS are a special case of the kinding proofs used in this paper. Curien and Ghelli <ref> [18] </ref> developed another technique for showing the syntactic coherence of a similar second-order translation by proof rewriting.
Reference: [19] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandi-navian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year>
Reference-contexts: Since constructors appear within kinds, not all kinds are well-formed, so some judgement must specify well-formedness of kinds; reflexive subkinding judgements serve this purpose. The Target The target calculus is essentially Girard's F ! <ref> [19, 20] </ref>, augmented with a few additional constructs. The syntax rules appear in Figure 2. There are just a few differences between the source and target calculi, all stemming from the absence of subtyping: At the kind level the kind Type is now primitive, replacing the power kind.
Reference: [20] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Since constructors appear within kinds, not all kinds are well-formed, so some judgement must specify well-formedness of kinds; reflexive subkinding judgements serve this purpose. The Target The target calculus is essentially Girard's F ! <ref> [19, 20] </ref>, augmented with a few additional constructs. The syntax rules appear in Figure 2. There are just a few differences between the source and target calculi, all stemming from the absence of subtyping: At the kind level the kind Type is now primitive, replacing the power kind.
Reference: [21] <author> Robert Harper. </author> <title> Constructing type systems over an operational semantics. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 71-84, </pages> <year> 1992. </year>
Reference-contexts: We begin by supposing that we are given a value-respecting partial equivalence relation (VPER, defined below) semantics built over some evaluation function <ref> [21, 1, 2] </ref>, and that we are given a set of coercions operating on that semantics' primitive types. We will then build a new VPER semantics that incorporates those coercions. A partial equivalence relation (PER) is a symmetric and transitive relation.
Reference: [22] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: result of the translation. 5 Reconciling Inclusion and Coercion Existence To this point it may appear that the two interpretations of subtyping, inclusion and coercion-existence, are disparate 3 In fact, an examination of the type ff:: '(ff; ) and the type [[]] reveals that the former is essentially a phase-split <ref> [22] </ref> version of the latter. ones. In this section we show that this need not be so, by giving a common semantics for the two interpretations.
Reference: [23] <author> Mark P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Also closely related to this work is the work of Jones on qualified types <ref> [24, 23] </ref>, which are types required to obey some predicate. These predicates are used to implement type classes in the Gofer programming language [26]. As here, Jones implements qualified types using a translation motivated by the propositions-as-types principle. <p> As here, Jones implements qualified types using a translation motivated by the propositions-as-types principle. This translation passes evidence terms analogous to the kinding proofs of this paper. Jones shows also that the translation is coherent whenever terms have unique minimal types <ref> [23, 25] </ref>. Early work in this area was done by Reynolds [29], who used category theory to develop a framework for defining semantics for and showing the coherence of calculi with subtyping and overloaded operators.
Reference: [24] <author> Mark P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In Fourth European Symposium on Programming, volume 582 of Lecture Notes in Computer Science, Rennes, </booktitle> <address> France, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Also closely related to this work is the work of Jones on qualified types <ref> [24, 23] </ref>, which are types required to obey some predicate. These predicates are used to implement type classes in the Gofer programming language [26]. As here, Jones implements qualified types using a translation motivated by the propositions-as-types principle.
Reference: [25] <author> Mark P. Jones. </author> <title> Coherence for qualified types. </title> <institution> Research Report YALEU/DCS/RR-989, Yale University, Department of Computer Science, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: As here, Jones implements qualified types using a translation motivated by the propositions-as-types principle. This translation passes evidence terms analogous to the kinding proofs of this paper. Jones shows also that the translation is coherent whenever terms have unique minimal types <ref> [23, 25] </ref>. Early work in this area was done by Reynolds [29], who used category theory to develop a framework for defining semantics for and showing the coherence of calculi with subtyping and overloaded operators.
Reference: [26] <author> Mark P. Jones. </author> <title> The implementation of the Gofer functional programming system. </title> <institution> Research Report YALEU/DCS/RR-1030, Yale University, Department of Computer Science, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Also closely related to this work is the work of Jones on qualified types [24, 23], which are types required to obey some predicate. These predicates are used to implement type classes in the Gofer programming language <ref> [26] </ref>. As here, Jones implements qualified types using a translation motivated by the propositions-as-types principle. This translation passes evidence terms analogous to the kinding proofs of this paper. Jones shows also that the translation is coherent whenever terms have unique minimal types [23, 25].
Reference: [27] <author> Paul Francis Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: The techniques of Mendler <ref> [27] </ref> could extend this construction to impredicative types, but the extension is omitted here for the sake of simplicity, since this detail does not affect our purposes in any significant way. 2 We leave open the definition of semantics-preserving functions, although any proper definition would include the identity functions.
Reference: [28] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order sub-typing. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1997. </year> <note> To appear. Available as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94. </note>
Reference-contexts: The basic idea is for bounded polymorphic functions to take the necessary coercion as an additional argument. In this paper we show how to extend this technique to languages with higher-order type constructors and a subkinding relation, such as Quest [9], F ! <ref> [8, 28] </ref> and K [16]. Instead of taking a coercion as an extra argument, as in BCGS, polymorphic functions take a higher-order kinding proof.
Reference: [29] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. In Semantics-Directed Compiler Generation, </title> <booktitle> volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: This is easily shown from the fact that our coercion set forms a forest. If our coercion set were permitted to form a DAG then it would be necessary to require that our primitive coercions be coherent among themselves <ref> [29] </ref>. 5.1 Coherence Since the translation of a term depends upon the derivation of its typing judgement, it is possible for a term to have many different possible translations. <p> This translation passes evidence terms analogous to the kinding proofs of this paper. Jones shows also that the translation is coherent whenever terms have unique minimal types [23, 25]. Early work in this area was done by Reynolds <ref> [29] </ref>, who used category theory to develop a framework for defining semantics for and showing the coherence of calculi with subtyping and overloaded operators.
Reference: [30] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <booktitle> In Theoretical Aspects of Computer Software 1991, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: More recently, the semantics for the programming language Forsythe [31] interpreted intersection types as a category-theoretic pullback, a non-syntax-directed definition; this was proven coherent in Reynolds <ref> [30] </ref>. 7 Summary and Conclusions We have given a translation of a higher-order subtyping calculus into subsumption-free calculus suitable for implementation by conventional means. Such a translation is necessitated by changing the interpretation of subtyping from inclusion (the programmer's model) to coercion-existence (the machine's model).
Reference: [31] <author> John C. Reynolds. </author> <title> Design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-94-146, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Early work in this area was done by Reynolds [29], who used category theory to develop a framework for defining semantics for and showing the coherence of calculi with subtyping and overloaded operators. More recently, the semantics for the programming language Forsythe <ref> [31] </ref> interpreted intersection types as a category-theoretic pullback, a non-syntax-directed definition; this was proven coherent in Reynolds [30]. 7 Summary and Conclusions We have given a translation of a higher-order subtyping calculus into subsumption-free calculus suitable for implementation by conventional means.
References-found: 31

