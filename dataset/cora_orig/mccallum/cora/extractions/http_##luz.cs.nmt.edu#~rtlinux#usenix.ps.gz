URL: http://luz.cs.nmt.edu/~rtlinux/usenix.ps.gz
Refering-URL: http://luz.cs.nmt.edu/~rtlinux/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Real-Time Linux  
Author: Victor Yodaiken and Michael Barabanov 
Address: 1  
Affiliation: New Mexico Institute of Technology  
Abstract: The paper describes the design, implementation, experimental results, and possible applications of a real-time version of the Linux operating system. We have used the idea of virtual machines for running a standard time-sharing OS and a real-time executive on the same computer. Services provided by the real-time kernel are described. The comparison of our solution with other work on real-time UNIXes is also presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Borko Furht et al. </editor> <title> Real-time UNIX systems: design and application guide. </title> <publisher> Kluwer Academic Publishers Group, Norwell, </publisher> <address> MA, USA, </address> <year> 1991. </year>
Reference-contexts: Individual disabling/enabling of interrupts is handled similarly. 7 5 Conclusion Our approach to building a real-time operating system can be contrasted two two more well-known methods. One method is add real-time support to a general purpose operating system. The Real-Time Unix of <ref> [1] </ref> is a good example of this approach and illustrates the effort needed to make a Unix kernel fully preemptive. Other examples include VAX VMS [?], the POSIX 1.b standard (and the similar work in [15]) and the Maruti real-time OS [7].
Reference: [2] <author> Bill O. Gallmeister. </author> <title> POSIX.4 Programming for the Real World. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1995. </year>
Reference-contexts: These problems are compounded in Linux and most other UNIX derivatives, because kernel mode execution is non-preemptable [6] and because disabling interrupts is used as the primary means of synchronization. By locking process pages into memory and requiring use of a round-robin scheduler as in the POSIX.1b standard <ref> [2] </ref> one can gain a certain degree of predictability, but still not meet the requirements of even moderately demanding hard real-time systems [14]. Low interrupt handling latency is critical for any real-time operating system. But interrupt latency is high in in Linux.
Reference: [3] <author> P. M. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Currently, interrupts are disabled when a RT-FIFO is accessed. Since data are transmitted in small chunks, this does not compromise a low response time. Other approaches, notably using lock-free data structures <ref> [3] </ref>, [9] are also possible and are being considered. The following are the system calls related to RT-FIFOs. * int RTfifo_create (unsigned int fifo, int size) creates a RT-FIFO "FIFO" of size "SIZE" bytes. FIFOs' numbers are global; FIFOs are numbered from 0 to RT_MAX_FIFO-1.
Reference: [4] <author> Dan Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 113-126, </pages> <address> Seattle, WA, </address> <month> April 27-28 </month> <year> 1992. </year> <booktitle> USENIX. </booktitle> <pages> 8 </pages>
Reference-contexts: The second approach is to design an operating system specifically to support real-time. VX-Works [16] is a particularly successful example of such a system. Other examples include the QNX microkernel <ref> [4] </ref> and OS9 [11]. We have chosen a third path. Real-time POSIX standards alone are not "hard" enough for our purposes. To make Linux fully pre-emptable was too time consuming and would cut us off from the mainstream of Linux development.
Reference: [5] <author> Intel Corporation. </author> <title> Pentium Processor Family Developer's Manual. Order Number 241430-004. </title>
Reference-contexts: Our next system will sacrifice some of this safety for speed and the convenience of using Linux modules to allow dynamic loading and replacement of real-time tasks and the real-time scheduler. 4 The Virtual Machine The RT-executive has been implemented on the x86/PC architecture <ref> [5] </ref> [10]. 4.1 Interrupt handling Modifications to the Linux kernel are primarily in three places: 5 * The cli routine to disable interrupts is modified to simply clear a global variable controlling soft interrupt enable. * The sti routine to enable interrupts is modified to generate emulated interrupts for any pending
Reference: [6] <author> Samuel J. Le*er, Marshall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <address> Addison-Wes-ley, Reading, MA, USA, </address> <year> 1989. </year>
Reference-contexts: As a result the execution of any process depends in a complex and unpredictable fashion on system load and the behavior of other processes. These problems are compounded in Linux and most other UNIX derivatives, because kernel mode execution is non-preemptable <ref> [6] </ref> and because disabling interrupts is used as the primary means of synchronization.
Reference: [7] <author> S.-T. Levi, S. K. Tripathi, S. D. Carson, and A. K. Agrawala. </author> <title> The MARUTI hard real-time operating system. </title> <journal> ACM Operating Systems Review, SIGOPS, </journal> <volume> 23(3) </volume> <pages> 90-105, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The Real-Time Unix of [1] is a good example of this approach and illustrates the effort needed to make a Unix kernel fully preemptive. Other examples include VAX VMS [?], the POSIX 1.b standard (and the similar work in [15]) and the Maruti real-time OS <ref> [7] </ref>. The second approach is to design an operating system specifically to support real-time. VX-Works [16] is a particularly successful example of such a system. Other examples include the QNX microkernel [4] and OS9 [11]. We have chosen a third path.
Reference: [8] <author> H. Lycklama and D. L. Bayer. </author> <title> Unix time-sharing system: The MERT operating system. </title> <journal> Bell System Technical Journal, </journal> <volume> 57(6) </volume> <pages> 2049-2086, </pages> <year> 1978. </year>
Reference-contexts: Linux is then able to provide sophisticated services to the real-time system without increasing interrupt latency. A virtual machine layer has been advanced as a technique for making UNIX real-time as far back as 1978 <ref> [8] </ref>, but our use of the technique differs from previous efforts in both scope and purpose. Our virtual machine "layer" emulates only a specific hardware component | interrupt control.
Reference: [9] <author> Henry Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Currently, interrupts are disabled when a RT-FIFO is accessed. Since data are transmitted in small chunks, this does not compromise a low response time. Other approaches, notably using lock-free data structures [3], <ref> [9] </ref> are also possible and are being considered. The following are the system calls related to RT-FIFOs. * int RTfifo_create (unsigned int fifo, int size) creates a RT-FIFO "FIFO" of size "SIZE" bytes. FIFOs' numbers are global; FIFOs are numbered from 0 to RT_MAX_FIFO-1.
Reference: [10] <author> Muhammad Ali Mazidi and Janice Gillespie Mazidi. </author> <title> Design and Interfacing of the IBM PC, PS, and Compatibles. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: Our next system will sacrifice some of this safety for speed and the convenience of using Linux modules to allow dynamic loading and replacement of real-time tasks and the real-time scheduler. 4 The Virtual Machine The RT-executive has been implemented on the x86/PC architecture [5] <ref> [10] </ref>. 4.1 Interrupt handling Modifications to the Linux kernel are primarily in three places: 5 * The cli routine to disable interrupts is modified to simply clear a global variable controlling soft interrupt enable. * The sti routine to enable interrupts is modified to generate emulated interrupts for any pending soft
Reference: [11] <institution> OS9 Real-Time Operating System. </institution> <note> http://www.gespac.com/html/os9 arch diagram.html. </note>
Reference-contexts: The second approach is to design an operating system specifically to support real-time. VX-Works [16] is a particularly successful example of such a system. Other examples include the QNX microkernel [4] and OS9 <ref> [11] </ref>. We have chosen a third path. Real-time POSIX standards alone are not "hard" enough for our purposes. To make Linux fully pre-emptable was too time consuming and would cut us off from the mainstream of Linux development.
Reference: [12] <author> L. H. Seawright and Mackinnon R. A. </author> <title> VM/370 | A Study of Multiplicity and Usefulness. </title> <journal> IBM Systems Journal, </journal> <volume> 18 </volume> <pages> 4-17, </pages> <year> 1978. </year>
Reference-contexts: We have attacked this problem of apparently contradictory requirements using a simple version of the well known "virtual machine" technique <ref> [12] </ref>. Linux interacts with a software emulation of the interrupt control hardware. The emulation supports the synchronization requirements of the Linux kernel while preventing Linux from disabling interrupts. Interrupts that are handled by Linux are passed through to the emulation software after any needed real-time processing completes.
Reference: [13] <author> Sang H. Son, </author> <title> editor. </title> <booktitle> Advances In Real-Time Systems, chapter 10, </booktitle> <pages> pages 225-248. </pages> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1984. </year>
Reference-contexts: Tasks give up the processor voluntarily, or are preempted by a higher-priority task when its time to execute comes. Typically there is a tradeoff between the clock interrupt rate and the task release jitter <ref> [13] </ref>. In most systems tasks are resumed in the periodic clock interrupt handler. High clock interrupt rate ensures low jitter, but at the same time incurs much overhead. Low interrupt rate causes tasks to be resumed either too early or too late.
Reference: [14] <author> J. A. Stankovic. </author> <title> Misconceptions about real-time computing A serious problem for next-generation systems. </title> <journal> IEEE Computer, </journal> <volume> 21(10) </volume> <pages> 10-19, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: By locking process pages into memory and requiring use of a round-robin scheduler as in the POSIX.1b standard [2] one can gain a certain degree of predictability, but still not meet the requirements of even moderately demanding hard real-time systems <ref> [14] </ref>. Low interrupt handling latency is critical for any real-time operating system. But interrupt latency is high in in Linux. On a 120MHz Pentium based PC, we measure up to 400 sec latency in handling of "fast" Linux interrupts.
Reference: [15] <author> Gabriel A. </author> <title> Wainer. Implementing Real-Time services in MINIX. </title> <journal> Operating Systems Review, </journal> <volume> 29(3) </volume> <pages> 75-84, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: The Real-Time Unix of [1] is a good example of this approach and illustrates the effort needed to make a Unix kernel fully preemptive. Other examples include VAX VMS [?], the POSIX 1.b standard (and the similar work in <ref> [15] </ref>) and the Maruti real-time OS [7]. The second approach is to design an operating system specifically to support real-time. VX-Works [16] is a particularly successful example of such a system. Other examples include the QNX microkernel [4] and OS9 [11]. We have chosen a third path.
Reference: [16] <institution> Wind River Systems, Inc., </institution> <address> 1010 Atlantic Avenue, Alameda, CA 94501-1147, USA. VxWorks Programmer's Guide 5.1, </address> <month> December </month> <year> 1993. </year> <month> 9 </month>
Reference-contexts: Other examples include VAX VMS [?], the POSIX 1.b standard (and the similar work in [15]) and the Maruti real-time OS [7]. The second approach is to design an operating system specifically to support real-time. VX-Works <ref> [16] </ref> is a particularly successful example of such a system. Other examples include the QNX microkernel [4] and OS9 [11]. We have chosen a third path. Real-time POSIX standards alone are not "hard" enough for our purposes.
References-found: 16

