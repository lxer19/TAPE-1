URL: ftp://mancos.cs.utah.edu/papers/presint2.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/presint2.html
Root-URL: 
Title: Separating Presentation from Interface in RPC and IDLs  
Author: Bryan Ford Mike Hibler Jay Lepreau 
Affiliation: University of Utah  
Abstract: In RPC-based communication, we term the interface the set of remote procedures and the types of their arguments; the presentation is the way these procedures and types are mapped to the target language environment in a particular client or server, including semantic requirements. For example, presentation includes the local names assigned to RPC stubs, the physical representation of a logical block of data (e.g., in-line, out-of-line, linked blocks), and trust requirements (e.g., integrity, security). In existing systems, the presentation of a given RPC construct is largely fixed. Separating presentation from interface, both in the interface definition language (IDL) itself and in the RPC implementation, is the key to interoperability, with many benefits in the area of elegance, as well. This separation and resulting cleanliness makes it manageable to generate specialized kernel code paths for each type of client-server pair. This is a key element of end-to-end optimization. The separation should also allow the integration of disparate RPC optimization techniques, such as those applied in LRPC[2] and fbufs[6], into a single system, in a uniform and fully interoperable way. In initial work we demonstrate a variant of threaded code generation and two presentation-based optimizations, transparently activated by the RPC system. Each of these optimizations speeds up local RPC by approximately 25%. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. S. Auerbach and J. R. Russell. </author> <title> The Concert signature representation: IDL as an intermediate language. </title> <booktitle> In Proc. of the Workshop on Interface Definition Languages, </booktitle> <pages> pages 1-12, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: We know of two IDLs in which the notion of separate presentation exists to some degree. DCE IDL's Application Configuration File allows specification, separate from the interface definition file, of a few attributes such as binding protocol, error condition treatment, and data type equivalence. The Concert system's <ref> [1] </ref> endpoint modifier supports more presentation attributes. Since Concert does not have a separate IDL, the endpoint modifier is automatically generated by each language's compiler and only handles the vagaries of the language mapping.
Reference: [2] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: of an RPC interface only see the base type, DataBlock (or their own independent presentations of that base type). 4 Presentation and Interface in RPC Imple mentation Many powerful techniques for optimizing IPC have been demonstrated, such as data transfer with page remapping [4, 15], copy-on-write, pairwise shared memory buffers <ref> [2] </ref>, and memory buffers group-wise shared across full data paths, leveraging weakened semantics when possible [6]. These techniques impose various restrictions on the situations in which they can be used and on the way the client and server code must be written.
Reference: [3] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Also, in some sense we are separating implementation from interface, where the implementation is our presentation of the interface. However, our initial exploration of the deeper language issues shows that the issue is complex, as Cardelli <ref> [3] </ref> discusses, and is worthy of a research effort in its own right. Clark et al [5] emphasize the importance of optimizing the presentation layer in traditional networking, showing that it can dominate processing time.
Reference: [4] <author> D. R. Cheriton. </author> <title> The V distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: them, but programs on the other end of an RPC interface only see the base type, DataBlock (or their own independent presentations of that base type). 4 Presentation and Interface in RPC Imple mentation Many powerful techniques for optimizing IPC have been demonstrated, such as data transfer with page remapping <ref> [4, 15] </ref>, copy-on-write, pairwise shared memory buffers [2], and memory buffers group-wise shared across full data paths, leveraging weakened semantics when possible [6]. These techniques impose various restrictions on the situations in which they can be used and on the way the client and server code must be written.
Reference: [5] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceedings of the SIGCOMM '90 Symposium, </booktitle> <pages> pages 200-208, </pages> <year> 1990. </year>
Reference-contexts: However, our initial exploration of the deeper language issues shows that the issue is complex, as Cardelli [3] discusses, and is worthy of a research effort in its own right. Clark et al <ref> [5] </ref> emphasize the importance of optimizing the presentation layer in traditional networking, showing that it can dominate processing time. They also emphasize that for performance reasons, the necessity of non-contiguous data location in the recipient is a critical architectural constraint.
Reference: [6] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 189-202, </pages> <year> 1993. </year>
Reference-contexts: of that base type). 4 Presentation and Interface in RPC Imple mentation Many powerful techniques for optimizing IPC have been demonstrated, such as data transfer with page remapping [4, 15], copy-on-write, pairwise shared memory buffers [2], and memory buffers group-wise shared across full data paths, leveraging weakened semantics when possible <ref> [6] </ref>. These techniques impose various restrictions on the situations in which they can be used and on the way the client and server code must be written. They give up generality in return for better performance in specific common cases.
Reference: [7] <author> B. Ford and J. Lepreau. </author> <title> Evolving Mach 3.0 to a migrating thread model. </title> <booktitle> In Proc. of the Winter 1994 USENIX Conference, </booktitle> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Presentation Support to an IDL To demonstrate the benefits of fully supporting separate specification of presentation and interface, we are creating a new Mach RPC system, based on the CORBA IDL [13], Sun's freely-available IDL compiler, our own IDL compiler back-end, and an extension of our migrating threads RPC mechanism <ref> [7] </ref>. An interface specification is generally intended to be independent of the languages used to write its client programs. However, presentation specification is fundamentally language-specific, because it defines the interaction between client or server code and the IPC system (RPC stubs). <p> Basic threaded code performance: Null local RPC now takes 4.6 secs, and passing one 32-byte in parameter takes 5.9 secs. This null RPC is now nine times as fast as traditional Mach RPC and more than twice as fast as our migrating threads implementation <ref> [7] </ref> which relied on the traditional Mach message format, RPC is now twice as fast as system calls on native monolithic operating systems (BSD, HP-UX). This is because the latter are not, in general, specialized, but must set up exception handlers and other rarely used functions. <p> This is because the latter are not, in general, specialized, but must set up exception handlers and other rarely used functions. This excellent base performance was achieved through a range of optimization techniques (passing parameters in 4 registers, migrating threads, avoiding register state saving and restoring) <ref> [12, 8, 7] </ref>, as well as specialized code. With full knowledge of both client and server presentation, up into user code, more optimizations are possible on non-null RPCs.
Reference: [8] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: a microkernel for objects. </title> <booktitle> In Proc. of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <address> Cincin-nati, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This is because the latter are not, in general, specialized, but must set up exception handlers and other rarely used functions. This excellent base performance was achieved through a range of optimization techniques (passing parameters in 4 registers, migrating threads, avoiding register state saving and restoring) <ref> [12, 8, 7] </ref>, as well as specialized code. With full knowledge of both client and server presentation, up into user code, more optimizations are possible on non-null RPCs.
Reference: [9] <author> G. Hamilton, M. L. Powell, and J. J. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: However, with the growth of client-server computing and large object-oriented distributed systems, RPC interfaces have changed from a programming convenience to abstractions useful in themselves to promote software modularity and interoperability. Entire software systems, such as Spring <ref> [9] </ref>, are designed and built in terms of the RPC interfaces between their components. <p> The Concert system's [1] endpoint modifier supports more presentation attributes. Since Concert does not have a separate IDL, the endpoint modifier is automatically generated by each language's compiler and only handles the vagaries of the language mapping. The Subcontract work <ref> [9] </ref>, an elegant and general method for extending and specializing object communication mechanisms and semantics, is largely complementary to our work. Their Spring system has separate stub, subcontract, and kernel levels, with the language-level stubs and kernel IPC mechanism remaining entirely generic, and all specialization restricted to the subcontract layer.
Reference: [10] <author> M. Jones, R. Rashid, and M. Thompson. Matchmaker: </author> <title> An interface specification language for distributed processing. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1985. </year>
Reference: [11] <author> P. Klint. </author> <title> Interpretation techniques. </title> <journal> Software Practice and Experience, </journal> <volume> 11(9) </volume> <pages> 963-973, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Thus, the kernel only has to compare registered type signatures once; successive uses of a particular RPC path require no expensive computation. In fact, the combination signature include a block which threads <ref> [11] </ref> together small blocks of code which perform key parts of the RPC, such as register saving and restoring.
Reference: [12] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This is because the latter are not, in general, specialized, but must set up exception handlers and other rarely used functions. This excellent base performance was achieved through a range of optimization techniques (passing parameters in 4 registers, migrating threads, avoiding register state saving and restoring) <ref> [12, 8, 7] </ref>, as well as specialized code. With full knowledge of both client and server presentation, up into user code, more optimizations are possible on non-null RPCs.
Reference: [13] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and specification. </title> <note> Draft 10 Rev 1.1 Doc # 91.12.1, OMG, </note> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: These awkward mechanisms are nevertheless used extensively, demonstrating the inherent need to control presentation separately from interface. 3.1 Adding Presentation Support to an IDL To demonstrate the benefits of fully supporting separate specification of presentation and interface, we are creating a new Mach RPC system, based on the CORBA IDL <ref> [13] </ref>, Sun's freely-available IDL compiler, our own IDL compiler back-end, and an extension of our migrating threads RPC mechanism [7]. An interface specification is generally intended to be independent of the languages used to write its client programs.
Reference: [14] <author> J. Saltzer, D.P.Reed, and D.D.Clark. </author> <title> End to end arguments in system design. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> Nov. </month> <year> 1984. </year>
Reference-contexts: This can occur not only in RPC, where each parameter is scattered in memory, but in integrated-layer processing of stream-based protocols, due to dropped packets. Their emphasis is on the latter, ours the former. Our optimization effort applies the end-to-end argument <ref> [14] </ref>, which emphasizes the importance, in a multitude of domains, of considering the total path in design and implementation. Operating system interfaces are replete with special calls whose only purpose is to accommodate slight variance in presentation.
Reference: [15] <author> S.-Y. Tzou and D. Anderson. </author> <title> The performance of message passing using restricted virtual memory mapping. </title> <journal> Software Practice and Experience, </journal> <volume> 21(3) </volume> <pages> 251-267, </pages> <month> Mar. </month> <year> 1991. </year> <month> 5 </month>
Reference-contexts: them, but programs on the other end of an RPC interface only see the base type, DataBlock (or their own independent presentations of that base type). 4 Presentation and Interface in RPC Imple mentation Many powerful techniques for optimizing IPC have been demonstrated, such as data transfer with page remapping <ref> [4, 15] </ref>, copy-on-write, pairwise shared memory buffers [2], and memory buffers group-wise shared across full data paths, leveraging weakened semantics when possible [6]. These techniques impose various restrictions on the situations in which they can be used and on the way the client and server code must be written.
References-found: 15

