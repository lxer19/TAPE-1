URL: ftp://ftp.cs.arizona.edu/reports/1995/TR95-10.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: One-Pass, Optimal Tree Parsing With Or Without Trees  
Author: Todd A. Proebsting Benjamin R. Whaley 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Note: September  
Date: TR 95-10  22, 1995  
Abstract: This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. Furthermore, wburg eliminates the need for an explicit IR tree altogether. The generated parser emits optimal code, and can do so without retaining an entire IR tree during its single pass. The grammars that wburg-generated parsers can parse are a proper subset of those that the two-pass systems can handle. However, analysis indicates that wburg can optimally handle grammars for most major instruction sets, including the SPARC, the MIPS R3000, and the x86. 
Abstract-found: 1
Intro-found: 1
Reference: [AGT89] <author> Alfred V. Aho, Mahedevan Ganapathi, and Steven W. K. Tjiang. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The code-generator generator consumes a cost-augmented tree grammar with associated semantic actions. The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG [ESL89], twig <ref> [AGT89] </ref>, burg [FHP92b, Pro92], iburg [FHP92a], and lburg [FH95]. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> The various code-generator generators differ in the pattern-matching technology they use, and in when they perform dynamic programming. Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down <ref> [AGT89] </ref>, to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time <ref> [ESL89, AGT89, FHP92a, FH95] </ref>; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88].
Reference: [BDB90] <author> A. Balachandran, D. M. Dhamdhere, and S. Biswas. </author> <title> Efficient retargetable code generation using bottom-up tree pattern matching. </title> <journal> Computer Languages, </journal> <volume> 15(3) </volume> <pages> 127-140, </pages> <year> 1990. </year>
Reference-contexts: Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. Previous tree-pattern matching systems required two passes over the IR tree: one for labeling the tree with dynamic programming information, and another for selecting the least-cost parse based on that information. To enable two tree walks, this design requires allocating and building an explicit IR tree. <p> A chain rule has only a single nonterminal on its right-hand side, while a base rule always has a terminal on its right-hand side. In Figure 1, rules 3 and 5 are the only chain rules. We restrict our analysis to grammars in normal form <ref> [BDB90] </ref>. A grammar is in normal form if all patterns are either chain rules, or base rules of the form n 0 ! op (n 1 ; : : : ; n k ) where n i are all nonterminals and op is an operator.
Reference: [ESL89] <author> Helmut Emmelmann, Friedrich-Wilhelm Schroer, and Rudolf Landwehr. </author> <title> BEG|a generator for efficient back ends. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 227-237, </pages> <address> New York, 1989. </address> <publisher> ACM. </publisher>
Reference-contexts: The code-generator generator consumes a cost-augmented tree grammar with associated semantic actions. The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG <ref> [ESL89] </ref>, twig [AGT89], burg [FHP92b, Pro92], iburg [FHP92a], and lburg [FH95]. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> The various code-generator generators differ in the pattern-matching technology they use, and in when they perform dynamic programming. Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive <ref> [ESL89, FHP92a, FH95] </ref>, to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time <ref> [ESL89, AGT89, FHP92a, FH95] </ref>; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88].
Reference: [FH95] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1995. </year>
Reference-contexts: The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG [ESL89], twig [AGT89], burg [FHP92b, Pro92], iburg [FHP92a], and lburg <ref> [FH95] </ref>. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> The various code-generator generators differ in the pattern-matching technology they use, and in when they perform dynamic programming. Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive <ref> [ESL89, FHP92a, FH95] </ref>, to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time <ref> [ESL89, AGT89, FHP92a, FH95] </ref>; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> Tests utilized modified versions of lcc grammars for the SPARC and the x86 <ref> [FH95] </ref>. The tests consisted of labeling and reducing the 1,234 unique trees lcc generates when it compiles itself. Each test parsed a set of 1,234 trees (a total of 11,587 nodes) 500 times. The tests were performed on lightly loaded DEC Alpha and Sun SPARCstation workstations.
Reference: [FHP92a] <author> Christopher W. Fraser, David R. Hanson, and Todd A. Proebsting. </author> <title> Engineering a simple, efficient code-generator generator. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 213-226, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG [ESL89], twig [AGT89], burg [FHP92b, Pro92], iburg <ref> [FHP92a] </ref>, and lburg [FH95]. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> The various code-generator generators differ in the pattern-matching technology they use, and in when they perform dynamic programming. Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive <ref> [ESL89, FHP92a, FH95] </ref>, to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88]. Most systems perform dynamic programming at compile-time <ref> [ESL89, AGT89, FHP92a, FH95] </ref>; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88].
Reference: [FHP92b] <author> Christopher W. Fraser, Robert R. Henry, and Todd A. Proebsting. </author> <title> BURG | fast optimal instruction selection and tree parsing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(4) </volume> <pages> 68-76, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: The code-generator generator consumes a cost-augmented tree grammar with associated semantic actions. The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG [ESL89], twig [AGT89], burg <ref> [FHP92b, Pro92] </ref>, iburg [FHP92a], and lburg [FH95]. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. Previous tree-pattern matching systems required two passes over the IR tree: one for labeling the tree with dynamic programming information, and another for selecting the least-cost parse based on that information. To enable two tree walks, this design requires allocating and building an explicit IR tree. <p> code generator, however, does not generate optimal code for all expressions, and is not automatically generated. 3 burg Automata burg is a code-generator generator that accepts a cost-augmented tree grammar as input and automatically produces a tree-parser that gives an optimal parse of an IR tree using a two-pass algorithm <ref> [FHP92b] </ref>. burg does all dynamic programming at compile-compile time and creates a state machine for guiding all subsequent pattern matching and instruction selection decisions. Rules in a burg grammar have the form nonterminal : rule = rule number (cost); Consider the burg grammar, G, in Figure 1.
Reference: [HO82] <author> Christoph M. Hoffmann and Michael J. O'Donnell. </author> <title> Pattern matching in trees. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: The resulting code generator uses tree pattern matching and dynamic programming to find least-cost instruction sequences for realizing the given IR tree's computations. The various code-generator generators differ in the pattern-matching technology they use, and in when they perform dynamic programming. Pattern-matching techniques vary widely in theoretical efficiency <ref> [HO82] </ref>. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up [FHP92b, Pro92, BDB90, PLG88].
Reference: [PLG88] <author> Eduardo Pelegri-Llopart and Susan L. Graham. </author> <title> Optimal code generation for expression trees: An application of BURS theory. </title> <booktitle> In Proceedings of the 15th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 294-308, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. Previous tree-pattern matching systems required two passes over the IR tree: one for labeling the tree with dynamic programming information, and another for selecting the least-cost parse based on that information. To enable two tree walks, this design requires allocating and building an explicit IR tree.
Reference: [Pro92] <author> Todd A. Proebsting. </author> <title> Simple and efficient BURS table generation. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 331-340, </pages> <address> New York, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: The code-generator generator consumes a cost-augmented tree grammar with associated semantic actions. The resulting code generator requires two passes over the IR tree to determine a least-cost parse and to execute the associated semantic actions. Code-generator generators based on this model include BEG [ESL89], twig [AGT89], burg <ref> [FHP92b, Pro92] </ref>, iburg [FHP92a], and lburg [FH95]. This paper describes the theory behind and implementation of wburg, a code-generator generator that accepts tree grammars as input and produces a code generator that emits an optimal parse of an IR tree in just a single bottom-up pass. <p> Pattern-matching techniques vary widely in theoretical efficiency [HO82]. Previous code generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. <p> generators have employed many of these pattern-matching technologies, ranging from the slowest, naive [ESL89, FHP92a, FH95], to top-down [AGT89], to the fastest, bottom-up <ref> [FHP92b, Pro92, BDB90, PLG88] </ref>. Most systems perform dynamic programming at compile-time [ESL89, AGT89, FHP92a, FH95]; those based on BURS technology do all dynamic programming at compile-compile time [FHP92b, Pro92, BDB90, PLG88]. Previous tree-pattern matching systems required two passes over the IR tree: one for labeling the tree with dynamic programming information, and another for selecting the least-cost parse based on that information. To enable two tree walks, this design requires allocating and building an explicit IR tree.
Reference: [WG92] <author> N. Wirth and J. Gutknecht. </author> <title> Project Oberon, the Design of an Operating System and Computer. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The Oberon compiler's code generator works in a single pass without the benefit of an explicit IR tree <ref> [WG92] </ref>.
References-found: 10

