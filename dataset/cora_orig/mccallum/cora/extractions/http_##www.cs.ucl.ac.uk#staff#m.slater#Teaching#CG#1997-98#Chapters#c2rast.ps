URL: http://www.cs.ucl.ac.uk/staff/m.slater/Teaching/CG/1997-98/Chapters/c2rast.ps
Refering-URL: http://www.cs.ucl.ac.uk/staff/m.slater/Teaching/CG/1997-98/Chapters/
Root-URL: http://www.cs.ucl.ac.uk
Title: Computer Graphics and Virtual Environments Chapter 2 Raster Displays and Algorithms  
Date: October, 1996,  
Note: M. Slater,  2.1 Introduction  
Abstract: At the root of any modern computer graphics system is a set of processes that convert geometric primitives (such as lines and polygons) into a form suitable for display on graphics hardware. These processes are known as rasterisation following the form into which the primitives must be converted. The most common form of graphics display hardware today is known as a raster display . This name comes from the raster scan technology commonly employed on TV displays. In this chapter we outline a simple abstraction of a raster display device, and then discuss the problem of rasterisation or scan conversion - that is how the geometric primitives used in computer graphics are prepared for display. This chapter presents what might be called the central algorithm of computer graphics - that is, how to shade the interior of a closed polygon . This algorithm is central because it lies at the heart of the graphics rendering pipeline , that is, at the heart of the process that converts high level descriptions of a 3D virtual environment into the lowest level form suitable for raster displays. Surprisingly, although this algorithm is specified for a polygon described in a 2D space, it is used to solve what would otherwise be very complex issues in 3D computer graphics - the problem of visibility (how to determine those parts of a scene, and only those parts visible from a viewpoint), and how to shade objects to give an impression of smoothness (even though in fact those objects are faceted, that is composed of many polygons joined edge to edge). Another important part of this chapter is that it introduces a notion that is also central to computer graphics thinking: coherence . Algorithm efficiency is often achieved with the use of this idea, that is, whenever possible use the results of the current computation to reduce to a minimum the next computation, rather than computing the next computation from scratch. There are two types of coherence that occur in computer graphics. Spatial coherence exploits the fact that one region of a geometric entity is much like its neighbouring regions. As a very simple example, suppose we are given a point (X,Y) on a line with equation y = a + bx. Then given the value of y at X, Y = a+bX to find the value of y at X+1 we could, of course, compute a + b*(X+1). However, it is more efficient to exploit the coherence in y values for successive x values of course, a unit increment in x increases y by the slope of the line, in this case b. Hence the value of y at X+1 is Y+b. In general, any computation performed over one region can usually be used to efficiently compute a similar result for its immediate neighbour. The second kind of coherence is temporal: when a sequence of images is being displayed, it is often the case that certain properties of the process that produced the images, or indeed of the image itself can be exploited for efficiency. For example, suppose that the scene is produced as a result of a particular viewpoint onto a 3D scene. If the viewpoint changes slightly, it is likely that from the new position of the eye much the same visibility relationships will be maintained as in the previous viewpoint (in other words, if previously object A partially obscured B, then it is likely that this will occur again). This kind of observation can be used to create very efficient 3D visibility algorithms. Regarding the image itself, it is often the case that between one frame in the sequence (for example, an animation sequence) and the next, that large regions of the image will remain unchanged. An approach that tries to identify only those parts of the image 
Abstract-found: 1
Intro-found: 0
Reference: [APPE 68] <author> Appel, A. </author> <title> (1968) Some Techniques for Shading Machine Renderings of Solids, </title> <booktitle> Proc. AFIPS JSCC 32, </booktitle> <pages> 37-45. </pages>
Reference-contexts: The following algorithm makes use of scan-line coherence, and is based on the approach of <ref> [APPE 68; BOUK 70; WATK 70] </ref>. Consider an edge (x 1 1 2 2 ) with the labels chosen so that the y-value of the first point is always less than that of the second (y &lt; y ) 1 2 . Horizontal edges are ignored throughout.
Reference: [BOUK 70] <author> Bouknight, W.J., Kelley, K. </author> <title> (1970) An Algorithm for Producing HalfTone Computer Graphics Presentations with Shadows and Movable Light Sources, </title> <booktitle> AFIPS Conf. Proc. </booktitle> <volume> 36, </volume> <pages> 1-10. </pages>
Reference-contexts: The following algorithm makes use of scan-line coherence, and is based on the approach of <ref> [APPE 68; BOUK 70; WATK 70] </ref>. Consider an edge (x 1 1 2 2 ) with the labels chosen so that the y-value of the first point is always less than that of the second (y &lt; y ) 1 2 . Horizontal edges are ignored throughout.
Reference: [BRES 65] <author> Bresenham, </author> <title> J.E. (1965) Algorithm for Computer Control of Digital Plotter, </title> <journal> IBM System Journal, </journal> <volume> 4(1), </volume> <pages> 25-30. </pages>
Reference-contexts: In fact it is possible to construct a line drawing algorithm using only integer arithmetic, with additions, and multiplications by 2. This algorithm is due to Bresenham <ref> [BRES 65] </ref>. 2.4 Bresenham's Line Drawing Algorithm In this section, we assume that x 1 1 = 0, dx &gt; 0, dy &gt; 0, and that the slope is less than 1 (0 &lt; dy &lt; dx).
Reference: [BRES 77] <author> Bresenham, </author> <title> J.E. (1977) A Linear Algorithm for Incremental Digital Display of Circular Arcs, </title> <journal> Communications of the ACM, </journal> <volume> 20(2), </volume> <pages> 100-106. </pages>
Reference-contexts: Of course there are other algorithms for other primitives, such as arcs of circles and ellipses and other types of curve. However, no fundamentally new ideas are involved, so we leave discovery of such algorithms to the reader <ref> [BRES 77; PITT 67] </ref>. Exercises 2.1. Suppose that a frame buffer consists of M rows of N pixels each. In one read, which takes r seconds, the video controller can access and output P pixels. The horizontal and vertical retrace times are h and v seconds respectively.
Reference: [FUNG] <author> Fung, </author> <title> K.Y, T.M. Nicholl, A.K. Dewdney A Run-Length Slice Line Drawing Algorithm without Division Operations, </title> <booktitle> Eurographics 92, Computer Graphics Forum 11(3), Conference Issue, </booktitle> <editor> eds. A. Kilgour and L. </editor> <booktitle> Kjelldahl, </booktitle> <pages> 267-277. </pages>
Reference: [NICH 90] <author> Nicholl, R.A. </author> <title> and T.N. Nicholl (1990) Performing geometric transformations by program transformation, </title> <journal> ACM Transactions on Graphics, </journal> <volume> 9(1), </volume> <pages> 28-40. </pages>
Reference-contexts: An interesting paper by Nicholl and Nicholl shows how to construct program transformations corresponding to geometric transformations, and deals with the various cases of Bresenham's algorithm as an example <ref> [NICH 90] </ref>. We have presented the core of the algorithm for the rasterisation of line segments. For the time being we are not taking into account the complicating factor of aliasing, nor many improvements that can be made to this core.
Reference: [PINE 88] <author> Pineda, J. </author> <title> (1988) A Parallel Algorithm for Polygon Rasterization, </title> <journal> Computer Graphics, </journal> <volume> 22(4), </volume> <pages> 17-20. </pages>
Reference-contexts: A Parallel Algorithm for Polygon Filling Of course there is not just one method for filling polygons. There are many methods - the above being the best known. The purpose of this section is only to introduce a different approach, by Juan Pineda <ref> [PINE 88] </ref>. Consider the line segment shown in Figure 2.8, and suppose this is an up-directed edge of a convex polygon (with clockwise traversal of the edges). Equation (17) defines a function E (x,y) in relation to this line segment.
Reference: [PITT 67] <author> Pitteway, M.L.V. </author> <title> (1967) Algorithm for Drawing Ellipses or Hyperbolae with a Digital Plotter, </title> <journal> Computer Journal 10(3), </journal> <pages> 282-289. </pages>
Reference-contexts: Of course there are other algorithms for other primitives, such as arcs of circles and ellipses and other types of curve. However, no fundamentally new ideas are involved, so we leave discovery of such algorithms to the reader <ref> [BRES 77; PITT 67] </ref>. Exercises 2.1. Suppose that a frame buffer consists of M rows of N pixels each. In one read, which takes r seconds, the video controller can access and output P pixels. The horizontal and vertical retrace times are h and v seconds respectively.
Reference: [ROKN 90] <author> Rokne, J.G., Wyvill, B. </author> <title> (1990) Fast Line Scan-Conversion, </title> <journal> ACM Transactions on Graphics, </journal> <volume> 9(4), </volume> <pages> 376-388. </pages>
Reference-contexts: In this way it is possible to quickly identify which pixels should be set between each successive 4 pixels, without doing any arithmetical computations. This work, and similar work is described in <ref> [ROKN 90] </ref>[ROKN 92] [FUNG 92]. 2.5 Polygon Rasterisation A polygon is represented by a sequence of points [p 0 ,p 1 ,...,p n-1 ,p n ](p n = p 0 ), where each p i = (x i ,y i ) is a pixel position.
Reference: [ROKN 92] <author> Rokne, J.G., Y. </author> <title> Rao (1992) DoubleStep Incremental Linear Interpolation, </title> <journal> ACM Transactions on Graphics, </journal> <volume> 11(2), </volume> <pages> 183-192. </pages>
Reference: [WATK 70] <author> Watkins, G.S. </author> <title> (1970) A Real-Time Visible Surface Algorithm, </title> <type> PhD Thesis, </type> <institution> University of Utah Computer Science Dept. </institution> <type> Technical Report, </type> <institution> UTEC-CSC-7-101. </institution>
Reference-contexts: The following algorithm makes use of scan-line coherence, and is based on the approach of <ref> [APPE 68; BOUK 70; WATK 70] </ref>. Consider an edge (x 1 1 2 2 ) with the labels chosen so that the y-value of the first point is always less than that of the second (y &lt; y ) 1 2 . Horizontal edges are ignored throughout.
References-found: 11

