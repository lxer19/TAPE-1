URL: ftp://ftp.cs.washington.edu/pub/lis/papers/burns/async94.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/burns/professional/pubs.html
Root-URL: 
Email: E-mail: fhenrik,burnsg@cs.washington.edu  
Title: Bounded Delay Timing Analysis of a Class of CSP Programs with Choice  
Author: Henrik Hulgaard and Steven M. Burns 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We extend our technique for determining exact time separation of events in systems with just concurrency to a restricted but still useful class of systems with both choice and concurrency. Such a system is described using a CSP program (including Martin's probe operator) with the restrictions that the communication behavior is data-independent, that there is no OR-causality, and that guard selection is either completely free or mutually exclusive. Such a CSP program is transformed into a safe Petri net. Interval time delays are specified on the places of the net. The timing analysis we perform is, for all possible timed executions of the system, determine the extreme separations in time for all occurrences of specified events. We formally define this problem, propose an algorithm for its solution, and apply the algorithm to an example program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and D. L. Dill. </author> <title> The theory of timed automata. </title> <editor> In J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rosenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, </booktitle> <volume> LNCS # 600, </volume> <pages> pages 28-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Here we extend this algorithm to cover systems with both choice and concurrency. We use a restricted class of CSP programs, that are then transformed into Petri nets, to describe such systems. Others have developed timing analysis algorithms for more general specifications <ref> [1, 4, 9, 14] </ref>. Orbits [14] represents the most developed algorithm and implementation. Our approach is significantly more efficient than Orbits for analyzing certain programs, including the parameterized example of Section 5. <p> The maxi mum separation analysis would correspond to: Ref = To = From = fP (0) (1) (2) fl = 0; fi = 1 If all the place delay ranges are set to <ref> [1; 2] </ref>, we get the maximum separation = 15 (see line 1 in Table 2). G (0) P (0) 0 P (2) G (1) P (0) P (0) G 1 2 1 0 1 stack. <p> We must include all Petri net transitions corresponding to Put and Get communications in the environment. Thus Ref = From = To = fP (0) (1) (2) (0) (1) (2) fl = 1; fi = 0 The results, again for <ref> [1; 2] </ref> delay ranges, are = 5 and ffi = 1 (see line 2 in Table 2). A number of other separation analysis are shown in Table 2 for larger eager stacks. For the 4-stage stack we illustrate an interesting property of the eager stack.
Reference: [2] <author> T. Amon, H. Hulgaard, S. M. Burns, and G. Borriello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <booktitle> In ICCD '93, </booktitle> <pages> pages 166-173, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This is accomplished by computing b using reversed roles for From and To, and fi and fl: b = b (; To; fl; From; fi; Ref ). 4.2 Timing Analysis without Choice In previous work <ref> [2, 8] </ref>, we developed the Time Separation of Events (TSE) algorithm that, given a Petri net without choice (a marked graph), determines the maximum separation between occurrences of two tran sitions, t from and t to , separated by a fixed occurrence index offset. <p> The maxi mum separation analysis would correspond to: Ref = To = From = fP (0) (1) (2) fl = 0; fi = 1 If all the place delay ranges are set to <ref> [1; 2] </ref>, we get the maximum separation = 15 (see line 1 in Table 2). G (0) P (0) 0 P (2) G (1) P (0) P (0) G 1 2 1 0 1 stack. <p> We must include all Petri net transitions corresponding to Put and Get communications in the environment. Thus Ref = From = To = fP (0) (1) (2) (0) (1) (2) fl = 1; fi = 0 The results, again for <ref> [1; 2] </ref> delay ranges, are = 5 and ffi = 1 (see line 2 in Table 2). A number of other separation analysis are shown in Table 2 for larger eager stacks. For the 4-stage stack we illustrate an interesting property of the eager stack.
Reference: [3] <author> E. </author> <title> Best. COSY: Its relation to nets and to CSP. </title> <editor> In W. Brauer, W. Reisig, and G. Rozenberg, editors, </editor> <title> Petri Nets: Applications and Relationships to Other Models of Concurrency, </title> <booktitle> LNCS # 255: Advances in Petri Nets, </booktitle> <pages> pages 416-440. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Petri net transitions are used to model communication synchronizations and places are used to model control choice. The Petri net can be constructed by syntax directed translation <ref> [3] </ref>. The mapping amounts to introducing a single token corresponding to the program counter in each communicating process. After constructing nets for each process, transitions are combined corresponding to matching communication actions. Figure 1 shows a simple CSP specification and the corresponding Petri net. <p> We solve the labeling problem by introducing a separate label for each possible pairing of communication actions <ref> [3] </ref>. In the exam ple, we introduce two labels: X (0) and X (1) . We then introduce a choice for each of the possible communications, and obtain the nets shown in Figure 2.
Reference: [4] <author> J. R. Burch. </author> <title> Trace algebra for automatic verification of real-time concurrent systems. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Here we extend this algorithm to cover systems with both choice and concurrency. We use a restricted class of CSP programs, that are then transformed into Petri nets, to describe such systems. Others have developed timing analysis algorithms for more general specifications <ref> [1, 4, 9, 14] </ref>. Orbits [14] represents the most developed algorithm and implementation. Our approach is significantly more efficient than Orbits for analyzing certain programs, including the parameterized example of Section 5.
Reference: [5] <author> P. Godefroid. </author> <title> Using partial orders to improve automatic verification methods. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> CAV '90, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 321-340, </pages> <year> 1991. </year>
Reference-contexts: We can therefore construct a graph that potentially is smaller than the reachability graph yet still satisfies (1). We call this graph a trace automaton. Several algorithms exist to construct trace automata without first constructing the reachability graph. We have modified the algorithm in <ref> [5] </ref> to take advantage of our Petri net restrictions. If there is no concurrency in the net, the trace automaton and the reachability graph are identical; if there is concurrency, there is potential for a large reduction is size.
Reference: [6] <author> J. Gunawardena. </author> <title> Timing analysis of digital circuits and the theory of min-max functions. </title> <booktitle> In International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (TAU), </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Data dependent computations are excluded due to computability issues as well as state-space explosion even in the case of no timing information. We disallow disjunctions in guards because they correspond to OR-causality, which is also known to be difficult <ref> [6, 12] </ref>. Finally, the semantic restriction on the guards allows the use of all untimed executions in determining the possible timed behaviors. As we shall see in Section 3, this is an important simplification to the timing analysis problem.
Reference: [7] <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Borriello. </author> <title> Practical applications of an efficient time separation of events algorithm. </title> <booktitle> In ICCAD '93, </booktitle> <pages> pages 146-151, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Separation analyses at the high-level can be used to help a designer choose among potential designs to perform a given computation. At a low-level they can be used to determine if isochronic fork assumptions are valid <ref> [7] </ref>. This paper is composed of six sections. We follow this introduction with a description of the CSP specification language and its translation to Petri nets. Timed and untimed execution semantics of Petri nets are introduced in Section 3.
Reference: [8] <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Bor-riello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <type> Technical report, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> February </month> <year> 1994. </year> <note> TR #94-02-02 (available via anonymous ftp: cs.washington.edu:tr/1994/02/UW-CSE94-02-02.PS.Z). </note>
Reference-contexts: This is accomplished by computing b using reversed roles for From and To, and fi and fl: b = b (; To; fl; From; fi; Ref ). 4.2 Timing Analysis without Choice In previous work <ref> [2, 8] </ref>, we developed the Time Separation of Events (TSE) algorithm that, given a Petri net without choice (a marked graph), determines the maximum separation between occurrences of two tran sitions, t from and t to , separated by a fixed occurrence index offset. <p> The algorithm computes (b) in time linear in the size of . For finite sets b , we can obtain the global maximum by applying the algorithm to each triple: = maxf (b) j b 2 b g : In <ref> [8] </ref>, we showed that for nets without choice each b 2 b can be constructed from three fixed processes, R , S , and T as follows: = R z -| - where R starts at the initial marking M 0 and T con tains the transitions t dst and t <p> We can obtain the maximum of this infinite sequence by computing the matrix closure of S, and then compute from R S fl T. Another approach, also described in <ref> [8] </ref> and based on ideas in [13], is to use this same algebra to compute iteratively. This is done by forming the matrix products S n T in order of increasing n. For each n, we compute lower and upper bounds on .
Reference: [9] <author> A. R. Martello and S. P. Levitan. </author> <title> Temporal analysis of time bounded digital systems. In Correct hardware design and verification methods : CHARME '93, </title> <month> May </month> <year> 1993. </year>
Reference-contexts: Here we extend this algorithm to cover systems with both choice and concurrency. We use a restricted class of CSP programs, that are then transformed into Petri nets, to describe such systems. Others have developed timing analysis algorithms for more general specifications <ref> [1, 4, 9, 14] </ref>. Orbits [14] represents the most developed algorithm and implementation. Our approach is significantly more efficient than Orbits for analyzing certain programs, including the parameterized example of Section 5.
Reference: [10] <author> A. J. Martin. </author> <title> Programming in VLSI: From communicating processes to delay-insensitive circuits. In C.A.R. Hoare, editor, </title> <booktitle> UT Year of Programming Institute on Concurrent Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Finally, Section 6 summarizes the contributions of this paper. 2 Specifications We now describe our restricted specification language and show how to translate these specifications into an intermediate form that is more suitable for timing analysis. 2.1 CSP Programs We specify computations using CSP (Martin style <ref> [10] </ref>). However, to make the timing analysis feasible, we restrict the expressive power of the specification language. First, we exclude data-dependent communication behavior by requiring that guards consist entirely of conjunctions of non-negated probes (possibly the empty conjunction true).
Reference: [11] <author> A. Mazurkiewicz. </author> <title> Basic notions of trace theory. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <publisher> LNCS # 354, </publisher> <pages> pages 285-363. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Let M 0 [iM denote that the firing sequence transforms the marking from M 0 into M . The set of firing sequences of is denoted by FS (). One of the firing sequence for the Petri net in Figure 1 is = ABCEADF BA. A process <ref> [11, 15] </ref> is a simple class of Petri nets. The process = hS; T; F; labi is a net with places S, transitions T , and flow relation F .
Reference: [12] <author> K. McMillan and D. L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Data dependent computations are excluded due to computability issues as well as state-space explosion even in the case of no timing information. We disallow disjunctions in guards because they correspond to OR-causality, which is also known to be difficult <ref> [6, 12] </ref>. Finally, the semantic restriction on the guards allows the use of all untimed executions in determining the possible timed behaviors. As we shall see in Section 3, this is an important simplification to the timing analysis problem. <p> The TSE algorithm is based on an algorithm proposed by McMillan and Dill <ref> [12] </ref> to determine the maximum separation between two fixed transitions in a process. Let (b) be the maximum separation be tween t src and t dst in process . The algorithm computes (b) in time linear in the size of .
Reference: [13] <author> C. J. Myers and T. H.-Y. Meng. </author> <title> Synthesis of timed asynchronous circuits. </title> <journal> IEEE Transactions on Very Large Scale Integration (VLSI) Systems, </journal> <volume> 1(2) </volume> <pages> 106-119, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Similar information can be used to generate worst-case and amortized performance bounds. We may also perform minimum separation analyses in order to determine if it is feasible to remove circuitry from a speed-independent implementation <ref> [13] </ref>. Our algorithm performs these sorts of analyses and is useful in many contexts and at many levels of abstraction. Separation analyses at the high-level can be used to help a designer choose among potential designs to perform a given computation. <p> We can obtain the maximum of this infinite sequence by computing the matrix closure of S, and then compute from R S fl T. Another approach, also described in [8] and based on ideas in <ref> [13] </ref>, is to use this same algebra to compute iteratively. This is done by forming the matrix products S n T in order of increasing n. For each n, we compute lower and upper bounds on .
Reference: [14] <author> T. G. Rokicki. </author> <title> Representing and Modeling Digital Circuits. </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: Here we extend this algorithm to cover systems with both choice and concurrency. We use a restricted class of CSP programs, that are then transformed into Petri nets, to describe such systems. Others have developed timing analysis algorithms for more general specifications <ref> [1, 4, 9, 14] </ref>. Orbits [14] represents the most developed algorithm and implementation. Our approach is significantly more efficient than Orbits for analyzing certain programs, including the parameterized example of Section 5. <p> Here we extend this algorithm to cover systems with both choice and concurrency. We use a restricted class of CSP programs, that are then transformed into Petri nets, to describe such systems. Others have developed timing analysis algorithms for more general specifications [1, 4, 9, 14]. Orbits <ref> [14] </ref> represents the most developed algorithm and implementation. Our approach is significantly more efficient than Orbits for analyzing certain programs, including the parameterized example of Section 5. Determining tight bounds on separation times between arbitrary system events provides information which can be used to answer many different temporal questions. <p> We have also proposed an algorithm to solve this problem based on our previous algebraic solution of the no choice case. In practice, our algorithm is able to analyze fairly large nets. Table 3 and Figure 15 show this and also compare our algorithm to Orbits <ref> [14] </ref>, a tool for answering temporal questions about a more general class of timed Petri nets.

References-found: 14

