URL: ftp://cl-ftp.dfki.uni-sb.de/pub/papers/local/RR-94-37.ps.Z
Refering-URL: http://cl-www.dfki.uni-sb.de/cl/papers/cl-abstracts.html
Root-URL: 
Phone: Tel.: 49 (631) 205-3211 Stuhlsatzenhausweg 3  Tel.: 49 (681) 302-5252  
Title: TDLA Type Description Language for HPSG Part 1: Overview  
Author: f ur K unstliche Hans-Ulrich Krieger, Ulrich Schafer f ur K unstliche Intelligenz 
Address: Postfach 20 80 67608 Kaiserslautern, FRG  66123 Saarbrucken, FRG  
Note: Deutsches Forschungszentrum  
Date: November 1994  
Affiliation: Deutsches Forschungszentrum  Intelligenz GmbH Research  GmbH  
Pubnum: Report RR-94-37  
Abstract-found: 0
Intro-found: 1
Reference: <institution> References </institution>
Reference: [ At-Kaci & Nasr 86 ] <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A Logic Programming Language with Built-In Inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: To the best of our knowledge, the problem of type expansion within a typed feature-based environment was first addressed by [ At-Kaci 86 ] . The language he described was called KBL and shared great similarities with LOGIN; see <ref> [ At-Kaci & Nasr 86 ] </ref> . However, the expansion mechanism he described was order dependent in that it replaced types by their definition instead of unifying the information.
Reference: [ At-Kaci et al. 85 ] <author> Hassan At-Kaci, Robert Boyer, and Roger Nasr. </author> <title> An Encoding Technique for the Efficient Implementation of Type Inheritance. </title> <type> Technical Report AI-109-85, </type> <institution> MCC, Austin, TX, </institution> <year> 1985. </year>
Reference-contexts: the control machinery of TDL during the definition of a type (type classification) or indirectly via the simplifier both at definition and at run time (type unification and type expansion). 3.2.1 Encoding Method The implementation of the type hierarchy is based on At-Kaci's bit vector encoding technique for partial orders <ref> [ At-Kaci et al. 85; At-Kaci et al. 89 ] </ref> . Every type t is assigned a code fl (t) (represented through a bit vector) such that fl (t) reflects the reflexive transitive closure of the subsumption relation with respect to t.
Reference: [ At-Kaci et al. 89 ] <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient Implementation of Lattice Operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 115-146, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Moreover, generalizations can be made at the appropriate levels of representation. * efficient processing Certain type constraints can be compiled into more efficient representations, for instance, <ref> [ At-Kaci et al. 89 ] </ref> reduces GLB (greatest lower bound), LUB (least upper bound), and (type subsumption) computation to low-level bit manipulations; see Section 3.2. Moreover, types can be used to eliminate expensive unification operations, for example, by explicit declaration of type incompatibility. <p> the control machinery of TDL during the definition of a type (type classification) or indirectly via the simplifier both at definition and at run time (type unification and type expansion). 3.2.1 Encoding Method The implementation of the type hierarchy is based on At-Kaci's bit vector encoding technique for partial orders <ref> [ At-Kaci et al. 85; At-Kaci et al. 89 ] </ref> . Every type t is assigned a code fl (t) (represented through a bit vector) such that fl (t) reflects the reflexive transitive closure of the subsumption relation with respect to t.
Reference: [ At-Kaci et al. 93 ] <author> Hassan At-Kaci, Andreas Podelski, and Seth Copen Goldstein. </author> <title> Order-Sorted Feature Theory Unification. </title> <type> Technical Report 32, </type> <institution> Digital Equipment Corporation, DEC Paris Research Laboratory, France, </institution> <month> May </month> <year> 1993. </year> <booktitle> Also in Proceedings of the International Symposium on Logic Programming, </booktitle> <address> Oct. 1993, </address> <publisher> MIT Press. </publisher>
Reference-contexts: Reconstructing the constraints which determine a type (idiosyncratic plus inherited constraints) requires a complex operation called type expansion. This operation is comparable to Carpenter's total well-typedness [ Carpenter 92 ] or At-Kaci's sort unfolding <ref> [ At-Kaci et al. 93 ] </ref> . <p> expansion mechanism can be either used as a stand-alone system or as an integrated part of the typed unification machinery. 16 It should be noted that we define TFS to have a nested structure and not to be flat (in contrast to feature clauses in a more logic-oriented approach, e.g., <ref> [ At-Kaci et al. 93 ] </ref> ) in order to make the connection to the implementation clear and to come close to the structured attribute-value matrix notation. 3.4 Type Expansion and Control 27 We only have to say a few words on the semantic foundations of type expansion at the end <p> In every other case, the unfolding process goes on by substituting types through their definitions. Recently, <ref> [ At-Kaci et al. 93 ] </ref> have formally shown a similar result by using the compactness theorem of first-order logic. <p> delayed expansion * recursive types are treated specially * preference information can be employed * prototype memoization speeds up processing 4 Comparison to other Systems TDL is unique in that it implements many novel features not found in other systems like ALE [ Carpenter & Penn 94 ] , LIFE <ref> [ At-Kaci et al. 93 ] </ref> , or TFS [ Zajac 92 ] .
Reference: [ At-Kaci 86 ] <author> Hassan At-Kaci. </author> <title> An Algebraic Semantics Approach to the Effective Resolution of Type Equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 293-351, </pages> <year> 1986. </year>
Reference-contexts: Moreover, if the formalism does not allow functional or relational constraints, one must specify certain functions/relations like append through recursive types. Take for instance At-Kaci's version of append <ref> [ At-Kaci 86 ] </ref> which can be stated in T DL as follows: append 0 := [ FRONT &lt; &gt;, BACK #1 ^ list , WHOLE #1 ]. append 1 := [ FRONT &lt; #first . #rest1 &gt;, BACK #back ^ list , WHOLE &lt; #first . #rest2 &gt;, PATCH append <p> In the following, we refer to a type hierarchy I by a pair hT ; i, such that T fi T is a decidable partial order, i.e., is reflexive, antisymmetric, and transitive. A typed feature structure (TFS) is essentially either a -term or an *-term <ref> [ At-Kaci 86 ] </ref> , i.e., such that x 2 V , t 2 T , = ff 1 : : = n g, and fi = f 1 ; : : : ; n g, where each f i 2 F and i is again a TFS. <p> on the construction of a fixpoint over a particular continuous function. 19 The first approach is in general closer to an implementation (and thus to our algorithm) in that the function which is involved in the fixpoint construction corresponds more or less to the unification/substitution of TFS (see for instance <ref> [ At-Kaci 86 ] </ref> or [ Pollard & Moshier 90 ] ). The latter approach is based on the assumption that TFS are only syntactic sugar for first-order formulae. <p> To the best of our knowledge, the problem of type expansion within a typed feature-based environment was first addressed by <ref> [ At-Kaci 86 ] </ref> . The language he described was called KBL and shared great similarities with LOGIN; see [ At-Kaci & Nasr 86 ] . However, the expansion mechanism he described was order dependent in that it replaced types by their definition instead of unifying the information.
Reference: [ At-Kaci 93 ] <author> Hassan At-Kaci. </author> <title> An Introduction to LIFE|Programming with Logic, Inheritance, Functions, and Equations. </title> <booktitle> In: Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pp. 52-68, </pages> <year> 1993. </year>
Reference-contexts: Another way one might pursue is to integrate type expansion into the typed unification process so that it can take place at run time. Systems that explore this strategy are TFS [ Zajac 92 ] and LIFE <ref> [ At-Kaci 93 ] </ref> . However, both implementations are not lazy, thus hard to control and moreover, might not terminate. In addition, if prototype memoization is not available, type expansion at run time is inefficient; cf. the results of our grammar example in Table (11).
Reference: [ Alshawi 92 ] <author> Hiyan Alshawi (ed.). </author> <title> The Core Language Engine. ACL-MIT Press Series in Natural Language Processing. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Reape 91 ] (see [ Blackburn 94 ] for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG [ Gazdar et al. 85 ] and PATR-II [ Shieber et al. 83 ] , as well as their successors CLE <ref> [ Alshawi 92 ] </ref> and ELU [ Russell et al. 92 ] ), modern formalisms try to specify grammatical knowledge as well as lexicon entries entirely through feature structures.
Reference: [ Backofen & Smolka 92 ] <author> Rolf Backofen and Gert Smolka. </author> <title> A Complete and Recursive Feature Theory. </title> <type> Technical Report RR-92-30, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany, </institution> <year> 1992. </year>
Reference-contexts: Paul King's work aimed to reconstruct a special grammar theory, viz., HPSG, in mathematical terms [ King 89 ] , whereas Backofen and Smolka's treatment bridged the gap between logic programming and unification-based grammar formalisms <ref> [ Backofen & Smolka 92 ] </ref> . New work by Backofen investigates a very general feature theory which incorporates nearly all extensions of feature descriptions that have been proposed in the literature.
Reference: [ Backofen & Weyers 94 ] <author> Rolf Backofen and Christoph Weyers. </author> <title> UDiNe|A Feature Constraint Solver with Distributed Disjunction and Classical Negation. </title> <type> Technical report, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Ger-many, 1994(95). Forthcoming, hopefully ;-g. </institution>
Reference-contexts: The parser is a bidirectional bottom-up chart parser, providing a user with parameterized parsing strategies as well as control over the processing of individual rules [ Kiefer & Scherf 94 ] . The core machinery of DISCO consists of TDL (see below) and the feature constraint solver UDiNe <ref> [ Backofen & Weyers 94 ] </ref> . UDiNe itself is a powerful untyped unification machine which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: [ Backofen et al. 93 ] <author> Rolf Backofen, Hans-Ulrich Krieger, Stephen P. Spackman, and Hans Uszkoreit (eds.). </author> <title> Report of the EAGLES Workshop on Implemented Formalisms at DFKI, </title> <type> Saarbrucken. Technical Report D-93-27, </type> <institution> DFKI, Saarbrucken, </institution> <year> 1993. </year>
Reference-contexts: as a stand-alone system, it must implement recursive types if it does not provide phrase-structure recursion directly (within the formalism) 4 For instance, Bob Carpenter's ALE system [ Carpenter & Penn 94 ] gives a user the option of defining definite clauses, using disjunction, negation, and Prolog cut. 5 Cf. <ref> [ Backofen et al. 93 ] </ref> for a comprehensive overview of modern systems, including a detailed description of their features. 6 See [ Daelemans et al. 92 ] for a general introduction. 1.3 Overview of the Paper 7 or indirectly (via a parser/generator). 7 In addition, certain forms of relations (like <p> Moreover, recursive types are supported as well. In T DL, a grammar writer decides whether types live in an open or a closed world. This effects GLB and LUB computations. 20 <ref> [ Backofen et al. 93 ] </ref> gives an overview of implemented formalisms. 38 5 SUMMARY The type system itself consists of several inference components, each designed to cover a specific task efficiently: (i) a bit vector encoding of the hierarchy, (ii) a fast symbolic simplifier for complex type expressions, (iii) memoization
Reference: [ Backofen 94 ] <author> Rolf Backofen. </author> <title> Expressivity and Decidability of First-Order Languages over Feature Trees. </title> <type> PhD thesis, </type> <institution> Universitat des Saarlandes, Department of Computer Science, </institution> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: New work by Backofen investigates a very general feature theory which incorporates nearly all extensions of feature descriptions that have been proposed in the literature. This language is of course undecidable w.r.t. satisfiability, but Backofen presents several fragments of the language that show more desirable properties <ref> [ Backofen 94 ] </ref> .
Reference: [ Blackburn 94 ] <author> Patrick Blackburn. </author> <title> Structures, Languages and Translations: the Structural Approach to Feature Logic. </title> <editor> In: C.J. Rupp, M.A. Rosner, and R.L. Johnson (eds.), </editor> <title> Constraints, Language and Computation. </title> <publisher> Academic Press, </publisher> <year> 1994. </year> <note> REFERENCES 49 </note>
Reference-contexts: There exist only a few other proposals to feature descriptions nowadays which do not use standard first order logic directly, for instance Reape's approach, using a polymodal logic [ Reape 91 ] (see <ref> [ Blackburn 94 ] </ref> for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG [ Gazdar et al. 85 ] and PATR-II [ Shieber et al. 83 ] , as well as their successors CLE [ Alshawi 92 ] and
Reference: [ Brew 93 ] <author> Chris Brew. </author> <title> Adding Preferences to CUF. </title> <editor> In: Jochen Dorre (ed.), </editor> <booktitle> Computational Aspects of Constraint-Based Linguistic Description I, </booktitle> <pages> pp. 54-69. </pages> <institution> ILLC/Department of Philosophy, University of Amsterdam, </institution> <year> 1993. </year> <note> DYANA-2 Deliverable R1.2.A. </note>
Reference: [ Carpenter & Penn 94 ] <author> Bob Carpenter and Gerald Penn. </author> <title> ALE|The Attribute Logic Engine User's Guide. Version 2.0. </title> <type> Technical report, </type> <institution> Laboratory for Computational Linguistics. Philosophy Department, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This leads to multiple inheritance in the description of linguistic entities. 6 Finally, if a formalism is intended to be used as a stand-alone system, it must implement recursive types if it does not provide phrase-structure recursion directly (within the formalism) 4 For instance, Bob Carpenter's ALE system <ref> [ Carpenter & Penn 94 ] </ref> gives a user the option of defining definite clauses, using disjunction, negation, and Prolog cut. 5 Cf. [ Backofen et al. 93 ] for a comprehensive overview of modern systems, including a detailed description of their features. 6 See [ Daelemans et al. 92 ] <p> of the underlying deduction system|we are not interested in the normalization of feature constraints (i.e., how unification of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower bound is obligatory (TFS [ Zajac 92 ] ; ALE <ref> [ Carpenter & Penn 94 ] </ref> ) or optional as in T DL. We assume here that typed unification is simply a black box and can be accessed through an interface function (say unify-tfs ). <p> However, the expansion mechanism he described was order dependent in that it replaced types by their definition instead of unifying the information. Moreover, it was non-lazy, thus it will fail to terminate for recursive types and performs type expansion only at definition time as is the case for ALE <ref> [ Carpenter & Penn 94 ] </ref> . However, ALE provides recursion through a built-in bottom-up chart parser and through definite clauses. Allowing type expansion only at definition time is in general space consuming, thus unification and copying is expensive at run time. <p> as well as global control is possible * delayed expansion * recursive types are treated specially * preference information can be employed * prototype memoization speeds up processing 4 Comparison to other Systems TDL is unique in that it implements many novel features not found in other systems like ALE <ref> [ Carpenter & Penn 94 ] </ref> , LIFE [ At-Kaci et al. 93 ] , or TFS [ Zajac 92 ] .
Reference: [ Carpenter 92 ] <author> Bob Carpenter. </author> <title> The Logic of Typed Feature Structures. </title> <booktitle> Tracts in Theoretical Computer Science. </booktitle> <address> Cambridge: </address> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Reconstructing the constraints which determine a type (idiosyncratic plus inherited constraints) requires a complex operation called type expansion. This operation is comparable to Carpenter's total well-typedness <ref> [ Carpenter 92 ] </ref> or At-Kaci's sort unfolding [ At-Kaci et al. 93 ] .
Reference: [ Daelemans et al. 92 ] <author> Walter Daelemans, Koenraad De Smedt, and Gerald Gazdar. </author> <title> Inheritance in Natural Language Processing. </title> <journal> Computational Linguistics, </journal> <volume> 18(2) </volume> <pages> 205-218, </pages> <year> 1992. </year>
Reference-contexts: instance, Bob Carpenter's ALE system [ Carpenter & Penn 94 ] gives a user the option of defining definite clauses, using disjunction, negation, and Prolog cut. 5 Cf. [ Backofen et al. 93 ] for a comprehensive overview of modern systems, including a detailed description of their features. 6 See <ref> [ Daelemans et al. 92 ] </ref> for a general introduction. 1.3 Overview of the Paper 7 or indirectly (via a parser/generator). 7 In addition, certain forms of relations (like append ) or additional extensions of the formalism (like functional uncertainty) can be nicely modelled through recursive types. 1.3 Overview of the
Reference: [ Dorre & Dorna 93 ] <author> Jochen Dorre and Michael Dorna. </author> <title> CUF|A Formalism for Linguistic Knowledge Representation. </title> <editor> In: Jochen Dorre (ed.), </editor> <title> Computational Aspects of Constraint-Based Linguistic Description I. </title> <address> DYANA, </address> <year> 1993. </year>
Reference-contexts: Other proposals considered the integration of functional and relational dependencies into formalisms which makes them Turing-complete in general. 4 However the most important extension to formalisms consists in the incorporation of types , for instance in modern systems like TFS [ Emele & Zajac 90; Zajac 92 ] , CUF <ref> [ Dorre & Eisele 91; Dorre & Dorna 93 ] </ref> , or TDL [ Krieger & Schafer 93a; Krieger & Schafer 94a; Krieger & Schafer 94b ] . 5 Types are ordered hierarchically (via subsumption) as in object-oriented programming languages. <p> In addition, if prototype memoization is not available, type expansion at run time is inefficient; cf. the results of our grammar example in Table (11). A system that employs a lazy strategy on demand at run time is CUF <ref> [ Dorre & Dorna 93 ] </ref> . Laziness can be achieved by specifying delay patterns as is familiar from Prolog.
Reference: [ Dorre & Eisele 91 ] <author> Jochen Dorre and Andreas Eisele. </author> <title> A Comprehensive Unification-Based Grammar Formalism. </title> <type> Technical Report Deliverable R3.1.B, </type> <institution> DYANA, Centre for Cognitive Science, University of Edinburgh, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: Other proposals considered the integration of functional and relational dependencies into formalisms which makes them Turing-complete in general. 4 However the most important extension to formalisms consists in the incorporation of types , for instance in modern systems like TFS [ Emele & Zajac 90; Zajac 92 ] , CUF <ref> [ Dorre & Eisele 91; Dorre & Dorna 93 ] </ref> , or TDL [ Krieger & Schafer 93a; Krieger & Schafer 94a; Krieger & Schafer 94b ] . 5 Types are ordered hierarchically (via subsumption) as in object-oriented programming languages.
Reference: [ Eisele & Dorre 90 ] <author> Andreas Eisele and Jochen Dorre. </author> <title> Disjunctive Unification. </title> <type> IWBS Report 124, </type> <institution> IWBS, IBM Germany, Stuttgart, </institution> <year> 1990. </year>
Reference-contexts: The input is specified through a list under path input ; cf. the definition of type ab below. The distributed (or named) disjunction <ref> [ Eisele & Dorre 90 ] </ref> headed by $1 in type state1 is used to map input symbols to state types (and vice versa).
Reference: [ Emele & Zajac 90 ] <author> Martin Emele and Remi Zajac. </author> <title> Typed Unification Grammars. </title> <booktitle> In: Proceedings of the 13th International Conference on Computational Linguistics, COLING-90, </booktitle> <pages> pp. 293-298, </pages> <year> 1990. </year>
Reference-contexts: Other proposals considered the integration of functional and relational dependencies into formalisms which makes them Turing-complete in general. 4 However the most important extension to formalisms consists in the incorporation of types , for instance in modern systems like TFS <ref> [ Emele & Zajac 90; Zajac 92 ] </ref> , CUF [ Dorre & Eisele 91; Dorre & Dorna 93 ] , or TDL [ Krieger & Schafer 93a; Krieger & Schafer 94a; Krieger & Schafer 94b ] . 5 Types are ordered hierarchically (via subsumption) as in object-oriented programming languages.
Reference: [ Gazdar et al. 85 ] <author> Gerald Gazdar, Ewan Klein, Geoffrey Pullum, and Ivan Sag. </author> <title> Generalized Phrase Structure Grammar. </title> <publisher> Harvard University Press, </publisher> <year> 1985. </year>
Reference-contexts: feature descriptions nowadays which do not use standard first order logic directly, for instance Reape's approach, using a polymodal logic [ Reape 91 ] (see [ Blackburn 94 ] for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG <ref> [ Gazdar et al. 85 ] </ref> and PATR-II [ Shieber et al. 83 ] , as well as their successors CLE [ Alshawi 92 ] and ELU [ Russell et al. 92 ] ), modern formalisms try to specify grammatical knowledge as well as lexicon entries entirely through feature structures.
Reference: [ Johnson 88 ] <author> Mark Johnson. </author> <title> Attribute Value Logic and the Theory of Grammar. </title> <booktitle> CSLI Lecture Notes, Number 16. Stanford: Center for the Study of Language and Information, </booktitle> <year> 1988. </year>
Reference-contexts: Mark Johnson then enriched the descriptive apparatus with classical negation and showed that the feature calculus is a decidable subset of first-order predicate logic <ref> [ Johnson 88 ] </ref> .
Reference: [ Karttunen 84 ] <author> Lauri Karttunen. </author> <title> Features and Values. </title> <booktitle> In: Proceedings of the 10th International Conference on Computational Linguistics, COLING-84, </booktitle> <pages> pp. 28-33, </pages> <year> 1984. </year>
Reference-contexts: Pereira and Shieber were the first to give a mathematical reconstruction of PATR-II in terms of a denotational semantics [ Pereira & Shieber 84 ] . 3 The work of Karttunen led to major extensions of PATR-II, concerning disjunction, atomic negation, and the use of cyclic structures <ref> [ Karttunen 84 ] </ref> .
Reference: [ Kasper & Rounds 86 ] <author> Robert T. Kasper and William C. </author> <title> Rounds. A Logical Semantics for Feature Structures. </title> <booktitle> In: Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pp. 257-266, </pages> <year> 1986. </year>
Reference-contexts: Kasper and Rounds' seminal work <ref> [ Kasper & Rounds 86; Rounds & Kasper 86 ] </ref> is important in many respects: it clarified the connection between feature structures and finite automata, gave a logical characterization of the notion of disjunction, and presented complexity results for the first time (see [ Kasper & Rounds 90 ] for a
Reference: [ Kasper & Rounds 90 ] <author> Robert T. Kasper and William C. </author> <title> Rounds. The Logic of Unification in Grammar. </title> <journal> Linguistics and Philosophy, </journal> <volume> 13 </volume> <pages> 35-58, </pages> <year> 1990. </year> <note> 50 REFERENCES </note>
Reference-contexts: Kasper and Rounds' seminal work [ Kasper & Rounds 86; Rounds & Kasper 86 ] is important in many respects: it clarified the connection between feature structures and finite automata, gave a logical characterization of the notion of disjunction, and presented complexity results for the first time (see <ref> [ Kasper & Rounds 90 ] </ref> for a summary). Mark Johnson then enriched the descriptive apparatus with classical negation and showed that the feature calculus is a decidable subset of first-order predicate logic [ Johnson 88 ] .
Reference: [ Kay 79 ] <author> Martin Kay. </author> <title> Functional Grammar. </title> <editor> In: C. Chiarello et al. (ed.), </editor> <booktitle> Proceedings of the 5th Annual Meeting of the Berkeley Linguistics Society, </booktitle> <pages> pp. 142-158, </pages> <institution> Berkeley, Cal, </institution> <year> 1979. </year>
Reference-contexts: Kay's Functional Grammar <ref> [ Kay 79 ] </ref> represents the first formalism in the unification paradigm and is the predecessor of strictly lexicalized approaches like FUG [ Kay 85 ] , HPSG [ Pollard & Sag 87; Pollard & Sag 94 ] and UCG [ Moens et al. 89 ] .
Reference: [ Kay 85 ] <author> Martin Kay. </author> <title> Parsing in Functional Unification Grammar. </title> <editor> In: David R. Dowty, Lau-ri Karttunen, and Arnold M. Zwicky (eds.), </editor> <booktitle> Natural Language Parsing. Psychological, Computational, and Theoretical Perspectives, chapter 7, </booktitle> <pages> pp. 251-278. </pages> <address> Cambridge: </address> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: Kay's Functional Grammar [ Kay 79 ] represents the first formalism in the unification paradigm and is the predecessor of strictly lexicalized approaches like FUG <ref> [ Kay 85 ] </ref> , HPSG [ Pollard & Sag 87; Pollard & Sag 94 ] and UCG [ Moens et al. 89 ] .
Reference: [ Keller 93 ] <author> Bill Keller. </author> <title> Feature Logics, Infinitary Descriptions and Grammar. </title> <booktitle> CSLI Lecture Notes, Number 44. Stanford: Center for the Study of Language and Information, </booktitle> <year> 1993. </year>
Reference-contexts: Finally, Gert Smol-ka's work gave a fresh impetus to the whole field: his approach is distinguished from oth 2 [ Shieber 86 ] and [ Uszkoreit 88 ] are excellent introductions to unification-based grammar theories. <ref> [ Keller 93 ] </ref> investigates different characterizations of feature logics and compares them. [ Pereira 87 ] makes the connection between unification-based grammar formalisms and logic programming explicit. [ Knight 89 ] gives an overview of the different fields in computer science which make use of the notion of unification. 3
Reference: [ Kiefer & Fettig 94 ] <author> Bernd Kiefer and Thomas Fettig. </author> <title> FEGRAMED|An Interactive Graphics Editor for Feature Structures. </title> <type> Technical report, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: 43 By using the type grapher of TDL, we can depict the type hierarchy for this special type system (recall that thick lines indicates a disjunctive specification): 44 B SAMPLE SESSIONS Expanding w (see sample session above) leads to the following feature structure|notice that we choose the feature editor FEGRAMED <ref> [ Kiefer & Fettig 94 ] </ref> as the visualization tool (certain attributes are hidden). Another way to have access to this structure would be to employ the TDL2L a T E X tool of T DL (see [ Krieger & Schafer 94a ] ).
Reference: [ Kiefer & Scherf 94 ] <author> Bernd Kiefer and Oliver Scherf. </author> <title> Gimme more HQ Parsers. The Generic Parser Class of DISCO. </title> <type> Technical report, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: Grammars and lexicons written in TDL can be tested by using the DISCO parser. The parser is a bidirectional bottom-up chart parser, providing a user with parameterized parsing strategies as well as control over the processing of individual rules <ref> [ Kiefer & Scherf 94 ] </ref> . The core machinery of DISCO consists of TDL (see below) and the feature constraint solver UDiNe [ Backofen & Weyers 94 ] . UDiNe itself is a powerful untyped unification machine which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: [ King 89 ] <author> Paul J. King. </author> <title> A Logical Formalism for Head-Driven Phrase Structure Grammar. </title> <type> PhD thesis, </type> <institution> University of Manchester, Department of Mathematics, </institution> <year> 1989. </year>
Reference-contexts: Later, [ Smolka 89 ] explained that the undecidability result is due to the use of coreference constraints. Paul King's work aimed to reconstruct a special grammar theory, viz., HPSG, in mathematical terms <ref> [ King 89 ] </ref> , whereas Backofen and Smolka's treatment bridged the gap between logic programming and unification-based grammar formalisms [ Backofen & Smolka 92 ] .
Reference: [ Knight 89 ] <author> Kevin Knight. </author> <title> Unification: A Multidisciplinary Survey. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(1) </volume> <pages> 93-124, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: approach is distinguished from oth 2 [ Shieber 86 ] and [ Uszkoreit 88 ] are excellent introductions to unification-based grammar theories. [ Keller 93 ] investigates different characterizations of feature logics and compares them. [ Pereira 87 ] makes the connection between unification-based grammar formalisms and logic programming explicit. <ref> [ Knight 89 ] </ref> gives an overview of the different fields in computer science which make use of the notion of unification. 3 Pereira and Shieber's work was novel in that they made a distinction between descriptions and described objects, which seems to date back to the early work in LFG.
Reference: [ Krieger & Schafer 93a ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|A Type Description Language for Unification-Based Grammars. </title> <booktitle> In: Proceedings of the Workshop on "Neuere Entwicklungen der Deklarativen KI-Programmierung", </booktitle> <address> KI-93, Berlin, </address> <year> 1993. </year>
Reference: [ Krieger & Schafer 93b ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDLExtraLight User Guide. </title> <type> Technical Report D-93-09, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany, </institution> <year> 1993. </year>
Reference-contexts: Work on T DL started at the end of 1988 in the DISCO project of the DFKI and led to T DLExtraLight , the predecessor of TDL <ref> [ Krieger & Schafer 93b ] </ref> . The DISCO grammar currently consists of more than 900 type specifications written in T DL and is the largest HPSG grammar for German [ Netter 93 ] . Grammars and lexicons written in TDL can be tested by using the DISCO parser.
Reference: [ Krieger & Schafer 94a ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|A Type Description Language for HPSG. Part 2: User Guide. </title> <type> Technical report, </type> <institution> Deutsches Forschungszen-trum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: Note that recursive types can be substituted by definite relations (equivalences), as is the case for CUF, such that parsing/generation roughly corresponds to SLD resolution. 8 A more practice-oriented introduction to TDL is <ref> [ Krieger & Schafer 94a ] </ref> . <p> We also plan to extend the grammar development environment with other useful tools, e.g., a classifier (cf. <ref> [ Krieger & Schafer 94a ] </ref> for a description of the current status). Moreover, providing a classifier allow us to incorporate T DL in other areas of knowledge representation which are currently handled exclusively by terminological/KL-ONE-like languages. 39 The T DL syntax is given in extended BNF (Backus-Naur Form). <p> Another way to have access to this structure would be to employ the TDL2L a T E X tool of T DL (see <ref> [ Krieger & Schafer 94a ] </ref> ).
Reference: [ Krieger & Schafer 94b ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|A Type Description Language for Constraint-Based Grammars. </title> <booktitle> In: Proceedings of the 15th International Conference on Computational Linguistics, COLING-94, </booktitle> <address> Kyoto, Japan, </address> <pages> pp. 893-899, </pages> <year> 1994. </year>
Reference: [ Krieger et al. 93 ] <author> Hans-Ulrich Krieger, John Nerbonne, and Hannes Pirker. </author> <title> Feature-Based Allomorphy. </title> <booktitle> In: Proceedings of the 31st Annual Meeting of the Association for Computational Linguistics, </booktitle> <year> 1993. </year> <note> A version of this paper is available as DFKI Research Report RR-93-28. REFERENCES 51 </note>
Reference-contexts: An instance of such a recursive type, where expansion will terminate, is the recursive version of list, as defined below. 3.4.4.4 Example In the following, we define a finite state machine <ref> [ Krieger et al. 93 ] </ref> with two states that accepts the language a fl (a + b). The input is specified through a list under path input ; cf. the definition of type ab below. <p> The first one makes heavy use of At-Kaci's append encoding through types, the second one defines finite automata directly within T DL (see <ref> [ Krieger et al. 93 ] </ref> ).
Reference: [ Krieger 95 ] <author> Hans-Ulrich Krieger. </author> <title> TDL|A Type Description Language for Constraint-Based Grammars. Foundations, Implementation, and Applications. </title> <type> PhD thesis, </type> <institution> Universitat des Saarlandes, Department of Computer Science, </institution> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: definite equivalences), thus viewing T DL as just syntactic sugar for first-order predicate logic. 10 For instance, take the following feature description written as an attribute-value matrix: = 6 6 6 4 AGR x 6 agreement NUM sg PERS 3rd 3 5 SUBJ x 3 7 7 7 10 Cf. <ref> [ Krieger 95 ] </ref> for a precise description of the semantics of TDL, including a fixpoint characterization of recursive types. 12 3 T DL It is not hard to rewrite this two-dimensional description to a flat first-order formula, where attributes/features (e.g., AGR) are interpreted as binary predicate symbols and sorts (e.g., <p> sets of objects and the global 3.3 Symbolic Simplifier 17 b &gt; &gt; e := b ^ [p ]: bottom propagation ? fa;b;cg ? fa;b;cg as well as a ^ e ^ c will simplify to ? during processing. interpretation is determined by the intersection of the two sets (cf. <ref> [ Krieger 95 ] </ref> for a thorough investigation). Take for instance the type definitions A := [a 1] and B := [b 1], plus the user declaration ? = A ^ B, viz., that A and B are incompatible. <p> This means to delay the evaluation of a relation until the specified parameters are instantiated. 19 In both cases, there is, in general, more than one fixpoint, but it seems desirable to choose the greatest one; see <ref> [ Krieger 95 ] </ref> . 37 Our approach, which has been fully implemented as a stand-alone module, is novel in that it combines the benefits of these systems plus much more: * freely choose time of TE, e.g., during unification, parsing etc. * local as well as global control is possible
Reference: [ Laubsch 93 ] <author> Joachim Laubsch. Zebu: </author> <title> A Tool for Specifying Reversible LALR(1) Parsers. </title> <type> Technical report, </type> <institution> Hewlett-Packard, </institution> <year> 1993. </year>
Reference-contexts: This dichotomy is the analogue to the distinction between classes and instances in object-oriented programming languages. Input given to T DL is parsed by a Zebu-generated LALR (1) parser <ref> [ Laubsch 93 ] </ref> to allow for an intuitive, high-level input syntax and to abstract away from uninteresting details of the unifier and the underlying Lisp system.
Reference: [ Lloyd 87 ] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: This is because we could either choose extensions of feature logic [ Smolka 89 ] or directly interpret our structures within the paradigm of (constraint) logic programming <ref> [ Lloyd 87 ] </ref> . 3.4.4 Algorithm In this section, we explain the basic structure of our algorithm, extend it by a technique called indexed prototype memoization, describe the syntax of control information and (informally) the integration into the algorithm, and finally give an example. 17 The overall design of our
Reference: [ Michie 68 ] <author> Donald Michie. </author> <title> Memo Functions and Machine Learning. </title> <journal> Nature, </journal> <volume> 218(1) </volume> <pages> 19-22, </pages> <year> 1968. </year>
Reference-contexts: negate-fs ( = ht; ff 1 : : return h&gt;; fh:t; fgi; h&gt;; ff 1 "gi; h&gt;; ff 1 : = negate-fs ( 1 )gi; : : : ; h&gt;; ff n "gi; h&gt;; ff n = negate-fs ( n )gigi. 3.4.4.2 Indexed Prototype Memoization The basic idea of memoization <ref> [ Michie 68 ] </ref> is to tabulate results of function applications in order to prevent wasted calculations. The more expensive the computation of a value is, 3.4 Type Expansion and Control 29 the bigger the efficiency gain will be.
Reference: [ Moens et al. 89 ] <author> Marc Moens, Jo Calder, Ewan Klein, Mike Reape, and Henk Zeevat. </author> <title> Expressing generalizations in unification-based grammar formalisms. </title> <booktitle> In: Proceedings of the 4th EACL, </booktitle> <pages> pp. 174-181, </pages> <year> 1989. </year>
Reference-contexts: Kay's Functional Grammar [ Kay 79 ] represents the first formalism in the unification paradigm and is the predecessor of strictly lexicalized approaches like FUG [ Kay 85 ] , HPSG [ Pollard & Sag 87; Pollard & Sag 94 ] and UCG <ref> [ Moens et al. 89 ] </ref> .
Reference: [ Netter 93 ] <author> Klaus Netter. </author> <title> Architecture and Coverage of the DISCO Grammar. </title> <editor> In: S. Buse-mann and Karin Harbusch (eds.), </editor> <booktitle> Proceedings of the DFKI Workshop on Natural Language Systems: Modularity and Re-Usability, DFKI, </booktitle> <address> D-93-03, </address> <year> 1993. </year>
Reference-contexts: The DISCO grammar currently consists of more than 900 type specifications written in T DL and is the largest HPSG grammar for German <ref> [ Netter 93 ] </ref> . Grammars and lexicons written in TDL can be tested by using the DISCO parser.
Reference: [ Norvig 91a ] <author> Peter Norvig. </author> <booktitle> Paradigms of Artificial Intelligence Programming. </booktitle> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: y ! disjunction symbol string number disjunction 8i : x i &lt; NF y i true true true symbol false x &lt; lex y true true string false false x 1 &lt; lex y 1 true number false false false x &lt; y 3.3.5 Memoization The memoization technique described in <ref> [ Norvig 91b; Norvig 91a ] </ref> has been adapted in order to reuse precomputed results of type simplification.
Reference: [ Norvig 91b ] <author> Peter Norvig. </author> <title> Techniques for Automatic Memoization with Applications to Context-Free Parsing. </title> <journal> Computational Linguistics, </journal> <volume> 17(1) </volume> <pages> 91-98, </pages> <year> 1991. </year>
Reference-contexts: y ! disjunction symbol string number disjunction 8i : x i &lt; NF y i true true true symbol false x &lt; lex y true true string false false x 1 &lt; lex y 1 true number false false false x &lt; y 3.3.5 Memoization The memoization technique described in <ref> [ Norvig 91b; Norvig 91a ] </ref> has been adapted in order to reuse precomputed results of type simplification. <p> The time difference between the memoized and non-memoized algorithm may be even bigger if disjunctions are involved. The sample grammar contains only a few disjunctions. 18 One of the most impressing examples is the memoized fib function <ref> [ Norvig 91b ] </ref> (fib n returns the n-th Fibonacci number) which reduces exponential run-time to a simple table look-up for n once the value for a number n has been computed. 30 3 T DL algorithm depth-1st-expand types-1st-expand depth-1st-expand types-1st-expand memoization yes yes no no time (secs) 45 j 23
Reference: [ Pereira & Shieber 84 ] <author> Fernando C.N. Pereira and Stuart M. Shieber. </author> <title> The Semantics of Grammar Formalisms Seen as Computer Languages. </title> <booktitle> In: Proceedings of the 10th International Conference on Computational Linguistics, </booktitle> <pages> pp. 123-129, </pages> <year> 1984. </year>
Reference-contexts: Pereira and Shieber were the first to give a mathematical reconstruction of PATR-II in terms of a denotational semantics <ref> [ Pereira & Shieber 84 ] </ref> . 3 The work of Karttunen led to major extensions of PATR-II, concerning disjunction, atomic negation, and the use of cyclic structures [ Karttunen 84 ] .
Reference: [ Pereira 83 ] <author> Fernando C.N. Pereira. </author> <title> Parsing as Deduction. </title> <booktitle> In: Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pp. 137-144, </pages> <year> 1983. </year>
Reference-contexts: Again, type expansion is necessary to determine the global consistency of a given description. * recursive types Recursive types give a grammar writer the opportunity to formulate certain functions or relations as recursive type specifications. Working in the Parsing as Deduction <ref> [ Pereira 83 ] </ref> paradigm forces a grammar writer to replace the context-free backbone through recursive types.
Reference: [ Pereira 87 ] <author> Fernando C.N. Pereira. </author> <title> Grammars and Logics of Partial Information. </title> <editor> In: J.-L. Lassez (ed.), </editor> <booktitle> Proceedings of the 4th International Conference on Logic Programming, </booktitle> <volume> Vol. 2, </volume> <pages> pp. 989-1013, </pages> <year> 1987. </year>
Reference-contexts: Finally, Gert Smol-ka's work gave a fresh impetus to the whole field: his approach is distinguished from oth 2 [ Shieber 86 ] and [ Uszkoreit 88 ] are excellent introductions to unification-based grammar theories. [ Keller 93 ] investigates different characterizations of feature logics and compares them. <ref> [ Pereira 87 ] </ref> makes the connection between unification-based grammar formalisms and logic programming explicit. [ Knight 89 ] gives an overview of the different fields in computer science which make use of the notion of unification. 3 Pereira and Shieber's work was novel in that they made a distinction between
Reference: [ Pollard & Moshier 90 ] <author> Carl J. Pollard and M. Drew Moshier. </author> <title> Unifying Partial Descriptions of Sets. </title> <editor> In: P. Hanson (ed.), </editor> <title> Information, Language, </title> <journal> and Cognition. </journal> <volume> Vol. </volume> <booktitle> 1 of Vancou-ver Studies in Cognitive Science, </booktitle> <pages> pp. 285-322. </pages> <institution> University of British Columbia Press, </institution> <year> 1990. </year>
Reference-contexts: fixpoint over a particular continuous function. 19 The first approach is in general closer to an implementation (and thus to our algorithm) in that the function which is involved in the fixpoint construction corresponds more or less to the unification/substitution of TFS (see for instance [ At-Kaci 86 ] or <ref> [ Pollard & Moshier 90 ] </ref> ). The latter approach is based on the assumption that TFS are only syntactic sugar for first-order formulae.
Reference: [ Pollard & Sag 87 ] <author> Carl Pollard and Ivan A. Sag. </author> <title> Information-Based Syntax and Semantics. Vol. I: Fundamentals. </title> <booktitle> CSLI Lecture Notes, Number 13. Stanford: Center for the Study of Language and Information, </booktitle> <year> 1987. </year>
Reference-contexts: Kay's Functional Grammar [ Kay 79 ] represents the first formalism in the unification paradigm and is the predecessor of strictly lexicalized approaches like FUG [ Kay 85 ] , HPSG <ref> [ Pollard & Sag 87; Pollard & Sag 94 ] </ref> and UCG [ Moens et al. 89 ] . <p> Strictly speaking, lexicon entries can be seen as leaves in the type hierarchy which do not admit further subtypes (see also <ref> [ Pollard & Sag 87 ] </ref> , p. 198). This dichotomy is the analogue to the distinction between classes and instances in object-oriented programming languages.
Reference: [ Pollard & Sag 94 ] <author> Carl Pollard and Ivan A. Sag. </author> <title> Head-Driven Phrase Structure Grammar. </title> <booktitle> Studies in Contemporary Linguistics. </booktitle> <address> Chicago: </address> <publisher> University of Chicago Press, </publisher> <year> 1994. </year> <note> 52 REFERENCES </note>
Reference-contexts: Kay's Functional Grammar [ Kay 79 ] represents the first formalism in the unification paradigm and is the predecessor of strictly lexicalized approaches like FUG [ Kay 85 ] , HPSG <ref> [ Pollard & Sag 87; Pollard & Sag 94 ] </ref> and UCG [ Moens et al. 89 ] .
Reference: [ Reape 91 ] <author> Mike Reape. </author> <title> An Introduction to the Semantics of Unification-Based Grammar Formalisms. </title> <type> Technical Report Deliverable R3.2.A, </type> <institution> DYANA, Centre for Cognitive Science, University of Edinburgh, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: There exist only a few other proposals to feature descriptions nowadays which do not use standard first order logic directly, for instance Reape's approach, using a polymodal logic <ref> [ Reape 91 ] </ref> (see [ Blackburn 94 ] for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG [ Gazdar et al. 85 ] and PATR-II [ Shieber et al. 83 ] , as well as their successors CLE
Reference: [ Rounds & Kasper 86 ] <author> William C. Rounds and Robert T. Kasper. </author> <title> A Complete Logical Calculus for Record Structures Representing Linguistic Information. </title> <booktitle> In: Proceedings of the 15th Annual Symposium of the IEEE on Logic in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: Kasper and Rounds' seminal work <ref> [ Kasper & Rounds 86; Rounds & Kasper 86 ] </ref> is important in many respects: it clarified the connection between feature structures and finite automata, gave a logical characterization of the notion of disjunction, and presented complexity results for the first time (see [ Kasper & Rounds 90 ] for a
Reference: [ Rounds & Manaster-Ramer 87 ] <author> William C. Rounds and Alexis Manaster-Ramer. </author> <title> A Logical Version of Functional Grammar. </title> <booktitle> In: Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pp. 89-96, </pages> <year> 1987. </year>
Reference-contexts: Moreover, Smolka gave solutions to problems concerning the complexity and decidability of feature descriptions. Work by Rounds and Manaster-Ramer, however, showed that a Kasper-Rounds logic enriched with types (type definitions) leads to the undecidability of the satisfiability problem <ref> [ Rounds & Manaster-Ramer 87 ] </ref> . Later, [ Smolka 89 ] explained that the undecidability result is due to the use of coreference constraints. <p> the :attribute-preference list to define the "right" order for expansion. * Finally, one can define an appropriate :resolved-predicate that is suitable for a class of recursive types. 3.5 Theoretical Results It is worth noting that testing for the satisfiability of feature descriptions admitting recursive type equations/definitions is in general undecidable. <ref> [ Rounds & Manaster-Ramer 87 ] </ref> were the first to have shown that a Kasper-Rounds logic enriched with recursive types allows one to encode a Turing machine|hence, deciding satisafiability would imply that the Halting problem is decidable (which is obviously not).
Reference: [ Rupp et al. 94 ] <editor> C.J. Rupp, M.A. Rosner, and R.L. Johnson (eds.). </editor> <booktitle> Constraints, Language and Computation. Computation in Cognitive Science. </booktitle> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: a structure-building operation 2. rejecting inconsistent knowledge unification determines the satisfiability of a description 1.1 A Short History Martin Kay was the first person to lay out a generalized linguistic framework, called unification-based grammars , by introducing the notions of extension, unification, and generalization into computational linguistics (see overview in <ref> [ Rupp et al. 94 ] </ref> for a good introduction).
Reference: [ Russell et al. 92 ] <author> Graham Russell, Afzal Ballim, John Carroll, and Susan Warwick-Armstrong. </author> <title> A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons. </title> <journal> Computational Linguistics, </journal> <volume> 18(3) </volume> <pages> 311-337, </pages> <year> 1992. </year>
Reference-contexts: 94 ] for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG [ Gazdar et al. 85 ] and PATR-II [ Shieber et al. 83 ] , as well as their successors CLE [ Alshawi 92 ] and ELU <ref> [ Russell et al. 92 ] </ref> ), modern formalisms try to specify grammatical knowledge as well as lexicon entries entirely through feature structures.
Reference: [ Schafer 95 ] <author> Ulrich Schafer. </author> <title> Parametrizable Type Expansion for TDL. </title> <type> Master's thesis, </type> <institution> Uni-versitat des Saarlandes, Department of Computer Science, </institution> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: Clearly, atoms and types that possess no features are always expanded. The exploitation of these flags lead to a drastic reduction of the search space in the expansion algorithm. 17 A thorough description of the algorithm, its realization, and other related subjects are presented in <ref> [ Schafer 95 ] </ref> . 28 3 T DL 3.4.4.1 Basic Structure The following functions briefly sketch the basic algorithm. It is a destructive depth-first algorithm with a special treatment of recursive types that will be explained in Section ??. expand-tfs is the main function that initiates type expansion.
Reference: [ Shieber et al. 83 ] <author> Stuart Shieber, Hans Uszkoreit, Fernando Pereira, Jane Robinson, and Mabry Tyson. </author> <title> The Formalism and Implementation of PATR-II. </title> <editor> In: Barbara J. Grosz and Mark E. Stickel (eds.), </editor> <booktitle> Research on Interactive Acquisition and Use of Knowledge, </booktitle> <pages> pp. 39-79. </pages> <address> Menlo Park, </address> <institution> Cal.: AI Center, SRI International, </institution> <year> 1983. </year>
Reference-contexts: first order logic directly, for instance Reape's approach, using a polymodal logic [ Reape 91 ] (see [ Blackburn 94 ] for an overview). 1.2 Expressivity of Formalisms While the first unification-based approaches relied on annotated phrase structure rules (for instance GPSG [ Gazdar et al. 85 ] and PATR-II <ref> [ Shieber et al. 83 ] </ref> , as well as their successors CLE [ Alshawi 92 ] and ELU [ Russell et al. 92 ] ), modern formalisms try to specify grammatical knowledge as well as lexicon entries entirely through feature structures.
Reference: [ Shieber 86 ] <author> Stuart M. Shieber. </author> <title> An Introduction to Unification-Based Approaches to Grammar. </title> <booktitle> CSLI Lecture Notes, Number 4. Stanford: Center for the Study of Language and Information, </booktitle> <year> 1986. </year>
Reference-contexts: Mark Johnson then enriched the descriptive apparatus with classical negation and showed that the feature calculus is a decidable subset of first-order predicate logic [ Johnson 88 ] . Finally, Gert Smol-ka's work gave a fresh impetus to the whole field: his approach is distinguished from oth 2 <ref> [ Shieber 86 ] </ref> and [ Uszkoreit 88 ] are excellent introductions to unification-based grammar theories. [ Keller 93 ] investigates different characterizations of feature logics and compares them. [ Pereira 87 ] makes the connection between unification-based grammar formalisms and logic programming explicit. [ Knight 89 ] gives an overview
Reference: [ Smolka 88 ] <author> Gert Smolka. </author> <title> A Feature Logic with Subsorts. </title> <type> LILOG Report 33, </type> <institution> WT LILOG-IBM Germany, Stuttgart, </institution> <month> May </month> <year> 1988. </year> <note> Also in J. </note> <editor> Wedekind and C. Rohrer (eds.), </editor> <title> Unification in Grammar, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Moreover, they presented a fixpoint semantics for PATR-II (actually, they chose the least fixpoint) where PATR-II grammars are interpreted in the rational tree domain. 6 1 INTRODUCTION ers in that he presents a sorted set-theoretical semantics for feature structures <ref> [ Smolka 88; Smolka 89 ] </ref> . Moreover, Smolka gave solutions to problems concerning the complexity and decidability of feature descriptions. <p> Later, other operations came into play, viz., (classical) negation, or implication. Full negation, however, can be seen as an input macro facility because it can be expressed through the use of disjunctions, negated coreferences, and negated atoms with the help of existential quantification as shown in <ref> [ Smolka 88 ] </ref> . <p> The kernel of T DL (and of most other monotonic systems) can be given a set-theoretical semantics along the lines of <ref> [ Smolka 88; Smolka 89 ] </ref> .
Reference: [ Smolka 89 ] <author> Gert Smolka. </author> <title> Feature Constraint Logic for Unification Grammars. </title> <type> IWBS Report 93, </type> <institution> IWBS, IBM Germany, Stuttgart, </institution> <month> November </month> <year> 1989. </year> <note> Also in Journal of Logic Programming, </note> <month> 12 </month> <pages> 51-87, </pages> <year> 1992. </year>
Reference-contexts: Moreover, they presented a fixpoint semantics for PATR-II (actually, they chose the least fixpoint) where PATR-II grammars are interpreted in the rational tree domain. 6 1 INTRODUCTION ers in that he presents a sorted set-theoretical semantics for feature structures <ref> [ Smolka 88; Smolka 89 ] </ref> . Moreover, Smolka gave solutions to problems concerning the complexity and decidability of feature descriptions. <p> Moreover, Smolka gave solutions to problems concerning the complexity and decidability of feature descriptions. Work by Rounds and Manaster-Ramer, however, showed that a Kasper-Rounds logic enriched with types (type definitions) leads to the undecidability of the satisfiability problem [ Rounds & Manaster-Ramer 87 ] . Later, <ref> [ Smolka 89 ] </ref> explained that the undecidability result is due to the use of coreference constraints. <p> The kernel of T DL (and of most other monotonic systems) can be given a set-theoretical semantics along the lines of <ref> [ Smolka 88; Smolka 89 ] </ref> . <p> This is because we could either choose extensions of feature logic <ref> [ Smolka 89 ] </ref> or directly interpret our structures within the paradigm of (constraint) logic programming [ Lloyd 87 ] . 3.4.4 Algorithm In this section, we explain the basic structure of our algorithm, extend it by a technique called indexed prototype memoization, describe the syntax of control information and (informally) <p> We adapt Smolka's treatment of negation to our TFS <ref> [ Smolka 89 ] </ref> . <p> Later, <ref> [ Smolka 89 ] </ref> argued that the undecidability result is due to the use of coreference constraints. He demonstrated his claim by encoding the word problem of Thue systems. Hence, our expansion mechanism is faced with the same result, viz., that expansion might not terminate.
Reference: [ Uszkoreit et al. 94 ] <author> Hans Uszkoreit, Rolf Backofen, Stephan Busemann, Abdel Kader Di-agne, Elizabeth A. Hinkelman, Walter Kasper, Bernd Kiefer, Hans-Ulrich Krieger, Klaus Netter, Gunter Neumann, Stephan Oepen, and Stephen P. Spackman. </author> <title> DISCO| An HPSG-based NLP System and its Application for Appointment Scheduling. </title> <booktitle> In: Proceedings of COLING-94, </booktitle> <address> Kyoto, Japan, </address> <pages> pp. 436-440, </pages> <year> 1994. </year>
Reference-contexts: The system as described in this paper has been fully implemented in Common Lisp and runs on various software/hardware platforms (Allegro CL, Lucid CL, Macintosh CL, CLisp). It has been integrated successfully into the DISCO environment <ref> [ Uszkoreit et al. 94 ] </ref> and is used at several places outside (e.g., CSLI, Stanford currently uses T DL for writing a large English HPSG grammar).
Reference: [ Uszkoreit 88 ] <author> Hans Uszkoreit. </author> <title> From Feature Bundles to Abstract Data Types: New Directions in the Representation and Processing of Linguistic Knowledge. </title> <editor> In: A. Blaser (ed.), </editor> <title> REFERENCES 53 Natural Language at the Computer|Contributions to Syntax and Semantics for Text Processing and Man-Machine Translation, </title> <journal> pp. </journal> <pages> 31-64. </pages> <address> Berlin: </address> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: Finally, Gert Smol-ka's work gave a fresh impetus to the whole field: his approach is distinguished from oth 2 [ Shieber 86 ] and <ref> [ Uszkoreit 88 ] </ref> are excellent introductions to unification-based grammar theories. [ Keller 93 ] investigates different characterizations of feature logics and compares them. [ Pereira 87 ] makes the connection between unification-based grammar formalisms and logic programming explicit. [ Knight 89 ] gives an overview of the different fields in
Reference: [ Uszkoreit 91 ] <author> Hans Uszkoreit. </author> <title> Strategies for Adding Control Information to Declarative Grammars. </title> <booktitle> In: Proceedings of the 29th Meeting of the ACL, </booktitle> <pages> pp. 237-245, </pages> <year> 1991. </year>
Reference-contexts: Working in the Parsing as Deduction [ Pereira 83 ] paradigm forces a grammar writer to replace the context-free backbone through recursive types. Here, parameterized delayed type expansion is the key to controlled linguistic deduction <ref> [ Uszkoreit 91 ] </ref> ; see Section 3.4. 3 T DL TDL is a unification-based grammar development environment and run time system supporting HPSG-style grammars. <p> However, [ Zajac 92 ] has shown that type expansion without sophisticated control strategies is in many cases inefficient and moreover does not guarantee termination. 3.4.2 Controlled Type Expansion Uszkoreit introduced in <ref> [ Uszkoreit 91 ] </ref> a new strategy for linguistic processing called controlled linguistic deduction. His approach permits the specification of linguistic performance models without giving up the declarative basis of linguistic competence, especially monotonicity and completeness. The evaluation of both conjunctive and disjunctive constraints can be controlled in this framework. <p> B :Expanded NIL) [] Which alternative in G under path X should be expanded next (1, 2, or 0 to leave them unexpanded, or :all to expand all alternatives in this order, or :quiet to continue without asking again in G) ? _ * :use-fconj j disjg-heuristics ft j nilg <ref> [ Uszkoreit 91 ] </ref> suggested the exploitation of numerical preference information for features and disjunctions to speed up unification.
Reference: [ Wahlster 93 ] <author> Wolfgang Wahlster. </author> <title> VERBMOBIL|Translation of Face-to-Face Dialogs. </title> <institution> Research Report RR-93-34, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DF-KI), Saarbrucken, Germany, </institution> <year> 1993. </year> <note> Also appeared in: </note> <institution> MT Summit IV, </institution> <address> Kobe, Japan, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Other extensions of the system will concern the type expansion mechanism. We are planning to provide additional expansion strategies and to realize the expansion mechanism as a true anytime module <ref> [ Wahlster 93 ] </ref> (implemented as a separate process), so that it can be interrupted and restarted from the outside. We also plan to extend the grammar development environment with other useful tools, e.g., a classifier (cf. [ Krieger & Schafer 94a ] for a description of the current status).
Reference: [ Zajac 92 ] <author> Remi Zajac. </author> <title> Inheritance and Constraint-Based Grammar Formalisms. </title> <journal> Computational Linguistics, </journal> <volume> 18(2) </volume> <pages> 159-182, </pages> <year> 1992. </year>
Reference-contexts: Other proposals considered the integration of functional and relational dependencies into formalisms which makes them Turing-complete in general. 4 However the most important extension to formalisms consists in the incorporation of types , for instance in modern systems like TFS <ref> [ Emele & Zajac 90; Zajac 92 ] </ref> , CUF [ Dorre & Eisele 91; Dorre & Dorna 93 ] , or TDL [ Krieger & Schafer 93a; Krieger & Schafer 94a; Krieger & Schafer 94b ] . 5 Types are ordered hierarchically (via subsumption) as in object-oriented programming languages. <p> However, <ref> [ Zajac 92 ] </ref> has shown that type expansion without sophisticated control strategies is in many cases inefficient and moreover does not guarantee termination. 3.4.2 Controlled Type Expansion Uszkoreit introduced in [ Uszkoreit 91 ] a new strategy for linguistic processing called controlled linguistic deduction. <p> Our algorithm is independent of the underlying deduction system|we are not interested in the normalization of feature constraints (i.e., how unification of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower bound is obligatory (TFS <ref> [ Zajac 92 ] </ref> ; ALE [ Carpenter & Penn 94 ] ) or optional as in T DL. We assume here that typed unification is simply a black box and can be accessed through an interface function (say unify-tfs ). <p> Another way one might pursue is to integrate type expansion into the typed unification process so that it can take place at run time. Systems that explore this strategy are TFS <ref> [ Zajac 92 ] </ref> and LIFE [ At-Kaci 93 ] . However, both implementations are not lazy, thus hard to control and moreover, might not terminate. <p> preference information can be employed * prototype memoization speeds up processing 4 Comparison to other Systems TDL is unique in that it implements many novel features not found in other systems like ALE [ Carpenter & Penn 94 ] , LIFE [ At-Kaci et al. 93 ] , or TFS <ref> [ Zajac 92 ] </ref> .
References-found: 67

