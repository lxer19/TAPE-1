URL: http://www.cs.utexas.edu/users/moore/publications/symsim.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/publications/symsim-script/index.html
Root-URL: 
Email: moore@cs.utexas.edu  
Title: Symbolic Simulation: an ACL2 Approach  
Author: J Strother Moore 
Address: Austin, TX 78712-1188  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: Executable formal specification can allow engineers to test (or simulate) the specified system on concrete data before the system is implemented. This is beginning to gain acceptance. A largely unexplored but potentially very useful next step is symbolic simulation, the "execution" of the formal specification on indeterminant data. With the right interface, this need not require much additional training of the engineers using the tool. It allows many tests to be collapsed into one. Furthermore, it familiarizes the working engineer with the abstractions and notation used in the design, thus allowing team members to speak clearly to one another. We illustrate these ideas with a formal specification of a simple computing machine in ACL2. We sketch some requirements on the interface, which we call a symbolic spreadsheet. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W. R. Bevier, W. A. Hunt, J S. Moore and W. D. Young. </author> <note> Special Issue on System Verification Journal of Automated Reasoning 5(4), </note> <year> 1989. </year>
Reference-contexts: The comments explain how it works. (TIMES (MOVI 2 0) ; 0 mem [2] &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem <ref> [1] </ref> + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)) ; 5 return to caller If called with two naturals i and j in memory locations 0 and 1, the program leaves i fi j in memory <p> We use fi to denote the state above. Recall the TIMES program : (TIMES (MOVI 2 0) ; 0 mem [2] &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem <ref> [1] </ref> + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)))) ; 5 return to caller What is the result if we start a simulation on fi and run for 4 steps? Assume that i and j are <p> A symbolic simulation capability is basically a first step in any ACL2 project aimed at code proofs and our ideas for how to harness the simplifier in this capacity have been developed by many, especially those who participated in the CLI "short stack" work <ref> [1] </ref> and its extensions, including Bill Bevier, Bob Boyer, Bishop Brock, Art Flatau, Warren Hunt, Matt Kaufmann, Matt Wilding, and Bill Young. I am especially indebted to Warren Hunt and Bishop Brock for the current view of the symbolic spreadsheet.
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> Mechanized Formal Reasoning about Programs and Computing Machines. </title> <editor> In R. Veroff (ed.), </editor> <booktitle> Automated Reasoning and Its Applications: Essays in Honor of Larry Wos, </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: How might we formalize such a machine in ACL2? The most commonly used approach is described in <ref> [2] </ref>. That paper and the corresponding ACL2 script containing all of the definitions and theorems mentioned here are available at http://www.cs.utexas.edu/users/moore/publications. We only sketch the formal model here. We represent the state of the machine as a 5-tuple. <p> Using evaluation you can test the system specification. Below we show a particular program in the sm language. The program is named TIMES and it computes the product of two natural numbers by repeated addition. The comments explain how it works. (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)) ; 5 return to <p> The comments explain how it works. (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)) ; 5 return to caller If called with two naturals i and j in memory locations 0 and 1, the program leaves i fi <p> The comments explain how it works. (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)) ; 5 return to caller If called with two naturals i and j in memory locations 0 and 1, the program leaves i fi j in memory location 2 and <p> It takes a lot of expertise to develop books. It is not unlike trying to teach a new class. A lot of material must be organized in ways that, when done, seem obvious; but many other, less-effective organizations are available and have to be considered. In <ref> [2] </ref> we describe such a book for sm. <p> Even with well-designed books, proving theorems like this requires a certain amount of training in how to use the book, how to approach the proof at a high level, and how to interact with ACL2. We explain some of the techniques used in <ref> [2] </ref>. What ACL2 can achieve in the hands of an expert is illustrated by David Russinoff's work in [9]. Russinoff used ACL2 to check proofs of the correctness of the AMD-K7 TM hardware for floating-point addition, subtraction, multiplication, division and square root. <p> We use the variables i, j, x, y and z to denote those contents. We use fi to denote the state above. Recall the TIMES program : (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)))) ; 5 return to <p> We use fi to denote the state above. Recall the TIMES program : (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)))) ; 5 return to caller What is the result if we start a simulation on fi and run for 4 steps? Assume that i <p> We use fi to denote the state above. Recall the TIMES program : (TIMES (MOVI 2 0) ; 0 mem <ref> [2] </ref> &lt;- 0 (JUMPZ 0 5) ; 1 if mem [0]=0, go to 5 (ADD 2 1) ; 2 mem [2] &lt;- mem [1] + mem [2] (SUBI 0 1) ; 3 mem [0] &lt;- mem [0] - 1 (JUMP 1) ; 4 go to 1 (RET)))) ; 5 return to caller What is the result if we start a simulation on fi and run for 4 steps? Assume that i and j are natural numbers and <p> Actually, for this example to work the expression specifying the length of the run should be (cplus (times-clock i) 2). As noted in <ref> [2] </ref>, it is convenient to maintain an isolation between arithmetic expressions denoting run-lengths and other expressions, so the former can be used by user to control proof decomposition.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, Second Edition. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1997. </year>
Reference-contexts: The system I use is ACL2. "ACL2" stands for "A Computational Logic for Applicative Common Lisp" [4, 8]. It was developed by Matt Kaufmann and me as a successor to the Boyer-Moore theorem prover, Nqthm <ref> [3] </ref>.
Reference: 4. <author> B. Brock, M. Kaufmann, and J S. Moore. </author> <title> ACL2 Theorems about Commercial Microprocessors. </title> <booktitle> In Proceedings of Formal Methods in Computer-Aided Design (FM-CAD'96), </booktitle> <editor> M. Srivas and A. Camilleri (eds.), </editor> <publisher> Springer-Verlag, </publisher> <month> November, </month> <year> 1996, </year> <pages> pp. 275-293. </pages>
Reference-contexts: In the rest of this paper, I use one particular formal logic and theorem prover to illustrate the points just made. The system I use is ACL2. "ACL2" stands for "A Computational Logic for Applicative Common Lisp" <ref> [4, 8] </ref>. It was developed by Matt Kaufmann and me as a successor to the Boyer-Moore theorem prover, Nqthm [3]. <p> The sm example is so small that it does not illustrate an important point: ACL2's execution capability can handle much larger system designs. Indeed, on "well-typed" (i.e., "gold" definitions [8]), ACL2's execution capability is just Common Lisp. In <ref> [4] </ref> we discuss a project in which Bishop Brock used ACL2 to formalize the Motorola CAP digital signal processor [5]. A model similar to the one described here was used, but it was orders of magnitude more complex. From [4]: The CAP design follows the `Harvard architecture', i.e., there are separate <p> In <ref> [4] </ref> we discuss a project in which Bishop Brock used ACL2 to formalize the Motorola CAP digital signal processor [5]. A model similar to the one described here was used, but it was orders of magnitude more complex. From [4]: The CAP design follows the `Harvard architecture', i.e., there are separate program and data memories. The design includes 252 programmer-visible data and control registers. There are six independently addressable data and parameter memories. <p> The simple nature of the problem we tackled here may make some readers think this is an unrealistic proposal for designs of industrial scale. However, ACL2 has been used successfully to handle very large problems. Indeed, in the Motorola CAP work <ref> [4] </ref>, Brock used ACL2 in exactly the fashion described producing states that sometimes required several megabytes of text to print fully. ACL2's simplifier is up to the task. One of Brock's problems was how to glean information from such large symbolic states. The spreadsheet would help render such states surveyable.
Reference: 5. <author> S. Gilfeather, J. Gehman, and C. Harrison. </author> <title> Architecture of a Complex Arithmetic Processor for Communication Signal Processing in SPIE Proceedings, </title> <booktitle> International Symposium on Optics, Imaging, and Instrumentation, 2296 Advanced Signal Pro--cessing: Algorithms, Architectures, and Implementations V, </booktitle> <month> July, </month> <year> 1994, </year> <pages> pp. 624-625. </pages>
Reference-contexts: Indeed, on "well-typed" (i.e., "gold" definitions [8]), ACL2's execution capability is just Common Lisp. In [4] we discuss a project in which Bishop Brock used ACL2 to formalize the Motorola CAP digital signal processor <ref> [5] </ref>. A model similar to the one described here was used, but it was orders of magnitude more complex. From [4]: The CAP design follows the `Harvard architecture', i.e., there are separate program and data memories. The design includes 252 programmer-visible data and control registers.
Reference: 6. <author> D. A. Greve and M. M. </author> <title> Wilding Stack-based Java a back-to-future step", Electronic Engineering Times, </title> <journal> Jan. </journal> <volume> 12, </volume> <year> 1998, </year> <pages> pp. 92. </pages>
Reference-contexts: It is noteworthy that the 80 million test vectors failed to expose several errors in the design errors found by proof. ACL2 is currently being used in an experiment at Rockwell-Collins to construct an executable specification of their JEM1, the world's first silicon Java Virtual Machine <ref> [10, 6] </ref>.
Reference: 7. <author> M. Kaufmann. </author> <title> ACL2 Support for Verification Projects. </title> <booktitle> In 15th International Conference on Automated Deduction (CADE) (to appear, </booktitle> <year> 1998). </year>
Reference: 8. <author> M. Kaufmann and J S. Moore. </author> <title> An Industrial Strength Theorem Prover for a Logic Based on Common Lisp. </title> <journal> In IEEE Transactions on Software Engineering 23(4), </journal> <month> April, </month> <year> 1997, </year> <pages> pp. 203-213. </pages>
Reference-contexts: In the rest of this paper, I use one particular formal logic and theorem prover to illustrate the points just made. The system I use is ACL2. "ACL2" stands for "A Computational Logic for Applicative Common Lisp" <ref> [4, 8] </ref>. It was developed by Matt Kaufmann and me as a successor to the Boyer-Moore theorem prover, Nqthm [3]. <p> The sm example is so small that it does not illustrate an important point: ACL2's execution capability can handle much larger system designs. Indeed, on "well-typed" (i.e., "gold" definitions <ref> [8] </ref>), ACL2's execution capability is just Common Lisp. In [4] we discuss a project in which Bishop Brock used ACL2 to formalize the Motorola CAP digital signal processor [5]. A model similar to the one described here was used, but it was orders of magnitude more complex.
Reference: 9. <author> D. M. Russinoff. </author> <title> A Mechanically Checked Proof of IEEE Compliance of the Float ing Point Multiplication, Division, and Square Root Algorithms of the AMD-K7 TM Processor URL http://www.onr.com/user/russ/david/k7-div-sqrt.html. </title>
Reference-contexts: We explain some of the techniques used in [2]. What ACL2 can achieve in the hands of an expert is illustrated by David Russinoff's work in <ref> [9] </ref>. Russinoff used ACL2 to check proofs of the correctness of the AMD-K7 TM hardware for floating-point addition, subtraction, multiplication, division and square root. Using a translator written by Art Flatau, Russinoff translated AMD's HDL descriptions (at the RTL level) into ACL2 functions.
Reference: 10. <author> A. Wolfe. </author> <title> First Java-specific MPU Rolls Electronic Engineering Times, </title> <address> Sept 22, </address> <year> 1997, </year> <pages> pp. </pages> <month> 1. </month> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: It is noteworthy that the 80 million test vectors failed to expose several errors in the design errors found by proof. ACL2 is currently being used in an experiment at Rockwell-Collins to construct an executable specification of their JEM1, the world's first silicon Java Virtual Machine <ref> [10, 6] </ref>.
References-found: 10

