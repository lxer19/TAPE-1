URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/UW-CSE-94-02-05.PS.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: Identifying Profitable Specialization in Object-Oriented Languages  
Author: Jeffrey Dean, Craig Chambers, and David Grove 
Note: -jdean,chambers,grove-@cs.washington.edu  
Abstract: Department of Computer Science and Engineering, FR-35 University of Washington Seattle, Washington 98195 USA Technical Report 94-02-05 February 1994 
Abstract-found: 1
Intro-found: 1
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 [Nelson 91], and CLOS <ref> [Bobrow et al. 88] </ref>, dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: For example, an efficient implementation of Smalltalk-80 runs a suite of small benchmarks 5 to 10 times more slowly than does optimized C, in large part due to the overhead of dynamic binding <ref> [Chambers & Ungar 91] </ref>. Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 [Nelson 91], and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. <p> for GrowableHashTables, since [] never called any routines (directly or indirectly) where the knowledge that the receiver was a GrowableHashTable would have provided any additional benefit over knowing that it inherited from HashTable. 3 Previous Work Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF <ref> [Chambers & Ungar 91] </ref>, Trellis [Kilian 88], and Sather [Lim & Stolcke 91]. <p> We hope to have initial performance results shortly. 10 Identifying Profitable Specialization in Object-Oriented Languages UW-CS-TR-94-02-05 6 Related Work The implementations of SELF <ref> [Chambers & Ungar 91] </ref>, Trellis [Kilian 88], and Sather [Lim & Stolcke 91] use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Chambers 92a] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, report STAN-CS-92-1420, </institution> <month> March, </month> <year> 1992. </year>
Reference-contexts: This provides the compiler with additional information about the classes of the methods formal arguments, permitting messages sent to the formals to be statically bound and potentially inlined. This can greatly improve performance. For example, SELF programs run from 1.5 to 5 times faster as a result of specialization <ref> [Chambers 92a] </ref>. In this paper we present an algorithm that identifies automatically those points in the program where specialization is profitable using call graphs derived from dynamic profiles of the program. Section 2 provides an example motivating the benefits of specialization.
Reference: [Chambers 92b] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil <ref> [Chambers 92b] </ref>, dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Chang et al. 92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-Guided Automatic Inline Expansion for C Programs. </title> <booktitle> In SoftwarePractice and Experience 22(5), </booktitle> <pages> pp. 349-369, </pages> <month> May, </month> <year> 1992. </year>
Reference-contexts: Other compilation systems have exploited dynamic profiles to guide the application of optimizations, such as the Impact-C profile-guided inliner <ref> [Chang et al. 92] </ref>. * The Cecil implementation uses polymorphic inline caches (PICs) to speed dynamic dispatch [Hlzle et al. 91]. A PIC is a call-site-specific method lookup cache, mapping argument classes for a message send to the routine which should be invoked.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceeding of the 1992 IEEE International Conference on Computer Languages, </booktitle> <pages> pp. 96-105, </pages> <address> Oakland, CA, </address> <month> April, </month> <year> 1992. </year>
Reference-contexts: We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Kranser 83, Hlzle et al. 91]. Cooper, Hall, and Kennedy present a general framework for identifying when creating multiple, specialized copies of a procedure can provide additional information for solving dataow optimization problems <ref> [Cooper et al. 92] </ref>. Their work is similar to ours. Some of the differences are that they assume the existence of a program call graph and are focusing on improving information available for data dependence calculations, primarily through interprocedural constant propagation.
Reference: [Dean & Chambers 94] <author> Jeffrey Dean and Craig Chambers. </author> <title> Toward Better Inlining Decisions Using Inlining Trials. </title> <booktitle> To appear in Proceedings of the ACM Symposium on Lisp and Functional Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> June, </month> <year> 1994. </year> <note> An earlier version appears as technical report 93-05-05, </note> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> May, </month> <year> 1993. </year>
Reference-contexts: In particular, they do not account for the performance improvement due to post-specialization inlining. Our profitability metric can be extended to take these secondary effects into account by incorporating a persistent database that records the costs and benefits of inlining <ref> [Dean & Chambers 94] </ref>. Our algorithm identifies profitable places to specialize by examining the programs call graph.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Object-oriented languages are useful for implementing abstractions and structuring programs to be more extensible and maintainable. One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk <ref> [Goldberg & Robson 83] </ref>, Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Harnett & Montenyohl 92] <author> Sheila Harnett and Margaret Montenyohl. </author> <title> Towards Efficient Compilation of a Dynamic Object-Oriented Language. </title> <booktitle> In Proceedings of the 1992 Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 82-89, </pages> <address> San Francisco, CA, </address> <year> 1992. </year> <note> Published as Yale University Department of Computer Science Technical Report YALEU/DCS/RR-909. </note>
Reference-contexts: However, many dynamically-bound message sends still exist in the residual program. Other work focuses on reducing the overhead of dynamic dispatching in object-oriented programs, by partially evaluating the routines to perform method lookup with respect to the inheritance hiearchy of the program being executed <ref> [Khoo & Sundaresh 91, Harnett & Montenyohl 92] </ref>. We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Kranser 83, Hlzle et al. 91].
Reference: [Hlzle et al. 91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: Other compilation systems have exploited dynamic profiles to guide the application of optimizations, such as the Impact-C profile-guided inliner [Chang et al. 92]. * The Cecil implementation uses polymorphic inline caches (PICs) to speed dynamic dispatch <ref> [Hlzle et al. 91] </ref>. A PIC is a call-site-specific method lookup cache, mapping argument classes for a message send to the routine which should be invoked. <p> We rely on standard caching techniques to reduce the overhead of dynamic dispatching <ref> [Kranser 83, Hlzle et al. 91] </ref>. Cooper, Hall, and Kennedy present a general framework for identifying when creating multiple, specialized copies of a procedure can provide additional information for solving dataow optimization problems [Cooper et al. 92]. Their work is similar to ours.
Reference: [Kilian 88] <author> Michael F. Kilian. </author> <title> Why Trellis/Owl Runs Fast. </title> <type> Unpublished manuscript, </type> <month> March, </month> <year> 1988. </year>
Reference-contexts: called any routines (directly or indirectly) where the knowledge that the receiver was a GrowableHashTable would have provided any additional benefit over knowing that it inherited from HashTable. 3 Previous Work Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF [Chambers & Ungar 91], Trellis <ref> [Kilian 88] </ref>, and Sather [Lim & Stolcke 91]. Each of these systems has used a fairly simple-minded strategy to determine when to specialize a method: a method is always specialized on the exact class of the receiver, for all receiver classes, and never on anything else. <p> We hope to have initial performance results shortly. 10 Identifying Profitable Specialization in Object-Oriented Languages UW-CS-TR-94-02-05 6 Related Work The implementations of SELF [Chambers & Ungar 91], Trellis <ref> [Kilian 88] </ref>, and Sather [Lim & Stolcke 91] use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Khoo & Sundaresh 91] <author> Siau Cheng Khoo and R. S. Sundaresh. </author> <title> Compiling Inheritance using Partial Evaluation. </title> <booktitle> In Proceedings of the 1991 Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 211-222, </pages> <address> New Haven, CT, </address> <year> 1991. </year>
Reference-contexts: However, many dynamically-bound message sends still exist in the residual program. Other work focuses on reducing the overhead of dynamic dispatching in object-oriented programs, by partially evaluating the routines to perform method lookup with respect to the inheritance hiearchy of the program being executed <ref> [Khoo & Sundaresh 91, Harnett & Montenyohl 92] </ref>. We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Kranser 83, Hlzle et al. 91].
Reference: [Knuth 92] <author> Donald E. Knuth. </author> <title> Literate Programming. </title> <booktitle> Center for the Study of Language and Information - Lecture Notes Series, </booktitle> <year> 1992. </year>
Reference-contexts: The algorithm is presented below interspersed with discussion about its various pieces. The presentation is in the style of a literate program <ref> [Knuth 92] </ref>. When helpful, call graph diagrams illustrating the various situations which occur are presented. In these diagrams, pass-through edges are indicated as solid black lines, and non pass-through edges are shown as gray lines.
Reference: [Krasner 83] <author> Glenn Krasner, </author> <title> editor. Smalltalk-80: Bits of History, Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference: [Lea 90] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <pages> pp. 301-314, </pages> <address> San Francisco, CA, </address> <month> April, </month> <year> 1990. </year>
Reference-contexts: We are developing the algorithm in the context of a language based on multi-methods. Lea has explored the potential benefits of applying specialization in the C++ language <ref> [Lea 90] </ref>. For a simple matrix multiplication benchmark where the index function was dynamically bound, Lea calculated a potential speedup of around a factor 10 if the multiply routine were specialized to the particular matrix representations, thereby statically-binding the index call.
Reference: [Lim & Stolcke 91] <author> Chu-Cheow Lim and Andreas Stolcke. </author> <title> Sather Language Design and Performance Evaluation. </title> <type> Technical report TR-91-034, </type> <institution> International Computer Science Institute, </institution> <month> May, </month> <year> 1991. </year>
Reference-contexts: or indirectly) where the knowledge that the receiver was a GrowableHashTable would have provided any additional benefit over knowing that it inherited from HashTable. 3 Previous Work Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF [Chambers & Ungar 91], Trellis [Kilian 88], and Sather <ref> [Lim & Stolcke 91] </ref>. Each of these systems has used a fairly simple-minded strategy to determine when to specialize a method: a method is always specialized on the exact class of the receiver, for all receiver classes, and never on anything else. <p> We hope to have initial performance results shortly. 10 Identifying Profitable Specialization in Object-Oriented Languages UW-CS-TR-94-02-05 6 Related Work The implementations of SELF [Chambers & Ungar 91], Trellis [Kilian 88], and Sather <ref> [Lim & Stolcke 91] </ref> use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel <ref> [Meyer 92] </ref>, Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91] </ref>, and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis <ref> [Schaffert et al. 86] </ref>, SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ <ref> [Stroustrup 91] </ref>, Modula-3 [Nelson 91], and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF <ref> [Ungar & Smith 87] </ref>, and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
References-found: 21

