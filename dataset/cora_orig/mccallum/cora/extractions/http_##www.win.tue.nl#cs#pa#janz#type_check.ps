URL: http://www.win.tue.nl/cs/pa/janz/type_check.ps
Refering-URL: http://www.win.tue.nl/cs/pa/janz/publications.html
Root-URL: http://www.win.tue.nl
Email: e-mail janz@win.tue.nl  
Title: A Type System for Record Concatenation and Subtyping  
Author: Jan Zwanenburg 
Date: July 18, 1997  
Address: P.O.Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: We define a second-order type system with records, record concatenation and subtyping. The aim of this system is to model the most important concepts in object-oriented languages. The novelty in our approach is that record concatenation is controlled by a relation called compatibility. This relation is flexible enough to solve the polymorphic record update problem with concatenation, and restrictive enough to keep the theoretical properties relatively simple. In this article, we prove many of these properties and show that type checking is decidable. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> H. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In D. M. Gabbai, S. Abramsky, and T. S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: This defining property of OOP is called inheritance. It permits easily extensible software systems which is very important for programming in the real. Our goal is to model the most important concepts of OOP in the framework of the typed lambda-calculus (see for example <ref> [Bar92] </ref>), because it has well known semantics, proof-rules and typing rules, which are all (largely) missing in object-oriented languages. By such a model we hope to gain insight in these issues. But pure lambda calculus is not rich enough to model OOP.
Reference: [Car92] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <type> Technical Report 81, </type> <institution> DEC Systems Research Center, </institution> <year> 1992. </year> <month> 30 </month>
Reference-contexts: Therefore more powerful explicitly typed calculi were defined. Most introduced a form of disjoint concatenation (only new fields may be added), and a way of restricting records (removing a field). Together these operations can provide a polymorphic update. But the ones that include subtyping <ref> [CM91, Car92] </ref> have no full record concatenation, just extension. Alternatives that do have record concatenation [HP91], do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent record types.
Reference: [CD78] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> A new type assignment for -terms. </title> <journal> Archiv Math. Logik, </journal> <volume> 19 </volume> <pages> 139-156, </pages> <year> 1978. </year>
Reference-contexts: Note that (-Conc-L) and (-Conc-R) together imply that the With construct produces least upper bounds, which makes it quite similar to the intersection construct in <ref> [CD78] </ref>. Depth-subtyping is possible because of (-Depth). <p> In fact, our calculus is not even a proper extension of system F , since we have no general polymorphism. This could easily be fixed however, by adding the usual quantification construction. * The With construction has surprising similarities with the intersection type ^, as introduced in <ref> [CD78] </ref>. The main similarity is formed by the subtyping rules for With , which are a restricted version of the rules for ^. The restriction is that With is only defined on record types, whereas ^ is defined on all types.
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year>
Reference-contexts: Therefore more powerful explicitly typed calculi were defined. Most introduced a form of disjoint concatenation (only new fields may be added), and a way of restricting records (removing a field). Together these operations can provide a polymorphic update. But the ones that include subtyping <ref> [CM91, Car92] </ref> have no full record concatenation, just extension. Alternatives that do have record concatenation [HP91], do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent record types.
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Subtyping in F ! ^ is decidable. </title> <type> Technical Report ECS-LFCS 94-281, </type> <institution> LFCS, University of Edinburgh, </institution> <year> 1994. </year>
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and poly morphism. Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: In the domain of implicitly typed languages, Wand [Wan87] first defined a system of extensible records. This was later extended to include concatenation and the type-inference problem was solved [Wan89]. Cardelli and Wegner <ref> [CW85] </ref> defined a full second-order, explicitly typed language with records, subtyping and bounded quantification. This is an abstraction over a type variable that has to be a subtype of some type. However, this was not enough to solve the polymorphic record update problem. <p> Rather, we discuss the differences with the more general calculi F and F ^ , and with the previous version of F # , as it was defined in [Zwa95]. We also compare our work with the recent record calculus F width . * F , as defined in <ref> [CW85] </ref>, is the standard second order calculus for subtyping. It does not include record concatenation or record update, or a compatibility relation. Roughly spoken, F # is an extension of F . But there are two differences, both in the bounded quantification construction.
Reference: [FM94] <author> Kathleen Fisher and John Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In Proceedings of Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 844-885. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS 789. </note>
Reference-contexts: F ! (see [SP94]) and F ! should be applicable to our calculus as well. The full advantage of having record concatenation in our language becomes evident when modeling more complicated object oriented features, such as mixin classes (see <ref> [FM94] </ref>). An ordinary class always inherits from some fixed parent class, but in a mixin class, the class to be inherited from is a parameter. To achieve type safety, we have to demand that this parameter may be extended with certain fields.
Reference: [HP91] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <year> 1991. </year>
Reference-contexts: Together these operations can provide a polymorphic update. But the ones that include subtyping [CM91, Car92] have no full record concatenation, just extension. Alternatives that do have record concatenation <ref> [HP91] </ref>, do not have subtyping, which is necessary for a natural model of inheritance. Most problems are caused by type variables that represent record types. We present an explicitly typed calculus with subtyping and a powerful form of record concatenation.
Reference: [Pie91] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: The restriction is that With is only defined on record types, whereas ^ is defined on all types. The similarity between the two gave us the opportunity to base our subtyping algorithm on the algorithm for F ^ which was given in <ref> [Pie91] </ref>. However, our subtyping algorithm is considerably simpler, because of the restriction on With and the absence of distributivity rules. * The type system defined in this article is in spirit the same as the one defined in [Zwa95]. However, there are some technical differences.
Reference: [Pol97] <author> Erik Poll. </author> <title> System F with Width-subtyping and Record Updating. </title> <booktitle> In Theoretical Aspects of Computer Software (TACS'97), Sendai, </booktitle> <address> Japan. </address> <publisher> Springer LNCS, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: So we refrain from this rule here, for the sake of simplicity. * F width , introduced in <ref> [Pol97] </ref>, is a simple second order calculus which provides a polymorphic record update. It has one relation on types, viz. width-subtyping. As discussed earlier, this is exactly the intersection of our subtyping and compatibility relations.
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <year> 1994. </year>
Reference-contexts: The main results are a terminating type checking algorithm and a proof of the subject reduction property. The pragmatical side of this calculus is described in [Zwa95], where we give an encoding of objects, classes and inheritance in terms of records, subtyping and concatenation, along the lines of <ref> [PT94] </ref>. In section 2 we present the syntax and typing rules of our calculus F # . Section 3 gives an alternative set of typing rules, that are equivalent to the original rules, but syntax-directed. This set forms the typing algorithm. <p> Record concatenation in this calculus is flexible enough to make polymorphic record updates possible. This is an important building block in many object models, in particular the existential object model introduced in <ref> [PT94] </ref>. Another building block is the record concatenation itself because it can be used to extend records of methods, which is necessary to create a subclass. Most other recent calculi ignore this problem, suggesting a more ad-hoc solution for extension of records.
Reference: [SP94] <author> Martin Steffen and Benjamin C. Pierce. </author> <title> Higher-order subtyping. </title> <type> Technical Report ECS LFCS-94-280, </type> <institution> University of Edinburgh and Universitat Erlangen-Nurnberg, </institution> <year> 1994. </year>
Reference-contexts: It is easy to extend the syntax of our calculus with type-constructors, but giving a correct type-checking algorithm is more difficult, because of reduction on types. However, the techniques developed for other higher order calculi with subtyping, e.g. F ! (see <ref> [SP94] </ref>) and F ! should be applicable to our calculus as well. The full advantage of having record concatenation in our language becomes evident when modeling more complicated object oriented features, such as mixin classes (see [FM94]).
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1987. </year>
Reference-contexts: This is more powerful than record extension, and is necessary for multiple inheritance (where a class may have more than one superclass). In the domain of implicitly typed languages, Wand <ref> [Wan87] </ref> first defined a system of extensible records. This was later extended to include concatenation and the type-inference problem was solved [Wan89]. Cardelli and Wegner [CW85] defined a full second-order, explicitly typed language with records, subtyping and bounded quantification.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: In the domain of implicitly typed languages, Wand [Wan87] first defined a system of extensible records. This was later extended to include concatenation and the type-inference problem was solved <ref> [Wan89] </ref>. Cardelli and Wegner [CW85] defined a full second-order, explicitly typed language with records, subtyping and bounded quantification. This is an abstraction over a type variable that has to be a subtype of some type. However, this was not enough to solve the polymorphic record update problem.
Reference: [Zwa95] <author> Jan Zwanenburg. </author> <title> Record concatenation with intersection types. </title> <type> Technical Report 95-34, </type> <institution> Eindhoven University of Technology, </institution> <year> 1995. </year> <note> Web address: http://www.win.tue.nl/ win/cs/csr/csr95.html 31 </note>
Reference-contexts: This article concentrates on the meta-theoretical properties of this calculus. The main results are a terminating type checking algorithm and a proof of the subject reduction property. The pragmatical side of this calculus is described in <ref> [Zwa95] </ref>, where we give an encoding of objects, classes and inheritance in terms of records, subtyping and concatenation, along the lines of [PT94]. In section 2 we present the syntax and typing rules of our calculus F # . <p> k fl r 4 fl 1 =e 1 ; : : : l n1 =e n1 g:l k fl&gt; r where the last step uses the induction hypothesis. 2 5 Related work We will not discuss the differences between F # and other record calculi, as this is done in <ref> [Zwa95] </ref> in detail. Rather, we discuss the differences with the more general calculi F and F ^ , and with the previous version of F # , as it was defined in [Zwa95]. <p> We will not discuss the differences between F # and other record calculi, as this is done in <ref> [Zwa95] </ref> in detail. Rather, we discuss the differences with the more general calculi F and F ^ , and with the previous version of F # , as it was defined in [Zwa95]. We also compare our work with the recent record calculus F width . * F , as defined in [CW85], is the standard second order calculus for subtyping. It does not include record concatenation or record update, or a compatibility relation. <p> However, our subtyping algorithm is considerably simpler, because of the restriction on With and the absence of distributivity rules. * The type system defined in this article is in spirit the same as the one defined in <ref> [Zwa95] </ref>. However, there are some technical differences. First of all, the compatibility relation defined here is symmetrical. It turned out that this gives compatibility nicer properties and makes it much easier to give a decision algorithm for #. In [Zwa95], we had a rule for "specialized updating": ` U T (#-Sub) <p> article is in spirit the same as the one defined in <ref> [Zwa95] </ref>. However, there are some technical differences. First of all, the compatibility relation defined here is symmetrical. It turned out that this gives compatibility nicer properties and makes it much easier to give a decision algorithm for #. In [Zwa95], we had a rule for "specialized updating": ` U T (#-Sub) As a consequence of the symmetry of #, specialized update is no longer sound. 29 In [Zwa95], we had a rule for "recursive updating": ` T # U (#-Equal) This rule could be added to the system described here, <p> In <ref> [Zwa95] </ref>, we had a rule for "specialized updating": ` U T (#-Sub) As a consequence of the symmetry of #, specialized update is no longer sound. 29 In [Zwa95], we had a rule for "recursive updating": ` T # U (#-Equal) This rule could be added to the system described here, but makes a number of properties more complicated.
References-found: 15

