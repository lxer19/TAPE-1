URL: ftp://theory.lcs.mit.edu/pub/people/oded/testSU.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/test.html
Root-URL: 
Email: E-mail: oded@wisdom.weizmann.ac.il.  
Title: Combinatorial Property Testing (a survey)  
Author: Oded Goldreich Shafi Goldwasser and Dana Ron 
Note: Based mainly on joint work with  [17], and joint works with Dana Ron [19, 20]. Currently visiting LCS, MIT. Supported by DARPA grant DABT63-96-C-0018.  
Date: May 5, 1998  
Address: Rehovot, Israel.  
Affiliation: Department of Computer Science and Applied Mathematics Weizmann Institute of Science,  
Abstract: We consider the question of determining whether a given object has a predetermined property or is "far" from any object having the property. Specifically, objects are modeled by functions, and distance between functions is measured as the fraction of the domain on which the functions differ. We consider (randomized) algorithms which may query the function at arguments of their choice, and seek algorithms which query the function at relatively few places. We focus on combinatorial properties, and specifically on graph properties. The two standard representations of graphs by adjacency matrices and by incidence lists yield two different models for testing graph properties. In the first model, most appropriate for dense graphs, distance between N -vertex graphs is measured as the fraction of edges on which the graphs disagree over N 2 . In the second model, most appropriate for bounded-degree graphs, distance between N -vertex d-degree graphs is measured as the fraction of edges on which the graphs disagree over dN . To illustrate the two models, we survey results regarding the complexity of testing whether a graph is Bipartite. For a constant distance parameter, a constant number of queries suffice in the first model, whereas e fi( p N ) queries are necessary and sufficient in the second model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon and J.H. Spencer, </author> <title> The Probabilistic Method, </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1992. </year>
Reference-contexts: This is indeed the case, but proving it is less straightforward than it seems, the problem being that the i;j 's are not pairwise independent. Yet, since the sum of the covariances of the dependent i;j 's is quite small, Chebyshev's Inequality is still very useful (cf., <ref> [1, Sec. 4.3] </ref>).
Reference: [2] <author> S. Arora, D. Karger, and M Karpinski. </author> <title> Polynomial time approximation schemes for dense instances of NP-hard problems. </title> <booktitle> In Proceedings of the Twenty-Seventh Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 284-293, </pages> <year> 1995. </year>
Reference-contexts: This yields a constant time approximation scheme (i.e., to within any constant relative error) for dense graphs, improving over previous work of Arora et. al. <ref> [2] </ref> and de la Vega [13] who solved this problem in polynomial-time (i.e., in O (N 1=* 2 )-time and exp ( e O (1=* 2 )) N 2 -time, respectively). In the latter works the problem is solved by actually constructing approximate max-cuts.
Reference: [3] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and intractability of approximation problems. </title> <booktitle> In Proceedings of the Thirty-Third Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials <ref> [6, 7, 14, 4, 3] </ref> to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36]. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36].
Reference: [4] <author> S. Arora and S. Safra. </author> <title> Probabilistic checkable proofs: A new characterization of NP. </title> <booktitle> In Proceedings of the Thirty-Third Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 1-13, </pages> <year> 1992. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials <ref> [6, 7, 14, 4, 3] </ref> to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36].
Reference: [5] <author> M. Bellare, D. Coppersmith, J. H-astad, M. Kiwi, and M. Sudan. </author> <title> Linearity testing in characteristic two. </title> <booktitle> In Proceedings of the Thirty-Sixth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 432-441, </pages> <year> 1995. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36].
Reference: [6] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 3-40, </pages> <year> 1991. </year> <month> 12 </month>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials <ref> [6, 7, 14, 4, 3] </ref> to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36].
Reference: [7] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In Proceedings of the Twenty-Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in <ref> [7] </ref>, has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36]. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials <ref> [6, 7, 14, 4, 3] </ref> to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36].
Reference: [8] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs and applications to approximation. </title> <booktitle> In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36].
Reference: [9] <author> M. Bellare, O. Goldreich, and M. Sudan. </author> <title> Free bits, pcps and non-approximability towards tight results. </title> <booktitle> Extended abstract in Proceedings of the Thirty-Sixth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 422-431, </pages> <year> 1995. </year> <note> To appear in SICOMP. </note>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" <ref> [9, 22, 24, 36] </ref>. Much of the work cited above deals with the development and analysis of testers for algebraic properties; specifically, linearity, multi-linearity, and low-degree polynomials [10, 29, 6, 7, 14, 16, 34, 4, 3, 8, 11, 5]. <p> To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [9, 22, 23] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [10] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 549-595, </pages> <year> 1993. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking <ref> [10, 29, 16, 34] </ref> and probabilistically checkable proofs (pcp) [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24]. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [10, 34] </ref>, and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code.
Reference: [11] <author> M. Bellare and M. Sudan. </author> <title> Improved non-approximability results. </title> <booktitle> In Proceedings of the 26th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36].
Reference: [12] <author> B. Bollobas. </author> <title> Combinatorics. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Clearly, Algorithm 1 accepts every monotone function with probability 1. Establishing the fact that it rejects, with probability at least 2=3, any function which is *-far from being monotone was reduced in [18] to the following combinatorial lemma referring to the Boolean Lattice (cf., background in <ref> [12] </ref>). For each i, 0 i n, let L i f0; 1g n denote the set of n-bit long strings of weight i.
Reference: [13] <author> W. F. de la Vega. </author> <title> MAX-CUT has a randomized approximation scheme in dense graphs. </title> <note> To appear in Random Structures and Algorithms, </note> <year> 1994. </year>
Reference-contexts: This yields a constant time approximation scheme (i.e., to within any constant relative error) for dense graphs, improving over previous work of Arora et. al. [2] and de la Vega <ref> [13] </ref> who solved this problem in polynomial-time (i.e., in O (N 1=* 2 )-time and exp ( e O (1=* 2 )) N 2 -time, respectively). In the latter works the problem is solved by actually constructing approximate max-cuts.
Reference: [14] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the Thirty-Second Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials <ref> [6, 7, 14, 4, 3] </ref> to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" [9, 22, 24, 36].
Reference: [15] <author> A. Frieze and R. Kanan. </author> <title> The regularity lemma and approximation schemes for dense problems. </title> <booktitle> In Proceedings of the Thirty-Seventh Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 12-20, </pages> <year> 1996. </year>
Reference: [16] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the Twenty-Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking <ref> [10, 29, 16, 34] </ref> and probabilistically checkable proofs (pcp) [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24]. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function.
Reference: [17] <author> O. Goldreich, S. Goldwasser, and D. Ron. </author> <title> Property testing and its connection to learning and approximation. To appear in JACM. </title> <booktitle> Extended abstract in Proc. of the 37th IEEE Symp. on Foundation of Computer Science, </booktitle> <pages> pages 339-348, </pages> <year> 1996. </year> <note> Available as TR96-057 of ECCC , http://www.eccc.uni-trier.de/eccc/, 1996. </note>
Reference-contexts: 1 Introduction and Summary of Known Results The following general formulation of Property Testing was suggested in <ref> [17] </ref>: Let P be a fixed property of functions, and f be an unknown function. <p> One may also be allowed to query f on instances of one's choice. The above formulation is inspired by the PAC learning model [37]. In fact, property testing is related to variants of PAC learning as has been shown in <ref> [17] </ref>. The general formulation above allows the consideration of arbitrary distributions rather than uniform ones, and of testers which utilize only randomly chosen instances (rather than being able to query instances of their own choice). <p> Much of the work cited above deals with the development and analysis of testers for algebraic properties; specifically, linearity, multi-linearity, and low-degree polynomials [10, 29, 6, 7, 14, 16, 34, 4, 3, 8, 11, 5]. In contrast, following <ref> [17] </ref> we focus on testing combinatorial properties, and specifically on testing graph properties such as Bipartiteness. 1 Alternatively, one may consider a RAM model of computation, in which trivial manipulation of domain and range elements (e.g., reading/writing an element and comparing elements) is performed at unit cost. 1 The relevant parameters. <p> We demonstrate the difference between the two representations by considering the task of testing whether a graph is Bipartite. 1.2.1 Some known results in the first (i.e., adjacency predicate) representation Testers of complexity which depends only on the distance parameter, *, are known for several natural graph properties <ref> [17] </ref>. In particular, the following properties can be tested in query-complexity poly (1=*) and time complexity exp (poly (1=*)): * k-Colorability, for any fixed k 2. The query-complexity is poly (k=*), and for k = 2 the running-time is e O (1=* 3 ). <p> A tester for the general problem has been presented in <ref> [17] </ref> too. The algorithm uses e O (k 2 =*) 2k+O (1) queries, runs in time exponential in its query-complexity, and has two-sided error. <p> Going beyond the General Graph Partition Problem, we remark that there are graph properties which are very easy to test in this model (e.g., Connectivity, Hamiltonicity, and Planarity) <ref> [17] </ref>. <p> On the other hand, there are ("unnatural") graph properties in N P which are extremely hard to test; namely, any testing algorithm must inspect at least (N 2 ) of the vertex pairs <ref> [17] </ref>. In view of the above, we believe that providing a characterization of graph properties, according to the complexity of testing them, may be very challenging. <p> The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao [38], King [27] and Hajnal [21] culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the testing results of <ref> [17] </ref> mentioned above, by which some non-trivial monotone graph properties can be tested by examining a constant number of locations in the matrix. Application to the standard notion of approximation: The relation of testing graph properties to the standard notions of approximation is best illustrated in the case of Max-CUT. <p> Thus, for any constant * &gt; 0, using the above tester of <ref> [17] </ref>, we can approximate the size of the max-cut to within *N 2 in constant time. <p> In the latter works the problem is solved by actually constructing approximate max-cuts. Finding an approximate max-cut does not seem to follow from the mere existence of a tester for -cut; yet, as mentioned above, the tester in <ref> [17] </ref> can be used to find such a cut in time linear in N . Relation to "dual approximation" (cf., [25, 26]): To illustrate this relation, we consider the - Clique Tester mentioned above. <p> The bipartite tester is extremely simple: It selects a tiny, random set of vertices and checks whether the induced subgraph is bipartite. Algorithm 2 (Bipartite Tester in the first model <ref> [17] </ref>): On input N , d, * and oracle access to an adjacency predicate of an N -vertex graph, G = (V; E): 6 1. Uniformly select a subset of e O (1=* 2 ) vertices of V. 2. <p> Step (2) amounts to querying the predicate on all pairs of vertices in the subset selected at Step (1). As will become clear from the analysis, it actually suffice to query only e O (1=* 3 ) of these pairs. Theorem 2 <ref> [17] </ref>: Algorithm 2 is a Bipartite Tester (in the adjacency predicate representation). Furthermore, the algorithm always accepts a Bipartite graph, and in case of rejection it provides a witness of length poly (1=*) (that the graph is not bipartite). <p> More than half a dozen of these testers are interesting, and though they share some techniques, no general structure seems to arise. Some negative results in <ref> [17] </ref> seem to indicate that general results may be hard to obtain: For example, it was shown that there exist properties in N P which require high query complexity for testing. Also some properties are easy to test with one-sided error, whereas other require two-sided error to be tested efficiently. <p> Thus, obtaining "structural" results regarding easily testable properties may be very challenging as well as of great interest. Acknowledgments This survey is based mainly on joint work with Shafi Goldwasser and Dana Ron <ref> [17] </ref>, and joint works with Dana Ron [19, 20]. The subsection on testing monotonicity is based on a recent joint work with Shafi Goldwasser, Eric Lehman, and Dana Ron [18].
Reference: [18] <author> O. Goldreich, S. Goldwasser, E. Lehman, and D. Ron. </author> <title> Testing Monotinicity. </title> <type> Unpublished manuscript, </type> <year> 1998. </year>
Reference-contexts: Let w (x) denote the weight of x (i.e., the number of 1's in x). The following natural test of Monotonicity was suggested and analyzed in <ref> [18] </ref>. Algorithm 1 (Monotonicity Tester): Given n, * and oracle access to a function f : f0; 1g n 7! f0; 1g, repeat 2n 2 =* times: 1. Uniformly select x 2 f0; 1g n , and obtain the value f (x). 2. <p> If all iterations were completed without rejecting then accept. Clearly, Algorithm 1 accepts every monotone function with probability 1. Establishing the fact that it rejects, with probability at least 2=3, any function which is *-far from being monotone was reduced in <ref> [18] </ref> to the following combinatorial lemma referring to the Boolean Lattice (cf., background in [12]). For each i, 0 i n, let L i f0; 1g n denote the set of n-bit long strings of weight i. <p> Lemma 1.1 <ref> [18] </ref>: Let r and s be integers satisfying, 0 r &lt; s n, and let R; S f0; 1g n , be sets such that R L r , and S L s , and jRj = jSj = m. <p> Then there exist m vertex-disjoint directed paths from S to R in G n . We stress that these vertex-disjoint paths do not have to respect . In fact, if one requires these paths to respect then the lemma becomes false (cf., <ref> [18] </ref>). <p> Acknowledgments This survey is based mainly on joint work with Shafi Goldwasser and Dana Ron [17], and joint works with Dana Ron [19, 20]. The subsection on testing monotonicity is based on a recent joint work with Shafi Goldwasser, Eric Lehman, and Dana Ron <ref> [18] </ref>.
Reference: [19] <author> O. Goldreich and D. Ron. </author> <title> Property Testing in Bounded Degree Graphs. </title> <booktitle> In Proc. of the 29th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 406-415, </pages> <year> 1997. </year>
Reference-contexts: tasks is more important than the other: Each of these tasks may be relevant in some applications and irrelevant in others. 1.2.2 Some known results in the second (i.e., incidence function) representation Testers of complexity which depends only on the distance parameter, *, are known for several natural graph properties <ref> [19] </ref>. In particular, the following properties can be tested in time (and thus query-complexity) poly (d=*): * Connectivity. The tester runs in time e O (1=*). <p> Unlike all other algorithms, this algorithm has two-sided error probability, which is unavoidable for testing this property (within o ( N ) queries). The complexity of Bipartiteness testing is considered in Section 3. We survey an ( p N ) lower bound on the query complexity of any tester <ref> [19] </ref> and a recent result of [20] by which a natural algorithm of running time (and query complexity) e O (poly (1=*) p N ) is a good tester. <p> Theorem 3 <ref> [19] </ref>: Testing Bipartiteness (with constant * and d) requires ( p N ) queries (in the incidence function representation). Proof Idea: For any (even) N , we consider the following two families of graphs: 8 1. <p> Thus, obtaining "structural" results regarding easily testable properties may be very challenging as well as of great interest. Acknowledgments This survey is based mainly on joint work with Shafi Goldwasser and Dana Ron [17], and joint works with Dana Ron <ref> [19, 20] </ref>. The subsection on testing monotonicity is based on a recent joint work with Shafi Goldwasser, Eric Lehman, and Dana Ron [18].
Reference: [20] <author> O. Goldreich and D. Ron. </author> <title> A sublinear Bipartite Tester for Bounded Degree Graphs. </title> <booktitle> To appear in Proc. of the 30th ACM Symp. on Theory of Computing, </booktitle> <year> 1998. </year> <note> Available from http://theory.lcs.mit.edu/~oded/test.html. </note>
Reference-contexts: The complexity of Bipartiteness testing is considered in Section 3. We survey an ( p N ) lower bound on the query complexity of any tester [19] and a recent result of <ref> [20] </ref> by which a natural algorithm of running time (and query complexity) e O (poly (1=*) p N ) is a good tester. The lower bound stands in sharp contrast to the situation in the first model (i.e., representation by adjacency predicates), where Bipartite testing is possible in poly (1=*)-time. <p> Furthermore, the following natural algorithm constitutes a Bipartite tester of running time poly ((log N )=*) p Algorithm 3 (Bipartite Tester in the second model <ref> [20] </ref>): On input N , d, * and oracle access to an incidence function for an N -vertex graph, G = (V; E), of degree bound d, repeat T def * ) times: 1. <p> If the algorithm did not reject in any one of the above T iterations, then it accepts. Theorem 4 <ref> [20] </ref>: Algorithm 3 is a Bipartite Tester (in the incidence function representation). Furthermore, the algorithm always accepts a Bipartite graph, and in case of rejection it provides a witness of length poly ((log N )=*) (that the graph is not bipartite). Motivation the special case of rapid mixing graphs. <p> The claim follows. Beyond rapid mixing graphs. The proof in <ref> [20] </ref> refers to a more general sum of products; that is, v2V p odd (v)p even (v), where U V is an appropriate set of vertices, and p odd (v) (resp., p even (v)) is the probability that a random walk (starting at s) passes through v after more than L=2 <p> Much of the analysis in <ref> [20] </ref> goes into selecting the appropriate U (and an appropriate starting vertex s), and pasting together many such U's to cover all of V. <p> The actual argument of <ref> [20] </ref> proceeds in iterations. In each iteration a vertex s for which Step (2) accepts with high probability is fixed, and an appropriate set of remaining vertices, U, is found. The set U is then 2-partitioned so that there are few violating edges inside U. <p> Thus, obtaining "structural" results regarding easily testable properties may be very challenging as well as of great interest. Acknowledgments This survey is based mainly on joint work with Shafi Goldwasser and Dana Ron [17], and joint works with Dana Ron <ref> [19, 20] </ref>. The subsection on testing monotonicity is based on a recent joint work with Shafi Goldwasser, Eric Lehman, and Dana Ron [18].
Reference: [21] <author> P. Hajnal. </author> <title> An (n 4=3 ) lower bound on the randomized complexity of graph properties. </title> <journal> Com-binatorica, </journal> <volume> 11(2) </volume> <pages> 131-144, </pages> <year> 1991. </year> <month> 13 </month>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao [38], King [27] and Hajnal <ref> [21] </ref> culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the testing results of [17] mentioned above, by which some non-trivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
Reference: [22] <author> J. H-astad. </author> <title> Testing of the long code and hardness for clique. </title> <booktitle> In Proc. of the 28th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 11-19, </pages> <year> 1996. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" <ref> [9, 22, 24, 36] </ref>. Much of the work cited above deals with the development and analysis of testers for algebraic properties; specifically, linearity, multi-linearity, and low-degree polynomials [10, 29, 6, 7, 14, 16, 34, 4, 3, 8, 11, 5]. <p> To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [9, 22, 23] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [23] <author> J. H-astad. </author> <title> Clique is hard to approximate within n 1* . In Proc. </title> <booktitle> of the 37th IEEE Symp. on Foundation of Computer Science, </booktitle> <pages> pages 627-636, </pages> <year> 1996. </year>
Reference-contexts: To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [9, 22, 23] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [24] <author> J. H-astad. </author> <title> Getting optimal in-approximability results. </title> <booktitle> In Proc. of the 29th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1997. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking [10, 29, 16, 34] and probabilistically checkable proofs (pcp) <ref> [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24] </ref>. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" <ref> [9, 22, 24, 36] </ref>. Much of the work cited above deals with the development and analysis of testers for algebraic properties; specifically, linearity, multi-linearity, and low-degree polynomials [10, 29, 6, 7, 14, 16, 34, 4, 3, 8, 11, 5].
Reference: [25] <author> D. S. Hochbaum and D. B. Shmoys. </author> <title> Using dual approximation algorithms for scheduling problems: Theoretical and practical results. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 34(1) </volume> <pages> 144-162, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Finding an approximate max-cut does not seem to follow from the mere existence of a tester for -cut; yet, as mentioned above, the tester in [17] can be used to find such a cut in time linear in N . Relation to "dual approximation" (cf., <ref> [25, 26] </ref>): To illustrate this relation, we consider the - Clique Tester mentioned above. The traditional notion of approximating Max-Clique corresponds to distinguishing the case in which the max-clique has size at least N from, say, the case in which the max-clique has size at most N=2.
Reference: [26] <author> D. S. Hochbaum and D. B. Shmoys. </author> <title> A polynomial approximation scheme for machine scheduling on uniform processors: Using the dual approximation approach. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(3) </volume> <pages> 539-551, </pages> <year> 1988. </year>
Reference-contexts: Finding an approximate max-cut does not seem to follow from the mere existence of a tester for -cut; yet, as mentioned above, the tester in [17] can be used to find such a cut in time linear in N . Relation to "dual approximation" (cf., <ref> [25, 26] </ref>): To illustrate this relation, we consider the - Clique Tester mentioned above. The traditional notion of approximating Max-Clique corresponds to distinguishing the case in which the max-clique has size at least N from, say, the case in which the max-clique has size at most N=2.
Reference: [27] <author> V. King. </author> <title> An (n 5=4 ) lower bound on the randomized complexity of graph properties. </title> <journal> Combi-natorica, </journal> <volume> 11(1) </volume> <pages> 23-32, </pages> <year> 1991. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao [38], King <ref> [27] </ref> and Hajnal [21] culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the testing results of [17] mentioned above, by which some non-trivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
Reference: [28] <author> M. Kiwi. </author> <title> Probabilistically Checkable Proofs and the Testing of Hadamard-like Codes. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36].
Reference: [29] <author> R. J. Lipton. </author> <title> New directions in testing. </title> <type> Unpublished manuscript, </type> <year> 1989. </year>
Reference-contexts: Property testing (as just defined) emerges naturally in the context of program checking <ref> [10, 29, 16, 34] </ref> and probabilistically checkable proofs (pcp) [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24]. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function.
Reference: [30] <author> L. Lovasz and N. Young. </author> <title> Lecture notes on evasiveness of graph properties. </title> <type> Technical Report TR-317-91, </type> <institution> Princeton University, Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: Relation to recognizing graph properties: Our notion of testing a graph property P is a relaxation of the notion of deciding the graph property P which has received much attention in the last two decades <ref> [30] </ref>. In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it.
Reference: [31] <author> M. Mihail. </author> <title> Conductance and convergence of Markov chains A combinatorial treatment of expanders. </title> <booktitle> In Proceedings 30th Annual Symp. on Foundations of Computer Science, </booktitle> <pages> pages 526-531, </pages> <year> 1989. </year>
Reference-contexts: The selection is based on the "combinatorial treatment of expansion" of Mihail <ref> [31] </ref>.
Reference: [32] <author> A. L. Rosenberg. </author> <title> On the time required to recognize properties of graphs: A problem. </title> <journal> SIGACT News, </journal> <volume> 5 </volume> <pages> 15-16, </pages> <year> 1973. </year>
Reference-contexts: In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. In 1975 Rivest and Vuillemin [35] resolved the Aanderaa-Rosenberg Conjecture <ref> [32] </ref>, showing that any deterministic procedure for deciding any non-trivial monotone N -vertex graph property must examine (N 2 ) entries in the adjacency matrix representing the graph. The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ).
Reference: [33] <author> R. Rubinfeld. </author> <title> Robust functional equations and their applications to program testing. </title> <booktitle> In Proceedings of the 35th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1994. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference-contexts: However, we do not consider these latter generalizations here, but rather focus on the special case (formulated previously in <ref> [34, 33] </ref>) where the distribution is uniform on the domain of the function, and testers are allowed to query the function on instances of their choice. Thus, the above formulation simplifies to the following definition, in which we associate a property with the class of functions satisfying it.
Reference: [34] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characterization of polynomials with applications to program testing. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(2) </volume> <pages> 252-271, </pages> <year> 1996. </year>
Reference-contexts: However, we do not consider these latter generalizations here, but rather focus on the special case (formulated previously in <ref> [34, 33] </ref>) where the distribution is uniform on the domain of the function, and testers are allowed to query the function on instances of their choice. Thus, the above formulation simplifies to the following definition, in which we associate a property with the class of functions satisfying it. <p> Property testing (as just defined) emerges naturally in the context of program checking <ref> [10, 29, 16, 34] </ref> and probabilistically checkable proofs (pcp) [6, 7, 14, 4, 3, 8, 11, 5, 9, 22, 24]. Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> Specifically, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [10, 34] </ref>, and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code.
Reference: [35] <author> R. L. Rivest and J. Vuillemin. </author> <title> On recognizing graph properties from adjacency matrices. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 371-384, </pages> <year> 1976. </year>
Reference-contexts: In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. In 1975 Rivest and Vuillemin <ref> [35] </ref> resolved the Aanderaa-Rosenberg Conjecture [32], showing that any deterministic procedure for deciding any non-trivial monotone N -vertex graph property must examine (N 2 ) entries in the adjacency matrix representing the graph. The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ).
Reference: [36] <author> L. Trevisan. </author> <title> Recycling queries in PCPs and in linearity tests. </title> <booktitle> To appear in Proc. of the 30th ACM Symp. on Theory of Computing, </booktitle> <year> 1998. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes <ref> [3, 8, 11, 5, 28, 36] </ref>, and recently to testing the "long code" [9, 22, 24, 36]. <p> This paradigm, explicitly introduced in [7], has shifted from testing codes defined by low-degree polynomials [6, 7, 14, 4, 3] to testing Hadamard codes [3, 8, 11, 5, 28, 36], and recently to testing the "long code" <ref> [9, 22, 24, 36] </ref>. Much of the work cited above deals with the development and analysis of testers for algebraic properties; specifically, linearity, multi-linearity, and low-degree polynomials [10, 29, 6, 7, 14, 16, 34, 4, 3, 8, 11, 5].
Reference: [37] <author> L. G. Valiant. </author> <title> A theory of the learnable. </title> <journal> Communications of the ACM, </journal> <volume> 27(11) </volume> <pages> 1134-1142, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Towards this end, one is given examples of the form (x; f (x)), where x is distributed according to D. One may also be allowed to query f on instances of one's choice. The above formulation is inspired by the PAC learning model <ref> [37] </ref>. In fact, property testing is related to variants of PAC learning as has been shown in [17].
Reference: [38] <author> A. C. C. Yao. </author> <title> Lower bounds to randomized algorithms for graph properties. </title> <booktitle> In Proceedings of the Twenty-Eighth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 393-400, </pages> <year> 1987. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao <ref> [38] </ref>, King [27] and Hajnal [21] culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the testing results of [17] mentioned above, by which some non-trivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
References-found: 38

