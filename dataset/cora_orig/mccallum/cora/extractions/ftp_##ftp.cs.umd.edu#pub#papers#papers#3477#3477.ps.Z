URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3477/3477.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Slicing Real-Time Programs for Enhanced Schedulability on complex task interactions which are usually exposed at
Author: Richard Gerber and Seongsoo Hong 
Keyword: Real-time, programming languages, event-based semantics, compiler optimization, program slicing, system-tuning, static priority scheduling, priority assignment.  
Note: Correctness depends not only on each program individually, but also  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Email: rich@cs.umd.edu sshong@cs.umd.edu  
Phone: (301) 405-2710  
Date: April 25, 1995  
Abstract: In this paper we present an automated, compiler-based technique to help developers synthesize correct real-time systems. The domain we consider is that of multi-programmed real-time applications, in which periodic tasks control a physical systems via interacting with external sensors and actuators. While a system is up and running, these operations must be performed as specified otherwise the system may fail. We describe a static alternative to this process, which relies on well-accepted technologies from optimizing compilers and fixed-priority scheduling. Specifically, when an application is found to be overloaded, the scheduling component determines good candidate tasks to get transformed via program slicing. The slicing engine decomposes each of the selected tasks into two fragments: one that is "time-critical," and the other "unobservable." The unobservable part is then spliced to the end of the time-critical code, with the semantics being maintained. The benefit is that the scheduler may postpone the unobservable code beyond its original deadline, which can enhance overall schedulability. While the optimization is completely local, the improvement is realized globally, for the entire task set. fl This research is supported in part by ONR grant N00014-94-10228, NSF grant CCR-9209333, an NSF Young Investigator Award CCR-9357850. An earlier version of this paper appeared in preliminary form in the Proceedings of IEEE Real-Time System Symposium, (December 1993). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, R. DeMillo, and E. Spafford. </author> <title> Debugging with dynamic slicing and backtracking. </title> <journal> Software Practice and Experience, </journal> <volume> 23(6) </volume> <pages> 590-616, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: F5 and F6 with simple arithmetic operations. Figure 14 shows the transformed code that was generated by splicing the two slices together. 26 Implementation. The prototype implementation of TimeWare/SLICE is based on a dynamic program slicing tool SPYDER developed at the Purdue University <ref> [1] </ref>. SPYDER is a program debugging tool relying on dynamic slicing, and it consists of two components: a modified version of GCC (GNU C compiler) and GDB (GNU symbolic debugger).
Reference: [2] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1986. </year> <month> 28 </month>
Reference-contexts: A similar but more advanced approach was reported in [23]. While the latter approach is able to predict pipeline stalls as well, both essentially rely on attribute grammars <ref> [2] </ref> to propagate cache hit information backward in a flow graph. However, no static timing tool is precise enough to be used with complete confidence for developing production-quality software. Moreover, even sophisticated timing analysis methods such as [23, 31] are not appropriate for fine-grained instruction timing. <p> fhL1; datai; hL9; cmdig. 3.2 Slicing, Splicing and Timing Analysis Program slicing may easily increase worst-case execution times of tasks for a number of reasons: (1) control structures are replicated and will be executed twice; (2) splitting a basic block may increase the number of register load and store operations <ref> [2] </ref>; and (3) worst-case execution time paths of the two resultant subtasks may be incorrectly derived. We take a close look at the last factor, since it tends to take up the greatest portion of the increase, though it is mainly an artifact of overly-conservative timing prediction.
Reference: [3] <author> F. Allen, B. Rosen, and K. Zadeck. </author> <title> the forthcoming Optimization in Compilers. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: To do so, we can potentially use a code transformation algorithm such as the rename transformation in [7], the static single assignment (SSA) form translation in [6, 15]. In order to avoid loop-unrolling, we could potentially use dependence-breaking methods, e.g., scalar expansion <ref> [3] </ref>. However, it is practically impossible to massage a program into a form that is entirely free of false dependences, mainly due to the existence of aliases and pointers.
Reference: [4] <author> N. Audsley. </author> <title> Optimal priority assignment and feasibility of static priority tasks with arbitrary start times. </title> <type> Technical Report YCS 164, </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Most recently, a group of researchers at the University of York developed a set of analytical techniques which can provide schedulability tests for broad classes of tasks, including those whose deadlines are greater than their periods <ref> [4, 35, 33] </ref>.
Reference: [5] <author> A. Burns. </author> <title> Fixed priority scheduling with deadlines prior to completion. </title> <type> Technical Report YCS 212 (1993), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: In Section 3 we provide a technical treatment of program slicing that forms the crux of our transformation. In Section 4 we give an overview of new scheduling methods for the TCEL task model, concentrating on an algorithm that was recently developed for it by researchers at York <ref> [5] </ref>. 5 In Section 5 we put the analysis method to use and harness it in our own priority ordering algorithm. The algorithm decides which are the best tasks to get sliced, and determines the resulting priority order for the entire task set. <p> The dual-priority scheme mandates a dynamic priority-exchange mechanism, which in turn requires additional kernel support. So the following question arises: when can a set of transformed TCEL tasks be scheduled under a fully preemptive, static priority scheme? Burns <ref> [5] </ref> provides an answer to this question after identifying a simple, but essential fact about the TCEL task model. That is, whenever we let a task's deadline be greater than its period, this represents a relaxation of the classical rate-monotonic restrictions put forth in [25]. <p> In <ref> [5] </ref> Burns presents a search algorithm to generate the feasible static-priority order or to detect when no such order exists. Thus the approach includes the following components. Online Scheduler: This is a simple, preemptive dispatching mechanism, in which priority "ties" are broken in favor of the task dispatched first. <p> The priority assignment algorithm in <ref> [5] </ref> expects that all tasks in are sliced before they are submitted for priority assignment. However, it is typically not desirable to slice all tasks in the application due to execution time overhead incurred. As an example, consider a task set whose utilization is 0.96.
Reference: [6] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13 </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: To do so, we can potentially use a code transformation algorithm such as the rename transformation in [7], the static single assignment (SSA) form translation in <ref> [6, 15] </ref>. In order to avoid loop-unrolling, we could potentially use dependence-breaking methods, e.g., scalar expansion [3]. However, it is practically impossible to massage a program into a form that is entirely free of false dependences, mainly due to the existence of aliases and pointers.
Reference: [7] <author> R. Cytron, A. Lowry, and K. Zadeck. </author> <title> Code motion of control structures in high-level languages. </title> <booktitle> In Conference Record 13th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-85. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Such dependences are caused by variable reuse rather a requirement for data integrity, and real-time slicing will be much more effective if 12 they can be minimized. To do so, we can potentially use a code transformation algorithm such as the rename transformation in <ref> [7] </ref>, the static single assignment (SSA) form translation in [6, 15]. In order to avoid loop-unrolling, we could potentially use dependence-breaking methods, e.g., scalar expansion [3].
Reference: [8] <author> B. Dasarathy. </author> <title> Timing constraints of real-time systems: Constructs for expressing them, method for validating them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 80-86, </pages> <month> Jan-uary </month> <year> 1985. </year>
Reference-contexts: Functional specifications define valid translations from inputs into outputs. As such they are realized by a set of programs, which consume CPU time. Temporal requirements, on the other hand, place upper and lower bounds between occurrences of events <ref> [8, 18] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment. Temporal requirements implicitly limit the time that can be provided by the system's resources.
Reference: [9] <author> J. Ferrante and K. Ottenstein. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 319-345, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [9, 16, 28] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows. <p> S 1 and S 2 are disjoint. Since many real-time programming languages allow only "structured" programs without unrestricted gotos 3 , this does not impose serious restrictions on our approach. As a consequence, our definition of control dependence is simpler than that found in <ref> [9] </ref>. The program dependence graph PDG of our controller task t 2 is shown in Figure 9. The slice of program P with respect to program point p and expression e (i.e., P=hp; ei) can be obtained through a traversal of P 's program dependence graph.
Reference: [10] <author> R. Gerber and S. Hong. </author> <title> Semantics-based compiler transformations for enhanced schedulabil-ity. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 232-242. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: In <ref> [10] </ref> we present a RMS-based method, in which each process receives two priorities, one for t IO and one for t State . Its principal strength is a simple dual-priority assignment rule, and an efficient analysis test to determine schedulability.
Reference: [11] <author> R. Gerber and S. Hong. </author> <title> Compiling real-time programs with timing constraint refinement and structural code motion. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> May </month> <year> 1995. </year> <note> To Appear. </note>
Reference-contexts: As a last resort, entire subsystems may have to be re-designed altogether. In this paper we present a static alternative to this process, which is based on two inter-related components: a real-time annotation language called TCEL <ref> [11] </ref> (for "Time-Constrained Event Language"), and the compiler transformation known as program slicing [28, 36, 37]. Surprisingly, while our use of static slicing often leads to longer execution times and even higher utilizations - it simultaneously helps achieve real-time correctness and schedulability for the entire system. <p> In [39] an approach to speculative execution is postulated for distributed real-time systems. The idea is that the speculative "shadow threads" are forked off to execute on available resources. In <ref> [11, 15] </ref> we show how to use TCEL's event-based semantics to help synthesize feasible task code. (We call a code segment is infeasible if its execution time stretches over its specified deadline.) The transformation algorithm corrects such faults via a two-step process. <p> This is done by a variant of Trace Scheduling, in which worst-case paths of the infeasible task are selected, and unobservable code is moved to shorten their execution time. In this paper we address the more ambitious goal of optimizing multi-threaded applications. But here unlike in <ref> [11, 15] </ref> we have to consider the role of scheduling support. Since scheduling analysis often defines whether timing constraints will be met, the particular scheduling strategy will play a leading role in optimization metric.
Reference: [12] <author> P. Gopinath and R. Gupta. </author> <title> Applying compiler techniques to scheduling in real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 247-256. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: There has been a growing amount of work within the area of program transformation. The resulting techniques address different problems associated with real-time programming, but they share the goal of enhancing the predictability and schedulability. In <ref> [12] </ref> a compiler tool classifies an application program on the basis of its predictability and monotonicity, and creates partitions which have a higher degree of adaptability.
Reference: [13] <author> M. Harmon, T. Baker, and D. Whalley. </author> <title> A retargetable technique for predicting execution time. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 68-77. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1992. </year>
Reference-contexts: Yet static analysis is developing at a rapid pace, and tools are being produced which can yield tighter results. The technique reported in [29] is based on a simple source-level timing schema, and it is fairly straightforward to implement in a tool. In <ref> [13] </ref> another approach for more accurate timing was proposed; the resulting tool was able to analyze micro-instruction streams using machine-description rules, and thus it was retargetable to various architectures.
Reference: [14] <author> L. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the ACM 29 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: At worst, we end up with code that appears totally unsliceable when it may, in fact, be amenable to slicing. Again, the developers can be of enormous help, by manually breaking some of the false dependences. We also note that dependence analyzers are improving at a fast rate (see <ref> [14, 30] </ref>), and our algorithm will improve along with them. For example, if we incorporate the recent advances in loop dependence analyses such as those in the Omega Test [30], we may not have to unroll loops to slice a real-time task.
Reference: [15] <author> S. Hong and R. Gerber. </author> <title> Compiling real-time programs into schedulable code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 166-176. </pages>
Reference-contexts: In [39] an approach to speculative execution is postulated for distributed real-time systems. The idea is that the speculative "shadow threads" are forked off to execute on available resources. In <ref> [11, 15] </ref> we show how to use TCEL's event-based semantics to help synthesize feasible task code. (We call a code segment is infeasible if its execution time stretches over its specified deadline.) The transformation algorithm corrects such faults via a two-step process. <p> This is done by a variant of Trace Scheduling, in which worst-case paths of the infeasible task are selected, and unobservable code is moved to shorten their execution time. In this paper we address the more ambitious goal of optimizing multi-threaded applications. But here unlike in <ref> [11, 15] </ref> we have to consider the role of scheduling support. Since scheduling analysis often defines whether timing constraints will be met, the particular scheduling strategy will play a leading role in optimization metric. <p> To do so, we can potentially use a code transformation algorithm such as the rename transformation in [7], the static single assignment (SSA) form translation in <ref> [6, 15] </ref>. In order to avoid loop-unrolling, we could potentially use dependence-breaking methods, e.g., scalar expansion [3]. However, it is practically impossible to massage a program into a form that is entirely free of false dependences, mainly due to the existence of aliases and pointers.
Reference: [16] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The first assumption allows us to avoid interprocedural slicing <ref> [16] </ref>. The next two assumptions simplify the problems induced by false data dependences. Such dependences are caused by variable reuse rather a requirement for data integrity, and real-time slicing will be much more effective if 12 they can be minimized. <p> Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [9, 16, 28] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows.
Reference: [17] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> Object-oriented real-time language design: Constructs for timing constraints. </title> <booktitle> In Proceedings of OOPSLA-90, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms.
Reference: [18] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Functional specifications define valid translations from inputs into outputs. As such they are realized by a set of programs, which consume CPU time. Temporal requirements, on the other hand, place upper and lower bounds between occurrences of events <ref> [8, 18] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment. Temporal requirements implicitly limit the time that can be provided by the system's resources.
Reference: [19] <author> E. Kligerman and A. Stoyenko. </author> <title> Real-Time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12 </volume> <pages> 941-949, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms.
Reference: [20] <author> J. Krause. </author> <title> GN&C domain modeling: Functionality requirements for fixed rate algorithms. </title> <type> Technical Report (DRAFT) version 0.2, </type> <institution> Honeywell Systems and Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Since discrete control software possesses many representative properties that can be found in other applications (e.g., multimedia, vision, etc.), this discussion has close analogues in other types of real-time systems. 2.1 Characterization of Discrete Control Software Many discrete control algorithms possess computations that fit a fixed-rate algorithm paradigm <ref> [20] </ref>, i.e., control-loops which execute repetitively with fixed periods. During each period, the physical world measurement data are sampled, and then actuator commands are computed. Meanwhile, a set of states is updated based on the current state and the sampled data.
Reference: [21] <author> I. Lee and V. Gehlot. </author> <title> Language constructs for real-time programming. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms.
Reference: [22] <author> J. Leung and M. Merill. </author> <title> A note on the preemptive scheduling of periodic, real-time tasks. </title> <journal> Information Processing Letters, </journal> <volume> 11(3) </volume> <pages> 115-118, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: However, their algorithm is applicable only to the periodic task model where tasks have fixed periods, deadlines are equal to periods, and tasks are totally independent of each other. Recent research has made significant enhancements to this model, enhancements which relaxed the original restrictions. In <ref> [22] </ref> Leung and Merrill showed that a deadline-monotonic priority assignment is also optimal where deadlines may be shorter than periods. In [32] Sha et al. presented two protocols which enable tasks to interact via shared resources, while still guaranteeing the tasks' deadlines.
Reference: [23] <author> S. Lim, Y. Bae, C. Jang, B. Rhee, S. Min, C. Park, H. Shin, K. Park, and C. Kim. </author> <title> An accurate worst case timing analysis for risc processors. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 97-108. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: In [31] Arnold et al. developed a timing prediction method called static cache simulation to statically analyze memory and cache reference patterns. A similar but more advanced approach was reported in <ref> [23] </ref>. While the latter approach is able to predict pipeline stalls as well, both essentially rely on attribute grammars [2] to propagate cache hit information backward in a flow graph. However, no static timing tool is precise enough to be used with complete confidence for developing production-quality software. <p> However, no static timing tool is precise enough to be used with complete confidence for developing production-quality software. Moreover, even sophisticated timing analysis methods such as <ref> [23, 31] </ref> are not appropriate for fine-grained instruction timing. In Section 3.3 we explain how we can effectively use these tools in spite of the limitations, by also taking advantage of software profiling, as well as static timing prediction.
Reference: [24] <author> K. Lin and S. Natarajan. </author> <title> Expressing and maintaining timing constraints in FLEX. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms.
Reference: [25] <author> C. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Rate-monotonic scheduling, originally developed by Liu and Layland, was the first well-known algorithm of this kind. In their seminal paper <ref> [25] </ref> they proposed a priority assignment algorithm, in which a task with the shorter period is assigned the higher priority (hence the name rate-monotonic scheduling, or RMS). <p> That is, whenever we let a task's deadline be greater than its period, this represents a relaxation of the classical rate-monotonic restrictions put forth in <ref> [25] </ref>. Thus the rate-monotonic priority assignment may not be the optimal one.
Reference: [26] <author> C. Locke, D. Vogel, and T Mesler. </author> <title> Building a predictable avionics platform in ada: A case study. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 181-189. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1991. </year> <month> 30 </month>
Reference-contexts: else (9) t 0 = Slice (t ); (10) if Feasible (L; t 0 ) then (11) return (L@[t 0 ]); end (12) return (Search (L 0 1 ; [t ]@L 2 )); 23 5.3 A Larger Example In a somewhat larger example, we adapted the periodic tasks described in <ref> [26, 35] </ref>, factoring in display server activity, as well as the IO and state-update components (while modifying the execution times accordingly). The adapted task set had a utilization of 0.836, and it was unschedulable under any static priority ordering.
Reference: [27] <author> V. Nirkhe. </author> <title> Application of Partial Evaluation to Hard Real-Time Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Maryland at College Park, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms. <p> Specifically, the tool denotes whether a piece of code belongs in one of four classes; based on this classification, programs are rearranged to help support adaptive run-time scheduling. The objective is to produce a transformed program possessing a smaller variance in its execution time. In <ref> [27] </ref> a partial evaluator is applied to a source program, which produces residual code that is both more optimized and more deterministic. In [39] an approach to speculative execution is postulated for distributed real-time systems.
Reference: [28] <author> K. Ottenstein and L. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: As a last resort, entire subsystems may have to be re-designed altogether. In this paper we present a static alternative to this process, which is based on two inter-related components: a real-time annotation language called TCEL [11] (for "Time-Constrained Event Language"), and the compiler transformation known as program slicing <ref> [28, 36, 37] </ref>. Surprisingly, while our use of static slicing often leads to longer execution times and even higher utilizations - it simultaneously helps achieve real-time correctness and schedulability for the entire system. For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. <p> Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [9, 16, 28] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows.
Reference: [29] <author> C. Park and A. Shaw. </author> <title> Experimenting with a program timing tool based on source-level timing schema. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 72-81. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: But this is also its downside: the result can be a conservative "worst of all worst cases," i.e., an experimentally unachievable measurement. Yet static analysis is developing at a rapid pace, and tools are being produced which can yield tighter results. The technique reported in <ref> [29] </ref> is based on a simple source-level timing schema, and it is fairly straightforward to implement in a tool. In [13] another approach for more accurate timing was proposed; the resulting tool was able to analyze micro-instruction streams using machine-description rules, and thus it was retargetable to various architectures.
Reference: [30] <author> W. Pugh and D. Wonnacott. </author> <title> Eliminating false data dependences using the Omega test. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: At worst, we end up with code that appears totally unsliceable when it may, in fact, be amenable to slicing. Again, the developers can be of enormous help, by manually breaking some of the false dependences. We also note that dependence analyzers are improving at a fast rate (see <ref> [14, 30] </ref>), and our algorithm will improve along with them. For example, if we incorporate the recent advances in loop dependence analyses such as those in the Omega Test [30], we may not have to unroll loops to slice a real-time task. <p> We also note that dependence analyzers are improving at a fast rate (see [14, 30]), and our algorithm will improve along with them. For example, if we incorporate the recent advances in loop dependence analyses such as those in the Omega Test <ref> [30] </ref>, we may not have to unroll loops to slice a real-time task. Moreover, we can obtain better slices for loops using techniques like loop distribution. We also rely on achieving reasonable execution time bounds for the code segments.
Reference: [31] <author> D. Whalley R. Arnold, F. Mueller. </author> <title> Bounding worst-case instruction cache performance. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 172-181. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: Zhang et al. [40] presented a timing analyzer based on a mathematical model of the pipelined Intel 80C188 processor. This analysis method is able to take into account the overlap between instruction execution and fetching, which is an improvement over schemes where instruction executions are treated individually. In <ref> [31] </ref> Arnold et al. developed a timing prediction method called static cache simulation to statically analyze memory and cache reference patterns. A similar but more advanced approach was reported in [23]. <p> However, no static timing tool is precise enough to be used with complete confidence for developing production-quality software. Moreover, even sophisticated timing analysis methods such as <ref> [23, 31] </ref> are not appropriate for fine-grained instruction timing. In Section 3.3 we explain how we can effectively use these tools in spite of the limitations, by also taking advantage of software profiling, as well as static timing prediction.
Reference: [32] <author> L. Sha, R. Rajkumar, and J. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 39 </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Recent research has made significant enhancements to this model, enhancements which relaxed the original restrictions. In [22] Leung and Merrill showed that a deadline-monotonic priority assignment is also optimal where deadlines may be shorter than periods. In <ref> [32] </ref> Sha et al. presented two protocols which enable tasks to interact via shared resources, while still guaranteeing the tasks' deadlines.
Reference: [33] <author> K. Tindell. </author> <title> Using offset information to analyse static priority pre-emptively scheduled task sets. </title> <type> Technical Report YCS 182 (1992), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Most recently, a group of researchers at the University of York developed a set of analytical techniques which can provide schedulability tests for broad classes of tasks, including those whose deadlines are greater than their periods <ref> [4, 35, 33] </ref>.
Reference: [34] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> Allocating real-time tasks (an np-hard problem made easy). </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 4(2) </volume> <pages> 145-165, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: traditional separation of concerns between the kernel and the compiler has evolved for many good reasons, and in this paper we strive to maintain it. 1 For example, a multiprocessor scheduling problem is often modeled as a combination of an allocation sub-problem and multiple instances of single processor scheduling sub-problems <ref> [34] </ref>. 4 Timing analysis is a key step in building a real-time application; this is especially true in a hard real-time system, in which all deadlines must be met. Many analysis techniques have been proposed, ranging from static, source-based methods to profilers and testing tools, through some combination thereof.
Reference: [35] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> An extendible approach for analysing fixed priority hard real-time tasks. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 6(2) </volume> <pages> 133-152, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Most recently, a group of researchers at the University of York developed a set of analytical techniques which can provide schedulability tests for broad classes of tasks, including those whose deadlines are greater than their periods <ref> [4, 35, 33] </ref>. <p> In this case Eq 1 is not sufficient, since uncompleted iterations of t i can now interfere with the current one. Thanks to <ref> [35] </ref>, the following general equation can be used instead. <p> Although q is denoted as an unbounded number in Eq 3, it can be trivially shown that there exists bounded response time R IO i as long as utilization of hp (i) [ ft i g is less than 100% <ref> [35] </ref>. <p> else (9) t 0 = Slice (t ); (10) if Feasible (L; t 0 ) then (11) return (L@[t 0 ]); end (12) return (Search (L 0 1 ; [t ]@L 2 )); 23 5.3 A Larger Example In a somewhat larger example, we adapted the periodic tasks described in <ref> [26, 35] </ref>, factoring in display server activity, as well as the IO and state-update components (while modifying the execution times accordingly). The adapted task set had a utilization of 0.836, and it was unschedulable under any static priority ordering.
Reference: [36] <author> G. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: As a last resort, entire subsystems may have to be re-designed altogether. In this paper we present a static alternative to this process, which is based on two inter-related components: a real-time annotation language called TCEL [11] (for "Time-Constrained Event Language"), and the compiler transformation known as program slicing <ref> [28, 36, 37] </ref>. Surprisingly, while our use of static slicing often leads to longer execution times and even higher utilizations - it simultaneously helps achieve real-time correctness and schedulability for the entire system. For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events.
Reference: [37] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10 </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: As a last resort, entire subsystems may have to be re-designed altogether. In this paper we present a static alternative to this process, which is based on two inter-related components: a real-time annotation language called TCEL [11] (for "Time-Constrained Event Language"), and the compiler transformation known as program slicing <ref> [28, 36, 37] </ref>. Surprisingly, while our use of static slicing often leads to longer execution times and even higher utilizations - it simultaneously helps achieve real-time correctness and schedulability for the entire system. For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events.
Reference: [38] <author> V. Wolfe, S. Davidson, and I. Lee. RTC: </author> <title> Language support for real-time concurrency. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 43-52. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1991. </year> <month> 31 </month>
Reference-contexts: For this reason we call the transformation real-time task slicing. The Language of Time Constrained Events. TCEL's annotation syntax is quite similar to that found in other experimental real-time languages (e.g., <ref> [17, 19, 21, 24, 27, 38] </ref>). However, the semantics differs significantly, in that it is based on the time-constrained relationships between observable events. For example, consider a construct such as "every 10ms do B," where the block of code "B" is executed once every 10ms.
Reference: [39] <author> M. Younis, T. Marlowe, and A. Stoyenko. </author> <title> Compiler transformations for speculative execution in a real-time system. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 109-117. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: The objective is to produce a transformed program possessing a smaller variance in its execution time. In [27] a partial evaluator is applied to a source program, which produces residual code that is both more optimized and more deterministic. In <ref> [39] </ref> an approach to speculative execution is postulated for distributed real-time systems. The idea is that the speculative "shadow threads" are forked off to execute on available resources.
Reference: [40] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined processors and worst case execution times. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 5(4), </volume> <month> October </month> <year> 1993. </year> <month> 32 </month>
Reference-contexts: On the other hand, neither approach addresses the problem of predicting architecture-specific timing behavior due to the various latencies inherent in memory hierarchies and pipelines. New results have begun to account for this timing variance. Zhang et al. <ref> [40] </ref> presented a timing analyzer based on a mathematical model of the pipelined Intel 80C188 processor. This analysis method is able to take into account the overlap between instruction execution and fetching, which is an improvement over schemes where instruction executions are treated individually.
References-found: 40

