URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-TLCA93.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: steffen@cs.kun.nl  
Title: Partial Intersection Type Assignment in Applicative Term Rewriting Systems  
Author: Steffen van Bakel 
Address: Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands.  
Affiliation: Department of Informatics, Faculty of Mathematics and Informatics, University of  
Abstract: This paper introduces a notion of partial type assignment on applicative term rewriting systems that is based on a combination of an essential intersection type assignment system, and the type assignment system as defined for ML [16], both extensions of Curry's type assignment system [11]. Terms and rewrite rules will be written as trees, and type assignment will consists of assigning intersection types function symbols, and specifying the way in which types can be assigned to nodes and edges between nodes. The only constraints on this system are local: they are imposed by the relation between the type assigned to a node and those assigned to its incoming and out-going edges. In general, given an arbitrary typeable applicative term rewriting system, the subject reduction property does not hold. We will formulate a sufficient but undecidable condition typeable rewrite rules should satisfy in order to obtain this property.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. van Bakel. </author> <title> Complete restrictions of the Intersection Type Discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 135-163, </pages> <year> 1992. </year>
Reference-contexts: Because of this power, type assignment in this system (and even in the system that does not contain !, see <ref> [1] </ref>) is undecidable. The essential type assignment system as presented in this paper is a restriction of the intersection type discipline presented in [6] that satisfies all properties of that system, and is also an extension of the Curry type assignment system. <p> constant ! completely from the presentation of the system, because we can always assume that n = 0 in 1 " " n , but some of the definitions and the results we obtain are more clear when ! is dealt with explicitly. 1.1 Essential type assignment Definition 1.1.1 (cf. <ref> [1] </ref>) i) T s , the set of strict types, is inductively defined by: a) All type-variables ' 0 , ' 1 , : : : 2 T s . b) If t , 1 , : : : , n 2 T s (n 0), then 1 " " n
Reference: [2] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting Systems. </title> <type> Technical Report 92-03, </type> <institution> Department of Computer Science, University of Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: The applicative term rewriting systems defined in this paper are extensions to those suggested by most functional programming languages in that they do not discriminate against the varieties of function symbols that can be used in patterns. In [4] and <ref> [2] </ref> partial type assignment systems for (left linear) applicative term rewriting systems are presented. <p> The system presented here can be seen as a variant of those systems; the main difference between those two systems and the one presented here are in the set of types that can be assigned to nodes and edges: Curry types in [4], intersection types of Rank 2 in <ref> [2] </ref>, and strict intersection types in this one. Also, type assignment in those systems is decidable, but in the one presented in this paper it is not. <p> The environment E 0 maps function symbols to Curry-types, so even for a notion of type assignment based on Curry-types types are not preserved under rewriting. In [4] and <ref> [2] </ref> two restrictions (variants) of the notion of type assignment of this paper are discussed for which a decidable and sufficient condition is formulated that rewrite rules should satisfy in order to reach the subject reduction property. 13 The construction of those conditions is made using a notion of principal pairs; <p> For the notion of type assignment defined in this section we are not able to formulate this condition in a constructive way, since it is not clear how we should define the principal pair for a term. This problem is overcome in [4] and <ref> [2] </ref> by defining a most general unification algorithm for types and defining principal pairs using that algorithm. At this moment there is no general unification algorithm for types in T S that works well on all types, so we cannot take this approach.
Reference: [3] <author> S. van Bakel. </author> <title> Principal type schemes for the Strict Type Assignment System. </title> <booktitle> Logic and Computation, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: M has a normal form. iii) 9 B, [ B ` E M : & 6= ! ] () M has a head normal form. 1.2 Operations on pairs In this subsection we present three different operations on pairs of &lt;basis, type&gt;, namely substitution, expansion, and lifting as defined in <ref> [3] </ref>. The operation of substitution deals with the replacement of type-variables by types and is a slight modification of the one normally used; this modification is needed to make sure that substitution is closed on strict types.
Reference: [4] <author> S. van Bakel, S. Smetsers, and S. Brock. </author> <title> Partial Type Assignment in Left Linear Applicative Term Rewriting Systems. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> Proceedings of CAAP '92. 17th Colloquim on Trees in Algebra and Programming, Rennes, France, volume 581 of Lecture Notes in Computer Science, </booktitle> <pages> pages 300-321. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: For example, type assignment in term rewriting systems in general does not satisfy the subject reduction property: i.e. types are not preserved under rewriting, as illustrated in <ref> [4] </ref>. In order to be able to study the details of type assignment for term rewriting systems, a formal notion of type assignment on term rewriting systems is needed, that is more close to the approach of type assignment in lambda calculus than the algebraic one [12]. <p> The applicative term rewriting systems defined in this paper are extensions to those suggested by most functional programming languages in that they do not discriminate against the varieties of function symbols that can be used in patterns. In <ref> [4] </ref> and [2] partial type assignment systems for (left linear) applicative term rewriting systems are presented. <p> The system presented here can be seen as a variant of those systems; the main difference between those two systems and the one presented here are in the set of types that can be assigned to nodes and edges: Curry types in <ref> [4] </ref>, intersection types of Rank 2 in [2], and strict intersection types in this one. Also, type assignment in those systems is decidable, but in the one presented in this paper it is not. <p> Of course it makes no difference to assume the existence from the start of such a mapping from symbols (both defined and constant) to types, and to define type assignment using that mapping (in the following such a mapping is called an `environment'). Definition 2.1.1 (cf. <ref> [15, 4] </ref>) An Applicative Term Rewriting System (ATRS) is a pair (S, R) of an alphabet or signature S and a set of rewrite rules R. i) The alphabet S consists of: a) A countable infinite set of variables x 1 , x 2 , x 3 , : : : <p> Definition 2.1.2 (cf. <ref> [15, 4] </ref>) Let (S, R) be an ATRS. i) A replacement is a map R : T (F; X ) ! T (F; X ) satisfying R (F (t 1 , : : : , t n )) = F (R (t 1 ), : : : , R (t n <p> We should emphasize that the loss of the subject reduction property is not caused by the fact that we use intersection types. The environment E 0 maps function symbols to Curry-types, so even for a notion of type assignment based on Curry-types types are not preserved under rewriting. In <ref> [4] </ref> and [2] two restrictions (variants) of the notion of type assignment of this paper are discussed for which a decidable and sufficient condition is formulated that rewrite rules should satisfy in order to reach the subject reduction property. 13 The construction of those conditions is made using a notion of <p> For the notion of type assignment defined in this section we are not able to formulate this condition in a constructive way, since it is not clear how we should define the principal pair for a term. This problem is overcome in <ref> [4] </ref> and [2] by defining a most general unification algorithm for types and defining principal pairs using that algorithm. At this moment there is no general unification algorithm for types in T S that works well on all types, so we cannot take this approach.
Reference: [5] <author> H. Barendregt. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus <ref> [5] </ref>, but also term rewriting systems [15] and term graph rewriting systems [7] are topics of research. <p> This corresponds to the fact that in CL the term K I is not a redex. Because ACL is Curry-closed, it is in fact combinatory complete: every lambda term can be translated into a term in ACL; for details of such a translation, see <ref> [5, 13] </ref>.
Reference: [6] <author> H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year> <month> 14 </month>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages are based on (extensions of) the Curry type assignment system. In <ref> [9, 6] </ref> the intersection type discipline for the lambda calculus is presented, an extension of Curry's type assignment system. The extension consists of allowing more than one type for term-variables and adding a type constant `!' and, next to the type constructor `!', the type constructor `"'. <p> Because of this power, type assignment in this system (and even in the system that does not contain !, see [1]) is undecidable. The essential type assignment system as presented in this paper is a restriction of the intersection type discipline presented in <ref> [6] </ref> that satisfies all properties of that system, and is also an extension of the Curry type assignment system. The main advantage of the essential system over the intersection system is that the set of types assignable to a term is significantly smaller. <p> The symbol B is used for bases. 2 Because of the restricted length of this paper, all results are presented without proofs. 1 Essential type assignment for the lambda calculus In this section we present the essential type assignment system, a restricted version of the system presented in <ref> [6] </ref>, together with some of its properties. The major feature of this restricted system is, compared to that system, a restricted version of the derivation rules and it is based on a set of strict types. <p> The major feature of this restricted system is, compared to that system, a restricted version of the derivation rules and it is based on a set of strict types. Strict types are the types that are strictly needed to assign a type to a term in the system of <ref> [6] </ref>. We will assume that ! is the same as an intersection over zero elements: if n = 0, then 1 " " n = !, so ! does not occur in an intersection subtype.
Reference: [7] <author> H.P. Barendregt, M.C.J.D. van Eekelen, J.R.W. Glauert, J.R. Kennaway, M.J. Plasmeijer, </author> <title> and M.R. Sleep. Term graph rewriting. </title> <booktitle> In Proceedings of PARLE, Parallel Architectures and Languages Europe, Eindhoven, The Netherlands, volume 259-II of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-158. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus [5], but also term rewriting systems [15] and term graph rewriting systems <ref> [7] </ref> are topics of research. Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [22], term rewriting systems are used in the underlying model for the language OBJ [14], and term graph rewriting systems is the model for the language Clean [8, 17].
Reference: [8] <author> T. Brus, M.C.J.D. van Eekelen, M.O. van Leer, and M.J. Plasmeijer. </author> <title> Clean A Language for Functional Graph Rewriting. </title> <booktitle> In Proceedings of the Third International Conference on Functional Programming Languages and Computer Architecture, Portland, Oregon, USA, volume 274 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-368. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [22], term rewriting systems are used in the underlying model for the language OBJ [14], and term graph rewriting systems is the model for the language Clean <ref> [8, 17] </ref>. The lambda calculus, term rewriting systems and graph rewriting systems themselves are type free, whereas in programming the notion of types plays an important role.
Reference: [9] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> An Extension of the Basic Functionality Theory for the -Calculus. </title> <journal> Notre Dame, Journal of Formal Logic, </journal> <volume> 21(4) </volume> <pages> 685-693, </pages> <year> 1980. </year>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages are based on (extensions of) the Curry type assignment system. In <ref> [9, 6] </ref> the intersection type discipline for the lambda calculus is presented, an extension of Curry's type assignment system. The extension consists of allowing more than one type for term-variables and adding a type constant `!' and, next to the type constructor `!', the type constructor `"'.
Reference: [10] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and -calculus semantics. </title> <editor> In J. R. Hindley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in <ref> [10, 21] </ref>. The operation of lifting deals with the introduction of extra (types to) statements in the basis of a derivation, or introduces extra types to term-variables that are bound. Substitution is normally defined on types as the operation that replaces type-variables by types.
Reference: [11] <author> H.B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: There exists a well understood and well defined notion of type assignment on lambda terms, known as the Curry type assignment system <ref> [11] </ref> which expresses abstraction and application. Many of the now existing type assignment systems for functional programming languages are based on (extensions of) the Curry type assignment system. In [9, 6] the intersection type discipline for the lambda calculus is presented, an extension of Curry's type assignment system.
Reference: [12] <author> N. Dershowitz and J.P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 6, </booktitle> <pages> pages 245-320. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: In order to be able to study the details of type assignment for term rewriting systems, a formal notion of type assignment on term rewriting systems is needed, that is more close to the approach of type assignment in lambda calculus than the algebraic one <ref> [12] </ref>. The aim of this paper is to present a formal notion of type assignment on term rewriting systems that is close to those defined for the lambda calculus and use intersection types. <p> Moreover, they are a natural extension of those rewrite systems considerd in papers on type assignment on term rewriting systems that follow the `algebraic' approach <ref> [12] </ref>, and are also the kind of rewrite systems an effecient implementation of a functional language would be based upon [18]. Since the 6 pure applicative term rewriting systems are a subclass of the applicative term rewriting systems, all results obtained in this paper are also valid for that subclass.
Reference: [13] <author> M. Dezani-Ciancaglini and J.R. Hindley. </author> <title> Intersection types for combinatory logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 100 </volume> <pages> 303-324, </pages> <year> 1992. </year>
Reference-contexts: This corresponds to the fact that in CL the term K I is not a redex. Because ACL is Curry-closed, it is in fact combinatory complete: every lambda term can be translated into a term in ACL; for details of such a translation, see <ref> [5, 13] </ref>.
Reference: [14] <author> K. Futatsugi, J. Goguen, J.P. Jouannaud, and J. Meseguer. </author> <booktitle> Principles of OBJ2. In Proceedings 12 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66, </pages> <year> 1985. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [22], term rewriting systems are used in the underlying model for the language OBJ <ref> [14] </ref>, and term graph rewriting systems is the model for the language Clean [8, 17]. The lambda calculus, term rewriting systems and graph rewriting systems themselves are type free, whereas in programming the notion of types plays an important role.
Reference: [15] <author> J.W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Clarendon Press, </publisher> <year> 1992. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus [5], but also term rewriting systems <ref> [15] </ref> and term graph rewriting systems [7] are topics of research. <p> Moreover, intersection types seem to be promising for use in functional programming languages, since they seem to provide a good formalism to express overloading (see also [20]). In this paper we define applicative term rewriting systems (ATRS), a slight extension of the term rewriting systems as defined in <ref> [15] </ref>, as the term rewriting systems that contain a special binary operator Ap. The applicative term rewriting systems defined in this paper are extensions to those suggested by most functional programming languages in that they do not discriminate against the varieties of function symbols that can be used in patterns. <p> Moreover, all three operations can be proven to be sound on all pairs. 5 2 Type assignment in Applicative Term Rewriting Systems In this paper we study type assignment on applicative term rewriting systems, which is a slight extension of the term rewriting systems as defined in <ref> [15] </ref>. <p> Of course it makes no difference to assume the existence from the start of such a mapping from symbols (both defined and constant) to types, and to define type assignment using that mapping (in the following such a mapping is called an `environment'). Definition 2.1.1 (cf. <ref> [15, 4] </ref>) An Applicative Term Rewriting System (ATRS) is a pair (S, R) of an alphabet or signature S and a set of rewrite rules R. i) The alphabet S consists of: a) A countable infinite set of variables x 1 , x 2 , x 3 , : : : <p> Definition 2.1.2 (cf. <ref> [15, 4] </ref>) Let (S, R) be an ATRS. i) A replacement is a map R : T (F; X ) ! T (F; X ) satisfying R (F (t 1 , : : : , t n )) = F (R (t 1 ), : : : , R (t n
Reference: [16] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: The notion of type assignment presented here for term rewriting systems is based on both an essential type assignment system for the lambda calculus and the polymorphic type assignment system for the functional programming language ML <ref> [16] </ref>. The polymorphic aspect of type assignment can be found in the use of an environment, that provides a type for every function symbol F ; for every occurrence of F the way in which its type can be obtained from the one provided by the environment is specified.
Reference: [17] <author> E.G.J.M.H. Nocker, J.E.W. Smetsers, M.C.J.D. van Eekelen, and M.J. Plasmeijer. </author> <title> Concurrent Clean. </title> <booktitle> In Proceedings of PARLE '91, Parallel Architectures and Languages Europe, Eindhoven, The Netherlands, volume 506-II of Lecture Notes in Computer Science, </booktitle> <pages> pages 202-219. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [22], term rewriting systems are used in the underlying model for the language OBJ [14], and term graph rewriting systems is the model for the language Clean <ref> [8, 17] </ref>. The lambda calculus, term rewriting systems and graph rewriting systems themselves are type free, whereas in programming the notion of types plays an important role.
Reference: [18] <editor> S. Peyton Jones and J. Salkild. </editor> <booktitle> The spineless tagless G-machine. In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 184-201. </pages> <publisher> ACM press, </publisher> <year> 1989. </year>
Reference-contexts: Moreover, they are a natural extension of those rewrite systems considerd in papers on type assignment on term rewriting systems that follow the `algebraic' approach [12], and are also the kind of rewrite systems an effecient implementation of a functional language would be based upon <ref> [18] </ref>. Since the 6 pure applicative term rewriting systems are a subclass of the applicative term rewriting systems, all results obtained in this paper are also valid for that subclass.
Reference: [19] <author> F. Pfenning. </author> <title> Partial Polymorphic Type Inference and Higher-Order Unification. </title> <booktitle> In Proceedings of the 1988 conference on LISP and Functional Programming Languages, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-163. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We treat Ap as a predefined symbol; the symbol Ap is neglected when we are looking for the symbol that is defined in a rewrite rule. The type assignment system we present in this paper is a partial system in the sense of <ref> [19] </ref>: we not only define how terms and rewrite rules can be typed, but assume that every function symbol already has a type, which structure is usually motivated by a rewrite rule. There are several reasons to do so.
Reference: [20] <author> B.C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pitssburgh, </institution> <year> 1991. </year> <month> CMU-CS-91-205. </month>
Reference-contexts: Moreover, intersection types seem to be promising for use in functional programming languages, since they seem to provide a good formalism to express overloading (see also <ref> [20] </ref>). In this paper we define applicative term rewriting systems (ATRS), a slight extension of the term rewriting systems as defined in [15], as the term rewriting systems that contain a special binary operator Ap.
Reference: [21] <author> S. Ronchi della Rocca and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year>
Reference-contexts: The operation of expansion replaces types by the intersection of a number of copies of that type and coincides with the one given in <ref> [10, 21] </ref>. The operation of lifting deals with the introduction of extra (types to) statements in the basis of a derivation, or introduces extra types to term-variables that are bound. Substitution is normally defined on types as the operation that replaces type-variables by types. <p> It is possible to prove the principal type property for the essential type assignment system, in the same way as done in <ref> [21] </ref> for the BCD-system. The operations needed for this proof are substitution, expansion, and lifting, and it is possible to show that all pairs for a term can be generated by chains that exist of expansions, and substitutions (in that order) and that end with one lifting.
Reference: [22] <author> D.A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the conference on Functional Programming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 15 </month>
Reference-contexts: Not only the lambda calculus [5], but also term rewriting systems [15] and term graph rewriting systems [7] are topics of research. Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda <ref> [22] </ref>, term rewriting systems are used in the underlying model for the language OBJ [14], and term graph rewriting systems is the model for the language Clean [8, 17].
References-found: 22

