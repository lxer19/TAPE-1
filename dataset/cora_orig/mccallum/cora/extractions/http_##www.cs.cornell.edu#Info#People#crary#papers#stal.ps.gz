URL: http://www.cs.cornell.edu/Info/People/crary/papers/stal.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Stack-Based Typed Assembly Language  
Author: Greg Morrisett Karl Crary Neal Glew David Walker 
Affiliation: Cornell University  
Abstract: In previous work, we presented a Typed Assembly Language (TAL). TAL is sufficiently expressive to serve as a target language for compilers of high-level languages such as ML. Moreover, TAL's type system is powerful enough to encode source-level abstractions such as closures and abstract data types, yet flexible enough to admit most traditional low-level optimizations. The compiler presented in our original work was based on a continuation-passing style (CPS) transform, which eliminated the need for a control stack by heap allocating activation records. However, modern architectures and most compilers are based on stack allocation of these records. This paper presents STAL, an extension of TAL with stack constructs and stack types to support the stack allocation style. We show that STAL is sufficiently expressive to support languages such as Java, Pascal, and ML; constructs such as exceptions and displays; and optimizations such as tail call elimination and callee-saves registers. This paper makes two additional contributions. First, it formalizes the typing connection between CPS-based compilation and stack-based compilation. The latter is seen as a continuation-passing style where continuation closures are unboxed by the caller and the continuation's environment is placed on the stack. Second, it illustrates how STAL can formally model calling conventions by specifying them as formal translations of source function types to STAL types.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew Appel and Zhong Shao. </author> <title> Callee-saves registers in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 189-219, </pages> <year> 1992. </year>
Reference-contexts: The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a <p> ; r3:ff; ra:8 []fsp:; r1:int ; r3:ffg; sp:g Translating this type back in to a boxed, heap allocated closure, we obtain: 8 [ff]:fr1:hi; r2 : int ; r3:ff; ra:9fi:h8 []fr1:fi; r2:int ; r3:ffg 1 ; fi 1 ig This is the type of the callee-saves approach of Appel and Shao <ref> [1] </ref>. Thus we see how our correspondence enables transformations developed for heap-based compilers to be used in traditional stack-based compilers and vice versa. The generalization to multiple callee-saves registers and other calling conventions should be clear.
Reference: [2] <author> Andrew Appel and Zhong Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with clsoures. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1), </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads when continuations are heap allocated [3, 31, 34]. Second, Appel and Shao <ref> [2] </ref> have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including stack frames. Finally, Appel and Shao [2] have argued <p> and Shao <ref> [2] </ref> have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including stack frames. Finally, Appel and Shao [2] have argued that, at least for SML/NJ, the locality lost by heap-allocating stack frames is negligible. Nevertheless, there are also compelling reasons for providing support for stacks. <p> caller might unpack the continuations: 8 [ff 1 ; ff 2 ]:fr1:int ; ra:8 [ ]:fr1:ff 1 ; r2:hig; ra 0 :ff 1 ; re:8 [ ]:fr1:ff 2 ; r2:exng; re 0 :ff 2 g Then the caller might attempt to place the continuation environments on stacks, as before: 8 <ref> [ 1 ; 2 ] </ref>:fr1:int ; ra:8 [ ]:fsp: 1 ; r1:hig; sp: 1 ; re:8 [ ]:fsp: 2 ; r1:exn g; sp 0 : 2 g (illegal) Unfortunately, this calling convention uses two stack pointers, and STAL has only one stack. 3 Observe, though, that the exception continuation's stack is <p> This observation leads to the following calling convention for exceptions with stacks: 8 <ref> [ 1 ; 2 ] </ref>:fsp: 1 ffi 2 ; r1:int ; ra:8 [ ]:fsp: 1 ffi 2 ; r1:hig; re 0 :ptr ( 2 ); re:8 [ ]:fsp: 2 ; r1:exngg This type uses some two new constructs we now add to STAL (see Figure 5). <p> In the above example the load will be rejected because r1's type t :: is not a tail of sp 0 s type, ns::. 4.3 Using Compound Stacks Recall the type for a function in the presence of exceptions: 8 <ref> [ 1 ; 2 ] </ref>:fsp: 1 ffi 2 ; r1:int ; ra:8 [ ]:fsp: 1 ffi 2 ; r1:hig; re 0 :ptr ( 2 ); re:8 [ ]:fsp: 2 ; r1:exngg An exception may be raised within the body of such a function by restoring the handler's stack from re 0 <p> This last convention illustrates a use for compound stacks that goes beyond implementing exceptions. We have a general tool for locating data of type t amidst the stack by using the calling convention: 8 <ref> [ 1 ; 2 ] </ref>:fsp: 1 ffi (t :: 2 ); r1:ptr (t :: 2 ); : : :g One application of this tool would be for implementing Pascal with displays.
Reference: [3] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: However, the compiler we presented was critically based on a continuation-passing style transform, which eliminated the need for a control stack. In particular, activation records were represented by heap-allocated closures as in the SML of New Jersey compiler (SML/NJ) <ref> [5, 3] </ref>. For example, computation. Each function takes an additional argument which represents the control stack as a continuation closure. <p> Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads when continuations are heap allocated <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. <p> The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: [4] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible.
Reference: [5] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: However, the compiler we presented was critically based on a continuation-passing style transform, which eliminated the need for a control stack. In particular, activation records were represented by heap-allocated closures as in the SML of New Jersey compiler (SML/NJ) <ref> [5, 3] </ref>. For example, computation. Each function takes an additional argument which represents the control stack as a continuation closure. <p> The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: [6] <author> Mark Bailey and Jack Davidson. </author> <title> A formal model of procedure calling conventions. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In contrast, STAL only allows allocation at the top of the stack and assumes a garbage collector for heap-allocated values. However, the type system for STAL is considerably simpler than the type system of Tofte et al., as it requires no effect information in types. Bailey and Davidson <ref> [6] </ref> also describe a specification language for modeling procedure calling conventions and checking that implementations respect these conventions. They are able to specify features such as a variable number of arguments that our formalism does not address.
Reference: [7] <author> Lars Birkedal, Nick Rothwell, Mads Tofte, and David N. Turner. </author> <title> The ML Kit (version 1). </title> <type> Technical Report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: [8] <author> Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference <ref> [8] </ref>, subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. <p> Consequently, procedure call must be a primitive construct (which it is in JVML). In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [8, 33] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion on abstracted region variables plays a critical role.
Reference: [9] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination <ref> [9, 11] </ref>, and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion.
Reference: [10] <author> Karl Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: However, we claim that the framework presented here is a practical approach to compilation. To substantiate this claim, we are constructing a compiler called TALC that maps the KML programming language <ref> [10] </ref> to a variant of STAL described here, suitably adapted for the Intel IA32 architecture. We have found it straightforward to enrich the target language type system to include support for other type constructors, such as references, higher-order constructors, and recursive types.
Reference: [11] <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination <ref> [9, 11] </ref>, and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion.
Reference: [12] <author> Allyn Dimock, Robert Muller, Franklyn Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed reprsentation transformations. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Ams-terdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: [13] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory subsystem performance of programs using copying garbage collection. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Nevertheless, there are also compelling reasons for providing support for stacks. First, Appel and Shao's work did not consider imperative languages, such as Java, where the ability to share environments is greatly reduced nor did it consider languages that do not require garbage collection. Second, Tarditi and Diwan <ref> [14, 13] </ref> have shown that with some cache architectures, heap allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality. Third, stack-based activation records can have a smaller memory footprint than heap-based activation records.
Reference: [14] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory system performance of programs with intensive heap allocation. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 244-273, </pages> <month> August </month> <year> 1995. </year> <month> 15 </month>
Reference-contexts: Nevertheless, there are also compelling reasons for providing support for stacks. First, Appel and Shao's work did not consider imperative languages, such as Java, where the ability to share environments is greatly reduced nor did it consider languages that do not require garbage collection. Second, Tarditi and Diwan <ref> [14, 13] </ref> have shown that with some cache architectures, heap allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality. Third, stack-based activation records can have a smaller memory footprint than heap-based activation records.
Reference: [15] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class contin-uations. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices, 25(6). </note>
Reference-contexts: Second, threads and advanced mechanisms for implementing first-class continuations such as the work by Hieb et al. <ref> [15] </ref> cannot be modeled in this system without adding new primitives. However, we claim that the framework presented here is a practical approach to compilation.
Reference: [16] <author> Intel Corporation. </author> <title> Intel Architecture Optimization Manual. </title> <publisher> Intel Corporation, </publisher> <address> P.O. Box 7641, Mt. Prospect, IL, 60056-7641, </address> <year> 1997. </year>
Reference-contexts: Finally, many machine architectures have hardware mechanisms that expect programs to behave in a stack-like fashion. For example, the Pentium Pro processor has an internal stack that it uses to predict return addresses for procedures so that instruction pre-fetching will not be stalled <ref> [16] </ref>. The internal stack is guided by the use of call/return primitives which use the standard 2 control stack. Clearly, compiler writers must weigh a complex set of factors before choosing stack allocation, heap allocation, or both. The target language must not constrain these design decisions.
Reference: [17] <author> David Kranz, R. Kelsey, J. Rees, P. R. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible.
Reference: [18] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer J., </journal> <volume> 6(4) </volume> <pages> 308-20, </pages> <year> 1964. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible.
Reference: [19] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. <p> These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: [20] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. <p> More specifically, the typing discipline supports stack allocation of temporary variables and values that do not escape, stack allocation of procedure activation frames, exception handlers, and displays, as well as optimizations such as callee-saves registers. Unlike the JVM architecture <ref> [20] </ref>, our system does not constrain the stack to have the same size at each control-flow point, nor does it require new high-level primitives for procedure call/return. Instead, our assembly language continues to have low-level RISC-like primitives such as loads, stores, and jumps.
Reference: [21] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible. <p> At the TAL level, we represent closures as a pair consisting of a code block label and a pointer to an environment data structure. The type of the environment must be held abstract in order to avoid typing difficulties <ref> [21] </ref>, and thus we pack the type of the environment and the pair to form an existential type. All functions, including continuation functions introduced during CPS conversion, are thus represented as existentials.
Reference: [22] <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <address> Tucson, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Although type-checkers for decidable type systems will not catch all compiler errors, they have proven themselves valuable debugging tools in practice <ref> [22] </ref>. Despite the numerous advantages of compiling with types, until recently, no compiler propagated type information through the final stages of code generation. The TIL/ML compiler, for instance, preserves types through approximately 80% of compilation but leaves the remaining 20% untyped.
Reference: [23] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> Extended version published as Cornell University technical report TR97-1651, </note> <month> November </month> <year> 1997. </year>
Reference-contexts: Many of the complex tasks of code generation including register allocation and instruction scheduling are left unchecked and types cannot be used to specify or explain these low-level code transformations. These observations motivated our exploration of very low-level type systems and corresponding compiler technology. In Morrisett et al. <ref> [23] </ref>, we presented a typed assembly language (TAL) and proved that its type system was sound with respect to an operational semantics. We demonstrated the expressiveness of this type system by sketching a type-preserving compiler from an ML-like language to TAL. <p> The other non-standard instruction is malloc, which is explained below. Evaluation is specified as a deterministic rewriting system that takes programs to programs (see Morrisett et al. <ref> [23] </ref> for details). The types for TAL consist of type variables, integers, tuple types, existential types, and polymorphic code types. Tuple types contain initialization flags (either 0 or 1) that indicate whether or not components have been initialized.
Reference: [24] <author> Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: [25] <author> Simon L. Peyton Jones, Cordelia V. Hall, Kevin Hammond, Will Partain, and Philip Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: [26] <author> John Reynolds. </author> <title> Using functor categories to generate intermediate code. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: It appears that this limitation could be removed by introducing a limited form of intersection type, but we have not yet explored the ramifications of this enhancement. 13 5 Related and Future Work Our work is partially inspired by Reynolds <ref> [26] </ref>, which uses functor categories to "replace continuations by instruction sequences and store shapes by descriptions of the structure of the run-time stack." However, Reynolds was primarily concerned with using functors to express an intermediate language of a semantics-based compiler for Algol, whereas we are primarily concerned with type structure for
Reference: [27] <author> John C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <booktitle> In Information Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year> <booktitle> Proceedings of the IFIP 9th World Computer Congress. </booktitle>
Reference-contexts: Our type system describes this well-known connection elegantly. 2 Some intuition on this topic may be obtained from Reynolds' theorem on parametric polymorphism <ref> [27] </ref> but a formal proof is difficult. 9 (H; fsp 7! nil g; I) where H = l fact: code []fr1 : hi; r2 : int; sp : ; ra : t g. % main entry point for factorial bneq r2,l nonzero [] % if n = 0 continue mov r1,1
Reference: [28] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Workshop on Types in Compilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: [29] <author> Zhong Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. In many cases, without types, these transformations are less effective or simply impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: [30] <author> Raymie Stata and Martn Abadi. </author> <title> A type system for java bytecode subroutines. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: Stata and Abadi <ref> [30] </ref> formalize the Java bytecode verifier's treatment of subroutines by giving a type system for a subset of the Java Virtual Machine language.
Reference: [31] <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. In many cases, without types, these transformations are less effective or simply impossible. <p> Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads when continuations are heap allocated <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments.
Reference: [32] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: [33] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Consequently, procedure call must be a primitive construct (which it is in JVML). In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [8, 33] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion on abstracted region variables plays a critical role.
Reference: [34] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proceedings of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <month> August </month> <year> 1980. </year> <month> 16 </month>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads when continuations are heap allocated <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments.
References-found: 34

