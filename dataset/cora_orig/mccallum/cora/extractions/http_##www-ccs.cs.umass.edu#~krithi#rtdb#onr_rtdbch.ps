URL: http://www-ccs.cs.umass.edu/~krithi/rtdb/onr_rtdbch.ps
Refering-URL: http://www-ccs.cs.umass.edu/rtdb/publications.html
Root-URL: 
Title: Scheduling In Real-Time Transaction Systems  
Author: John A. Stankovic, Krithi Ramamritham, and Don Towsley 
Note: This work was supported by ONR under contracts NOOO14-85-K-0389 and N00014-87-K-796, and NSF under grants IRI-8908693 and DCR-8500332.  
Address: Amherst, Mass. 01003  
Affiliation: Dept. of Computer and Information Science University of Massachusetts  
Abstract: In many application areas database management systems may have to operate under real-time constraints. We have taken an integrated approach to developing algorithms for cpu scheduling, con-currency control (based both on locking and on optimistic concur-rency control), conflict resolution, transaction restart, transaction wakeup, deadlock, buffer management, and disk I/O scheduling. In all cases the algorithms directly address real-time constraints. We have developed new algorithms, implemented them on an experimental testbed called RT-CARAT, and evaluated their performance. We have paid particular note to how the algorithms interact with each other and to actual implementation costs and their impact on performance. The experimental results are numerous and constitute the first such results on an actual real-time database testbed. The main algorithms and conclusions reached are presented in this Chapter. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Abbott and H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions," </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: In this study, some of the protocols 1 Note that there are no standard workloads for real-time transactions, but a value function has been used in other real-time system work <ref> [24, 1] </ref>. assume that the transaction length is known when the transaction is submitted to the system.
Reference: [2] <author> R. Abbott and H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions: A Performance Evaluation," </title> <booktitle> Proceedings of the 14th VLDB Conference, </booktitle> <year> 1988. </year>
Reference: [3] <author> R. Abbott and H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions with Disk Resident Data," </title> <booktitle> Proceedings of the 15th VLDB Conference, </booktitle> <year> 1989. </year>
Reference: [4] <author> R. Agrawal, M.J. Carey and M. Livny, </author> <title> "Concurrency Control Performance Modeling: Alternatives and Implications," </title> <booktitle> ACM Transaction on Database Systems, </booktitle> <address> Vol.12, No.4, </address> <month> December </month> <year> 1987. </year>
Reference-contexts: This model is an extended version of the model used in <ref> [4] </ref>. The system contains a fixed number of users that submit transaction requests separated by a think time. This model captures many applications in the real world, although certainly not all applications (e.g., an open system model is more appropriate for a process control system).
Reference: [5] <editor> A.P. Buchmann, et. al., </editor> <title> "Time-Critical Database Scheduling: A Framework For Integerating Real-Time Scheduling and Concur-rency Control," </title> <booktitle> Data Engineering Conference, </booktitle> <month> February </month> <year> 1989. </year>
Reference-contexts: These scheduling algorithms are not adequate for real-time transactions. In real-time environments, transactions should get access to the CPU based on criticalness and deadline, not fairness. If the complete data access requirements and timing constraints are known in advance, then scheduling can be done through transaction preanalysis <ref> [5] </ref>. On the other hand, in many cases complete knowledge may not be available. Then a priority based scheduling algorithm may be used, where the priority is set based on deadline, criticalness, length of the transaction, or some combination of these factors. We consider three simple CPU scheduling algorithms.
Reference: [6] <author> M. J. Carey, R. Jauhari and M. Livny, </author> <title> "Priority in DBMS Resource Scheduling," </title> <booktitle> Proceedings of the 15th VLDB Conference, </booktitle> <year> 1989. </year>
Reference: [7] <author> S. Chen, J. Stankovic, J. Kurose, and D. Towsley, </author> <title> "Performance Evaluation of Two New Disk Scheduling Algorithms for Real-Time Systems," </title> <note> submitted for publication, </note> <month> August, </month> <year> 1990. </year>
Reference-contexts: The performance of SSEDO and SSEDV algorithms is compared with three real-time disk scheduling algorithms proposed in the literature, ED, P-SCAN, and FD-SCAN, as well as four conventional algorithms SSTF, SCAN, C-SCAN, and FCFS. See <ref> [7] </ref> for a full description of these algorithms and their performance evaluation. An important aspect of the performance study is that the evaluation is not done in isolation with respect to the disk, but as part of an integrated collection of protocols necessary to support a real-time transaction system.
Reference: [8] <author> S. Chen, and D. Towsley, </author> <title> "Performance of a Mirrored Disk in a Real-Time Transaction System," </title> <note> to appear Proc. 1991 ACM SIG-METRICS, </note> <month> May </month> <year> 1991. </year>
Reference: [9] <author> U. Dayal, et. al., </author> <title> "The HiPAC Project: Combining Active Database and Timing Constraints," </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1988. </year>
Reference: [10] <author> U. Dayal, </author> <title> "Active Database Management Systems," </title> <booktitle> Proceedings of the 3rd International Conference on Data and Knowledge Management, </booktitle> <month> June </month> <year> 1988. </year>
Reference: [11] <author> W. Effelsberg and T. Haerder, </author> <title> "Principles of Database Buffer Man--agement," </title> <journal> ACM Transactions on Database Systems, Vol.9, </journal> <volume> No.4, </volume> <month> December </month> <year> 1984. </year>
Reference-contexts: Buffer management policies should capitalize on one or more of these three types of locality. Buffer allocation and buffer replacement are considered to be two basic components of database buffer management <ref> [11] </ref>. Buffer allocation strategies attempt to distribute the available buffer frames among concurrent database transactions, while buffer replacement strategies attempt to minimize the buffer fault rate for a given buffer size and allocation.
Reference: [12] <author> J. R. Haritsa, M.J. Carey and M. Livny, </author> <title> "On Being Optimistic about Real-Time Constraints," </title> <booktitle> PODS, </booktitle> <year> 1990. </year>
Reference-contexts: In particular, the protocols are sensitive to priority inversion, but not to resource contention (as measured by I/O utilization). Furthermore, in contrast to the simulation results from <ref> [12, 13] </ref>, our experimental results show that OCC may not always outperform a 2PL protocol which aborts the lower priority transaction when conflict occurs. The optimistic scheme performs better than the two-phase locking scheme when data contention is low, and vice versa when data contention is high.
Reference: [13] <author> J. R. Haritsa, M.J. Carey and M. Livny, </author> <title> "Dynamic Real-Time Optimistic Concurrency Control," </title> <booktitle> Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: In particular, the protocols are sensitive to priority inversion, but not to resource contention (as measured by I/O utilization). Furthermore, in contrast to the simulation results from <ref> [12, 13] </ref>, our experimental results show that OCC may not always outperform a 2PL protocol which aborts the lower priority transaction when conflict occurs. The optimistic scheme performs better than the two-phase locking scheme when data contention is low, and vice versa when data contention is high.
Reference: [14] <author> M. Hsu, R. Ladin and D.R. McCarthy, </author> <title> "An Execution Model for Active Database Management Systems," </title> <booktitle> Proceedings of the 3rd International Conference on Data and Knowledge Management, </booktitle> <month> June </month> <year> 1988. </year>
Reference: [15] <author> J. Huang, J. Stankovic, D. Towsley, and K. Ramamritham, </author> <title> "Experimental Evaluation of Real-Time Transaction Processing," </title> <booktitle> Proc. Real-Time System Symposium, </booktitle> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: In this section, we explicitly address the problems of CPU scheduling, conflict resolution, and deadlock resolution. The algorithms for transaction wakeup and transaction restart are not presented here due to space limitations and due to the fact that these algorithms do not significantly impact performance. See <ref> [15] </ref> for a full description of all these algorithms and their performance evaluation. CPU Scheduling There is a wide variety of algorithms for scheduling the CPU in traditional database systems. Such algorithms usually emphasize fairness and attempt to balance CPU and I/O bound transactions.
Reference: [16] <author> J. Huang and J. Stankovic, </author> <title> "Real-Time Buffer Management," </title> <type> COINS TR 90-65, </type> <month> August </month> <year> 1990. </year>
Reference-contexts: To achieve this goal, buffer management should consider not only transaction reference behaviors, but also the timing requirements of the referencing transactions. We investigated several real-time buffer organizations based on the system structure of RT-CARAT which includes a workspace buffer for each transaction <ref> [16] </ref>. On RT-CARAT, we then implemented a global buffer in connection with a transaction recovery scheme using after-image journaling. Based on the overall system structure, we studied both real-time buffer allocation and real-time buffer replacement for the management of this global buffer which captures inter-transaction locality and restart-transaction locality.
Reference: [17] <author> J. Huang, J. Stankovic, D. Towsley, and K. Ramamritham, </author> <title> "Priority Inheritance Under Two-Phase Locking," </title> <note> submitted for publication, </note> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: It has been shown that this approach is effective in real-time operating systems. The goal of this work is to investigate Priority Inheritance in real-time transaction systems. By implementing and evaluating Priority Inheritance in our testbed <ref> [17] </ref>, we found that for short transactions the performance of the system using Priority Inheritance is better than using simple two-phase locking.
Reference: [18] <author> J. Huang and J.A. Stankovic, </author> <title> "Concurrency Control in Real-Time Database Systems: Optimistic Scheme vs. Two-Phase Locking," </title> <type> A Technical Report, COINS 90-66, </type> <institution> University of Massachusetts, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Owing to its potential for a high degree of parallelism, optimistic concurrency control is expected to perform better than two-phase locking when integrated with priority-driven CPU scheduling in real-time database systems. In this study <ref> [18, 19] </ref>, we examine the overall effects and the impact of the overheads involved in implementing real-time optimistic concur-rency control. Using a locking mechanism to ensure the correctness of the OCC implementation, we develop a set of optimistic concurrency control protocols.
Reference: [19] <author> J. Huang, J.A. Stankovic, K. Ramamritham and D. Towsley, </author> <title> "Performance Evaluation of Real-Time Optimistic Concurrency Control Schemes," </title> <note> submitted for publication VLDB, also appears as A Technical Report, COINS 91-16, </note> <institution> University of Massachusetts, </institution> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Owing to its potential for a high degree of parallelism, optimistic concurrency control is expected to perform better than two-phase locking when integrated with priority-driven CPU scheduling in real-time database systems. In this study <ref> [18, 19] </ref>, we examine the overall effects and the impact of the overheads involved in implementing real-time optimistic concur-rency control. Using a locking mechanism to ensure the correctness of the OCC implementation, we develop a set of optimistic concurrency control protocols.
Reference: [20] <author> J. P. Kearns and S. DeFazio, </author> <title> "Diversity in Database Reference Behavior," Performance Evaluation Review, </title> <address> Vol.17, No.1, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The principle of buffer management is based on transaction reference behaviors <ref> [20] </ref>.
Reference: [21] <author> W. Kohler and B.P. Jenq, "CARAT: </author> <title> A Testbed for the Perfor--mance Evaluation of Distributed Database Systems," </title> <booktitle> Proc. of the Fall Joint Computer Conference, IEEE Computer Society and ACM, </booktitle> <address> Dallas Texas, </address> <month> November </month> <year> 1986. </year>
Reference: [22] <author> H. T. Kung and J.T. Robinson, </author> <title> "On Optimistic Methods for Concurrency Control," </title> <journal> ACM Transactions on Database Systems, Vol.6, No.2, </journal> <month> June </month> <year> 1981. </year>
Reference-contexts: Optimistic Concurrency Control While two-phase locking is widely used for concurrency control in non real-time database systems, this approach has some inherent disadvantages for real-time systems, such as the possibility of deadlocks and long and unpredictable blocking times. In seeking alternatives of two-phase locking, we investigate the optimistic approach <ref> [22] </ref> which ideally has the properties of non-blocking and deadlock freedom. Owing to its potential for a high degree of parallelism, optimistic concurrency control is expected to perform better than two-phase locking when integrated with priority-driven CPU scheduling in real-time database systems.
Reference: [23] <author> K. J. Lin, </author> <title> "Consistency Issues in Real-Time Database Systems," </title> <booktitle> Proceedings of the 22nd Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1989. </year>
Reference-contexts: As is usually required in traditional database systems, we also require that all the real-time transaction operations maintain data consistency as defined by serializability. Serializability may be relaxed in some real-time database systems, depending on the application environment and data properties <ref> [27, 29, 23] </ref>, but this is not considered here.
Reference: [24] <author> C. D. Locke, </author> <title> "Best-Effort Decision Making for Real-Time Scheduling," </title> <type> Ph.D. Dissertation, </type> <institution> Canegie-Mellon University, </institution> <year> 1986. </year>
Reference-contexts: In this study, some of the protocols 1 Note that there are no standard workloads for real-time transactions, but a value function has been used in other real-time system work <ref> [24, 1] </ref>. assume that the transaction length is known when the transaction is submitted to the system. <p> In a real-time database, each transaction imparts a value to the system, which is related to its criticalness and to when it completes execution (relative to its deadline). In general, the selection of a value function depends on the application <ref> [24] </ref>. In this work, we model the value of a transaction as a function of its criticalness, start time, deadline, and the current system time. Here criticalness represents the importance of transactions, while deadlines constitute the time constraints of real-time transactions.
Reference: [25] <author> G. M. Sacco and M. Schkolnick, </author> <title> "Buffer Management in Relational Database Systems," </title> <booktitle> ACM Transaction on Database Systems, </booktitle> <address> Vol.11, No.4, </address> <month> December </month> <year> 1986. </year>
Reference: [26] <author> L. Sha, R. Rajkumar and J.P. Lehoczky, </author> <title> "Concurrency Control for Distributed Real-Time Databases," </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1988. </year>
Reference: [27] <author> S. H. Son, </author> <title> "Using Replication for High Performance Database Support in Distributed Real-Time Systems," </title> <booktitle> Proceedings of the 8th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference-contexts: As is usually required in traditional database systems, we also require that all the real-time transaction operations maintain data consistency as defined by serializability. Serializability may be relaxed in some real-time database systems, depending on the application environment and data properties <ref> [27, 29, 23] </ref>, but this is not considered here.
Reference: [28] <author> S. H. Son and C.H. Chang, </author> <title> "Priority-Based Scheduling in Real-Time Database Systems," </title> <booktitle> Proceedings of the 15th VLDB Conference, </booktitle> <year> 1989. </year>
Reference: [29] <author> J. A. Stankovic and W. Zhao, </author> <title> "On Real-Time Transactions," </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: As is usually required in traditional database systems, we also require that all the real-time transaction operations maintain data consistency as defined by serializability. Serializability may be relaxed in some real-time database systems, depending on the application environment and data properties <ref> [27, 29, 23] </ref>, but this is not considered here. <p> When the virtual clock of an executing transaction has surpassed its deadline, it cannot be aborted. Intuitively, this means that for the transaction T H to make its deadline, we are predicting that it should not be aborted. For further details about this protocol, the reader is referred to <ref> [29] </ref>. Protocol 5 (CRP5): Based on combining transaction parameters. This protocol takes into account a variety of different information about the involved transactions. It uses a function CP T (t) to make decisions. <p> Again, the reader is referred to <ref> [29] </ref> for further discussion of this protocol. In a disk resident database system, it is difficult to determine the computation time and I/O time of a transaction.
References-found: 29

