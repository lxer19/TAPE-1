URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_8E_pp314-358.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Title: of Computing An Algebraic Semantic Framework for Object Oriented Languages with Concurrency 1  
Author: Ruth Breu and Elena Zucca 
Keyword: Object oriented languages; Semantics; Concurrency; Algebraic specifications; Labelled transition systems; Classes; Inheritance; Object identity.  
Address: Genova, Italy  
Affiliation: 1 Inst. fur Informatik, TU Munchen, Munchen, Germany; 2 DISI Dipartimento di Informatica e Scienze dell'Informazione, Universita di Genova,  
Note: Formal Aspects of Computing (1996) 8E: 314 358 c 1996 BCS Formal Aspects  
Abstract: This paper presents an algebraic semantics for a schema of object oriented languages including concurrent features. A class, the basic syntactic unit of object oriented languages, denotes a set of algebras determined by an algebraic specification. This specification describes a system of (possibly active) objects interacting via method calls. Extending other approaches, structured classes are modelled in a fully compositional way. This means that the semantic counterpart of class combinators like inheritance and clientship are specification combinators. A model of records with sharing allows us to describe typical object oriented features like object sharing, inheritance polymorphism and dynamic binding. For modelling how objects evolve in a concurrent environment, we rely on an algebraic description of labelled transition systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Ame86] <author> P. </author> <title> America. POOL-T A parallel object-oriented language. In Object-Oriented Concurrent Systems. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: A variety of different features can be provided in these languages for achieving process communication, mutual exclusion and scheduling policies. For example DRAGOON [BKS88] allows the declaration of a policy of mutual exclusion between methods inside an object (see below), while POOL-T <ref> [Ame86] </ref> introduces synchronization and communication between active objects via method calls: when issuing a method call, the caller's thread remains suspended until the call is accepted and the execution of the corresponding method is performed by the receiver; the receiver can specify the set of methods that can be accepted at
Reference: [Ame91] <author> P. </author> <title> America. Designing an object-oriented programming language with behavioural subtyping. </title> <booktitle> In Proc. REX School/Workshop on Foundations of Object Oriented Languages, Noordwijkerhout (NL), 489 in LNCS, </booktitle> <pages> pages 60-90, </pages> <address> Berlin, 1991. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Either a method is deferred, i.e. totally unspecified, or it is implemented, i.e. its behaviour is totally fixed. Some approaches try to overcome this lack of expressiveness by integrating more sophisticated specification facilities. Most of them are based on the specification of pre- and postconditions of methods (e.g. <ref> [ScP87, Win87, Mey88, Ame91] </ref>). Our semantic framework provides an ideal setting for integrating such specification facilities in a way that the correctness of method implementations with respect to their abstract specification can be proved formally.
Reference: [AdB86] <author> P. America, J. de Bakker, Kok J., and J. Rutten. </author> <title> Denotational semantics of a parallel object-oriented language. </title> <type> Technical Report CS-R8626, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1986. </year>
Reference: [ANB86] <author> E. Astesiano, C. Bendix Nielsen, N. Botta, A. Fantechi, A. Giovini, P. Inverardi, E. Karlsen, F. Mazzanti, J. Storbank Pedersen, G. Reggio, and E. Zucca. </author> <title> The draft formal definition of ANSI/MIL-STD 1815a Ada. Technical Report 7, deliverable of the project "The Draft Formal Definition of ANSI/STD 1815a Ada", </title> <year> 1986. </year>
Reference: [AsC92] <author> E. Astesiano and M. Cerioli. </author> <title> Partial higher-order specifications. </title> <journal> Fundamenta Informaticae, </journal> <volume> 16(2) </volume> <pages> 101-126, </pages> <year> 1992. </year>
Reference-contexts: In the specification P rocess (C; c) below we assume to have built-in higher-order sorts (those of the form (s 1 ; : : : s n ) ! s) and operations for building higher-order terms (-abstractions, if then else). For foundations of higher-order partial algebras see <ref> [AsC92] </ref>. Let RES = fT j m: (C; w) ! T 2 F ull-M ethod-Sig (C; c)g [ fnullg; again, T denotes T , if T is a basic sort, name T if T is a class sort.
Reference: [AGR89] <author> E. Astesiano, A. Giovini, G. Reggio, and E. Zucca. </author> <title> An integrated algebraic approach to the specification of data types, processes and objects. </title> <editor> In M. Wirsing and J.A. Bergstra, editors, </editor> <booktitle> Algebraic Methods: Theory, Tools and Applications, 394 in LNCS, </booktitle> <pages> pages 91-116, </pages> <address> Berlin, 1989. </address> <publisher> Springer Verlag. </publisher>
Reference: [AsR93] <author> E. Astesiano and G. Reggio. </author> <title> Algebraic specification of concurrency. </title> <editor> In M. Bidoit and C. Choppy, editors, </editor> <title> Recent Trends in Data Type Specification (Dourdan, </title> <address> France, </address> <month> August </month> <year> 1991), </year> <booktitle> 655 in LNCS, </booktitle> <address> Berlin, 1993. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: By concurrent environment we mean a context where many processes are acting in parallel, each one executing either a thread or a method of some existing object. We first give a brief introduction to the approach to concurrency based on algebraic transition systems (see <ref> [AsR93] </ref>), starting from the notion of labelled transition system. <p> We refer to <ref> [AsR93] </ref> for richer parametric schemas which enable to model a great variety of concrete distributed systems or concurrent languages. The schema we present in this paper models only an interleaving form of parallelism between processes and, as already said, does not consider open systems. <p> This idea is extremely fruitful and at the root of a variety of formalisms (see <ref> [AsR93] </ref> for references). Nevertheless, somebody could not like the fact that in this approach there is no strong distinction between static and dynamic aspects of a system.
Reference: [AsZ93] <author> E. Astesiano and E. Zucca. </author> <title> A semantic model for dynamic systems. </title> <editor> In U.W. Lipeck and B. Thalheim, editors, </editor> <title> Modelling Database Dynamics, </title> <booktitle> Volkse 1992, Workshops in Computing, </booktitle> <pages> pages 63-83. </pages> <publisher> Springer Verlag, </publisher> <address> London, </address> <year> 1993. </year>
Reference-contexts: a value of a special sort (obj-env for "object environment" in what follows); the fact that an object can change from a configuration into another, but preserving its identity, can be modelled having, for each class name C, a sort of corresponding object names (name C in what follows); see <ref> [AsZ93, AsZ95] </ref> for an extension of the algebraic approach which enables a more abstract description of these features. The basic operations which can be performed on an object environment are reading/updating an attribute of an existing object and creating a new object of an existing class.
Reference: [AsZ95] <author> E. Astesiano and E. Zucca. D-oids: </author> <title> a model for dynamic data-types. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5(2) </volume> <pages> 257-282, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: a value of a special sort (obj-env for "object environment" in what follows); the fact that an object can change from a configuration into another, but preserving its identity, can be modelled having, for each class name C, a sort of corresponding object names (name C in what follows); see <ref> [AsZ93, AsZ95] </ref> for an extension of the algebraic approach which enables a more abstract description of these features. The basic operations which can be performed on an object environment are reading/updating an attribute of an existing object and creating a new object of an existing class. <p> Indeed some work has been done in extending in a more proper way the algebraic treatment to the dynamic case, introducing a new kind of structures which are a generalization of usual algebras, called d-oids ([AsZ93], <ref> [AsZ95] </ref>). In this approach, the "state-as-algebra" view is taken, like in [Gur91], seeing configurations as usual algebras and transformations as operations at a higher level, ie operations handling algebras.
Reference: [BKS88] <author> R. Bayan, F. Kaag, A. Spasojevic, A. Di Maio, C. Cardigno, S. Gatti, S. Crespi Reghizzi, E. Astesiano, A. Giovini, B. Gautier, C. Atkinson, M. Wirsing, R. Hen-nicker, and E. Zucca. </author> <title> An object oriented approach to dragon. </title> <type> Technical report, </type> <institution> deliverable of the project "DRAGON" (Esprit 1550), </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: A variety of different features can be provided in these languages for achieving process communication, mutual exclusion and scheduling policies. For example DRAGOON <ref> [BKS88] </ref> allows the declaration of a policy of mutual exclusion between methods inside an object (see below), while POOL-T [Ame86] introduces synchronization and communication between active objects via method calls: when issuing a method call, the caller's thread remains suspended until the call is accepted and the execution of the corresponding
Reference: [Bre91] <author> R. Breu. </author> <title> Algebraic Specification Techniques in Object Oriented Programming Environment. </title> <booktitle> 562 in LNCS. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year> <type> PhD thesis, </type> <institution> Universitat Passau TUMunchen. </institution>
Reference-contexts: First, the embedding of inheritance within the theory of algebraic implementation relations allows an application of results and extensions within a well-studied theory. A thorough discussion of this aspect in a sequential environment can be found in <ref> [Bre91] </ref>. Second, the above view of inheritance supports principles of object oriented design which have been postulated by many authors, e.g. by Meyer for the language Eiffel. In these approaches to object oriented design, inheritance is proposed as a mechanism supporting the step by step development of systems. <p> A slightly different approach in which a (sequential) class can be associated with an algebraic specification specifying its abstract behaviour has been studied in <ref> [Bre91] </ref>. An extension to the general concurrent case has still to be done. 3. <p> This is particularly relevant in the case in which an object oriented language is used in the design stage of software, as for example pursued in the approach of [Mey88]. The relation between a sequential object oriented approach and algebraic specifications has been deeply investigated in <ref> [Bre91] </ref>. On this foundation, a full methodology for object oriented development, tools and languages supporting such a methodology could be based.
Reference: [BrZ89] <author> R. Breu and E. Zucca. </author> <title> An algebraic compositional semantics of an object oriented notation with concurrency. </title> <editor> In C.E. Veni Madhavan, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science 1989, 405 in LNCS, </booktitle> <pages> pages 131-142, </pages> <address> Berlin, December 1989. </address> <publisher> Springer Verlag. </publisher>
Reference: [BrW82] <author> M. Broy and M. Wirsing. </author> <title> Partial abstract types. </title> <journal> Acta Informatica, </journal> <volume> 18, </volume> <year> 1982. </year>
Reference: [BrL90] <author> K.B. Bruce and G. Longo. </author> <title> A modest model of records, inheritance and bounded quantification. </title> <journal> Information and Computation, </journal> 87(1/2):196-240, 1990. 
Reference-contexts: A similar idea can be found, applied to storage structures, in [Jon81]; moreover, some comparison can be made with the model of types as partial equivalence relations (see for instance <ref> [BrL90] </ref>). The main idea is to see an object as an equivalence class. First we give an intuitive explanation.
Reference: [Car84] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <booktitle> In Proc. International Symposium on Semantics of Data Types, 173 in LNCS, </booktitle> <pages> pages 51-67, </pages> <address> Berlin, 1984. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: In this spirit, an heir class describes a set of objects which is a subset of the objects described by its ancestor class. Similar models which are based on a notion of set inclusion are classic approaches to inheritance in the literature (e.g. <ref> [Car84] </ref>). This view supports the type aspect of inheritance within the semantics (cf the remarks in Example 1.1). We formalize now the approach outlined above in our semantic framework.
Reference: [CaM89] <author> L. Cardelli and J.C. Mitchell. </author> <title> Operations on records. </title> <booktitle> In Proc. 5th International Conference on Mathematical Foundation of Programming Semantics, </booktitle> <institution> Tulane University, </institution> <address> New Orleans, </address> <year> 1989. </year>
Reference-contexts: This state can be changed as an effect of calling methods of the object from the ouside. In this paper, we assume for simplicity that an object state has a record structure, as modelled in <ref> [CaM89] </ref> and as it is in most existing object oriented languages. That means that, as assumed in the language schema in Section 1, the internal state of an object is determined by its attributes, which are either basic values or (references to) other objects.
Reference: [CHC90] <author> W.R. Cook, W.L. Hill, and P.S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In ACM Symp. on Principles of Programming Languages 1990, </booktitle> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year>
Reference: [EGS93] <author> H. D. Ehrich, M. Gogolla, and A. Sernadas. </author> <title> Objects and their specification. </title> <editor> In M. Bidoit and C. Choppy, editors, </editor> <title> Recent Trends in Data Type Specification (Dourdan, </title> <address> France, </address> <month> August </month> <year> 1991), </year> <booktitle> 655 in LNCS, </booktitle> <address> Berlin, 1993. </address> <publisher> Springer Verlag. </publisher>
Reference: [GoR83] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference: [Gur91] <author> Y. Gurevich. </author> <title> Evolving algebra, a tutorial introduction. </title> <journal> Bull. of EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: Indeed some work has been done in extending in a more proper way the algebraic treatment to the dynamic case, introducing a new kind of structures which are a generalization of usual algebras, called d-oids ([AsZ93], [AsZ95]). In this approach, the "state-as-algebra" view is taken, like in <ref> [Gur91] </ref>, seeing configurations as usual algebras and transformations as operations at a higher level, ie operations handling algebras. An interesting further work in that direction would be to give within this new framework a compositional model of classes as the one proposed in this paper. Acknowledgment.
Reference: [Jon81] <author> H.B.M. Jonkers. </author> <title> Abstract storage structures. </title> <editor> In J.W. de Bakker and J.C. van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> pages 321-343. </pages> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: The formalization is quite straightforward. We prefer to present here another model of object environments, which is interesting especially for what concerns the way in which object sharing is represented. A similar idea can be found, applied to storage structures, in <ref> [Jon81] </ref>; moreover, some comparison can be made with the model of types as partial equivalence relations (see for instance [BrL90]). The main idea is to see an object as an equivalence class. First we give an intuitive explanation.
Reference: [Mey88] <author> B. Meyer. </author> <title> Object Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year> <title> An Algebraic Semantic Framework for Object Oriented Languages with Concurrency 357 </title>
Reference-contexts: Though the result of Fact 2.6 is not very surprising from the theoretical point of view, this fact is very important concerning aspects of design methodology. Fact 2.6 shows clearly the effect of inheritance concerning the module aspect of a class (cf <ref> [Mey88] </ref> and the remarks in Example 1.1). Conceiving a module (or a class) as an entity offering services to the outside, the notion of modules corresponds to the notion of specifications, or at the semantic level, to the notion of signatures and model sets. <p> Either a method is deferred, i.e. totally unspecified, or it is implemented, i.e. its behaviour is totally fixed. Some approaches try to overcome this lack of expressiveness by integrating more sophisticated specification facilities. Most of them are based on the specification of pre- and postconditions of methods (e.g. <ref> [ScP87, Win87, Mey88, Ame91] </ref>). Our semantic framework provides an ideal setting for integrating such specification facilities in a way that the correctness of method implementations with respect to their abstract specification can be proved formally. <p> Our object model describes typical object oriented features like object sharing, inheritance polymorphism and dynamic binding of methods. Accordingly to the twofold view of classes as modules and as types which has been suggested by Meyer in <ref> [Mey88] </ref>, a clear modelling of inheritance on these two very different levels has been achieved. In our framework, the notion of a module corresponds to the notion of specification, or on the semantic level, to signatures and sets of models. <p> This is particularly relevant in the case in which an object oriented language is used in the design stage of software, as for example pursued in the approach of <ref> [Mey88] </ref>. The relation between a sequential object oriented approach and algebraic specifications has been deeply investigated in [Bre91]. On this foundation, a full methodology for object oriented development, tools and languages supporting such a methodology could be based.
Reference: [ScP87] <author> S.A. Schuman and D.H. Pitt. </author> <title> Object-oriented subsystem specification. </title> <booktitle> In Program Specification and Transformation, </booktitle> <pages> pages 313-342. </pages> <publisher> North Holland, </publisher> <year> 1987. </year>
Reference-contexts: Either a method is deferred, i.e. totally unspecified, or it is implemented, i.e. its behaviour is totally fixed. Some approaches try to overcome this lack of expressiveness by integrating more sophisticated specification facilities. Most of them are based on the specification of pre- and postconditions of methods (e.g. <ref> [ScP87, Win87, Mey88, Ame91] </ref>). Our semantic framework provides an ideal setting for integrating such specification facilities in a way that the correctness of method implementations with respect to their abstract specification can be proved formally.
Reference: [Str86a] <author> R. Strom. </author> <title> A comparison of the object-oriented and process paradigm. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(10) </volume> <pages> 88-97, </pages> <year> 1986. </year>
Reference-contexts: Some useful discussion can be found in [Weg87] and in <ref> [Str86a] </ref>. In this paper, we consider as "object oriented languages with concurrent features" languages which support class hierarchies and moreover are "process-based" in the sense of [Weg87], ie in which objects may be active and execute concurrently.
Reference: [Str86b] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [Weg87] <author> P. Wegner. </author> <title> Dimensions of object based language design. </title> <booktitle> In ACM Symp. on Object-Oriented Programming: Systems, Languages and Applications 1987, </booktitle> <pages> pages 168-182, </pages> <year> 1987. </year>
Reference-contexts: In 3.1 and 3.2 we describe the passive part of the concurrent object environment, while in 3.3 we describe processes and the evolution of the system. An Algebraic Semantic Framework for Object Oriented Languages with Concurrency 331 3.1. Object Environments: An Abstract View Following Wegner's definition <ref> [Weg87] </ref>, we consider an object as an entity having an immutable identity and a dynamically evolving state. This state can be changed as an effect of calling methods of the object from the ouside. <p> Attempts at combining concurrent features with a general object oriented schema have been done in many different ways and with different underlying views of the relation between objects and processes, which seems to be a topic deserving a complete clarification. Some useful discussion can be found in <ref> [Weg87] </ref> and in [Str86a]. In this paper, we consider as "object oriented languages with concurrent features" languages which support class hierarchies and moreover are "process-based" in the sense of [Weg87], ie in which objects may be active and execute concurrently. <p> Some useful discussion can be found in <ref> [Weg87] </ref> and in [Str86a]. In this paper, we consider as "object oriented languages with concurrent features" languages which support class hierarchies and moreover are "process-based" in the sense of [Weg87], ie in which objects may be active and execute concurrently. A variety of different features can be provided in these languages for achieving process communication, mutual exclusion and scheduling policies.
Reference: [Win87] <author> J.M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <year> 1987. </year>
Reference-contexts: Either a method is deferred, i.e. totally unspecified, or it is implemented, i.e. its behaviour is totally fixed. Some approaches try to overcome this lack of expressiveness by integrating more sophisticated specification facilities. Most of them are based on the specification of pre- and postconditions of methods (e.g. <ref> [ScP87, Win87, Mey88, Ame91] </ref>). Our semantic framework provides an ideal setting for integrating such specification facilities in a way that the correctness of method implementations with respect to their abstract specification can be proved formally.
Reference: [Wir86] <author> M. Wirsing. </author> <title> Structured algebraic specifications: A kernel language. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 123-250, </pages> <year> 1986. </year>
Reference-contexts: According to Fact 2.6 inheritance can be characterized as a mechanism which constrains model sets 330 R. Breu and E. Zucca and extends signatures. In this sense, inheritance corresponds to implementation relations between algebraic specifications which are common in the algebraic framework (e.g. <ref> [Wir86, Wir88] </ref>). The view of inheritance as a mechanism for implementing a class (specification) is useful for two reasons. First, the embedding of inheritance within the theory of algebraic implementation relations allows an application of results and extensions within a well-studied theory.
Reference: [Wir88] <author> M. Wirsing. </author> <title> Algebraic description of reusable software components. </title> <booktitle> In Proc. COMPEURO 88, 834 in IEEE Computer Society, </booktitle> <pages> pages 300-312. </pages> <publisher> Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: According to Fact 2.6 inheritance can be characterized as a mechanism which constrains model sets 330 R. Breu and E. Zucca and extends signatures. In this sense, inheritance corresponds to implementation relations between algebraic specifications which are common in the algebraic framework (e.g. <ref> [Wir86, Wir88] </ref>). The view of inheritance as a mechanism for implementing a class (specification) is useful for two reasons. First, the embedding of inheritance within the theory of algebraic implementation relations allows an application of results and extensions within a well-studied theory.
Reference: [Wol87] <author> M. Wolczko. </author> <title> Semantics of Smalltalk-80. </title> <editor> In J. Bezivin, J. Hullot, P. Cointe, and H. Lieberman, editors, </editor> <booktitle> ECOOP '87, 276 in LNCS, </booktitle> <pages> pages 108-120, </pages> <address> Berlin, 1987. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Objects as Equivalence Classes Many different concrete models of object environments satisfy the specification given in the preceding subsection. For instance, a model which is quite standard and often used in giving denotational semantics of object oriented languages (see for instance <ref> [Wol87] </ref>) defines the current state of an object as a record with one component for each attribute, being either a basic value (if the corresponding attribute is of a basic sort) or a reference to an object, i.e. an object name (if the corresponding attribute is of a class sort).
References-found: 30

