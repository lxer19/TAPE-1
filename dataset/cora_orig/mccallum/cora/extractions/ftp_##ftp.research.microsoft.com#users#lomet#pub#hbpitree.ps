URL: ftp://ftp.research.microsoft.com/users/lomet/pub/hbpitree.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: The hB -tree: A Modified hB-tree Supporting Concurrency, Recovery and Node Consolidation  
Author: Georgios Evangelidis David Lomet Betty Salzberg 
Address: GR-54639 Thessaloniki, Greece  Redmond, WA 98052  Boston, MA 02115  
Affiliation: Leoforos Stratou 13  Microsoft Corporation  Northeastern University  
Abstract: We describe a new access method, the hB -tree, an adaptation of the hB-tree index to the constraints of the -tree . The -trees, a generalization of the B link -trees, provide high concurrency with recovery, because they break down structure modification into a series of short atomic actions. In addition, the - trees include a node consolidation algorithm. The hB-tree is a multi-attribute index which is highly insensitive to dimensionality, but which has no node consolidation algorithm and has a flaw in its split/post algorithm in certain special cases. The hB -tree corrects the splitting/posting algorithm and adapts the concurrency, recovery and node consolidation of the -tree to the hB-tree. The combination makes the hB -tree suitable for inclusion in a general purpose database management system supporting multi-attribute and spatial queries. keywords: indexing, B-trees, multi-attribute access methods, spatial access methods, con currency, recovery
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Bentley. </author> <title> Multidimensional binary search trees in database applications. </title> <journal> IEEE Trans. on Software En gineering, </journal> <volume> SE-5(4):333-340, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: The nodes of an hB-tree represent bricks (i.e., multi-dimensional rectangles), or "holey" bricks, that is, bricks from which smaller bricks have been removed. An hB-tree node stores index and sibling terms in a unified way using kd-trees <ref> [1] </ref>. In Figures 2a and 2b we can see the organization of an index hB-tree node Q and the corresponding space decomposition.
Reference: [2] <author> R. Bayer and E. McCreight. </author> <title> Organization and main tenance of large ordered indexes. </title> <journal> Acta Informatica, </journal> <volume> 1(3) </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Current DBMSs efficiently organize, access, and manipulate enormous quantities of data for traditional applications in banks, airlines, government agencies, hospitals, and other large organizations. Almost all of them implement some variation of the B + -tree <ref> [2, 4] </ref>. fl This work was partially supported by NSF grants IRI 91-02821 and IRI-93-03403.
Reference: [3] <author> R. Bayer and M. </author> <title> Schkolnick. </title> <journal> Concurrency of opera tions on B-Trees. Acta Informatica, </journal> <volume> 9(1) </volume> <pages> 1-21, </pages> <year> 1977. </year>
Reference-contexts: One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers <ref> [3, 12, 19, 13, 11] </ref>. Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes.
Reference: [4] <author> D. Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(4) </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Current DBMSs efficiently organize, access, and manipulate enormous quantities of data for traditional applications in banks, airlines, government agencies, hospitals, and other large organizations. Almost all of them implement some variation of the B + -tree <ref> [2, 4] </ref>. fl This work was partially supported by NSF grants IRI 91-02821 and IRI-93-03403.
Reference: [5] <author> G. Evangelidis, D. Lomet, and B. Salzberg. </author> <title> Node Deletion in the hB -Tree. </title> <type> Report NU-CCS-94-04, </type> <institution> Northeastern Univ, </institution> <address> Boston, MA, </address> <year> 1994 </year>
Reference-contexts: This flaw does not appear until there are three levels in the index above the leaves and then only in special cases. A construction of such a four-level tree can be found in [17] and <ref> [5] </ref>. <p> Since an hB -tree node uses a kd-tree for its intra-node organization, we also have to reorganize the kd-trees of the parent and container nodes of the extracted node. In <ref> [5] </ref>, we show how one can determine whether a node can be deleted by examining the kd-tree of its parent, how deletion is performed, and how kd-tree node pruning is used to reorganize kd-trees. 5 Performance In this section we demonstrate the performance of the hB -tree on multi-attribute point data. <p> Our experiments show that even with these simpler algorithms the performance is very good. We have also developed a deletion algorithm for the hB -tree <ref> [5] </ref>. We intend to assess the performance of additional splitting/posting algorithms, based on even more flexible splitting strategies, using polygon and graph data from the Sequoia 2000 Storage Benchmark [21].
Reference: [6] <author> G. Evangelidis and B. Salzberg. </author> <title> Using the Holey Brick Tree for Spatial Data in General Purpose DBMSs. </title> <journal> IEEE Data Engineering Bult., </journal> <volume> 16(3) </volume> <pages> 34-39, </pages> <month> Sept </month> <year> 1993. </year>
Reference-contexts: It corrects the flaw in the hB-tree and, with suitable modifications, inherits the concur-rency, recovery and node-deletion algorithms of the -tree. It is insensitive to dimension and so is suitable for high-dimensional applications <ref> [6] </ref>. We have implemented and tested various splitting/posting algorithms for the hB -tree. We found that if we post more information than is actually needed (the full path), or if we restrict index node splits to certain places on their kd-tree (the decorated fragments), our algorithms become simpler.
Reference: [7] <author> O. Guenther. </author> <title> The design of the cell tree: an object ori ented index structure for geometric databases. </title> <booktitle> IEEE Data Engineering Conf., </booktitle> <pages> 598-605, </pages> <address> Los Angeles, CA, </address> <year> 1989. </year>
Reference-contexts: Spatial organization of large databases is a largely unsolved problem. There have been a number of proposals for multi-attribute and spatial indexing in the past 15 years (for example, <ref> [8, 15, 7, 18, 10] </ref>), but none of them has been integrated into a commercial general purpose DBMS. One reason for this is that there are very complicated or no concurrency and recovery methods for them.
Reference: [8] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> ACM/SIGMOD Conf., </booktitle> <pages> 47-57, </pages> <address> Boston, MA, </address> <year> 1984. </year>
Reference-contexts: Spatial organization of large databases is a largely unsolved problem. There have been a number of proposals for multi-attribute and spatial indexing in the past 15 years (for example, <ref> [8, 15, 7, 18, 10] </ref>), but none of them has been integrated into a commercial general purpose DBMS. One reason for this is that there are very complicated or no concurrency and recovery methods for them. <p> For page sizes greater than 1K bytes the hB -tree is fairly insensitive to dimension. (In all cases the same 150,000 24-byte records were inserted with their attribute values following a 90:10 skewed distribution.) This is in contrast, for example, with the R-tree <ref> [8] </ref>, where index entries are bounding coordinates of objects plus a pointer. Thus, in the R-Tree (and its variants) the size of the index is proportional to the dimension of the space.
Reference: [9] <author> D. Lomet. </author> <title> Grow and Post Index Trees: role, tech niques and future potential. </title> <booktitle> Symp. on Large Spa tial Databases (1991) Zurich. In Advances in Spatial Databases, LN in Computer Science 525, </booktitle> <pages> 183-206, </pages> <address> Berlin, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference: [10] <author> D. Lomet and B. Salzberg. </author> <title> The hB-Tree: A multiat tribute indexing method with good guaranteed perfor mance. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 15(4) </volume> <pages> 625-658, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Spatial organization of large databases is a largely unsolved problem. There have been a number of proposals for multi-attribute and spatial indexing in the past 15 years (for example, <ref> [8, 15, 7, 18, 10] </ref>), but none of them has been integrated into a commercial general purpose DBMS. One reason for this is that there are very complicated or no concurrency and recovery methods for them. <p> Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes. The hB -tree is a new access method for multi-attribute point or spatial data that is based on the hB-tree <ref> [10] </ref> and can be used in a general purpose DBMS since a robust concurrency and recovery algorithm is available for it [11] (the "-tree paper"). This algorithm is applicable to an abstract index tree structure, the -tree, which is a generalization of the B link -tree [12]. <p> This paper is organized as follows. Section 2 briefly reviews the -tree. Section 3 introduces the hB - tree, which is a combination of the hB-tree and the -tree. Section 4 introduces the new splitting and posting algorithms which correct the error in <ref> [10] </ref>. Finally, Section 5 reports performance results. 2 Concurrency & recovery: the -tree In this section we review the -tree and its algorithms. <p> We call the resulting tree the hB -tree. 3.1 Multi-attribute indexing The hB-tree <ref> [10] </ref> is a multi-attribute point data indexing method. The nodes of an hB-tree represent bricks (i.e., multi-dimensional rectangles), or "holey" bricks, that is, bricks from which smaller bricks have been removed. An hB-tree node stores index and sibling terms in a unified way using kd-trees [1]. <p> C for an extracted node and its container node respectively, and P for the parent of the container node where the index term that describes the split is posted. 4 hB -tree restructuring In this section, we present new splitting and posting policies which correct the flawed splitting/posting algorithm of <ref> [10] </ref>. This flaw does not appear until there are three levels in the index above the leaves and then only in special cases. A construction of such a four-level tree can be found in [17] and [5]. <p> In the case of D/cp, although condensed paths are posted, the index term that we post when we extract a decorated subtree describes a region which is defined by DSBs. Algorithm A/cp corresponds to the splitting and posting algorithm for the hB-tree described in <ref> [10] </ref>. The strengths and weaknesses of the other algorithms are summarized in Table 2. <p> This obviously results in a substantial increase in data space consumed and hence index size, which becomes worse as the dimension of the data increases. 6 Summary The hB -tree is a combination of the hB-tree <ref> [10] </ref> and the -tree [11]. It corrects the flaw in the hB-tree and, with suitable modifications, inherits the concur-rency, recovery and node-deletion algorithms of the -tree. It is insensitive to dimension and so is suitable for high-dimensional applications [6].
Reference: [11] <author> D. Lomet and B. Salzberg. </author> <title> Access method concur rency with recovery. </title> <booktitle> ACM/SIGMOD Conf., </booktitle> <pages> 351-360, </pages> <address> San Diego, CA, </address> <year> 1992. </year>
Reference-contexts: One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers <ref> [3, 12, 19, 13, 11] </ref>. Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes. <p> One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers [3, 12, 19, 13, 11]. Most of these papers, with the exception of <ref> [13, 11] </ref>, have not addressed the problem of system crashes during structure changes. <p> The hB -tree is a new access method for multi-attribute point or spatial data that is based on the hB-tree [10] and can be used in a general purpose DBMS since a robust concurrency and recovery algorithm is available for it <ref> [11] </ref> (the "-tree paper"). This algorithm is applicable to an abstract index tree structure, the -tree, which is a generalization of the B link -tree [12]. A recent study [20] compared the performance of various concurrency control algorithms. <p> This obviously results in a substantial increase in data space consumed and hence index size, which becomes worse as the dimension of the data increases. 6 Summary The hB -tree is a combination of the hB-tree [10] and the -tree <ref> [11] </ref>. It corrects the flaw in the hB-tree and, with suitable modifications, inherits the concur-rency, recovery and node-deletion algorithms of the -tree. It is insensitive to dimension and so is suitable for high-dimensional applications [6]. We have implemented and tested various splitting/posting algorithms for the hB -tree.
Reference: [12] <author> P. Lehman and S. B. Yao. </author> <title> Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <month> Dec </month> <year> 1981. </year>
Reference-contexts: One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers <ref> [3, 12, 19, 13, 11] </ref>. Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes. <p> This algorithm is applicable to an abstract index tree structure, the -tree, which is a generalization of the B link -tree <ref> [12] </ref>. A recent study [20] compared the performance of various concurrency control algorithms. Its conclusion was that algorithms using the link technique provide the most concurrency and the best overall performance. <p> More formally, as a generalization of the B link - tree <ref> [12] </ref>, the -tree is a rooted DAG. It consists of index and data nodes. Each node is responsible for a specific part of the key space. A -tree node: * Can be directly responsible for some part of the space.
Reference: [13] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> an efficient and high concurrency index management method using write-ahead logging. </title> <type> Report RJ 6846, </type> <institution> IBM Almaden Research Center, </institution> <address> San Jose, CA, </address> <year> 1989. </year>
Reference-contexts: One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers <ref> [3, 12, 19, 13, 11] </ref>. Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes. <p> One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers [3, 12, 19, 13, 11]. Most of these papers, with the exception of <ref> [13, 11] </ref>, have not addressed the problem of system crashes during structure changes.
Reference: [14] <author> J. Nievergelt and Hinrichs. </author> <title> The Grid File: A Data Structure to Support Proximity Queries on Spatial Objects. </title> <booktitle> Int'l Workshop on Graph Theoretic Concepts in Computer Science, </booktitle> <pages> 100-113, </pages> <address> Linz, Austria, </address> <year> 1983. </year>
Reference: [15] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The Grid File: An adaptable, symmetric, multikey file structure. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 9(1):38 71, </volume> <year> 1984. </year>
Reference-contexts: Spatial organization of large databases is a largely unsolved problem. There have been a number of proposals for multi-attribute and spatial indexing in the past 15 years (for example, <ref> [8, 15, 7, 18, 10] </ref>), but none of them has been integrated into a commercial general purpose DBMS. One reason for this is that there are very complicated or no concurrency and recovery methods for them. <p> Thus, in the R-Tree (and its variants) the size of the index is proportional to the dimension of the space. If data is uniformly distributed with respect to all index attributes, the grid file <ref> [15] </ref> can be efficient for large dimension. However, in the case of correlated data, for example, it can be an O (n k ) size index, where n is the number of points and k is the dimension of the space.
Reference: [16] <author> J. A. Orenstein and T. Merrett. </author> <title> A class of data struc tures for associative searching. </title> <booktitle> SIGART-SIGMOD Symp. on Prin. of Database Sys., </booktitle> <pages> 181-190, </pages> <address> Waterloo, Canada, </address> <year> 1984. </year>
Reference-contexts: However, in the case of correlated data, for example, it can be an O (n k ) size index, where n is the number of points and k is the dimension of the space. Z-ordering <ref> [16] </ref> usually requires that the field expressing the interleaved attributes is appended to each record.
Reference: [17] <author> B. Salzberg. </author> <title> On indexing spatial and temporal data. </title> <journal> Information Sys., </journal> <volume> 19(6) </volume> <pages> 447-465, </pages> <year> 1994. </year>
Reference-contexts: This flaw does not appear until there are three levels in the index above the leaves and then only in special cases. A construction of such a four-level tree can be found in <ref> [17] </ref> and [5].
Reference: [18] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + -tree: a dynamic index for multi-dimensional ob jects. </title> <booktitle> VLDB Conf., </booktitle> <pages> 1-24, </pages> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: Spatial organization of large databases is a largely unsolved problem. There have been a number of proposals for multi-attribute and spatial indexing in the past 15 years (for example, <ref> [8, 15, 7, 18, 10] </ref>), but none of them has been integrated into a commercial general purpose DBMS. One reason for this is that there are very complicated or no concurrency and recovery methods for them.
Reference: [19] <author> D. Shasha and N. Goodman. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 13(1) </volume> <pages> 53-90, </pages> <month> Mar </month> <year> 1988. </year>
Reference-contexts: One reason for this is that there are very complicated or no concurrency and recovery methods for them. Concurrency in B + -trees has been the subject of many papers <ref> [3, 12, 19, 13, 11] </ref>. Most of these papers, with the exception of [13, 11], have not addressed the problem of system crashes during structure changes.
Reference: [20] <author> V. Srinivasan and M. Carey. </author> <title> Performance of B tree concurrency control algorithms. </title> <booktitle> ACM/SIGMOD Conf., </booktitle> <pages> 416-425, </pages> <address> Denver, CO, </address> <year> 1991. </year>
Reference-contexts: This algorithm is applicable to an abstract index tree structure, the -tree, which is a generalization of the B link -tree [12]. A recent study <ref> [20] </ref> compared the performance of various concurrency control algorithms. Its conclusion was that algorithms using the link technique provide the most concurrency and the best overall performance.
Reference: [21] <author> M. Stonebraker, J. Frew, K. Gardels, and J. Meredith. </author> <title> The Sequoia 2000 Storage Benchmark. </title> <booktitle> ACM/SIGMOD Conf., </booktitle> <pages> 2-11, </pages> <address> Washington, DC, </address> <year> 1993. </year>
Reference-contexts: We have implemented the hB -tree and tested it in extensive experiments with computer-generated skewed point data and with point data from the Se-quoia 2000 Storage Benchmark <ref> [21] </ref>. We show that the hB -tree is relatively insensitive to dimension. This paper is organized as follows. Section 2 briefly reviews the -tree. Section 3 introduces the hB - tree, which is a combination of the hB-tree and the -tree. <p> We use both computer-generated data and geographic data from the Sequoia project <ref> [21] </ref> and we measure node space utilization and range search performance. We show that the hB -tree is insensitive to dimension. <p> In the second part of our experiment, data from the Sequoia 2000 Storage Benchmark <ref> [21] </ref> was inserted in the hB -tree. These are 62,584 points representing California place names. We tested two of the splitting/posting algorithms we have described in this paper: D/fp, and A/fp. <p> We have also developed a deletion algorithm for the hB -tree [5]. We intend to assess the performance of additional splitting/posting algorithms, based on even more flexible splitting strategies, using polygon and graph data from the Sequoia 2000 Storage Benchmark <ref> [21] </ref>.
References-found: 21

