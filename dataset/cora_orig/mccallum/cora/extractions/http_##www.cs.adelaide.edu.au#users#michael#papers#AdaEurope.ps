URL: http://www.cs.adelaide.edu.au/users/michael/papers/AdaEurope.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 2  
Title: Beyond Ada95: The Addition of Persistence and its Consequences  
Author: Michael J. Oudshoorn and Stephen C. Crawley 
Address: Adelaide, SA 5005, Australia  PO Box 1500, Salisbury, SA 5108, Australia  
Affiliation: 1 Department of Computer Science University of  Defence Science and Technology Organisation  
Abstract: Research into persistent programming languages and systems in recent years has shown that the technology is useful for developing complex software in many problem domains. This paper explores the issues and consequences of adding persistence to Ada95. The persistence extensions support transparent migration of objects between a program's address space and a persistent store in a way that preserves both type safety and encapsulation of abstract data types.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, W. P. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: Persistent objects are typically restored into the memory of a subsequent execution "on demand"; e.g. when the program tries to use them. An early example of a persistence by reachability mechanism [4] was at the heart of PS-Algol [3], the first persistent programming language. Atkinson et al <ref> [1] </ref> proposed the following two design principles for languages that support persistent programming: "The Principle of Persistence Independence: The persistence of a data object is independent of how the program manipulates that data object, and conversely a fragment of program is expressed independently of the persistence of data it manipulates." and <p> In such a language, the type and value spaces for the persistent data are seamless extensions of those of the executing program. Of the four mechanisms above, persistence by reachability is the only one really suitable for supporting orthogonal persistence. Programming languages that use persistence by reachability (e.g. PS-Algol <ref> [1, 3] </ref> and Napier88 [14]) typically have a relatively simple semantic model for the process of saving persistent data. Persistent data is held in a non-volatile database known as a persistent store. At certain points during a program's execution, the persistent store is stabilised.
Reference: 2. <author> M.P. Atkinson and O.P. Buneman. </author> <title> Types and persistence in database programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 19, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: In its broadest sense, the term covers conventional and object-oriented databases, execution check-pointing and data structure pickling as well as more sophisticated transparent mechanisms. There are many possible schemes for supporting persistence for applications systems; for a comprehensive survey, see <ref> [2] </ref>. Restricting our discussion to those mechanisms that make a program's data values or objects persist (rather than saving the data with a different schema), there are four basic approaches; i.e. checkpointing, persistence by property, persistence by copying, and persistence by reachability.
Reference: 3. <author> M.P. Atkinson, K.J. Chisholm, and W.P. Cockshott. </author> <title> PS-Algol: An Algol with a persistent heap. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Persistent objects are typically restored into the memory of a subsequent execution "on demand"; e.g. when the program tries to use them. An early example of a persistence by reachability mechanism [4] was at the heart of PS-Algol <ref> [3] </ref>, the first persistent programming language. <p> In such a language, the type and value spaces for the persistent data are seamless extensions of those of the executing program. Of the four mechanisms above, persistence by reachability is the only one really suitable for supporting orthogonal persistence. Programming languages that use persistence by reachability (e.g. PS-Algol <ref> [1, 3] </ref> and Napier88 [14]) typically have a relatively simple semantic model for the process of saving persistent data. Persistent data is held in a non-volatile database known as a persistent store. At certain points during a program's execution, the persistent store is stabilised.
Reference: 4. <author> M.P. Atkinson, K.J. Chisholm, and W.P. Cockshott. </author> <title> Algorithms for a persistent heap. </title> <journal> Software Practice and Experience, </journal> <volume> 13(3) </volume> <pages> 259-272, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: Persistent objects are typically restored into the memory of a subsequent execution "on demand"; e.g. when the program tries to use them. An early example of a persistence by reachability mechanism <ref> [4] </ref> was at the heart of PS-Algol [3], the first persistent programming language.
Reference: 5. <author> L. Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report SRC Report 45, </type> <institution> DEC Systems Research Centre, Palo Alto, </institution> <year> 1989. </year>
Reference-contexts: Existentially quantified types provide a complete separation of types from their implementations, to the extent that a client of a type can transparently use multiple implementations while preserving type encapsulation. Languages that implement existentially quantified types include Russell [10], Napier88 [14] and Quest <ref> [5] </ref>.
Reference: 6. <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and poly-morphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-523, </pages> <year> 1985. </year>
Reference-contexts: The first option goes part way towards turning package instances into objects. Our second option is to go a step further, replacing Ada packages and private types with an existentially quantified type construct along the lines described by Cardelli <ref> [6] </ref>. Existentially quantified types provide a complete separation of types from their implementations, to the extent that a client of a type can transparently use multiple implementations while preserving type encapsulation. Languages that implement existentially quantified types include Russell [10], Napier88 [14] and Quest [5].
Reference: 7. <author> S.C. Crawley and M.J. Oudshoorn. </author> <title> Orthogonal persistence and Ada. </title> <booktitle> In Proceedings TRI-Ada'94, </booktitle> <address> Baltimore MD, </address> <pages> pages 298-308. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: The term persistent Ada95 is used when referring to the two variants collectively. In this paper, we concentrate mainly on language design issues. For more detailed discussions of the implementation issues, the reader should refer to <ref> [7, 8] </ref>. Note that we do not consider interactions between persistence and the Ada95 specialist annexes. <p> The Ada type system uses name equivalence rather than structural equivalence. Furthermore, the language uses the lifetime of a type as a basis for managing dynamically allocated space. This causes difficulties for persistence in Ada. In <ref> [7] </ref>, we demonstrated that the standard Ada type equivalence and lifetime rules cannot be used for persistent data. We identified four main options for type equivalence of open (not private) data types in persistent Ada95: Use structural equivalence when binding to persistent data, and name equivalence in other situations.
Reference: 8. <author> S.C. Crawley and M.J. Oudshoorn. </author> <title> Persistence extensions to Ada95. </title> <editor> In C. Mingins, R. Duke, and B. Meyer, editors, </editor> <booktitle> Proceedings of TOOLS PACIFIC '95, </booktitle> <address> Melbourne Australia, </address> <pages> pages 25-39. </pages> <publisher> Prentice Hall, </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: The term persistent Ada95 is used when referring to the two variants collectively. In this paper, we concentrate mainly on language design issues. For more detailed discussions of the implementation issues, the reader should refer to <ref> [7, 8] </ref>. Note that we do not consider interactions between persistence and the Ada95 specialist annexes.
Reference: 9. <author> A. Dearle. </author> <title> Environments: a flexible binding mechanism to support system evolution. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on Systems Sciences, </booktitle> <volume> volume 2, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: In Figure 4 for instance, "p" is declared as a variable, so that an assignment to "p" in the body would update a root reachable cell. The benefits of persistent L-value binding are described in <ref> [9] </ref>. Binding to persistent package instances in persistent Ada95b requires syntax extensions to the Ada with statement as used in Figure 5. When this code is compiled, the compiler finds the package specification for "my pack" in the Ada library, and statically checks the usage of imported types and operations.
Reference: 10. <author> J. Donahue and A. Demers. </author> <title> Data types are values. </title> <journal> ACM Transactions on Pro--gramming Languages and Systems, </journal> <volume> 7 </volume> <pages> 426-445, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Existentially quantified types provide a complete separation of types from their implementations, to the extent that a client of a type can transparently use multiple implementations while preserving type encapsulation. Languages that implement existentially quantified types include Russell <ref> [10] </ref>, Napier88 [14] and Quest [5].
Reference: 11. <author> G. Green. </author> <title> Access values pointing to any type. </title> <journal> ACM Ada Letters, </journal> <volume> 10 </volume> <pages> 101-109, </pages> <month> May-June </month> <year> 1990. </year>
Reference-contexts: Notable examples include Green's proposal <ref> [11] </ref>, APPL/A [17], PGRAPHITE [22], the work of Millan et al [13] and Intermetrics' proposed ODMG Ada95 binding [16]. This paper focuses on orthogonal persistence, which we believe most closely matches the high-level design goals for Ada.
Reference: 12. <author> ISO. </author> <title> Ada95 Reference Manual. International Standard ANSI/ISO/IEC-8652:1995, </title> <year> 1995. </year>
Reference-contexts: 1 Introduction Ada has recently undergone a major cycle of review and update. The result of this is the new programming language Ada95 <ref> [12] </ref> which is, in the main, backward compatible with Ada83 [18]. Two of the principle changes to Ada were the addition of constructs to make it a fully fledged object-oriented language and the use of annexes for defining specialist language capabilities.
Reference: 13. <author> T. Millan and F. Mulatero. </author> <title> Ada persistence through an OODBMS O2. </title> <journal> Ada User Journal, </journal> <volume> 16 </volume> <pages> 71-82, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Notable examples include Green's proposal [11], APPL/A [17], PGRAPHITE [22], the work of Millan et al <ref> [13] </ref> and Intermetrics' proposed ODMG Ada95 binding [16]. This paper focuses on orthogonal persistence, which we believe most closely matches the high-level design goals for Ada. Orthogonal persistence offers the highest level of reliability and maintainability of all forms of persistence, and supports the broadest range of (non real-time) applications.
Reference: 14. <author> R. Morrison, A. Brown, R.C.H. Connor, and A. Dearle. </author> <title> The Napier88 reference manual. </title> <type> Technical Report PPRR-77-89, </type> <institution> University of St Andrews, </institution> <year> 1989. </year>
Reference-contexts: Of the four mechanisms above, persistence by reachability is the only one really suitable for supporting orthogonal persistence. Programming languages that use persistence by reachability (e.g. PS-Algol [1, 3] and Napier88 <ref> [14] </ref>) typically have a relatively simple semantic model for the process of saving persistent data. Persistent data is held in a non-volatile database known as a persistent store. At certain points during a program's execution, the persistent store is stabilised. <p> Existentially quantified types provide a complete separation of types from their implementations, to the extent that a client of a type can transparently use multiple implementations while preserving type encapsulation. Languages that implement existentially quantified types include Russell [10], Napier88 <ref> [14] </ref> and Quest [5].
Reference: 15. <author> J. Richardson, M. Carey, and D. Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(3) </volume> <pages> 494-534, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: We follow the precedent of <ref> [15] </ref> and [21] and classify types as either persistent types or non-persistent types according to whether or not they have this property 3 . Note that objects of a persistent type may persist depending on their reachability. Conversely, objects of a non persistent type can not persist.
Reference: 16. <author> M.T. Rowley. </author> <title> An OMDG Ada95 binding. </title> <type> Technical report, </type> <institution> Intermetrics Inc, </institution> <month> September </month> <year> 1995. </year> <note> http://www.inmet.com/pob.html. </note>
Reference-contexts: Notable examples include Green's proposal [11], APPL/A [17], PGRAPHITE [22], the work of Millan et al [13] and Intermetrics' proposed ODMG Ada95 binding <ref> [16] </ref>. This paper focuses on orthogonal persistence, which we believe most closely matches the high-level design goals for Ada. Orthogonal persistence offers the highest level of reliability and maintainability of all forms of persistence, and supports the broadest range of (non real-time) applications.
Reference: 17. <author> S.M. Sutton, D. Heimbigner, and L.J. Osterweil. </author> <title> Language constructs for managing change in process-centered environments. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 15 </volume> <pages> 206-217, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Notable examples include Green's proposal [11], APPL/A <ref> [17] </ref>, PGRAPHITE [22], the work of Millan et al [13] and Intermetrics' proposed ODMG Ada95 binding [16]. This paper focuses on orthogonal persistence, which we believe most closely matches the high-level design goals for Ada.
Reference: 18. <author> U.S. </author> <title> Department of Defense. The Programming Language Ada Reference Manual, </title> <institution> ANSI/MIL-STD-1815A-1983. United States Department of Defense, </institution> <address> Washington, D.C., </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Ada has recently undergone a major cycle of review and update. The result of this is the new programming language Ada95 [12] which is, in the main, backward compatible with Ada83 <ref> [18] </ref>. Two of the principle changes to Ada were the addition of constructs to make it a fully fledged object-oriented language and the use of annexes for defining specialist language capabilities. This paper examines the emerging technology of persistence, and considers how persistent programming can be supported in Ada.
Reference: 19. <author> U.S. </author> <title> Department of Defense. Ada Board's Recommended Ada 9X Strategy. Office of the Under Secretary for Defence Applications, </title> <address> Washington, D.C., </address> <year> 1988. </year>
Reference-contexts: We then address the linguistic problems of supporting persistent programming in Ada95, focussing in particular on preserving type safety and encapsulation of abstract data types (ADTs). Next we present two designs for variants of Ada95 that support persistent programming. These designs follow the revision guidelines for Ada95 <ref> [19, 20] </ref> as far as is practical. Changes relative to Ada95 are restricted to those that are essential to supporting persistent programming. The designs are labelled persistent Ada95a and persistent Ada95b to distinguish them from standard Ada83 and Ada95.
Reference: 20. <author> U.S. </author> <title> Department of Defense. Ada 9X Requirements. Office of the Under Secretary for Defence Applications, </title> <address> Washington, D.C., </address> <month> December </month> <year> 1990. </year>
Reference-contexts: We then address the linguistic problems of supporting persistent programming in Ada95, focussing in particular on preserving type safety and encapsulation of abstract data types (ADTs). Next we present two designs for variants of Ada95 that support persistent programming. These designs follow the revision guidelines for Ada95 <ref> [19, 20] </ref> as far as is practical. Changes relative to Ada95 are restricted to those that are essential to supporting persistent programming. The designs are labelled persistent Ada95a and persistent Ada95b to distinguish them from standard Ada83 and Ada95.
Reference: 21. <author> B. Walsh, P. Taylor, C. McHugh, M. Riveill, V. Cahill, and R. Balter. </author> <title> The Co-mandos supported programming languages. </title> <type> Technical Report TCD-CS-93-34, </type> <institution> Trinity College, Dublin; Unite mixte BULL-IMAG, Trinity College Dublin, </institution> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: We follow the precedent of [15] and <ref> [21] </ref> and classify types as either persistent types or non-persistent types according to whether or not they have this property 3 . Note that objects of a persistent type may persist depending on their reachability. Conversely, objects of a non persistent type can not persist.
Reference: 22. <author> J.C. Wilden, A.L. Wolfe, C.D. Fisher, and P.L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent object management. </title> <journal> ACM SIGSOFT Software Engineering News, </journal> <volume> 13 </volume> <pages> 130-142, </pages> <month> November </month> <year> 1988. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Notable examples include Green's proposal [11], APPL/A [17], PGRAPHITE <ref> [22] </ref>, the work of Millan et al [13] and Intermetrics' proposed ODMG Ada95 binding [16]. This paper focuses on orthogonal persistence, which we believe most closely matches the high-level design goals for Ada. <p> This is backwards compatible with Ada95, but it provides a "backdoor" means to circumvent name equivalence. Declare types as being persistent and then use structural equivalence for them; e.g. as in PGRAPHITE <ref> [22] </ref>. This violates the definition of orthogonal persistence. Use a hybrid of structural equivalence and name equivalence in which two types are equivalent iff they have the same structure and are defined in analogous lexical contexts.
References-found: 22

