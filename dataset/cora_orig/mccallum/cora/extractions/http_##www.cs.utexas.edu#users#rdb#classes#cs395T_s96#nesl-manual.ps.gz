URL: http://www.cs.utexas.edu/users/rdb/classes/cs395T_s96/nesl-manual.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/rdb/classes/cs395T_s96/
Root-URL: 
Title: Nesl: A Nested Data-Parallel Language (Version 3.1)  
Author: Guy E. Blelloch 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Note: CMU-CS-95-170 (Updated version of CMU-CS-92-103, January 1992, and CMU-CS-93-129,  
Date: September 21, 1995  April 1993)  
Abstract: This research was sponsored in part by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. It was also supported in part by an NSF Young Investigator Award under grant number CCR-9258525, and by Finmeccanica. The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of Wright Laboratory or the U. S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ANSI. </author> <title> ANSI Fortran Draft S8, </title> <type> Version 111. </type>
Reference-contexts: Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. The data-parallel languages C* [38], *Lisp [31], and Fortran 90 <ref> [1] </ref> (with array extensions) support no form of nested parallelism. The parallel collections in these languages can only contain scalars or fixed sized records. <p> We are currently working on a follow-up on Nesl, which will be based on a more rigorous type system, and will include some support for higher-order functions. 1.1 Parallel Operations on Sequences Nesl supports parallelism through operations on sequences, which are specified using square brackets. For example <ref> [2, 1, 9, -3] </ref> is a sequence of four integers. In Nesl all elements of a sequence must be of the same type, and all sequences must be of finite length. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in [3, -4, -9, 5]; b in <ref> [1, 2, 3, 4] </ref>g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> For example: permute ("nesl",[2,1,3,0]); ) "lens" : [char] In this case, the 4 characters of the string "nesl" (the term string is used to refer to a sequence of characters) are permuted to the indices <ref> [2, 1, 3, 0] </ref> (n ! 2, e ! 1, s ! 3, and l ! 0). The implementation of the permute function on a distributed-memory parallel 2 This is not strictly true since some of the utility functions, such as reading or writing from a file, have side effects. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = [4, 8, 2, 3, 1, 7, 2] pivot = 3 fx in s | x &lt; pivotg = <ref> [2, 1, 2] </ref> After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. In this case, the algorithm calls kth smallest recursively on lesser using the same k. <p> This rule permits the nesting of sequences to an arbitrary depth. A nested sequence can be written as <ref> [[2, 1] </ref>, [7,3,0], [4]] This sequence has type: [[int]] (a sequence of sequences of integers). <p> For example, we could apply the parallel sequence function sum over a nested sequence: fsum (v) : v in <ref> [[2, 1] </ref>, [7,3,0], [4]]g; ) [3, 10, 4] : [int] In this expression there is parallelism both within each sum, since the sequence function has a parallel implementation, and across the three instances of sum, since the apply-to-each construct is defined such that all instances can run in parallel. <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], [4]]); ) <ref> [2, 1, 7, 3, 0, 4] </ref> : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements from the <p> Table 3 lists several examples. As an example, consider how the function sum might be implemented, function my sum (a) = if (#a == 1) then a [0] else let r = fmy sum (v) : v in bottop (a)g; in r [0] + r <ref> [1] </ref>; Application Outer Parallelism Inner Parallelism Sum of Neighbors in Graph For each vertex Sum neighbors of graph of vertex Figure Drawing For each line Draw pixels of image of line Compiling For each procedure Compile code of program of procedure Text Formatting For each paragraph Justify lines of document of <p> if (#a &lt; 2) then a else let pivot = a [#a/2]; lesser = fe in a| e &lt; pivotg; equal = fe in a| e == pivotg; greater = fe in a| e &gt; pivotg; result = fqsort (v): v in [lesser,greater]g in result [0] ++ equal ++ result <ref> [1] </ref>; This code tests if the length of the input is one, and returns the single element if it is. If the length is not one, it uses bottop to split the sequence in two parts, and then applies itself recursively to each part in parallel. <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; <ref> [[2, 1, 7, 3] </ref>, [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must <p> Both the body and the sieve are optional: they could both be left out, as in fa in <ref> [1, 2, 3] </ref>g; The rbinds can contain multiple bindings which are separated by semicolons. We first consider the case in which there is a single binding. <p> In a full binding the expression is evaluated (it must evaluate to a sequence) and the variables in the pattern are bound in turn to each element of the sequence. The body and sieve are applied for each of these bindings. For example: 26 fa + 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) <p> 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) [3, 4, 5] : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length. <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as defined in the list of <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied.
Reference: [2] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This allows the user to run the environment, including the compiler, on a local workstation while executing interactive calls to Nesl programs on the remote parallel machines. As in the Standard ML of New Jersey compiler <ref> [2] </ref>, all interactive invocations are first compiled (in our case into Vcode), and then executed. 1 In previous descriptions of the language, the term step was used instead of depth. 3 Control parallel languages that have some feature that are similar to NESL include ID [35, 3], Sisal [32], and Proteus <p> We are currently working on a follow-up on Nesl, which will be based on a more rigorous type system, and will include some support for higher-order functions. 1.1 Parallel Operations on Sequences Nesl supports parallelism through operations on sequences, which are specified using square brackets. For example <ref> [2, 1, 9, -3] </ref> is a sequence of four integers. In Nesl all elements of a sequence must be of the same type, and all sequences must be of finite length. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in [3, -4, -9, 5]; b in <ref> [1, 2, 3, 4] </ref>g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> For example: permute ("nesl",[2,1,3,0]); ) "lens" : [char] In this case, the 4 characters of the string "nesl" (the term string is used to refer to a sequence of characters) are permuted to the indices <ref> [2, 1, 3, 0] </ref> (n ! 2, e ! 1, s ! 3, and l ! 0). The implementation of the permute function on a distributed-memory parallel 2 This is not strictly true since some of the utility functions, such as reading or writing from a file, have side effects. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = [4, 8, 2, 3, 1, 7, 2] pivot = 3 fx in s | x &lt; pivotg = <ref> [2, 1, 2] </ref> After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. In this case, the algorithm calls kth smallest recursively on lesser using the same k. <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], [4]]); ) <ref> [2, 1, 7, 3, 0, 4] </ref> : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements from the <p> Based on the current candidates, next char narrows the set of candidates by only keeping the candidates that match on the next character of w. To do this, each candidate 17 function primes (n) = if n == 2 then <ref> [2] </ref> else let sqr primes = primes (ceil (sqrt (float (n)))); sieves = f [2*p:n:p]: p in sqr primesg; flat sieves = flatten (sieves); flags = dist (t,n) &lt;- f (i,f): i in flat sievesg in drop (fi in [0:n]; flag in flags| flagg, 2) ; checks whether the i th <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: <ref> [6, 2, 4, 5] </ref>; [[2, 1, 7, 3], [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; [[2, 1, 7, 3], <ref> [6, 2] </ref>, [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must be explicitly typed since <p> Both the body and the sieve are optional: they could both be left out, as in fa in <ref> [1, 2, 3] </ref>g; The rbinds can contain multiple bindings which are separated by semicolons. We first consider the case in which there is a single binding. <p> In a full binding the expression is evaluated (it must evaluate to a sequence) and the variables in the pattern are bound in turn to each element of the sequence. The body and sieve are applied for each of these bindings. For example: 26 fa + 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) <p> 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) [3, 4, 5] : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length. <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied.
Reference: [3] <author> Arvind, Rishiyur S. Nikhil, and Keshav K. Pingali. I-structures: </author> <title> Data structures for parallel computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: ML of New Jersey compiler [2], all interactive invocations are first compiled (in our case into Vcode), and then executed. 1 In previous descriptions of the language, the term step was used instead of depth. 3 Control parallel languages that have some feature that are similar to NESL include ID <ref> [35, 3] </ref>, Sisal [32], and Proteus [33]. ID and Sisal are both side-effect free and supply operations on collections of values. The remainder of this section discusses the use of sequences and nested parallelism in Nesl, and how complexity can be derived from Nesl code. <p> The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda [43] and Haskell [28]. For example, the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref>g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". <p> For example, the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref>g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". The symbol ) points to the result of the expression, and the expression [int] specifies the type of the result: a sequence of integers. <p> Henceforth we will refer to the notation as the apply-to-each construct. As with set comprehensions, the apply-to-each construct also provides the ability to subselect elements of a sequence: the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref> | a &lt; 4g; ) [-3, 4, 9] : [int] can be read as, "in parallel for each a in the sequence -3, 4, 9, 1- such that a is less than 4, negate a". The elements that remain maintain their order relative to each other. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in <ref> [3, -4, -9, 5] </ref>; b in [1, 2, 3, 4]g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in [3, -4, -9, 5]; b in <ref> [1, 2, 3, 4] </ref>g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> For example: permute ("nesl",[2,1,3,0]); ) "lens" : [char] In this case, the 4 characters of the string "nesl" (the term string is used to refer to a sequence of characters) are permuted to the indices <ref> [2, 1, 3, 0] </ref> (n ! 2, e ! 1, s ! 3, and l ! 0). The implementation of the permute function on a distributed-memory parallel 2 This is not strictly true since some of the utility functions, such as reading or writing from a file, have side effects. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> For example, we could apply the parallel sequence function sum over a nested sequence: fsum (v) : v in [[2, 1], [7,3,0], [4]]g; ) <ref> [3, 10, 4] </ref> : [int] In this expression there is parallelism both within each sum, since the sequence function has a parallel implementation, and across the three instances of sum, since the apply-to-each construct is defined such that all instances can run in parallel. <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], <ref> [7, 3, 0] </ref>, [4]]); ) [2, 1, 7, 3, 0, 4] : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], [4]]); ) <ref> [2, 1, 7, 3, 0, 4] </ref> : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements from the <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; <ref> [[2, 1, 7, 3] </ref>, [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must <p> Both the body and the sieve are optional: they could both be left out, as in fa in <ref> [1, 2, 3] </ref>g; The rbinds can contain multiple bindings which are separated by semicolons. We first consider the case in which there is a single binding. <p> In a full binding the expression is evaluated (it must evaluate to a sequence) and the variables in the pattern are bound in turn to each element of the sequence. The body and sieve are applied for each of these bindings. For example: 26 fa + 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) <p> 2: a in <ref> [1, 2, 3] </ref>g; fa + b: (a,b) in [(1,2), (3,4), (5,6)]g; In a shorthand binding, the variable must be a sequence, and the body and sieve are applied to each element of the sequence with the variable name bound to the element. For example: let a = [1, 2, 3] ) [3, 4, 5] : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length. <p> For example: let a = [1, 2, 3] ) <ref> [3, 4, 5] </ref> : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length. <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> For example: fa in <ref> [1, 2, 3] </ref>; b in [1, 4, 9]g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied.
Reference: [4] <author> G. Blelloch, G.L. Miller, and D. Talmor. </author> <title> Parallel Delaunay triangulation implementation. </title> <booktitle> In MSI workshop on Computational geometry, </booktitle> <institution> Cornell, </institution> <month> Oct </month> <year> 1994. </year>
Reference-contexts: To promote the use of parallelism, Nesl supplies no serial looping constructs (although serial looping can be simulated with recursion). NESL has been used for 3 years now for teaching parallel algorithms [10], and many applications and algorithms have been written in the language <ref> [22, 4, 5] </ref>. Nesl is the first data-parallel language whose implementation supports nested parallelism. Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. <p> The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda [43] and Haskell [28]. For example, the expression fnegate (a) : a in [3, -4, -9, 5]g; ) <ref> [-3, 4, 9, -5] </ref> : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". <p> Henceforth we will refer to the notation as the apply-to-each construct. As with set comprehensions, the apply-to-each construct also provides the ability to subselect elements of a sequence: the expression fnegate (a) : a in [3, -4, -9, 5] | a &lt; 4g; ) <ref> [-3, 4, 9] </ref> : [int] can be read as, "in parallel for each a in the sequence -3, 4, 9, 1- such that a is less than 4, negate a". The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in [3, -4, -9, 5]; b in <ref> [1, 2, 3, 4] </ref>g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> This rule permits the nesting of sequences to an arbitrary depth. A nested sequence can be written as [[2, 1], [7,3,0], <ref> [4] </ref>] This sequence has type: [[int]] (a sequence of sequences of integers). <p> For example, we could apply the parallel sequence function sum over a nested sequence: fsum (v) : v in [[2, 1], [7,3,0], [4]]g; ) <ref> [3, 10, 4] </ref> : [int] In this expression there is parallelism both within each sum, since the sequence function has a parallel implementation, and across the three instances of sum, since the apply-to-each construct is defined such that all instances can run in parallel. <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], <ref> [4] </ref>]); ) [2, 1, 7, 3, 0, 4] : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], [4]]); ) <ref> [2, 1, 7, 3, 0, 4] </ref> : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements from the <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: <ref> [6, 2, 4, 5] </ref>; [[2, 1, 7, 3], [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : <p> For example: let a = [1, 2, 3] ) <ref> [3, 4, 5] </ref> : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length. <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as defined in the list of <p> For example: fa + b: a in [1, 2, 3]; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], <ref> [4, 4] </ref>, [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as defined in the list of functions, elementwise zips together the <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied.
Reference: [5] <author> Guy Blelloch and Girija Narlikar. </author> <title> A comparison of two n-body algorithms. </title> <booktitle> In Dimacs implementation challenge workshop, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: To promote the use of parallelism, Nesl supplies no serial looping constructs (although serial looping can be simulated with recursion). NESL has been used for 3 years now for teaching parallel algorithms [10], and many applications and algorithms have been written in the language <ref> [22, 4, 5] </ref>. Nesl is the first data-parallel language whose implementation supports nested parallelism. Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. <p> The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda [43] and Haskell [28]. For example, the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref>g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". <p> For example, the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref>g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". The symbol ) points to the result of the expression, and the expression [int] specifies the type of the result: a sequence of integers. <p> Henceforth we will refer to the notation as the apply-to-each construct. As with set comprehensions, the apply-to-each construct also provides the ability to subselect elements of a sequence: the expression fnegate (a) : a in <ref> [3, -4, -9, 5] </ref> | a &lt; 4g; ) [-3, 4, 9] : [int] can be read as, "in parallel for each a in the sequence -3, 4, 9, 1- such that a is less than 4, negate a". The elements that remain maintain their order relative to each other. <p> The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. The expression fa + b : a in <ref> [3, -4, -9, 5] </ref>; b in [1, 2, 3, 4]g; 4 Operation Description Work * dist (a,l) Distribute value a to sequence of length l. S (result) * #a Return length of sequence a. 1 a [i] Return element at position i of a. <p> All candidates that do match are packed and passed into the recursive call of next char. The recursion completes when the algorithm reaches the end of w. The progression of candidates in the "foo" example would be: i candidates 0 <ref> [0, 5, 8, 12] </ref> 2 [5, 12] Lets consider the complexity of the algorithm. We assume #w = m and #s = n. The depth complexity of the algorithm is some constant times the number of recursive calls, which is simply O (m). <p> All candidates that do match are packed and passed into the recursive call of next char. The recursion completes when the algorithm reaches the end of w. The progression of candidates in the "foo" example would be: i candidates 0 [0, 5, 8, 12] 2 <ref> [5, 12] </ref> Lets consider the complexity of the algorithm. We assume #w = m and #s = n. The depth complexity of the algorithm is some constant times the number of recursive calls, which is simply O (m). <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: <ref> [6, 2, 4, 5] </ref>; [[2, 1, 7, 3], [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : <p> For example: let a = [1, 2, 3] ) <ref> [3, 4, 5] </ref> : [int] In the case of multiple rbinds, each of the sequences (either the result of the expression in a full binding or the value of the variable in a shorthand binding) must be of equal length.
Reference: [6] <author> Guy E. Blelloch. </author> <title> Scans as primitive parallel operations. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-38(11):1526-1538, </volume> <month> November </month> <year> 1989. </year>
Reference-contexts: As another more involved example, consider a parallel variation of quicksort <ref> [6] </ref> (see elements lesser, equal and greater than the pivot) and calls itself recursively on the lesser and greater subsets. <p> This formula can be derived from Brent's scheduling principle [14] as shown in [41, 7, 30]. The lg P term shows up because of the cost of allocating tasks to processors, and the cost of implementing the sum and scan operations. On the scan-PRAM <ref> [6] </ref>, where it is assumed that the scan operations are no more expensive than references to the shared-memory (they both require O (lg P ) on a machine with bounded degree circuits), then the equation is: T = O (W=P + D) (4) In the mapping onto a PRAM, the only <p> The function flatten, is now used to flatten this nested sequence by one level, therefore returning a sequence containing all the sieves. For example, flatten ([[4, 6, 8, 10, 12, 14, 16, 18], <ref> [6, 9, 12, 15, 18] </ref>]); ) [4, 6, 8, 10, 12, 14, 16, 18, 6, 9, 12, 15, 18] : [int] This sequence of sieves is used by the &lt;- function to place a false flag in all positions that are a multiple of one of the sqr primes. <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: <ref> [6, 2, 4, 5] </ref>; [[2, 1, 7, 3], [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; [[2, 1, 7, 3], <ref> [6, 2] </ref>, [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must be explicitly typed since
Reference: [7] <author> Guy E. Blelloch. </author> <title> Vector Models for Data-Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Nested parallelism is critical for describing both divide-and-conquer algo rithms and algorithms with nested data structures <ref> [7] </ref>. 3. To generate efficient code for a variety of architectures, including both SIMD and MIMD machines, with both shared and distributed memory. <p> To be well suited for describing parallel algorithms, and to supply a mechanism for deriving the theoretical running time directly from the code. Each function in Nesl has two complexity measures associated with it, the work and depth complexities <ref> [7] </ref>. A simple equation maps these complexities to the asymptotic running time on a Parallel Random Access Machine (PRAM) Model. Nesl is a strongly-typed strict first-order functional (applicative) language. It runs within an interactive environment and is loosely based on the ML language [34]. <p> Nesl is a strongly-typed strict first-order functional (applicative) language. It runs within an interactive environment and is loosely based on the ML language [34]. The language uses sequences as a primitive parallel data type, and parallelism is achieved exclusively through operations on these sequences <ref> [7] </ref>. The set of sequence functions supplied by Nesl was chosen based both on their usefulness on a broad variety of algorithms, and on their efficiency when implemented on parallel machines. <p> For this reason, Nesl was designed so that the built-in functions are quite simple and so that the asymptotic complexity can be derived from the code. To derive the complexity, each function in Nesl has two complexity measures associated with it: the work and depth complexities <ref> [7] </ref> 1 The work complexity represents the serial work executed by a program| the running time if executed on a serial RAM. The depth complexity represents the deepest path taken by the function|the running time if executed with an unbounded number of processors. <p> We also have an MPI [20] version of VCODE [25], which will run on machines that support MPI, such as the IBM SP-2, the Intel Paragon, or clusters of workstations. The sequence functions in this interpreter have been highly optimized <ref> [7, 17] </ref> and, for large sequences, the interpretive overhead becomes relatively small yielding high efficiencies. The interactive Nesl environment runs within Common Lisp and can be used to run Vcode on remote machines. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], <ref> [7, 3, 0] </ref>, [4]]); ) [2, 1, 7, 3, 0, 4] : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first <p> Nesl supplies a handful of functions for moving between levels of nesting. These include flatten, which takes a nested sequence and flattens it by one level. For example, flatten ([[2, 1], [7, 3, 0], [4]]); ) <ref> [2, 1, 7, 3, 0, 4] </ref> : [int] Another useful function is bottop (for bottom and top), which takes a sequence of values and creates a nested sequence of length 2 with all the elements from the bottom half of the input sequence in the first element and elements from the <p> The depth complexity of all the sequence functions supplied by Nesl is constant. The work and depth complexities are based on the vector random access machine (VRAM) model <ref> [7] </ref>, a strictly data-parallel abstraction of the parallel random access machine (PRAM) model [19]. Since the complexities are meant for determining asymptotic complexity, these complexities do not include constant factors. All the Nesl functions, however, can be executed in a small number of machine instructions per element. <p> This formula can be derived from Brent's scheduling principle [14] as shown in <ref> [41, 7, 30] </ref>. The lg P term shows up because of the cost of allocating tasks to processors, and the cost of implementing the sum and scan operations. <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; <ref> [[2, 1, 7, 3] </ref>, [6, 2], [22, 9]]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must
Reference: [8] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 21(1) </volume> <pages> 4-14, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Nesl currently generates a portable intermediate code called Vcode [9], which runs on vector multiprocessors (the CRAY C90 and J90) as well as distributed memory machines (the IBM SP2, Intel Paragon, and Connection Machine CM-5). Various benchmark algorithms achieve very good running times on these machines <ref> [16, 8] </ref>. 4. To be well suited for describing parallel algorithms, and to supply a mechanism for deriving the theoretical running time directly from the code. Each function in Nesl has two complexity measures associated with it, the work and depth complexities [7]. <p> A Vcode interpreter has been implemented for running Vcode on the Cray C90 and J90, the Connection Machine CM-5, or any machine serial machine with a C compiler <ref> [8] </ref>. We also have an MPI [20] version of VCODE [25], which will run on machines that support MPI, such as the IBM SP-2, the Intel Paragon, or clusters of workstations. <p> The algorithm then selects all the elements less than the pivot, and places them in a sequence that is bound to lesser. For example: s = <ref> [4, 8, 2, 3, 1, 7, 2] </ref> pivot = 3 fx in s | x &lt; pivotg = [2, 1, 2] After the pack, if the number of elements in the set lesser is greater than k, then the k th smallest element must belong to that set. <p> All candidates that do match are packed and passed into the recursive call of next char. The recursion completes when the algorithm reaches the end of w. The progression of candidates in the "foo" example would be: i candidates 0 <ref> [0, 5, 8, 12] </ref> 2 [5, 12] Lets consider the complexity of the algorithm. We assume #w = m and #s = n. The depth complexity of the algorithm is some constant times the number of recursive calls, which is simply O (m).
Reference: [9] <author> Guy E. Blelloch, Siddhartha Chatterjee, Fritz Knabe, Jay Sipelstein, and Marco Zagha. </author> <title> VCODE reference manual (version 1.1). </title> <type> Technical Report CMU-CS-90-146, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Nested parallelism is critical for describing both divide-and-conquer algo rithms and algorithms with nested data structures [7]. 3. To generate efficient code for a variety of architectures, including both SIMD and MIMD machines, with both shared and distributed memory. Nesl currently generates a portable intermediate code called Vcode <ref> [9] </ref>, which runs on vector multiprocessors (the CRAY C90 and J90) as well as distributed memory machines (the IBM SP2, Intel Paragon, and Connection Machine CM-5). Various benchmark algorithms achieve very good running times on these machines [16, 8]. 4. <p> Simple composition rules can be used to combine the two complexities across expressions and, based on Brent's scheduling principle [14], the two complexities place an upper bound on the asymptotic running times for the parallel random access machine (PRAM) [19]. The current compiler translates Nesl to Vcode <ref> [9] </ref>, a portable intermediate language. The compiler uses a technique called flattening nested parallelism [13] to translate Nesl into the simpler flat data-parallel model supplied by Vcode. <p> We are currently working on a follow-up on Nesl, which will be based on a more rigorous type system, and will include some support for higher-order functions. 1.1 Parallel Operations on Sequences Nesl supports parallelism through operations on sequences, which are specified using square brackets. For example <ref> [2, 1, 9, -3] </ref> is a sequence of four integers. In Nesl all elements of a sequence must be of the same type, and all sequences must be of finite length. <p> The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda [43] and Haskell [28]. For example, the expression fnegate (a) : a in [3, -4, -9, 5]g; ) <ref> [-3, 4, 9, -5] </ref> : [int] negates each elements of the sequence [3, -4, -9, 5]. This construct can be read as "in parallel for each a in the sequence -3, -4, -9, 5-, negate a". <p> Henceforth we will refer to the notation as the apply-to-each construct. As with set comprehensions, the apply-to-each construct also provides the ability to subselect elements of a sequence: the expression fnegate (a) : a in [3, -4, -9, 5] | a &lt; 4g; ) <ref> [-3, 4, 9] </ref> : [int] can be read as, "in parallel for each a in the sequence -3, 4, 9, 1- such that a is less than 4, negate a". The elements that remain maintain their order relative to each other. It is also possible to iterate over multiple sequences. <p> The function flatten, is now used to flatten this nested sequence by one level, therefore returning a sequence containing all the sieves. For example, flatten ([[4, 6, 8, 10, 12, 14, 16, 18], <ref> [6, 9, 12, 15, 18] </ref>]); ) [4, 6, 8, 10, 12, 14, 16, 18, 6, 9, 12, 15, 18] : [int] This sequence of sieves is used by the &lt;- function to place a false flag in all positions that are a multiple of one of the sqr primes. <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; [[2, 1, 7, 3], [6, 2], <ref> [22, 9] </ref>]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must be explicitly typed since the type <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in <p> The bindings are interleaved so that the body is evaluated with bindings made for elements at the same index of each sequence. For example: fa + b: a in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], [9, 9, 9]] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as defined in the list of <p> For example: fa + b: a in [1, 2, 3]; b in [1, 4, 9]g; fdist (b,a): a in [1, 2, 3]; b in [1, 4, 9]g; ) [[1], [4, 4], <ref> [9, 9, 9] </ref>] : [[int]] An apply-to-each with a body and two bindings, fbody: pattern1 in exp1; pattern2 in exp2 | sieveg is equivalent to the single binding construct fbody: (pattern1,pattern2) in zip (exp1,exp2) | sieveg where zip, as defined in the list of functions, elementwise zips together the two sequences <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in <ref> [1, 4, 9] </ref>g; fa in [1, 2, 3]; b in [2, 4, 9] | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied. <p> If there is no body in an apply-to-each construct, then the results of the first binding is returned. For example: fa in [1, 2, 3]; b in [1, 4, 9]g; fa in [1, 2, 3]; b in <ref> [2, 4, 9] </ref> | b == 2*ag; fb in [2, 4, 9]; a in [1, 2, 3] | b == 2*ag; 27 If there is a body and a sieve, the body and sieve are both evaluated for all bindings, and then the subselection is applied.
Reference: [10] <author> Guy E. Blelloch and Jonathan C. Hardwick. </author> <title> Class notes: Programming parallel algorithms. </title> <type> Technical Report CMU-CS-93-115, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: To promote the use of parallelism, Nesl supplies no serial looping constructs (although serial looping can be simulated with recursion). NESL has been used for 3 years now for teaching parallel algorithms <ref> [10] </ref>, and many applications and algorithms have been written in the language [22, 4, 5]. Nesl is the first data-parallel language whose implementation supports nested parallelism. <p> For example, we could apply the parallel sequence function sum over a nested sequence: fsum (v) : v in [[2, 1], [7,3,0], [4]]g; ) <ref> [3, 10, 4] </ref> : [int] In this expression there is parallelism both within each sum, since the sequence function has a parallel implementation, and across the three instances of sum, since the apply-to-each construct is defined such that all instances can run in parallel.
Reference: [11] <author> Guy E. Blelloch, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <note> NESL user's manual (for NESL version 3.1). Technical Report CMU-CS-95-169, </note> <institution> Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year>
Reference: [12] <author> Guy E. Blelloch and James J. Little. </author> <title> Parallel solutions to geometric problems on the scan model of computation. </title> <booktitle> In Proceedings International Conference on Parallel Processing, </booktitle> <volume> pages Vol 3: </volume> <pages> 218-222, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: All candidates that do match are packed and passed into the recursive call of next char. The recursion completes when the algorithm reaches the end of w. The progression of candidates in the "foo" example would be: i candidates 0 <ref> [0, 5, 8, 12] </ref> 2 [5, 12] Lets consider the complexity of the algorithm. We assume #w = m and #s = n. The depth complexity of the algorithm is some constant times the number of recursive calls, which is simply O (m). <p> All candidates that do match are packed and passed into the recursive call of next char. The recursion completes when the algorithm reaches the end of w. The progression of candidates in the "foo" example would be: i candidates 0 [0, 5, 8, 12] 2 <ref> [5, 12] </ref> Lets consider the complexity of the algorithm. We assume #w = m and #s = n. The depth complexity of the algorithm is some constant times the number of recursive calls, which is simply O (m). <p> The function flatten, is now used to flatten this nested sequence by one level, therefore returning a sequence containing all the sieves. For example, flatten ([[4, 6, 8, 10, 12, 14, 16, 18], <ref> [6, 9, 12, 15, 18] </ref>]); ) [4, 6, 8, 10, 12, 14, 16, 18, 6, 9, 12, 15, 18] : [int] This sequence of sieves is used by the &lt;- function to place a false flag in all positions that are a multiple of one of the sqr primes. <p> The planar convex hull problem has many applications ranging from computer graphics [21] to statistics [27]. The algorithm we use to solve the problem is a parallel version <ref> [12] </ref> of the quickhull algorithm [36]. The quickhull algorithm was given its name because of its similarity to the quicksort algorithm. As with quicksort, the algorithm picks 19 algorithm. Since A and P are the two x extrema, the line AP is the original split line.
Reference: [13] <author> Guy E. Blelloch and Gary W. Sabot. </author> <title> Compiling collection-oriented languages onto massively parallel computers. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 119-134, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The languages Connection Machine Lisp [45], and Paralation Lisp [39] both supply nested parallel constructs, but no implementation ever supported the parallel execution of these constructs. Blelloch and Sabot implemented an experimental compiler that supported nested-parallelism for a small subset of Paralation Lisp <ref> [13] </ref>, but it was deemed near impossible to extend it to the full language. <p> The current compiler translates Nesl to Vcode [9], a portable intermediate language. The compiler uses a technique called flattening nested parallelism <ref> [13] </ref> to translate Nesl into the simpler flat data-parallel model supplied by Vcode. Vcode is a small stack-based language with about 100 functions all of which operate on sequences of atomic values (scalars are implemented as sequences of length 1).
Reference: [14] <author> Richard P. Brent. </author> <title> The parallel evaluation of general arithmetic expressions. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 21(2) </volume> <pages> 201-206, </pages> <year> 1974. </year> <month> 29 </month>
Reference-contexts: The depth complexity represents the deepest path taken by the function|the running time if executed with an unbounded number of processors. Simple composition rules can be used to combine the two complexities across expressions and, based on Brent's scheduling principle <ref> [14] </ref>, the two complexities place an upper bound on the asymptotic running times for the parallel random access machine (PRAM) [19]. The current compiler translates Nesl to Vcode [9], a portable intermediate language. <p> This formula can be derived from Brent's scheduling principle <ref> [14] </ref> as shown in [41, 7, 30]. The lg P term shows up because of the cost of allocating tasks to processors, and the cost of implementing the sum and scan operations.
Reference: [15] <author> D. Breslauer and Z. Galil. </author> <title> An optimal O(log log n) time parallel string matching algorithm. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(6) </volume> <pages> 1051-1058, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: There are parallel string-searching algorithms that give better bounds on the parallel time (depth complexity), and that bound the worst case work complexity to be linear in the length of the search string <ref> [15, 44] </ref>, but these algorithms are somewhat more complicated. 2.2 Primes Our second example finds all the primes less than n. The algorithm is based on the sieve of Eratosthenes. <p> The function flatten, is now used to flatten this nested sequence by one level, therefore returning a sequence containing all the sieves. For example, flatten ([[4, 6, 8, 10, 12, 14, 16, 18], <ref> [6, 9, 12, 15, 18] </ref>]); ) [4, 6, 8, 10, 12, 14, 16, 18, 6, 9, 12, 15, 18] : [int] This sequence of sieves is used by the &lt;- function to place a false flag in all positions that are a multiple of one of the sqr primes.
Reference: [16] <author> Siddhartha Chatterjee. </author> <title> Compiling Data-Parallel Programs for Efficient Execution on Shared-Memory Multiprocessors. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Nesl currently generates a portable intermediate code called Vcode [9], which runs on vector multiprocessors (the CRAY C90 and J90) as well as distributed memory machines (the IBM SP2, Intel Paragon, and Connection Machine CM-5). Various benchmark algorithms achieve very good running times on these machines <ref> [16, 8] </ref>. 4. To be well suited for describing parallel algorithms, and to supply a mechanism for deriving the theoretical running time directly from the code. Each function in Nesl has two complexity measures associated with it, the work and depth complexities [7].
Reference: [17] <author> Siddhartha Chatterjee, Guy E. Blelloch, and Marco Zagha. </author> <title> Scan primitives for vector computers. </title> <booktitle> In Proceedings Supercomputing '90, </booktitle> <pages> pages 666-675, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We also have an MPI [20] version of VCODE [25], which will run on machines that support MPI, such as the IBM SP-2, the Intel Paragon, or clusters of workstations. The sequence functions in this interpreter have been highly optimized <ref> [7, 17] </ref> and, for large sequences, the interpretive overhead becomes relatively small yielding high efficiencies. The interactive Nesl environment runs within Common Lisp and can be used to run Vcode on remote machines.
Reference: [18] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press and McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: In this algorithm the work is the same as the time required by the standard serial version (loops have been replaced by parallel calls), which has an expected time of O (n) <ref> [18] </ref>. It is also not hard to show that the expected number of recursive calls is O (lg n), since we expect to drop some fraction of the elements on each recursive call [37]. <p> The function flatten, is now used to flatten this nested sequence by one level, therefore returning a sequence containing all the sieves. For example, flatten ([[4, 6, 8, 10, 12, 14, 16, 18], <ref> [6, 9, 12, 15, 18] </ref>]); ) [4, 6, 8, 10, 12, 14, 16, 18, 6, 9, 12, 15, 18] : [int] This sequence of sieves is used by the &lt;- function to place a false flag in all positions that are a multiple of one of the sqr primes.
Reference: [19] <author> Steven Fortune and James Wyllie. </author> <title> Parallelism in random access machines. </title> <booktitle> In Proceedings ACM Symposium on Theory of Computing, </booktitle> <pages> pages 114-118, </pages> <year> 1978. </year>
Reference-contexts: Simple composition rules can be used to combine the two complexities across expressions and, based on Brent's scheduling principle [14], the two complexities place an upper bound on the asymptotic running times for the parallel random access machine (PRAM) <ref> [19] </ref>. The current compiler translates Nesl to Vcode [9], a portable intermediate language. The compiler uses a technique called flattening nested parallelism [13] to translate Nesl into the simpler flat data-parallel model supplied by Vcode. <p> The depth complexity of all the sequence functions supplied by Nesl is constant. The work and depth complexities are based on the vector random access machine (VRAM) model [7], a strictly data-parallel abstraction of the parallel random access machine (PRAM) model <ref> [19] </ref>. Since the complexities are meant for determining asymptotic complexity, these complexities do not include constant factors. All the Nesl functions, however, can be executed in a small number of machine instructions per element. The complexities are combined using simple combining rules.
Reference: [20] <author> Message Passing Interface Forum. </author> <title> Draft document for a standard message-passing interface. </title> <type> Technical Report CS-93-214, </type> <institution> University of Tennessee, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: A Vcode interpreter has been implemented for running Vcode on the Cray C90 and J90, the Connection Machine CM-5, or any machine serial machine with a C compiler [8]. We also have an MPI <ref> [20] </ref> version of VCODE [25], which will run on machines that support MPI, such as the IBM SP-2, the Intel Paragon, or clusters of workstations. The sequence functions in this interpreter have been highly optimized [7, 17] and, for large sequences, the interpretive overhead becomes relatively small yielding high efficiencies.
Reference: [21] <author> H. Freeman. </author> <title> Computer processing of line-drawing images. </title> <journal> Computer Surveys, </journal> <volume> 6 </volume> <pages> 57-97, </pages> <year> 1974. </year>
Reference-contexts: The planar convex hull problem has many applications ranging from computer graphics <ref> [21] </ref> to statistics [27]. The algorithm we use to solve the problem is a parallel version [12] of the quickhull algorithm [36]. The quickhull algorithm was given its name because of its similarity to the quicksort algorithm. As with quicksort, the algorithm picks 19 algorithm.
Reference: [22] <author> John Greiner. </author> <title> A comparison of data-parallel algorithms for connected components. </title> <booktitle> In Proceedings Sixth Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 16-25, </pages> <address> Cape May, NJ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: To promote the use of parallelism, Nesl supplies no serial looping constructs (although serial looping can be simulated with recursion). NESL has been used for 3 years now for teaching parallel algorithms [10], and many applications and algorithms have been written in the language <ref> [22, 4, 5] </ref>. Nesl is the first data-parallel language whose implementation supports nested parallelism. Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. <p> The type of a sequence whose elements are of type ff, is specified as [ff]. For examples: [6, 2, 4, 5]; [[2, 1, 7, 3], [6, 2], <ref> [22, 9] </ref>]; Sequences of characters can be written between double quotes, "a string"; ) "a string" : [char] but can also be written as a sequence of characters: 23 [`a, Space, `s, `t, `r, `i, `n, `g]; ) "a string" : [char] Empty sequences must be explicitly typed since the type
Reference: [23] <author> John Greiner and Guy E. Blelloch. </author> <title> The NESL cost semantics. </title> <note> In preparation, </note> <year> 1995. </year>
Reference: [24] <author> G. H. Hardey and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers, 5th ed. </title> <publisher> Oxford University Press, Oxford, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: In this first call, the work is proportional to the length of the sequence flat sieves. Using the standard formula X 1=p = log log x + C + O (1= log x) where p are the primes <ref> [24] </ref>, the length of this sequence is: X p n=p = O (n log log n) therefore giving a work complexity of O (n log log n). 2.3 Planar Convex-Hull Our next example solves the planar convex hull problem: given n points in the plane, find which of these points lie
Reference: [25] <author> Jonathan C. Hardwick. </author> <title> Porting a vector library: a comparison of MPI, Paris, CMMD and PVM. </title> <booktitle> In Scalable Parallel Libraries Conference, </booktitle> <pages> pages 68-77, </pages> <address> Starkville, Missis-sippi, </address> <month> October </month> <year> 1994. </year> <note> A longer version appears as CMU-CS-94-200, </note> <institution> School of Computer Science, Carnegie Mellon University. </institution>
Reference-contexts: A Vcode interpreter has been implemented for running Vcode on the Cray C90 and J90, the Connection Machine CM-5, or any machine serial machine with a C compiler [8]. We also have an MPI [20] version of VCODE <ref> [25] </ref>, which will run on machines that support MPI, such as the IBM SP-2, the Intel Paragon, or clusters of workstations. The sequence functions in this interpreter have been highly optimized [7, 17] and, for large sequences, the interpretive overhead becomes relatively small yielding high efficiencies.
Reference: [26] <author> C. A. R. Hoare. </author> <title> Algorithm 63 (partition) and algorithm 65 (find). </title> <journal> Communications of the ACM, </journal> <volume> 4(7) </volume> <pages> 321-322, </pages> <year> 1961. </year>
Reference-contexts: We now consider an example of the use of sequences in Nesl. The algorithm we consider solves the problem of finding the k th smallest element in a set s, using a parallel version of the quickorder algorithm <ref> [26] </ref>. Quickorder is similar to quicksort, but only calls itself recursively on either the elements lesser or greater than the pivot. The Nesl code for the algorithm is shown in Figure 1. The let construct is used to bind local variables (see Section 3.2.2 for more details.).
Reference: [27] <author> J. G. Hocking and G. S. Young. </author> <title> Topology. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1961. </year>
Reference-contexts: The planar convex hull problem has many applications ranging from computer graphics [21] to statistics <ref> [27] </ref>. The algorithm we use to solve the problem is a parallel version [12] of the quickhull algorithm [36]. The quickhull algorithm was given its name because of its similarity to the quicksort algorithm. As with quicksort, the algorithm picks 19 algorithm.
Reference: [28] <author> Paul Hudak and Philip Wadler. </author> <title> Report on the functional programming language HASKELL. </title> <type> Technical report, </type> <institution> Yale University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda [43] and Haskell <ref> [28] </ref>. For example, the expression fnegate (a) : a in [3, -4, -9, 5]g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5]. <p> As well as parametric polymorphism Nesl also allows a form of overloading similar to what is supplied by the Haskell Language <ref> [28] </ref>. The type of a polymorphic function in Nesl is specified by using type-variables, which are declared in a type-context. <p> Specifying the type using ":" serves as good documentation for a function even when the inference system can determine the type. The notion of type-classes in Nesl is similar to the type-classes used in the Haskell language <ref> [28] </ref>, but, unlike Haskell, Nesl currently does not permit the user to add new type classes. 4 1.5 Deriving Complexity There are two complexities associated with all computations in Nesl. 1.
Reference: [29] <author> Kenneth E. Iverson. </author> <title> A Programming Language. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: A common complaint about high-level data-parallel languages and, more generally, in the class of languages based on operations over collections [42], such as SETL [40] and APL <ref> [29] </ref>, is that it can be hard or impossible to determine approximate running times by looking at the code.
Reference: [30] <author> Richard M. Karp and Vijaya Ramachandran. </author> <title> Parallel algorithms for shared memory machines. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science| Volume A: Algorithms and Complexity. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year> <month> 30 </month>
Reference-contexts: This formula can be derived from Brent's scheduling principle [14] as shown in <ref> [41, 7, 30] </ref>. The lg P term shows up because of the cost of allocating tasks to processors, and the cost of implementing the sum and scan operations.
Reference: [31] <author> Clifford Lasser. </author> <title> The Essential *Lisp Manual. </title> <institution> Thinking Machines Corporation, </institution> <address> Cam--bridge, MA, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. The data-parallel languages C* [38], *Lisp <ref> [31] </ref>, and Fortran 90 [1] (with array extensions) support no form of nested parallelism. The parallel collections in these languages can only contain scalars or fixed sized records.
Reference: [32] <author> James McGraw, Stephen Skedzielewski, Stephen Allan, Rod Oldehoeft, John Glauert, Chris Kirkham, Bill Noyce, and Robert Thomas. </author> <title> SISAL: Streams and Iteration in a Single Assignment Language, Language Reference Manual Version 1.2. </title> <institution> Lawrence Livermore National Laboratory, </institution> <month> March </month> <year> 1985. </year>
Reference-contexts: Jersey compiler [2], all interactive invocations are first compiled (in our case into Vcode), and then executed. 1 In previous descriptions of the language, the term step was used instead of depth. 3 Control parallel languages that have some feature that are similar to NESL include ID [35, 3], Sisal <ref> [32] </ref>, and Proteus [33]. ID and Sisal are both side-effect free and supply operations on collections of values. The remainder of this section discusses the use of sequences and nested parallelism in Nesl, and how complexity can be derived from Nesl code.
Reference: [33] <author> Peter H. Mills, Lars S. Nyland, Jan F. Prins, John H. Reif, and Robert A. Wagner. </author> <title> Prototyping parallel and distributed programs in Proteus. </title> <type> Technical Report UNC-CH TR90-041, </type> <institution> Computer Science Department, University of North Carolina, </institution> <year> 1990. </year>
Reference-contexts: all interactive invocations are first compiled (in our case into Vcode), and then executed. 1 In previous descriptions of the language, the term step was used instead of depth. 3 Control parallel languages that have some feature that are similar to NESL include ID [35, 3], Sisal [32], and Proteus <ref> [33] </ref>. ID and Sisal are both side-effect free and supply operations on collections of values. The remainder of this section discusses the use of sequences and nested parallelism in Nesl, and how complexity can be derived from Nesl code.
Reference: [34] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: A simple equation maps these complexities to the asymptotic running time on a Parallel Random Access Machine (PRAM) Model. Nesl is a strongly-typed strict first-order functional (applicative) language. It runs within an interactive environment and is loosely based on the ML language <ref> [34] </ref>. The language uses sequences as a primitive parallel data type, and parallelism is achieved exclusively through operations on these sequences [7].
Reference: [35] <author> Rishiyur S. Nikhil. </author> <title> Id reference manual. </title> <type> Technical Report Computation Structures Group Memo 284-1, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: ML of New Jersey compiler [2], all interactive invocations are first compiled (in our case into Vcode), and then executed. 1 In previous descriptions of the language, the term step was used instead of depth. 3 Control parallel languages that have some feature that are similar to NESL include ID <ref> [35, 3] </ref>, Sisal [32], and Proteus [33]. ID and Sisal are both side-effect free and supply operations on collections of values. The remainder of this section discusses the use of sequences and nested parallelism in Nesl, and how complexity can be derived from Nesl code.
Reference: [36] <author> Franco P. Preparata and Michael I. Shamos. </author> <title> Computational Geometry|An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: The planar convex hull problem has many applications ranging from computer graphics [21] to statistics [27]. The algorithm we use to solve the problem is a parallel version [12] of the quickhull algorithm <ref> [36] </ref>. The quickhull algorithm was given its name because of its similarity to the quicksort algorithm. As with quicksort, the algorithm picks 19 algorithm. Since A and P are the two x extrema, the line AP is the original split line.
Reference: [37] <author> R. Reischuk. </author> <title> Probabilistic parallel algorithms for sorting and selection. </title> <journal> SIAM J. Computing, </journal> <volume> 14(2) </volume> <pages> 396-409, </pages> <year> 1985. </year>
Reference-contexts: It is also not hard to show that the expected number of recursive calls is O (lg n), since we expect to drop some fraction of the elements on each recursive call <ref> [37] </ref>. <p> p) = O (n=p + lg 2 n) EREW PRAM = O (n=p + lg n) scan-PRAM One can similarly show for the quicksort algorithm given in Figure 2 that the work and depth complexities are W (n) = O (n lg n) and D (n) = O (lg n) <ref> [37] </ref>, which give a EREW 15 PRAM running time of: T (n) = O (n lg n=p + lg 2 n) EREW PRAM = O (n lg n=p + lg n) scan-PRAM In the remainder of this paper we will only derive the work and depth complexities.
Reference: [38] <author> John Rose and Guy L. Steele Jr. </author> <title> C*: An extended C language for data parallel programming. </title> <type> Technical Report PL87-5, </type> <institution> Thinking Machines Corporation, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Nesl is the first data-parallel language whose implementation supports nested parallelism. Nested parallelism is the ability to take a parallel function and apply it over multiple instances in parallel|for example, having a parallel sorting routine, and then using it to sort several sequences concurrently. The data-parallel languages C* <ref> [38] </ref>, *Lisp [31], and Fortran 90 [1] (with array extensions) support no form of nested parallelism. The parallel collections in these languages can only contain scalars or fixed sized records.
Reference: [39] <author> Gary Sabot. </author> <title> Paralation Lisp Reference Manual, </title> <month> May </month> <year> 1988. </year>
Reference-contexts: There is also no means in these languages to apply a user defined function over each element of a collection. 2 This prohibits the expression of any form of nested parallelism. The languages Connection Machine Lisp [45], and Paralation Lisp <ref> [39] </ref> both supply nested parallel constructs, but no implementation ever supported the parallel execution of these constructs. Blelloch and Sabot implemented an experimental compiler that supported nested-parallelism for a small subset of Paralation Lisp [13], but it was deemed near impossible to extend it to the full language.
Reference: [40] <author> J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: A common complaint about high-level data-parallel languages and, more generally, in the class of languages based on operations over collections [42], such as SETL <ref> [40] </ref> and APL [29], is that it can be hard or impossible to determine approximate running times by looking at the code. <p> The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL <ref> [40] </ref> and list-comprehensions in Miranda [43] and Haskell [28]. For example, the expression fnegate (a) : a in [3, -4, -9, 5]g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5].
Reference: [41] <author> Yossi Shiloach and Uzi Vishkin. </author> <title> An O(n 2 log n) parallel Max-Flow algorithm. </title> <journal> J. Algorithms, </journal> <volume> 3 </volume> <pages> 128-146, </pages> <year> 1982. </year>
Reference-contexts: This formula can be derived from Brent's scheduling principle [14] as shown in <ref> [41, 7, 30] </ref>. The lg P term shows up because of the cost of allocating tasks to processors, and the cost of implementing the sum and scan operations.
Reference: [42] <author> Jay Sipelstein and Guy E. Blelloch. </author> <booktitle> Collection-oriented languages. Proceedings of the IEEE, </booktitle> <volume> 79(4) </volume> <pages> 504-523, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: A common complaint about high-level data-parallel languages and, more generally, in the class of languages based on operations over collections <ref> [42] </ref>, such as SETL [40] and APL [29], is that it can be hard or impossible to determine approximate running times by looking at the code.
Reference: [43] <author> David Turner. </author> <title> An overview of MIRANDA. </title> <journal> SIGPLAN Notices, </journal> <month> December </month> <year> 1986. </year>
Reference-contexts: The application of a function over a sequence is achieved using set-like notation similar to set-formers in SETL [40] and list-comprehensions in Miranda <ref> [43] </ref> and Haskell [28]. For example, the expression fnegate (a) : a in [3, -4, -9, 5]g; ) [-3, 4, 9, -5] : [int] negates each elements of the sequence [3, -4, -9, 5].
Reference: [44] <author> Uzi Vishkin. </author> <title> Deterministic sampling|a new technique for fast pattern matching. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(1) </volume> <pages> 22-40, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: There are parallel string-searching algorithms that give better bounds on the parallel time (depth complexity), and that bound the worst case work complexity to be linear in the length of the search string <ref> [15, 44] </ref>, but these algorithms are somewhat more complicated. 2.2 Primes Our second example finds all the primes less than n. The algorithm is based on the sieve of Eratosthenes.
Reference: [45] <author> Skef Wholey and Guy L. Steele Jr. </author> <title> Connection Machine Lisp: A dialect of Common Lisp for data parallel programming. </title> <booktitle> In Proceedings Second International Conference on Supercomputing, </booktitle> <month> May </month> <year> 1987. </year> <month> 31 </month>
Reference-contexts: There is also no means in these languages to apply a user defined function over each element of a collection. 2 This prohibits the expression of any form of nested parallelism. The languages Connection Machine Lisp <ref> [45] </ref>, and Paralation Lisp [39] both supply nested parallel constructs, but no implementation ever supported the parallel execution of these constructs.
References-found: 45

