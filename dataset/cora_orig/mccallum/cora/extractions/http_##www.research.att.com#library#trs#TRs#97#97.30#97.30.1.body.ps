URL: http://www.research.att.com/library/trs/TRs/97/97.30/97.30.1.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: rnf@orbit.hr.att.com rnp@rosina.hr.att.com lma@rosina.hr.att.com  shakir@rosina.att.com jjs@rosina.hr.att.com dwt@rosina.hr.att.com  chen@research.att.com gsf@research.att.com bala@research.att.com kpv@research.att.com  
Title: Software Reuse Metrics for an Industrial Project  
Author: Richard N. Ferri Raghavan N. Pratiwadi Lynn M. Rivera Mohammed Shakir John J. Snyder D. W. Thomas Yih-Farn Chen Glenn S. Fowler Balachander Krishnamurthy Kiem-Phong Vo 
Date: November 5 7, 1997  
Note: To Be Published in: Proceedings of the Fourth International Symposium on Software Metrics IEEE Metrics '97  
Address: 480 Red Hill Road Middletown, NJ 07748-3098 USA  180 Park Avenue Florham Park, NJ 07932-0971 USA  Albuquerque, New Mexico, USA  
Affiliation: AT&T Network and Computer Services  AT&T Labs Research  
Abstract: In 1990 a project was established at AT&T to build applications that manage telephone systems. Since then the project has successfully completed over 20 applications comprising about 500,000 lines of source code. These systems are used daily by hundreds of managers and operators to monitor and provision the AT&T long distance telephone network. The project's success can be attributed directly to an early commitment in making software reuse a major component of its software development process. A critical factor was the establishment of a feedback loop between consumers and producers of reusable software to foster continual improvement and extension of reusable code repositories. Progresses in the feedback loop are measured by five different reuse measures. While no one measure is best as each provides a different perspective on reuse, two derived from the consumer/producer model have proven particularly useful: use of reusable library components and reuse growth factor. The latter, developed in this study and described below, helped uncover a new opportunity for reuse that was not obvious from other measures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Agresti and W. Evanco. </author> <title> Projecting software defects in analyzing Ada designs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(11):988997, </volume> <year> 1992. </year>
Reference-contexts: Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units <ref> [1] </ref>, files, functions, lines of code, etc. Then a complete and precise measure calculates exactly the amount of reusable code required for the functioning of the application being measured. Reference [4] described a model and methodology to compute such reuse measures.
Reference: [2] <author> B. H. Barnes and T. B. Bollinger. </author> <title> Making Reuse Cost-Effective. </title> <journal> IEEE Software, </journal> <volume> 8(1):1324, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Five objective reuse measures [4] have been applied to the code to estimate current impact of reuse and stimulate new reuse. While each measure has strengths and weaknesses (see Table 7 in the Discussion section), two derived from the consumer/producer model <ref> [2] </ref> have been particularly useful: use of reusable library components (for producers) and reuse growth factor (for consumers). The latter, developed in this study and introduced in the Measurements section below, helped identify a new opportunity for reuse that was not obvious from other measures. <p> Based on a consumer/producer model <ref> [2] </ref>, Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc. <p> The literature, however, suggests that code expansion factors overstate reuse (see <ref> [2] </ref>), as the code generated by a macro is counted each time the macro is used. Furthermore, this measure does not account for reuse of important components in other architectural layers, such as the reusable frames and reusable C functions in this project.
Reference: [3] <author> Y. F. Chen. </author> <title> Reverse Engineering. </title> <editor> In B. Krishnamurthy, editor, </editor> <title> Practical Reusable UNIX Software. </title> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year> <note> Chapter 6. </note>
Reference-contexts: Reference [4] described a model and methodology to compute such reuse measures. In particular, specific measures for the C language were proposed based on the C Information Abstraction System, CIA <ref> [3] </ref>. We follow their lead and the reuse measures used here build on their model. The perspective of their work was mainly on producers of reusable components.
Reference: [4] <author> Y. F. Chen, B. Krishnamurthy, and K. P. Vo. </author> <title> An Objective Reuse Metric: Model and Methodology. </title> <booktitle> In Fifth European Software Engineering Conference, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: These systems are used daily to monitor and provision our telephone network. Level of software reuse is high. The top 50 reusable components are called anywhere from 100 to over 10,000 times across applications and certain applications approach 60% of reusable code. Five objective reuse measures <ref> [4] </ref> have been applied to the code to estimate current impact of reuse and stimulate new reuse. <p> Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo <ref> [4] </ref> introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc. <p> Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc. Then a complete and precise measure calculates exactly the amount of reusable code required for the functioning of the application being measured. Reference <ref> [4] </ref> described a model and methodology to compute such reuse measures. In particular, specific measures for the C language were proposed based on the C Information Abstraction System, CIA [3]. We follow their lead and the reuse measures used here build on their model. <p> Each measure reveals some aspect of software reuse and leads to different insights and observations about the code. Code profile and reuse growth factor are derived below in this study from the model in reference <ref> [4] </ref>. Code expansion via macros The highest layer of reusable code consists of macros that implement parameterized, high-level reusable objects and generate EASEL code. These macros encapsulate details of complicated tasks that are tedious to implement directly in EASEL. <p> Reuse percentages of library components Producers of reusable components are often interested in finding out how much of a library is being used by applications (see <ref> [4] </ref>). Table 4 reports the number of components called in each of the project libraries. The INLIB row shows the total number of components in each library, including internal library functions, and the fact that all of them (100%) are being used. Comm. Comm. Comm.
Reference: [5] <author> P. Devanbu, S. Karstu, W. Melo, and W. Thomas. </author> <title> Analytical and Empirical Evaluation of Software Reuse Metrics. </title> <booktitle> In The 18th Internation Conference on Software Engineering, </booktitle> <pages> pages 189 199, </pages> <year> 1996. </year>
Reference-contexts: Except for time-proven components (e.g., standard library functions), the lack of such a feedback loop often leads to the temptation to copy and modify (as occurred in <ref> [5] </ref>), where knowledge gained in a modification is quickly lost and convergence to final highly reusable software is not possible. Our model of this active feedback is depicted in Figure 4. Project managers and architects help define the software architecture for the project. <p> In our environment, a reusable repository is expected to continually evolve along with new requirements. However, component reuse can be treated as reuse at any given point in time, since only component producers update libraries and not component users. A recent study by Devanbu et al. <ref> [5] </ref> reported a limited experiment with seven student projects using three libraries: MotifApp, a GNU C++ library, and a C++ database library. It was found that there was no unmodified software reuse. In each case, library code was copied and changed.
Reference: [6] <author> G. S. Fowler, J. J. Snyder, and K. P. Vo. </author> <title> End User Systems, Reusability, and High Level Design. </title> <booktitle> In USENIX Symposium on Very High Level Languages, </booktitle> <pages> pages 101118. </pages> <publisher> USENIX, </publisher> <month> October 26-28 </month> <year> 1994. </year>
Reference-contexts: In 1990, a project was started to build applications that tied together many of the existing tools and to build new tools more suitable for the management of a modern telephone network. For this task, the team chose EASEL <ref> [14, 6] </ref> a language and system to build end-user applications based on interactive constructs such as windows, forms, menus, and hypertexts. Data manipulation and analysis for applications and their users can be performed by EASEL code or can be handed out to existing computational tools written in other languages.
Reference: [7] <author> W. Frakes and C. Terry. </author> <title> Software Reuse: Metrics and Models. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(2):415435, </volume> <year> 1996. </year>
Reference-contexts: that might benefit from the solution Implement in: present application new releases of identified applications new applications Managers & Architects Define Layered Architecture Design New Abstractions and Reuse Components Feedback Loop Reuse 4 Objective Reuse Measures A variety of software reuse models and measures have been proposed in the literature <ref> [7, 8, 10, 11] </ref>. Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc.
Reference: [8] <author> J. Gaffney and T. Durek. </author> <title> Software reuse key to enhanced productivity: Some quantitative models. </title> <journal> Information and Software Technology, </journal> <volume> 31(5):258267, </volume> <year> 1989. </year>
Reference-contexts: that might benefit from the solution Implement in: present application new releases of identified applications new applications Managers & Architects Define Layered Architecture Design New Abstractions and Reuse Components Feedback Loop Reuse 4 Objective Reuse Measures A variety of software reuse models and measures have been proposed in the literature <ref> [7, 8, 10, 11] </ref>. Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc.
Reference: [9] <author> B. Krishnamurthy, </author> <title> editor. Practical Reusable UNIX Software. </title> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: Instead, generic solutions are sought and codified in reusable code. The creation of valuable reusable software involves much hard work. Our experience in this project parallels that recorded in <ref> [9] </ref>: the production of reusable software is much more effective when there is an active feedback loop that fosters close interaction between producers and consumers of such code.
Reference: [10] <author> W. Lim. </author> <title> Effects of Reuse on Quality, Productivity, </title> <journal> and Economics. IEEE Software, </journal> <volume> 11(5):2330, </volume> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: that might benefit from the solution Implement in: present application new releases of identified applications new applications Managers & Architects Define Layered Architecture Design New Abstractions and Reuse Components Feedback Loop Reuse 4 Objective Reuse Measures A variety of software reuse models and measures have been proposed in the literature <ref> [7, 8, 10, 11] </ref>. Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc.
Reference: [11] <author> H. Mili, F. Mili, and A. Mili. </author> <title> Reusing Software: Issues and Research Directions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(6):528562, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: that might benefit from the solution Implement in: present application new releases of identified applications new applications Managers & Architects Define Layered Architecture Design New Abstractions and Reuse Components Feedback Loop Reuse 4 Objective Reuse Measures A variety of software reuse models and measures have been proposed in the literature <ref> [7, 8, 10, 11] </ref>. Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source [12], compilation units [1], files, functions, lines of code, etc.
Reference: [12] <author> J. Poulin, J. Caruso, and D. Hancock. </author> <title> The Business Case for Software Reuse. </title> <journal> IBM Systems Journal, </journal> <volume> 32(4):567594, </volume> <year> 1993. </year>
Reference-contexts: Based on a consumer/producer model [2], Chen, Krisnamurthy and Vo [4] introduced the idea of code-based objective, complete, and precise reuse measures. Objective measures start with fixing some chosen code granularity such as shipped source <ref> [12] </ref>, compilation units [1], files, functions, lines of code, etc. Then a complete and precise measure calculates exactly the amount of reusable code required for the functioning of the application being measured. Reference [4] described a model and methodology to compute such reuse measures.
Reference: [13] <author> R. F. Rey, </author> <title> editor. Engineering and Operations in the Bell System. </title> <institution> AT&T Bell Laboratories, </institution> <year> 1983. </year>
Reference-contexts: The Project The daily management of a telephone network comprises many activities. For example, a major part is provisioning <ref> [13] </ref>, which collects, monitors and equips switches, reviews trunk forecasts, and develops plans for the order, installation, or removal of equipment. Much of the raw data are generated automatically by the switches and processors in the telephone network.
Reference: [14] <author> J. J. Snyder and K. P. Vo. </author> <title> EASEL An Application-Building Language. </title> <editor> In B. Krishnamurthy, editor, </editor> <title> Practical Reusable UNIX Software. </title> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year> <note> Chapter 4.2. </note>
Reference-contexts: In 1990, a project was started to build applications that tied together many of the existing tools and to build new tools more suitable for the management of a modern telephone network. For this task, the team chose EASEL <ref> [14, 6] </ref> a language and system to build end-user applications based on interactive constructs such as windows, forms, menus, and hypertexts. Data manipulation and analysis for applications and their users can be performed by EASEL code or can be handed out to existing computational tools written in other languages. <p> Common C Function Library General-purpose functions, including calls to construct SQL queries for ORACLE databases. At the highest level, each application is modeled by a frame network <ref> [14] </ref> in which each frame captures a high level task. These tasks model groups of activities that a group of communications network engineers and managers would perform in a course of their daily work.
Reference: [15] <author> K. P. Vo. </author> <title> IFS: A Tool to Build Application Systems. </title> <journal> IEEE Software, </journal> <volume> 7(4):2936, </volume> <month> July </month> <year> 1990. </year> <month> 9 </month>
Reference-contexts: From the outset, the project committed to a framework for software reuse to increase development effectiveness by leveraging from the many common tasks in the application suite. The software reuse framework consisted of three major components: * Employing a layered software architecture <ref> [15] </ref> with layers ranging from very high-level code with parameterized macros to fairly low-level C code interfacing directly with file and database systems, * Forming a single organization containing both consumers and producers of reusable software compo nents, and * Fostering close communications between consumers and producers (in some cases, they <p> Data manipulation and analysis for applications and their users can be performed by EASEL code or can be handed out to existing computational tools written in other languages. This is facilitated by EASEL language constructs that map into two broad programming categories <ref> [15] </ref> shown in Figure 1. Design Programming Activities focused on the user interface and high level tasks as seen from the user's point of view.
References-found: 15

