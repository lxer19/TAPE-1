URL: http://www.cs.dartmouth.edu/~jonh/research/pjw3/howell-straightforward-pjw3.ps
Refering-URL: http://www.cs.dartmouth.edu/~jonh/research/
Root-URL: http://www.cs.dartmouth.edu
Email: jonh@cs.dartmouth.edu  
Title: Straightforward Java Persistence Through Checkpointing  
Author: Jon Howell 
Date: August 6, 1998  
Address: Hanover, NH 03755-3510  
Affiliation: Department of Computer Science Dartmouth College  
Abstract: Several techniques have been proposed for adding persistence to the Java language environment. This paper describes a system we call icee that works by checkpointing the Java Virtual Machine. We compare the scheme to other persistent Java techniques. Checkpointing offers two unique advantages: first, the implementation is independent of the JVM implementation, and therefore survives JVM updates; second, because checkpointing saves and restores execution state, even threads become persistent entities.
Abstract-found: 1
Intro-found: 1
Reference: [ADJ + 96] <author> Malcom Atkinson, Laurent Daynes, Mick Jordan, Tony Printezis, and Susan Spence. </author> <title> An orthogonally persistent Java. </title> <journal> ACM SIGMOD Record, </journal> <volume> 25(4) </volume> <pages> 68-75, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package <ref> [Spe96, SA97, Jor96, ADJ + 96, PAD + 97] </ref>. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96].
Reference: [BP93] <author> N. S. Bowen and D. K. Pradhan. </author> <title> Processor- and memory-based checkpoint and rollback recovery. </title> <journal> IEEE Computer, </journal> <volume> 26(2) </volume> <pages> 22-31, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Cristian gives an overview of fault tolerance [Cri91]. He discusses how checkpointing and rollback provide failure masking for individual servers and server groups. Bowen and Pradhan discuss applications of checkpointing throughout the memory hierarchy <ref> [BP93] </ref>. The following two sections discuss extensions of checkpointing to distributed systems and some interesting uses of checkpointing. 7.2.1 Distributed checkpointing Strom and Yemini wrote a seminal paper on distributed checkpointing using message logs to recover consistent states from asynchronous checkpoints [SY85]. <p> Perl makes the same dump/reincarnate functionality available to the programmer. Checkpointing enables an intriguing mode of program debugging known as reverse execution. A sidebar in Bowen's overview describes this process <ref> [BP93] </ref>. 11 8 Conclusions By checkpointing a Java Virtual Machine, we provide persistence to the Java language environment.
Reference: [Chi93] <author> Tzi-Cker Chiueh. </author> <title> Polar: a storage architecture for fast checkpointing. </title> <journal> Journal of Information Science and Engineering, </journal> <volume> 9(1) </volume> <pages> 61-80, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Li, Naughton and Plank implemented a real-time, concurrent checkpointing system for parallel applications [LNP90]. Chiueh describes a hardware optimization for checkpointing <ref> [Chi93] </ref>. By preventing checkpoints from slowing down the target process, Chiueh's design enables a checkpoint-per-message approach to consistent distributed checkpoints, which is the most straightforward solution to the nondeter-minism and cascaded rollback problems encountered in distributed checkpointing.
Reference: [Cri91] <author> Flaviu Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Cristian gives an overview of fault tolerance <ref> [Cri91] </ref>. He discusses how checkpointing and rollback provide failure masking for individual servers and server groups. Bowen and Pradhan discuss applications of checkpointing throughout the memory hierarchy [BP93].
Reference: [Dea97] <author> Alan Dearle. </author> <title> Persistent servers + ephemeral clients = user mobility. </title> <booktitle> In Proceedings of the Second International Workshop on Persistence and Java, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: Dearle et al. suggest implementing Java on top of the Grasshopper persistent operating system. They describe how Grasshopper could be used below a JVM (or other language) to provide transparent persistence support, without modifying the runtime language system at all <ref> [DHF96, Dea97, RDH + 96] </ref>. 7.2 Checkpointing Lee and Anderson provide a thorough introduction to fault tolerance; they cover checkpointing in chapter seven in the context of backward error recovery [LA90]. Cristian gives an overview of fault tolerance [Cri91].
Reference: [DHF96] <author> Alan Dearle, David Hulse, and Alex Farkas. </author> <title> Persistent operating system support for Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: Dearle et al. suggest implementing Java on top of the Grasshopper persistent operating system. They describe how Grasshopper could be used below a JVM (or other language) to provide transparent persistence support, without modifying the runtime language system at all <ref> [DHF96, Dea97, RDH + 96] </ref>. 7.2 Checkpointing Lee and Anderson provide a thorough introduction to fault tolerance; they cover checkpointing in chapter seven in the context of backward error recovery [LA90]. Cristian gives an overview of fault tolerance [Cri91].
Reference: [dST96] <author> C. Souza dos Santos and E. Theroude. </author> <title> Persistent Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: The disadvantage is that such systems can not support persistence by reachability, type-orthogonality, or thread persistence. Persistent Java maps Java objects to a database via JDBC. The system is implemented as a Java class library, and involves no changes to the compiler or the JVM <ref> [dST96] </ref>. Classes in Persistent 9 system. Java must be declared persistent. The Jspin system provides persistence through a mapping to an object-oriented database. Jspin also avoids modifying the JVM, but requires processing any potentially persistent classes through a modified compiler [RTW97, WKMR96].
Reference: [GN96] <author> Alex Garthwaite and Scott Nettles. </author> <title> Transactions for Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM <ref> [GN96] </ref>. The Persistent Java project from IBM modifies a JVM to simulate a large address architecture, even on 32-bit hardware.
Reference: [JMN + 97] <author> Maynard P. Johnson, Steven J. Munroe, John G. Nistler, James W. Stopyro, and Ashok Malhotra. </author> <title> Java(tm) persistence via persistent virtual storage. </title> <booktitle> In Proceedings of the Second International Workshop on Persistence and Java, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: The Persistent Java project from IBM modifies a JVM to simulate a large address architecture, even on 32-bit hardware. That address space is made persistent by shared address space subsystem <ref> [Mal96, JMN + 97] </ref>. 7.1.3 Operating system support A third approach to Java persistence is to run the JVM and Java application on top of a persistent operating system. See Figure 4 (c). The advantage of such an approach is ubiquitous, orthogonal persistence without modification to the JVM.
Reference: [Jor96] <author> Mick Jordan. </author> <title> Early experiences with persistent Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: The icee-recover bar represents restarting the checkpoint taken by icee-initial to invoke the compiler again. This case shows how taking a snapshot of the Java compiler after it has completed the CPU-intensive task of loading and verifying all of its classes dramatically shortens startup time for future compilations <ref> [Jor96] </ref>. The same concept has been applied in many contexts; Section 7.2.2 mentions some examples. 6 Future work on the checkpointer We have several ideas for improvements to our checkpointer. Plank's libckpt package includes two several common optimizations we would be silly to overlook [PBKL95]. <p> The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package <ref> [Spe96, SA97, Jor96, ADJ + 96, PAD + 97] </ref>. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96].
Reference: [KMB98] <author> A.-M. Kermarrec, C. Morin, and M. Ban^atre. </author> <title> Design, implementation and evaluation of ICARE: An efficient recoverable DSM. </title> <journal> Software Practice and Experience, </journal> <volume> 28(9) </volume> <pages> 981-1010, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: ICARE, for example, is a checkpointed DSM that can improve execution time of an application because the pages replicated to form a checkpoint can serve as read-only replicas <ref> [KMB98] </ref>. Smith and Ioannidis implemented remote fork, a process migration system for Unix [SI88]. It works by checkpointing, transferring the checkpointed image to another machine, and restarting the image on the destination host.
Reference: [LA90] <author> P. A. Lee and T. Anderson. </author> <title> Fault Tolerance: </title> <booktitle> Principles and Practice, volume 3 of Dependable Computing and Fault-Tolerant Systems. </booktitle> <address> Springer Verlag, </address> <note> second revised edition, </note> <year> 1990. </year>
Reference-contexts: used below a JVM (or other language) to provide transparent persistence support, without modifying the runtime language system at all [DHF96, Dea97, RDH + 96]. 7.2 Checkpointing Lee and Anderson provide a thorough introduction to fault tolerance; they cover checkpointing in chapter seven in the context of backward error recovery <ref> [LA90] </ref>. Cristian gives an overview of fault tolerance [Cri91]. He discusses how checkpointing and rollback provide failure masking for individual servers and server groups. Bowen and Pradhan discuss applications of checkpointing throughout the memory hierarchy [BP93].
Reference: [LLOW91] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Jspin also avoids modifying the JVM, but requires processing any potentially persistent classes through a modified compiler [RTW97, WKMR96]. The ObjectStore PSE system uses a bytecode postprocessor to insert residency and update checks into methods for potentially-persistent classes <ref> [O'B96, LLOW91] </ref>. Concordia, an infrastructure for mobile agents, employs Java serialization facilities to provide persistence for agent code and data [WPW + 97]. 7.1.2 Virtual machine extension A second approach is to modify the Java Virtual Machine to provide type-orthogonal persistence to applications. See Figure 4 (b).
Reference: [LNP90] <author> Kai Li, Jeffrey F. Naughton, and James S. Plank. </author> <title> Real-time, concurrent checkpoint for parallel programs. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 79-88, </pages> <year> 1990. </year>
Reference-contexts: Li, Naughton and Plank implemented a real-time, concurrent checkpointing system for parallel applications <ref> [LNP90] </ref>. Chiueh describes a hardware optimization for checkpointing [Chi93]. By preventing checkpoints from slowing down the target process, Chiueh's design enables a checkpoint-per-message approach to consistent distributed checkpoints, which is the most straightforward solution to the nondeter-minism and cascaded rollback problems encountered in distributed checkpointing.
Reference: [Mal96] <author> Ashok Malhotra. </author> <title> Persistent Java objects: A proposal. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: The Persistent Java project from IBM modifies a JVM to simulate a large address architecture, even on 32-bit hardware. That address space is made persistent by shared address space subsystem <ref> [Mal96, JMN + 97] </ref>. 7.1.3 Operating system support A third approach to Java persistence is to run the JVM and Java application on top of a persistent operating system. See Figure 4 (c). The advantage of such an approach is ubiquitous, orthogonal persistence without modification to the JVM.
Reference: [MH96] <author> J. Eliot B. Moss and Tony L. Hosking. </author> <title> Approaches to adding persistence to Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: This technique gives rise to a unique set of persistence semantics. Moss and Hosking provide a taxonomy for categorizing persistent systems <ref> [MH96] </ref>. Figure 1 characterizes our checkpointer according to their taxonomy, to put it into the context of the persistent Java literature. The following semantic consequences arise from our checkpointing persistence scheme: 1. Persistence is type-orthogonal, includes threads, and is determined by reachability. 2. <p> Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package [Spe96, SA97, Jor96, ADJ + 96, PAD + 97]. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system <ref> [MH96] </ref>. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96]. The Persistent Java project from IBM modifies a JVM to simulate a large address architecture, even on 32-bit hardware.
Reference: [MP97] <author> C. Morin and I. Puaut. </author> <title> A survey of recoverable distributed shared virtual memory systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 8(9) </volume> <pages> 959-969, </pages> <month> Sept. </month> <year> 1997. </year>
Reference-contexts: POGS is a checkpoint coordinator, a CORBA service that assists a distributed application in taking globally-consistent checkpoints [Zwe97]. 7.2.2 Uses of checkpointing Morin and Puaut discuss the application of checkpointing to distributed shared virtual memory systems <ref> [MP97] </ref>. DSVMs are an interesting design point for checkpointing because of their implicit communication patterns that differ from those of explicit message-based systems.
Reference: [NW91] <author> S.M. Nettles and J.M. Wing. Persistence+undoability=transactions. </author> <booktitle> In Proceedings of the Twenty-Fifth Hawaii International Conference on System Sciences, </booktitle> <pages> pages 832-843, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: M2: Is program execution state persistent? Yes, thread stacks are included in the checkpoint file. M3: What is the transaction model? Our system implements persistence, not explicit transactions. Nettles and Wing describe how to build transactions out of persistence and `undoability.' <ref> [NW91] </ref> T1: Is the source language changed? No. I1: Is the Java compiler changed? No. T2: Is the object language changed? No. I2: Is the Java interpreter and run-time system modified? Trivially.
Reference: [O'B96] <author> Patrick O'Brien. </author> <title> Java data management using ObjectStore and PSE. Object Design, </title> <publisher> Inc. </publisher> <address> white paper, </address> <month> November </month> <year> 1996. </year> <note> Available at: http://www.odi.com/content/ white papers/javawp1.html. </note>
Reference-contexts: Jspin also avoids modifying the JVM, but requires processing any potentially persistent classes through a modified compiler [RTW97, WKMR96]. The ObjectStore PSE system uses a bytecode postprocessor to insert residency and update checks into methods for potentially-persistent classes <ref> [O'B96, LLOW91] </ref>. Concordia, an infrastructure for mobile agents, employs Java serialization facilities to provide persistence for agent code and data [WPW + 97]. 7.1.2 Virtual machine extension A second approach is to modify the Java Virtual Machine to provide type-orthogonal persistence to applications. See Figure 4 (b).
Reference: [PAD + 97] <author> Tony Printezis, Malcolm Atkinson, Laurent Daynes, Susan Spence, and Pete Bailey. </author> <title> The design of a new persistent object store for PJama. </title> <booktitle> In Proceedings of the Second International Workshop on Persistence and Java, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: The drawback is that the implementation of such a system must be modified to track each change to the JVM implementation. The authors of PJama, for example, lament making "a succession of ports of our technology between different versions of the JVM, an activity that will not diminish" <ref> [PAD + 97] </ref>. The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package [Spe96, SA97, Jor96, ADJ + 96, PAD + 97]. <p> The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package <ref> [Spe96, SA97, Jor96, ADJ + 96, PAD + 97] </ref>. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96].
Reference: [PBKL95] <author> James S. Plank, Micah Beck, Gerry Kingsley, and Kai Li. Libckpt: </author> <title> Transparent checkpointing under Unix. </title> <booktitle> In Proceedings of the 1995 USENIX Technical Conference, </booktitle> <pages> pages 213-224, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The same concept has been applied in many contexts; Section 7.2.2 mentions some examples. 6 Future work on the checkpointer We have several ideas for improvements to our checkpointer. Plank's libckpt package includes two several common optimizations we would be silly to overlook <ref> [PBKL95] </ref>. We may exploit shared libraries to save time and disk space. We may simplify the tool by packaging it completely as a native class. We may provide a way for our data to persist beyond class and JVM upgrades.
Reference: [RDH + 96] <author> J. Rosenberg, A. Dearle, D. Hulse, A. Lindstrom, and S. Norris. </author> <title> Operating system support for persistant and recoverable computations. </title> <journal> Communications of the ACM, </journal> <volume> 39(9) </volume> <pages> 62-69, </pages> <month> Sept. </month> <year> 1996. </year> <month> 13 </month>
Reference-contexts: Dearle et al. suggest implementing Java on top of the Grasshopper persistent operating system. They describe how Grasshopper could be used below a JVM (or other language) to provide transparent persistence support, without modifying the runtime language system at all <ref> [DHF96, Dea97, RDH + 96] </ref>. 7.2 Checkpointing Lee and Anderson provide a thorough introduction to fault tolerance; they cover checkpointing in chapter seven in the context of backward error recovery [LA90]. Cristian gives an overview of fault tolerance [Cri91].
Reference: [RTW97] <author> John V. E. Ridgway, Craig Thrall, and Jack C. Wileden. </author> <title> Toward assessing approaches to persistence for Java. </title> <booktitle> In Proceedings of the Second International Workshop on Persistence and Java, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: Classes in Persistent 9 system. Java must be declared persistent. The Jspin system provides persistence through a mapping to an object-oriented database. Jspin also avoids modifying the JVM, but requires processing any potentially persistent classes through a modified compiler <ref> [RTW97, WKMR96] </ref>. The ObjectStore PSE system uses a bytecode postprocessor to insert residency and update checks into methods for potentially-persistent classes [O'B96, LLOW91].
Reference: [SA97] <author> Susan Spence and Malcolm Atkinson. </author> <title> A scalable model of distribution promoting autonomy of and cooperation between PJava object stores. </title> <booktitle> In Proceedings of the Thirtieth Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 513-522, </pages> <year> 1997. </year>
Reference-contexts: The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package <ref> [Spe96, SA97, Jor96, ADJ + 96, PAD + 97] </ref>. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96].
Reference: [SI88] <author> Jonathan M. Smith and John Ioannidis. </author> <title> Implementing remote fork() with checkpoint/restart. </title> <type> Technical Report CUCS-365-88, </type> <institution> Columbia University, </institution> <year> 1988. </year> <note> Available at: ftp://ftp.cs.columbia.edu/pub/reports/reports-1988/ cucs-365-88.ps.gz. </note>
Reference-contexts: ICARE, for example, is a checkpointed DSM that can improve execution time of an application because the pages replicated to form a checkpoint can serve as read-only replicas [KMB98]. Smith and Ioannidis implemented remote fork, a process migration system for Unix <ref> [SI88] </ref>. It works by checkpointing, transferring the checkpointed image to another machine, and restarting the image on the destination host. Their migrated processes are "deaf and dumb;" that is, they do not attempt to handle the disconnected file descriptors.
Reference: [Spe96] <author> Susan Spence. </author> <title> Distribution strategies for Persistent Java. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: The PJama project extends the JVM by adding a persistent object pool alongside the original transient object heap. Objects are moved out to a buffer pool of storage made persistent using the Recoverable Virtual Memory (RVM) package <ref> [Spe96, SA97, Jor96, ADJ + 96, PAD + 97] </ref>. Moss and Hosking describe a new Java interpreter that they expect to base on their Persistent Smalltalk system [MH96]. Transactions for Java extends the JVM to log changes to the heap, and back them to stable storage using RVM [GN96].
Reference: [SY85] <author> R.E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: The following two sections discuss extensions of checkpointing to distributed systems and some interesting uses of checkpointing. 7.2.1 Distributed checkpointing Strom and Yemini wrote a seminal paper on distributed checkpointing using message logs to recover consistent states from asynchronous checkpoints <ref> [SY85] </ref>. Li, Naughton and Plank implemented a real-time, concurrent checkpointing system for parallel applications [LNP90]. Chiueh describes a hardware optimization for checkpointing [Chi93].
Reference: [WKMR96] <author> Jack C. Wileden, Alan Kaplan, Geir A. Myrestrand, and John V.E. Ridgway. </author> <title> Our SPIN on persistent Java: The JavaSPIN approach. </title> <booktitle> In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: Classes in Persistent 9 system. Java must be declared persistent. The Jspin system provides persistence through a mapping to an object-oriented database. Jspin also avoids modifying the JVM, but requires processing any potentially persistent classes through a modified compiler <ref> [RTW97, WKMR96] </ref>. The ObjectStore PSE system uses a bytecode postprocessor to insert residency and update checks into methods for potentially-persistent classes [O'B96, LLOW91].
Reference: [WPW + 97] <author> D. Wong, N. Paciorek, T. Walsh, J. DiCelie, M. Young, and B. Peet. </author> <title> Concordia: an infrastructure for collaborating mobile agents. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents, </booktitle> <pages> pages 86-97, </pages> <year> 1997. </year>
Reference-contexts: The ObjectStore PSE system uses a bytecode postprocessor to insert residency and update checks into methods for potentially-persistent classes [O'B96, LLOW91]. Concordia, an infrastructure for mobile agents, employs Java serialization facilities to provide persistence for agent code and data <ref> [WPW + 97] </ref>. 7.1.2 Virtual machine extension A second approach is to modify the Java Virtual Machine to provide type-orthogonal persistence to applications. See Figure 4 (b). Such systems are tightly coupled to the JVM, which is both an advantage and a drawback.
Reference: [Zwe97] <author> M. Zweiacker. </author> <title> Making CORBA applications fault tolerant using checkpointing and recovery. </title> <journal> Ada User Journal, </journal> <volume> 18(2) </volume> <pages> 78-91, </pages> <month> June </month> <year> 1997. </year> <type> 14 Figure 6: </type> <institution> Flo w c hec kp oin ting and reco v ery op erations. </institution> <month> 15 </month>
Reference-contexts: POGS is a checkpoint coordinator, a CORBA service that assists a distributed application in taking globally-consistent checkpoints <ref> [Zwe97] </ref>. 7.2.2 Uses of checkpointing Morin and Puaut discuss the application of checkpointing to distributed shared virtual memory systems [MP97]. DSVMs are an interesting design point for checkpointing because of their implicit communication patterns that differ from those of explicit message-based systems.
References-found: 30

