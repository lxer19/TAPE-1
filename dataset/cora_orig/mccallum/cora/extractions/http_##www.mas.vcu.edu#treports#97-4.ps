URL: http://www.mas.vcu.edu/treports/97-4.ps
Refering-URL: http://www.mas.vcu.edu/technic.html
Root-URL: http://www.mas.vcu.edu
Email: dresler@vcu.edu  boyle@anl.gov  
Title: Register Allocation: A Program-Algebraic Approach  
Author: R. Daniel Resler James M. Boyle 
Note: Supported in part by the Grant-in-Aid Program for Faculty of Virginia Common wealth University. Supported by the BM/C3 directorate, Ballistic Missile Defense Organization, U.S. Department of Defense.  
Address: Richmond, VA 23284-2014, USA  Argonne, IL 60439, USA  
Affiliation: Dept. of Mathematical Sciences Virginia Commonwealth University  Technology Development Division Argonne National Laboratory  
Abstract: The problem of allocating a finite number of hardware registers to evaluate arbitrarily complex arithmetic expressions arises in the implementation of programming language compilers. This problem is especially important in compiling programs to be executed on RISC-architecture computers, because, relative to CPU operations, memory references are expensive; therefore, to produce efficient code such references must be minimized. Traditionally, register allocation has been implemented by using graph-theoretic algorithms. In contrast, we discuss an approach based on direct algebraic manipulation of the expressions for which registers are to be allocated. These manipulations employ simple identities and canonical forms from "program algebra". The algebraic approach admits a straightforward implementation of the required identities as rewrite-rule program transformations. The use of canonical forms for the intermediate expressions makes it pos sible to apply the transformations automatically. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ76] <author> A.V. Aho and S.C. Johnson. </author> <title> Optimal code generation for expression trees. </title> <journal> Journal of the ACM, </journal> <volume> 23(3) </volume> <pages> 488-501, </pages> <month> July </month> <year> 1976. </year>
Reference-contexts: Allocation for code segments with straight-line control flow (i.e. for expressions or basic blocks) generally involves reordering of subexpressions to minimize the number of registers required <ref> [SU70, AJ76] </ref>. Freiburghouse uses usage counts to determine which registers to reuse or spill over a single block [Fre74].
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> VCU Mathematical Sciences Technical Report VCU-MAS-97-4 34 </note>
Reference-contexts: Freiburghouse uses usage counts to determine which registers to reuse or spill over a single block [Fre74]. Standard practice in compiler design (see, for example, <ref> [ASU86] </ref> chapter 9) is to convert an arithmetic or logical expression to a directed acyclic graph (DAG) and then to perform register allocation in two or three steps: 1. <p> The first step is to assign each temporary variable to a unique register, assuming that there is an infinite set of registers available. The second is to find a near-optimal mapping of these temporaries onto a finite set of registers. This mapping has traditionally been determined using graph-coloring algorithms <ref> [ASU86] </ref>. In order to apply a graph-coloring algorithm, one must represent, using a graph, the aspects of the code that are important for register allocation.
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torc-zon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <year> 1989. </year>
Reference-contexts: Many such heuristics have been suggested ([CAC + 81], [Cha82], <ref> [BCKT89] </ref>, [CH90], [CK91]).
Reference: [BH92] <author> James M. Boyle and Terence J. Harmer. </author> <title> A practical functional program for the CRAY X-MP. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1) </volume> <pages> 81-126, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: We have implemented the program-algebraic approach to register allocation described here as a sequence of sets of program transformations that are applied by the TAMPR program transformation system (see, for example, <ref> [BM84, Boy89, BH92, BHW97] </ref> for discussions of TAMPR and its applications). TAMPR program transformations are pure rewrite rules, expressed in terms of the syntax of the source language being transformed.
Reference: [BHW97] <author> James M. Boyle, Terence J. Harmer, and Victor L. Winter. </author> <title> The TAMPR program transformation system: Simplifying the development of numerical software. In Erland Arge, Are Mag-nus Bruaset, </title> <editor> and Hans Petter Langtangen, editors, </editor> <booktitle> Modern Software Tools for Scientific Computing, chapter 17, </booktitle> <pages> pages 353-372. </pages> <publisher> Birkhauser Boston, Inc., </publisher> <year> 1997. </year>
Reference-contexts: We have implemented the program-algebraic approach to register allocation described here as a sequence of sets of program transformations that are applied by the TAMPR program transformation system (see, for example, <ref> [BM84, Boy89, BH92, BHW97] </ref> for discussions of TAMPR and its applications). TAMPR program transformations are pure rewrite rules, expressed in terms of the syntax of the source language being transformed. <p> TAMPR program transformations are pure rewrite rules, expressed in terms of the syntax of the source language being transformed. As discussed in <ref> [BHW97] </ref>, the problem of applying sets of program transformations automatically can be solved by using intermediate canonical forms.
Reference: [BM84] <author> J.M. Boyle and M.N. Muralidharan. </author> <title> Program reuseability through program transformation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):574-588, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: We have implemented the program-algebraic approach to register allocation described here as a sequence of sets of program transformations that are applied by the TAMPR program transformation system (see, for example, <ref> [BM84, Boy89, BH92, BHW97] </ref> for discussions of TAMPR and its applications). TAMPR program transformations are pure rewrite rules, expressed in terms of the syntax of the source language being transformed.
Reference: [Boy89] <author> James M. Boyle. </author> <title> Abstract programming and program transformation|an approach to reusing programs. </title> <editor> In Ted. J. Bigger-staff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume I, chapter 15, </volume> <pages> pages 361-413. </pages> <publisher> ACM Press (Addison-Wesley), </publisher> <year> 1989. </year>
Reference-contexts: We have implemented the program-algebraic approach to register allocation described here as a sequence of sets of program transformations that are applied by the TAMPR program transformation system (see, for example, <ref> [BM84, Boy89, BH92, BHW97] </ref> for discussions of TAMPR and its applications). TAMPR program transformations are pure rewrite rules, expressed in terms of the syntax of the source language being transformed.
Reference: [BR96] <author> James M. Boyle and R. Daniel Resler. </author> <title> A program-algebraic approach to eliminating common subexpressions. </title> <type> Technical Report VCU-MAS-97-1, </type> <institution> Dept. of Mathematical Sciences, Virginia Commonwealth University, Richmond, </institution> <address> VA 23284, </address> <year> 1996. </year>
Reference-contexts: Common subexpression elimination is easy to understand and verify in the algebraic approach (see <ref> [BR96] </ref> for a thorough discussion). It simply involves expanding the scope of each lambda expression until that scope encompasses all possible instances of the subexpression the lambda expression represents. Any instances of the subexpression within the scope of that lambda expression can then be replaced by instances of the -variable.
Reference: [Bri92] <author> Preston Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, Houston, Texas, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: 1.1 Approaches to Register Allocation The problem of register allocation can be considered in four contexts according to the program scope over which registers are allocated|allocation over an expression, allocation over all expressions in a basic block, global register allocation over an entire subroutine or function, and inter-procedural register allocation <ref> [Bri92] </ref>. In this paper we apply the algebraic approach to allocation over an expression; these results can easily be extended to allocation over basic blocks. <p> Optionally, eliminate common subexpressions by reusing already loaded operands or already computed results, and 3. Map the set of temporary variable names onto the finite (usually small) set of available hardware registers as efficiently as possible. Graph-coloring <ref> [CAC + 81, CH90, Bri92] </ref> algorithms are often used to perform the last step of register allocation. (We discuss graph coloring in more detail in Section 3.) Such algorithms are NP-complete, so heuristics are employed VCU Mathematical Sciences Technical Report VCU-MAS-97-4 4 to approximately minimize the number of loads and stores
Reference: [BRW97] <author> James M. Boyle, R. Daniel Resler, and Victor L. Winter. </author> <title> Do you trust your compiler? Applying formal methods to constructing high-assurance compilers. </title> <booktitle> In Proceedings, High-Assurance Systems Engineering HASE'97, </booktitle> <address> Washington, DC, </address> <month> August 11-12, </month> <title> 1996. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1997. </year> <note> VCU Mathematical Sciences Technical Report VCU-MAS-97-4 35 </note>
Reference-contexts: Such proven transformations could be used to construct a trusted compiler|a compiler that has been formally verified to correctly compile any correct program <ref> [BRW97] </ref>. To formally verify a compiler constructed using conventional techniques requires proving that the program implementing the compiler is correct. Proofs of such programs tend to be massive and monolithic, even when the correctness of individual subroutines is proved independently [DMLJ77].
Reference: [BUVO94] <author> Brad Burgess, Nasr Ullah, Peter Van Overen, and Deene Ogden. </author> <title> The PowerPC 603 microprocessor. </title> <journal> Communications of the ACM, </journal> <volume> 37(6) </volume> <pages> 34-42, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The register allocation problem is especially interesting in compilers that produce code for RISC-architecture (reduced instruction set computer) central processing units (CPUs), such as the Sun SPARC, the DEC Alpha [Sit93], the IBM RS6000, and the Motorola-Apple-IBM PowerPC <ref> [BUVO94] </ref>. RISC architecture CPUs require that the operands of all arithmetic and logical operations reside in registers; if an operand is not already in a register, then a load instruction must be generated to place it there prior to performing the arithmetic or logical operation.
Reference: [CAC + 81] <author> C.T. Chaitin, M.A. Auslander, A.K. Chandra, J. Cooke, M.E. Hopkins, and P.W. Markstein. </author> <title> Register allocation vis graph coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Optionally, eliminate common subexpressions by reusing already loaded operands or already computed results, and 3. Map the set of temporary variable names onto the finite (usually small) set of available hardware registers as efficiently as possible. Graph-coloring <ref> [CAC + 81, CH90, Bri92] </ref> algorithms are often used to perform the last step of register allocation. (We discuss graph coloring in more detail in Section 3.) Such algorithms are NP-complete, so heuristics are employed VCU Mathematical Sciences Technical Report VCU-MAS-97-4 4 to approximately minimize the number of loads and stores
Reference: [CH90] <author> Fred C. Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Optionally, eliminate common subexpressions by reusing already loaded operands or already computed results, and 3. Map the set of temporary variable names onto the finite (usually small) set of available hardware registers as efficiently as possible. Graph-coloring <ref> [CAC + 81, CH90, Bri92] </ref> algorithms are often used to perform the last step of register allocation. (We discuss graph coloring in more detail in Section 3.) Such algorithms are NP-complete, so heuristics are employed VCU Mathematical Sciences Technical Report VCU-MAS-97-4 4 to approximately minimize the number of loads and stores <p> Many such heuristics have been suggested ([CAC + 81], [Cha82], [BCKT89], <ref> [CH90] </ref>, [CK91]).
Reference: [Cha82] <author> C.T. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-101, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Many such heuristics have been suggested ([CAC + 81], <ref> [Cha82] </ref>, [BCKT89], [CH90], [CK91]).
Reference: [CK91] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <year> 1991. </year>
Reference-contexts: Many such heuristics have been suggested ([CAC + 81], [Cha82], [BCKT89], [CH90], <ref> [CK91] </ref>).
Reference: [DMLJ77] <author> F. A. De Millo, R. J. Lipton, and Perlis A. J. </author> <title> Social processes and proof of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 271-280, </pages> <month> May </month> <year> 1977. </year>
Reference-contexts: To formally verify a compiler constructed using conventional techniques requires proving that the program implementing the compiler is correct. Proofs of such programs tend to be massive and monolithic, even when the correctness of individual subroutines is proved independently <ref> [DMLJ77] </ref>. The task is complex and labor-intensive even for simple computer programs; it is almost impossible to carry out for complex programs such as compilers that perform optimization.
Reference: [Fre74] <author> R.A. </author> <title> Freiburghouse. Register allocation via usage counts. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 638-642, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: Allocation for code segments with straight-line control flow (i.e. for expressions or basic blocks) generally involves reordering of subexpressions to minimize the number of registers required [SU70, AJ76]. Freiburghouse uses usage counts to determine which registers to reuse or spill over a single block <ref> [Fre74] </ref>. Standard practice in compiler design (see, for example, [ASU86] chapter 9) is to convert an arithmetic or logical expression to a directed acyclic graph (DAG) and then to perform register allocation in two or three steps: 1.
Reference: [Gri85] <editor> David Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1985. </year>
Reference-contexts: The first of these differences means that the usual approach to proving programs correct cannot be readily applied to TAMPR transformations. The usual approach is based on weakest preconditions <ref> [Gri85] </ref>, which describe the meaning of each statement in a programming language.
Reference: [Man74] <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill Inc., </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Why might proving that a transformation preserves correctness be eas ier than proving that a program is correct? 5.1 Semantic Basis for Proof The basis for proving that program transformations preserve correctness is the concept of program refinement <ref> [Man74] </ref>. A program P2 is a refinement of P1 if P2 is defined (terminates) whenever P1 is defined and P2 and P1 produce the same result whenever P1 is defined. <p> Thus, to be a refinement, program P2 must do everything that P1 does, and produce the same result; however, P2 may do some things that P1 does not. Thus, refinement is not equivalence, because refinement may increase definedness. If a programming language has a property called monotonicity <ref> [Man74] </ref>, then a replacing a program fragment p1 within a program P1 by a program fragment that is a refinement of p1 produces a program P2 that is a refinement of a program P1.
Reference: [McC94] <author> William W. McCune. </author> <title> OTTER 3.0 users guide. </title> <type> Technical report anl-94/6, </type> <institution> Argonne National Laboratory, </institution> <year> 1994. </year>
Reference-contexts: The manipulations required to demonstrate that the replacement of a transformation is a refinement of its pattern are tedious to carry out by hand. Therefore, we have automated them using the OTTER automated reasoning system <ref> [McC94] </ref>. The use of OTTER enables proofs of non-trivial program transformations to be constructed in practice. 5.4 Why Are Transformations Easier to Prove Than Programs? There is an important connection between the ability to apply transformations automatically and the ability to prove that these transformations preserve correctness.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics. Wm. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <address> Dubuque, Iowa, </address> <year> 1986. </year> <note> VCU Mathematical Sciences Technical Report VCU-MAS-97-4 36 </note>
Reference-contexts: A more suitable approach is to use denotational semantics <ref> [Sch86] </ref> to define the meaning of a programming language. The denotational semantics can then be used to prove that transformations of programs in that language preserve correctness. A denotational semantics constructs meaning from, and assigns meaning to, every symbol in a programming language.
Reference: [Sit93] <author> Richard L. </author> <title> Sites. Alpha AXP architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(4) </volume> <pages> 33-44, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: The register allocation problem is especially interesting in compilers that produce code for RISC-architecture (reduced instruction set computer) central processing units (CPUs), such as the Sun SPARC, the DEC Alpha <ref> [Sit93] </ref>, the IBM RS6000, and the Motorola-Apple-IBM PowerPC [BUVO94].
Reference: [SU70] <author> Ravi Sethi and J.D. Ullman. </author> <title> The generation of optimal code for arithmetic expressions. </title> <journal> Journal of the ACM, </journal> <volume> 17(4) </volume> <pages> 715-728, </pages> <month> October </month> <year> 1970. </year>
Reference-contexts: Allocation for code segments with straight-line control flow (i.e. for expressions or basic blocks) generally involves reordering of subexpressions to minimize the number of registers required <ref> [SU70, AJ76] </ref>. Freiburghouse uses usage counts to determine which registers to reuse or spill over a single block [Fre74].
Reference: [WB97] <author> Victor L. Winter and James M. Boyle. </author> <title> Proving refinement transformations for deriving high-assurance software. </title> <booktitle> In Proceedings, High-Assurance Systems Engineering Workshop, Niagara on the Lake, </booktitle> <address> Ontario, Canada, </address> <month> Oct. </month> <pages> 21-22, </pages> <year> 1996, </year> <pages> pages 68-77. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1997. </year>
Reference-contexts: Space does not permit a discussion of this methodology here (see, however, <ref> [WB97] </ref>). However, we do discuss briefly the answers to some questions and issues that arise concerning proofs that program transformations preserve correctness: VCU Mathematical Sciences Technical Report VCU-MAS-97-4 30 1. What is a suitable semantic basis for proving that TAMPR program transformations preserve correctness? 2. <p> A schema variable stands for any program fragment of its syntactic type, enabling transformations to match an unbounded set of programs. To assign meanings to schemas, denotational semantics must be extended. We extend it by adding semantic valuation functions that we call delta functions <ref> [WB97] </ref>, which describe the change in meaning of a program fragment across a schema variable. Essentially, the delta function for a schema variable describes the general semantic properties that any program fragment of its type possesses.
References-found: 24

