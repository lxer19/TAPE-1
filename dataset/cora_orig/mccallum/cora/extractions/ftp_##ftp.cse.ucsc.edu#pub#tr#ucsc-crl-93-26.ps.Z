URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-26.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Type-Specific Storage Management presentation of fault interpretation, which is a technique for improving certain algorithms
Author: Daniel Ross Edelson 
Keyword: Garbage collection, memory management, object-oriented program ming, C++, memory allocation, reference counting  
Note: a  
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Pubnum: UCSC-CRL-93-26  
Date: 28 May 1993  
Abstract: This dissertation explores the limits of integrating garbage collection (GC) and other memory management techniques into `industrial-strength' statically-typed object-oriented programming languages (OOPLs). GC cannot entirely replace manual reclamation in such languages. However, providing GC as an alternative has many benefits. We discuss various aspects of the integration of garbage collectors into programming languages such as C++. This thesis includes: * a comparison of the behavior of smart pointers with that of normal pointers, and examples of how smart pointers help integrate compiler independent memory management algorithms into a program; * a discussion of the memory management components we provide, which include: two garbage collectors, a precompiler and additional tools. 
Abstract-found: 1
Intro-found: 1
Reference: [ADH + 89] <author> R. Atkinson, Alan Demers, Carl Hauser, Christian Jacobi, Peter Kessler, and Mark Weiser. </author> <title> Experiences creating a portable Cedar. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 261-269, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: When the collector determines that an object has become garbage, the collector calls the object's finalization function. 2.6.1 Hayes Hayes presents a survey of finalization mechanisms in 10 programming languages and systems. [Hay92] His discussion of finalization includes not just object-based finalization as is found in languages like Cedar/Mesa <ref> [Rov84, ADH + 89] </ref>, but also package-based finalization as is found for packages in Ada 9X [Dep91a, Dep91b]. 1 In C++ finalization functions are called destructors. 18 2. Related Work Hayes points out several things. For one, finalization and weak pointers [Mil87] are often used together.
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proc. Programming Languages Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN Notices 23(7). </journal>
Reference-contexts: That heuristic is not perfect and memory does get lost. Therefore, a full, compacting mark and sweep garbage collection is performed off-line about once a day. 2.5.5 Appel, Ellis, Li Appel, Ellis and Li describe a realtime, concurrent garbage collector implemented on a DEC Firefly multiprocessor <ref> [AEL88] </ref>. The algorithm allows the mutators to run concurrently with the collector. Synchronization is medium-grained and accomplished with virtual memory hardware. Their collector is based on the Baker algorithm. <p> To avoid annoying pauses, the collector does its work in short chunks. Incremental garbage collectors are often concurrent, in which case protected pages of memory can serve as medium grain synchronization mechanism between the collector and the application <ref> [AEL88] </ref>. 56 4. Fault Interpretation for Implementing the GC Remembered Set Incremental Mark-and-Sweep Collection Incremental mark-and-sweep garbage collection has been implemented previously using virtual memory page protection [BDS91]. The normal implementation provides one bit of information per page: there was or was not a fault.
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proc. International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year> <journal> SIGPLAN Notices 26(4). </journal>
Reference-contexts: In this implementation, however, when a cell is removed from the free list, its value is immediately fetched. That fetch is used to avoid the test and branch. The last page of the last cell array is read-protected <ref> [AL91] </ref>. Attempting to load the link stored in the first cell on the read-protected page causes the program to receive a signal. The signal handler unprotects the page, links in and initializes a new cell array, and read-protects the last page of the new array. <p> Fault Interpretation for Implementing the GC Remembered Set 4. Fault Interpretation for Implementing the GC Remembered Set Virtual memory (VM) page protection can be used to improve the efficiency of garbage collection algorithms. (See <ref> [AL91] </ref> for a survey of uses of VM protection for GC and for other uses.) VM protection is often used to implement the remembered set in generational collectors, e.g., in generational collectors by both Boehm and Bartlett. <p> By and large, they are architecture specific and require reading the state of the CPU when the fault occurs. Thus, this technique is less portable and less general than those discussed by Appel <ref> [AL91] </ref>. Nonetheless, it has several uses and may let some programs run more efficiently. 4.4.1 Code Modification When the signal handler is invoked after a fault, it determines what instruction has faulted. <p> This also requires being able to restart the instruction following the faulted instruction. One advantage of this is the interpreter can take advantage of extra information. For example, if the fault page is also mapped without protection elsewhere in the address space <ref> [AL91, Wil92a] </ref>, the interpreter can use that version to avoid needing to unprotect and reprotect the page. 2 On delayed branch architectures, a nop is written after the branch. 60 4. Fault Interpretation for Implementing the GC Remembered Set 4.4.4 Parallelization The F I code is currently sequential. <p> The time for protect + f ault + unprotect was obtained by protecting a page, faulting, and unprotecting the page, all in a loop. This is a test whose efficiency is also measured in <ref> [AL91] </ref> and is repeated here to provide a baseline for comparison. The time for fault interpret is the time to interpret a fault, i.e., to access a protected page and have the application's notify function informed that the access has occurred, while finishing with the page still protected.
Reference: [ANS89] <author> ANSI X3.159-1989, </author> <year> 1989. </year> <title> American national standard for the C programming language. </title>
Reference-contexts: The same arguments are passed except that the flags indicate post-access. 6. F I returns the page to its previous protection state and resumes the application. The application continues with the instruction following the one that caused the fault. The library is written in C <ref> [ANS89, ISO90] </ref> using Unix system call extensions. It can also be compiled as C++ code. In order to avoid name clashes, all external identifiers used in F I begin with fi . Managed memory is obtained in segments whose size is an integral number of pages.
Reference: [ANS93] <institution> Draft proposed international standard for information systems|Programming language C++, </institution> <month> January </month> <year> 1993. </year> <title> ANSI document X3J16/93-0010, ISO document WG21/N0218. </title>
Reference-contexts: Modula-3 [CDG + 88] and C++ <ref> [ANS93] </ref> are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation. <p> C++ has multiple inheritance, parameterized types, and more recently, exception handling <ref> [ANS93] </ref>. C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. <p> If this operator could be overloaded such that it altered the value of the pointer, then the error could be avoided. Note, the current language definition does not explicitly forbid overloading this operator, nor does it explicitly permit it <ref> [ANS93] </ref>, however, it seems inevitable that overloading this operator will eventually be prohibited. 3.5.3 Another Error with Pointer Hierarchies There is one other error that the schemes presented in the last two subsections both share: they both permit an incorrect, implicit type conversion. <p> transform subsequent classes gcpush off Push state off, meaning do not transform subsequent classes gcpop Pop current state (return to previous state) the vast majority of C ++ files include the standard header file &lt;iostream.h&gt;, it would violate C ++ 's one definition rule to transform the I/O Stream classes <ref> [ANS93] </ref>. <p> The distributed garbage collector requires local garbage collectors with support for finalization. This mark-and-sweep collector serves as the foundation for the distributed garbage collector. Future implementations of C ++ will support overloaded memory allocation operators for arrays <ref> [ANS93] </ref>. However, the lack of such language support in current implementations makes it impossible to garbage collect arrays of objects. 5.11 Concluding Remarks on Type Specific Garbage Collection The complexity of the semantics of C++ is daunting.
Reference: [App87] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: He identifies and incorporates Unix features such as the memory layout of a process's address space and the virtual memory system calls. Appel argues that since copying collectors never deallocate individual objects, garbage collection can be faster than stack allocation <ref> [App87] </ref>. His collector uses a simple allocation strategy that can be hand coded in very few Vax assembly instructions. Virtual memory protection is used to avoid explicit bound checks during allocation. When a new object is 16 2.
Reference: [App89a] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <booktitle> In Lisp and Symbolic Computation, </booktitle> <volume> volume 2, </volume> <pages> pages 153-162, </pages> <year> 1989. </year>
Reference-contexts: Using this information, it marks the objects reachable from the roots present in that activation record. The map information may be maintained dynamically in the activation record [Wen88], or it may be generated statically, with the program counter used to locate the map corresponding to each activation record <ref> [Gol92, App89a] </ref>. This solution permits source-level compatibility with existing code; it requires recompilation of the libraries. Root registration: Collectors based on root registration record the addresses of the roots in auxiliary data structures, for example, the protection stack of [War87] and the root lists of [EP92]. <p> A type-accurate garbage collector can (by definition) unambiguously locate the pointers in a program. Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information [Gol92], building on work by Appel <ref> [App89a] </ref>. Gold-berg's compiler emits functions that know how to locate the pointers in all possible (necessary) activation records of the program. For example, if some function F contains two pointers as local variables, then another function would be emitted to mark from those pointers during a collection.
Reference: [App89b] <author> Andrew W. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The assignment tables are updated on every store into an old object, not just on stores of pointers to young objects. Thus the tables can become large giving an exaggerated root set for the collection <ref> [App89b] </ref>. 2.5.3 Moon The ephemeral garbage collector described by Moon is an incremental copying garbage collector based on the Baker algorithm [Moo84]. It segregates objects according to the expected longevity to concentrate effort where it is likely to be of most benefit. <p> The performance measurements of the Boyer benchmark from Gabriel [Gab85] show a garbage collection overhead of 13%. 2.5.6 Appel Appel describes a generational garbage collector suitable for use in functional language systems under Unix <ref> [App89b] </ref>. He explains the major problems inherent in generational collectors and offers efficient solutions. He identifies and incorporates Unix features such as the memory layout of a process's address space and the virtual memory system calls. <p> Given a pointer to a block the allocator can tell three things: 2 This is a nonstandard term that the author uses to describe the simple allocation scheme for a copying collector described by Appel in <ref> [App89b] </ref>. 22 2. Related Work 1. whether or not the block is currently free 2. whether or not the proceeding block is free 3. whether or not the following block is free Proceeding and following are defined in terms of absolute address, not linked-list order.
Reference: [Bak78] <author> H. G. Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: The pointers in global data, on the stack, and in the registers collectively comprise the roots. 5 2.2.2 Copying collection Modern copy collectors are based on the work of Fenichel and Yochelson [FY69] and Minsky [Min63]. Incremental copy collectors are typically based on the Baker algorithm <ref> [Bak78] </ref>. Copy collectors allocate objects from one region and then copy all live objects into another region. These collectors compact the objects into the new region improving virtual memory performance. Mark-and-sweep collectors, by contrast, require a third pass to compact; conservative collection generally precludes compaction. <p> Real-time collection is normally synonymous with incremental collection. Under this paradigm a small amount of garbage collection work is done frequently. Reference counting is one incremental reclamation technique. Baker's 1978 algorithm was incremental, but inefficient. Baker's was the first incremental, copying collector <ref> [Bak78] </ref>. 2.2.4 Generational Collection In 1983-1984 three copying collectors were presented that improved efficiency by segregating objects according to their actual age or anticipated life expectancy [LH83, Moo84, Ung84]. These collectors by Lieberman and Hewitt, Moon, and Ungar respectively, were the first generation-based collectors. <p> However, if scanning objects is relatively expensive, then remembering several stored addresses may improve efficiency. 4.2.2 Incremental Garbage Collection Incremental garbage collection is a family of algorithms in which the collector never stops the application for an extended period of time. The first such algorithm was Baker's copying collector <ref> [Bak78] </ref> with many other algorithms based on it. To avoid annoying pauses, the collector does its work in short chunks. Incremental garbage collectors are often concurrent, in which case protected pages of memory can serve as medium grain synchronization mechanism between the collector and the application [AEL88]. 56 4.
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation, Western Research Laboratory, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: As these examples illustrate, conservative collection is a very useful technique, but it is not a panacea. 2.4 Partially Conservative Garbage Collection 2.4.1 Bartlett Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C ++ that uses both conservative and copying techniques <ref> [Bar89, Bar88] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier.
Reference: [Bar89] <author> Joel F. Bartlett. </author> <title> Mostly copying garbage collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> DEC WRL, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: The opposite of type-accurate is conservative [BW88]. Conservative collectors assume that any value that might be a pointer actually is a pointer. Partially conservative collectors such as <ref> [Bar89] </ref> and [Det90] are conservative in certain regions of memory and type-accurate in others. Definitions of these and the other technical terms used in this thesis are provided in appendix A. 2.2.8 Basic Garbage Collection Techniques There are certain problems that all garbage collection algorithms must solve. <p> Conservative collection generally precludes copying collection because updating an integer that was interpreted as a pointer would be incorrect. Some collectors such as <ref> [Bar89] </ref> are conservative in some regions of memory and type-accurate in others, allowing them to copy and compact a subset of the objects. Tags: Collectors based on tags examine every word on the stack, in global data, and in the registers. <p> As these examples illustrate, conservative collection is a very useful technique, but it is not a panacea. 2.4 Partially Conservative Garbage Collection 2.4.1 Bartlett Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C ++ that uses both conservative and copying techniques <ref> [Bar89, Bar88] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier. <p> Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection <ref> [Bar89] </ref>, * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90]. <p> The mark-and-sweep collector (derived from an early version of Boehm's) uses macros and inline functions we have supplied which are shown in x 5.3.1. The collector derived from Bartlett's collector uses Bartlett's macros for this purpose <ref> [Bar89] </ref> as shown in x 5.3.2. 2 2 We use an experimental version of Bartlett's collector that has not yet been made generally available, however, the programmatic interface is the same as in the available version. 66 5. <p> Time (seconds) Memory Management Algorithm x min max 99% Partial reference counting 8.28 8.10 8.95 8.27-8.29 0.48 Generational mostly coping GC 10.80 10.50 11.10 10.76-10.78 0.11 Mark-and-sweep GC 8.30 8.23 9.03 8.29-8.31 0.09 81 <ref> [Bar89] </ref>. Both collectors were modified to support type-accurate scans of the root tables, as well as to correctly scan and update the weak pointer tables. The mark-and-sweep collector was additionally modified to support type-accurate object-scanning and finalization.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proc. Programming Languages Design and Implementation, </booktitle> <pages> pages 157-164. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year> <journal> SIGPLAN Notices 26(6). </journal>
Reference-contexts: some Smalltalk-80 implementations [GR83, Ung86] constitutes root indirection, as do the root tables of [Ede92b]. 2.3 Conservative Garbage Collection Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer <ref> [BDS91, BW88] </ref>. For example, upon examining a quantity that the program interprets as an integer (in a register, perhaps), but whose value is such that it also could be a pointer, the collector would assume the value to be a pointer. <p> Related Work quantity that points at the beginning of an object, even though the free-store memory may be discontinuous. Handling pointers into the middle of objects is more difficult requiring an expensive hash. 2.3.2 Boehm, Demers, et al. Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection <ref> [BDS91, DWH + 90] </ref> for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ [Rus91b, Rus91a]. <p> Fault Interpretation for Implementing the GC Remembered Set Incremental Mark-and-Sweep Collection Incremental mark-and-sweep garbage collection has been implemented previously using virtual memory page protection <ref> [BDS91] </ref>. The normal implementation provides one bit of information per page: there was or was not a fault. Pages on which a fault occurred must be entirely rescanned. This is another case in which fault interpretation can provide finer granularity information, possibly increasing the efficiency of the algorithm.
Reference: [Bea91] <author> Barbara Beaudoing. </author> <title> Recycler-en-Marquant : un algorithme de gestion de memoire en temps reel, Etude et implantation. </title> <type> Ph.D. thesis, </type> <institution> Universite de Paris VI, </institution> <year> 1991. </year>
Reference-contexts: The object-initialization code requires that the entire object be initialized when the object is allocated. 17 The collector's scheme for tracking pointers from old-objects to young ones is efficient only provided assignments are rare. 2.5.7 Beaudoing Beaudoing describes the Mark-During-Sweep incremental GC algorithm <ref> [Bea91, QBQ89] </ref>. This algorithm improves the efficiency of standard mark-and-sweep garbage collection by marking and sweeping together in one pass. Specifically, the sweep phase of garbage collection N is performed concurrently with the mark phase of garbage collection N + 1. This permits the algorithm to guarantee real-time performance.
Reference: [Boe91] <author> Hans-J. Boehm. </author> <title> Simple GC-safe compilation. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object. In addition, Boehm discusses compiler changes to preclude optimizations that would cause a conservative garbage collector to reclaim data that is actually accessible <ref> [Boe91] </ref>. 2.3.3 Limitations of Conservative Collection Conservative collectors can retain more garbage than type-accurate collectors because conservative collectors interpret non-pointer data as pointers. Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory.
Reference: [Bud91] <author> Timothy Budd. </author> <title> An Introduction to Object-Oriented Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: In object-oriented programming languages, finalization is even more important because the author of a class knows best what action to perform when instances of the class terminate <ref> [Bud91] </ref>. Delegating this responsibility to clients of a class violates encapsulation. In garbage collectors that support finalization, a finalization function may be associated with a dynamically allocated object.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year> <title> 242 Appendix E. GC Code </title>
Reference-contexts: This second phase is known as the sweep. This process deallocates all unreachable objects. Mark-and-sweep collection must be able to locate both the roots and the internal pointers. A form of mark-and-sweep known as conservative collection relaxes this requirement <ref> [BW88] </ref>. Basically, conservative collection treats as a pointer any properly aligned value whose value is such that it could possibly be a pointer. <p> The job of the garbage collector is to locate and deallocate every garbage object. A collector for a statically typed programming language is called type-accurate if every value that the collector interprets as a pointer is actually a pointer. The opposite of type-accurate is conservative <ref> [BW88] </ref>. Conservative collectors assume that any value that might be a pointer actually is a pointer. Partially conservative collectors such as [Bar89] and [Det90] are conservative in certain regions of memory and type-accurate in others. <p> some Smalltalk-80 implementations [GR83, Ung86] constitutes root indirection, as do the root tables of [Ede92b]. 2.3 Conservative Garbage Collection Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer <ref> [BDS91, BW88] </ref>. For example, upon examining a quantity that the program interprets as an integer (in a register, perhaps), but whose value is such that it also could be a pointer, the collector would assume the value to be a pointer. <p> This is a useful technique for accomplishing garbage collection in programming languages that do not use tagged pointers, and in the absence of compiler support. 2.3.1 Boehm and Weiser Boehm and Weiser describe a conservative garbage collector for use with statically type-checked languages like Pascal and C without compiler assistance <ref> [BW88] </ref>. They rejected tagged or limited integers or incompatibility with the standard libraries. They wanted to design a collector that would not penalize programs that did not use it. Their goals are quite similar to those of the author's project. <p> [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC <ref> [BW88, DWH + 90] </ref>. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In [Ede90], we proposed implementing GC strictly in application-code: GC implemented in a library. <p> rather than a raw pointer, collector B is guaranteed to find the pointer, and thus to avoid collecting the object. 5.5.1 The Mark-and-Sweep Collector Our mark-and-sweep garbage collector is derived from a version of Boehm's conservative collector that we have modified to support type tags, finalization, roots and weak roots <ref> [BW88] </ref>. The collector divides the heap into blocks that are used to allocate objects of uniform size. <p> The results of using this application to format the 76 page perl manual page are shown in Table 5.4. 5.10 Status of the Type-Specific Garbage Collection Components We have integrated two garbage collectors. One is a conservative mark-and-sweep collector derived from a version of Boehm's collector <ref> [BW88] </ref>. This other is derived from an experimental version of Bartlett's VM-synchronized generational mostly-copying collector Table 5.3: Execution Time for the Lisp Interpreter and Database Application Partial reference counting means the application reclaimed some objects using reference counting and made no attempt to reclaim the rest of the objects.
Reference: [Cam71] <author> J. A. Campbell. </author> <title> A note on an optimal-fit method for dynamic allocation of storage. </title> <journal> Computer Journal, </journal> <volume> 14(1) </volume> <pages> 7-9, </pages> <month> February </month> <year> 1971. </year>
Reference-contexts: Worst Fit always scans the entire ring and uses the largest block it finds. The justification is that this will not create many small blocks that cause external fragmentation. Optimal Fit scans part of the ring to get a representative sample of its contents <ref> [Cam71] </ref>. After scanning some fraction of the ring it then selects the next block it finds that is better than all the ones it has seen. Optimal Fit examines fewer blocks than Best Fit so it is faster. It examines more blocks than First Fit so it causes less fragmentation.
Reference: [CDG + 88] <author> L. Cardelli, J. Donahue, L. Glassman, M. Jordan, B. Kalsow, and G. Nelson. </author> <type> Modula-3 report. Technical report, </type> <institution> Digital Systems Research Center and Olivetti Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1988. </year>
Reference-contexts: The ways programming languages support dynamic memory reclamation can be viewed as a spectrum ranging from garbage collection (GC) as the unique memory management technique (e.g., LISP [McC60, SJ84] and Smalltalk/80 [GR83]) to languages having manual reclamation as the only language-supported technique (e.g., C [ISO90]). Modula-3 <ref> [CDG + 88] </ref> and C++ [ANS93] are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation.
Reference: [Coh81] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: The methods they use to handle back-pointers is one of the things that distinguishes these algorithms from each other. 2.2.5 Other Surveys of Garbage Collection Techniques Two major surveys of garbage collection techniques have been published. Cohen published a survey of early garbage collection techniques and algorithms <ref> [Coh81] </ref>. Wilson describes more recent techniques in uniprocessor garbage collection [Wil92b]. 2.2.6 Summary of Garbage Collection Issues Dynamically allocated memory is a critical element of modern programming practices. It is vital in graph algorithms, which constitute one of the most important abstractions in computer science.
Reference: [Col60] <author> G. E. Collins. </author> <title> A method of overlapping and erasure of lists. </title> <journal> Communications of the ACM, </journal> <volume> 3(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: *) - - dst; int main (void) - dst = (char*) src; // bad: explicit type coercion - // curly braces explicitly limit tmp_var's lifetime register char *tmp_var = src; dst = tmp_var; - 3.11 Smart Pointer Examples: Reference Counting One of the classic memory management techniques is reference counting <ref> [Col60, Knu73] </ref>. In reference counting, every object carries with it a count of the pointers that reference the object. Every pointer operation such as creating, copying, or destroying a pointer keeps the reference counts correct.
Reference: [Cop92] <author> James Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. <p> For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of <ref> [Cop92] </ref>) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. <p> In addition, reference counting imposes substantial overhead. Despite its overhead, its simplicity and effectiveness for acyclic structures make reference counting a very useful technique. This is one of the common uses of smart pointers (and accessors) in C++ <ref> [Str91, Cop92] </ref>. Appendix C.1 contains an implementation of reference counting smart pointers. 45 Most C++ implementations of reference counting are based on the traditional algorithm, described above. There are many variations that can be more efficient. Any variation should be an available, replaceable component of a program.
Reference: [DB76] <author> L. P. Deutch and D. G. Bobrow. </author> <title> An efficient incremental automatic garbage collector. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: However, testing an optimized pointer against NULL requires an additional compare and conditional branch. 3.11.2 Deferred Reference Counting Deferred Reference Counting is another optimization of the standard reference counting algorithm <ref> [DB76] </ref>. In this variation, reference counts from local variables are ignored; 46 3. Smart Pointers for Garbage Collection and Reference Counting only reference counts of global pointers and within objects are considered. This increases dramatically the efficiency of traversing a structure with a local variable (or a function parameter).
Reference: [Dep91a] <author> Department of Defense. </author> <title> Mapping Rational, volume I of Ada 9X Mapping. </title> <address> Cambridge, MA, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: finalization function. 2.6.1 Hayes Hayes presents a survey of finalization mechanisms in 10 programming languages and systems. [Hay92] His discussion of finalization includes not just object-based finalization as is found in languages like Cedar/Mesa [Rov84, ADH + 89], but also package-based finalization as is found for packages in Ada 9X <ref> [Dep91a, Dep91b] </ref>. 1 In C++ finalization functions are called destructors. 18 2. Related Work Hayes points out several things. For one, finalization and weak pointers [Mil87] are often used together.
Reference: [Dep91b] <author> Department of Defense. </author> <title> Mapping Rational, volume II of Ada 9X Mapping. </title> <address> Cambridge, MA, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: finalization function. 2.6.1 Hayes Hayes presents a survey of finalization mechanisms in 10 programming languages and systems. [Hay92] His discussion of finalization includes not just object-based finalization as is found in languages like Cedar/Mesa [Rov84, ADH + 89], but also package-based finalization as is found for packages in Ada 9X <ref> [Dep91a, Dep91b] </ref>. 1 In C++ finalization functions are called destructors. 18 2. Related Work Hayes points out several things. For one, finalization and weak pointers [Mil87] are often used together.
Reference: [Det90] <author> David Detlefs. </author> <title> Concurrent garbage collection for C++. </title> <type> Technical Report CMU CS-90-119, </type> <institution> Carnegie Mellon, </institution> <year> 1990. </year>
Reference-contexts: The opposite of type-accurate is conservative [BW88]. Conservative collectors assume that any value that might be a pointer actually is a pointer. Partially conservative collectors such as [Bar89] and <ref> [Det90] </ref> are conservative in certain regions of memory and type-accurate in others. Definitions of these and the other technical terms used in this thesis are provided in appendix A. 2.2.8 Basic Garbage Collection Techniques There are certain problems that all garbage collection algorithms must solve. <p> This collector works with non-polymorphic C ++ data structures, and requires that the programmer make a few declarations to enable the collector to locate the internal pointers within collected objects. 2.4.2 Detlefs Detlefs has implemented a concurrent atomic garbage collection in the cfront C ++ compiler <ref> [Det90] </ref>. This collector generalizes Bartlett's collector in two ways. Bartlett's collector contains two restrictions: 1. Internal pointers must be located at the beginning of objects, and 2. heap-allocated objects may not contain unsure pointers, that is, values that may or may not be pointers. <p> Indeed, at the time of this writing, garbage collection is receiving an unprecedented amount of attention in the two C ++ -related Usenix newsgroups: comp.lang.c++ and comp.std.c++. Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection <ref> [Det90] </ref>, * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91],
Reference: [Dic92] <author> Peter Dickman. </author> <title> Trading space for time in the garbage collection of actors. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 [YY91]. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors <ref> [Dic92, KWN90] </ref>. 2.5.1 Baker's Algorithm Baker's algorithm predates 1981. It is described here because several of the other collectors described in this survey are based upon it. Baker's algorithm partitions memory into two hemispaces: from-space and to-space. New objects are allocated from one end of to-space.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An excercise in cooperation. </title> <journal> Commu nications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-974, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: This organization is presented in figure 2.1. A program is typically modeled as a set of one or more application processes and one or more garbage collector processes. The application processes are called the mutators; the garbage collector processes are called the collectors. This terminology was introduced in <ref> [DLM + 78] </ref> and has since become standard. Garbage collection algorithms are typically based on one of two techniques: trace-and-sweep or copying. 2.2.1 Mark-and-sweep collection A mark-and-sweep (or trace-and-sweep, the terms are equivalent) garbage collector iterates over all of the roots [Knu73].
Reference: [DMH92] <author> Amer Diwan, Eliot Moss, and Richard Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Proc. Programming Languages Design and Implementation, </booktitle> <pages> pages 273-282. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year> <journal> SIGPLAN Notices 27(7). </journal>
Reference-contexts: Thus, for this and other reasons, the proposal retains conservative scanning of the run-time stack rather than adopting a more general but harder to implement root-finding technique such as the stack-frame maps <ref> [DMH92] </ref>. Their proposal is consistent with C ++ in that not all programs or data structures are required to use garbage collection. They partition the programs dynamic memory into the normal heap and the collected heap.
Reference: [DMS92] <author> Peter Dickman, Messac Makpangou, and Marc Shapiro. </author> <title> Contrasting fragmented objects with uniform transparent object references for distributed programming. </title> <booktitle> In Proc. SIGOPS 1992 European Workshop on Models and Paradigms for Dis tributed Systems Structuring, </booktitle> <year> 1992. </year>
Reference-contexts: This is the main problem that accessors solve. 3.9 Accessors as an Alternative to Smart Pointers Kennedy describes accessors in OATH [Ken92] as an alternative to smart pointers. The central difference between accessors and smart pointers is that accessors do not overload the indirection operators; instead, like stubs <ref> [DMS92] </ref>, they duplicate all the public member functions of the referent object and forward those calls through a pointer to the object.
Reference: [DN66] <author> O. J. Dahl and K. Nygaard. </author> <title> Simula|An Algol-based simulation language. </title> <journal> Communications of the ACM, </journal> <volume> 9 </volume> <pages> 671-678, </pages> <year> 1966. </year>
Reference-contexts: Language independent techniques include numerous garbage collection algorithms, memory allocation strategies, and finalization. 2.1 C++ C ++ is an imperative, object-oriented programming language that tries to combine the low-level efficiency of C with high-level abstractive mechanisms such as are found in Simula <ref> [Str91, Poh93, ISO90, DN66] </ref>. C++ has multiple inheritance, parameterized types, and more recently, exception handling [ANS93]. C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators.
Reference: [DWH + 90] <author> Alan Demers, Mark Weiser, Barry Hayes, Hans Boehm, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Proc. Principles of Programming Lan guages, </booktitle> <pages> pages 261-269. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Related Work quantity that points at the beginning of an object, even though the free-store memory may be discontinuous. Handling pointers into the middle of objects is more difficult requiring an expensive hash. 2.3.2 Boehm, Demers, et al. Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection <ref> [BDS91, DWH + 90] </ref> for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ [Rus91b, Rus91a]. <p> of this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 4.2.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects. <p> This has been implemented using page protection <ref> [DWH + 90] </ref>. The garbage collector write-protects all of the older-generation pages. Every fault indicates that there has been an assignment to an older generation object; the page is added to the remembered set. Upon collection, the remembered pages are scanned for back pointers. <p> [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC <ref> [BW88, DWH + 90] </ref>. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In [Ede90], we proposed implementing GC strictly in application-code: GC implemented in a library.
Reference: [ED93] <author> John R. Ellis and David L. Detlefs. </author> <title> Safe, efficient garbage collection for C++, </title> <month> February </month> <year> 1993. </year> <note> Draft in unpublished form, currently available via anonymous ftp from ftp.parc.xerox.com (13.1.64.94) in pub/ellis/gc/fl. </note>
Reference-contexts: No perfect solution to this problem has yet been presented. Ellis and Detlefs address the problem by giving correctness higher priority than completeness: their proposed garbage collector does not reclaim objects in finalization cycles <ref> [ED93, Ell93] </ref>. 2.6.2 Hudson Hudson discusses finalization [Hud91] in the context of the language-independent garbage collector toolkit [HMDW91]. The finalization semantics described by Hudson address the problem of references between finalizable objects by finalizing objects in chronological order based on time of creation. <p> The collector interface is intended to be independent of any particular algorithm, but the prototype implementation is mark-and-sweep with a conservative scan of the stack. 2.7.5 Ellis and Detlefs Ellis and Detlefs propose adding garbage collection to C ++ through a combination of language changes and compiler-enforced programming style restrictions <ref> [ED93] </ref>. The compiler changes are kept relatively simple, limiting the efficiency of the potential GC algorithms, but increasing the likelihood that compiler vendors will actually implement the changes.
Reference: [Ede90] <author> Daniel Edelson. </author> <title> Dynamic storage reclamation in C++. </title> <type> Technical Report UCSC-CRL-90-19, </type> <institution> Computer and Information Science, University of California at Santa Cruz, </institution> <month> June </month> <year> 1990. </year> <title> M.S. </title> <type> Thesis. 243 </type>
Reference-contexts: The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In <ref> [Ede90] </ref>, we proposed implementing GC strictly in application-code: GC implemented in a library. The problem with this approach is that it requires too much effort on the part of the end-user. The user must first customize/instantiate the library, and then follow its rules.
Reference: [Ede92a] <author> Daniel R. Edelson. </author> <title> Comparing two garbage collectors for C++. </title> <type> Technical Report UCSC-CRL-93-20, </type> <institution> Computer and Information Science, University of California, Santa Cruz, </institution> <year> 1992. </year>
Reference-contexts: Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection [Rus91b]. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM <ref> [Kar89, Ede92a, Ede92b] </ref>. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed. Thus, our brief efforts with conservative collection in this application proved unsuccessful. <p> The actual space overhead is greater than that because the root table grows in increments of 8 kilobytes. Measurements of the efficiency of these smart pointers show them to be more expensive than raw pointers but less expensive than reference counted pointers <ref> [Ede92a] </ref>. If a global register can be dedicated to the Root Table, then initializing a new smart pointer requires 49 When the object is reclaimed, the collector overwrites the weak pointer with NULL. two memory references and destroying one requires one memory reference. <p> Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers <ref> [Ede92a] </ref>, * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is.
Reference: [Ede92b] <author> Daniel R. Edelson. </author> <title> A mark-and-sweep collector for C++. </title> <booktitle> In Proc. Principles of Programming Languages, </booktitle> <pages> pages 51-58. </pages> <publisher> ACM, ACM, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Its disadvantages include the level of indirection and the cost of maintaining the tables. The object table of some Smalltalk-80 implementations [GR83, Ung86] constitutes root indirection, as do the root tables of <ref> [Ede92b] </ref>. 2.3 Conservative Garbage Collection Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer [BDS91, BW88]. <p> Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection [Rus91b]. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM <ref> [Kar89, Ede92a, Ede92b] </ref>. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed. Thus, our brief efforts with conservative collection in this application proved unsuccessful. <p> To implement the remembered set for generations, the collector requires a macro invocation on every assignment to an internal pointer. Similarly to the collector we describe in <ref> [Ede92b] </ref>, this collector requires that the programmer supply a function to locate internal pointers.
Reference: [Ede92c] <author> Daniel R. Edelson. </author> <title> Precompiling C++ for garbage collection. </title> <booktitle> In Proc. International Workshop on Memory Management, </booktitle> <pages> pages 299-314. </pages> <address> Spring-Verlag, </address> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science Number 637. </booktitle>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection <ref> [Ede92c] </ref>, * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. <p> C ++ was not designed with garbage collection, but there have been many proposals for GC in C ++ . On page 390 of [Poh93], <ref> [Ede92c] </ref> and [EP92] are cited, and the author suggests that omitting garbage collection from C ++ was a mistake. 2.2 Garbage Collection Overview The problem of garbage collection (GC) presupposes a data structure of dynamically allocated objects. The objects are represented as nodes in a directed graph. <p> For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection <ref> [Ken92, Ede92c] </ref>. A smart pointer encapsulates either a raw pointer or a complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. For example, code that accesses both transient and persistent objects can be written to perform its manipulations through smart pointers. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection <ref> [Ede92c] </ref>, * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. <p> In other cases, it is not critical that the application be prevented from obtaining raw pointers. For example, mark-and-sweep garbage collectors can normally tolerate the existence of raw pointers, provided the raw pointers point at objects that are also referenced by smart pointers <ref> [Ede92c] </ref>. Smart pointers leak raw pointers because of the definition in C ++ of the overloaded indirect member access operator, -&gt;. When the compiler sees an expression of the form X-&gt;Y, where X is an expression of class type, the compiler evaluates X.operator-&gt;().
Reference: [Ede92d] <author> Daniel R. Edelson. </author> <title> Smart pointers: They're smart but they're not pointers. </title> <booktitle> In Proc. Usenix C++ Technical Conference, </booktitle> <pages> pages 1-19. </pages> <publisher> Usenix Association, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e., making the smart pointer semantics a superset of raw pointer semantics, is impossible <ref> [Ede92d] </ref>. The next best thing is to see how close the code can come to making the smart pointers perfect substitutes for raw pointers in all ways except declaration syntax. C ++ was not designed with garbage collection, but there have been many proposals for GC in C ++ . <p> When the application classes are related through inheritance, the precompiler gives the derived class smart pointers user-defined type conversions to the base class smart pointer types. A detailed description of the best organization can be found in <ref> [Ede92d] </ref>. A typical smart pointer class is shown in Fig. 3.15. 3.12.3 Smart Pointer Efficiency Each smart pointer takes up two words in memory, one for the indirect pointer and one for the direct pointer.
Reference: [Ell92] <author> John R. Ellis. </author> <title> Confirmation of unreachability after finalization, 1992. </title> <type> Private communication. </type>
Reference-contexts: with the collector gc_tag CL::_gctag = gc_register (sizeof (CL), finalize, _gctrace); This modified code is produced by either the precompiler or the programmer. reclaimed in a turn when it is finalized; it is only reclaimed after another collection confirms that it is unreachable and that finalization is disabled for it <ref> [Ell92, Rov84] </ref>. A finalize function must be static, therefore, it may not be virtual (i.e., dynamically bound). However, since it is allowed to invoke virtual functions, the effect of a virtual finalize function is easily obtained.
Reference: [Ell93] <author> John R. Ellis. </author> <title> No attempt to reclaim cycles of finalizable objects, </title> <month> February </month> <year> 1993. </year> <title> Private communication. </title>
Reference-contexts: No perfect solution to this problem has yet been presented. Ellis and Detlefs address the problem by giving correctness higher priority than completeness: their proposed garbage collector does not reclaim objects in finalization cycles <ref> [ED93, Ell93] </ref>. 2.6.2 Hudson Hudson discusses finalization [Hud91] in the context of the language-independent garbage collector toolkit [HMDW91]. The finalization semantics described by Hudson address the problem of references between finalizable objects by finalizing objects in chronological order based on time of creation.
Reference: [EP92] <author> Daniel R. Edelson and Ira Pohl. </author> <title> A copying collector for C++. </title> <booktitle> In Proc. Usenix C++ Technical Conference, </booktitle> <pages> pages 85-102. </pages> <publisher> Usenix Association, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: C ++ was not designed with garbage collection, but there have been many proposals for GC in C ++ . On page 390 of [Poh93], [Ede92c] and <ref> [EP92] </ref> are cited, and the author suggests that omitting garbage collection from C ++ was a mistake. 2.2 Garbage Collection Overview The problem of garbage collection (GC) presupposes a data structure of dynamically allocated objects. The objects are represented as nodes in a directed graph. <p> This solution permits source-level compatibility with existing code; it requires recompilation of the libraries. Root registration: Collectors based on root registration record the addresses of the roots in auxiliary data structures, for example, the protection stack of [War87] and the root lists of <ref> [EP92] </ref>. Collectors based on this technique have the potential for object-level compatibility for existing code. Root indirection: Collectors based on root indirection permit the application to manipulate only indirect pointers. Each indirect pointer references a direct pointer that is located in a root table.
Reference: [Fer91] <author> Paulo Ferreira. </author> <title> Garbage collection in C++. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: Additionally, current compiler technology renders long macros, such as those required for OATH, quite difficult to debug. A precompiler would have substantial benefits over a preprocessor for a system like OATH. 2.7.2 Ferreira Ferreira discusses a C ++ library that provides garbage collection for C ++ programs <ref> [Fer91] </ref>. The library supplies both incremental mark-and-sweep and generational copy collection, and supports pointers to the interiors of objects. The programmer renders the program suitable for garbage collection be placing macro definitions at various places in the program. <p> [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros <ref> [Fer91] </ref>, and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is. In [Ede90], we proposed implementing GC strictly in application-code: GC implemented in a library.
Reference: [FY69] <author> R. Fenichel and J. Yochelson. </author> <title> A LISP garbage-collector for virtual-memory systems. </title> <journal> Communications of the ACM, </journal> <volume> 12(11) </volume> <pages> 611-612, </pages> <month> November </month> <year> 1969. </year>
Reference-contexts: The pointers in global data, on the stack, and in the registers collectively comprise the roots. 5 2.2.2 Copying collection Modern copy collectors are based on the work of Fenichel and Yochelson <ref> [FY69] </ref> and Minsky [Min63]. Incremental copy collectors are typically based on the Baker algorithm [Bak78]. Copy collectors allocate objects from one region and then copy all live objects into another region. These collectors compact the objects into the new region improving virtual memory performance.
Reference: [Gab85] <author> Richard Gabriel. </author> <title> Performance and Evaluation of LISP Systems. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Additionally an access of a from-space object may result in very little work or in a lot of work. The amortized cost of collection is still small, however, and according to the authors, the algorithm is efficient. The performance measurements of the Boyer benchmark from Gabriel <ref> [Gab85] </ref> show a garbage collection overhead of 13%. 2.5.6 Appel Appel describes a generational garbage collector suitable for use in functional language systems under Unix [App89b]. He explains the major problems inherent in generational collectors and offers efficient solutions.
Reference: [Gau92] <author> Philippe Gautron. </author> <note> Don't convert smart pointers to voidfl, 1992. Private commu nication. </note>
Reference-contexts: Smart pointers are sometimes defined with a user-defined type conversion to voidfl; this permits the smart pointer instances to be used in control statements, e.g., if (ptr) and while (ptr). The conversion to voidfl may also be seen as undesirable <ref> [Gau92] </ref>, in which case all testing is explicit using overloaded comparison operators. Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some.
Reference: [Gin91] <author> Andrew Ginter. </author> <title> Cooperative garbage collectors using smart pointers in the C++ programming language. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, University of Calgary, </institution> <month> December </month> <year> 1991. </year> <note> Tech. Rpt. 91/451/45. </note>
Reference-contexts: of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers <ref> [Gin91] </ref>, * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90]. The vast number of proposals, without the widespread acceptance of any one, reflects how hard the problem is.
Reference: [Gol92] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proc. Programming Languages Design and Implementation, </booktitle> <pages> pages 165-176. </pages> <publisher> ACM, </publisher> <year> 1992. </year> <journal> SIGPLAN Notices 26(6). </journal>
Reference-contexts: Using this information, it marks the objects reachable from the roots present in that activation record. The map information may be maintained dynamically in the activation record [Wen88], or it may be generated statically, with the program counter used to locate the map corresponding to each activation record <ref> [Gol92, App89a] </ref>. This solution permits source-level compatibility with existing code; it requires recompilation of the libraries. Root registration: Collectors based on root registration record the addresses of the roots in auxiliary data structures, for example, the protection stack of [War87] and the root lists of [EP92]. <p> A type-accurate garbage collector can (by definition) unambiguously locate the pointers in a program. Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information <ref> [Gol92] </ref>, building on work by Appel [App89a]. Gold-berg's compiler emits functions that know how to locate the pointers in all possible (necessary) activation records of the program.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Imple mentation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: 1. Introduction The manipulation of dynamically allocated objects is fundamental to modern and classic programming practices. The ways programming languages support dynamic memory reclamation can be viewed as a spectrum ranging from garbage collection (GC) as the unique memory management technique (e.g., LISP [McC60, SJ84] and Smalltalk/80 <ref> [GR83] </ref>) to languages having manual reclamation as the only language-supported technique (e.g., C [ISO90]). Modula-3 [CDG + 88] and C++ [ANS93] are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation. <p> This method, too, has the potential for object-level compatibility between code that uses garbage collection and code that does not. Its disadvantages include the level of indirection and the cost of maintaining the tables. The object table of some Smalltalk-80 implementations <ref> [GR83, Ung86] </ref> constitutes root indirection, as do the root tables of [Ede92b]. 2.3 Conservative Garbage Collection Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer [BDS91, BW88].
Reference: [Gro92] <author> Ed Grossman. </author> <title> Using smart pointers for transparent access to objects on disk or across a network, 1992. </title> <type> Private communication. </type>
Reference-contexts: For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e., making the smart pointer semantics a superset of raw pointer semantics, is impossible [Ede92d]. <p> For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [Hay92] <author> Barry Hayes. </author> <title> Finalization in the collector interface. </title> <booktitle> In Proc. International Workshop on Memory Management. Spring-Verlag, 1992. Lecture Notes in Computer Science Number 637. </booktitle>
Reference-contexts: In garbage collectors that support finalization, a finalization function may be associated with a dynamically allocated object. When the collector determines that an object has become garbage, the collector calls the object's finalization function. 2.6.1 Hayes Hayes presents a survey of finalization mechanisms in 10 programming languages and systems. <ref> [Hay92] </ref> His discussion of finalization includes not just object-based finalization as is found in languages like Cedar/Mesa [Rov84, ADH + 89], but also package-based finalization as is found for packages in Ada 9X [Dep91a, Dep91b]. 1 In C++ finalization functions are called destructors. 18 2. <p> Thus, an object referenced by a root is guaranteed to be preserved during garbage collection. Furthermore, if the garbage collector relocates objects, then roots will have their values updated to reflect object motion. Weak pointers are frequently found in systems that support garbage collection with finalization <ref> [Mil87, Hay92] </ref>. The weak pointers are not traced during collection. Rather, after collection, any weak pointer that references an just-collected object has its pointer value overwritten with NULL. The code for these smart pointers is presented in E.
Reference: [HM90] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Towards compile-time optimizations for persistence. </title> <booktitle> In Fourth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 17-27. </pages> <publisher> Morgan Kaufman (1991), </publisher> <year> 1990. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [HMDW91] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christopher F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <type> Technical Report Coins 91-47, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> September </month> <year> 1991. </year> <title> 244 Appendix E. GC Code </title>
Reference-contexts: Ellis and Detlefs address the problem by giving correctness higher priority than completeness: their proposed garbage collector does not reclaim objects in finalization cycles [ED93, Ell93]. 2.6.2 Hudson Hudson discusses finalization [Hud91] in the context of the language-independent garbage collector toolkit <ref> [HMDW91] </ref>. The finalization semantics described by Hudson address the problem of references between finalizable objects by finalizing objects in chronological order based on time of creation. He claims that in both functional languages and Modula-3 with the new operator, this yields the desired semantics in many cases.
Reference: [Hud91] <author> Richard L. Hudson. </author> <title> Finalization in a garbage collected world. </title> <institution> University Computing Services, University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: No perfect solution to this problem has yet been presented. Ellis and Detlefs address the problem by giving correctness higher priority than completeness: their proposed garbage collector does not reclaim objects in finalization cycles [ED93, Ell93]. 2.6.2 Hudson Hudson discusses finalization <ref> [Hud91] </ref> in the context of the language-independent garbage collector toolkit [HMDW91]. The finalization semantics described by Hudson address the problem of references between finalizable objects by finalizing objects in chronological order based on time of creation.
Reference: [ISO90] <institution> ISO 9899-1990, </institution> <year> 1990. </year> <title> International standard for the C programming language. </title>
Reference-contexts: The ways programming languages support dynamic memory reclamation can be viewed as a spectrum ranging from garbage collection (GC) as the unique memory management technique (e.g., LISP [McC60, SJ84] and Smalltalk/80 [GR83]) to languages having manual reclamation as the only language-supported technique (e.g., C <ref> [ISO90] </ref>). Modula-3 [CDG + 88] and C++ [ANS93] are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation. <p> Language independent techniques include numerous garbage collection algorithms, memory allocation strategies, and finalization. 2.1 C++ C ++ is an imperative, object-oriented programming language that tries to combine the low-level efficiency of C with high-level abstractive mechanisms such as are found in Simula <ref> [Str91, Poh93, ISO90, DN66] </ref>. C++ has multiple inheritance, parameterized types, and more recently, exception handling [ANS93]. C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. <p> The same arguments are passed except that the flags indicate post-access. 6. F I returns the page to its previous protection state and resumes the application. The application continues with the instruction following the one that caused the fault. The library is written in C <ref> [ANS89, ISO90] </ref> using Unix system call extensions. It can also be compiled as C++ code. In order to avoid name clashes, all external identifiers used in F I begin with fi . Managed memory is obtained in segments whose size is an integral number of pages.
Reference: [Kar89] <author> Kevin Karplus. </author> <title> Using if-then-else DAGs for multi-level logic minimization. </title> <editor> In Charles L. Seitz, editor, </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 101-118, </pages> <address> Pasadena, CA, 20-22 March 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection [Rus91b]. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM <ref> [Kar89, Ede92a, Ede92b] </ref>. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed. Thus, our brief efforts with conservative collection in this application proved unsuccessful.
Reference: [Ken92] <author> Brian Kennedy. </author> <title> The features of the object-oriented abstract type hierarchy (OATH). </title> <booktitle> In Proc. Usenix C++ Technical Conference, </booktitle> <pages> pages 41-50. </pages> <publisher> Usenix Association, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. <p> Since finalization may have made the object reachable, it is not reclaimed until another garbage collection confirms the object to be inaccessible. 19 2.7 C++ Libraries and Extensions 2.7.1 Kennedy Kennedy describes a C ++ type hierarchy called OATH that uses garbage collection <ref> [Ken92] </ref>. Its collector algorithm uses a combination of reference counting and mark-and-sweep. In OATH, objects are accessed exclusively through references called accessors. An accessor implements reference counting on its referent. Thus, the first reclamation algorithm available for OATH objects is reference counting. <p> For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection <ref> [Ken92, Ede92c] </ref>. A smart pointer encapsulates either a raw pointer or a complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. For example, code that accesses both transient and persistent objects can be written to perform its manipulations through smart pointers. <p> Given this, we conclude that the C ++ programming language does not support seamless smart pointers: smart pointers 26 3. Smart Pointers for Garbage Collection and Reference Counting cannot transparently replace raw pointers in all ways except declaration syntax. We show that this conclusion also applies to accessors <ref> [Ken92] </ref>. The organization of this chapter is as follows: x 3.2 very briefly summarizes the behavior of raw pointers that smart pointers try to emulate, particularly in terms of the standard type conversions. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. <p> It is also possible to emulate them using the standard reference conversions <ref> [Ken92] </ref>. We arrange the smart pointer classes in a class hierarchy that parallels the object hierarchy. Figure 3.2 illustrates this. Since class Pc derives from Pb, any instance of Pc can be converted to an instance of Pb through the standard Derived& to Base& conversion. <p> & a, objA & b) a= b; - int main (void) - characterA ch = characterA::make ('A'); stringA str = minStringA::make (); str &lt;< "hello"n"; cout &lt;< str; f (str,ch); // incompatible assignment cout &lt;< str; // This causes a core dump. return 0; - This example uses OATH accessors <ref> [Ken92, x 3.9] </ref>. Of the possibilities discussed, we suggest using user-defined type conversions to direct and indirect base classes. The programmer may need to disambiguate some overloaded function calls that would be legal using raw pointers. 3.6 Supporting const Type Conversions Supporting the base class conversions is one problem. <p> In some cases (though not all), it is desirable to prevent this. For example, if smart pointers are used to implement copying garbage collection, then after a garbage collection, all dynamically allocated objects have been moved and any raw pointer no longer has the correct value. As another example, <ref> [Ken92] </ref> discusses why the problem of raw pointer leakage makes smart pointers unsafe for reference counting. The basic idea is that the application can obtain a reference counted pointer as a temporary expression, perhaps as the return value from a function. <p> However, as shown for the case of reference counting, for example, destroying the smart pointer may cause the raw pointer to become a dangling reference. This is the main problem that accessors solve. 3.9 Accessors as an Alternative to Smart Pointers Kennedy describes accessors in OATH <ref> [Ken92] </ref> as an alternative to smart pointers. The central difference between accessors and smart pointers is that accessors do not overload the indirection operators; instead, like stubs [DMS92], they duplicate all the public member functions of the referent object and forward those calls through a pointer to the object. <p> Accessors are somewhere in between smart pointers and smart references, because they implement pointer semantics, but use `.' rather than `-&gt;' to access the underlying object. to reproduce all the functionality described in <ref> [Ken92] </ref>, instead, it just shows the relation between the application class and the accessor class. Accessors are clearly superior to smart pointers because they prevent raw pointer leakage. However, they are difficult to declare because every member function of the application class must also be declared in the accessor class. <p> Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC <ref> [Ken92] </ref>, * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers [MIKC92, Mae92], * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, <p> This is because any collector in the system is required to examine all the roots. 5.6 Stack Pointers Using accessors, it would almost be possible to keep the application from obtaining raw pointers <ref> [Ken92] </ref>. However, there would remain the problem of this pointers on the stack. Overall, for both convenience and efficiency, it does not appear desirable to attempt to prevent absolutely the creation of raw pointers on the stack.
Reference: [Knu73] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison, Wesley, </publisher> <address> Reading, Mass., </address> <year> 1973. </year> <note> Second ed. </note>
Reference-contexts: This terminology was introduced in [DLM + 78] and has since become standard. Garbage collection algorithms are typically based on one of two techniques: trace-and-sweep or copying. 2.2.1 Mark-and-sweep collection A mark-and-sweep (or trace-and-sweep, the terms are equivalent) garbage collector iterates over all of the roots <ref> [Knu73] </ref>. From each root, it visits the subgraph reachable from the root. As each object is visited, a mark bit associated with the object is set. This is known as the mark or trace phase. After the mark phase, the collector iterates over all of the allocated objects. <p> Running time of LISP programs is significantly impacted by the efficiency of the memory allocator. Research into improving efficiency has resulted in a wide variety of strategies. There are four common classes of memory allocation strategies: Sequential Fit, Buddy System, Segregated Free-list, and Buffer Block allocation. 2 Knuth <ref> [Knu73] </ref> and Standish [Sta80] are good references for detailed descriptions of the issues that arise in implementing these strategies. Knuth's book predates the Quick Fit Segregated Free-list method. Dynamic allocation strategies are difficult to analyze analytically but easy to measure empirically. <p> It examines more blocks than First Fit so it causes less fragmentation. A naive Sequential Fit allocator might use a linear linked list rather than a circular one. Knuth found that this leads to many very small fragments at the beginning of the list <ref> [Knu73] </ref>. This slows down the First Fit and Optimal Fit strategies. This was an important observation because First Fit was the most common strategy at the time it was made. <p> For example, a request for 10 bytes would be satisfied with a 16 byte block. How this is accomplished if no 16 byte block is available is described in the following paragraphs. Every block has its buddy <ref> [Knu73] </ref>. A block of size 2 k is always aligned so that the last k 1 bits of its address are zero. The k th bit may be either one or zero. <p> *) - - dst; int main (void) - dst = (char*) src; // bad: explicit type coercion - // curly braces explicitly limit tmp_var's lifetime register char *tmp_var = src; dst = tmp_var; - 3.11 Smart Pointer Examples: Reference Counting One of the classic memory management techniques is reference counting <ref> [Col60, Knu73] </ref>. In reference counting, every object carries with it a count of the pointers that reference the object. Every pointer operation such as creating, copying, or destroying a pointer keeps the reference counts correct.
Reference: [KWN90] <author> Dennis Kafura, Doug Washabaugh, and Jeff Nelson. </author> <title> Garbage collection of actors. </title> <booktitle> In Proc. OOPSLA/ECOOP, </booktitle> <pages> pages 126-134, </pages> <month> October </month> <year> 1990. </year> <journal> SIGPLAN Notices 25(10). </journal>
Reference-contexts: Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 [YY91]. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors <ref> [Dic92, KWN90] </ref>. 2.5.1 Baker's Algorithm Baker's algorithm predates 1981. It is described here because several of the other collectors described in this survey are based upon it. Baker's algorithm partitions memory into two hemispaces: from-space and to-space. New objects are allocated from one end of to-space.
Reference: [LH83] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Reference counting is one incremental reclamation technique. Baker's 1978 algorithm was incremental, but inefficient. Baker's was the first incremental, copying collector [Bak78]. 2.2.4 Generational Collection In 1983-1984 three copying collectors were presented that improved efficiency by segregating objects according to their actual age or anticipated life expectancy <ref> [LH83, Moo84, Ung84] </ref>. These collectors by Lieberman and Hewitt, Moon, and Ungar respectively, were the first generation-based collectors. These collectors and more recent ones are described in the next chapter. 6 2. <p> The amount of work that it performs during a request is proportional to the size of the request. While incremental and therefore by definition real-time, this algorithm is inefficient. 2.5.2 Lieberman and Hewitt Lieberman and Hewitt designed an incremental copying garbage collection algorithm that segregates objects by their age <ref> [LH83] </ref>. The algorithm creates a number of regions of objects that are garbage collected at different rates. A region that is very young probably contains more garbage than an older region and therefore is garbage collected more frequently. The creation region is used to allocate new objects. <p> of this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 4.2.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [LH89] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: phase has terminated, the pages that had between 1 and N faults can be serviced very quickly because the addresses of the writes have been saved. 4.2.3 Consistency and Replication Control F I can be used to implement arbitrary replication and consistency protocols on top of transparent distributed shared memory <ref> [LH89] </ref>. The contribution of F I is the ability to execute application code before and after memory pages are accessed. This code might, for example, implement a voting algorithm [Lon88]. The consistency protocol runs transparently; the client accesses the memory with normal load and store instructions.
Reference: [Lon88] <author> Darrell D. E. </author> <title> Long. The Management of Replication in a Distributed System. </title> <type> Ph.D. dissertation, </type> <institution> University of California at San Diego, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: The contribution of F I is the ability to execute application code before and after memory pages are accessed. This code might, for example, implement a voting algorithm <ref> [Lon88] </ref>. The consistency protocol runs transparently; the client accesses the memory with normal load and store instructions. One possible implementation is the following. Shared memory pages are replicated on all the participating sites.
Reference: [Mae92] <author> Roman E. Maeder. </author> <title> A provably correct reference count scheme for a symbolic computation system. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. <p> Ferreira's collector can also scan objects conservatively in order to obviate the need for programmer-coding of this function. 2.7.3 Maeder Maeder describes a C ++ library for symbolic computation systems based on smart pointers and reference counting <ref> [Mae92] </ref>. The library contains class hierarchies for expressions, strings, symbols, and other objects that are called normal. To improve the efficiency of assignment of reference counted pointers, Maeder uses the address of a discrete object 20 2. Related Work as a replacement for the NULL pointer. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. <p> Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers <ref> [MIKC92, Mae92] </ref>, * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90].
Reference: [Mak89] <author> Mesaac Mounchili Makpangou. </author> <title> Protocoles de communication et programmation par objets : l'exemple de SOS. </title> <type> Ph.D. thesis, </type> <institution> Universite Paris VI, Paris (France), </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: For transparent persistent memory, the fault time is inconsequential compared to the time to write the data to disk. Similarly, assuming that the time for a network message for a relatively fast protocol such as UDP is on the order of 1.5ms <ref> [Mak89] </ref>, fault handling should not be the bottleneck in implementing distributed shared memory. Lastly, we observe that disk and network latencies do not scale with processor speeds, whereas fault handling latency does increase with faster CPUs, subject to memory access time.
Reference: [McC60] <author> J. McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Communications of the ACM, </journal> <volume> 3 </volume> <pages> 184-195, </pages> <year> 1960. </year>
Reference-contexts: 1. Introduction The manipulation of dynamically allocated objects is fundamental to modern and classic programming practices. The ways programming languages support dynamic memory reclamation can be viewed as a spectrum ranging from garbage collection (GC) as the unique memory management technique (e.g., LISP <ref> [McC60, SJ84] </ref> and Smalltalk/80 [GR83]) to languages having manual reclamation as the only language-supported technique (e.g., C [ISO90]). Modula-3 [CDG + 88] and C++ [ANS93] are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation.
Reference: [MIKC92] <author> Peter W. Madany, Nayeem Islam, Panos Kougiouris, and Roy H. Campbell. </author> <title> Reification and reflection in C++: An operating systems perspective. </title> <type> Technical Report UIUCDCS-R-92-1736, </type> <institution> Dept. of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. <p> Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of <ref> [MIKC92] </ref> or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting <ref> [Ken92, Mae92, MIKC92, Cop92] </ref>, * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> Previous proposals span the spectrum of techniques including: * compiler-based concurrent atomic mostly-copying garbage collection [Det90], * library-based reference counting and mark-and-sweep GC [Ken92], * library-based mostly copying generational garbage collection [Bar89], * library-based reference counting through smart pointers <ref> [MIKC92, Mae92] </ref>, * library-based mark-and-sweep GC using smart pointers [Ede92a], * compiler-based GC using smart pointers [Gin91], * library-based mark-and-sweep and generational copying collection using macros [Fer91], and, * library-based conservative generational mark-and-sweep GC [BW88, DWH + 90].
Reference: [Mil87] <author> J. S. Miller. Multischeme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <year> 1987. </year> <note> MIT/LCS/Tech. Rep.-402. </note>
Reference-contexts: Related Work Hayes points out several things. For one, finalization and weak pointers <ref> [Mil87] </ref> are often used together. A weak pointer to an object is a pointer that does not prevent the object from being reclaimed by the garbage collector. To prevent dangling references, when an object is reclaimed, all weak pointers to the object should be overwritten with a NULL pointer value. <p> Thus, an object referenced by a root is guaranteed to be preserved during garbage collection. Furthermore, if the garbage collector relocates objects, then roots will have their values updated to reflect object motion. Weak pointers are frequently found in systems that support garbage collection with finalization <ref> [Mil87, Hay92] </ref>. The weak pointers are not traced during collection. Rather, after collection, any weak pointer that references an just-collected object has its pointer value overwritten with NULL. The code for these smart pointers is presented in E. <p> The application also has available smart pointers implementing weak pointers into the data structure. These are pointers that do not prevent the referenced objects from being collected. When a referenced object is garbage collected, all weak pointers to the object have their values overwritten with NULL <ref> [Mil87] </ref>. The roots and the weak pointers constitute a form of shared data between the application and the collector, as shown in figure 5.1. In fact, figure 5.1 is somewhat simplistic because it shows only one collector.
Reference: [Min63] <author> M. L. Minsky. </author> <title> A LISP garbage collector algorithm using serial secondary storage. </title> <type> Technical Report Memo 58 (rev.), </type> <institution> Project Mac, MIT, </institution> <address> Cambridge, MA, </address> <month> December </month> <year> 1963. </year>
Reference-contexts: The pointers in global data, on the stack, and in the registers collectively comprise the roots. 5 2.2.2 Copying collection Modern copy collectors are based on the work of Fenichel and Yochelson [FY69] and Minsky <ref> [Min63] </ref>. Incremental copy collectors are typically based on the Baker algorithm [Bak78]. Copy collectors allocate objects from one region and then copy all live objects into another region. These collectors compact the objects into the new region improving virtual memory performance.
Reference: [Moo84] <author> David Moon. </author> <title> Garbage collection in a large LISP system. </title> <booktitle> In Proc. Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 235-246. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Reference counting is one incremental reclamation technique. Baker's 1978 algorithm was incremental, but inefficient. Baker's was the first incremental, copying collector [Bak78]. 2.2.4 Generational Collection In 1983-1984 three copying collectors were presented that improved efficiency by segregating objects according to their actual age or anticipated life expectancy <ref> [LH83, Moo84, Ung84] </ref>. These collectors by Lieberman and Hewitt, Moon, and Ungar respectively, were the first generation-based collectors. These collectors and more recent ones are described in the next chapter. 6 2. <p> Thus the tables can become large giving an exaggerated root set for the collection [App89b]. 2.5.3 Moon The ephemeral garbage collector described by Moon is an incremental copying garbage collector based on the Baker algorithm <ref> [Moo84] </ref>. It segregates objects according to the expected longevity to concentrate effort where it is likely to be of most benefit. The collector works very closely with virtual memory and related dedicated hardware of the Symbolics 3600 LISP system to perform collection-related processing quickly and concurrently with the mutator. <p> of this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 4.2.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [Nil91] <author> Kelvin Nilsen. </author> <title> A high-performance architecture for real-time garbage collection. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: This permits the algorithm to guarantee real-time performance. The algorithm is described in both incremental and true parallel versions. 2.5.8 Schmidt and Nilsen Schmidt and Nilsen discuss a customized hardware memory system that supports hard real-time garbage collection in languages like C++ <ref> [SN91, Nil91] </ref>.
Reference: [Poh93] <author> Ira Pohl. </author> <title> Object-Oriented Programming Using C++. </title> <address> Benjamin-Cummings, </address> <year> 1993. </year> <month> 245 </month>
Reference-contexts: Language independent techniques include numerous garbage collection algorithms, memory allocation strategies, and finalization. 2.1 C++ C ++ is an imperative, object-oriented programming language that tries to combine the low-level efficiency of C with high-level abstractive mechanisms such as are found in Simula <ref> [Str91, Poh93, ISO90, DN66] </ref>. C++ has multiple inheritance, parameterized types, and more recently, exception handling [ANS93]. C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. <p> C ++ was not designed with garbage collection, but there have been many proposals for GC in C ++ . On page 390 of <ref> [Poh93] </ref>, [Ede92c] and [EP92] are cited, and the author suggests that omitting garbage collection from C ++ was a mistake. 2.2 Garbage Collection Overview The problem of garbage collection (GC) presupposes a data structure of dynamically allocated objects. The objects are represented as nodes in a directed graph.
Reference: [PS92] <author> David Plainfosse and Marc Shapiro. </author> <title> A distributed GC in an object-support operating system. </title> <editor> In Luis-Felipe Cabrera, Vince Russo, and Shapiro Marc, editors, </editor> <booktitle> Proc. Workshop on Object Orientation in Operating Systems, </booktitle> <address> Dourdan, France, </address> <month> October </month> <year> 1992. </year> <title> IEEE, </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Due to the grammar upon which it is based, the precompiler cannot parse code using templates or nested classes. The SOR group at INRIA Rocquencourt has designed and is developing a distributed garbage collection algorithm <ref> [SDP92, PS92] </ref>. The distributed garbage collector requires local garbage collectors with support for finalization. This mark-and-sweep collector serves as the foundation for the distributed garbage collector. Future implementations of C ++ will support overloaded memory allocation operators for arrays [ANS93].
Reference: [QBQ89] <author> Christian Queinnec, Barbara Beaudoing, and Jean-Pierre Queille. </author> <title> Mark DURING sweep rather than mark THEN sweep. </title> <booktitle> In Proc. PARLE '89, </booktitle> <pages> pages 224-237. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: The object-initialization code requires that the entire object be initialized when the object is allocated. 17 The collector's scheme for tracking pointers from old-objects to young ones is efficient only provided assignments are rare. 2.5.7 Beaudoing Beaudoing describes the Mark-During-Sweep incremental GC algorithm <ref> [Bea91, QBQ89] </ref>. This algorithm improves the efficiency of standard mark-and-sweep garbage collection by marking and sweeping together in one pass. Specifically, the sweep phase of garbage collection N is performed concurrently with the mark phase of garbage collection N + 1. This permits the algorithm to guarantee real-time performance.
Reference: [Rov84] <author> Paul Rovner. </author> <title> On adding garbage collection and runtime types to a strongly-typed, statically checked, concurrent language. </title> <type> Technical Report CSL-84-7, </type> <note> Xerox PARC, </note> <year> 1984. </year>
Reference-contexts: When the collector determines that an object has become garbage, the collector calls the object's finalization function. 2.6.1 Hayes Hayes presents a survey of finalization mechanisms in 10 programming languages and systems. [Hay92] His discussion of finalization includes not just object-based finalization as is found in languages like Cedar/Mesa <ref> [Rov84, ADH + 89] </ref>, but also package-based finalization as is found for packages in Ada 9X [Dep91a, Dep91b]. 1 In C++ finalization functions are called destructors. 18 2. Related Work Hayes points out several things. For one, finalization and weak pointers [Mil87] are often used together. <p> However, it is already inconsistent because the object is usable after having been destroyed, so it is not clear how compelling that argument is. 2.6.3 Cedar/Mesa Cedar/Mesa used a combination of deferred reference counting with preemptive mark-and-sweep to reclaim cyclic garbage structures <ref> [Rov84] </ref>. A finalization function and finalization queue could be associated with a type. Instances of the type may have finalization enabled on a per-instance basis. When an object with finalization enabled is identified as garbage, it is enqueued on the finalization queue for its type. <p> Again, this limits the generality and maximum efficiency of the applicable GC algorithms, while making the proposal's restrictions less onerous and more likely to be accepted. The restrictions divide C++ into the normal language and a safe-subset. This is similar to the "storage safe" subset of Cedar <ref> [Rov84] </ref>. If a programmer codes entirely in the safe subset, the proposal guarantees the program to be free of storage management errors such as dangling pointers, memory leaks, array bound errors, bogus pointer values, etc. <p> with the collector gc_tag CL::_gctag = gc_register (sizeof (CL), finalize, _gctrace); This modified code is produced by either the precompiler or the programmer. reclaimed in a turn when it is finalized; it is only reclaimed after another collection confirms that it is unreachable and that finalization is disabled for it <ref> [Ell92, Rov84] </ref>. A finalize function must be static, therefore, it may not be virtual (i.e., dynamically bound). However, since it is allowed to invoke virtual functions, the effect of a virtual finalize function is easily obtained.
Reference: [Rus91a] <author> Vincent Russo. </author> <title> Garbage collecting an object-oriented operating system kernel. </title> <booktitle> Workshop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection [BDS91, DWH + 90] for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ <ref> [Rus91b, Rus91a] </ref>. Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object.
Reference: [Rus91b] <author> Vincent Russo. </author> <title> Using the parallel Boehm/Weiser/Demers collector in an oper ating system, 1991. </title> <type> Private communication. </type>
Reference-contexts: Boehm, Demers, et al. describe conservative, generational, parallel mark-and-sweep garbage collection [BDS91, DWH + 90] for languages such as C. Russo has adapted these techniques for use in an object-oriented operating system written in C ++ <ref> [Rus91b, Rus91a] </ref>. Since they are fully conservative, during a collection these collectors must examine every word of the stack, of global data, and of every marked object. <p> For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces [Wen90, Wen88]. Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection <ref> [Rus91b] </ref>. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM [Kar89, Ede92a, Ede92b]. This application creates large data structures that are strongly connected when they become garbage. A single false pointer into the data structure keeps the entire mass of data from being reclaimed.
Reference: [Sal92] <author> Hayssam Saleh. </author> <title> Conception et realisation d'un systeme pour la programmation d'applications objets concurrentes et reparties sur machines paralleles. </title> <type> Ph.D. thesis, </type> <institution> Universite de Paris VI, </institution> <year> 1992. </year>
Reference-contexts: However, the conversion from Derivedflfl to Baseflfl is prohibited because it introduces a gaping hole in the otherwise (mostly) safe type system. Specifically, given two objects whose classes are different but have a common base, this conversion allows you to incorrectly compare or assign pointers to these objects <ref> [Sal92] </ref>.
Reference: [Sam92] <author> A. </author> <title> Dain Samples. Garbage collection cooperative C++. </title> <booktitle> In Proc. International Workshop on Memory Management. Spring-Verlag, 1992. Lecture Notes in Computer Science Number 637. </booktitle>
Reference-contexts: Other functionality allows the programmer to detect memory leaks, by reporting objects that are still alive when the program terminates. 2.7.4 Samples Samples discusses minor changes to the C ++ language that would enable it to support garbage collection <ref> [Sam92] </ref>. The changes include 3 new keywords, collected, embedded, and heap that allow: 1. classes to be collected or not, 2. individual objects to be collected or not, and, 3. pointers to reference collected or non-collected objects.
Reference: [SDP92] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Proc. Symposium on Principles of Distributed Computing, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e., making the smart pointer semantics a superset of raw pointer semantics, is impossible [Ede92d]. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems <ref> [SDP92, SMC92] </ref>, persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. <p> For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> Due to the grammar upon which it is based, the precompiler cannot parse code using templates or nested classes. The SOR group at INRIA Rocquencourt has designed and is developing a distributed garbage collection algorithm <ref> [SDP92, PS92] </ref>. The distributed garbage collector requires local garbage collectors with support for finalization. This mark-and-sweep collector serves as the foundation for the distributed garbage collector. Future implementations of C ++ will support overloaded memory allocation operators for arrays [ANS93].
Reference: [SGH + 89] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruffin, and Celine Valot. </author> <title> SOS: An object-oriented operating system|Assessment and perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [SGM89] <author> Marc Shapiro, Philippe Gautron, and Laurence Mosseri. </author> <title> Persistence and migration for C++ objects. </title> <editor> In Stephen Cook, editor, </editor> <booktitle> Proc. Third European Conference on Object-Oriented Programming, British Computer Society Workshop Series, </booktitle> <pages> pages 191-204, </pages> <address> Nottingham (GB), </address> <month> July </month> <year> 1989. </year> <institution> The British Computer Society, Cambridge University Society. </institution>
Reference-contexts: Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [SJ84] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, MA, </address> <year> 1984. </year>
Reference-contexts: 1. Introduction The manipulation of dynamically allocated objects is fundamental to modern and classic programming practices. The ways programming languages support dynamic memory reclamation can be viewed as a spectrum ranging from garbage collection (GC) as the unique memory management technique (e.g., LISP <ref> [McC60, SJ84] </ref> and Smalltalk/80 [GR83]) to languages having manual reclamation as the only language-supported technique (e.g., C [ISO90]). Modula-3 [CDG + 88] and C++ [ANS93] are two examples of programming languages that improve upon these extremes. Modula-3 gives the programmer a choice between GC and manual reclamation.
Reference: [SMC92] <author> Marc Shapiro, Julien Maisonneuve, and Pierre Collet. </author> <title> Implementing references as chains of links. </title> <booktitle> In Proc. Workshop on Object Orientation in Operating Systems, </booktitle> <year> 1992. </year>
Reference-contexts: For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e., making the smart pointer semantics a superset of raw pointer semantics, is impossible [Ede92d]. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems <ref> [SDP92, SMC92] </ref>, persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. <p> For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [SN91] <author> William J. Schmidt and Kelvin Nilsen. </author> <title> Architectural support for garbage collected memory in hard real-time systems, 1991. In unpublished form. </title>
Reference-contexts: This permits the algorithm to guarantee real-time performance. The algorithm is described in both incremental and true parallel versions. 2.5.8 Schmidt and Nilsen Schmidt and Nilsen discuss a customized hardware memory system that supports hard real-time garbage collection in languages like C++ <ref> [SN91, Nil91] </ref>.
Reference: [Sta80] <author> Thomas A. Standish. </author> <title> Data Structure Techniques. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: Research into improving efficiency has resulted in a wide variety of strategies. There are four common classes of memory allocation strategies: Sequential Fit, Buddy System, Segregated Free-list, and Buffer Block allocation. 2 Knuth [Knu73] and Standish <ref> [Sta80] </ref> are good references for detailed descriptions of the issues that arise in implementing these strategies. Knuth's book predates the Quick Fit Segregated Free-list method. Dynamic allocation strategies are difficult to analyze analytically but easy to measure empirically. Weinstock compared allocation strategies in [Wei76] and Zorn compared them in [Zor92]. <p> The lower-level can be simple or complicated. Hopefully it is not invoked too often. The second level is backed-up by the operating system memory allocator. This is the Quick Fit strategy described by Weinstock in his doctoral thesis [Wei76] and by Standish <ref> [Sta80] </ref>. Weinstock found that in some cases First Fit is faster, and in some cases Best Fit results in less fragmentation, but on the average Quick Fit is the overall best strategy. The first level Quick Fit allocator is very simple to implement.
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> The evolution of C++ 1985 to 1987. </title> <booktitle> In Proc. Usenix C++ Workshop, </booktitle> <pages> pages 1-22. </pages> <publisher> Usenix Association, </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: We then discuss a variety of GC implementations as well as related techniques such as finalization and memory allocation. Chapter 3 discusses smart pointers. Smart pointers are user-defined class objects that overload the indirection operators to be usable like normal pointers <ref> [Str87] </ref>. Smart pointers provide a compiler-independent way of incorporating into a program memory management techniques such as reference counting and garbage collection. We have analyzed the support for smart pointers in our chosen implementation language, C ++ . <p> C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. Application-level objects that overload these operators are called smart pointers <ref> [Str87, Str91] </ref> because they can substitute for the raw pointers that are predefined by the language. Smart pointers have constructors that permit them to be initialized with raw pointers such as new returns. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers <ref> [Str87] </ref> or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. <p> We are not interested in explicit type coercions they can easily conceal type-errors and because they hide important semantics such as chaining of type conversions. 3.3 Using Smart Pointers Smart pointers are class objects that behave like raw pointers <ref> [Str87, Str91] </ref>. The smart pointers overload the indirection operators (fl and -&gt;) to be usable with normal pointer syntax. They have constructors that permit them to be initialized with raw pointers such as new returns.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year> <title> 246 Appendix E. GC Code </title>
Reference-contexts: Language independent techniques include numerous garbage collection algorithms, memory allocation strategies, and finalization. 2.1 C++ C ++ is an imperative, object-oriented programming language that tries to combine the low-level efficiency of C with high-level abstractive mechanisms such as are found in Simula <ref> [Str91, Poh93, ISO90, DN66] </ref>. C++ has multiple inheritance, parameterized types, and more recently, exception handling [ANS93]. C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. <p> C ++ provides operator overloading in which an existing operator symbol is given a new meaning when applied to a user-defined type. The indirection operators fl and -&gt; are included among the overloadable operators. Application-level objects that overload these operators are called smart pointers <ref> [Str87, Str91] </ref> because they can substitute for the raw pointers that are predefined by the language. Smart pointers have constructors that permit them to be initialized with raw pointers such as new returns. <p> Programmers use smart pointers in order to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to both transient and persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g., the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken92, Ede92c]. A smart pointer encapsulates either a raw pointer or a complex handle. <p> We are not interested in explicit type coercions they can easily conceal type-errors and because they hide important semantics such as chaining of type conversions. 3.3 Using Smart Pointers Smart pointers are class objects that behave like raw pointers <ref> [Str87, Str91] </ref>. The smart pointers overload the indirection operators (fl and -&gt;) to be usable with normal pointer syntax. They have constructors that permit them to be initialized with raw pointers such as new returns. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the and then some might be: * tracing garbage collection [Ede92c], * reference counting [Ken92, Mae92, MIKC92, Cop92], * convenient access to transient or persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], or, * instrumenting (measuring) the code. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. <p> In addition, reference counting imposes substantial overhead. Despite its overhead, its simplicity and effectiveness for acyclic structures make reference counting a very useful technique. This is one of the common uses of smart pointers (and accessors) in C++ <ref> [Str91, Cop92] </ref>. Appendix C.1 contains an implementation of reference counting smart pointers. 45 Most C++ implementations of reference counting are based on the traditional algorithm, described above. There are many variations that can be more efficient. Any variation should be an available, replaceable component of a program.
Reference: [UJ88] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In Proc. Object-Oriented Programming Systems Languages and Applications, </booktitle> <pages> pages 1-17, </pages> <month> September </month> <year> 1988. </year> <journal> SIGPLAN Notices 23(11). </journal>
Reference-contexts: The tables are implemented as bit-maps to indicate pages that contain roots. Separate tables indicated in-core pages and swapped pages since in-core pages need to be processed more efficiently. 2.5.4 Ungar Generation scavenging is a memory reclamation algorithm designed by Ungar <ref> [Ung84, Ung86, UJ88] </ref>. Like the two algorithms considered earlier in this section, Generation Scavenging separates young objects from old objects. Unlike Lieberman's and Moon's algorithms Generation Scavenging is not incremental. Initially in Generation Scavenging all objects are young and they live in a single space. <p> In an early description of the algorithm [Ung86] the number of scavenges that an object needed to survive was fixed. Later work by Ungar and Jackson discusses ways of using feedback to influence the tenure threshold <ref> [UJ88] </ref>. Since the number of generations that an object survives must be counted the algorithm requires a counter per object. It also requires a single mark bit per object for marking during scavenges.
Reference: [Ung84] <author> David Ungar. </author> <title> Generation Scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year> <journal> SIGPLAN Notices 19(2). </journal>
Reference-contexts: Reference counting is one incremental reclamation technique. Baker's 1978 algorithm was incremental, but inefficient. Baker's was the first incremental, copying collector [Bak78]. 2.2.4 Generational Collection In 1983-1984 three copying collectors were presented that improved efficiency by segregating objects according to their actual age or anticipated life expectancy <ref> [LH83, Moo84, Ung84] </ref>. These collectors by Lieberman and Hewitt, Moon, and Ungar respectively, were the first generation-based collectors. These collectors and more recent ones are described in the next chapter. 6 2. <p> The tables are implemented as bit-maps to indicate pages that contain roots. Separate tables indicated in-core pages and swapped pages since in-core pages need to be processed more efficiently. 2.5.4 Ungar Generation scavenging is a memory reclamation algorithm designed by Ungar <ref> [Ung84, Ung86, UJ88] </ref>. Like the two algorithms considered earlier in this section, Generation Scavenging separates young objects from old objects. Unlike Lieberman's and Moon's algorithms Generation Scavenging is not incremental. Initially in Generation Scavenging all objects are young and they live in a single space. <p> Typically, young objects are expected to become garbage relatively soon <ref> [Ung84] </ref>, therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [Ung86] <author> David Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: This method, too, has the potential for object-level compatibility between code that uses garbage collection and code that does not. Its disadvantages include the level of indirection and the cost of maintaining the tables. The object table of some Smalltalk-80 implementations <ref> [GR83, Ung86] </ref> constitutes root indirection, as do the root tables of [Ede92b]. 2.3 Conservative Garbage Collection Conservative garbage collection is a technique in which the collector does not have access to type information so it assumes that anything that might be a pointer actually is a pointer [BDS91, BW88]. <p> The tables are implemented as bit-maps to indicate pages that contain roots. Separate tables indicated in-core pages and swapped pages since in-core pages need to be processed more efficiently. 2.5.4 Ungar Generation scavenging is a memory reclamation algorithm designed by Ungar <ref> [Ung84, Ung86, UJ88] </ref>. Like the two algorithms considered earlier in this section, Generation Scavenging separates young objects from old objects. Unlike Lieberman's and Moon's algorithms Generation Scavenging is not incremental. Initially in Generation Scavenging all objects are young and they live in a single space. <p> As that space becomes full it is scavenged. The number of scavenges that an object survives is recorded in the object. After an object survives some number of scavenges it is tenured to the next generation. In an early description of the algorithm <ref> [Ung86] </ref> the number of scavenges that an object needed to survive was fixed. Later work by Ungar and Jackson discusses ways of using feedback to influence the tenure threshold [UJ88]. Since the number of generations that an object survives must be counted the algorithm requires a counter per object.
Reference: [War87] <author> The Soft Warehouse. </author> <title> muLISP Reference Manual. </title> <address> Honolulu, </address> <year> 1987. </year>
Reference-contexts: This solution permits source-level compatibility with existing code; it requires recompilation of the libraries. Root registration: Collectors based on root registration record the addresses of the roots in auxiliary data structures, for example, the protection stack of <ref> [War87] </ref> and the root lists of [EP92]. Collectors based on this technique have the potential for object-level compatibility for existing code. Root indirection: Collectors based on root indirection permit the application to manipulate only indirect pointers. Each indirect pointer references a direct pointer that is located in a root table.
Reference: [Wei76] <author> Charles B. Weinstock. </author> <title> Dynamic Storage Allocation. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1976. </year>
Reference-contexts: Knuth's book predates the Quick Fit Segregated Free-list method. Dynamic allocation strategies are difficult to analyze analytically but easy to measure empirically. Weinstock compared allocation strategies in <ref> [Wei76] </ref> and Zorn compared them in [Zor92]. <p> The lower-level can be simple or complicated. Hopefully it is not invoked too often. The second level is backed-up by the operating system memory allocator. This is the Quick Fit strategy described by Weinstock in his doctoral thesis <ref> [Wei76] </ref> and by Standish [Sta80]. Weinstock found that in some cases First Fit is faster, and in some cases Best Fit results in less fragmentation, but on the average Quick Fit is the overall best strategy. The first level Quick Fit allocator is very simple to implement.
Reference: [Wen88] <author> E. P. Wentworth. </author> <title> An environment for investigating functional languages and implementations. </title> <type> Ph.D. thesis, </type> <institution> University of Port Elizabeth, South Africa, </institution> <year> 1988. </year>
Reference-contexts: The collector "unwinds" the stack, and interprets the map information that it finds in every activation record. Using this information, it marks the objects reachable from the roots present in that activation record. The map information may be maintained dynamically in the activation record <ref> [Wen88] </ref>, or it may be generated statically, with the program counter used to locate the map corresponding to each activation record [Gol92, App89a]. This solution permits source-level compatibility with existing code; it requires recompilation of the libraries. <p> Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory. For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces <ref> [Wen90, Wen88] </ref>. Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection [Rus91b]. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM [Kar89, Ede92a, Ede92b].
Reference: [Wen90] <author> E. P. Wentworth. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Software Practice and Experience, </journal> <pages> pages 719-727, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Often, the amount of retained garbage is small, and conservative collection succeeds quite well. Other times, conservative techniques are not satisfactory. For example, Wentworth has found that conservative garbage collection performs poorly in densely populated address spaces <ref> [Wen90, Wen88] </ref>. Russo, in using a conservative collector to reclaim dynamic storage used by an object-oriented operating system, has also found that inconveniently large amounts of garbage escape collection [Rus91b]. Lastly, we have tested conservative garbage collection with a CAD software tool called ITEM [Kar89, Ede92a, Ede92b].
Reference: [Wik87] <author> Ake Wikstrom. </author> <title> Functional programming using standard ML. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: One inefficiency with this scheme is that objects are inserted even if they do not reference a young object, e.g., if the assignment was of an old-space pointer. The ameliorating factor is that these assignments are comparatively rare in functional languages such as ML <ref> [Wik87] </ref>. As one last noteworthy item, the collector requires that old, living objects be at a fixed end of the space. However, after a major collection they have been copied to the middle of the space.
Reference: [Wil92a] <author> Paul Wilson, </author> <year> 1992. </year> <title> Private communication. </title>
Reference-contexts: This also requires being able to restart the instruction following the faulted instruction. One advantage of this is the interpreter can take advantage of extra information. For example, if the fault page is also mapped without protection elsewhere in the address space <ref> [AL91, Wil92a] </ref>, the interpreter can use that version to avoid needing to unprotect and reprotect the page. 2 On delayed branch architectures, a nop is written after the branch. 60 4. Fault Interpretation for Implementing the GC Remembered Set 4.4.4 Parallelization The F I code is currently sequential.
Reference: [Wil92b] <author> Paul Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Proc. International Workshop on Memory Management. Spring-Verlag, 1992. Lecture Notes in Computer Science Number 637. </booktitle>
Reference-contexts: Cohen published a survey of early garbage collection techniques and algorithms [Coh81]. Wilson describes more recent techniques in uniprocessor garbage collection <ref> [Wil92b] </ref>. 2.2.6 Summary of Garbage Collection Issues Dynamically allocated memory is a critical element of modern programming practices. It is vital in graph algorithms, which constitute one of the most important abstractions in computer science. Managing dynamically allocated memory is nontrivial.
Reference: [YY91] <author> Masahiro Yasugi and Akinori Yonezawa. </author> <title> Towards user (application) language-level garbage collection in object-oriented concurrent languages. </title> <booktitle> In Proc. Work shop on GC in Object Oriented Systems at OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: A function may have more than one garbage collection routine because different variables are live at different points in the function. Clearly, this collector is very tightly coupled to the compiler. Yasugi and Yonezawa discuss user-level garbage collection for the concurrent object-oriented programming language ABCL/1 <ref> [YY91] </ref>. Their programming language is based on active objects, thus, the garbage collection requirements for this language are basically the same as for garbage collection of Actors [Dic92, KWN90]. 2.5.1 Baker's Algorithm Baker's algorithm predates 1981.
Reference: [Zor92] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <type> Technical Report CU-CS-573-92, </type> <institution> University of Colorado at Boulder, </institution> <year> 1992. </year>
Reference-contexts: Knuth's book predates the Quick Fit Segregated Free-list method. Dynamic allocation strategies are difficult to analyze analytically but easy to measure empirically. Weinstock compared allocation strategies in [Wei76] and Zorn compared them in <ref> [Zor92] </ref>. Historically, improving the efficiency of these techniques resulted in substantially faster LISP systems. 2.8.1 Sequential Fit Allocation Sequential Fit allocation is a family of allocation strategies that use the same data structure but differ in how they choose the block to satisfy a request.
References-found: 97

