URL: http://www.csl.sri.com/reports/postscript/amast95.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: dold@informatik.uni-ulm.de  
Title: Representing, Verifying and Applying Software Development Steps using the PVS System  
Author: Axel Dold 
Address: D-89069 Ulm, Germany  
Affiliation: Abt. Kunstliche Intelligenz, Universitat Ulm,  
Abstract: In this paper generic software development steps of different complexity are represented and verified using the (higher-order, strongly typed) specification and verification system PVS. The transformations considered in this paper include "large" powerful steps encoding general algorithmic paradigms as well as "smaller" transformations for the operationalization of a descriptive specification. The application of these transformation patterns is illustrated by means of simple examples. Furthermore, we show how to guide proofs of correctness assertions about development steps. Finally, this work serves as a case-study and test for the usefulness of the PVS system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Dold. </author> <title> Formalisierung schematischer Algorithmen. </title> <type> Technical Report UIB-94-10, </type> <institution> Fakultat fur Informatik, Universitat Ulm, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The method described in this paper can readily be used to represent other development steps of both kinds as we have demonstrated within the BMFT project KORSO (correct software). In another paper, for example, we have formalized the theory of global-search algorithms using a type-theoretic framework <ref> [1] </ref>. This framework in which all entities of the software development process can be formally represented and reasoned about has also been developed within this project. We refer to [15] for more information about the framework and the project.
Reference: 2. <author> The CIP Language Group. </author> <title> The Munich Project CIP, Volume I: The Wide Spectrum Language CIP-L. </title> <publisher> LNCS 183. Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: However, his approach is only semi-formal, some important aspects remain informal. The transformations developed in the CIP-project and its descendants <ref> [2, 3, 10] </ref> can be considered as "smaller" development steps since they mainly operate on the level of functions. Among them one can find transformations for optimizing functions, recursion simplification, and as well, steps which operationalize a descriptive specification. <p> correct.2.3 respectively, just substitute proj 2 for proj 1 in for mula f1g. correct.2.1 : [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- O (proj_1 (decompose (x!1)), f_dc (proj_1 (decompose (x!1)))) <ref> [2] </ref> primitive?(x!1) [3] O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) correct.2.3 (TCC): [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- I (proj_2 (decompose (x!1))) [2] primitive?(x!1) [3] <p> (decompose (x!1)))) <ref> [2] </ref> primitive?(x!1) [3] O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) correct.2.3 (TCC): [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- I (proj_2 (decompose (x!1))) [2] primitive?(x!1) [3] O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) Consider the first subgoal correct.2.1. Automatically instantiation of the term proj 1 (decompose (x!1)) for y and applying assumptions ax1 and ax4 completes the proof.
Reference: 3. <author> The CIP System Group. </author> <title> The Munich Project CIP Volume II: The Program Transformation System CIP-S. </title> <publisher> LNCS 292. Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: However, his approach is only semi-formal, some important aspects remain informal. The transformations developed in the CIP-project and its descendants <ref> [2, 3, 10] </ref> can be considered as "smaller" development steps since they mainly operate on the level of functions. Among them one can find transformations for optimizing functions, recursion simplification, and as well, steps which operationalize a descriptive specification. <p> just substitute proj 2 for proj 1 in for mula f1g. correct.2.1 : [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- O (proj_1 (decompose (x!1)), f_dc (proj_1 (decompose (x!1)))) [2] primitive?(x!1) <ref> [3] </ref> O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) correct.2.3 (TCC): [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- I (proj_2 (decompose (x!1))) [2] primitive?(x!1) [3] O (x!1, <p> [2] primitive?(x!1) <ref> [3] </ref> O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) correct.2.3 (TCC): [-1] (FORALL (y: D): lt (y) &lt;= lt (x!1) AND lt (y) /= lt (x!1) IMPLIES I (y) IMPLIES O (y, f_dc (y))) [-2] I (x!1) -1- I (proj_2 (decompose (x!1))) [2] primitive?(x!1) [3] O (x!1, compose (x!1, f_dc (proj_1 (decompose (x!1))), f_dc (proj_2 (decompose (x!1))))) Consider the first subgoal correct.2.1. Automatically instantiation of the term proj 1 (decompose (x!1)) for y and applying assumptions ax1 and ax4 completes the proof.
Reference: 4. <author> G. Huet and B. Lang. </author> <title> Proving and Applying Program Transformations Expressed with Second-Order-Patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: The operationalization of a descriptive specification is presented in Sect. 3 and is applied to the problem of finding a minimum element in a list. Related Work The formalization of transformations using higher-order functions has been considered by several researchers. In <ref> [4] </ref>, for example, program transformations for recursion removal are expressed as second-order patterns defined in the simply typed -calculus.
Reference: 5. <author> C. </author> <title> Kreitz. Metasynthesis Deriving Programs that Develop Programs. </title> <type> Technical Report AIDA-93-03, </type> <institution> Fachgebiet Intellektik, Technische Hochschule Darmstadt, </institution> <year> 1993. </year>
Reference-contexts: Similar work dealing with the representation of existing approaches to program synthesis, development steps, and programming paradigms as well as a library of standard theories in the context of the Nuprl system has been carried out by Christoph Kreitz <ref> [5] </ref>. 2 Divide-and-Conquer The well-known algorithmic paradigm divide-and-conquer is based on the principle of solving primitive problem instances directly, and large problem instances by decomposing them into `smaller' instances, solving them independently and composing the resulting solutions. Here, we consider the decomposition of the problem into two subproblems.
Reference: 6. <author> Z. Luo and R. Pollack. </author> <title> LEGO Proof Development System: User's Manual. </title> <institution> University of Edinburgh, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Independently from the work described herein, my colleague Harald Rue has formalized, among other things, the divide-and-conquer paradigm in his dissertation [11] using the calculus of constructions and has given a verification with the LEGO proof checker <ref> [6] </ref>.
Reference: 7. <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A Prototype Verification System. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In order to represent software development steps higher-order logic greatly facilitates the formalization process. Therefore, and in order to have adequate system support we choose the specification and verification system PVS <ref> [7] </ref> in which the whole process of representation and verification can be carried out.
Reference: 8. <author> S. Owre, N. Shankar, and J.M. Rushby. </author> <title> The PVS Proof Checker: A Reference Manual. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Specifications are realized as PVS theories which can be parameterized where the parameters can be constrained by means of assumptions. Detailed information about the language, prover and the usage of the system can be found in <ref> [8, 9] </ref>. A distinctive feature of the typing system is the automatic generation of proof obligations, especially when instantiating the general scheme with a specific problem.
Reference: 9. <author> S. Owre, N. Shankar, and J.M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Specifications are realized as PVS theories which can be parameterized where the parameters can be constrained by means of assumptions. Detailed information about the language, prover and the usage of the system can be found in <ref> [8, 9] </ref>. A distinctive feature of the typing system is the automatic generation of proof obligations, especially when instantiating the general scheme with a specific problem.
Reference: 10. <author> H.A. Partsch. </author> <title> Specification and Transformation of Programs. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: However, his approach is only semi-formal, some important aspects remain informal. The transformations developed in the CIP-project and its descendants <ref> [2, 3, 10] </ref> can be considered as "smaller" development steps since they mainly operate on the level of functions. Among them one can find transformations for optimizing functions, recursion simplification, and as well, steps which operationalize a descriptive specification. <p> Finally, having discharged all TCC's we obtain a correct solution using the instantiated algorithm f dc. 3 Operationalization of a Descriptive Specification In this section we represent a transformation called operationalization of a choice given in <ref> [10] </ref>. We closely follow the method described in the previous section in representing this step. However, we give another possibility to establish the correctness of such a formalization.
Reference: 11. <author> H. Rue. </author> <title> Metaprogrammierung in einer typtheoretischen Umgebung. </title> <type> PhD thesis, </type> <institution> Universitat Ulm, Abt. </institution> <note> KI, to appear in 1995. </note>
Reference-contexts: In [4], for example, program transformations for recursion removal are expressed as second-order patterns defined in the simply typed -calculus. Independently from the work described herein, my colleague Harald Rue has formalized, among other things, the divide-and-conquer paradigm in his dissertation <ref> [11] </ref> using the calculus of constructions and has given a verification with the LEGO proof checker [6].
Reference: 12. <author> Douglas R. Smith. </author> <title> Applications of a Strategy for Designing Divide-and-Conquer-Algorithms. </title> <booktitle> Science of Computer Programming, </booktitle> (8):213-229, 1987. 
Reference-contexts: Part of the research reported herein has been funded by the German Federal Ministry of Research and Technology (BMFT) under contract no. 01 IS 203 K5 (KORSO). specific problem, synthesize a solution to this problem. These "algorithm theo-ries" have intensively been investigated by Doug Smith <ref> [12, 13, 14] </ref> who defines, among other things, a hierarchy of algorithm theories encoding well-known programming paradigms such as divide-and-conquer, global search, generate-and-test and others. However, his approach is only semi-formal, some important aspects remain informal.
Reference: 13. <author> Douglas R. Smith. </author> <title> Structure and Design of Global Search Algorithms. </title> <type> Technical Report KES.U.87.12, </type> <institution> Kestrel Institute, </institution> <address> Palo Alto, CA, </address> <year> 1987. </year>
Reference-contexts: Part of the research reported herein has been funded by the German Federal Ministry of Research and Technology (BMFT) under contract no. 01 IS 203 K5 (KORSO). specific problem, synthesize a solution to this problem. These "algorithm theo-ries" have intensively been investigated by Doug Smith <ref> [12, 13, 14] </ref> who defines, among other things, a hierarchy of algorithm theories encoding well-known programming paradigms such as divide-and-conquer, global search, generate-and-test and others. However, his approach is only semi-formal, some important aspects remain informal.
Reference: 14. <author> Douglas R. Smith and Michael R. Lowry. </author> <title> Algorithm Theories and Design Tactics. </title> <booktitle> Science of Computer Programming, </booktitle> (14):305-321, 1990. 
Reference-contexts: Part of the research reported herein has been funded by the German Federal Ministry of Research and Technology (BMFT) under contract no. 01 IS 203 K5 (KORSO). specific problem, synthesize a solution to this problem. These "algorithm theo-ries" have intensively been investigated by Doug Smith <ref> [12, 13, 14] </ref> who defines, among other things, a hierarchy of algorithm theories encoding well-known programming paradigms such as divide-and-conquer, global search, generate-and-test and others. However, his approach is only semi-formal, some important aspects remain informal. <p> There are of course some aspects which can be improved in future versions of PVS. For example, when representing hierarchies of software development steps following the ideas of Smith <ref> [14] </ref> it is desirable to define theories which have other theories as their parameters. This is not possible in the current version. Furthermore, it is not possible to express properties about theories such as refinements between theories (theory morphisms). PVS does not allow types as parameters or results of functions.
Reference: 15. <author> F.W. von Henke, A. Dold, H. Rue, D. Schwier, and M. Strecker. </author> <title> Construction and Deduction Methods for the Formal Development of Software. </title> <editor> In M. Broy and S. Jahnichen, editors, KORSO, </editor> <title> Correct Software by Formal Methods. </title> <note> Springer-Verlag, Lecture Notes in Computer Science, to appear in 1995, also available as Technical Report UIB-94-09, </note> <institution> Fakultat fur Informatik, Universitat Ulm. </institution>
Reference-contexts: In another paper, for example, we have formalized the theory of global-search algorithms using a type-theoretic framework [1]. This framework in which all entities of the software development process can be formally represented and reasoned about has also been developed within this project. We refer to <ref> [15] </ref> for more information about the framework and the project. Furthermore, we have shown how to synthesize a specific algorithm for some given problem simply by "filling the holes" of a general scheme.
References-found: 15

