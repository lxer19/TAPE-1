URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1997/GIT-CC-97-02.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.97.html
Root-URL: 
Email: -jdixon,calvert-@cc.gatech.edu  
Title: Effective Search Strategies for Application-Independent Speedup in  
Author: UDP Demultiplexing Joseph T. Dixon and Kenneth L. Calvert 
Address: Atlanta, GA 30332-0280  
Affiliation: Networking and Telecommunications Group College of Computing Georgia Institute of Technology  
Pubnum: GIT-CC-97-02  
Abstract: We present UDP datagram demultiplexing techniques that can yield potentially substantial application-independent performance gains over BSD-derived UDP implementations. Our demultiplexing strategies exploit local host and UDP implementation features - (1) how UDP processes connection-less datagrams, (2) local host application as client or server, and (3) local host application density - resulting in straightforward hash-based search strategies that caused demultiplexing speedups as high as 24-to-1 over BSDs one-behind cache. Furthermore, while past researchers have shown that cache-based schemes yield little performance benefit for UDP, we show that cache-based implementations can actually degrade demultiplexing performance. Finally, we recommend simple, non-protocol altering local host modifications for existing and future UDP implementations. We used four server traffic traces and eight algorithms in our tracedriven simulations, and executed more than 60 simulations to obtain our results. 
Abstract-found: 1
Intro-found: 1
Reference: [Chan&Varg95] <author> Girish P. Chandranmenon and George Varghese, </author> <title> Trading packet Headers for Packet Processing, </title> <type> SIGCOMM 95, </type> <year> 1995. </year>
Reference-contexts: Conclusions Recent proposals (including our own past work) have focused almost exclusively on TCP demultiplexing speed up. Such approaches include passing 32-bit pcb identification parameters as a TCP connect-time option [Huitema95]; source hashing , which allows direct access to various information associated with general packet processing <ref> [Chan&Varg95] </ref>; Mentat, Inc.s streams-implemented TCP/IP, which demultiplexes incoming packets in IP rather than TCP or UDP [Mentat93]; and our own multiple hash chain recommendations [Dix&Cal96].
Reference: [Clark89] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen, </author> <title> An Analysis of TCP Processing Overhead, </title> <journal> IEEE Communications Magazine, </journal> <month> June, </month> <year> 1989. </year>
Reference-contexts: 1. Introduction 1.1 Background The recent Internet explosion has placed greater demand on TCP/IPs performance. As a result, several works have presented implementations that can yield significant TCP/IP performance gains over BSD-derived implementations. <ref> [Clark89, Part&Pink93, Dix&Cal96] </ref> A common strategy is to speed up specific processing steps that are potential performance bottlenecks. In this paper, we show how unicast datagram demultiplexing - the successful delivery of a datagram to its intended communication endpoint/process - can be improved so that overall packet processing improves. <p> While arriving UDP packets can be unicast, broadcast, or multicast, we focus on unicast packet demultiplexing because broadcast and multicast UDP packets always require an exhaustive list search: a packets payload must be delivered to all matching pcbs. 1.4 Previous Work Several researchers have investigated TCP demultiplexing efficiency. <ref> [Clark89, McK&Dove92, Dix&Cal96, GIT-CC-96-08] </ref> Fewer, however, have addressed UDP demultiplexing: Mogul, who investigated persistence and temporal locality at the process level, showed traffic traces in which half of all datagrams received are replies to the last datagram that was sent.
Reference: [Com&Stev91] <author> Douglas E. Comer and David L. Stevens, </author> <title> Internetworking with TCP/IP Volume II: Design, Implementation, and Internals, </title> <publisher> Prentice Hall, Inc., </publisher> <year> 1991. </year>
Reference: [Dix&Cal96] <author> Joseph T. Dixon and Kenneth L. Calvert, </author> <title> Increasing Demultiplexing Efficiency in TCP/IP Network Servers, </title> <booktitle> International Conference on Computer Communications and Networks, </booktitle> <month> October, </month> <year> 1996. </year>
Reference-contexts: 1. Introduction 1.1 Background The recent Internet explosion has placed greater demand on TCP/IPs performance. As a result, several works have presented implementations that can yield significant TCP/IP performance gains over BSD-derived implementations. <ref> [Clark89, Part&Pink93, Dix&Cal96] </ref> A common strategy is to speed up specific processing steps that are potential performance bottlenecks. In this paper, we show how unicast datagram demultiplexing - the successful delivery of a datagram to its intended communication endpoint/process - can be improved so that overall packet processing improves. <p> In an earlier paper, we asserted that TCP and UDP packet demultiplexing may warrant separate solutions. <ref> [Dix&Cal96] </ref> In this paper, we investigate UDP to determine more precise features of effective pcb search strategies. <p> While arriving UDP packets can be unicast, broadcast, or multicast, we focus on unicast packet demultiplexing because broadcast and multicast UDP packets always require an exhaustive list search: a packets payload must be delivered to all matching pcbs. 1.4 Previous Work Several researchers have investigated TCP demultiplexing efficiency. <ref> [Clark89, McK&Dove92, Dix&Cal96, GIT-CC-96-08] </ref> Fewer, however, have addressed UDP demultiplexing: Mogul, who investigated persistence and temporal locality at the process level, showed traffic traces in which half of all datagrams received are replies to the last datagram that was sent. <p> passing 32-bit pcb identification parameters as a TCP connect-time option [Huitema95]; source hashing , which allows direct access to various information associated with general packet processing [Chan&Varg95]; Mentat, Inc.s streams-implemented TCP/IP, which demultiplexes incoming packets in IP rather than TCP or UDP [Mentat93]; and our own multiple hash chain recommendations <ref> [Dix&Cal96] </ref>. We know of little else done recently to address UDP demultiplexing efficiency since Partridge and Pinks effort. [Part&Pink93] In this work, we turned our attention to UDP demultiplexing.
Reference: [GIT-CC-96-08] <author> Joseph T. Dixon and Kenneth L. Calvert, </author> <title> Increasing Demultiplexing Efficiency in TCP/IP Network Servers, </title> <type> Technical Report #: GIT-CC-96-08, </type> <institution> Georgia Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: While arriving UDP packets can be unicast, broadcast, or multicast, we focus on unicast packet demultiplexing because broadcast and multicast UDP packets always require an exhaustive list search: a packets payload must be delivered to all matching pcbs. 1.4 Previous Work Several researchers have investigated TCP demultiplexing efficiency. <ref> [Clark89, McK&Dove92, Dix&Cal96, GIT-CC-96-08] </ref> Fewer, however, have addressed UDP demultiplexing: Mogul, who investigated persistence and temporal locality at the process level, showed traffic traces in which half of all datagrams received are replies to the last datagram that was sent. <p> f_cache [ R ]; If !(cache hit) inp = in_pcblookup (f_chain [ R ], ...); If (inp == NULL) inp = in_pcblookup (w_chain [ R ], ...);-else f_cache [ R ] = inp; Return inp as the destination PCB; Our multiple hash chain algorithm is consistent with our TCP recommendations <ref> [GIT-CC-96-08] </ref>; We only use 64 hash chains for each store. (We showed that additional performance speedup may not justify system resource costs when more than 64 hash chains are used.) We use a straightforward and efficient hash chain function. Hash is merely the destination/local hosts service port modulo-64 .
Reference: [Huitema95] <author> Christian Huitema, </author> <type> Multi-homed TCP - IETF Draft, </type> <institution> Network Working Group, </institution> <month> May, </month> <year> 1995. </year> <note> This is a work in progress. </note>
Reference-contexts: Conclusions Recent proposals (including our own past work) have focused almost exclusively on TCP demultiplexing speed up. Such approaches include passing 32-bit pcb identification parameters as a TCP connect-time option <ref> [Huitema95] </ref>; source hashing , which allows direct access to various information associated with general packet processing [Chan&Varg95]; Mentat, Inc.s streams-implemented TCP/IP, which demultiplexes incoming packets in IP rather than TCP or UDP [Mentat93]; and our own multiple hash chain recommendations [Dix&Cal96].
Reference: [Hen&Pat96] <author> Hohn L. Hennessy and David A. Patterson, </author> <title> Computer Architecture - A Quantitative Approach 2nd Edition, </title> <publisher> Morgan Kaufman Publishers, </publisher> <year> 1996. </year>
Reference-contexts: Imbed the code to compute instruction counts for each lookup (from step 3) in the C program. We also report UDP demultiplexing speedup for each algorithm relative to the original in_pcblookup using the simple ratio <ref> [Hen&Pat96] </ref>: Speedup Avg InstructionCost LinearSearch Avg InstructionCost NewAlgorithm = ( ) 2.4 Assumptions We made several assumptions so our simulation results would be as realistic as possible. (Some were also necessary to overcome packet traces limitations.) All arriving packets will be delivered to a valid pcb.
Reference: [McK&Dove92] <author> Paul E. McKenney and Ken F. Dove, </author> <title> Efficient Demultiplexing of Incoming TCP Packets, </title> <booktitle> ACM SIGCOMM 92, </booktitle> <month> August, </month> <year> 1992. </year>
Reference-contexts: While arriving UDP packets can be unicast, broadcast, or multicast, we focus on unicast packet demultiplexing because broadcast and multicast UDP packets always require an exhaustive list search: a packets payload must be delivered to all matching pcbs. 1.4 Previous Work Several researchers have investigated TCP demultiplexing efficiency. <ref> [Clark89, McK&Dove92, Dix&Cal96, GIT-CC-96-08] </ref> Fewer, however, have addressed UDP demultiplexing: Mogul, who investigated persistence and temporal locality at the process level, showed traffic traces in which half of all datagrams received are replies to the last datagram that was sent.
Reference: [Mentat93] <institution> Mentat TCP/IP Design Overview (extracted from Mentat TCP/IP Internals Manual), Mentat, Inc., </institution> <address> Los Angeles, CA., </address> <month> July, </month> <year> 1993. </year>
Reference-contexts: Such approaches include passing 32-bit pcb identification parameters as a TCP connect-time option [Huitema95]; source hashing , which allows direct access to various information associated with general packet processing [Chan&Varg95]; Mentat, Inc.s streams-implemented TCP/IP, which demultiplexes incoming packets in IP rather than TCP or UDP <ref> [Mentat93] </ref>; and our own multiple hash chain recommendations [Dix&Cal96]. We know of little else done recently to address UDP demultiplexing efficiency since Partridge and Pinks effort. [Part&Pink93] In this work, we turned our attention to UDP demultiplexing.
Reference: [Mogul92] <author> Jeffrey C. Mogul, </author> <title> Network Locality at the Scale of Processes, </title> <journal> ACM Transactions on Computer Systems, </journal> <month> May, </month> <year> 1992. </year>
Reference: [Part&Pink93] <author> Craig Partridge and Stephen Pink, </author> <title> A Faster UDP, </title> <journal> IEEE/ACM Transactions on Networking, </journal> <month> August, </month> <year> 1993. </year>
Reference-contexts: 1. Introduction 1.1 Background The recent Internet explosion has placed greater demand on TCP/IPs performance. As a result, several works have presented implementations that can yield significant TCP/IP performance gains over BSD-derived implementations. <ref> [Clark89, Part&Pink93, Dix&Cal96] </ref> A common strategy is to speed up specific processing steps that are potential performance bottlenecks. In this paper, we show how unicast datagram demultiplexing - the successful delivery of a datagram to its intended communication endpoint/process - can be improved so that overall packet processing improves. <p> While informal, this approach puts demultiplexing speedup in the overall packet processing context. Partridge and Pink showed that the checksum calculation ( in_cksum in Net/3) accounted for 8.4% of total IP and UDP packet processing time for a 512-byte UDP datagram. <ref> [Part&Pink93] </ref> This includes four in_cksum invocations (for the IP header and the entire datagram on send and receive.) Our experiments show that, when optimally compiled on a SPARC architecture, the four in_cksum invocations require 1680 assembly language instructions to process a 512-byte UDP datagram. 5 Therefore, if we assume: the fraction <p> We know of little else done recently to address UDP demultiplexing efficiency since Partridge and Pinks effort. <ref> [Part&Pink93] </ref> In this work, we turned our attention to UDP demultiplexing. We corroborated past findings when we 5 A single 20-byte IP header checksum calculation required 87 instructions while the 512-byte UDP datagram checksum required 753 instructions.
Reference: [Stevens90] <author> W. Richard Stevens, </author> <title> UNIX Network Programming, </title> <publisher> Prentice Hall, Inc., </publisher> <year> 1990. </year>
Reference: [Wri&Stev95] <author> Gary R. Wright and W. Richard Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 2: The Implementation, </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: associated user process. (We assume that all other typical UDP/IP datagram processing also takes place.) 1.2 BSDs PCB and UDP Implementations BSD-derived UDP implementations use protocol control blocks (pcbs) as communication endpoints and manage the pcbs using a circular linked list store combined with a one-behind cached pcb pointer. 2 <ref> [Wri&Stev95] </ref> Traditionally, in_pcblookup is the kernel function that performs the pcb list search. <p> In practice, UDP clients that utilize an actual connection (via connect ) are optional; such UDP server implementations are rare. <ref> [Wri&Stev95] </ref> 3 Partridge and Pink observed that the one-behind cache yielded little performance benefit for UDP. <p> Figure 8 shows the primary Net/3 function calls that make up total packet processing, given an Ethernet NIC. <ref> [Wri&Stev95] </ref> Many function calls are not shown; they do not represent major processing steps. Datagram (Data Link) (Network) (Transport) (Application) *inetsw [].pr_input ipintr schednetisr ether_input leread leintr in_pcblookup udp_input = ipintrq: sbappendaddr sowakeup so_recv soreceive uiomove recvfrom, etc. USER KERNEL (Physical) datagram to its destination pcb.
References-found: 13

