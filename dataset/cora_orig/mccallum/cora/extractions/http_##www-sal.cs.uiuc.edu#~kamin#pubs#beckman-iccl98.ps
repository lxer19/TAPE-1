URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/beckman-iccl98.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: fbeckman,kaming@cs.uiuc.edu  
Title: Controlled Self-Applicable On-Line Partial Evaluation, Using Strategies  
Author: Mattox Beckman Sam Kamin 
Keyword: Partial evaluation, on-line partial evaluation, lambda calculus  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois  
Abstract: On-line partial evaluators are hardly ever self-applicable, because the complexity of deciding whether to residualize terms causes combinatorial explosion when self-application is attempted. Recently, T. Mogensen found a way to write a self-applicable online partial evaluator for -calculus. His method is to regard every -term as having both static and dynamic aspects; then, applications can always be done statically (using the static aspect of the operator). However, the absence of decision-making about residual-ization has a down side: his partial evaluator knows only how to fully reduce partially evaluated terms. The result is considerable code explosion. We show how this problem can be overcome, in part, by changing the type of the partial evaluator, and giving a new version of the Futamura projections to correspond to that new type. Specifically, we have the partial evaluator take a third argument, called a strategy, which "advises" the partial evaluator whether to residualize. Strategies allow the programmer to control the tradeoff between the size of a specialized term and the cost of subsequently applying it. We present a number of strategies and examples of each. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Grant, M. Mock, M. Philipose, C. Chambers, S. Eggers, </author> <title> Annotation-Directed Run-Time Specialization in C, </title> <booktitle> Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM), </booktitle> <address> June 1997. Amster-dam, Netherlands. </address>
Reference-contexts: Strategies are a kind of program annotation directing the actions of the partial evaluator. The use of such annotations is far from new | indeed, the earliest self-applicable partial evaluators required explicit static/dynamic annotations [2]. More sophisticated annotations for practical partial evaluation have been studied by several researchers <ref> [1, 6, 7] </ref>, particularly in the context of on-line partial evaluation. The contribution of this paper is not in the particular strategies we present | indeed, our strategies are rather weak, being constrained by the higher-order abstract syntax representation of terms.
Reference: [2] <author> Neil D. Jones, Peter Sestoft, and Ha rald Stndergaard. </author> <title> Mix: A self-applicable partial evaluator for experiments in compiler generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year> <type> DIKU Report 91/12. </type>
Reference-contexts: However, we have a variety of strategies that give interesting results. Strategies are a kind of program annotation directing the actions of the partial evaluator. The use of such annotations is far from new | indeed, the earliest self-applicable partial evaluators required explicit static/dynamic annotations <ref> [2] </ref>. More sophisticated annotations for practical partial evaluation have been studied by several researchers [1, 6, 7], particularly in the context of on-line partial evaluation. <p> To again compare our results to Mogensen's directly, if we denote P [Ack] <ref> [2] </ref> none by Ack 2;none , we see in Table 2 that Ack 2;none 3 reduces to 9 after 76 fi-reductions, compared to the 65 for Ack 2;all . Of course, it takes fewer fi-reductions to calculate Ack 2;none and, perhaps more importantly, Ack 2;none is smaller. <p> Expression Size fi Ack 2 3 ! 9 21 76 P [Ack] <ref> [2] </ref> 0 ! Ack 2;0 35 492 P [Ack] [2] 4 ! Ack 2;4 35 523 Ack 2;0 3 ! 9 21 76 1:0 Ack 2;4 3 ! 9 21 73 1:041 Ack 2;all 3 ! 9 21 65 1:169 P [P ] [[Ack]] 8 ! Ack gen;8 339 4746 P <p> Expression Size fi Ack 2 3 ! 9 21 76 P [Ack] <ref> [2] </ref> 0 ! Ack 2;0 35 492 P [Ack] [2] 4 ! Ack 2;4 35 523 Ack 2;0 3 ! 9 21 76 1:0 Ack 2;4 3 ! 9 21 73 1:041 Ack 2;all 3 ! 9 21 65 1:169 P [P ] [[Ack]] 8 ! Ack gen;8 339 4746 P [P ] [[Ack]] 96 ! Ack gen;96 3848 51104 <p> Ack 2;4 35 523 Ack 2;0 3 ! 9 21 76 1:0 Ack 2;4 3 ! 9 21 73 1:041 Ack 2;all 3 ! 9 21 65 1:169 P [P ] [[Ack]] 8 ! Ack gen;8 339 4746 P [P ] [[Ack]] 96 ! Ack gen;96 3848 51104 Ack gen;0 <ref> [2] </ref> ! Ack 2 52 758 0:981 Ack gen;64 [2] ! Ack 2 52 621 1:198 Ack gen;all [2] ! Ack 2 52 510 1:459 P [P ] [[P ]] 50 ! P gen 50 47672 643247 P [P ] [[P ]] all ! P gen all ? ? P gen <p> 21 76 1:0 Ack 2;4 3 ! 9 21 73 1:041 Ack 2;all 3 ! 9 21 65 1:169 P [P ] [[Ack]] 8 ! Ack gen;8 339 4746 P [P ] [[Ack]] 96 ! Ack gen;96 3848 51104 Ack gen;0 <ref> [2] </ref> ! Ack 2 52 758 0:981 Ack gen;64 [2] ! Ack 2 52 621 1:198 Ack gen;all [2] ! Ack 2 52 510 1:459 P [P ] [[P ]] 50 ! P gen 50 47672 643247 P [P ] [[P ]] all ! P gen all ? ? P gen 50 [[Ack]] all ! Ack gen;all 3842 51992 0:982 <p> 73 1:041 Ack 2;all 3 ! 9 21 65 1:169 P [P ] [[Ack]] 8 ! Ack gen;8 339 4746 P [P ] [[Ack]] 96 ! Ack gen;96 3848 51104 Ack gen;0 <ref> [2] </ref> ! Ack 2 52 758 0:981 Ack gen;64 [2] ! Ack 2 52 621 1:198 Ack gen;all [2] ! Ack 2 52 510 1:459 P [P ] [[P ]] 50 ! P gen 50 47672 643247 P [P ] [[P ]] all ! P gen all ? ? P gen 50 [[Ack]] all ! Ack gen;all 3842 51992 0:982 P [mP ] [[mP ]] all ! mP gen;all
Reference: [3] <author> Neil D. Jones, Carsten K. Gomard, and Peter Ses-toft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall International Series in Computer Science. </publisher> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: For our final change of representations, we add an annotation field to abstractions. For this example the annotation will be a boolean value which expresses whether or not we want to perform a fi-reduction if given the opportunity. Annotations of this type are discussed in chapter 7 of <ref> [3] </ref>.
Reference: [4] <author> Torben . Mogensen. </author> <title> Self-applicable online partial evaluation of the pure lambda calculus. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> La Jolla, California, </address> <month> June </month> <year> 1995, </year> <pages> pages 39-44. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1995. </year>
Reference-contexts: On-line partial evaluators contain explicit tests for staticness, and these tests tend to cause combinatorial explosion when the partial evaluator is self-applied.[3, 6] fl Partially supported by NASA grant NAG-1-613 y Partially supported by NSF grant CCR 93-03043 Recently, Mogensen <ref> [4] </ref> found an ingenious solution for creating a self-applicable on-line partial evaluator for -calculus. The idea is to interpret every -expression as a pair of values: an equivalent - expression and a function, essentially representing the application of that -expression by fi-reduction. <p> The standard Futamura projections for the - calculus <ref> [4] </ref> are in Figure 1 1 . The modified projections are in Figure 2. Though they look nearly identical, there is a big difference: With the standard version, the partial evaluator, P , is responsible for making all static-vs.-dynamic application decisions. <p> Rather, it is the way our strategies are incorporated into the partial evaluator so as not to interfere with self-application. In the next section, we review Mogensen's results from <ref> [4] </ref>. We then present the idea of strategies, and our strategy-based partial evaluator in section 3. In section 4, we discuss self-application of our partial evaluator. In section 5, we change the representation of -expressions slightly, in a way that permits the definition of more strategies. <p> 693 8095 Ack gen d0e ! dAck 0 e 10 56 2.1 Ack gen d1e ! dAck 1 e 24 94 2.7 Ack gen d2e ! dAck 2 e 52 180 2.8 P dP e ddP ee ! dP gen e 17819 268481 Table 1: Excerpt from Table 2 of <ref> [4] </ref> We provide this control by giving the partial evaluator a third argument, called a strategy. The strategy tells the partial evaluator what to do when one P EV is applied to another.
Reference: [5] <author> Frank Pfenning and Conal Elliott. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the ACM SIG-PLAN '88 Symposium on Language Design and Implementation, </booktitle> <pages> pages 199-208, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This contrasts with the usual approach in which Abs takes as arguments a variable and an AST and returns an AST. The difference is just the difference between the higher-order abstract syntax used here and the first-order abstract syntax usually used <ref> [5] </ref>. -expressions are translated to P EV 's by the following rules.
Reference: [6] <author> Eric Ruf. </author> <title> Topics in Online Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Stanford University, California, </institution> <note> Febru-ary 1993. Published as technical report CSL-TR-93-563. </note>
Reference-contexts: Strategies are a kind of program annotation directing the actions of the partial evaluator. The use of such annotations is far from new | indeed, the earliest self-applicable partial evaluators required explicit static/dynamic annotations [2]. More sophisticated annotations for practical partial evaluation have been studied by several researchers <ref> [1, 6, 7] </ref>, particularly in the context of on-line partial evaluation. The contribution of this paper is not in the particular strategies we present | indeed, our strategies are rather weak, being constrained by the higher-order abstract syntax representation of terms.
Reference: [7] <author> E. Volanschi, C. Consel, G. Muller, C. Cowan, </author> <title> Declarative specialization of objet-oriented programs. </title> <booktitle> OOPSLA '97, </booktitle> <address> Atlanta, </address> <month> Oct. </month> <year> 1997, </year> <pages> pp. 286-300. </pages>
Reference-contexts: Strategies are a kind of program annotation directing the actions of the partial evaluator. The use of such annotations is far from new | indeed, the earliest self-applicable partial evaluators required explicit static/dynamic annotations [2]. More sophisticated annotations for practical partial evaluation have been studied by several researchers <ref> [1, 6, 7] </ref>, particularly in the context of on-line partial evaluation. The contribution of this paper is not in the particular strategies we present | indeed, our strategies are rather weak, being constrained by the higher-order abstract syntax representation of terms.
References-found: 7

