URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr95/tr95-013.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr95-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: The Performance of Holding Versus Releasing Locks in a Multiprogrammed Multiprocessor  
Author: Theodore Johnson Krishna Harathi 
Affiliation: Dept. of Computer and Information Science University of Florida  
Abstract: In a multiprogrammed multiprocessor system, existing lock based mechanisms hold the lock for a task during a context-switch. In this case, the time that a task holds a lock can be greatly increased, resulting in a wasted lock utilization and an increase in the average response time for tasks using the lock. An option for avoiding this problem is to release the lock held by a task during a context-switch. The lock is reacquired when the task executes in the next quantum. In this paper, we compare the performance of releasing versus holding a lock during a critical section. We discuss our implementation, the ICSM-R algorithm, as implemented on a multiprocessor system. Next, we develop an analytical performance model, and validate it with a simulation. We study the various parameters under which the ICSM-R algorithm outperforms lock-based algorithms. We find that if the critical section execution time is 50% or less of the time quantum, ICSM-R has better performance than locking alone, reducing response times and improving scalability.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. </author> <title> Alemany and E.W. Felten, Performance Issues in Non-Blocking Synchronization on Shared Memory Multiprocessors, </title> <booktitle> Proceedings of the 11th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Vancouver, BC, Canada, </address> <year> 1992, </year> <pages> pp. 125-134. </pages>
Reference-contexts: An approach that is related to the ICSM-R algorithm is the use of non-blocking algorithms. Ale-many and Felton <ref> [1] </ref> consider implementation issues of non-blocking concurrent objects on shared-memory multiprocessors. They show how the resources wasted by the non-blocking operations that fail and the cost of data copying required by a non-blocking implementation can be reduced by relying on the operating system support. <p> This protocol assigns an abort ceiling priority to the critical section instead. The contribution of this work is to make provide a detailed analytical performance model of both the lock holding and the lock releasing strategies. Some previous works have pointed out the benefit of a lock releasing strategy <ref> [3, 1] </ref>, but did not provide an analytical model. <p> The final write commits the updates that are recorded in the buffer by setting a commit flag. Any subsequent process that executes the ICS performs the updates and clears the commit flag. Related approaches to optimistic synchronization are discussed by Alemany and Felton <ref> [1] </ref> and by Bershad [4]. However, these protocols require that if context switch occurs while a task is executing a critical section, the operating system kernel must either complete the critical section execution or back out of the execution.
Reference: [2] <author> T. E. Anderson, E. D. Lazowska, and H. M. Levy, </author> <title> The Performance Implications of Thread Management Alternatives for Shared-Memory Multiprocessors, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 38. No. 12, </volume> <year> 1989, </year> <pages> pp. 1631-1644. </pages>
Reference-contexts: There has recently been a great deal of interest in the problem of handling critical sections in a multipro-grammed shared memory multiprocessor. Anderson et al. <ref> [2] </ref> show that a naive implementation of spin-locks can not only delay the processor waiting for a lock, but other processors doing work. They suggest an Ethernet-style backoff scheme or a queue-based algorithm for reducing the cost of spin-waiting.
Reference: [3] <author> T. E. Anderson and H. M. Levy, </author> <title> Scheduler Activations: Effective Kernel Support for the User Level Management of Parallelism, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 9, No. 1, </volume> <year> 1992, </year> <pages> pp. 53-79. </pages>
Reference-contexts: They suggest an Ethernet-style backoff scheme or a queue-based algorithm for reducing the cost of spin-waiting. McCann et al. [11] conclude that preempting processors in a coordinated way is critical to response times while using critical sections. Anderson et al. <ref> [3] </ref> argue that the operating system should recognize that a preempted thread is executing in a critical section, and execute the preempted thread until the thread exits the critical section. An approach that is related to the ICSM-R algorithm is the use of non-blocking algorithms. <p> This protocol assigns an abort ceiling priority to the critical section instead. The contribution of this work is to make provide a detailed analytical performance model of both the lock holding and the lock releasing strategies. Some previous works have pointed out the benefit of a lock releasing strategy <ref> [3, 1] </ref>, but did not provide an analytical model.
Reference: [4] <author> B. Bershad, </author> <title> Practical Considerations for Non-Blocking Concurrent Objects, </title> <booktitle> IEEE 13th International Conference on Distributed Computing Systems, </booktitle> <address> Pittsburgh, PA, USA, </address> <year> 1993, </year> <pages> pp. 264-273. </pages>
Reference-contexts: Ale-many and Felton [1] consider implementation issues of non-blocking concurrent objects on shared-memory multiprocessors. They show how the resources wasted by the non-blocking operations that fail and the cost of data copying required by a non-blocking implementation can be reduced by relying on the operating system support. Bershad <ref> [4] </ref> discusses two approaches for implementing kernel level support for non-blocking critical sections. Interest in pre-emptable locks has recently developed in the real time systems community. Takada and Sakamura [16] proposed algorithms that extend queuing spin-locks to be preempted for servicing interrupts. <p> The final write commits the updates that are recorded in the buffer by setting a commit flag. Any subsequent process that executes the ICS performs the updates and clears the commit flag. Related approaches to optimistic synchronization are discussed by Alemany and Felton [1] and by Bershad <ref> [4] </ref>. However, these protocols require that if context switch occurs while a task is executing a critical section, the operating system kernel must either complete the critical section execution or back out of the execution. Requiring the kernel to perform the execution on behalf of the task has many difficulties.
Reference: [5] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, USA, </address> <year> 1987. </year>
Reference-contexts: A task calculates its modifications to the shared data structure, then attempts to commit its modification. If a higher priority task previously committed a conflicting modification, the lower priority task fails to commit, and must try again (as in optimistic concurrency control <ref> [5] </ref>). Otherwise, the task succeeds, and continues in its work. In [7], the ICS algorithm is extended to the ICSM-R algorithm, which executes on multiprocessors. In an interruptible critical section, a process can perform only one write that is visible to other processes.
Reference: [6] <author> P. A. Fishwick, SIMPACK: </author> <title> Getting Started with Simulation Programming in C and C++, </title> <type> Technical Report Electronic TR92-022, </type> <institution> University of Florida, </institution> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Knowing R and B, Z can be computed, and hence the cycle time C I . 3.2.3 Validation of Analysis We validated the analysis by simulation using SIMPACK <ref> [6] </ref>, a discrete event simulation package. We set the values of M = 4, T w = 1000, and T q = 100. The work time T w is a random variable uniformly distributed between 800 and 1200 with a mean of 1000.
Reference: [7] <author> K. Harathi, </author> <title> Synchronization Algorithms for Real Time Systems, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of CIS, University of Florida, </institution> <year> 1995. </year>
Reference-contexts: If a higher priority task previously committed a conflicting modification, the lower priority task fails to commit, and must try again (as in optimistic concurrency control [5]). Otherwise, the task succeeds, and continues in its work. In <ref> [7] </ref>, the ICS algorithm is extended to the ICSM-R algorithm, which executes on multiprocessors. In an interruptible critical section, a process can perform only one write that is visible to other processes. Furthermore, the globally visible write must be the last instruction in the protected region. <p> Our discussion of how an ICSM-R is implemented is of necessity quite brief. We refer the interested reader to our other reports for a more detailed discussion <ref> [9, 7] </ref>. 4 3 ICSM-R Performance Analysis The ICSM-R protocol has the intuitively good property that a task does not hold a lock while it is idle due to a context switch.
Reference: [8] <author> M. Herlihy, </author> <title> A Methodology for Implementing Highly Concurrent Data Objects, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 5, </volume> <year> 1993, </year> <pages> pp. 745-770. </pages>
Reference: [9] <author> T. Johnson and K. Harathi, </author> <title> Interruptable Critical Sections, </title> <type> Technical Report TR94-007, </type> <institution> Dept. of CIS, University of Florida, </institution> <year> 1994. </year> <note> Available at ftp.cis.ufl.edu:cis/tech-reports/tr94/tr94.007.ps.Z. </note>
Reference-contexts: of lock holding and of lock releasing, and find that a lock releasing strategy is better than a lock holding strategy if the critical section execution time is 50% or less of a time quanta. 2 2 The ICSM-R Algorithm We introduced the idea of an Interruptible Critical Section (ICS) <ref> [9] </ref>, which is a critical section protected by optimistic concurrency control instead of by blocking. A task calculates its modifications to the shared data structure, then attempts to commit its modification. <p> Our discussion of how an ICSM-R is implemented is of necessity quite brief. We refer the interested reader to our other reports for a more detailed discussion <ref> [9, 7] </ref>. 4 3 ICSM-R Performance Analysis The ICSM-R protocol has the intuitively good property that a task does not hold a lock while it is idle due to a context switch.
Reference: [10] <author> L. Kleinrock, </author> <title> Queuing Systems, Volume 1: Theory, </title> <publisher> John Wiley & Sons, </publisher> <address> New York, NY, USA, </address> <year> 1975. </year>
Reference-contexts: a M/M/1 queue, the expected blocking time Z is given by Z = (1 R r ) where R r is the utilization of the rest of the N 1 tasks that use the critical section, given by R r = N 8 and B r is the residual life <ref> [10] </ref> of the lock holding time B for which the task under consideration is blocked.
Reference: [11] <author> C. McCann, R. Vaswani, and J. Zahorjan, </author> <title> A Dynamic Processor Allocation Policy for Multiprogrammed Shared-Memory Multiprocessors, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 11, No. 2, </volume> <year> 1993, </year> <pages> pp. 146-178. </pages>
Reference-contexts: Anderson et al. [2] show that a naive implementation of spin-locks can not only delay the processor waiting for a lock, but other processors doing work. They suggest an Ethernet-style backoff scheme or a queue-based algorithm for reducing the cost of spin-waiting. McCann et al. <ref> [11] </ref> conclude that preempting processors in a coordinated way is critical to response times while using critical sections. <p> The code to support ICSM-R is easy to implement, and we present our implementation results in the next section. Other authors suggest that all tasks in a program be scheduled for execution simultaneously <ref> [11] </ref>. However, synchronizing the simultaneous context switches can be difficult to implement, and does not account for context switches due to background tasks. We discuss the ICSM-R algorithm as implemented in a VMEexec [13] system development environment with a pSOS+ [12] real-time, multi-tasking operating system kernel.
Reference: [12] <author> Motorola Inc., </author> <title> psos+ Rteid-Compliant Real-Time Kernel User's Manual, </title> <address> Tempe, AZ, USA, </address> <year> 1990. </year>
Reference-contexts: However, synchronizing the simultaneous context switches can be difficult to implement, and does not account for context switches due to background tasks. We discuss the ICSM-R algorithm as implemented in a VMEexec [13] system development environment with a pSOS+ <ref> [12] </ref> real-time, multi-tasking operating system kernel. The VMEexec system consists of a host running on a VMEmodule driven SYSTEM V/68 operating system and a set of VMEmodule target processors running the pSOS+ kernel.
Reference: [13] <author> Motorola Inc., </author> <title> Vmeexec User's Guide, Second Edition, </title> <address> Tempe, AZ, USA, </address> <year> 1990. </year>
Reference-contexts: Other authors suggest that all tasks in a program be scheduled for execution simultaneously [11]. However, synchronizing the simultaneous context switches can be difficult to implement, and does not account for context switches due to background tasks. We discuss the ICSM-R algorithm as implemented in a VMEexec <ref> [13] </ref> system development environment with a pSOS+ [12] real-time, multi-tasking operating system kernel. The VMEexec system consists of a host running on a VMEmodule driven SYSTEM V/68 operating system and a set of VMEmodule target processors running the pSOS+ kernel.
Reference: [14] <author> R. Rajkumar, L. Sha and J. P. Lehoczky, </author> <title> Real-Time Synchronization Protocols for Multiprocessors, </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <address> Huntsville, Alabama, </address> <year> 1988, </year> <pages> pp. 259-269. </pages>
Reference-contexts: Takada and Sakamura [16] proposed algorithms that extend queuing spin-locks to be preempted for servicing interrupts. They address the conflicting issue of servicing a pending interrupt while holding a lock. Shu et al. [15] proposed an Abort Ceiling Protocol, an extension to the Priority Ceiling Protocol <ref> [14] </ref>. In this algorithm, an abort ceiling priority is associated with a task. Another task may abort the currently running task and run immediately if its priority is higher than the current abort ceiling.
Reference: [15] <author> LihChyun Shu, Michal Young, and Ragunathan Rajkumar, </author> <title> An Abort Ceiling Protocol for Controling Priority Inversion, </title> <booktitle> Proceedings of the First International Workshop on Real-Time Computing Systems and Applications, </booktitle> <address> Seoul, Korea, </address> <year> 1994, </year> <pages> pp. 202-206. </pages>
Reference-contexts: Interest in pre-emptable locks has recently developed in the real time systems community. Takada and Sakamura [16] proposed algorithms that extend queuing spin-locks to be preempted for servicing interrupts. They address the conflicting issue of servicing a pending interrupt while holding a lock. Shu et al. <ref> [15] </ref> proposed an Abort Ceiling Protocol, an extension to the Priority Ceiling Protocol [14]. In this algorithm, an abort ceiling priority is associated with a task. Another task may abort the currently running task and run immediately if its priority is higher than the current abort ceiling.
Reference: [16] <author> H. Takada, and K. Sakamura, </author> <title> Predictable Spin Lock Algorithms with Preemption, </title> <booktitle> Proceedings of the 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Los Alamitos, CA, USA, </address> <year> 1994, </year> <pages> pp. 2-6. </pages>
Reference-contexts: Bershad [4] discusses two approaches for implementing kernel level support for non-blocking critical sections. Interest in pre-emptable locks has recently developed in the real time systems community. Takada and Sakamura <ref> [16] </ref> proposed algorithms that extend queuing spin-locks to be preempted for servicing interrupts. They address the conflicting issue of servicing a pending interrupt while holding a lock. Shu et al. [15] proposed an Abort Ceiling Protocol, an extension to the Priority Ceiling Protocol [14].
Reference: [17] <author> H. Takada, and K. Sakamura, </author> <title> Real-Time Synchronization Protocols with Abortable Critical Sections, </title> <booktitle> Proceedings of the First International Workshop on Real-Time Computing Systems and Applications, </booktitle> <address> Seoul, Korea, </address> <year> 1994, </year> <pages> pp. 48-52. 16 17 18 19 20 </pages>
Reference-contexts: Another task may abort the currently running task and run immediately if its priority is higher than the current abort ceiling. The protocol relies on the Interruptible Critical Sections to restart the critical section of the aborted task. The Ceiling Abort Protocol <ref> [17] </ref> proposed by Takada and Sakamur is a similar extension to the Priority Ceiling Protocol. This protocol assigns an abort ceiling priority to the critical section instead.
References-found: 17

