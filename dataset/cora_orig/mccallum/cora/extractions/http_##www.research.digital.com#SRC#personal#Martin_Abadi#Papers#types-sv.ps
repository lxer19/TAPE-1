URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/types-sv.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  
Title: Secrecy by Typing in Security Protocols  
Author: Martin Abadi 
Affiliation: Digital Equipment Corporation Systems Research Center  
Abstract: We develop principles and rules for achieving secrecy properties in security protocols. Our approach is based on traditional classification techniques, and extends those techniques to handle concurrent processes that use shared-key cryptography. The rules have the form of typing rules for a basic concurrent language with cryptographic primitives, the spi calculus. They guarantee that, if a protocol typechecks, then it does not leak its secret inputs. 
Abstract-found: 1
Intro-found: 1
Reference: [AG97a] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <booktitle> In Proceedings of the Fourth ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 36-47, </pages> <year> 1997. </year>
Reference-contexts: The rules of this paper capture a sufficient set of simple precautions that permit this declassification. The rules have the form of typing rules for a basic concurrent language, the spi calculus <ref> [AG97a] </ref>; this calculus is an extension of the pi calculus [MPW92] with shared-key cryptographic primitives. The purpose of these rules is rather different from those of standard typing rules for related languages (such as those of Pierce and Sangiorgi [PS96]). <p> This model is fairly accurate and expressive, but does not take into account issues of key length, for example. The next section explains, informally, our approach for achieving secrecy. Section 3 is a review of the spi calculus. (The spi calculus presented is a generalization of that defined originally <ref> [AG97a] </ref>; it includes polyadic constructs [Mil91].) Section 4 provides the typing rules for the spi calculus, and Section 5 shows that these rules can be applied to prevent undesirable flows of information. Section 6 illustrates the use of the rules in examples. Finally, Section 7 discusses some conclusions. <p> 1 ; : : : ; x k g N in P shared-key decryption (k 0) (The name n and the variables x, y, x 1 , . . . , x k are bound in these processes.) Most of these constructs should be familiar from earlier process algebras; see <ref> [AG97a] </ref> for a review, and see below for an operational semantics. The infor mal semantics of some of the constructs is as follows. <p> It is not important to specify who receives this last message, which we include only in order to illustrate that B is allowed to react. We can express this protocol in the spi calculus, much as in the earlier work on the spi calculus <ref> [AG97a] </ref> but with attention to the requirements of typing.
Reference: [AG97b] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <type> Technical Report 414, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> January </month> <year> 1997. </year> <note> Extended version of both [AG97a] and [AG97c]. </note>
Reference-contexts: However, this novelty is not substantial, as in particular it does not affect the expressiveness of the spi calculus. Therefore, our presentation is mostly a review. Most of this material is derived from the earlier presentations of the spi calculus <ref> [AG97b] </ref>; it includes ideas common in the pi-calculus literature. 3.1 Syntax We assume an infinite set of names and an infinite set of variables. We let m, n, p, q, and r range over names, and let w, x, y, and z range over variables. <p> We define the dual composition A j R symmetrically. (The definition of (m)(~n)h ~ M iQ is slightly different from the original one <ref> [AG97b] </ref>. <p> processes such that P S Q implies: (1) for every barb fi, if P fi ! A then Q fi ! B for some B, (2) if P ! P 0 then there exists Q 0 such that Q o (These requirements are somewhat stronger than those for barbed simulations <ref> [AG97b] </ref>.) A strict barbed bisimulation is a relation S such that both S and S 1 are strict barbed simulations. The following lemma provides a method for proving testing equivalence: Lemma 1. <p> The following lemma provides a method for proving testing equivalence: Lemma 1. If for every closed process R there exists a strict barbed bisimulation S such that (P j R) S (Q j R), then P ' Q. Proof. The lemma is a consequence of earlier results <ref> [AG97b] </ref>, but we give a simple direct proof, since there is one.
Reference: [AG97c] <author> M. Abadi and A. D. Gordon. </author> <title> Reasoning about cryptographic protocols in the spi calculus. </title> <note> To appear in the Proceedings of CONCUR'97, </note> <year> 1997. </year>
Reference-contexts: In order to prevent this small leak, A should create a confounder N A for each encryption. The modified protocol is: Message 1 B ! A : N B Message 2 A ! B : fM; N B ; N A g K AB This protocol is analyzed in <ref> [AG97c] </ref>, where it is proved that the protocol guar antees the secrecy of M .
Reference: [AN96] <author> M. Abadi and R. Needham. </author> <title> Prudent engineering practice for cryptographic protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 6-15, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: As in this example, it is common for principals to deduce the sensitivity of inputs from the expected kind of a message or other implicit information. Such implicit information is often incorrect and often hard to analyze <ref> [AN96] </ref>. It is clearer to label explicitly each component of a message with a classification, avoiding the dependence on implicit context. This labelling is important only for messages on secret channels or under secret keys, as all other messages can contain only public information.
Reference: [BAN89] <author> M. Burrows, M. Abadi, and R. M. Needham. </author> <title> A logic of authentication. </title> <journal> Proceedings of the Royal Society of London A, </journal> <volume> 426 </volume> <pages> 233-271, </pages> <year> 1989. </year> <note> A preliminary version appeared as Digital Equipment Corporation Systems Research Center report No. 39, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: These models are rather accurate, as in particular they can take into account issues of probability and complexity. Unfortunately, proofs in these models remain much more difficult than typechecking. 6.1 A First Example The first protocol is similar in structure to the Wide Mouthed Frog protocol <ref> [BAN89] </ref>.
Reference: [BN95] <author> M. Boreale and R. De Nicola. </author> <title> Testing equivalence for mobile processes. </title> <journal> Information and Computation, </journal> <volume> 120(2) </volume> <pages> 279-303, </pages> <month> August </month> <year> 1995. </year>
Reference: [BR95] <author> M. Bellare and P. Rogaway. </author> <title> Provably secure session key distribution: The three party case. </title> <booktitle> In Proceedings of the 27th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The corollaries exclude this possibility. Analogues of our corollaries can perhaps be established in informal but rigorous models (see for example <ref> [BR95] </ref>). These models are rather accurate, as in particular they can take into account issues of probability and complexity. Unfortunately, proofs in these models remain much more difficult than typechecking. 6.1 A First Example The first protocol is similar in structure to the Wide Mouthed Frog protocol [BAN89].
Reference: [Den82] <author> D. E. Denning. </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1982. </year>
Reference: [DES77] <institution> Data encryption standard. Fed. </institution> <note> Inform. Processing Standards Pub. 46, </note> <institution> National Bureau of Standards, </institution> <address> Washington DC, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: We write fM g K for the result of encrypting M with K, using a shared-key cryptosystem such as DES <ref> [DES77] </ref>. With shared-key cryptography, secrecy can be achieved by communication on public channels under secret keys. In addition to public channels, on which anyone may communicate, we consider channels with some built-in protection. We restrict attention to channels on which the same principals can send and receive.
Reference: [DH84] <author> R. De Nicola and M. C. B. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference: [Gas88] <author> M. Gasser. </author> <title> Building a Secure Computer System. </title> <publisher> Van Nostrand Reinhold Company Inc., </publisher> <address> New York, </address> <year> 1988. </year>
Reference: [LY96] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison--Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Then Sys1 ' Sys2 . 7 Conclusions Perhaps in part because of advances in programming languages, the idea of static checking of security properties seems to be reviving. The Java bytecode verifier is a recent static checker with security objectives <ref> [LY96] </ref>. In the last couple of years, more sophisticated security checks have been based on self-certification and on information-flow techniques (see for example [Nec97,VSI96]). This work can be seen as part of that revival.
Reference: [Mil91] <author> R. Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <note> Appeared in Logic and Algebra of Specification, </note> <editor> F. L. Bauer, W. Brauer, and H. Schwichtenberg, eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The next section explains, informally, our approach for achieving secrecy. Section 3 is a review of the spi calculus. (The spi calculus presented is a generalization of that defined originally [AG97a]; it includes polyadic constructs <ref> [Mil91] </ref>.) Section 4 provides the typing rules for the spi calculus, and Section 5 shows that these rules can be applied to prevent undesirable flows of information. Section 6 illustrates the use of the rules in examples. Finally, Section 7 discusses some conclusions.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, parts I and II. </title> <booktitle> Information and Computation, </booktitle> <pages> pages 1-40 and 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The rules of this paper capture a sufficient set of simple precautions that permit this declassification. The rules have the form of typing rules for a basic concurrent language, the spi calculus [AG97a]; this calculus is an extension of the pi calculus <ref> [MPW92] </ref> with shared-key cryptographic primitives. The purpose of these rules is rather different from those of standard typing rules for related languages (such as those of Pierce and Sangiorgi [PS96]). The rules guarantee that, if a protocol type-checks, then it does not leak its secret inputs.
Reference: [Nec97] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <year> 1997. </year>
Reference: [NS78] <author> R. M. Needham and M. D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: On the other hand, data that arrives with some protection may be either secret or public. The participants of protocols typically know how to handle each of the fields of the encrypted messages that they receive, as in the following example (inspired by the Needham-Schroeder protocol <ref> [NS78] </ref>): Message 1 A ! S : A; B Message 2 S ! A : fA; B; I A ; fI B g K SB g K SA Message 3 A ! B : fI B g K SB In this protocol, the principals A and B share keys K SA
Reference: [PS96] <author> B. Pierce and D. Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 6(5) </volume> <pages> 409-453, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The purpose of these rules is rather different from those of standard typing rules for related languages (such as those of Pierce and Sangiorgi <ref> [PS96] </ref>). The rules guarantee that, if a protocol type-checks, then it does not leak its secret inputs. This secrecy is obtained independently of any other feature (or any flaw) of the protocol.
Reference: [Sch96] <author> B. Schneier. </author> <title> Applied Cryptography: Protocols, Algorithms, and Source Code in C. </title> <publisher> John Wiley & Sons, Inc., </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: In particular, the same key should not be used to protect a great volume of sensitive traffic, because then even a brute-force attack on the key may be profitable. Weak secrets, such as passwords, should be protected from brute-force at tacks (see for example <ref> [Sch96] </ref>). Undoubtedly there are more. However, the discussion of this section suffices as background for our rules and theorems. 3 The Untyped, Polyadic Spi Calculus This section defines the version of the spi calculus that serves as the setting for our formal work.
Reference: [VSI96] <author> D. Volpano, G. Smith, and C. </author> <title> Irvine. A sound type system for secure flow analysis. </title> <journal> Journal of Computer Security, </journal> <volume> 4(3) </volume> <pages> 1-21, </pages> <year> 1996. </year>
Reference-contexts: Typically, these methods rely on putting objects and subjects into security classes, and guaranteeing that no data flows from higher classes to lower classes. In some of these methods, security classes are formalized as types, and the control of flows of information relies on typing rules (e.g., <ref> [VSI96] </ref>). We adapt some of that work to security protocols. This section describes our approach informally, along with the main difficulties that it addresses.
References-found: 19

