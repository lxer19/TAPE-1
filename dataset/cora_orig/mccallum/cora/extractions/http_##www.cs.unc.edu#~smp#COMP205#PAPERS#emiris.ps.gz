URL: http://www.cs.unc.edu/~smp/COMP205/PAPERS/emiris.ps.gz
Refering-URL: http://www.cs.unc.edu/~smp/COMP205/PAPERS/
Root-URL: http://www.cs.unc.edu
Title: Efficient Perturbations for Handling Geometric Degeneracies 1  
Author: Ioannis Z. Emiris, John F. Canny and Raimund Seidel 
Keyword: Key words. Input degeneracy, Efficient perturbations, Algorithm implementation, General-dimensional convex hulls.  
Date: June 6, 1994  
Abstract: This article defines input perturbations so that an algorithm designed under certain restrictions on the input can execute on arbitrary instances. A syntactic definition of perturbations is proposed and certain properties specified under which an algorithm executed on perturbed input produces an output from which the exact answer can be recovered. A general framework is adopted for linear perturbations, which are efficient from the point of view of worst-case asymptotic complexity. The deterministic scheme of Emiris and Canny [1] was the first efficient scheme and is extended, in a consistent manner, to cover a wide class of geometric algorithms. We introduce a variant scheme, applicable to a restricted class of algorithms, which is almost optimal in terms of the algebraic as well as the bit complexity. Neither scheme requires any symbolic computation and both are simple to use as illustrated by our implementation of a Convex Hull algorithm in arbitrary dimension; empirical results are reported. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I.Z. Emiris and J.F. Canny. </author> <title> A general approach to removing degeneracies. </title> <booktitle> In Proc. 32nd IEEE Symp. Found. of Comp. Sci., </booktitle> <pages> pages 405-413, </pages> <year> 1991. </year> <note> Full version to appear in SIAM J. Comput. </note>
Reference-contexts: The main drawback of previous approaches [2, 3] is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. The deterministic perturbation of Emiris and Canny <ref> [1] </ref> was the first efficient scheme in the sense that the algebraic complexity overhead is at most logarithmic in the dimension. The second contribution of this article is the design and application of specific efficient schemes to a 1 Some preliminary results have appeared in: I. Emiris and J. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program, if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> He uses towers of infinitesimals to eliminate degeneracies while preserving essential properties of the sets, namely emptiness and number of connected components. Emiris and Canny presented in <ref> [1] </ref> an infinitesimal perturbation that constitutes the first efficient scheme, inspired by the SoS method. For geometric algorithms, every coordinate x i;j is deterministically perturbed into x i;j (*) = x i;j + * i j ; (1) where * is a symbolic infinitesimal. <p> Dense interpolation costs O (ffiMM (t)), where ffi t. An improved technique for interpolating determinants whose entries are higher-degree polynomials in several variables appears in [24]. Here, following <ref> [1] </ref>, we generalize a near-optimal technique for the case when the entries are univariate polynomials. <p> For completeness we state the following proposition which relies on Theorem 8, the properties of Vandermonde matrices and Corollary 14. Proposition 16 <ref> [1] </ref> Perturbation (1) is valid with respect to algorithms that branch on determinants of fl ffi+1 and ffi , for ffi d, where d is the space dimension. The perturbation increases the asymptotic running-time complexity of evaluating the primitive, under the algebraic model, by O (log d).
Reference: [2] <author> H. Edelsbrunner and E.P. Mucke. </author> <title> Simulation of simplicity: A technique to cope with degenerate cases in geometric algorithms. </title> <journal> ACM Trans. Graphics, </journal> <volume> 9(1) </volume> <pages> 67-104, </pages> <year> 1990. </year>
Reference-contexts: Lastly, some general techniques for designing and evaluating efficient perturbations for a wide class of geometric primitives are suggested. The main drawback of previous approaches <ref> [2, 3] </ref> is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program, if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> Edelsbrunner and Mucke generalize in <ref> [2] </ref> a technique called Simulation of Simplicity (SoS for short), already presented in [17], which refines the above method. Every input coordinate x i;j is perturbed into x i;j (*) = x i;j + * 2 iffij ; where ffi &gt; d and d is the dimension. <p> In <ref> [2] </ref> every such vector is associated with a minor that may have to be evaluated. 5 Yap in [3] deals with the more general setting in which branching occurs at arbitrary rational ex-pressions and proposes a method which is equivalent to an infinitesimal perturbation, as proven in [18]. <p> P d i d+1 ;j P d i d+2 ;j 7 7 7 7 : Eliminating degeneracies for the particular matrix could be achieved by the "cheap trick" of <ref> [2] </ref> which perturbs the points on the higher-dimensional paraboloid, by perturbing the sum of squares as if it were an additional coordinate. However, this may lead to inconsistencies in some special configurations, if the same algorithm also uses another primitive such as fl d+1 . <p> complexity of evaluating the primitive is O (d 2 (ds + d 2 log n) 1+ff + (ds + d 2 log n)MM (d) log d): The overhead now follows from s log n. 2 6.4 Other Primitives Our techniques directly apply to several other primitives including those presented in <ref> [2] </ref>. Primitives that decide on the relative position of derived objects may pose a limitation to our method. Consider, for instance, the two-dimensional ham-sandwich algorithm in [31] with lines on the plane being the input objects and their intersection points being the derived objects.
Reference: [3] <author> C.-K. Yap. </author> <title> Symbolic treatment of geometric degeneracies. </title> <journal> J. Symbolic Comput., </journal> <volume> 10 </volume> <pages> 349-370, </pages> <year> 1990. </year>
Reference-contexts: Lastly, some general techniques for designing and evaluating efficient perturbations for a wide class of geometric primitives are suggested. The main drawback of previous approaches <ref> [2, 3] </ref> is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program, if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> In [2] every such vector is associated with a minor that may have to be evaluated. 5 Yap in <ref> [3] </ref> deals with the more general setting in which branching occurs at arbitrary rational ex-pressions and proposes a method which is equivalent to an infinitesimal perturbation, as proven in [18]. Recently, it has been extended to analytic test functions [19].
Reference: [4] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1987. </year>
Reference-contexts: For rational inputs, almost all arithmetic can be carried out over a finite field and all intermediate quantities computed grow in a quasi-linear fashion with the dimension. Furthermore, these schemes are simple to implement; to illustrate this claim, our third contribution is an implementation of the Beneath-Beyond algorithm <ref> [4] </ref> that uses the second scheme to construct the facet structure of convex hulls in arbitrary dimension and to compute their volume. The issue of postprocessing is closely examined in this context and experimental results are reported. <p> One should keep in mind that consistency requires that exactly one scheme is applied to all primitives of a specific algorithm. 7 Computing Convex Hulls This section discusses our implementation of the Beneath-Beyond algorithm <ref> [4] </ref> which solves the Convex Hull Volume (CHV) problem for finite input sets of integral points in arbitrary dimension, and reports on the running-time performance. The implementation produces approximate solutions to the Convex Hull Face-Structure (CHF) problem, in a sense specified later.
Reference: [5] <author> S. Teller and C.H.Sequin. </author> <title> Visibility Preprocessing for Interactive Walkthroughs. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '91), </booktitle> <volume> 25(4) </volume> <pages> 61-69, </pages> <year> 1991. </year>
Reference-contexts: The issue of postprocessing is closely examined in this context and experimental results are reported. Convex hull computation in general dimension is a fundamental geometric problem with a wide variety of applications, such as visibility and illumination in modeling and graphics <ref> [5, 6] </ref>, collision detection in robotics and animation [7], material identification in geology [8], molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision [10, 11]. This article is organized as follows.
Reference: [6] <author> S. Teller, C. Fowler, T. Funkhouser, and P. Hanrahan. </author> <title> Partitioning and Ordering Large Radiosity Computations. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '94), </booktitle> <volume> 28, </volume> <year> 1994. </year>
Reference-contexts: The issue of postprocessing is closely examined in this context and experimental results are reported. Convex hull computation in general dimension is a fundamental geometric problem with a wide variety of applications, such as visibility and illumination in modeling and graphics <ref> [5, 6] </ref>, collision detection in robotics and animation [7], material identification in geology [8], molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision [10, 11]. This article is organized as follows.
Reference: [7] <author> M.C. Lin, D. Manocha, and J. Canny. </author> <title> Efficient Contact Determination for Dynamic Environments. </title> <booktitle> In Proc. IEEE Intern. Conf. Robotics and Automation, </booktitle> <pages> pages 602-608, </pages> <year> 1994. </year>
Reference-contexts: The issue of postprocessing is closely examined in this context and experimental results are reported. Convex hull computation in general dimension is a fundamental geometric problem with a wide variety of applications, such as visibility and illumination in modeling and graphics [5, 6], collision detection in robotics and animation <ref> [7] </ref>, material identification in geology [8], molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision [10, 11]. This article is organized as follows.
Reference: [8] <author> J.W. Boardman. </author> <title> Automated Spectral Unmixing of Aviris Data Using Convex Geometry Concepts. </title> <booktitle> In Proc. 4th Airborne Geoscience Workshop, </booktitle> <address> Washington, D.C., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Convex hull computation in general dimension is a fundamental geometric problem with a wide variety of applications, such as visibility and illumination in modeling and graphics [5, 6], collision detection in robotics and animation [7], material identification in geology <ref> [8] </ref>, molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision [10, 11]. This article is organized as follows.
Reference: [9] <author> M.L. Connolly. </author> <title> Molecular Interstitial Skeleton. </title> <journal> Computers Chem., </journal> <volume> 15(1) </volume> <pages> 37-45, </pages> <year> 1991. </year>
Reference-contexts: Convex hull computation in general dimension is a fundamental geometric problem with a wide variety of applications, such as visibility and illumination in modeling and graphics [5, 6], collision detection in robotics and animation [7], material identification in geology [8], molecular docking in drug fabrication <ref> [9] </ref> as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision [10, 11]. This article is organized as follows.
Reference: [10] <author> B. Huber and B. Sturmfels. </author> <title> A polyhedral method for solving sparse polynomial systems. </title> <note> To appear in Mathematics of Computation. A preliminary version presented at the "Workshop on Real Algebraic Geometry", </note> <month> August </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: with a wide variety of applications, such as visibility and illumination in modeling and graphics [5, 6], collision detection in robotics and animation [7], material identification in geology [8], molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision <ref> [10, 11] </ref>. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them. Section 3 is a comparative study of previous work on handling degeneracies.
Reference: [11] <author> I. Emiris and J. Canny. </author> <title> A Practical Method for the Sparse Resultant. </title> <booktitle> In Proc. ACM Intern. Symp. on Symbolic and Algebr. Computation, </booktitle> <pages> pages 183-192, </pages> <year> 1993. </year>
Reference-contexts: with a wide variety of applications, such as visibility and illumination in modeling and graphics [5, 6], collision detection in robotics and animation [7], material identification in geology [8], molecular docking in drug fabrication [9] as well as in solving systems of nonlinear equations, particularly in modeling, robotics and vision <ref> [10, 11] </ref>. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them. Section 3 is a comparative study of previous work on handling degeneracies.
Reference: [12] <author> F.P. Preparata and M.I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Section 7 presents our implementation of the Beneath-Beyond algorithm. The conclusion summarizes the main results and suggests some open questions. 2 Definitions 2.1 Computational model Our model is the real Random Access Machine (RAM) of <ref> [12] </ref>. The input is organized as a set of n vectors in R d , where n d &gt; 0 and the i-th vector is x i = (x i;1 ; : : : ; x i;d ) for 1 i n; 1 j d.
Reference: [13] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: For integers of size O (b), addition and subtraction, multiplication and division and, lastly, the Greatest Common Divisor (GCD) operation require respectively O (b), O (b log b log log b) and O (b log 2 b log log b) bit operations <ref> [13] </ref>. We shall use M (b) = O (b log 2 b log log b) as an upper bound on the bit complexity of any arithmetic or GCD operation between any two rational numbers with numerator and denominator of size O (b). <p> If ffi + 1 interpolation pairs are available, dense interpolation can be used to compute the coefficients in O (ffi log 2 ffi) arithmetic operations <ref> [13] </ref>. If, furthermore, there is an a priori bound T on the number of non-zero terms that is significantly lower than the maximum number ffi +1, then sparse interpolation is preferable. <p> Besides the classical application to integer arithmetic <ref> [13] </ref>, modular methods and the Chinese Remainder Theorem can be used with rational data with the same asymptotic complexity [26]. The basic approach is as follows.
Reference: [14] <author> K. Dobrindt, K. Mehlhorn, and M. Yvinec. </author> <title> A complete framework for the intersection of a general polyhedron with a convex one. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., Lect. Notes Comp. Science 709, </booktitle> <pages> pages 314-324. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Postprocessing then has to merge these segments by eliminating points in the interior of polygon edges. This process is analyzed for the general CHF problem in Section 7. Postprocessing for the problem of polytope intersection is examined in <ref> [14] </ref>. 2.3 Computing with Perturbations Given a program that implements , the question is how to obtain another real RAM program that implements . First, all arithmetic operations in are transformed in order to handle perturbation curves. <p> schemes covering some common geometric primitives and study the issue of efficiently executing a transformed program. 3 Previous work The simplest approach in coping with degeneracies is to handle each special case separately, which is tedious for implementors and unattractive for theoreticians, though some recent work re-examines this common belief <ref> [14, 15] </ref>. Dantzig's [16] symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constraint equation by an infinitesimal quantity that depends on the index of this equation. <p> Dobrindt, Mehlhorn and Yvinec proposed an efficient scheme specifically for coping with degenerate intersections between a convex and a general polyhedron in three dimensions <ref> [14] </ref>. It is noteworthy that the vertices of the convex polyhedron are guaranteed to be perturbed in a specific direction with respect to the given facets. Another merit of this work is that it discusses postprocessing in detail in order to recover the exact solution. <p> The basic existential question on the perturbation method is still open. After the flurry of papers proposing different perturbation schemes, some objections have recently been voiced against the general applicability of this method <ref> [14, 15] </ref> motivated by the observation that the difficulty and complexity of postprocessing might dominate that of the entire program.
Reference: [15] <author> C. Burnikel, K. Mehlhorn, and S. Schirra. </author> <title> On degeneracy in geometric computations. </title> <booktitle> In Proc. 5th ACM-SIAM Symp. on Discr. Algorithms, </booktitle> <pages> pages 16-23, </pages> <year> 1994. </year>
Reference-contexts: schemes covering some common geometric primitives and study the issue of efficiently executing a transformed program. 3 Previous work The simplest approach in coping with degeneracies is to handle each special case separately, which is tedious for implementors and unattractive for theoreticians, though some recent work re-examines this common belief <ref> [14, 15] </ref>. Dantzig's [16] symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constraint equation by an infinitesimal quantity that depends on the index of this equation. <p> The reason is that the overhead incurred by perturbing is not output-sensitive. For instance, given n coincident points as input to an algorithm solving the CHF problem, the exact output is a single point whereas the perturbed output is a polytope with n bd=2c facets. See <ref> [15] </ref> for a discussion of limitations of this approach. <p> The basic existential question on the perturbation method is still open. After the flurry of papers proposing different perturbation schemes, some objections have recently been voiced against the general applicability of this method <ref> [14, 15] </ref> motivated by the observation that the difficulty and complexity of postprocessing might dominate that of the entire program.
Reference: [16] <author> G.B. Dantzig. </author> <title> Linear Programming and Extensions. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1963. </year>
Reference-contexts: Dantzig's <ref> [16] </ref> symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constraint equation by an infinitesimal quantity that depends on the index of this equation.
Reference: [17] <author> H. Edelsbrunner. </author> <title> Edge-skeletons in arrangements with applications. </title> <journal> Algorithmica, </journal> <volume> 1 </volume> <pages> 93-109, </pages> <year> 1986. </year>
Reference-contexts: Edelsbrunner and Mucke generalize in [2] a technique called Simulation of Simplicity (SoS for short), already presented in <ref> [17] </ref>, which refines the above method. Every input coordinate x i;j is perturbed into x i;j (*) = x i;j + * 2 iffij ; where ffi &gt; d and d is the dimension.
Reference: [18] <author> C.-K. Yap. </author> <title> A geometric consistency theorem for a symbolic perturbation scheme. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 40 </volume> <pages> 2-18, </pages> <year> 1990. </year>
Reference-contexts: In [2] every such vector is associated with a minor that may have to be evaluated. 5 Yap in [3] deals with the more general setting in which branching occurs at arbitrary rational ex-pressions and proposes a method which is equivalent to an infinitesimal perturbation, as proven in <ref> [18] </ref>. Recently, it has been extended to analytic test functions [19].
Reference: [19] <author> R. Seidel. </author> <title> The nature and meaning of perturbations in geometric computing. </title> <booktitle> In Proc. 11th Symp. Theoret. Aspects Computer Science, Lect. Notes Computer Science 775, </booktitle> <pages> pages 3-17. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Recently, it has been extended to analytic test functions <ref> [19] </ref>.
Reference: [20] <author> J.F. Canny. </author> <title> Computing roadmaps of semi-algebraic sets. </title> <booktitle> In Proc. Intern. Symp. Applied Algebra, Algebraic Algor. and Error-Corr. Codes, </booktitle> <year> 1991. </year>
Reference-contexts: Another merit of this work is that it discusses postprocessing in detail in order to recover the exact solution. A structural perturbation for a motion-planning algorithm, in which the input objects are the semi-algebraic sets describing the obstacles, is given by Canny in <ref> [20] </ref>. He uses towers of infinitesimals to eliminate degeneracies while preserving essential properties of the sets, namely emptiness and number of connected components. Emiris and Canny presented in [1] an infinitesimal perturbation that constitutes the first efficient scheme, inspired by the SoS method.
Reference: [21] <author> R. Zippel. </author> <title> Interpolating polynomials from their values. </title> <journal> J. Symbolic Computation, </journal> <volume> 9 </volume> <pages> 375-403, </pages> <year> 1990. </year>
Reference-contexts: In general, though, defining perturbation vectors b 1 ; : : : ; b n is a hard problem, a stronger version, in fact, of the zero avoidance problem <ref> [21] </ref>. <p> A deterministic algorithm has complexity O (T 2+ff log ffi) and requires 2T interpolation pairs, where ff again accounts for the polylogarithmic factor. Both algorithms are surveyed in <ref> [21] </ref>. Traditionally, the cost of evaluating the unknown polynomial is of minor concern in the context of the interpolation problem, yet here this cost must be assessed. In general, computing the interpolation pairs takes time proportional to the number of pairs times the complexity of evaluating the polynomial.
Reference: [22] <author> G.E. Collins and R. Loos. </author> <title> Real zeros of polynomials. </title> <editor> In B. Buchberger, G.E. Collins, and R. Loos, editors, </editor> <booktitle> Computer Algebra: Symbolic and Algebraic Computation, </booktitle> <pages> pages 83-94. </pages> <publisher> Springer-Verlag, Wien, </publisher> <address> 2nd edition, </address> <year> 1982. </year>
Reference-contexts: Proposition 9 (Descartes' Rule of Sign) <ref> [22] </ref> The number of sign variations of a polynomial's nonzero coefficients exceeds the number of positive zeros, multiplicities counted, by an even non-negative integer. 7 Proposition 10 Matrix W d+2 is non-singular for distinct positive i j , 1 j d + 2.
Reference: [23] <author> D. Coppersmith and S. Winograd. </author> <title> Matrix multiplication via arithmetic progressions. </title> <journal> J. Symbolic Computation, </journal> <volume> 9 </volume> <pages> 251-280, </pages> <year> 1990. </year>
Reference-contexts: The rest of this section concentrates on determinantal tests of order t and develops more efficient ways for the combined problem of evaluation and sign determination. Let MM (t) = O (t 2:376 ) <ref> [23] </ref> be the algebraic complexity of multiplying two t fi t matrices and I (I t ) the identity matrix (of order t). Dense interpolation costs O (ffiMM (t)), where ffi t. An improved technique for interpolating determinants whose entries are higher-degree polynomials in several variables appears in [24].
Reference: [24] <author> D. Manocha and J. Canny. </author> <title> Multipolynomial Resultants and Linear Algebra. </title> <booktitle> In Proc. ACM Intern. Symp. on Symbolic and Algebr. Computation, </booktitle> <pages> pages 96-102, </pages> <year> 1992. </year>
Reference-contexts: Dense interpolation costs O (ffiMM (t)), where ffi t. An improved technique for interpolating determinants whose entries are higher-degree polynomials in several variables appears in <ref> [24] </ref>. Here, following [1], we generalize a near-optimal technique for the case when the entries are univariate polynomials. <p> A 1 r A 1 A 1 r A r1 7 7 7 5 If A r is singular there exist rt fi rt matrices P and Q such that det (A (*)) = det (P * + Q). Moreover, <ref> [24] </ref> demonstrates a series of transformations that produces matrices P 0 and Q 0 of smaller order, such that the original problem is reduced to computing det (P 0 * + Q 0 ); the worst-case complexity of this method is O (rtMM (rt) log (rt)).
Reference: [25] <author> I. Gohberg, P. Lancaster, and L. Rodman. </author> <title> Matrix Polynomials. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: If A r is non-singular, we have A 1 r A r1 * r1 + + A 1 r A 0 and the determinant of the right-hand side equals <ref> [25] </ref> the characteristic polynomial of C = 6 6 6 4 0 0 I t 0 . . . . . .
Reference: [26] <author> J.H. Davenport, Y. Siret, and E. Tournier. </author> <title> Computer Algebra. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1988. </year>
Reference-contexts: Besides the classical application to integer arithmetic [13], modular methods and the Chinese Remainder Theorem can be used with rational data with the same asymptotic complexity <ref> [26] </ref>. The basic approach is as follows. <p> Then, it is straightforward to compute the exact volume by summing all simplex volumes whose expression as an *-polynomial has a non-zero constant term. Note that extension to rational inputs is possible without affecting the asymptotic complexity; for the case of modular arithmetic see <ref> [26] </ref>. The extreme points of a given point-set are those that strictly maximize the inner product with some d-vector, i.e. they are not expressible as a convex combination of the other points; these are exactly the vertices of the convex hull.
Reference: [27] <author> W. Keller-Gehrig. </author> <title> Fast algorithms for the characteristic polynomial. </title> <journal> Theor. Comp. Sci., </journal> <volume> 36 </volume> <pages> 309-317, </pages> <year> 1985. </year>
Reference-contexts: Each takes O (MM (t)) time, except from the last step which takes O (MM (t) log t) time, for arbitrary matrices, due to an algorithm by Keller-Gehrig <ref> [27] </ref>. To establish the bit complexity bound, the transformation of Theorem 13 is used. The bit size of the coefficients of the *-polynomial representing the determinant is O (ts) since the original matrix entries have size s and its order is t.
Reference: [28] <author> H. Edelsbrunner and L.J. Guibas. </author> <title> Topologically sweeping an arrangement. </title> <booktitle> In Proc. 18th Annual ACM Symp. Theory of Comp., </booktitle> <pages> pages 389-403, </pages> <year> 1986. </year>
Reference-contexts: d ;2 ::: x i d ;d 7 7 5 Matrix d also comes up in a dual context, when the input objects are hyperplanes in (d 1)-dimensional space and Transversality decides on which side of the first hyperplane lies the intersection of the other d 1 hyperplanes as in <ref> [28] </ref>, for example, where d = 3. For completeness we state the following proposition which relies on Theorem 8, the properties of Vandermonde matrices and Corollary 14.
Reference: [29] <author> J. von zur Gathen. </author> <title> Algebraic complexity theory. </title> <editor> In J. Traub, editor, </editor> <booktitle> Annual Review of Computer Science, </booktitle> <pages> pages 317-347. </pages> <publisher> Annual Reviews, </publisher> <address> Palo Alto, CA, </address> <year> 1988. </year>
Reference-contexts: Theorem 17 Perturbation (4) is valid with respect to Orientation and Transversality. It increases the worst-case algebraic and bit complexities of the Orientation and Transversality primitives by a O (log d) factor. Proof Validity follows from Theorem 8. The original algebraic complexity is fi (MM (d)) <ref> [29] </ref>. From Corollary 14, the complexity on perturbed input is O (MM (d) log d). The original worst-case bit complexity depends on the size of the answer which is fi (ds).
Reference: [30] <author> T. Thiele, </author> <year> 1993. </year> <type> Personal Communication. 17 </type>
Reference-contexts: Unfortunately, the hypothesis of the theorem is not readily satisfied by the second perturbation (4). A similar scheme, with residues taken mod q, with q = (n d1 ), has been recently shown <ref> [30] </ref> to be valid, offering a slight improvement on complexity.
Reference: [31] <author> H. Edelsbrunner and R. Waupotitsch. </author> <title> Computing a ham-sandwich cut in two dimensions. </title> <journal> J. Symbolic Comput., </journal> <volume> 2 </volume> <pages> 171-178, </pages> <year> 1986. </year>
Reference-contexts: Primitives that decide on the relative position of derived objects may pose a limitation to our method. Consider, for instance, the two-dimensional ham-sandwich algorithm in <ref> [31] </ref> with lines on the plane being the input objects and their intersection points being the derived objects.
Reference: [32] <author> J.L. Bentley, H.T. Kung, M. Schkolnick, and C.D. Thompson. </author> <title> On the Average Number of Maxima in a Set of Vectors. </title> <journal> J. ACM, </journal> <volume> 25 </volume> <pages> 536-543, </pages> <year> 1978. </year> <month> 18 </month>
Reference-contexts: In the worst case, the hull of n points in d dimensions has O (n bd=2c ) facets. However, the expected number of facets for points selected randomly as above is proportional to log d1 n <ref> [32] </ref>; this is verified by our experimental results. 8 Conclusion We have defined the notion of input perturbation and have concentrated on linear schemes, which are amenable to efficient computation techniques. In particular, we have proposed two such schemes that are valid for certain important geometric primitives.
References-found: 32

