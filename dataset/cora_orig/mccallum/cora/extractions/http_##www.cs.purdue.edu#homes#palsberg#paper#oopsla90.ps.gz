URL: http://www.cs.purdue.edu/homes/palsberg/paper/oopsla90.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.dk and mis@daimi.dk  
Title: Type Substitution for Object-Oriented Programming  
Author: Jens Palsberg Michael I. Schwartzbach 
Note: Internet addresses:  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: Genericity allows the substitution of types in a class. This is usually obtained through parameterized classes, although they are inflexible since any class can be inherited but is not in itself parameterized. We suggest a new genericity mechanism, type substitution, which is a subclassing concept that complements inheritance: any class is generic, can be "instantiated" gradually without planning, and has all of its generic instances as subclasses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan H. Borning and Daniel H. H. Ingalls. </author> <title> A type declaration and inference system for Smalltalk. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-141, </pages> <year> 1982. </year>
Reference-contexts: The class phonebook can now be obtained through a type substitution of text for arg and integer for res. 8 Heterogeneous Variables Assignments between unequal types were not needed to construct generic classes. Actually, most parts of a program do not need such assignments <ref> [1] </ref>. However, they are clearly required to build heterogeneous data structures. This suggests that genericity and heterogeneity are independent issues. To obtain a comprehensive language, we now introduce heterogeneous variables, i.e., variables which may hold not only instances of the declared class but also those of its subclasses. <p> In the following section we give the complete type-check rules which also considers heterogeneous expressions. 9 Type-checking The traditional purpose of type-checking in object-oriented languages is to ensure that all messages to objects will be understood <ref> [1] </ref>. In the homogeneous subset of our language this can be entirely determined at compile-time.
Reference: [2] <author> Peter S. Canning, William R. Cook, Walter L. Hill, John Mitchell, and Walter G. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: Bounded parametric polymorphism was introduced by Cardelli and Wegner [6] to avoid type-loss in applications, and recently F -bounded polymorphism <ref> [2, 3, 7] </ref> has been proposed to resolve a number of shortcomings involving recursive types.
Reference: [3] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 457-467. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Bounded parametric polymorphism was introduced by Cardelli and Wegner [6] to avoid type-loss in applications, and recently F -bounded polymorphism <ref> [2, 3, 7] </ref> has been proposed to resolve a number of shortcomings involving recursive types.
Reference: [4] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In Gilles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: Hence, code applicable to objects of some type can also be applied to objects of a subtype. ?? definitions code reused in Prefixing; applications code reused in Polymorphism; Code reuse Since Cardelli's seminal paper <ref> [4] </ref>, the definition of the subtype relation has undergone a number of modifications to achieve a closer resemblance to inheritance.
Reference: [5] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report No. 45, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: It should be noted, though, that these polymorphic languages cannot emulate inheritance of classes with variables because mutable types have no non-trivial subtypes, as observed by Cardelli <ref> [5] </ref>; this is further discussed in the section on heterogeneous variables. Some polymorphic languages allow parameterized types which give a different style of code reuse that cannot be expressed through inheritance. Parameterized types can be used to describe generic components, i.e., components whose type annotations can be substituted.
Reference: [6] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> Decem-ber </month> <year> 1985. </year>
Reference-contexts: Bounded parametric polymorphism was introduced by Cardelli and Wegner <ref> [6] </ref> to avoid type-loss in applications, and recently F -bounded polymorphism [2, 3, 7] has been proposed to resolve a number of shortcomings involving recursive types. <p> The minimum procedure is declared outside class order, is symmetrical, and takes two arguments of the same type provided the arguments are instances of a class which is a subclass of order. This gives an effect similar to bounded parametric polymorphism <ref> [6] </ref>. As a final example, consider the list classes and the (insertion) sort procedure in figure 17. We have obtained the functional programming style by declaring procedures outside classes. The sort procedure takes an argument whose class is a subclass of orderlist.
Reference: [7] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: Bounded parametric polymorphism was introduced by Cardelli and Wegner [6] to avoid type-loss in applications, and recently F -bounded polymorphism <ref> [2, 3, 7] </ref> has been proposed to resolve a number of shortcomings involving recursive types.
Reference: [8] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation, </journal> <volume> 114(2) </volume> <pages> 329-350, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN Fourth Annual Conference on Object-Oriented Program--ming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Notice that a tree denotation may still be infinite if it contains other recursive types. As a simple example, a sequence class and its tree denotation is presented in figure 3. Note that the standard dynamic semantics of method lookup <ref> [8, 25, 9] </ref> can be based exclusively on these denotations. Thus we need only explain inheritance and type substitution by their effect on denotations; their dynamic semantics can then be inferred.
Reference: [9] <author> William R. Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: Notice that a tree denotation may still be infinite if it contains other recursive types. As a simple example, a sequence class and its tree denotation is presented in figure 3. Note that the standard dynamic semantics of method lookup <ref> [8, 25, 9] </ref> can be based exclusively on these denotations. Thus we need only explain inheritance and type substitution by their effect on denotations; their dynamic semantics can then be inferred.
Reference: [10] <author> William R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <journal> The Computer Journal, </journal> <volume> 32(4) </volume> <pages> 305-311, </pages> <year> 1989. </year>
Reference-contexts: In section 4 we introduce type substitution as a new subclassing mechanism to complement inheritance. In section 5 we show how to program with type substitution, and note that it solves some problems in the Eiffel type system that were reported by Cook <ref> [10] </ref>. In section 6 we show that polymorphic procedures declared outside classes can be provided as a shorthand, allowing a symmetric programming style. In section 7 we demonstrate the usefulness of opaque definitions. In section 8 we discuss heterogeneous variables. Finally, in section 9 we present the type-checking rules. <p> Finally, in section 9 we present the type-checking rules. Throughout, we use examples which are reformulations of some taken from Meyer's paper on genericity versus inheritance [20], Sandberg's paper on parameterized and descriptive classes [26], and Cook's paper on problems in the Eiffel type system <ref> [10] </ref>. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula [11], C++ [31], and Eiffel [21]. The major aspects are as follows. Objects group together variables and procedures, and are instances of classes. <p> The converse is false because the extra code may exploit the larger types. Type substitution solves some problems in the Eiffel type system that were reported by Cook <ref> [10] </ref>, since attributes cannot be redeclared in isolation in subclasses, there are no asymmetries as with declaration by association, and parameterized class instantiation can be expressed as subclassing. The following section shows how to program with type substitution. 5 Programming Examples Consider the stack classes in figure 11. <p> All polymorphic procedures declared outside classes can, however, be reused. Thus, the sort procedure does not have to be altered. Let us reexamine (a reformulation of) one of the Eif-fel programs that Cook provided in his paper on problems in the Eiffel type system <ref> [10] </ref>, see figure 20. Class parent specifies a procedure base and a procedure get which takes an argument of type parent and calls the base procedure of this argument. Class son is a subclass of parent and specifies in addition a procedure extra. <p> In Cardelli's analysis, big is not a subclass of small since they both contain variables; hence, the call of switch with the actual parameter b is illegal. An analysis analogous to the ones of Cook <ref> [10] </ref> would erroneously deem the program legal since variables are ignored and only the usual subtyping rules are considered. In our analysis, the program is illegal because consistency fails in the call of switch: b and s have different types.
Reference: [11] <author> Ole-Johan Dahl, Bjtrn Myhrhaug, and Kristen Ny-gaard. </author> <title> Simula 67 common base language. </title> <type> Technical report, </type> <institution> Norwegian Computing Center, Oslo, Nor-way, </institution> <year> 1968. </year>
Reference-contexts: from Meyer's paper on genericity versus inheritance [20], Sandberg's paper on parameterized and descriptive classes [26], and Cook's paper on problems in the Eiffel type system [10]. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula <ref> [11] </ref>, C++ [31], and Eiffel [21]. The major aspects are as follows. Objects group together variables and procedures, and are instances of classes. The built-in classes are object (the empty class), boolean, integer, and array. Variables and parameters must be declared together with a type, which is a class. <p> A component may have more than one type. Examples: ML-functions [22], generic Ada-packages [12], parameterized CLU clusters [17]. * Prefixing. A component may be described as an extension of another component. Examples: Delegation [16], Simula-prefixing <ref> [11] </ref>, Smalltalk inheritance [13]. In typed languages, a component can be used only according to its type. A polymorphic component has several types; hence it can be used in several different ways. In this approach, code is reused in applications. <p> Another approach to generic classes is the use of modifiable declarations, exemplified by the Simula <ref> [11] </ref> and Beta [19, 14] notion of virtual attributes. This technique allows types to be modified in a subclass, thus providing substitution of type annotations in a generic class as a subclassing mechanism.
Reference: [12] <author> Jean D. Ichbiah et al. </author> <title> Reference Manual for the Ada Programming Language. </title> <type> US DoD, </type> <month> July </month> <year> 1982. </year>
Reference-contexts: The two major approaches to this are polymorphism and prefixing, see figure 1. * Polymorphism. A component may have more than one type. Examples: ML-functions [22], generic Ada-packages <ref> [12] </ref>, parameterized CLU clusters [17]. * Prefixing. A component may be described as an extension of another component. Examples: Delegation [16], Simula-prefixing [11], Smalltalk inheritance [13]. In typed languages, a component can be used only according to its type.
Reference: [13] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80| The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A component may have more than one type. Examples: ML-functions [22], generic Ada-packages [12], parameterized CLU clusters [17]. * Prefixing. A component may be described as an extension of another component. Examples: Delegation [16], Simula-prefixing [11], Smalltalk inheritance <ref> [13] </ref>. In typed languages, a component can be used only according to its type. A polymorphic component has several types; hence it can be used in several different ways. In this approach, code is reused in applications.
Reference: [14] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Another approach to generic classes is the use of modifiable declarations, exemplified by the Simula [11] and Beta <ref> [19, 14] </ref> notion of virtual attributes. This technique allows types to be modified in a subclass, thus providing substitution of type annotations in a generic class as a subclassing mechanism.
Reference: [15] <author> Karl J. Lieberherr and Arthur J. Riel. </author> <title> Contributions to teaching object-oriented design and programming. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 11-22. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Descriptive classes are used to avoid passing procedure parameters. Ohori and Buneman combine parameterized classes and inheritance with static type inference, though disallowing reimplementation of inherited procedures [23]. Language designs with both parameterized classes and inheritance include Eiffel [21], Trellis/Owl [27], and Demeter <ref> [15] </ref>. Instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized. In other words, code reuse with parameterized classes requires planning; code reuse with inheritance does not. Another drawback of parameterized classes is that they cannot be gradually instantiated.
Reference: [16] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object-oriented systems. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 214-223. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: The two major approaches to this are polymorphism and prefixing, see figure 1. * Polymorphism. A component may have more than one type. Examples: ML-functions [22], generic Ada-packages [12], parameterized CLU clusters [17]. * Prefixing. A component may be described as an extension of another component. Examples: Delegation <ref> [16] </ref>, Simula-prefixing [11], Smalltalk inheritance [13]. In typed languages, a component can be used only according to its type. A polymorphic component has several types; hence it can be used in several different ways. In this approach, code is reused in applications.
Reference: [17] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Scaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: The two major approaches to this are polymorphism and prefixing, see figure 1. * Polymorphism. A component may have more than one type. Examples: ML-functions [22], generic Ada-packages [12], parameterized CLU clusters <ref> [17] </ref>. * Prefixing. A component may be described as an extension of another component. Examples: Delegation [16], Simula-prefixing [11], Smalltalk inheritance [13]. In typed languages, a component can be used only according to its type. A polymorphic component has several types; hence it can be used in several different ways.
Reference: [18] <author> Ole Lehrmann Madsen, Boris Magnusson, and Birger Mtller-Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In Proc. OOP-SLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 140-150, </pages> <year> 1990. </year>
Reference-contexts: This technique allows types to be modified in a subclass, thus providing substitution of type annotations in a generic class as a subclassing mechanism. Unfortunately, individual conflicting modifications may yield type-incorrect subclasses; this leads to a fair amount of run-time type-checking <ref> [18] </ref>, which is superfluous if the resulting class is in fact type-correct. A summary of polymorphism and prefixing is provided in figure 2. In the following section, we introduce type substitution as a new approach to generic classes.
Reference: [19] <author> Ole Lehrmann Madsen and Birger Mtller-Pedersen. </author> <title> Virtual classes: A powerful mechanism in object-oriented programming. </title> <booktitle> In Proc. OOP-SLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 397-406. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Another approach to generic classes is the use of modifiable declarations, exemplified by the Simula [11] and Beta <ref> [19, 14] </ref> notion of virtual attributes. This technique allows types to be modified in a subclass, thus providing substitution of type annotations in a generic class as a subclassing mechanism.
Reference: [20] <author> Bertrand Meyer. </author> <title> Genericity versus inheritance. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 391-405. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: In section 7 we demonstrate the usefulness of opaque definitions. In section 8 we discuss heterogeneous variables. Finally, in section 9 we present the type-checking rules. Throughout, we use examples which are reformulations of some taken from Meyer's paper on genericity versus inheritance <ref> [20] </ref>, Sandberg's paper on parameterized and descriptive classes [26], and Cook's paper on problems in the Eiffel type system [10]. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula [11], C++ [31], and Eiffel [21]. <p> Furthermore, inheritance and type substitution can be shown to form an orthogonal basis for /, as indicated in fig ure 10. Thus, genericity and inheritance are reconciled as independent, complementary components of a unified concept <ref> [20] </ref>. <p> This illustrates how type substitution and inheritance complement each other: first object is substituted by boolean; then the inherited procedures are implemented appropriately. Since the recursive structure of a class is preserved during type substitutions, we do not need the association type like Current as found in Eiffel <ref> [20, 21] </ref>. This can be further illustrated by the matrix classes in figure 13. Again, the class matrix is obtained through a type substitution followed by an application of inheritance. <p> Again, the class matrix is obtained through a type substitution followed by an application of inheritance. Note that we, as opposed to Eiffel, do not need a dummy variable of type ring serving as an anchor for some association types <ref> [20, 21] </ref>. In class booleanma-trix occurrences of ring are substituted by booleanring, and consequently occurrences of object are substituted by boolean. Class matrixmatrix is obtained analogously.
Reference: [21] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: versus inheritance [20], Sandberg's paper on parameterized and descriptive classes [26], and Cook's paper on problems in the Eiffel type system [10]. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula [11], C++ [31], and Eiffel <ref> [21] </ref>. The major aspects are as follows. Objects group together variables and procedures, and are instances of classes. The built-in classes are object (the empty class), boolean, integer, and array. Variables and parameters must be declared together with a type, which is a class. <p> Descriptive classes are used to avoid passing procedure parameters. Ohori and Buneman combine parameterized classes and inheritance with static type inference, though disallowing reimplementation of inherited procedures [23]. Language designs with both parameterized classes and inheritance include Eiffel <ref> [21] </ref>, Trellis/Owl [27], and Demeter [15]. Instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized. In other words, code reuse with parameterized classes requires planning; code reuse with inheritance does not. <p> This illustrates how type substitution and inheritance complement each other: first object is substituted by boolean; then the inherited procedures are implemented appropriately. Since the recursive structure of a class is preserved during type substitutions, we do not need the association type like Current as found in Eiffel <ref> [20, 21] </ref>. This can be further illustrated by the matrix classes in figure 13. Again, the class matrix is obtained through a type substitution followed by an application of inheritance. <p> Again, the class matrix is obtained through a type substitution followed by an application of inheritance. Note that we, as opposed to Eiffel, do not need a dummy variable of type ring serving as an anchor for some association types <ref> [20, 21] </ref>. In class booleanma-trix occurrences of ring are substituted by booleanring, and consequently occurrences of object are substituted by boolean. Class matrixmatrix is obtained analogously.
Reference: [22] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: The two major approaches to this are polymorphism and prefixing, see figure 1. * Polymorphism. A component may have more than one type. Examples: ML-functions <ref> [22] </ref>, generic Ada-packages [12], parameterized CLU clusters [17]. * Prefixing. A component may be described as an extension of another component. Examples: Delegation [16], Simula-prefixing [11], Smalltalk inheritance [13]. In typed languages, a component can be used only according to its type.
Reference: [23] <author> Atsushi Ohori and Peter Buneman. </author> <title> Static type inference for parametric classes. </title> <booktitle> In Proc. OOP-SLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 445-456. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Together with parameterized classes, Sandberg introduces descriptive classes as an alternative to subclassing [26]. Descriptive classes are used to avoid passing procedure parameters. Ohori and Buneman combine parameterized classes and inheritance with static type inference, though disallowing reimplementation of inherited procedures <ref> [23] </ref>. Language designs with both parameterized classes and inheritance include Eiffel [21], Trellis/Owl [27], and Demeter [15]. Instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized.
Reference: [24] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Gener-icity And Inheritance. </title> <institution> Computer Science Department, Aarhus University. PB-318, </institution> <year> 1990. </year>
Reference-contexts: This section discusses a more general notion of type-safe code reuse of class definitions, and suggests type substitution as a new subclassing mechanism to complement inheritance. The discussion is informal; formal definitions and proofs are given in <ref> [24] </ref>. Let us first define the universe of all possible classes. A class can be thought of as untyped code in which type annotations are included whenever variables and parameters are declared. Since types are classes, this gives rise to a tree denotation of a class.
Reference: [25] <author> Uday S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: Notice that a tree denotation may still be infinite if it contains other recursive types. As a simple example, a sequence class and its tree denotation is presented in figure 3. Note that the standard dynamic semantics of method lookup <ref> [8, 25, 9] </ref> can be based exclusively on these denotations. Thus we need only explain inheritance and type substitution by their effect on denotations; their dynamic semantics can then be inferred.
Reference: [26] <author> David Sandberg. </author> <title> An alternative to subclassing. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 424-428. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: In section 8 we discuss heterogeneous variables. Finally, in section 9 we present the type-checking rules. Throughout, we use examples which are reformulations of some taken from Meyer's paper on genericity versus inheritance [20], Sandberg's paper on parameterized and descriptive classes <ref> [26] </ref>, and Cook's paper on problems in the Eiffel type system [10]. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula [11], C++ [31], and Eiffel [21]. The major aspects are as follows. <p> The simplest approach is to use parameterized classes. A parameterized class is a second-order entity which is instantiated to specific classes when actual type parameters are supplied. Together with parameterized classes, Sandberg introduces descriptive classes as an alternative to subclassing <ref> [26] </ref>. Descriptive classes are used to avoid passing procedure parameters. Ohori and Buneman combine parameterized classes and inheritance with static type inference, though disallowing reimplementation of inherited procedures [23]. Language designs with both parameterized classes and inheritance include Eiffel [21], Trellis/Owl [27], and Demeter [15].
Reference: [27] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 9-16. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Descriptive classes are used to avoid passing procedure parameters. Ohori and Buneman combine parameterized classes and inheritance with static type inference, though disallowing reimplementation of inherited procedures [23]. Language designs with both parameterized classes and inheritance include Eiffel [21], Trellis/Owl <ref> [27] </ref>, and Demeter [15]. Instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized. In other words, code reuse with parameterized classes requires planning; code reuse with inheritance does not.
Reference: [28] <author> Erik M. Schmidt and Michael I. Schwartzbach. </author> <title> An imperative type hierarchy with partial products. </title> <booktitle> In Proc. of Mathematical Foundations of Computer Science 1989. </booktitle> <publisher> Springer-Verlag (LNCS 379), </publisher> <year> 1989. </year>
Reference-contexts: Actual parameters can be instances of subclasses of the formal parameter types, but if two formal parameter types are equal then the corresponding two actual parameter types must be equal as well. This parallels the developments in <ref> [28, 29] </ref>. proc swap (inout x,y: object) var t: object begin t:=x; x:=y; y:=t end class order var value: object proc equal (other: order) returns boolean proc less (other: order) returns boolean end class integerorder inherits order [object integer] proc equal begin Result:=(value=other.value) end proc less begin Result:=(value&lt;other.value) end end proc
Reference: [29] <author> Michael I. Schwartzbach. </author> <title> Static correctness of hierarchical procedures. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1990, </booktitle> <pages> pages 32-45. </pages> <publisher> Springer-Verlag (LNCS 443), </publisher> <year> 1990. </year>
Reference-contexts: Actual parameters can be instances of subclasses of the formal parameter types, but if two formal parameter types are equal then the corresponding two actual parameter types must be equal as well. This parallels the developments in <ref> [28, 29] </ref>. proc swap (inout x,y: object) var t: object begin t:=x; x:=y; y:=t end class order var value: object proc equal (other: order) returns boolean proc less (other: order) returns boolean end class integerorder inherits order [object integer] proc equal begin Result:=(value=other.value) end proc less begin Result:=(value&lt;other.value) end end proc
Reference: [30] <author> Alan Snyder. </author> <title> Inheritance and the development of encapsulated software components. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 165-188. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: It allows the construction of subclasses by adding variables and procedures, and by replacing procedure bodies. This has inspired a development of polymorphic languages seeking to obtain the same style of code reuse in applications. They are functional languages using object interfaces as types <ref> [30] </ref>. By allowing a type to be a subtype of (conform to) other types, an object can be viewed as having both the declared type and its super-types.
Reference: [31] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: paper on genericity versus inheritance [20], Sandberg's paper on parameterized and descriptive classes [26], and Cook's paper on problems in the Eiffel type system [10]. 2 The Core Language To avoid purely syntactic issues, we use a core language with Pascal-like syntax and informal semantics, inspired by Simula [11], C++ <ref> [31] </ref>, and Eiffel [21]. The major aspects are as follows. Objects group together variables and procedures, and are instances of classes. The built-in classes are object (the empty class), boolean, integer, and array. Variables and parameters must be declared together with a type, which is a class.
References-found: 31

