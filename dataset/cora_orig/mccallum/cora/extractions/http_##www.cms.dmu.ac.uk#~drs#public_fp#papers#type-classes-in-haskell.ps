URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/type-classes-in-haskell.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Title: Type classes in Haskell  
Author: Cordelia Hall, Kevin Hammond, Simon Peyton Jones and Philip Wadler 
Affiliation: Glasgow University  
Abstract: This paper defines a set of type inference rules for resolving overloading introduced by type classes. Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to user programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the program.
Abstract-found: 1
Intro-found: 1
Reference: [Aug93] <author> L. Augustsson, </author> <title> Implementing Haskell Overloading. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: At the same time, these rules and the monad-based [ Wad92 ] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [ HaBl89, Aug93, Jon92b ] </ref> . A further contribution of this work is the use of explicit polymorphism in the target language. 2. Type Classes This section introduces type classes and defines the required terminology. Some simple examples based on equality and comparison operations are introduced.
Reference: [Blo91] <author> S. Blott, </author> <title> Type classes. </title> <type> Ph.D. Thesis, </type> <institution> Glasgow University, </institution> <year> 1991. </year>
Reference-contexts: This system was originally This work is supported by the SERC AQUA Project. Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. described by Wadler and Blott <ref> [ WB89, Blo91 ] </ref> , and a similar proposal was made independently by Kaes [ Kae88 ] . The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott <ref> [ WB89, Blo91 ] </ref> , Nipkow and Snelting [ NS91 ] , Nipkow and Prehofer [ NP93 ] , and Jones [ Jon92a, Jon93 ] . A number of simplifying assumptions made in those papers are not made here.
Reference: [CHO92] <author> K. Chen, P. Hudak, and M. Odersky, </author> <title> Parametric Type Classes. </title> <booktitle> In Lisp and Functional Programming, </booktitle> <year> 1992, </year> <pages> pp. 170-181. </pages>
Reference-contexts: inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky <ref> [ CHO92 ] </ref> . The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [CW90] <author> G. V. Comack and A. K. Wright, </author> <title> Type dependent parameter inference. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, June 1990, </address> <publisher> ACM Press. </publisher>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright <ref> [ CW90 ] </ref> , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ]
Reference: [HaBl89] <author> K. Hammond and S. Blott, </author> <title> Implementing Haskell Type Classes. </title> <booktitle> In 1989 Glasgow Workshop on Functional Programming, </booktitle> <address> Fraserburgh, Scotland, September 1989, </address> <publisher> Springer-Verlag WICS, </publisher> <pages> pp. 266-286. </pages>
Reference-contexts: At the same time, these rules and the monad-based [ Wad92 ] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [ HaBl89, Aug93, Jon92b ] </ref> . A further contribution of this work is the use of explicit polymorphism in the target language. 2. Type Classes This section introduces type classes and defines the required terminology. Some simple examples based on equality and comparison operations are introduced.
Reference: [HaHaPJW] <author> C.V. Hall, K. Hammond, S.L.Peyton Jones and P. Wadler, </author> <title> Type Classes In Haskell. </title> <institution> Department of Computing Science, Glasgow University, </institution> <month> Jan </month> <year> 1994. </year>
Reference-contexts: It includes constructs to build and select from dictionaries, and to perform type abstraction and application. A program consists of a set of bindings, which may be mutually recursive, followed by an expression. The class types appearing in the translation denote monotypes; a formal translation of them appears in <ref> [ HaHaPJW ] </ref> . program ! letrec bindset in exp Program bindset ! var 1 = exp 1 ; : : : ; var n = exp n Binding set (n 0) exp ! var Variable j pat: exp Function abstraction j exp exp 0 Function application j let var = <p> Programs. We omit the rules for declaration sequences and programs; these appear in the full technical report <ref> [ HaHaPJW ] </ref> . 5. Conclusions This paper presents a minimal, readable set of inference rules to handle type classes in Haskell, derived from the full static semantics [ PW91 ] .
Reference: [Hue 90] <editor> Gerard Huet, editor, </editor> <booktitle> Logical Foundations of Functional Programming, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year> <title> See Part II, Polymorphic Lambda Calculus, especially the introduction by Reynolds. </title>
Reference-contexts: The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). The semantics of the former is provided by translation into the latter, which has a well-known semantics <ref> [ Hue 90 ] </ref> . Normally, one expects a theorem stating that the translation is sound, in that the translation preserves the meaning of programs. That is not possible here, as the translation defines the meaning of programs.
Reference: [Jon92a] <author> M. P. Jones, </author> <title> A theory of qualified types. </title> <booktitle> In European Symposium on Programming, Rennes, </booktitle> <month> February </month> <year> 1992, </year> <note> LNCS 582, Springer-Verlag. </note>
Reference-contexts: There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones <ref> [ Jon92a, Jon93 ] </ref> , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] . <p> This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [ WB89, Blo91 ] , Nipkow and Snelting [ NS91 ] , Nipkow and Prehofer [ NP93 ] , and Jones <ref> [ Jon92a, Jon93 ] </ref> . A number of simplifying assumptions made in those papers are not made here. Unlike [ WB89 ] , it is not assumed that each class has exactly one operation. <p> Unlike [ WB89 ] , it is not assumed that each class has exactly one operation. Unlike [ NS91 ] , it is not assumed that the intersection of every pair of classes must be separately declared. Unlike <ref> [ Jon92a ] </ref> , we deal directly with instance and class declarations. Each of those papers emphasises one aspect or another of the theory, while this paper stresses what we learned from practice.
Reference: [Jon92b] <author> M. P. Jones, </author> <title> Efficient Implementation of Type Class Overloading. </title> <institution> Dept. of Computing Science, Oxford University. </institution>
Reference-contexts: At the same time, these rules and the monad-based [ Wad92 ] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [ HaBl89, Aug93, Jon92b ] </ref> . A further contribution of this work is the use of explicit polymorphism in the target language. 2. Type Classes This section introduces type classes and defines the required terminology. Some simple examples based on equality and comparison operations are introduced.
Reference: [Jon93] <author> M. P. Jones, </author> <title> A System of Constructor Classes: Overloading and Implicit Higher-Order Polymorphism. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993, </year> <pages> pp. 52-61. </pages>
Reference-contexts: There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones <ref> [ Jon92a, Jon93 ] </ref> , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] . <p> This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [ WB89, Blo91 ] , Nipkow and Snelting [ NS91 ] , Nipkow and Prehofer [ NP93 ] , and Jones <ref> [ Jon92a, Jon93 ] </ref> . A number of simplifying assumptions made in those papers are not made here. Unlike [ WB89 ] , it is not assumed that each class has exactly one operation.
Reference: [Kae88] <author> S. Kaes, </author> <title> Parametric polymorphism. </title> <booktitle> In European Symposium on Programming, </booktitle> <address> Nancy, France, March 1988, </address> <publisher> LNCS 300, Springer-Verlag. </publisher>
Reference-contexts: Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. described by Wadler and Blott [ WB89, Blo91 ] , and a similar proposal was made independently by Kaes <ref> [ Kae88 ] </ref> . The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> It is a grave shortcoming of the system presented here is that there is no direct way of assigning meaning to a program, and it must be done indirectly via translation; but there appears to be no alternative. (Note, however, that <ref> [ Kae88 ] </ref> does give a direct semantics for a slightly simpler form of overloading.) The original type inference rules given in [ WB89 ] were deliberately rather sparse, and were not intended to reflect the Haskell language precisely.
Reference: [Lau92] <editor> Polymorphic Type Inference and Abstract Data Types. K. </editor> <title> Laufer, </title> <type> Ph.D. Thesis, </type> <address> New York University, </address> <year> 1992. </year>
Reference-contexts: Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer <ref> [ Lau92, Lau93 ] </ref> , and Chen, Hudak and Odersky [ CHO92 ] . The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [Lau93] <institution> An Extension of Haskell with First-Class Abstract Types. K. Laufer, </institution> <type> Technical Report, </type> <institution> Loyola University of Chicago, </institution> <year> 1993. </year>
Reference-contexts: Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer <ref> [ Lau92, Lau93 ] </ref> , and Chen, Hudak and Odersky [ CHO92 ] . The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper, </author> <title> The definition of Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 [ Tur85 ] and Standard ML <ref> [ MTH90, MT91 ] </ref> offer differing solutions to these problems. The solutions differ not only between languages, but within a language. <p> We have been inspired in our work by the formal semantics of Standard ML prepared by Milner, Tofte, and Harper <ref> [ MTH90, MT91 ] </ref> . We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice.
Reference: [MT91] <author> R. Milner and M. Tofte, </author> <title> Commentary on Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 [ Tur85 ] and Standard ML <ref> [ MTH90, MT91 ] </ref> offer differing solutions to these problems. The solutions differ not only between languages, but within a language. <p> We have been inspired in our work by the formal semantics of Standard ML prepared by Milner, Tofte, and Harper <ref> [ MTH90, MT91 ] </ref> . We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice.
Reference: [Mil78] <author> R. Milner, </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 17, </volume> <year> 1978, </year> <pages> pp. 348-375. </pages>
Reference-contexts: The committee adopted a completely new technique, based on a proposal by Wadler, which extends the familiar Hindley-Milner system <ref> [ Mil78 ] </ref> with type classes. Type classes provide a uniform solution to overloading, including providing operations for equality, arithmetic, and string conversion. They generalise the idea of equality types from Standard ML, and subsume the approach to string conversion used in Miranda.
Reference: [NP93] <author> T. Nipkow and C. Prehofer, </author> <title> Type Checking Type Classes. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993, </year> <pages> pp. 409-418. </pages>
Reference-contexts: There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer <ref> [ NP93 ] </ref> , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] . <p> This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [ WB89, Blo91 ] , Nipkow and Snelting [ NS91 ] , Nipkow and Prehofer <ref> [ NP93 ] </ref> , and Jones [ Jon92a, Jon93 ] . A number of simplifying assumptions made in those papers are not made here. Unlike [ WB89 ] , it is not assumed that each class has exactly one operation.
Reference: [NS91] <author> T. Nipkow and G. Snelting, </author> <title> Type Classes and Overloading Resolution via Order-Sorted Unification. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Boston, </address> <month> August </month> <year> 1991, </year> <note> LNCS 523, Springer-Verlag. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting <ref> [ NS91 ] </ref> , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] . <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [ WB89, Blo91 ] , Nipkow and Snelting <ref> [ NS91 ] </ref> , Nipkow and Prehofer [ NP93 ] , and Jones [ Jon92a, Jon93 ] . A number of simplifying assumptions made in those papers are not made here. Unlike [ WB89 ] , it is not assumed that each class has exactly one operation. Unlike [ NS91 ] <p> and Snelting <ref> [ NS91 ] </ref> , Nipkow and Prehofer [ NP93 ] , and Jones [ Jon92a, Jon93 ] . A number of simplifying assumptions made in those papers are not made here. Unlike [ WB89 ] , it is not assumed that each class has exactly one operation. Unlike [ NS91 ] , it is not assumed that the intersection of every pair of classes must be separately declared. Unlike [ Jon92a ] , we deal directly with instance and class declarations.
Reference: [OdLa91] <author> M. Odersky and K. Laufer, </author> <title> Type classes are signatures of abstract types. </title> <type> Technical Report, </type> <institution> IBM TJ Watson Research Centre, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer <ref> [ OdLa91 ] </ref> , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] . The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [PW91] <author> S. L. Peyton Jones and P. Wadler, </author> <title> A static semantics for Haskell. </title> <institution> Department of Computing Science, Glasgow University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Contributions of this paper. This paper spells out the precise definition of type classes in Haskell. These rules arose from a practical impetus: our attempts to build a compiler for Haskell. It presents a simplified subset of the rules we derived. The full set of rules is given elsewhere <ref> [ PW91 ] </ref> , and contains over 30 judgement forms and over 100 rules, which deal with many additional syntactic features such as type declarations, pattern matching, and list comprehensions. <p> Programs. We omit the rules for declaration sequences and programs; these appear in the full technical report [ HaHaPJW ] . 5. Conclusions This paper presents a minimal, readable set of inference rules to handle type classes in Haskell, derived from the full static semantics <ref> [ PW91 ] </ref> . An important feature of this style of presentation is that it scales up well to a description of the entire Haskell language. We have found in practice that these rules can be directly implemented using monads.
Reference: [Rou90] <author> F. Rouaix, </author> <title> Safe run-time overloading. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> January </month> <year> 1990, </year> <note> ACM Press. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix <ref> [ Rou90 ] </ref> and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith [ VS91 ] , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91
Reference: [Tur85] <author> D. A. Turner, Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France, </address> <month> September </month> <year> 1985, </year> <title> LNCS 201, </title> <publisher> Springer-Verlag, </publisher> <pages> pp. 1-16. </pages>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 <ref> [ Tur85 ] </ref> and Standard ML [ MTH90, MT91 ] offer differing solutions to these problems. The solutions differ not only between languages, but within a language.
Reference: [VS91] <author> D. M. Volpano and G. S. Smith, </author> <title> On the complexity of ML typability with overloading. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Boston, </address> <month> August </month> <year> 1991, </year> <note> LNCS 523, Springer-Verlag. </note>
Reference-contexts: There has been closely related work by Rouaix [ Rou90 ] and Comack and Wright [ CW90 ] , and work directly inspired by type classes includes Nipkow and Snelting [ NS91 ] , Volpano and Smith <ref> [ VS91 ] </ref> , Jones [ Jon92a, Jon93 ] , Nipkow and Prehofer [ NP93 ] , Odersky and Laufer [ OdLa91 ] , Laufer [ Lau92, Lau93 ] , and Chen, Hudak and Odersky [ CHO92 ] .
Reference: [Wad92] <author> P. L. Wadler, </author> <title> The essence of functional programming. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Unlike [ Jon92a ] , we deal directly with instance and class declarations. Each of those papers emphasises one aspect or another of the theory, while this paper stresses what we learned from practice. At the same time, these rules and the monad-based <ref> [ Wad92 ] </ref> implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers [ HaBl89, Aug93, Jon92b ] . A further contribution of this work is the use of explicit polymorphism in the target language. 2.
Reference: [WB89] <author> P. L. Wadler and S. Blott, </author> <title> How to make ad-hoc polymorphism less ad hoc, </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1989, </year> <pages> pp. 60-76. </pages>
Reference-contexts: This system was originally This work is supported by the SERC AQUA Project. Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. described by Wadler and Blott <ref> [ WB89, Blo91 ] </ref> , and a similar proposal was made independently by Kaes [ Kae88 ] . The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> is no direct way of assigning meaning to a program, and it must be done indirectly via translation; but there appears to be no alternative. (Note, however, that [ Kae88 ] does give a direct semantics for a slightly simpler form of overloading.) The original type inference rules given in <ref> [ WB89 ] </ref> were deliberately rather sparse, and were not intended to reflect the Haskell language precisely. As a result, there has been some confusion as to precisely how type classes in Haskell are defined. 1.1. Contributions of this paper. <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott <ref> [ WB89, Blo91 ] </ref> , Nipkow and Snelting [ NS91 ] , Nipkow and Prehofer [ NP93 ] , and Jones [ Jon92a, Jon93 ] . A number of simplifying assumptions made in those papers are not made here. <p> A number of simplifying assumptions made in those papers are not made here. Unlike <ref> [ WB89 ] </ref> , it is not assumed that each class has exactly one operation. Unlike [ NS91 ] , it is not assumed that the intersection of every pair of classes must be separately declared. Unlike [ Jon92a ] , we deal directly with instance and class declarations.
References-found: 25

