URL: http://www.cs.toronto.edu/~vassos/research/publications/LH97b/paper.ps.gz
Refering-URL: http://www.cs.toronto.edu/~vassos/research/list-of-publications.html
Root-URL: 
Email: wklo@cs.utoronto.ca  vassos@cs.utoronto.ca  
Title: On the power of shared object types to implement one-resilient Consensus  
Author: Wai-Kau Lo Vassos Hadzilacos 
Abstract: In this paper we study the ability of shared object types to implement Consensus in asynchronous shared-memory systems where at most one process may crash. More specifically, we consider the following question: Let n 3 and S be a set of object types that can be used to solve one-resilient Consensus among n processes. Can S always be used to solve one-resilient Consensus among n 1 processes? We prove that for n = 3 the answer is negative, even if S consists only of deterministic types. (This strengthens an earlier result by the first author proving the same fact for nondeterministic types.) We also prove that, in contrast, for n &gt; 3 the answer to the above question is affirmative. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Elizabeth Borowsky and Eli Gafni. </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations. </title> <booktitle> In Proceedings of the Twenty-Fifth ACM Symposium on Theory of Computing, </booktitle> <pages> pages 91-100, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This holds even if S may contain nondeterministic types. The proof of this result is based on a simulation similar to the ones used by Borowsky and Gafni <ref> [1] </ref> and Chandra et al. [3]. Our simulation has some novel aspects, however. Shared: Active: array [0::s 1] of register, each is a Boolean variable, initially false Closed : register, a Boolean variable, initially false Done: register, a Boolean variable, initially false test&set. <p> Type dor defined in Section 2 is the only deterministic type we know of that is at level one of the Consensus hierarchy and has no one-resilient implementation for three or more processes using only registers. The simulation sketched in Section 3.2 was first used by Borowsky and Gafni <ref> [1] </ref>, and later by Chandra et al. [3]. The main innovation here is the TAS register implementation of Section 3.1. Borowsky and Gafni used a simulation that requires processes to agree on the outcome of each step by solving (a restricted form of) Consensus using only (read/write) registers.
Reference: [2] <author> James Burns and Nancy Lynch. </author> <title> Mutual exclusion using indivisible reads and writes. </title> <booktitle> In Proceedings of Eighteenth Annual Allerton Conference on Communications, Control and Computing, </booktitle> <pages> pages 833-842, </pages> <year> 1980. </year>
Reference-contexts: An implementation of TAS registers for s 2 processes Q 0 ; : : : ; Q s1 with the limited blocking property is shown in Figure 4. It is based on a mutual exclusion algorithm discovered independently by Burns and Lynch <ref> [2] </ref>, and Lamport [9]. A shared variable Closed , initially false, is used to record whether a test&set has already been invoked on the TAS register. To apply a test&set, a process first checks if Closed is true (meaning, that a test&set has been invoked).
Reference: [3] <author> Tushar Chandra, Vassos Hadzilacos, Prasad Jayanti, and Sam Toueg. </author> <title> Wait-freedom versus t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Thus, prima facie it appears possible that a set of types is strong enough to solve t-resilient Consensus among n processes, but too weak to solve t-resilient Consensus among n 1 processes. The question of whether this is possible was studied by Chandra et al. <ref> [3] </ref>. They showed that, for any integers n and t such that n 1 &gt; t 2, any set of types strong enough to solve t-resilient Consensus among n processes, is also strong enough to solve t-resilient Consensus among n 1 processes. <p> This special case is an important one since, in practice, handling a single failure is often an adequate degree of fault-tolerance [13]. In a subsequent paper, the first author considered this special case and proved that the restriction to t 2 is necessary for the above-cited result of <ref> [3] </ref>. Specifically, in [10] he exhibited a nondeterministic type wor with the following property: Using only wor objects and registers, it is possible to implement one-resilient Consensus for three, but not for two, processes. <p> This holds even if S may contain nondeterministic types. The proof of this result is based on a simulation similar to the ones used by Borowsky and Gafni [1] and Chandra et al. <ref> [3] </ref>. Our simulation has some novel aspects, however. Shared: Active: array [0::s 1] of register, each is a Boolean variable, initially false Closed : register, a Boolean variable, initially false Done: register, a Boolean variable, initially false test&set. <p> The simulation outlined above uses an unbounded number of TAS registers (one for each potential step of the simulated algorithm). In the full paper we show how to rectify this shortcoming, by using "resettable" TAS registers. 4 Conclusion The results of this paper, together with those in <ref> [3] </ref>, completely characterise the relationship between the solvability of Consensus among different numbers of processes. <p> The simulation sketched in Section 3.2 was first used by Borowsky and Gafni [1], and later by Chandra et al. <ref> [3] </ref>. The main innovation here is the TAS register implementation of Section 3.1. Borowsky and Gafni used a simulation that requires processes to agree on the outcome of each step by solving (a restricted form of) Consensus using only (read/write) registers.
Reference: [4] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: We use the bivalence argument of <ref> [4] </ref> to prove the existence of B and O.
Reference: [5] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This object type has another interesting property: To our knowledge it is the only known deterministic type at level one of the Consensus hierarchy <ref> [5] </ref> which cannot be implemented in a one-resilient manner for three or more processes using only registers. 1 In Section 3, on the other hand, we show that for any n 4, a set of (deterministic or nondeterministic) types strong enough to implement one-resilient Consensus among n processes is also strong <p> We conclude in Section 4. The model of shared objects used in this paper is a standard one <ref> [5] </ref>, and we do not detail it in this extended abstract. Due to space restrictions, all proofs have been omitted. <p> can implement wait-free (i.e., (n 1)- resilient) Consensus among n processes using only objects of that type and registers. (If there is no such maximum, the level of the type in the Consensus hierarchy is 1.) The significance of this hierarchy lies in the following fundamental result, due to Herlihy <ref> [5] </ref>: If a type T is at level n of the Consensus hierarchy, then it is possible to use only objects of type T and registers to give a wait-free implementation of any object type in a system of n processes. 2 The (exceptional) case of three processes In this section <p> Besides this characterisation, these results also reveal a qualitative difference between level one and other levels of the Consensus hierarchy <ref> [5, 7] </ref>. If S contains an object type at level two or above of the Consensus hierarchy, the result of Chandra et al. implies that the statement above is valid.
Reference: [6] <author> Maurice P. Herlihy and Jeannette M. Wing. Lin-earizability: </author> <title> A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference: [7] <author> Prasad Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 145-158, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Besides this characterisation, these results also reveal a qualitative difference between level one and other levels of the Consensus hierarchy <ref> [5, 7] </ref>. If S contains an object type at level two or above of the Consensus hierarchy, the result of Chandra et al. implies that the statement above is valid.
Reference: [8] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference: [9] <author> Leslie Lamport. </author> <title> The mutual exclusion problem: Parts I & II. </title> <journal> Journal of the ACM, </journal> <volume> 33(2) </volume> <pages> 313-348, </pages> <year> 1986. </year>
Reference-contexts: An implementation of TAS registers for s 2 processes Q 0 ; : : : ; Q s1 with the limited blocking property is shown in Figure 4. It is based on a mutual exclusion algorithm discovered independently by Burns and Lynch [2], and Lamport <ref> [9] </ref>. A shared variable Closed , initially false, is used to record whether a test&set has already been invoked on the TAS register. To apply a test&set, a process first checks if Closed is true (meaning, that a test&set has been invoked). If so, the process immediately returns 1.
Reference: [10] <author> Wai-Kau Lo. </author> <title> More on t-resilence vs. </title> <booktitle> wait-freedom. In Proceedings of the Fourteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 110-119, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: In a subsequent paper, the first author considered this special case and proved that the restriction to t 2 is necessary for the above-cited result of [3]. Specifically, in <ref> [10] </ref> he exhibited a nondeterministic type wor with the following property: Using only wor objects and registers, it is possible to implement one-resilient Consensus for three, but not for two, processes. <p> In this paper we complete the study of the special case of t = 1, focusing on the ability of object types to solve one-resilient Consensus. The rest of the paper is organised as follows: In Section 2, we strengthen the result of <ref> [10] </ref> by exhibiting a deterministic type that can be used (together with registers) to implement one-resilient Consensus for three processes, but not for two processes. <p> In particular, it is impossible to reliably determine whether 0 or 1 was the "winner" (i.e., was enrolled first). The nondeterministic type wor described in <ref> [10] </ref> did this by defining an "upset" state that the object enters if not accessed as required by the algorithm described above. The object responds by non-deterministically returning 0 or 1 if queried about the winner while in that state. <p> and registers. 2.3 ... nor is it too strong In this subsection we show that, using only objects of type dor and registers, we cannot solve wait-free Consensus for two processes. (Recall that the concepts of wait-freedom and one-resilience coincide for two-process algorithms.) The argument uses a technique introduced in <ref> [10] </ref>, and is outlined below. Assume, by way of contradiction, that there exists a wait-free Consensus algorithm A for processes P 0 and P 1 that uses only objects of type dor and registers. <p> The idea is very similar to the algorithm used in <ref> [10] </ref>: Each process Q k simulates the actions of the corresponding process P k in an execution of A, and uses this execution to determine what value to decide.
Reference: [11] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> On the power of shared object types to implement one-resilient consensus. </title> <type> Technical Report CSRI-357, </type> <institution> University of Toronto, Toronto, On-tario, Canada, </institution> <month> January </month> <year> 1997. </year> <note> Available at ftp://ftp.cs.utoronto.ca.pub/reports/csri/357. </note>
Reference-contexts: The model of shared objects used in this paper is a standard one [5], and we do not detail it in this extended abstract. Due to space restrictions, all proofs have been omitted. Full details may be found in a technical report that is available electronically <ref> [11] </ref>. 1 The level of a type in the Consensus hierarchy is the maximum positive integer n such that we can implement wait-free (i.e., (n 1)- resilient) Consensus among n processes using only objects of that type and registers. (If there is no such maximum, the level of the type in
Reference: [12] <author> Michael Loui and Hosame Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <booktitle> In Advances in Computer Research, </booktitle> <volume> volume 4, </volume> <pages> pages 163-183. </pages> <publisher> JAI Press Inc., </publisher> <year> 1987. </year>
Reference-contexts: Assume, further, that A uses a minimal number of dor objects. (This number is finite because the algorithm is wait-free, it uses only deterministic types, and in Consensus each process has only finitely many different input values.) Since wait-free Consensus for two processes is not solvable using only registers <ref> [12] </ref>, it follows that A uses at least one dor object. To derive a contradiction, we proceed in two stages.
Reference: [13] <author> Michael Stumm and Songnian Zhou. </author> <title> Fault tolerant distributed shared memory. </title> <booktitle> In Proceedings of the Second IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 719-724, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The case of t = 1 was left open in that investigation. This special case is an important one since, in practice, handling a single failure is often an adequate degree of fault-tolerance <ref> [13] </ref>. In a subsequent paper, the first author considered this special case and proved that the restriction to t 2 is necessary for the above-cited result of [3].
References-found: 13

