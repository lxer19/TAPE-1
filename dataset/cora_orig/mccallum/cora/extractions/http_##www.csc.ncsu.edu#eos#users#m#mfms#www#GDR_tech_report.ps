URL: http://www.csc.ncsu.edu/eos/users/m/mfms/www/GDR_tech_report.ps
Refering-URL: http://www.csc.ncsu.edu/eos/users/m/mfms/www/publications.html
Root-URL: http://www.csc.ncsu.edu
Title: GDR: A VISUALIZATION TOOL FOR GRAPH ALGORITHMS  
Author: MATTHIAS STALLMANN RANCE CLEAVELAND AND PRASHANT HEBBAR 
Abstract-found: 0
Intro-found: 1
Reference: [Baa88] <author> Sara Baase. </author> <title> Computer Algorithms: Introduction to Design and Analysis, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference: [BK87] <author> J. L. Bentley and B. W. Kernighan. </author> <title> A system for algorithm animation: Tutorial and user manual. </title> <type> Computing Science Technical Report 132, </type> <institution> AT&T Bell Laboratories, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: The features that distinguish GDR from other, simpler animation tools include its object-oriented design, its portability, and its fully interactive nature. In contrast to the system proposed by Bentley and Kernighan <ref> [BK87] </ref>, GDR provides high-level primitives for manipulating the basic objects (graphs, edges and labels) in graphs; the user is insulated from low-level details involving specific data structures and graphical operations.
Reference: [Bro87] <author> Marc H. Brown. </author> <title> Algorithm Animation. </title> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Related Work. In the remainder of this section we compare and contrast GDR with other animation packages. The most sophisticated of these is the BALSA system <ref> [Bro87] </ref>, which provides a very flexible tool for developing detailed graph animations. The system is much more advanced than tools like GDR, but a drawback is that it is difficult to use; developing animations requires a knowledgeable technical staff.
Reference: [BS89] <author> B. Birgisson and G. E. Shannon. GraphView: </author> <title> An extensible interactive platform for manipulating and displaying graphs. </title> <type> Technical Report 295, </type> <institution> Computer Science Department, Indiana University, </institution> <month> December </month> <year> 1989. </year>
Reference: [CLR90] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Suppose we want to design a simple animation to illustrate depth-first search on directed graphs. We begin by writing a C program that implements depth-first search | the program that we use is based on the description in Cormen, Leiserson, and Rivest <ref> [CLR90] </ref>, x 23.3. Figure 6 shows the recursive function called as each vertex is visited. The only part of the code that is consciously written with GDR in mind is the header of the for_adjacent loop, which uses the macro described in Figure 5. <p> by an #include "gr.h" at the beginning and a definition of the function animat at the end, in this case with a call to the driver: void animat () -DFS ();- To test the program on an example, one draws an example using GDR | we'll use the one in <ref> [CLR90] </ref>, page 479. The GDR drawing is shown in Figure 9. Recall that the ordering of the adjacency lists affects the order in which vertices are visited during depth-first search. In our example we sought to reproduce the sequence illustrated in Figure 23.4 of [CLR90]. <p> | we'll use the one in <ref> [CLR90] </ref>, page 479. The GDR drawing is shown in Figure 9. Recall that the ordering of the adjacency lists affects the order in which vertices are visited during depth-first search. In our example we sought to reproduce the sequence illustrated in Figure 23.4 of [CLR90].
Reference: [CPSar] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> To appear. </note>
Reference-contexts: Thus, programmers desiring to build systems that interface with vtview need not know the specifics of the data structures used to represent networks. At the moment, one such tool is being built that translates networks created using vtview into a format recognizable by the Concurrency Workbench <ref> [CPSar] </ref>, a system for verifying concurrent systems. Another tool is being planned that would permit the graphical simulation of networks designed in vtview. As with GDR, vtview is designed to be highly portable.
Reference: [DET93] <author> G. Di Battista, P. Eades, and R. Tamassia. </author> <title> Algorithms for drawing graphs: An annotated bibliography. </title> <note> Available by anonymous ftp from wilma.cs.brown.edu: files /pub/gdbiblio.tex.Z and /pub/gdbiblio.ps.Z, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: Moreover the current version of GDR has no facility for reading a logical graph as input and creating a drawing of it from scratch. The issue of creating aesthetically pleasing drawings of graphs has been studied extensively (Di Battista, Eades, and Tamassia <ref> [DET93] </ref> give an annotated bibliography of recent results). There are actually two issues for GDR here. One is the conversion of the logical representation of a graph obtained from another source to a physical (and logical) representation that can be manipulated by GDR.
Reference: [Ebe87] <author> J. Ebert. </author> <title> A versatile data structure for edge-oriented graph algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 30(6):513 - 519, </volume> <year> 1987. </year>
Reference-contexts: Internal access to the graph occurs when the animation (the program compiled and linked with GDR) is executed via the RUN FILE menu command. The paradigm for accessing the graph is edge oriented <ref> [Ebe87] </ref>, meaning that each vertex has access to a list of its incident edges (and multiple edges and loops are allowed). Table 4 shows the functions that may be used to access the logical structure of the current graph, while Table 5 shows those that modify logical graph attributes.
Reference: [JG89] <author> D. Jablonowski and V. A. Guarna, Jr. </author> <title> GMB: A tool for manipulating and animating graph data structures. </title> <journal> Software Practice and Experience, </journal> <volume> 19(3):283 - 301, </volume> <year> 1989. </year>
Reference-contexts: In contrast to the system proposed by Bentley and Kernighan [BK87], GDR provides high-level primitives for manipulating the basic objects (graphs, edges and labels) in graphs; the user is insulated from low-level details involving specific data structures and graphical operations. Two other animation packages|GMB, developed by Jablonowski and Guarna <ref> [JG89] </ref>, and GraphView, developed by Birgisson and Shannon [BS89]|are integrated systems rather than stand-alone tools; that is, the user or programmer is required to adopt the underlying abstract data types, and to develop graph representations entirely on the system.
Reference: [Mar91] <author> J. C. Martin. </author> <title> Introduction to Languages and the Theory of Computation. </title> <publisher> McGraw-Hill, Inc., </publisher> <year> 1991. </year>
Reference: [MSGS88] <author> J. Malhotra, S.A. Smolka, A. Giacalone, and R. Shapiro. Winston: </author> <title> A tool for hierarchical design and simulation of concurrent systems. </title> <booktitle> In Proceedings of the Workshop on Specification and Verification of Concurrent Systems, Stirling, </booktitle> <address> Scotland, </address> <year> 1988. </year>
Reference-contexts: The tool allows users to define networks consisting of sites connected to one another using communication links; each site may itself contain a network or an individual process in the form of a finite-state machine. In contrast with other graphical design tools <ref> [MSGS88, RdS90] </ref>, vtview provides a true abstraction and modularization mechanism while permitting bottom-up as well as top-down system design. vtview is intended to be a tool that can be interfaced with other tools for analyzing and verifying concurrent systems.
Reference: [RdS90] <author> V. Roy and R. de Simone. AUTO/Autograph. </author> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pages 477-491, </pages> <year> 1990. </year>
Reference-contexts: The tool allows users to define networks consisting of sites connected to one another using communication links; each site may itself contain a network or an individual process in the form of a finite-state machine. In contrast with other graphical design tools <ref> [MSGS88, RdS90] </ref>, vtview provides a true abstraction and modularization mechanism while permitting bottom-up as well as top-down system design. vtview is intended to be a tool that can be interfaced with other tools for analyzing and verifying concurrent systems.

References-found: 12

