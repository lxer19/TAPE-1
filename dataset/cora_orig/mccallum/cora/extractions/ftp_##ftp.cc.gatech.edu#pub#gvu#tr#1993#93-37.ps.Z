URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1993/93-37.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1993/
Root-URL: 
Email: -martin,foley-@cc.gatech.edu  
Title: INTERVIEW  
Author: Martin R. Frank James D. Foley 
Keyword: User Interface Management Systems. Model-based User Interface Design.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: Graphics, Visualization and Usability Center College of Computing, Georgia Institute of Technology  
Note: BY EXAMPLE AND BY  
Abstract: 1 (This is technical report GIT-GVU-93-37. Cite as Frank, M. and J. Foley, Model-Based User Interface Design by Example and by Interview, Proceedings of UIST93, ACM Symposium on User Interface Software and Technology, Nov. 1993.) MODEL-BASED USER INTERFACE DESIGN ABSTRACT Model-based user interface design is centered around a description of application objects and operations at a level of abstraction higher than that of code. A good model can be used to support multiple interfaces, help separate interface and application, describe input sequencing in a simple way , check consistency and completeness of the interface, evaluate the interfaces speed-of-use, generate contextspecific help and assist in designing the interface. However , designers rarely use computer-supported application modelling today and prefer less formal approaches such as story boards of user interface prototypes. One reason is that available tools often use cryptic languages for the model specification. Another reason is that these tools force the designers to specify the application model before they can start working on the visual interface, which is their main area of expertise. We present the Interactive User Interface Design Environment (Interactive UIDE), a novel framework for concurrent development of the application model and the user interface which combines storyboarding and model-based interface design. We also present Albert, an intelligent component within this framework, which is able to infer an application model from a user interface and from an interview process with the designer. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Foley, J., W. Kim, S. Kovacevic, and K. </author> <title> Murray , Defining Interfaces at a High Level of Abstraction, </title> <journal> IEEE Software, </journal> <volume> 6(1), </volume> <month> Jan. </month> <year> 1989, </year> <pages> pp. 25-32. </pages>
Reference-contexts: Application objects group commands and simple objects (variables) into a semantically meaningful entity. The data flow constraints are the control element in the model; they specify the dependencies between inputs, variables and objects. Interactive UIDE is based on ideas from the original UIDE <ref> [1] </ref>. The major differences are the departure from a model-first methodology, the concurrent editing of interface and model, and the intelligent component for interactive interface building, model building and consistency checking.
Reference: [2] <author> K i m , W. </author> <title> a n d J . F o l e y , D O N : U s e r I n t e r f a c e Presentation Design Assistant, Proceedings of U IS T 90 , AC M Sy m p osi um o n U se r I nte r fa ce Software and Technology, </title> <address> Oct. </address> <year> 1990, </year> <pages> pp. </pages> <month> 10-20. </month> <title> Top-Down And Bottom-Up Design Interface Model Interface-First Methodology Model-First Methodology Model Model Interface Interface Model Interface Time 1 2 1 Computer-Supported Application Model Inference 2 User Interface Generation 3 Computer-Supported Concurrent Development </title>
Reference-contexts: The existing components of UIDE such as the textual help generator [9], the animated help generator [8], and the noninteractive user interface generator <ref> [2] </ref> can still operate within Interactive UIDE. The application modelling language is best explained by an example. W e present a Using Interactive UIDE Phase 2: Write application code in a programming lan guage. Phase 1a: Build the user interface of the intended application using a direct-manipulation tool.
Reference: [3] <author> Khme, T. and M. Schneider-Hufschmidt, </author> <title> SX/Tools - A n O p e n D e s i g n E n v i r o n m e n t f o r A d a p ta b l e Multimedia User Interfaces, </title> <journal> Computer Graphics Forum, </journal> <volume> 11(3), </volume> <month> Sept. </month> <year> 1992, </year> <pages> pp. 93-105. </pages>
Reference-contexts: The glue is a special-purpose language which specifies the linkage between user interface objects and interaction techniques on one side and application model abstractions on the other side. The user interface is edited using an existing interface building tool, SX/T ools <ref> [3] </ref>, which supports designing custom objects in addition to providing predefined standard objects. The application model and the glue are edited in text editors under control of Interactive UIDE so that switching from design mode to run mode is instantaneous.
Reference: [4] <author> Luo, P., P. Szekely and R. </author> <title> Neches, </title> <booktitle> Management Of Interface Design in HUMANOID, Proceedings of INTERCHI93, ACM Conference on Human Factors in Computing Systems, </booktitle> <month> Apr. </month> <year> 1993, </year> <pages> pp. 107-114. </pages>
Reference: [5] <author> Myers, B., </author> <title> Creating User Interfaces By Demonstration, </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: It has no capabilities in natural language generation and understanding. The designer provides answers through selecting interface objects and f illing out forms. When used to infer an application model, our system starts from a user interface example but it is not a by-example approach such as Peridot <ref> [5] </ref> in a strict sense because a user interface example alone is not suf ficient for inferring a semantic application model. However, our approach still shares a similar philosophy. Examples are inherently easier to understand than abstract concepts, and our system makes use of this fact. <p> However, our approach still shares a similar philosophy. Examples are inherently easier to understand than abstract concepts, and our system makes use of this fact. Our system is not a withexample approach. In Myers and Halberts definition <ref> [5] </ref>, programming with example is a generalized macro recording approach, following the philosophy of do what I did rather than the do what I mean philosophy of byexample programming. <p> The inference found in by-example systems and the recording in with-example systems are also limited in their expressiveness; they often cannot handle simple parameters. Pure by-example approaches infer a program from a few examples. Myers observed that this contradicts modern software testing principles <ref> [5] </ref>. According to these principles, a program can never be guaranteed to work correctly if it was tested with a few examples. Consequently , a program inferred from a few examples can also not be guaranteed to implement the desired behavior.
Reference: [6] <author> Olsen, D., MIKE: </author> <title> The Menu Interaction Kontrol Environment, </title> <journal> ACM Transactions on Graphics, </journal> <volume> Vol. 5, No. 1, </volume> <month> Oct. </month> <year> 1986, </year> <pages> pp. 318-344. </pages>
Reference-contexts: THE APPLICATION MODEL We will now discuss in more detail what an application model is and how our model compares to previous models. This section reviews previous work and explains the structure and use of our model. MIKE <ref> [6] </ref> is one of the oldest user interface management systems which supports graphical user interfaces. Its application model consists of actions and their parameters. The parameters are of predefined types like String and Point, or applicationspecific types such as Resistor and W ire for a circuit design application.
Reference: [7] <author> Singh, G. and M. Green, </author> <title> A High-Level User Interface Management System, Proceedings of CHI89, ACM Co n fe re n c e on H um a n F a c t or s i n Co m p ut in g Systems, </title> <month> May </month> <year> 1989, </year> <pages> pp. 133-138. </pages>
Reference-contexts: Phase 3a: T une the generated user interface using a direct manipulation interface builder. Phase 3b: Write application code in a programming language. example, it is not possible to state that a wire is an object which consists of two references to connection points. UofA*s <ref> [7] </ref> application model also consists of actions and parameters and is similar in spirit to MIKE s model. The designer can define application-specific types only in a very limited sense by specifying ranges. For example, an Angle type can be defined as Angle=[0:360].
Reference: [8] <author> Sukaviriya, P. and J. Foley, </author> <title> Coupling a User Interface Framework with Automatic Generation of Context-Sensitive Animated Help, </title> <booktitle> Proceedings of UIST90, ACM Symposium on User Interface Softwar e and Technology, </booktitle> <month> Oct. </month> <year> 1990, </year> <pages> pp. 152-166. </pages>
Reference-contexts: The major differences are the departure from a model-first methodology, the concurrent editing of interface and model, and the intelligent component for interactive interface building, model building and consistency checking. The existing components of UIDE such as the textual help generator [9], the animated help generator <ref> [8] </ref>, and the noninteractive user interface generator [2] can still operate within Interactive UIDE. The application modelling language is best explained by an example. W e present a Using Interactive UIDE Phase 2: Write application code in a programming lan guage.
Reference: [9] <author> Sukaviriya, P., J. Foley and T. Griffith, </author> <title> A Second Generation User Interface Design Environment: The Model And The Runtime Architecture, </title> <booktitle> Proceedings of INTERCHI93, ACM Confer ence on Human Factors in Computing Systems, </booktitle> <month> Apr. </month> <year> 1993, </year> <pages> pp. 375-382. </pages>
Reference-contexts: Examples of model-based user interface manage-m e n t s y s t e m s ( U I M S ) a r e U I D E <ref> [ 1 , 9 ] </ref> a n d H U - MANOID [4,10,11], which both use high-level objectori-ented application models. <p> The major differences are the departure from a model-first methodology, the concurrent editing of interface and model, and the intelligent component for interactive interface building, model building and consistency checking. The existing components of UIDE such as the textual help generator <ref> [9] </ref>, the animated help generator [8], and the noninteractive user interface generator [2] can still operate within Interactive UIDE. The application modelling language is best explained by an example. W e present a Using Interactive UIDE Phase 2: Write application code in a programming lan guage.
Reference: [10] <author> Szekely, P., P. Luo and R. Neches, </author> <title> Facilitating the Exploration of Interface Design Alternatives: The H U M A N O I D M o d e l o f I n t e r f a c e D e s i g n , Proceedings of CHI92, </title> <booktitle> ACM Conference on Human Factors in Computing Systems , May 1992, </booktitle> <pages> pp. 507-515. </pages>
Reference-contexts: For example, an employee record can be declared to consist of a name of type string, an address of type address and a manager of type employee. The interface generator can then create a dialog box for displaying such a record. HUMANOIDs <ref> [10] </ref> model consists of commands, objects, global variables and data flow constraints. Commands have associated inputs (parameters) and preconditions for their applicability. An input describes one parameter of a command by defining its type, a predicate for semantic input validation and other properties.
Reference: [11] <author> Szekely, P., P. Luo and R. Neches, </author> <title> Beyond Interface Builders: Model-Based Interface Tools, </title> <booktitle> Proceedings of INTERCHI93, ACM Confer ence on Human Factors in Computing Systems, </booktitle> <month> Apr. </month> <year> 1993, </year> <pages> pp. 383-390. </pages>
Reference: [12] <author> Wiecha, C. and S. Boies, </author> <title> Generating User Interfaces: Principles and Use of ITS Style Rules, Proceedings of U I ST 90 , A CM S ym p os ium on U se r I nt er fa c e Software and Technology, </title> <address> Oct. </address> <year> 1990, </year> <pages> pp. 21-30. </pages>
Reference-contexts: For example, an Angle type can be defined as Angle=[0:360]. From a programming language perspective, the designer can use predef ined simple types like boolean and integer ranges but cannot define classes or records. ITS <ref> [12] </ref> is a user interface management environment consisting of four layers: user interface primitives like buttons and choice boxes, a rule-based user interface generator , a dialog control component, and application routines. Its main contribution is the encoding of user interface style rules. <p> For example, standard user interface design knowledge can be encoded in our questions so that this knowledge can be accessed and applied by people other than user interface designers. This is similar in spirit to ITS style rules <ref> [12] </ref> but augmented with the interactive interface to the knowledge. In this way, interface design knowledge is not only automatically applied, but the process is also visible and understandable to the designers so that they learn about interface design themselves while using the system.
References-found: 12

