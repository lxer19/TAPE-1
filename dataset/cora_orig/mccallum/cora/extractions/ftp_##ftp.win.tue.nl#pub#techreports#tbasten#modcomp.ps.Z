URL: ftp://ftp.win.tue.nl/pub/techreports/tbasten/modcomp.ps.Z
Refering-URL: http://wwwis.win.tue.nl/~tbasten/publications.html
Root-URL: http://www.win.tue.nl
Email: E-mail: tbasten@win.tue.nl  
Title: Event Abstraction in Modeling Distributed Computations  
Author: Twan Basten 
Keyword: Key words: event abstraction causality- partial order (reversed) vector time partially ordered multiset pomset grammar pomset LR parsing.  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology,  
Abstract: A well-known problem in event-based models of distributed computations is the amount and complexity of behavioral information. Event abstraction can be used to reduce the apparent complexity of a computation. Four aspects of event abstraction are studied: a model describing primitive behavior, a formalism for specifying abstract behavior, abstract descriptions of behavior, and verification of primitive or abstract descriptions against specified behavior. This paper discusses the issues involved in each of these four aspects, presents basic results, and identifies remaining problems.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, USA, </address> <year> 1988. </year>
Reference-contexts: In order to construct new pomsets from other pomsets and, subsequently, new pomset languages from other pomset languages, the following two operators on pomsets are introduced. Definition 3.2. Let M 0 = [V 0 ; 0 ; 0 ; 0 ] and M 1 = <ref> [V 1 ; 1 ; 1 ; 1 ] </ref> be pomsets. Without loss of generality, it is assumed that V 0 and V 1 are disjoint. <p> Theorem 5.8. The class of pomset languages generated by SCFPGs coincides with the class of regular pomset languages. 5.2 An introduction to PLR parsing In the area of compiler design, many parsing algorithms have been developed. Well-known algorithms are those based on the LL- and LR-parsing techniques <ref> [1, 17] </ref>. Theoretically, LR parsers are the most powerful and most general class of deterministic parsing algorithms. In practice, LR parsers have one disadvantage. For large grammars, the amount of storage required for an implementation is very large.
Reference: 2. <author> A.A. Basten. </author> <title> Hierarchical Event-Based Behavioral Abstraction in Interactive Distributed Debugging: A Theoretical Approach. </title> <type> Master's thesis, </type> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, </institution> <address> The Netherlands, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Definition 3.2. Let M 0 = [V 0 ; 0 ; 0 ; 0 ] and M 1 = [V 1 ; 1 ; 1 ; 1 ] be pomsets. Without loss of generality, it is assumed that V 0 and V 1 are disjoint. Pomset <ref> [V 2 ; 2 ; 2 ; 2 ] </ref> is the sequential composition of M 0 and M 1 , denoted M 0 M 1 , or sometimes M 0 ; M 1 , if and only if V 2 = V 0 [ V 1 , 2 = 0 [ <p> Furthermore, the class of languages recognized by predecessor automata is fairly limited. The main reason for this being that the input to predecessor automata can be ambiguous. A more detailed discussion of predecessor automata including references to relevant literature can be found in <ref> [2, pages 64-67] </ref>. Since the results of the automata-theoretic approach are rather disappointing, this section investigates the parsing approach. <p> A CFPG G = (N ; T ; R; S) is simple if and only if R N fi (V fl &V fl ). The next theorem shows that SCFPGs are powerful enough to generate the entire class of regular pomset languages. The proof can be found in <ref> [2, page 72] </ref>. The proof is also of practical use because it describes transformations from concurrent regular expressions to SCFPGs. Theorem 5.8. <p> In <ref> [2, Sections 4.3 and 4.4] </ref>, the process is for-malized yielding a PLR (0) algorithm and a proposal for a PLR (1) algorithm. As in other parsing formalisms, the numbers denote the number of lookahead symbols used to determine parsing actions. <p> In addition, the PLR-parsing formalism needs to be adapted to recognize subpomsets. Besides adapting PLR parsing to event abstraction, the formalism itself needs to be further developed. The PLR (0) algorithm given in <ref> [2, Section 4.3] </ref> only recognizes a very limited class of pomset languages. The PLR (1) algorithm [2, Section 4.4] is only a proposal. A formal correctness proof is needed and the class of languages recognized by this algorithm needs to be studied. Other PLR-parsing algorithms might be needed. <p> In addition, the PLR-parsing formalism needs to be adapted to recognize subpomsets. Besides adapting PLR parsing to event abstraction, the formalism itself needs to be further developed. The PLR (0) algorithm given in [2, Section 4.3] only recognizes a very limited class of pomset languages. The PLR (1) algorithm <ref> [2, Section 4.4] </ref> is only a proposal. A formal correctness proof is needed and the class of languages recognized by this algorithm needs to be studied. Other PLR-parsing algorithms might be needed.
Reference: 3. <author> A.A. Basten, T. Kunz, J.P. Black, M.H. Coffin, </author> <title> and D.J. Taylor. Time and the Order of Abstract Events in Distributed Computations. </title> <note> To appear. 18 </note>
Reference-contexts: A discussion of other models of synchronous communication can be found in <ref> [3, Section 2.1] </ref>. The relation can be used to express concurrency in a natural way. Two events e 0 ; e 1 2 E are concurrent if and only if e 0 6 e 1 and e 1 6 e 0 . <p> Theorem 2.3. For any i 2 P and events e 0 2 E i and e 1 2 E, e 0 e 1 , T:e 0 :i T:e 1 :i. A simple proof of these theorems and an algorithmic definition of the timestamp function can be found in <ref> [3, Section 2.2] </ref>. An example of the assignment of vector timestamps to events is given in Figure 1. For this example, the validity of the two precedence tests given above is easily verified. The vertical lines represent processes. Time increases from top to bottom. Events are depicted as dots. <p> For any A E, T:A = (SUP a : a 2 A : T:a), where the quantifier SUP is defined as the componentwise maximum. It can be shown that this timestamp is an encoding of the end of an abstract event <ref> [3] </ref>. This means that it is possible to improve the efficiency of determining precedence among abstract events. Furthermore, the associativity of the quantifier SUP implies that the timestamp of an abstract event is equal to the supremum of the timestamps of its constituents. <p> The beginning of an abstract event A in terms of ordinary vector time is given by the expression E T R :A, where vector E is a constant such that for every i 2 P, E:i = jE i j. In <ref> [3] </ref>, it is shown that reversed vector time yields the following precedence test. Theorem 4.8. For abstract events A and B, A B , E T R :A 6 T:B. The number of integer comparisons for this test is at most N . <p> However, unlike this test, the tests in Theorem 4.9 are independent of the primitive level of the abstraction hierarchy. Summarizing, this section presents two timestamps and some precedence tests for arbitrary abstract events in terms of these timestamps. In <ref> [3] </ref>, these results are further improved and applied to a subclass of abstract events, so-called convex abstract events.
Reference: 4. <author> P.C. Bates. </author> <title> Shu*e Automata: A Formal model for Behavior Recognition in Distributed Systems. </title> <type> COINS Technical Report 87-27, </type> <institution> University of Massachusetts, Computer and Information Science Department, Amherst, Massachusetts, USA, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: The analogy with language theory suggests the following two approaches: the automata-theoretic approach and the parsing approach. Bates <ref> [4] </ref> describes an automata-theoretic model for recognizing abstract events, called shu*e automata. However, shu*e automata are not useful for our purposes. First, they cannot be used to recognize true concurrency. Only the interleaving, or shu*e, of events can be recognized.
Reference: 5. <author> P.C. Bates. </author> <title> Debugging Heterogeneous Distributed Systems using Event-Based Models of Behavior. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 11-22, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns <ref> [5, 23] </ref>. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful. Such causal relationships can be expressed in terms of precedence.
Reference: 6. <author> P.C. Bates and J.C. Wileden. EDL: </author> <title> A Basis for Distributed System Debugging Tools. </title> <booktitle> In Proceedings of the 15th Hawaii International Conference on System Sciences, </booktitle> <volume> volume I, </volume> <pages> pages 86-93, </pages> <address> Honolulu, Hawaii, USA, </address> <month> January </month> <year> 1982. </year>
Reference-contexts: Algorithms that are able to decide whether a pomset belongs to a given pomset language can be used to develop a tool for recognizing occurrences of behavioral patterns in a distributed computation. Many different specification languages based on regular expressions have been developed for many different purposes <ref> [6, 8, 9] </ref>. However, none of them include true-concurrency operators. In [23], Hseush and Kaiser propose Data-Path Expressions, that do include operators modeling true concurrency. Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model.
Reference: 7. <author> J.P. Black, M.H. Coffin, T. Kunz, D.J. Taylor, and A.A. Basten. </author> <title> Linking Specification, Abstraction, and Debugging. </title> <type> CCNG Technical Report E-232, </type> <institution> Computer Communications and Networks Group, University of Waterloo, </institution> <address> Ontario, Canada, </address> <month> November </month> <year> 1993. </year> <note> Submitted 1993.11.04 to IBM Systems Journal, 26pp in ms. </note>
Reference-contexts: Consequently, obtaining detailed information about program behavior is a hard and tedious process. A powerful way to reduce the apparent complexity of a computation and, therefore, improve the process of obtaining behavioral information is abstraction <ref> [7] </ref>. This paper discusses one type of abstraction, namely event abstraction. Events are grouped together into higher-level abstract events, hiding their internal causal structure. Doing so, the programmer can obtain simpler, abstract views of program behavior, and focus only on information that is to his or her interest.
Reference: 8. <author> B. Bruegge and P. Hibbard. </author> <title> Generalized Path Expressions: A High-Level Debugging Mechanism. </title> <journal> The Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 265-276, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Algorithms that are able to decide whether a pomset belongs to a given pomset language can be used to develop a tool for recognizing occurrences of behavioral patterns in a distributed computation. Many different specification languages based on regular expressions have been developed for many different purposes <ref> [6, 8, 9] </ref>. However, none of them include true-concurrency operators. In [23], Hseush and Kaiser propose Data-Path Expressions, that do include operators modeling true concurrency. Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model.
Reference: 9. <author> R.H. </author> <title> Campbell and A.N. Habermann. The Specification of Process Synchronization by Path Expressions. </title> <editor> In E. Gelenbe and C. Kaiser, editors, </editor> <booktitle> Operating Systems, volume 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1974. </year>
Reference-contexts: Algorithms that are able to decide whether a pomset belongs to a given pomset language can be used to develop a tool for recognizing occurrences of behavioral patterns in a distributed computation. Many different specification languages based on regular expressions have been developed for many different purposes <ref> [6, 8, 9] </ref>. However, none of them include true-concurrency operators. In [23], Hseush and Kaiser propose Data-Path Expressions, that do include operators modeling true concurrency. Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model.
Reference: 10. <author> K.M. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: And, due to unknown communication delays or unreliable communication channels, program behavior may vary for every execution. To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms <ref> [10, 22, 25, 29] </ref>, predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations.
Reference: 11. <author> B. Charron-Bost. </author> <title> Combinatorics and Geometry of Consistent Cuts: Application to Concurrency Theory. </title> <editor> In J.-C. Bermond and M. Raynal, editors, </editor> <booktitle> Distributed Algorithms, volume 392 of Lecture Notes in Computer Science, </booktitle> <pages> pages 45-56. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year>
Reference-contexts: The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost <ref> [11, 12] </ref>, and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26].
Reference: 12. <author> B. Charron-Bost, F. Mattern, and G. Tel. </author> <title> Synchronous and Asynchronous Communication in Distributed Computations. </title> <type> Technical Report LITP 91.55, </type> <institution> Institut Blaise Pascal, Universite Paris 7, Paris, France, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost <ref> [11, 12] </ref>, and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26].
Reference: 13. <author> W.-H. Cheung. </author> <title> Process and Event Abstraction for Debugging Distributed Programs. </title> <type> Ph.D. Thesis, CCNG Technical Report T-189, </type> <institution> University of Waterloo, Department of Computer Science, Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1989. </year>
Reference-contexts: The first approach is to restrict the structure of abstract events in such a way that the precedence relation is guaranteed to be a partial order, and then to try to timestamp these restricted abstract events in a meaningful way. This is the approach taken by Cheung <ref> [13] </ref>, Summers [34], and Kunz [24]. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness. The second approach is to allow more flexible abstract events and, and then to try to derive general timestamp schemes.
Reference: 14. <author> R. Cooper and K. Marzullo. </author> <title> Consistent Detection of Global Predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163-173, </pages> <address> Santa Cruz, California, US, USA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms <ref> [14] </ref>, and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations.
Reference: 15. <author> C.J. Fidge. </author> <title> Dynamic Analysis of Event Orderings in Message-Passing Systems. </title> <type> PhD thesis, </type> <institution> Australian National University, Department of Computer Science, Canberra, Australia, </institution> <year> 1989. </year>
Reference-contexts: The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost [11, 12], and Fidge <ref> [15, 16] </ref>. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26]. <p> The precedence relation extends the "happens before" relation as defined by Lamport [26] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [15, 16] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously.
Reference: 16. <author> C.J. Fidge. </author> <title> Logical Time in Distributed Computing Systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost [11, 12], and Fidge <ref> [15, 16] </ref>. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26]. <p> The precedence relation extends the "happens before" relation as defined by Lamport [26] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [15, 16] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously. <p> Since the causality structure of a computation is a partial order, it is not possible to use physical time or any other totally ordered set as a characterization. For this reason, Mattern [29, 30] and Fidge <ref> [16] </ref> independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [26]. Definition 2.1. The function T : E ! IN N defines a timestamp for every event as follows. <p> However, vector representation of timestamps is not essential. If the number of processes is not known, the timestamp of an event can be defined as a set of pairs, where each pair consists of a process identifier and the corresponding timestamp component <ref> [16] </ref>. 3 The following theorems show that vector timestamps characterize causality. For two vectors t 0 ; t 1 2 IN N , we define t 0 t 1 to mean t 0 :i t 1 :i for all i, 0 i &lt; N . Theorem 2.2.
Reference: 17. <author> C.N. Fischer and R.J. LeBlanc, Jr. </author> <title> Crafting a Compiler. </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Menlo Park, California, USA, </address> <year> 1988. </year>
Reference-contexts: Theorem 5.8. The class of pomset languages generated by SCFPGs coincides with the class of regular pomset languages. 5.2 An introduction to PLR parsing In the area of compiler design, many parsing algorithms have been developed. Well-known algorithms are those based on the LL- and LR-parsing techniques <ref> [1, 17] </ref>. Theoretically, LR parsers are the most powerful and most general class of deterministic parsing algorithms. In practice, LR parsers have one disadvantage. For large grammars, the amount of storage required for an implementation is very large.
Reference: 18. <author> J.L. Gischer. </author> <title> The Equational Theory of Pomsets. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 61(2,3):199-224, </address> <month> November </month> <year> 1988. </year>
Reference-contexts: Since the precedence relation in a distributed computation is a partial order, it seems reasonable to require that the multiset of actions of a behavioral pattern also be partially ordered. In other words, a behavioral pattern is a partially ordered multiset, or pomset, of actions. Pomsets <ref> [18, 33] </ref> are attracting more and more interest in distributed and parallel computing. The reason being that they model true concurrency, whereas another well-known model for concur rency, the interleaving model, does not. <p> In terms of distributed computing, sequential and concurrent composition model precedence and concurrency respectively. = CB BA C = B A C C CA The two operators defined above yield an important class of pomsets, called series-parallel pomsets. Gischer <ref> [18] </ref> defines this class as the smallest set of pomsets that contains the empty pomset " and all unit pomsets, and is closed under the two composition operators. The composition operators can easily be translated to equivalent operators on pomset languages. <p> This class is a strict superset of the class of languages defined by regular expressions. Note that by definition, a regular pomset language only contains series-parallel pomsets. The following pomset, defined by Grabowski [19] and Gischer <ref> [18] </ref>, plays an important role in the theory of pomset languages. <p> A A 3 2 A pomset is said to be N-free if and only if it does not have N as a subpomset (possibly after relabeling). This yields the following theorem. The proof is fairly elaborate and can be found in <ref> [18] </ref>. A similar result is proven in [19]. Theorem 3.5. A finite pomset is series-parallel if and only if it is N-free. This theorem yields that a pomset language is regular if and only if all its elements are N-free.
Reference: 19. <author> J. Grabowski. </author> <title> On Partial Languages. </title> <journal> Fundamenta Informaticae, </journal> <volume> 4(2) </volume> <pages> 427-498, </pages> <year> 1981. </year>
Reference-contexts: This class is a strict superset of the class of languages defined by regular expressions. Note that by definition, a regular pomset language only contains series-parallel pomsets. The following pomset, defined by Grabowski <ref> [19] </ref> and Gischer [18], plays an important role in the theory of pomset languages. <p> A A 3 2 A pomset is said to be N-free if and only if it does not have N as a subpomset (possibly after relabeling). This yields the following theorem. The proof is fairly elaborate and can be found in [18]. A similar result is proven in <ref> [19] </ref>. Theorem 3.5. A finite pomset is series-parallel if and only if it is N-free. This theorem yields that a pomset language is regular if and only if all its elements are N-free. The class of regular pomset languages is a strict subset of the class of all pomset languages.
Reference: 20. <author> D. Haban and W. Weigel. </author> <title> Global Events and Global Breakpoints in Distributed Systems. </title> <booktitle> In Proceedings of the 21st Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 166-175, </pages> <address> Kailua-Kona, Hawaii, USA, </address> <month> January </month> <year> 1988. </year> <month> 19 </month>
Reference-contexts: To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities <ref> [20, 28, 31] </ref>, and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful. <p> Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model. There are two more papers that are important in the context of specifying behavioral patterns. Both the papers of Miller and Choi [31] and Haban and Weigel <ref> [20] </ref> describe how behavioral abstraction can be used to incorporate breakpoints in a distributed debugging environment. However, the sets of operators they introduce are different from the set of operators used to build regular expressions.
Reference: 21. <author> D.K. Hammer, J.P.C. Verhoosel, and K.H. Ecker. </author> <title> Refinement of Resource Constrained Executions for Modelling Dynamic System Aspects. This volume. </title>
Reference-contexts: Therefore, if tools for analyzing program behavior are adapted to use abstract descriptions, obtaining interesting information becomes faster and less tedious. The idea of using abstraction and refinement for analyzing and developing distributed applications, in particular real-time and embedded applications, is also expressed in <ref> [21] </ref>. This paper discusses four basic aspects of event abstraction. Section 2 describes primitive observed behavior in terms of events and causality. Section 3 introduces partially ordered multisets for specifying abstract behavior. Section 4 describes abstract behavior in terms of vector time and reversed vector time.
Reference: 22. <author> J.-M. Helary, N. Plouzeau, and M. Raynal. </author> <title> Computing Particular Snapshots in Distributed Systems. </title> <booktitle> In Proceedings of the 9th Annual International Phoenix Conference on Computers and Communications, </booktitle> <pages> pages 116-123, </pages> <address> Scottsdale, Arizona, USA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: And, due to unknown communication delays or unreliable communication channels, program behavior may vary for every execution. To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms <ref> [10, 22, 25, 29] </ref>, predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations.
Reference: 23. <author> W. Hseush and G.E. Kaiser. </author> <title> Moddeling Concurrency in Parallel Debugging. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(3) </volume> <pages> 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns <ref> [5, 23] </ref>. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful. Such causal relationships can be expressed in terms of precedence. <p> Many different specification languages based on regular expressions have been developed for many different purposes [6, 8, 9]. However, none of them include true-concurrency operators. In <ref> [23] </ref>, Hseush and Kaiser propose Data-Path Expressions, that do include operators modeling true concurrency. Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model. There are two more papers that are important in the context of specifying behavioral patterns. <p> Only the interleaving, or shu*e, of events can be recognized. Second, the ordering imposed on events is temporal instead of causal and, therefore, not very meaningful for analyzing causality. Third, like ordinary finite-state automata, shu*e automata can be nondeterministic. Obviously, a deterministic recognition algorithm is preferred. Hseush and Kaiser <ref> [23] </ref> introduce another class of automata, called predecessor automata. For specifying behavioral patterns, they use Data-Path Expressions which are essentially the same as concurrent regular expressions. Therefore, predecessor automata seem useful for recognizing abstract events.
Reference: 24. <author> T. Kunz. </author> <title> Event Abstraction: Some Definitions and Theorems. </title> <type> Technical Report TI-1/93, </type> <institution> Technische Hochschule Darmstadt, Fachbereich Informatik, Darmstadt, Germany, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: This is the approach taken by Cheung [13], Summers [34], and Kunz <ref> [24] </ref>. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness. The second approach is to allow more flexible abstract events and, and then to try to derive general timestamp schemes. This approach is pursued in this subsection.
Reference: 25. <author> T.H. Lai and T.H. Yang. </author> <title> On Distributed Snapshots. </title> <journal> Information Processing Letters, </journal> <volume> 25(3) </volume> <pages> 153-158, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: And, due to unknown communication delays or unreliable communication channels, program behavior may vary for every execution. To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms <ref> [10, 22, 25, 29] </ref>, predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations.
Reference: 26. <author> L. Lamport. </author> <title> Time, Clocks and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost [11, 12], and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport <ref> [26] </ref>. The algebraic structure underlying the model is Winskel's elementary event structure [36]. 2 The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : :; E N1 , where N is the number of processes. <p> Since the restrictions on do not guarantee the absence of cycles in the precedence relation, the set of definitions given so far models a distributed computation if and only if the precedence relation is a partial order. The precedence relation extends the "happens before" relation as defined by Lamport <ref> [26] </ref> to synchronous communication in a natural way. The condition C2, originally given by Fidge [15, 16], means that a synchronous communication can be interpreted as if it occurred instantaneously. <p> For this reason, Mattern [29, 30] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport <ref> [26] </ref>. Definition 2.1. The function T : E ! IN N defines a timestamp for every event as follows. For any event e 2 E and process i 2 P, T:e:i = jfe i 2 E i j e i egj.
Reference: 27. <author> H.R. Lewis and C.H. Papadimitriou. </author> <title> Elements of the Theory of Computation. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, USA, </address> <year> 1981. </year>
Reference-contexts: This means that a pomset is just a string in which the total order is relaxed to a partial order. The theory of strings and their languages has been investigated in great detail (see <ref> [27] </ref> among others). Finite representations of several classes of languages have been developed, such as regular expressions and grammars. Regular expressions have been used to develop specification languages. In addition, algorithms based on regular expressions and grammars have been developed to decide whether a string belongs to a given language. <p> This complicates reasoning about the recognition of occurrences of patterns. 3.2 Pomset language theory This subsection gives an introduction to the fundamentals of pomsets and their languages. The theory is developed analogously to the theory of string languages <ref> [27] </ref>. Based on the definition of pomsets, formal definitions of behavioral patterns and abstract events are given. Definition 3.1.
Reference: 28. <author> Y. Manabe and M. Imase. </author> <title> Global Conditions in Debugging Distributed Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 15(1) </volume> <pages> 62-69, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities <ref> [20, 28, 31] </ref>, and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful.
Reference: 29. <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevier Science Publishers B.V., Amsterdam, North-Holland, </publisher> <address> The Netherlands, </address> <year> 1989. </year>
Reference-contexts: And, due to unknown communication delays or unreliable communication channels, program behavior may vary for every execution. To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms <ref> [10, 22, 25, 29] </ref>, predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. <p> The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern <ref> [29, 30] </ref>, Charron-Bost [11, 12], and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26]. <p> For many applications in distributed computing, it is useful to have a characterization of causality. Since the causality structure of a computation is a partial order, it is not possible to use physical time or any other totally ordered set as a characterization. For this reason, Mattern <ref> [29, 30] </ref> and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [26]. Definition 2.1. The function T : E ! IN N defines a timestamp for every event as follows.
Reference: 30. <author> F. Mattern. </author> <title> On the Relativistic Structure of Logical Time in Distributed Systems. </title> <journal> Bigre, </journal> <volume> 78 </volume> <pages> 3-20, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The set of primitive events E is partially ordered by the ordering relation that models causal precedence. The labeling function maps events to actions in the alphabet fl. The model is based mainly on previous definitions of Mattern <ref> [29, 30] </ref>, Charron-Bost [11, 12], and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26]. <p> For many applications in distributed computing, it is useful to have a characterization of causality. Since the causality structure of a computation is a partial order, it is not possible to use physical time or any other totally ordered set as a characterization. For this reason, Mattern <ref> [29, 30] </ref> and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [26]. Definition 2.1. The function T : E ! IN N defines a timestamp for every event as follows.
Reference: 31. <author> B.P. Miller and J.-D. Choi. </author> <title> Breakpoints and Halting in Distributed Programs. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 316-323, </pages> <address> San Jose, California, USA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior [35], breakpoint facilities <ref> [20, 28, 31] </ref>, and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful. <p> Although the authors do not mention it explicitly, the model underlying Data-Path Expressions is the pomset model. There are two more papers that are important in the context of specifying behavioral patterns. Both the papers of Miller and Choi <ref> [31] </ref> and Haban and Weigel [20] describe how behavioral abstraction can be used to incorporate breakpoints in a distributed debugging environment. However, the sets of operators they introduce are different from the set of operators used to build regular expressions.
Reference: 32. <author> M.K. Ponamgi, W. Hseush, and G.E. Kaiser. </author> <title> Debugging Multithreaded Programs with MPD. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 37-43, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In a distributed computation, an asynchronous message communication typically creates a causal pattern like the pomset N. The literature describes only very little experience with such languages <ref> [32] </ref>. It might be necessary to extend the pomset formalism with a new operator that takes four pomsets as an argument and joins them into one pomset having the structure of the pomset N.
Reference: 33. <author> V.R. Pratt. </author> <title> Modeling Concurrency with Partial Orders. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 15(1) </volume> <pages> 33-71, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: Since the precedence relation in a distributed computation is a partial order, it seems reasonable to require that the multiset of actions of a behavioral pattern also be partially ordered. In other words, a behavioral pattern is a partially ordered multiset, or pomset, of actions. Pomsets <ref> [18, 33] </ref> are attracting more and more interest in distributed and parallel computing. The reason being that they model true concurrency, whereas another well-known model for concur rency, the interleaving model, does not. <p> However, for analyzing causality, the real-time ordering of events is usually not very meaningful. The pomset model does not make the assumption of a real-time ordering and is, therefore, more useful. Pratt discusses the advantages and disadvantages of both models extensively in <ref> [33] </ref>. One way of looking at a pomset is to consider it to be a generalization of a string. A string is nothing but a totally ordered multiset or tomset of symbols taken from some alphabet. <p> Square brackets are used to denote pomsets. For example, [V 0 ; ; 0 ; 0 ] is the pomset corresponding to M 0 . The set of all pomsets over alphabet is denoted by z. This corresponds to the notation used by Pratt <ref> [33] </ref>. Unless explicitly defined otherwise, the point set, alphabet, ordering relation, and 5 labeling function of some lpo or pomset M are denoted by V M , M , M , and M respectively. <p> The literature describes only very little experience with such languages [32]. It might be necessary to extend the pomset formalism with a new operator that takes four pomsets as an argument and joins them into one pomset having the structure of the pomset N. Pratt <ref> [33] </ref> defines such an operator. 7 The reason for not discussing this operator in this section is that it is not clear whether it is really necessary to extend the formalism for the purpose of event abstraction. There might be other useful extensions.
Reference: 34. <author> J.A. Summers. </author> <title> Precedence Preserving Abstraction for Distributed Debugging. </title> <type> Master's thesis, </type> <institution> University of Waterloo, Dept. of Computer Science, Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1992. </year>
Reference-contexts: The first approach is to restrict the structure of abstract events in such a way that the precedence relation is guaranteed to be a partial order, and then to try to timestamp these restricted abstract events in a meaningful way. This is the approach taken by Cheung [13], Summers <ref> [34] </ref>, and Kunz [24]. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness. The second approach is to allow more flexible abstract events and, and then to try to derive general timestamp schemes.
Reference: 35. <author> D.J. Taylor. </author> <title> A Prototype Debugger for Hermes. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 29-42, </pages> <address> Toronto, Ont., Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies. </institution>
Reference-contexts: To better understand the behavior of distributed applications, many tools and algorithms have been developed. To mention just a few of them, one could think of snapshot algorithms [10, 22, 25, 29], predicate-detection algorithms [14], and debugging tools including tools for visualizing behavior <ref> [35] </ref>, breakpoint facilities [20, 28, 31], and tools for recognizing behavioral patterns [5, 23]. All these tools and algorithms have one thing in common: They use event-based models of distributed computations. More in particular, they use the causal relationships among events to extract information that is considered useful.
Reference: 36. <author> G. Winskel. </author> <title> An Introduction to Event Structures. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozen-berg, editors, </editor> <title> Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <booktitle> volume 354 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-397. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year>
Reference-contexts: The model is based mainly on previous definitions of Mattern [29, 30], Charron-Bost [11, 12], and Fidge [15, 16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [26]. The algebraic structure underlying the model is Winskel's elementary event structure <ref> [36] </ref>. 2 The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : :; E N1 , where N is the number of processes. Each of these sets represents a local computation. It is assumed that E is finite.
References-found: 36

