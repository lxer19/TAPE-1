URL: http://www-graphics.stanford.edu/papers/bresen/bresen.ps.Z
Refering-URL: http://www-graphics.stanford.edu/papers/bresen/
Root-URL: http://www.cs.stanford.edu
Author: Peter Schroder Gordon Stoll 
Affiliation: Department of Computer Science National Information Display Laboratory Princeton University David Sarnoff Research Center  
Abstract: In this paper we describe an algorithm for volume raytracing in a data parallel framework. The algorithm uses the idiom of line drawing to traverse the data set when evaluating the path integrals corresponding to a raytracing of the volume. Since the rays of a parallel projection correspond to a single line instanced multiple times across the viewing plane the approach lends itself well to implementation on massively parallel computers. We have implemented this algorithm on the Princeton Engine (PE) and the Connection Machine CM2 com puters and achieved interactive performance.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Bailey. </author> <title> Implementing Fine-grained Scientific Algorithms on the Connection Machine Supercomputer, </title> <institution> tr89-1 ed. Thinking Machines Corporation, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction With the increasing availability of parallel computers, algorithms have been developed in many application domains to exploit their processing power <ref> [1] </ref>. This can be used both to admit more computationally expensive models and to move applications from batch processing to interactive computing. One such domain is volume visualization. It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14].
Reference: [2] <author> Guy Blelloch. </author> <title> Vector Models for Data Parallel Computing. </title> <booktitle> Artificial Intelligence Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1990. </year>
Reference-contexts: Parallelism assures that the above code remains invariant|only the runtime mapping of virtual processors onto the actual hardware changes. After the individual subintegrals have been computed in this fashion a parallel prefix operator <ref> [2] </ref> is used to combine the results of the sub integrals. As the number of processors approaches the number of voxels the length of the sub integrals goes to one, in effect evaluating the entire integral with the parallel prefix operators (for details of this approach to rendering see [20]). <p> This is due to the fact that for n 3 processors working on n 3 voxels the combining along the rays can be executed with a parallel prefix operator in logarithmic time <ref> [2] </ref>. Generally, however, the number of available processors is less than n 2 . In this case the present algorithm scales as expected.
Reference: [3] <author> C. Braccini, and G. Marino. </author> <title> Fast Geometrical Manipulations of Digital Images. </title> <booktitle> Computer Graphics and Image Processing 13 (1980), </booktitle> <pages> 127-141. </pages>
Reference-contexts: The present algorithm addresses this concern by describing a mapping of ray-samples onto the volume which is one-to-one. This mapping uses the idiom of line drawing on discrete grids <ref> [3] </ref>. Instead of transforming the volume once for a given rotation, we step the rays through the volume for each rendering.
Reference: [4] <author> George G. Cameron, and P. E. Undrill. </author> <title> Rendering Volumetric Medical Image Data on a SIMD-Architecture Computer. </title> <booktitle> In Proceedings of Third Eu-rographics Workshop on Rendering (May 1992). </booktitle>
Reference-contexts: In this case the present algorithm scales as expected. Note: It has come to the authors' attention that algorithms similar to that described in this paper have been developed independently by Roni Yagel [27] in the context of hardware design for volume rendering and by George Cameron <ref> [4] </ref> for a software implementation on the AMT DAP massively parallel processor. Acknowledgments The first author would like to thank Thinking Machines and Lew Tucker for access to "unlimited" CM2 cycles.
Reference: [5] <author> D. Chin, J. Passe, F. Bernard, H. Taylor, and S. Knight. </author> <title> The Princeton Engine: A Real-Time Video System Simulator. </title> <journal> IEEE Transactions on Consumer Electronics 34, </journal> <volume> 2 (1988), </volume> <pages> 285-297. </pages>
Reference-contexts: The particulars of this mapping can be influenced by the programmer, optimizing communication performance for a given application. The concept of virtual processors is especially useful for volume rendering since volumes often have more than 64k voxels. Princeton Engine The Princeton Engine <ref> [5] </ref> consists of 64 to 2048 16-bit DSP processors arranged in a ring. The processing elements operate at 14 MHz and have up to 640 kilo-bytes of memory each.
Reference: [6] <author> Robert A. Drebin, Loren Carpenter, and Pat Hanrahan. </author> <title> Volume Rendering. </title> <booktitle> Computer Graphics 22, </booktitle> <month> 4 (August </month> <year> 1988), </year> <pages> 65-74. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction <ref> [6] </ref>. * Splatting [24; 25; 12] * Cell projection [26; 16; 21] While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [7] <author> Akira Fujimoto, Tanaka Takayuki, and Kansei Iwata. </author> <title> ARTS: Accelerated Ray-Tracing System. </title> <journal> IEEE Computer Graphics and Applications (April 1986), </journal> <pages> 16-26. </pages>
Reference-contexts: Notice that some voxels may have more than one ray-sample point interior to them, while other voxels, although pierced by the ray, do not contain any ray-sample point. Enumerating these voxels is reminiscent of the approaches used for voxel traversal in non-volumetric ray tracing <ref> [7] </ref>. To simplify the discussion we first explain the algorithm in 2D. All arguments used readily generalize to the 3D case. Each ray starts in the image line (plane) and steps towards the volume.
Reference: [8] <author> Pat Hanrahan. </author> <title> Three-Pass Affine Transforms for Volume Rendering. </title> <booktitle> Computer Graphics 24, </booktitle> <month> 5 (November </month> <year> 1990), </year> <pages> 71-78. </pages>
Reference-contexts: The former can be characterized by ray parallelism and the latter by voxel parallelism. They are also distinguished by the communication patterns which they imply on distributed memory architectures. In image space methods the volume is treated as a set of planes which are subjected to two dimensional transformations <ref> [8] </ref>. The viewing transformation is decomposed into a set of affine transformations on the volume. These transformations have the advantage of being constant across planes of the volume and only involve simple one dimensional resampling operations. For parallel viewing projections of the volume it is sufficient to consider rotations only.
Reference: [9] <author> Danny W. Hillis. </author> <title> The Connection Machine. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: The processors are organized in a hypercube with a toroidal topology <ref> [9; 23] </ref>. Each processor has from 256 to 1024 kilo-bits of local memory. The programming model supports virtual processors, allowing the programmer to abstract from the actual number of physical processors available.
Reference: [10] <author> J. Kaba, J. Matey, G. Stoll, H. Taylor, and Pat Hanrahan. </author> <title> Interactive Terrain Rendering and Volume Visualization on the Princeton Engine. </title> <note> submitted to Visualization 92 conference, </note> <month> April </month> <year> 1992. </year>
Reference-contexts: In the first implementation of volume rendering on the PE <ref> [10] </ref>, only rotation about the X axis is supported, making rotation a completely local operation. The immediate goal for the new implementation is to provide rotation about the Y axis. <p> In the case that p is greater than n, high processor utilization can be maintained by the same method used in the previous implementation of volume rendering on the PE <ref> [10] </ref>: if the number of slices, n, is less than the number of processors, p, each successive group of n processors is given a copy of the volume. In this case each processor computes the rotation and projection for a horizontal strip with height n=p of the total height.
Reference: [11] <author> Wolfgang Kr uger. </author> <title> The Application of Transport Theory to the Visualization of 3-D Scalar Fields. </title> <booktitle> Computers in Physics (July 1991), </booktitle> <pages> 397-406. </pages>
Reference-contexts: necessary. * Lock step movement of all the rays, allowing for a SIMD implementation We describe the algorithm in detail in the following section. 2 Volume path integrals as line drawing When tracing a single ray through the volume we are interested in evaluating a path integral along that ray <ref> [11] </ref>. This is typically accomplished by discretizing the integral into a sum based on some step size along the ray. At each one of these ray-sample points we need to identify a set of surrounding grid points for resampling. <p> An example of an image generated is given in Figures 9 and 10. The clock frequency was 8MHz. The rendering used a volume source term, one lambertian light source and gradient magnitude surface source terms <ref> [11] </ref> for the engine block. The spine was rendered with a volume source term for the discs and a surface source term for the bone which consisted of a lambertian light source at the eye and a Phong light source. Integration was performed by using the conventional over operator.
Reference: [12] <author> David Laur, and Pat Hanrahan. </author> <title> Hierarchical Splat-ting: A Progressive Refinement Algorithm for Volume Rendering. </title> <booktitle> Computer Graphics 25, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 285-288. </pages>
Reference-contexts: One such domain is volume visualization. It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14]. While relatively fast algorithms for volume raytracing exist for high end workstations <ref> [15; 12] </ref>, very little work has been published describing algorithms which run on massively parallel platforms [20; 28; 17]. In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work [20]. <p> Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting <ref> [24; 25; 12] </ref> * Cell projection [26; 16; 21] While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [13] <author> Marc Levoy. </author> <title> Display of Surfaces from Volume Data. </title> <journal> IEEE Computer Graphics and Applications 8, </journal> <month> 3 (May </month> <year> 1988), </year> <pages> 29-37. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays <ref> [13] </ref>. 2.
Reference: [14] <author> Marc Levoy. </author> <title> Design for a Real-Time High-Quality Volume Rendering Workstation. In CH Volume Visualization Workshop (May 1989), </title> <publisher> ACM Siggraph, ACM Press, </publisher> <pages> pp. 85-92. </pages>
Reference-contexts: This can be used both to admit more computationally expensive models and to move applications from batch processing to interactive computing. One such domain is volume visualization. It has been acknowledged for some time that interactivity is very desirable in volume visualization <ref> [24; 14] </ref>. While relatively fast algorithms for volume raytracing exist for high end workstations [15; 12], very little work has been published describing algorithms which run on massively parallel platforms [20; 28; 17].
Reference: [15] <author> Marc Levoy. </author> <title> Efficient Ray Tracing of Volume Data. </title> <journal> ACM Transactions on Graphics 9, </journal> <month> 3 (July </month> <year> 1990), </year> <pages> 245-261. </pages>
Reference-contexts: One such domain is volume visualization. It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14]. While relatively fast algorithms for volume raytracing exist for high end workstations <ref> [15; 12] </ref>, very little work has been published describing algorithms which run on massively parallel platforms [20; 28; 17]. In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work [20].
Reference: [16] <author> Nelson Max, Pat Hanrahan, and Roger Craw-fis. </author> <title> Area and Volume Coherence for Efficient Visualization of 3D Scalar Functions. </title> <booktitle> Computer Graphics 24, </booktitle> <month> 5 (November </month> <year> 1990), </year> <pages> 27-33. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting [24; 25; 12] * Cell projection <ref> [26; 16; 21] </ref> While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [17] <author> Ulrich Neumann. </author> <title> Interactive Volume Rendering on a Multicomputer. </title> <booktitle> In Proceedings of 1992 Symposium on Interactive 3D Graphics (March 1992), ACM, ACM Siggraph, </booktitle> <pages> pp. 87-93. </pages>
Reference-contexts: It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14]. While relatively fast algorithms for volume raytracing exist for high end workstations [15; 12], very little work has been published describing algorithms which run on massively parallel platforms <ref> [20; 28; 17] </ref>. In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work [20].
Reference: [18] <author> Alan W. Paeth. </author> <title> A Fast Algorithm for General Raster Rotation. </title> <booktitle> Proceedings Graphics Interface (May 1986), </booktitle> <pages> 77-81. </pages>
Reference-contexts: The fact that rotations can be decomposed into a sequence of pure a 1 Duplication at every processor is not desirable in any case since the amount of wasted memory grows with the number of processors. shears <ref> [18; 22] </ref> was exploited in [20] for a massively parallel volume rendering algorithm. If the individual transformations are pure shears, only regular communication|shifting by constant amounts along each row|is necessary. One disadvantage of this approach in a data parallel framework is the high memory consumption of the algorithm.
Reference: [19] <author> Thomas Porter, and Tom Duff. </author> <title> Compositing Digital Images. </title> <booktitle> Computer Graphics 18, </booktitle> <month> 3 (July </month> <year> 1984), </year> <pages> 253-260. </pages>
Reference-contexts: The function interpolate executes a tri-linear interpolation, while color maps a sample value onto r, g, b, and ff; composite is typically just the over operator <ref> [19] </ref>. The step function increments the sample coordinates and tests the voxel local coordinates along the minor axes against overflow and underflow to determine whether to take a step orthogonal to the major axis.
Reference: [20] <author> Peter Schr oder, and James B. Salem. </author> <title> Fast Rotation of Volume Data on Data Parallel Architectures. In Proceedings Visualization 1991 (October 1991), </title> <editor> G. M. Nielson and L. Rosenblum, Eds., </editor> <publisher> IEEE, IEEE Computer Science Press, </publisher> <pages> pp. 50-57. </pages>
Reference-contexts: It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14]. While relatively fast algorithms for volume raytracing exist for high end workstations [15; 12], very little work has been published describing algorithms which run on massively parallel platforms <ref> [20; 28; 17] </ref>. In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work [20]. <p> In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work <ref> [20] </ref>. <p> The fact that rotations can be decomposed into a sequence of pure a 1 Duplication at every processor is not desirable in any case since the amount of wasted memory grows with the number of processors. shears [18; 22] was exploited in <ref> [20] </ref> for a massively parallel volume rendering algorithm. If the individual transformations are pure shears, only regular communication|shifting by constant amounts along each row|is necessary. One disadvantage of this approach in a data parallel framework is the high memory consumption of the algorithm. <p> As the number of processors approaches the number of voxels the length of the sub integrals goes to one, in effect evaluating the entire integral with the parallel prefix operators (for details of this approach to rendering see <ref> [20] </ref>). Non-even sided volumes can be accommodated as well. On the CM2 all processor layouts need to be rounded up to a power of 2 multiple of the machine size, since only such shapes are supported 3 . <p> The present algorithm is characterized by its ray parallelism. As a consequence the work per processor increases linearly in n, assuming that we have n 2 processors and n 3 voxels. If, on the other hand, object space parallelism is exploited (as is the case in <ref> [20] </ref>), the work per processor grows as log n. This is due to the fact that for n 3 processors working on n 3 voxels the combining along the rays can be executed with a parallel prefix operator in logarithmic time [2].
Reference: [21] <author> Peter Shirley, and Allan Tuchman. </author> <title> A Polygonal Approximation to Direct Scalar Volume Rendering. </title> <booktitle> Computer Graphics 24, </booktitle> <month> 5 (November </month> <year> 1990), </year> <pages> 63-70. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting [24; 25; 12] * Cell projection <ref> [26; 16; 21] </ref> While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [22] <author> A. Tanaka, M. Kameyama, S. Kazama, and O. Watanabe. </author> <title> A Rotation Method for Raster Image Using Skew Transformations. </title> <booktitle> In Proceedings IEEE Conference on Computer Vision and Pattern Recognition (June 1986), </booktitle> <pages> pp. 272-277. </pages>
Reference-contexts: The fact that rotations can be decomposed into a sequence of pure a 1 Duplication at every processor is not desirable in any case since the amount of wasted memory grows with the number of processors. shears <ref> [18; 22] </ref> was exploited in [20] for a massively parallel volume rendering algorithm. If the individual transformations are pure shears, only regular communication|shifting by constant amounts along each row|is necessary. One disadvantage of this approach in a data parallel framework is the high memory consumption of the algorithm.
Reference: [23] <institution> Connection Machine Model CM-2 Technical Summary. </institution> <type> Tech. Rep. HA 87-4, </type> <institution> Thinking Machines Corporation, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: The processors are organized in a hypercube with a toroidal topology <ref> [9; 23] </ref>. Each processor has from 256 to 1024 kilo-bits of local memory. The programming model supports virtual processors, allowing the programmer to abstract from the actual number of physical processors available.
Reference: [24] <author> Lee Westover. </author> <title> Interactive Volume Rendering. In CH Volume Visualization Workshop (May 1989), </title> <publisher> ACM Siggraph, ACM Press, </publisher> <pages> pp. 9-16. </pages>
Reference-contexts: This can be used both to admit more computationally expensive models and to move applications from batch processing to interactive computing. One such domain is volume visualization. It has been acknowledged for some time that interactivity is very desirable in volume visualization <ref> [24; 14] </ref>. While relatively fast algorithms for volume raytracing exist for high end workstations [15; 12], very little work has been published describing algorithms which run on massively parallel platforms [20; 28; 17]. <p> Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting <ref> [24; 25; 12] </ref> * Cell projection [26; 16; 21] While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [25] <author> Lee Westover. </author> <title> Footprint Evaluation for Volume Ren--dering. </title> <booktitle> Computer Graphics 24, </booktitle> <month> 4 (August </month> <year> 1990), </year> <pages> 367-376. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting <ref> [24; 25; 12] </ref> * Cell projection [26; 16; 21] While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [26] <author> Jane Wilhelms, and Allen Van Gelder. </author> <title> A Coherent Projection Approach for Direct Volume Rendering. </title> <booktitle> Computer Graphics 25, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 275-284. </pages>
Reference-contexts: Object space methods, which resample the volume at sample points along rays [13]. 2. Image space methods, which transform the volume to be axis aligned with the view direction [6]. * Splatting [24; 25; 12] * Cell projection <ref> [26; 16; 21] </ref> While both splatting and cell projection can have efficient parallel implementations we are concerned only with ray tracing methods in the present discussion. Parallel implementations of object and image space methods exploit different forms of parallelism.
Reference: [27] <author> Roni Yagel. </author> <title> Efficient Methods for Volumetric Graphics. </title> <type> PhD thesis, </type> <institution> SUNY Stony Brook, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Generally, however, the number of available processors is less than n 2 . In this case the present algorithm scales as expected. Note: It has come to the authors' attention that algorithms similar to that described in this paper have been developed independently by Roni Yagel <ref> [27] </ref> in the context of hardware design for volume rendering and by George Cameron [4] for a software implementation on the AMT DAP massively parallel processor. Acknowledgments The first author would like to thank Thinking Machines and Lew Tucker for access to "unlimited" CM2 cycles.
Reference: [28] <author> Terry S. Yoo, Ulrich Neumann, Henry Fuchs, Stephen M. Pizer, Tim Cullip, John Rhoades, and Ross Whitaker. </author> <title> Achieving Direct Volume Visualization with Interactive Semantic Region Selection. In Proceedings Visualization 1991 (October 1991), </title> <editor> G. M. Nielson and L. Rosenblum, Eds., </editor> <publisher> IEEE, IEEE Computer Science Press, </publisher> <pages> pp. </pages> <month> 58-65. </month> <title> a voxels rendered with a supersampling of 16 rays per voxel. a voxels rendered with a supersampling of 16 rays per voxel. </title>
Reference-contexts: It has been acknowledged for some time that interactivity is very desirable in volume visualization [24; 14]. While relatively fast algorithms for volume raytracing exist for high end workstations [15; 12], very little work has been published describing algorithms which run on massively parallel platforms <ref> [20; 28; 17] </ref>. In the present paper we describe an algorithm for data parallel volume raytracing which is both more memory efficient and less communications bound than previous work [20].
References-found: 28

