URL: http://www.idt.unit.no/~epos/Papers/main.ps
Refering-URL: http://www.idt.unit.no/~epos/bibliografia.html
Root-URL: 
Title: Techniques for Process Model Evolution in EPOS  
Author: Maria Letizia Jaccheri Reidar Conradi 
Date: 5 May 1993  
Address: 10129 Torino Italy  N-7034 Trondheim, Norway  
Affiliation: Dipartimento di Automatica e Informatica Politecnico di Torino  Dept. of Computer Systems and Telematics Norwegian Institute of Technology (NTH),  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Dowson, B. Nejmeh, and W. Riddle, </author> <title> "Fundamental Software Process Concepts," </title> <booktitle> in [38], </booktitle> <pages> pp. 15-37, </pages> <year> 1991. </year>
Reference-contexts: A Process Model is a description of one or more software processes, and it is composed by a production process model and a meta-process model (meta-model). A part of the model is called a model fragment. Software 2 Process Modeling (PM) is the discipline of describing process models <ref> [1] </ref> [2]. [3] [4]. In this paper, the term process model is used to denote the internal computer representation of an external process. The term process model denotes both a process abstract description (as a schema) and a more concrete description of the external process elements to be supported.
Reference: [2] <author> N. H. Madhavji, </author> <title> "The process cycle," </title> <journal> Software Engineering Journal, </journal> <volume> vol. 6, </volume> <pages> pp. 234-242, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: A Process Model is a description of one or more software processes, and it is composed by a production process model and a meta-process model (meta-model). A part of the model is called a model fragment. Software 2 Process Modeling (PM) is the discipline of describing process models [1] <ref> [2] </ref>. [3] [4]. In this paper, the term process model is used to denote the internal computer representation of an external process. The term process model denotes both a process abstract description (as a schema) and a more concrete description of the external process elements to be supported.
Reference: [3] <author> R. Conradi, C. Fernstrom, A. Fuggetta, and R. Snowdon, </author> <title> "Towards a Reference Framework for Process Concepts," </title> <editor> in J.-C. Derniame (ed.): </editor> <booktitle> Proc. from EWSPT'92, </booktitle> <month> Sept. </month> <pages> 7-8, </pages> <address> Trondheim, Norway, </address> <publisher> Springer Verlag LNCS 635, </publisher> <pages> pp. 3-17, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: A part of the model is called a model fragment. Software 2 Process Modeling (PM) is the discipline of describing process models [1] [2]. <ref> [3] </ref> [4]. In this paper, the term process model is used to denote the internal computer representation of an external process. The term process model denotes both a process abstract description (as a schema) and a more concrete description of the external process elements to be supported. <p> Different kinds of users are programmers, designers, quality engineers, project managers etc.. A project is the work context where the software processes occur and encompasses users, tools, and products, plus the process model that is actually governing it. A Process Support Environment (PSE) is a human-oriented system <ref> [3] </ref>, intended to serve interacting computerized tools and humans. Ideally it should serve as an intelligent and cooperative assistant in the daily chores of the project workers. However, users tend to modify and improve the process they are carrying out. <p> Conclusions are given in section 5, with indications of further work. 2 The Process Model Life cycle Process models are themselves produced by an engineering process. Such engineering (creating, changing etc.) consists of a set of phases, called PM meta-activities <ref> [3] </ref>, and constitute the meta-process. The meta-process of producing process models clearly resembles the software process of creating normal executable software products. 2.1 The PM meta-process Fig. 1 shows six meta-activities, depicted by boxes, and their respective inputs and outputs, depicted by ovals.
Reference: [4] <author> P. H. Feiler and W. Humphrey, </author> <title> "Software Process Development and Enactment: Concepts and Definitions," </title> <month> Jan. </month> <year> 1992. </year> <note> 12 pages (Second version). </note>
Reference-contexts: A part of the model is called a model fragment. Software 2 Process Modeling (PM) is the discipline of describing process models [1] [2]. [3] <ref> [4] </ref>. In this paper, the term process model is used to denote the internal computer representation of an external process. The term process model denotes both a process abstract description (as a schema) and a more concrete description of the external process elements to be supported.
Reference: [5] <author> M. M. Lehman and L. A. Belady, </author> <title> Program Evolution | Processes of Software Change. </title> <publisher> Academic Press, </publisher> <address> 538 p., </address> <year> 1985. </year>
Reference-contexts: A process model must therefore be continuously maintained during its life time. Software Process Model Evolution is the act of changing existing models in a controlled way <ref> [5] </ref> [6]. This includes Software Process Customization: reusing existing process model fragments and adapting them to different contexts. The paper is structured as follows: section 2 defines a process model life cycle, and elaborates the meta-process for process evolution and customization.
Reference: [6] <author> N. H. Madhavji, </author> <title> "Environment evolution: The prism model of changes," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. SE-18, </volume> <pages> pp. 380-392, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: A process model must therefore be continuously maintained during its life time. Software Process Model Evolution is the act of changing existing models in a controlled way [5] <ref> [6] </ref>. This includes Software Process Customization: reusing existing process model fragments and adapting them to different contexts. The paper is structured as follows: section 2 defines a process model life cycle, and elaborates the meta-process for process evolution and customization. Section 3 presents the EPOS support for process model evolution. <p> EPOS can offer only some initial functionalities and it is not integrated with a project management tool. Process model schema fragments are items of change in EPOS, as in SPADE, IPSE 2.5, and PRISM whereas HFSP [32] enables to change enacting models, but not schemas. PRISM <ref> [6] </ref> offers a Dependency Structure for describing change items and a Change Structure for describing change related data. The structure of EPOS instances, classes, and meta-classes connected by relations resembles the PRISM Dependency Structure whereas EPOS does not manage change related data, i.e. maintenance reports or history of changes.
Reference: [7] <author> P. H. Feiler, </author> <title> "Configuration management models in commercial environments," </title> <type> tech. rep., </type> <institution> Carnegie-Mellon University, Software Engineering Institute, Pittsburgh, Pennsylvania, </institution> <month> Mar. </month> <year> 1991. </year> <pages> 53 pp. </pages>
Reference-contexts: However, there are some additional problems in evolving enacting process models. Fig. 3 gives a CM perspective of PM change. Here, the terms revision and variant (branch) are given the classical CM semantics <ref> [7] </ref>. A process model may therefore be modified as sequential revisions, or as alternative/parallel variants that evolve independently. Revision and variant are commonly termed version. On the horizontal dimension, PM.1.1 is created as a revision of PM.1.0.
Reference: [8] <author> R. Conradi, E. Osjord, P. H. Westby, and C. Liu, </author> <title> "Initial Software Process Management in EPOS," </title> <journal> Software Engineering Journal (Special Issue on Software process and its support), </journal> <volume> vol. 6, </volume> <pages> pp. 275-284, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: To facilitate precise forward analysis and propagation, and similar backward traceability, we need to explicitly represent external process elements and their dependencies in an internal process model. 3 EPOS EPOS 3 <ref> [8] </ref> is a process support environment that offers a PML called SPELL (Software Process EvoLutionary Language) [9], an initial process schema, and a set of process tools.
Reference: [9] <author> R. Conradi, M. L. Jaccheri, C. Mazzi, A. Aarsten, and M. N. Nguyen, </author> <title> "Design, use, and implementation of SPELL, a language for software process modeling and evolution," </title> <editor> in J.-C. Derni-ame (ed.): </editor> <booktitle> Proc. from EWSPT'92, </booktitle> <month> Sept. </month> <pages> 7-8, </pages> <address> Trondheim, Norway, </address> <publisher> Springer Verlag LNCS 635, </publisher> <pages> pp. 167-177, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: To facilitate precise forward analysis and propagation, and similar backward traceability, we need to explicitly represent external process elements and their dependencies in an internal process model. 3 EPOS EPOS 3 [8] is a process support environment that offers a PML called SPELL (Software Process EvoLutionary Language) <ref> [9] </ref>, an initial process schema, and a set of process tools. In EPOS, the internal process model is a network of activity descriptions (tasks), being linked to descriptions of other tasks, products, tools, and roles. The activities interact with each other and with tools and humans.
Reference: [10] <author> M. H. Penedo and C. Shu, </author> <title> "Acquiring Experiences with the modelling and implementation of the project life-cycle process: the PMDB work," </title> <journal> Software Engineering Journal (Special Issue on Software process and its support), </journal> <volume> vol. 6, </volume> <pages> pp. 259-274, </pages> <month> Sept. </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: The main process tools operating on the above models are: a PM Manager, an Execution Manager (Process Engine), an AI Planner, and EPOSDB, a versioned object-oriented database. 3.1 The Layered EPOS Architecture PSEs that rely on an object-oriented database, e.g. PMDB <ref> [10] </ref> and ADELE [11], often have a PML as a layer around the underlying database. EPOS extends this by having three layers around the database. Thus, the EPOS layers are: A client-server EPOSDB with change oriented versioning [12] [13] in a context of long, nested and cooperating transactions.
Reference: [11] <author> N. Belkhatir, J. Estublier, and W. Melo, </author> <title> "Soft--ware Process Model and Work Space Control in the Adele System," </title> <editor> in Leon Osterweil (ed.): </editor> <booktitle> Proc. from 2nd Int'l Conference on Software Process (ICSP'2), </booktitle> <address> March 1993, Berlin. </address> <publisher> IEEE Press, </publisher> <pages> pp. 2-11, </pages> <year> 1993. </year>
Reference-contexts: The main process tools operating on the above models are: a PM Manager, an Execution Manager (Process Engine), an AI Planner, and EPOSDB, a versioned object-oriented database. 3.1 The Layered EPOS Architecture PSEs that rely on an object-oriented database, e.g. PMDB [10] and ADELE <ref> [11] </ref>, often have a PML as a layer around the underlying database. EPOS extends this by having three layers around the database. Thus, the EPOS layers are: A client-server EPOSDB with change oriented versioning [12] [13] in a context of long, nested and cooperating transactions. <p> In addition, some large examples have been run by the development teams, and several PSEs can assist in maintaining themselves (ADELE <ref> [11] </ref>, MARVEL [25]). In the following, the main characteristics of the EPOS system are compared against those offered by some other systems. During this comparison process we take as parameters both the general process evolution issues and the specific EPOS solutions.
Reference: [12] <author> A. Lie, R. Conradi, T. M. Didriksen, E.-A. Karls-son, S. O. Hallsteinsen, and P. Holager, </author> <title> "Change Oriented Versioning in a Software Engineering Database," </title> <editor> in Walter F. Tichy (Ed.): </editor> <booktitle> Proc. of the 2nd International Workshop on Software Configuration Management, </booktitle> <address> Princeton, USA, 25-27 Oct. </address> <year> 1989, </year> <title> 178 p. </title> <booktitle> In ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 14 (7), </volume> <pages> pp. 56-65, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: PMDB [10] and ADELE [11], often have a PML as a layer around the underlying database. EPOS extends this by having three layers around the database. Thus, the EPOS layers are: A client-server EPOSDB with change oriented versioning <ref> [12] </ref> [13] in a context of long, nested and cooperating transactions. EPOSDB offers a structurally object-oriented data model and its DDL to define entity and (binary) relation classes 4 . Entities (objects) have unique and immutable identity (an OID). There is a system-defined entity root class.
Reference: [13] <author> B. Gulla, E.-A. Karlsson, and D. Yeh, </author> <title> "Change-Oriented Version Descriptions in EPOS," </title> <journal> Software Engineering Journal, </journal> <volume> vol. 6, </volume> <pages> pp. 378-386, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: PMDB [10] and ADELE [11], often have a PML as a layer around the underlying database. EPOS extends this by having three layers around the database. Thus, the EPOS layers are: A client-server EPOSDB with change oriented versioning [12] <ref> [13] </ref> in a context of long, nested and cooperating transactions. EPOSDB offers a structurally object-oriented data model and its DDL to define entity and (binary) relation classes 4 . Entities (objects) have unique and immutable identity (an OID). There is a system-defined entity root class.
Reference: [14] <institution> Object Management Group, </institution> <note> Object Services/Data Model Request for Information, </note> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: entities, relationships, and their classes and meta-classes (as class descriptor instances) are stored in the database and they are thus uni formly versionable. 3 EPOS: Expert system for Program and ("Norwegian Og") System development. 4 In the EPOS literature they are called types, but here we adhere to the OMG <ref> [14] </ref> terminology. 5 A reflective and object-oriented PML SPELL unifies and extends the underlying DDL/ DML, and offers class-level attributes and instance/class-level procedures. Active procedures, or triggers, may also be defined. Meta-classes are used reflectively as in Smalltalk [16] to store class-level information.
Reference: [15] <author> J. Rumbaugh, </author> <title> "Relations as semantics constructs in an object-oriented language," </title> <booktitle> in Proc. of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'87), (Kissimmee, Florida), </booktitle> <pages> pp. 466-481, </pages> <month> Oct. </month> <year> 1987. </year> <journal> In ACM SIGPLAN Notices 22(12), </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Entities (objects) have unique and immutable identity (an OID). There is a system-defined entity root class. Both entities and relationships can have scalar attributes with inheritance. Entities can also have longfield attributes to describe external files. This data model is close to the object-relation model suggested by <ref> [15] </ref>. A free-standing Prolog based DML is offered.
Reference: [16] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison Wes-ley, </publisher> <year> 1983. </year>
Reference-contexts: Active procedures, or triggers, may also be defined. Meta-classes are used reflectively as in Smalltalk <ref> [16] </ref> to store class-level information. This EPOS layer supports meta-activities Analysis & Design (PM2) and Customization (PM3), and later Evolution through the PM Manager. A tasking framework for concurrent enaction of process models. <p> Among the specific EPOS choices, 1) Object Orientation, 2) Database support and versioning, 3) Automatic and incremental instan-tiation by planning, are considered. Reflection and meta-process The EPOS meta-process is explicitly represented by meta-classes. This is strongly influenced by the meta-class mechanism in Smalltalk <ref> [16] </ref>. CLOS [26] also offers reflective features and pre-defines procedures to change class definitions, and to convert the affected instances. Similarly, SELF [27] provides rules to control evolution. Further, IPSE 2.5 offers reflection, while MARVEL has a fixed meta-process expressed in another (non-reflective) language. SPADE [28] offers only task-level reflection. <p> Object-Orientation Among the PSEs exploiting object-orientation, the closest to EPOS is IPSE 2.5 using PS-Algol, and partly MARVEL. ADELE has a hybrid object-oriented model, with run-time binding (delegation [34]) towards product and/or project contexts for customization. EPOS has derived dynamic binding and class-properties from Smalltalk <ref> [16] </ref> to gain flexibility. Database Support and versioning Many of the PSEs have their own and partially proprietary Object Management Systems (OMSes), e.g. MARVEL, ARCADIA (CHIRON). Others use existing OMSes, e.g. PS-Algol used in IPSE 2.5, PCTE in ALF [35], O2 in SPADE, and LDL in OIKOS [36].
Reference: [17] <author> O.-J. Dahl, B. Myhrhaug, and K. Nygaard, </author> <title> "SIM-ULA Information | Common Base Language," </title> <type> Tech. Rep. 145 p., </type> <institution> S-22, Norwegian Computing Center, Oslo, </institution> <year> 1970. </year>
Reference-contexts: Three kinds of inheritance are available for class-level properties and for procedures: redefine, append, and concatenate. redefine means overwriting (the default), while append applies only to class-level attributes and means logic conjunction (used on the predicates in fig. 6). concatenate is inspired by the Simula <ref> [17] </ref> inner mechanism. It means, that if the code of a superclass is defined as step2, and the code of a subclass is defined as (step1,inner,step3), the concatenated subclass code is (step1,step2,step3). Redefined procedures in a subclass may be inherited by either redefine or concatenate.
Reference: [18] <author> C. Liu, </author> <title> "Software Process Planning and Execution: Coupling vs. Integration," </title> <booktitle> in Proc. of CAiSE'91, the 3rd International Conference on Advanced Information Systems, </booktitle> <address> Trondheim, Nor-way, </address> <note> 13-15 May 1991 (R. </note> <editor> Andersen, J. A. B. jr., and A. S. lvberg, </editor> <booktitle> eds.), </booktitle> <pages> pp. 356-374, </pages> <publisher> LNCS 498, Springer Verlag, </publisher> <address> 578 p., </address> <year> 1991. </year>
Reference-contexts: The attribute executor refers to the logical name of the tool that should execute the task, while role refers to the role or responsibility description of a generic human actor, e.g. a software developer. 3.3.2 The Planner The AI Planner <ref> [18] </ref> is technically a procedure in meta-activity PM4. It is implicitly and incrementally invoked by the Execution Manager to detail a composite task at the time. That is, the Planner will automatically generate a new subtask network for each composite task.
Reference: [19] <author> D. Chapman, </author> <title> "Planning for conjunctive goals," </title> <journal> Artificial Intelligence, </journal> <volume> vol. 32, </volume> <pages> pp. 333-377, </pages> <year> 1987. </year>
Reference-contexts: It is implicitly and incrementally invoked by the Execution Manager to detail a composite task at the time. That is, the Planner will automatically generate a new subtask network for each composite task. The EPOS Planner uses a domain-independent, non-linear AI planning algorithm, as in TWEAK <ref> [19] </ref> and IPEM [20]. Dynamic and incremental instantiation is achieved by this collaboration between Planner and Execution Manager. The Planner starts with a composite task and its desired output which is the goal. <p> Planning The EPOS Planner uses domain-independent, non-linear planning to incrementally (re)construct task networks. As mentioned, this is inspired by TWEAK <ref> [19] </ref>, and also by IPEM [20]. Other PSEs using goal-oriented AI techniques are GRAPPLE [37], and for a similar purpose as EPOS. SPADE uses reflection to incrementally construct its task network (a PetriNet).
Reference: [20] <author> J. A. Ambros-Ingerson and S. Steel, </author> <title> "Integrating planning, execution and monitoring," </title> <booktitle> in Proc. of AAAI'88, </booktitle> <pages> pp. 83-88, </pages> <year> 1988. </year>
Reference-contexts: It is implicitly and incrementally invoked by the Execution Manager to detail a composite task at the time. That is, the Planner will automatically generate a new subtask network for each composite task. The EPOS Planner uses a domain-independent, non-linear AI planning algorithm, as in TWEAK [19] and IPEM <ref> [20] </ref>. Dynamic and incremental instantiation is achieved by this collaboration between Planner and Execution Manager. The Planner starts with a composite task and its desired output which is the goal. <p> Planning The EPOS Planner uses domain-independent, non-linear planning to incrementally (re)construct task networks. As mentioned, this is inspired by TWEAK [19], and also by IPEM <ref> [20] </ref>. Other PSEs using goal-oriented AI techniques are GRAPPLE [37], and for a similar purpose as EPOS. SPADE uses reflection to incrementally construct its task network (a PetriNet).
Reference: [21] <author> C. Liu and R. Conradi, </author> <title> "Automatic Replanning of Task Networks for Process Model Evolution in EPOS," </title> <editor> in Ian Sommerville (Ed.): </editor> <booktitle> "Proc. from the 4th European Software Engineering Conference (ESEC'93)", </booktitle> <address> Garmisch-Partenkirchen, FRG. </address> <publisher> Forthcoming as a Springer LNCS. 17 p, </publisher> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: These class-level attributes together specify legality constraints on the structure of the task network. Clearly, changes to these schema attributes and to the product structure imply replanning. An incremental algorithm for replanning is presented in <ref> [21] </ref>. 3.3.3 EPOSDB: The Change Oriented Ver sioning Model In the following, we first describe transactions and then versioning. Transactions EPOSDB offers long and nested transactions with checked-out workspaces. Transactions may survive several application sessions, and are represented by special transaction objects in the database, connected to project tasks.
Reference: [22] <author> M. I. Kellner, P. H. Feiler, A. Finkelstein, T. Katayama, L. Osterweil, M. Penedo, and H. D. Rombach, </author> <title> "Software Process Modeling Problem (for ISPW6)," </title> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: For instance, it is not wise to cancel all the effects performed by very long transaction tasks. 3.5 An example: the ISPW7 Reference Problem We here give the EPOS solution to the reference problem of software process model change, as proposed for by 7th International Software Process Workshop (ISPW7) <ref> [22] </ref>. Let us suppose we have a process schema that includes a coding task class, stating that it is possible to begin coding before the design is approved.
Reference: [23] <author> C. Fernstrom, </author> <title> "Process WEAVER: Adding Process Support to UNIX," </title> <editor> in Leon Osterweil (ed.): </editor> <booktitle> Proc. from 2nd Int'l Conference on Software Process (ICSP'2), </booktitle> <address> Berlin. </address> <publisher> IEEE-CS Press, </publisher> <pages> pp. 12-26, </pages> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: to be automatically destroyed, but the responsible user has to be notified that some inconsistencies may have been introduced. window. 4 Comparisons and Related Work Many PSEs have been prototyped and documented over the last 5 years and some experiments in realistic external production environments, have been reported (Process Weaver <ref> [23] </ref>, IPSE 2.5 [24]). In addition, some large examples have been run by the development teams, and several PSEs can assist in maintaining themselves (ADELE [11], MARVEL [25]). In the following, the main characteristics of the EPOS system are compared against those offered by some other systems.
Reference: [24] <author> R. Snowdon, </author> <title> "An example of process change," </title> <editor> in J.-C. Derniame (ed.): </editor> <booktitle> Proc. from EWSPT'92, </booktitle> <month> Sept. </month> <pages> 7-8, </pages> <address> Trondheim, Norway, </address> <publisher> Springer Verlag LNCS 635, </publisher> <pages> pp. 178-195, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: destroyed, but the responsible user has to be notified that some inconsistencies may have been introduced. window. 4 Comparisons and Related Work Many PSEs have been prototyped and documented over the last 5 years and some experiments in realistic external production environments, have been reported (Process Weaver [23], IPSE 2.5 <ref> [24] </ref>). In addition, some large examples have been run by the development teams, and several PSEs can assist in maintaining themselves (ADELE [11], MARVEL [25]). In the following, the main characteristics of the EPOS system are compared against those offered by some other systems. <p> Change assessment, simulation, and validation In most PSEs, relationships can be used to control and propagate the impacts of change. At the moment, EPOS does not provide facilities for simulation of changes, and weak mechanisms for formal verification of changes. MARVEL [25], Mer-lin [30] and IPSE 2.5 <ref> [24] </ref> can offer some formal verification support, and MELMAC [31] can per form simulations. When process evolution may happen 14 Process model changes fall into two main cate-gories: refinement/customization before enaction, as in Process Weaver, and MELMAC [31]; or correction after enaction, as in MARVEL, IPSE 2.5, SPADE, and EPOS.
Reference: [25] <author> N. S. Barghouti and G. E. Kaiser, </author> <title> "Scaling up rule-based development environments," </title> <journal> International Journal on Software Engineering and Knowledge Engineering, World Scientific, </journal> <volume> vol. 2, </volume> <pages> pp. 59-78, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: In addition, some large examples have been run by the development teams, and several PSEs can assist in maintaining themselves (ADELE [11], MARVEL <ref> [25] </ref>). In the following, the main characteristics of the EPOS system are compared against those offered by some other systems. During this comparison process we take as parameters both the general process evolution issues and the specific EPOS solutions. <p> Change assessment, simulation, and validation In most PSEs, relationships can be used to control and propagate the impacts of change. At the moment, EPOS does not provide facilities for simulation of changes, and weak mechanisms for formal verification of changes. MARVEL <ref> [25] </ref>, Mer-lin [30] and IPSE 2.5 [24] can offer some formal verification support, and MELMAC [31] can per form simulations.
Reference: [26] <author> S. E. Keene, </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year> <note> 266 p. </note>
Reference-contexts: Among the specific EPOS choices, 1) Object Orientation, 2) Database support and versioning, 3) Automatic and incremental instan-tiation by planning, are considered. Reflection and meta-process The EPOS meta-process is explicitly represented by meta-classes. This is strongly influenced by the meta-class mechanism in Smalltalk [16]. CLOS <ref> [26] </ref> also offers reflective features and pre-defines procedures to change class definitions, and to convert the affected instances. Similarly, SELF [27] provides rules to control evolution. Further, IPSE 2.5 offers reflection, while MARVEL has a fixed meta-process expressed in another (non-reflective) language. SPADE [28] offers only task-level reflection.
Reference: [27] <author> D. Ungar and R. B. Smith, </author> <title> "Self: The Power of Simplicity," </title> <booktitle> in Proc. of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'87), (Kissimmee, Florida), </booktitle> <pages> pp. 227-242, </pages> <month> Oct. </month> <year> 1987. </year> <journal> In ACM SIGPLAN Notices 22(12), </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Reflection and meta-process The EPOS meta-process is explicitly represented by meta-classes. This is strongly influenced by the meta-class mechanism in Smalltalk [16]. CLOS [26] also offers reflective features and pre-defines procedures to change class definitions, and to convert the affected instances. Similarly, SELF <ref> [27] </ref> provides rules to control evolution. Further, IPSE 2.5 offers reflection, while MARVEL has a fixed meta-process expressed in another (non-reflective) language. SPADE [28] offers only task-level reflection. Laws to control evolution of both product and of the rules themselves may be defined DARWIN [29].
Reference: [28] <author> S. Bandinelli and A. Fuggetta, </author> <title> "Computational Reflection in Software Process Modeling: the SLANG Approach," </title> <booktitle> in Proc. ICSE'15, </booktitle> <address> Balti-more, USA, </address> <publisher> IEEE-CS Press (forthcoming), </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: CLOS [26] also offers reflective features and pre-defines procedures to change class definitions, and to convert the affected instances. Similarly, SELF [27] provides rules to control evolution. Further, IPSE 2.5 offers reflection, while MARVEL has a fixed meta-process expressed in another (non-reflective) language. SPADE <ref> [28] </ref> offers only task-level reflection. Laws to control evolution of both product and of the rules themselves may be defined DARWIN [29]. The use of reflection to manage process model evolution is not new, but EPOS exploits an integrated, object-oriented architecture for managing class changes.
Reference: [29] <author> N. Minsky, </author> <title> "Law-Governed Systems," </title> <journal> Software Engineering Journal, </journal> <volume> vol. 6, </volume> <pages> pp. 285-302, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Similarly, SELF [27] provides rules to control evolution. Further, IPSE 2.5 offers reflection, while MARVEL has a fixed meta-process expressed in another (non-reflective) language. SPADE [28] offers only task-level reflection. Laws to control evolution of both product and of the rules themselves may be defined DARWIN <ref> [29] </ref>. The use of reflection to manage process model evolution is not new, but EPOS exploits an integrated, object-oriented architecture for managing class changes. Change assessment, simulation, and validation In most PSEs, relationships can be used to control and propagate the impacts of change.
Reference: [30] <author> W. Emmerich, G. Junkermann, B. Peuschel, W. Schafer, and S. Wolf, "MERLIN: </author> <title> Knowledge-based Process Modeling," </title> <booktitle> in [38], </booktitle> <pages> pp. 181-187, </pages> <year> 1991. </year>
Reference-contexts: Change assessment, simulation, and validation In most PSEs, relationships can be used to control and propagate the impacts of change. At the moment, EPOS does not provide facilities for simulation of changes, and weak mechanisms for formal verification of changes. MARVEL [25], Mer-lin <ref> [30] </ref> and IPSE 2.5 [24] can offer some formal verification support, and MELMAC [31] can per form simulations. <p> A tool envelope corresponds to a task class in EPOS. To change a tool interface or to remove it, is much harder and may lead to loss of functionality. Among PSEs that have an explicit representation of team structure, Merlin <ref> [30] </ref> allows this to change. Other PSEs integrate with an external project management tool to perform such actions, as for Process Weaver. EPOS can offer only some initial functionalities and it is not integrated with a project management tool.
Reference: [31] <author> V. Gruhn, </author> <title> "The Software Process Management Environment MELMAC," </title> <booktitle> in [38], </booktitle> <pages> pp. 191-201, </pages> <year> 1991. </year>
Reference-contexts: At the moment, EPOS does not provide facilities for simulation of changes, and weak mechanisms for formal verification of changes. MARVEL [25], Mer-lin [30] and IPSE 2.5 [24] can offer some formal verification support, and MELMAC <ref> [31] </ref> can per form simulations. When process evolution may happen 14 Process model changes fall into two main cate-gories: refinement/customization before enaction, as in Process Weaver, and MELMAC [31]; or correction after enaction, as in MARVEL, IPSE 2.5, SPADE, and EPOS. <p> MARVEL [25], Mer-lin [30] and IPSE 2.5 [24] can offer some formal verification support, and MELMAC <ref> [31] </ref> can per form simulations. When process evolution may happen 14 Process model changes fall into two main cate-gories: refinement/customization before enaction, as in Process Weaver, and MELMAC [31]; or correction after enaction, as in MARVEL, IPSE 2.5, SPADE, and EPOS. To implement correction after enaction either late/dynamic binding or rebuild mechanisms are needed. Generally the sec ond category includes the first. Items of Change HFSP [32] enables to define meta-rules for changing the enaction state.
Reference: [32] <author> T. Katayama, </author> <title> "A Hierarchical and Functional Software Process Description and its Enaction," </title> <booktitle> in Proc. of the 11th Int'l ACM-SIGSOFT/IEEE-CS Conference on Software Engineering, </booktitle> <address> Pitts-burgh, PA, </address> <pages> pp. 343-352, </pages> <year> 1989. </year>
Reference-contexts: To implement correction after enaction either late/dynamic binding or rebuild mechanisms are needed. Generally the sec ond category includes the first. Items of Change HFSP <ref> [32] </ref> enables to define meta-rules for changing the enaction state. This can be done also in EPOS. ARCADIA [33] can add triggers and turn on/off predicates at runtime whereas EPOS does not offer the possibility of imposing global constraints, such as predicates. <p> EPOS can offer only some initial functionalities and it is not integrated with a project management tool. Process model schema fragments are items of change in EPOS, as in SPADE, IPSE 2.5, and PRISM whereas HFSP <ref> [32] </ref> enables to change enacting models, but not schemas. PRISM [6] offers a Dependency Structure for describing change items and a Change Structure for describing change related data.
Reference: [33] <author> S. M. S. Jr., D. Heimbigner, and L. Osterweil, </author> <title> "Language Constructs for Managing Change in Process-Centered Environments," </title> <booktitle> in Proc. of the 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <address> Irvine, California. </address> <booktitle> In ACM SIGPLAN Notices, </booktitle> <month> Dec. </month> <year> 1990, </year> <pages> pp. 206-217, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: To implement correction after enaction either late/dynamic binding or rebuild mechanisms are needed. Generally the sec ond category includes the first. Items of Change HFSP [32] enables to define meta-rules for changing the enaction state. This can be done also in EPOS. ARCADIA <ref> [33] </ref> can add triggers and turn on/off predicates at runtime whereas EPOS does not offer the possibility of imposing global constraints, such as predicates. Adding new (production) tools is easy in most systems and it corresponds to the tool installation and subsequent addition of a tool envelope.
Reference: [34] <author> L. A. Stein, </author> <title> "Delegation is inheritance," </title> <booktitle> in Proc. of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'87), (Kissim-mee, Florida), </booktitle> <pages> pp. 138-146, </pages> <month> Oct. </month> <year> 1987. </year> <journal> In ACM SIGPLAN Notices 22(12), </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: As PRISM, EPOS provides a way for incrementally defining or refining class level procedures to implement changes. Object-Orientation Among the PSEs exploiting object-orientation, the closest to EPOS is IPSE 2.5 using PS-Algol, and partly MARVEL. ADELE has a hybrid object-oriented model, with run-time binding (delegation <ref> [34] </ref>) towards product and/or project contexts for customization. EPOS has derived dynamic binding and class-properties from Smalltalk [16] to gain flexibility. Database Support and versioning Many of the PSEs have their own and partially proprietary Object Management Systems (OMSes), e.g. MARVEL, ARCADIA (CHIRON). Others use existing OMSes, e.g.
Reference: [35] <editor> F. Oquendo et al., </editor> <title> "A Meta-CASE Environment for Software Process-centred CASE Environments," </title> <booktitle> in Proc. Int'l Conf. on Advanced information Systems Engineering (CAiSE'92), </booktitle> <address> Manchester, UK. </address> <publisher> Springer Verlag LNCS 593, </publisher> <pages> pp. 568-588, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: EPOS has derived dynamic binding and class-properties from Smalltalk [16] to gain flexibility. Database Support and versioning Many of the PSEs have their own and partially proprietary Object Management Systems (OMSes), e.g. MARVEL, ARCADIA (CHIRON). Others use existing OMSes, e.g. PS-Algol used in IPSE 2.5, PCTE in ALF <ref> [35] </ref>, O2 in SPADE, and LDL in OIKOS [36]. ADELE and EPOS are the only systems that rely on a fully versioned OMS, thus integrating CM and PM. Both exploit triggers and nested transactions.
Reference: [36] <author> V. Ambriola, P. Ciancarini, and C. Montangero, </author> <title> "Software Process Enactment in Oikos," </title> <booktitle> in Proceedings of the 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <address> Irvine, California, </address> <pages> pp. 183-192, </pages> <year> 1990. </year>
Reference-contexts: Database Support and versioning Many of the PSEs have their own and partially proprietary Object Management Systems (OMSes), e.g. MARVEL, ARCADIA (CHIRON). Others use existing OMSes, e.g. PS-Algol used in IPSE 2.5, PCTE in ALF [35], O2 in SPADE, and LDL in OIKOS <ref> [36] </ref>. ADELE and EPOS are the only systems that rely on a fully versioned OMS, thus integrating CM and PM. Both exploit triggers and nested transactions.
Reference: [37] <author> K. E. Huff and V. R. Lesser, </author> <title> "A plan-based intelligent assistant that supports the software development process," </title> <booktitle> in Proc. of the 3rd ACM Symposium on Software Development Environments, </booktitle> <address> (Boston, Massachusetts), </address> <pages> pp. 97-106, </pages> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: Planning The EPOS Planner uses domain-independent, non-linear planning to incrementally (re)construct task networks. As mentioned, this is inspired by TWEAK [19], and also by IPEM [20]. Other PSEs using goal-oriented AI techniques are GRAPPLE <ref> [37] </ref>, and for a similar purpose as EPOS. SPADE uses reflection to incrementally construct its task network (a PetriNet).
Reference: [38] <author> A. Fuggetta, R. Conradi, and V. </author> <title> Ambriola, </title> <editor> eds., </editor> <booktitle> Proceedings of the First European Workshop on Process Modeling (EWPM'91), </booktitle> <address> (CEFRIEL, Mi-lano, Italy, </address> <month> 30-31 May </month> <year> 1991), </year> <institution> Italian Society of Computer Science (AICA) Press, </institution> <year> 1991. </year> <month> epos/papers/evolpm-tse93/main.tex May 26, </month> <year> 1993 </year> <month> 18 </month>
References-found: 38

