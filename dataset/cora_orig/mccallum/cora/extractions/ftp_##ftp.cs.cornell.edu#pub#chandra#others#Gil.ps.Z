URL: ftp://ftp.cs.cornell.edu/pub/chandra/others/Gil.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/podc95/program.html
Root-URL: 
Title: Failure Detectors and the Wait-Free Hierarchy (Extended Abstract)  
Author: Gil Neiger 
Affiliation: Software Technology Lab Intel Corporation  
Abstract: Fault-tolerant consensus cannot be achieved in asynchronous systems with shared read/write memory. Researchers have addressed this limitation by considering shared objects more powerful than read/write memory and by augmenting such systems with failure detectors. The former approach has led to the development of the wait-free hierarchy, which characterizes concurrent data types by their ability to achieve consensus. The latter approach has led to the identification of the weakest failure detector that can be used to solve consensus with read/write memory. This paper combines these research paths by considering failure detectors that augment the synchronization power of different types in the wait-free hierarchy. It provides a hierarchy of failure detectors, one corresponding to each level in the wait-free hierarchy, and demonstrates that each is the weakest to increase the consensus power of its corresponding set of types. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Afek, Y., Greenberg, D. S., Merritt, M., and Taubenfeld, G. </author> <title> Computing with faulty shared memory. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Distributed Computing (Aug. 1992), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 47-58. </pages>
Reference: [2] <author> Afek, Y., and Stupp, G. </author> <title> Delimiting the power of bounded size synchronization objects. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing (Aug. 1994), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 42-51. </pages>
Reference: [3] <author> Afek, Y., Weisberger, E., and Weisman, H. </author> <title> A completeness theorem for a class of synchronization objects. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing (Aug. 1993), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 159-170. </pages>
Reference: [4] <author> Amir, Y., Dolev, D., Kramer, S., and Malki, D. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proceedings of the Sixth International Workshop on Distributed Algorithms, </booktitle> <editor> A. Segall and S. Zaks, Eds., </editor> <volume> no. </volume> <booktitle> 647 in Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Nov. </month> <year> 1992, </year> <pages> pp. 292-312. </pages>
Reference: [5] <author> Bazzi, R. A., Neiger, G., and Peterson, G. L. </author> <title> On the use of registers in achieving wait-free consensus. </title> <journal> Distributed Computing (1995). </journal> <note> To appear. </note>
Reference: [6] <author> Borowsky, E., Gafni, E., and Afek, Y. </author> <booktitle> Consensus power makes (some) sense! In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing (Aug. 1994), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 363-372. </pages>
Reference: [7] <author> Chandra, T., Hadzilacos, V., Jayanti, P., and Toueg, S. </author> <title> Wait-freedom versus t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing (Aug. 1994), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 334-343. </pages>
Reference: [8] <author> Chandra, T. D., Hadzilacos, V., and Toueg, S. </author> <title> The weakest failure detector for solving consensus. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Distributed Computing (Aug. 1992), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 147-158. </pages>
Reference-contexts: Eventually, some correct process is never (mistakenly) detected by any correct process. Note that 3W may be quite imperfect: failures might not detected for arbitrarily long and all correct processes (but one) may be mistakenly considered faulty. Following this, Chandra, Hadzilacos, and Toueg <ref> [8] </ref> considered how weak a failure detector could be and still be used to solve consensus. Intuitively, a failure detector's "strength" is a measure of the correctness of the information it supplies about failures. <p> Alternatively, it might select the same process but begin doing so at different times. Despite the variability in the information provided, 3W is sufficient to allow solutions to consensus in systems with message passing or with shared memory. Chandra, Hadzilacos, and Toueg <ref> [8] </ref> undertook to determine the least information that a failure detector could provide and still admit consensus algorithms. They sought a "weakest" such detector, and identified 3W as one. <p> This means to always output a set of size at most n, eventually to always output the same set, and for that set to contain at least one correct process. An envisioned construction would use techniques similar to those developed by Chandra, Hadzilacos, and Toueg <ref> [8] </ref> (and used later by Lo and Hadzilacos [22]). It would exploit the fact that there is a consensus algorithm Cons that uses read/write memory, objects of type T , and D in a system with n + 1 processes.
Reference: [9] <author> Chandra, T. D., and Toueg, S. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Distributed Computing (Aug. 1991), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 325-340. </pages> <note> A revised and expanded version appears as Technical Report 91-1225, </note> <institution> Department of Computer Science, Cornell University, </institution> <note> August 1991 and is to appear in the Journal of the ACM. </note>
Reference-contexts: Intuitively, this is because, in such a system, it is impossible to distinguish a very slow process from one that has failed. Recognizing this, researchers have considered ways in which asynchronous systems might be realistically strengthened to allow achieving consensus. Chandra and Toueg <ref> [9] </ref> considered asynchronous message-passing systems augmented by failure detectors. 1 A failure detector is a module supplied by a system that gives processes some information about failures in the system; in the simplest cases, it gives a process a list of other processes that it "suspects" have crashed. <p> Normally, other processes are not directly aware of these failures. Failure detectors are modules provided to a system that allow processes to gain additional knowledge about failures. Chandra and Toueg <ref> [9] </ref> showed that, in order to solve consensus, this additional knowledge need not be perfect or even correct. A failure detector is defined by specifying, for each failure pattern (i.e., which processes crash at what times), a set of allowable failure-detector histories. <p> A careful analysis using Konig's Lemma [25] may allow the desired bounding, or it may be that stronger failure detectors may be required. For example, Chandra and Toueg <ref> [9] </ref> defined a failure detector W that is like 3W except that removes the "eventually" qualification from Eventual Weak Accuracy (see Section 1).
Reference: [10] <author> Chor, B., Israeli, A., and Li, M. </author> <title> Wait-free consensus using asynchronous hardware. </title> <journal> SIAM J. Comput. </journal> <volume> 23, </volume> <month> 4 (Aug. </month> <year> 1994), </year> <pages> 701-712. </pages>
Reference: [11] <author> Dolev, D., Dwork, C., and Stockmeyer, L. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> J. ACM 34, </journal> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 77-97. </pages>
Reference: [12] <author> Dolev, D., and Shavit, N. </author> <title> Bounded concurrent time-stamp systems are constructible. </title> <booktitle> In Proceedings of the Twenty-First ACM Symposium on Theory of Computing (May 1989), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 454-466. </pages>
Reference: [13] <author> Dwork, C., and Waarts, O. </author> <title> Simple and efficient bounded concurrent timestamping or bounded concurrent timestamp systems are comprehensible! In Proceedings of the Twenty-Fourth ACM Symposium on Theory of Computing (May 1992), </title> <publisher> ACM Press, </publisher> <pages> pp. 655-666. </pages>
Reference: [14] <author> Fich, F., Herlihy, M., and Shavit, N. </author> <title> On the space complexity of randomized synchronization. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing (Aug. 1993), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 241-250. </pages>
Reference: [15] <author> Fischer, M. J., Lynch, N. A., and Paterson, M. S. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> J. ACM 32, </journal> <month> 2 (Apr. </month> <year> 1985), </year> <pages> 374-382. </pages>
Reference: [16] <author> Herlihy, M. </author> <title> Wait-free synchronization. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 13, </volume> <month> 1 (Jan. </month> <year> 1991), </year> <pages> 124-149. </pages>
Reference-contexts: For example, Loui and Abu-Amara [23] showed that test-and-set bits can be used to solve consensus in systems with two processes but not in those with three. Herlihy <ref> [16] </ref> considered a wide variety of object types, characterizing each by the maximum number of processes that could achieve consensus using objects of that type. <p> Arguments in Section 5 also use the following, less obvious fact: Lemma 1 If n processes can solve static consensus using read/write memory and objects of type T , then they can also solve dynamic consensus using read/write memory and objects of type T . Herlihy <ref> [16] </ref> demonstrated that consensus is universal in the following sense: if objects of type T and read/write memory can solve consensus in a system with n processes, then objects of type T and read/write memory can implement any other type in a system with n processes.
Reference: [17] <author> Israeli, A., and Li, M. </author> <title> Bounded time-stamps. </title> <booktitle> Distributed Computing 6, </booktitle> <month> 4 (July </month> <year> 1993), </year> <pages> 205-209. </pages>
Reference: [18] <author> Jayanti, P. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing (Aug. 1993), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 145-158. </pages>
Reference-contexts: Jayanti and Toueg [20; Claims 4 and 5] showed that, for each n 1, there is a type with which n processes, but not n + 1, can do consensus. Jayanti <ref> [18] </ref> subsequently refined Herlihy's work, defining a hierarchy that he called h r m . <p> The consensus number of type T is the greatest integer n such that n processes can solve consensus using read/write memory and a single object of type T (or 1 is there is no such maximum). Jayanti <ref> [18] </ref> proposed an alternative numbering defined as follows.
Reference: [19] <author> Jayanti, P., Chandra, T. D., and Toueg, S. </author> <title> Fault-tolerant wait-free shared objects. </title> <booktitle> In Proceedings of the Thirty-Third Symposium on Foundations of Computer Science (Oct. 1992), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 157-166. </pages>
Reference: [20] <author> Jayanti, P., and Toueg, S. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <booktitle> In Proceedings of the Sixth International Workshop on Distributed Algorithms, </booktitle> <editor> A. Segall and S. Zaks, Eds., </editor> <volume> no. </volume> <booktitle> 647 in Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Nov. </month> <year> 1992, </year> <pages> pp. 69-84. </pages>
Reference-contexts: Herlihy [16] considered a wide variety of object types, characterizing each by the maximum number of processes that could achieve consensus using objects of that type. Jayanti and Toueg <ref> [20; Claims 4 and 5] </ref> showed that, for each n 1, there is a type with which n processes, but not n + 1, can do consensus. Jayanti [18] subsequently refined Herlihy's work, defining a hierarchy that he called h r m . <p> Let T be a type such that h r m (T ) = i (Jayanti and Toueg showed the existence of such a type <ref> [20; Claims 4 and 5] </ref>). By Theorem 10, h r m (T ; i ) = 1. Thus, there is a consensus algorithm Cons for N processes using T and i .
Reference: [21] <author> Kleinberg, J., and Mullainathan, S. </author> <title> Resource bounds and combinations of consensus objects. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing (Aug. 1993), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 133-144. </pages>
Reference: [22] <author> Lo, W.-K., and Hadzilacos, V. </author> <title> Using failure detectors to solve consensus in asynchronous shared-memory systems. </title> <booktitle> In Proceedings of the Eighth International Workshop on Distributed Algorithms, </booktitle> <editor> G. Tel and P. Vitanyi, Eds., </editor> <volume> no. </volume> <booktitle> 857 in Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <year> 1994, </year> <pages> pp. 280-295. </pages>
Reference-contexts: Because can simulate 3W , 3W is the weakest failure detector that can be used to solve consensus (actually, it is "a" weakest detector, since has this property also). Lo and Hadzilacos considered how failure detectors might be used to solve consensus in shared-memory systems <ref> [22] </ref>. They showed results that parallel the earlier ones, namely that 3W is the weakest failure detector that can be used to solve consensus in such systems. Their results also removed a subtle restriction on the results for message-passing systems. <p> Recall the notation defined in Section 1: for type T and failure detector D, h r m (T ; D) is the maximum number of processes for which there exists a consensus algorithm using objects of type T , read/write memory, and D. Lo and Hadzilacos <ref> [22] </ref> showed that, with 3W , consensus could be solved with read/write memory for any number of processes. That is, h r m (register; 3W ) = 1. <p> Note that, for N &lt; i, read/write memory and T can do consensus without a failure detector (recall that h r m (T ) i). The algorithm is a adaptation of one given by Lo and Hadzilacos <ref> [22; Algorithm 2] </ref> for read/write memory and failure detector 3S (a slightly stronger version of 3W ). Computation occurs in asynchronous "rounds". In a given round, each process performs some specified computation and then passes on to the next round. <p> An envisioned construction would use techniques similar to those developed by Chandra, Hadzilacos, and Toueg [8] (and used later by Lo and Hadzilacos <ref> [22] </ref>). It would exploit the fact that there is a consensus algorithm Cons that uses read/write memory, objects of type T , and D in a system with n + 1 processes. The existence of Cons would be used in the simulation of n .
Reference: [23] <author> Loui, M. C., and Abu-Amara, H. H. </author> <title> Memory requirements for agreement among unreliable asynchronous processors. </title> <booktitle> In Advances in Computing Research, </booktitle> <editor> F. P. Preparata, Ed., </editor> <volume> vol. 4. </volume> <publisher> JAI Press, </publisher> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: Although consensus cannot be achieved in unaugmented asynchronous systems with shared objects that support only read and write operations, it has been shown that stronger objects allow consensus among multiple processes. For example, Loui and Abu-Amara <ref> [23] </ref> showed that test-and-set bits can be used to solve consensus in systems with two processes but not in those with three. Herlihy [16] considered a wide variety of object types, characterizing each by the maximum number of processes that could achieve consensus using objects of that type.
Reference: [24] <author> Malki, D., Birman, K., Ricciardi, A., and Schiper, A. </author> <title> Uniform actions in asynchronous distributed systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing (Aug. 1994), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 274-283. </pages>
Reference: [25] <author> Neiger, G. </author> <title> Wait-free algorithms and Konig's Lemma. </title> <type> Unpublished manuscript, </type> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: This requirement might be eliminated for types that can be reset (i.e., that support a write operation) but, for general types, it may be necessary. A careful analysis using Konig's Lemma <ref> [25] </ref> may allow the desired bounding, or it may be that stronger failure detectors may be required. For example, Chandra and Toueg [9] defined a failure detector W that is like 3W except that removes the "eventually" qualification from Eventual Weak Accuracy (see Section 1).
Reference: [26] <author> Peterson, G. L., Bazzi, R. A., and Neiger, G. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Distributed Computing (Aug. 1994), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 344-353. </pages>
Reference: [27] <author> Peterson, G. L., and Burns, J. E. </author> <title> Concurrent reading while writing II: The multi-writer case. </title> <booktitle> In Proceedings of the Twenty-Eighth Symposium on Foundations of Computer Science (Oct. 1987), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 383-392. </pages>
Reference: [28] <author> Ricciardi, A. </author> <title> The Group Membership Problem in Asynchronous Systems. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <month> Nov. </month> <year> 1992. </year> <type> Technical Report 92-1313, </type> <institution> Department of Computer Science. </institution>
Reference: [29] <author> Ricciardi, A. M., and Birman, K. P. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Distributed Computing (Aug. 1991), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 341-353. </pages>
Reference: [30] <author> Schiper, A., and Sandoz, A. </author> <title> Primary partition "virtually synchronous communication" harder than consensus. </title> <booktitle> In Proceedings of the Eighth International Workshop on Distributed Algorithms, </booktitle> <editor> G. Tel and P. Vitanyi, Eds., </editor> <volume> no. </volume> <booktitle> 857 in Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <year> 1994, </year> <pages> pp. 39-52. </pages>
Reference-contexts: Electronic mail: gil@cse.ogi.edu. 1 Because failure detectors may provide information about the processes participating in a shared computation, they are sometimes called membership services [4,24,28,29]; because they are not necessarily accurate, they have also been called failure suspectors <ref> [30] </ref>. ure detectors and showed that, even if the information they provide is imperfect, consensus can be achieved if the detector is sufficiently reliable. In particular, they defined a detector called 3W (eventually weak) and showed that it can be used to solve consensus in asynchronous message-passing systems.
References-found: 30

