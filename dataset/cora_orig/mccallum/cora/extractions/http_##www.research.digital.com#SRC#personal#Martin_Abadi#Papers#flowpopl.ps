URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/flowpopl.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  ab@cs.stevens-tech.edu  
Title: A Core Calculus of Dependency  
Author: Martjn Abadi Anindya Banerjee Nevin Heintze nch@bell-labs.com Jon G. Riecke 
Address: Compaq  riecke@bell-labs.com  
Affiliation: Systems Research Center  Stevens Institute of Technology  Bell Laboratories  Bell Laboratories  
Abstract: Notions of program dependency arise in many settings: security, partial evaluation, program slicing, and call-tracking. We argue that there is a central notion of dependency common to these settings that can be captured within a single calculus, the Dependency Core Calculus (DCC), a small extension of Moggi's computational lambda calculus. To establish this thesis, we translate typed calculi for secure information flow, binding-time analysis, slicing, and call-tracking into DCC. The translations help clarify aspects of the source calculi. We also define a semantic model for DCC and use it to give simple proofs of noninterference results for each case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi. </author> <title> Secrecy by typing in security protocols. </title> <booktitle> In Theoretical Aspects of Computer Software: Third International Symposium, volume 1281 of Lect. Notes in Computer Sci. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Other possible extensions of DCC include accounting for the spawning of concurrent threads [13] and modelling cryptographic operations in such a way that encrypting a high-security datum could produce a low-security ciphertext <ref> [1] </ref>. The relationship of DCC to semantic dependency in the context of optimizing compilers [4, 11] and to region systems for memory management [37] should also be explored. Acknowledgements Thanks to Eugenio Moggi for discussions and to the anonymous referees for their comments.
Reference: [2] <author> M. Abadi, B. Lampson, and J.-J. Levy. </author> <title> Analysis and caching of dependencies. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 8391. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: For example, the slice of the application ((lx: 3) 2) should contain only the function lx: 3 and the constant 3, since the argument 2 does not contribute to the final result. To identify such subterms, we follow Abadi et al. <ref> [2] </ref> and use a labelled lambda calculus. We give a conservative approximation of the labelled operational semantics using a type system, whereas previous work by Biswas [3] employs set-based analysis. The type system for slicing is similar to that of the SLam calculus.
Reference: [3] <author> S. K. Biswas. </author> <title> Dynamic Slicing in Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1997. </year>
Reference-contexts: To identify such subterms, we follow Abadi et al. [2] and use a labelled lambda calculus. We give a conservative approximation of the labelled operational semantics using a type system, whereas previous work by Biswas <ref> [3] </ref> employs set-based analysis. The type system for slicing is similar to that of the SLam calculus. A type s is a pair consisting of a structural part, t, and a set of labels, k, denoting slicing information.
Reference: [4] <author> R. Cartwright and M. Felleisen. </author> <title> The semantics of program dependence. </title> <booktitle> In Proceedings of the 1989 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1327. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Other possible extensions of DCC include accounting for the spawning of concurrent threads [13] and modelling cryptographic operations in such a way that encrypting a high-security datum could produce a low-security ciphertext [1]. The relationship of DCC to semantic dependency in the context of optimizing compilers <ref> [4, 11] </ref> and to region systems for memory management [37] should also be explored. Acknowledgements Thanks to Eugenio Moggi for discussions and to the anonymous referees for their comments. Anindya Banerjee is a member of the Church Project and is supported in part by NSF grant EIA-9806835. 6 November 1998
Reference: [5] <author> C. Consel. </author> <title> Binding time analysis for higher order untyped functional languages. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 264 272. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: In call-tracking [33, 34], we wish to determine the functions that may be called during evaluation; functions that are not called can be replaced by any function of the same type without affecting the final value. In binding-time analysis <ref> [5, 25] </ref>, we wish to separate static from dynamic computations; dynamic values can be replaced by any expression of the same type without affecting the static results.
Reference: [6] <author> R. Davies. </author> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, Eleventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 184195, </pages> <year> 1996. </year>
Reference-contexts: Not all aspects of dependency can be translated into DCC. For example, the binding-time analyses of Davies and Pfenning <ref> [7, 6] </ref> cannot be directly translated into DCC because DCC cannot model the coercion from run-time objects to compile-time objects. A rather different semantics due to Moggi [21] has been developed for such binding-time analyses, using the concept of a fibration to model dependency.
Reference: [7] <author> R. Davies and F. Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In Conference Record of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 258270. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: Not all aspects of dependency can be translated into DCC. For example, the binding-time analyses of Davies and Pfenning <ref> [7, 6] </ref> cannot be directly translated into DCC because DCC cannot model the coercion from run-time objects to compile-time objects. A rather different semantics due to Moggi [21] has been developed for such binding-time analyses, using the concept of a fibration to model dependency.
Reference: [8] <author> D. Denning. </author> <title> A lattice model of secure information flow. </title> <journal> Com-mun. ACM, </journal> <volume> 19(5):236242, </volume> <year> 1976. </year>
Reference-contexts: This independence property is often called the noninterference property <ref> [8, 9, 17] </ref> in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus [27] and JFlow [22, 23] also appear to satisfy the noninterference property (although this is not proved).
Reference: [9] <author> D. Denning and P. Denning. </author> <title> Certification of programs for secure information flow. </title> <journal> Commun. ACM, </journal> <volume> 20(7):504513, </volume> <year> 1977. </year>
Reference-contexts: This independence property is often called the noninterference property <ref> [8, 9, 17] </ref> in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus [27] and JFlow [22, 23] also appear to satisfy the noninterference property (although this is not proved).
Reference: [10] <author> M. Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180 190. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: The operational semantics of this calculus deviates from the original operational semantics of the SLam calculus [13] in that arguments are passed by name rather than by value. Evaluation contexts are defined in the style of Felleisen <ref> [10] </ref> by the grammar E ::= [] j (E e) j (proj i E) j (case E of inj 1 (x): e 1 j inj 2 (x): e 2 ) and the local operational rules are ((lx : s: e) k e 0 ) ! e [e 0 =x] (proj i
Reference: [11] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 9(3):319349, </volume> <year> 1987. </year>
Reference-contexts: Other possible extensions of DCC include accounting for the spawning of concurrent threads [13] and modelling cryptographic operations in such a way that encrypting a high-security datum could produce a low-security ciphertext [1]. The relationship of DCC to semantic dependency in the context of optimizing compilers <ref> [4, 11] </ref> and to region systems for memory management [37] should also be explored. Acknowledgements Thanks to Eugenio Moggi for discussions and to the anonymous referees for their comments. Anindya Banerjee is a member of the Church Project and is supported in part by NSF grant EIA-9806835. 6 November 1998
Reference: [12] <author> J. Hatcliff and O. Danvy. </author> <title> A computational formalization for partial evaluation. </title> <booktitle> Mathematical Structures in Computer Science, 7:507541, 1997. Special issue containing selected papers presented at the 1995 Workshop on Logic, Domains, and Programming Languages, </booktitle> <address> Darmstadt, Germany. </address>
Reference-contexts: G; x : s i ` e i : s G ` (case e of inj 1 (x): e 1 j inj 2 (x): e 2 ) : s * b 4.3 Binding-Time Calculus The goal of binding-time analysis is to annotate a program with binding times and specialization directives <ref> [12] </ref>. The binding times specify when data is available. For instance, if there are only two binding times, static and dynamic, then static denotes known at specialization-time and dynamic denotes known at run-time. <p> If an expression has dynamic binding time, then it is residual, i.e., it cannot be reduced at compile time. Hatcliff and Danvy define one binding-time type system, focused on the computational lambda calculus <ref> [12] </ref>. <p> Under their system, if in a dynamic context G d an expression e of type int is mapped by the analysis to an annotated term w with annotation sta (for static), then w and e must be identical and must be equivalent to some integer constant n <ref> [12, Lemma 2] </ref>. This property is exactly noninterference: static data cannot rely on dynamic data. Implicit in the Hatcliff-Danvy type system is a restriction on the structure of types. This restriction can be made explicit by defining a notion of well-formedness of types [26, 35].
Reference: [13] <author> N. Heintze and J. G. Riecke. </author> <title> The SLam calculus: programming with secrecy and integrity. </title> <booktitle> In Conference Record of the Twenty-Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 365377. </pages> <publisher> ACM, </publisher> <year> 1998. </year>
Reference-contexts: 1 Introduction Systems that incorporate aspects of program dependency arise in many different contexts. For example, type systems for secure information flow trace dependencies between outputs and inputs of a computation. These type systems are meant to guarantee secrecy and integrity. In the Secure Lambda (SLam) Calculus <ref> [13] </ref> and the while-program languages of Volpano et al. [31, 38], data may be labelled as high security or low security, and the type system ensures that all computations that depend on high-security inputs yield high-security outputs, and conversely, that low-security outputs do not depend on high-security inputs. <p> we discuss this further in the concluding discussion. 2 Commonality among Dependency Analyses Before presenting the syntax and semantics of the core language DCC, we give two examples of dependency analyses: the SLam calculus and a slicing calculus. 2.1 Why the SLam Calculus is a Dependency Analysis The SLam calculus <ref> [13] </ref> is a typed lambda calculus extended with security annotations for access control and information flow. To simplify the setting, we consider only the functional facet of the calculus with information flow, which corresponds to a fragment of the trust calculus of rbk and Palsberg [27]. <p> The rest of the operational semantics is standard and hence omitted. 3.2 Semantics The model of DCC draws on ideas from other noninterference proofs <ref> [13, 19] </ref> which use Reynolds's concept of parametricity [28]. The method is easiest to explain with an example with high- and low-security booleans. A high-security computation can depend on a high-security input, but a low-security computation cannot. <p> The restriction of recursion to function types is not essential in a call-by-name context; the restriction here merely allows us to use the same type system for a call-by-value version below. The operational semantics of this calculus deviates from the original operational semantics of the SLam calculus <ref> [13] </ref> in that arguments are passed by name rather than by value. <p> DCC can also be used to point out apparent design inconsistencies in some of the existing calculi. We are currently redesigning the Imperative SLam Calculus <ref> [13] </ref> us ing a translation into DCC as a guide for the type system, and as a vehicle for proving noninterference. The model underlying DCC simplifies proofs of noninterference. The model was also invaluable in developing DCC itself. <p> A similar comment applies to the trust oper-ator that maps from untrusted to trusted in rbk and Palsberg's work [27]. Other possible extensions of DCC include accounting for the spawning of concurrent threads <ref> [13] </ref> and modelling cryptographic operations in such a way that encrypting a high-security datum could produce a low-security ciphertext [1]. The relationship of DCC to semantic dependency in the context of optimizing compilers [4, 11] and to region systems for memory management [37] should also be explored.
Reference: [14] <author> B. T. Howard. </author> <title> Inductive, </title> <booktitle> coinductive, and pointed types. In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 102109. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: For a recent account of pointed types, see the paper by Howard <ref> [14] </ref> or Mitchell's text [18].
Reference: [15] <author> P. Hudak, S. L. Peyton Jones, P. L. Wadler, Arvind, B. Boutel, J. Fairbairn, J. Fasel, M. Guzman, K. Hammond, J. Hughes, T. Johnsson, R. Kieburtz, R. S. Nikhil, W. Partain, and J. Pe-terson. </author> <title> Report on the functional programming language Haskell, Version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: The use of the computational lambda calculus in describing dependency is somewhat surprising. Usually, the computational lambda calculus describes languages with side effects [20], or forms the basis of adding side effects like I/O to pure functional languages <ref> [15] </ref>. Dependency analyses, in contrast, do not fundamentally change the values being computed. Nevertheless, there is one common idea underlying both uses of the computational lambda calculus.
Reference: [16] <author> J. Lambek and P. Scott. </author> <title> Introduction to higher order categorical logic. Cambridge studies in advanced mathematics. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: The key property we need of DC is that it is a model of DCC (and therefore of the typed lambda calculus with products and co-products). To establish this, we adapt standard results from categorical semantics <ref> [16] </ref> to show that DC is cartesian closed, has coproducts, and has a monad for each ` 2 L. (These results are necessary to justify the constructions in this paper; however, the reader unfamiliar with category theory can safely skip them.) More concretely, if A; B;C; D are objects and f
Reference: [17] <author> J. McLean. </author> <title> Security models. </title> <editor> In J. Marciniak, editor, </editor> <booktitle> Encyclopedia of Software Engineering. </booktitle> <publisher> Wiley Press, </publisher> <year> 1994. </year>
Reference-contexts: This independence property is often called the noninterference property <ref> [8, 9, 17] </ref> in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus [27] and JFlow [22, 23] also appear to satisfy the noninterference property (although this is not proved).
Reference: [18] <author> J. C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: For a recent account of pointed types, see the paper by Howard [14] or Mitchell's text <ref> [18] </ref>. <p> We formalize these ideas via a category. Recall that a complete partial order (cpo) is a poset that contains least upper bounds for every directed subset; a cpo may or may not have a least element <ref> [18] </ref>. Recall also that a directed-complete relation is a relation that preserves least upper bounds of directed sets. <p> However, these morphisms are not the identities in the category, since they do not have the same domain and codomain. The first four of these definitions are not surprising; Mitchell's text <ref> [18] </ref> gives a history of these definitions. This structure gives us all the machinery needed to interpret the types and terms of DCC.
Reference: [19] <author> M. Mizuno and D. A. Schmidt. </author> <title> A security flow control algorithm and its denotational semantics correctness proof. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4:727754, </volume> <year> 1992. </year>
Reference-contexts: The rest of the operational semantics is standard and hence omitted. 3.2 Semantics The model of DCC draws on ideas from other noninterference proofs <ref> [13, 19] </ref> which use Reynolds's concept of parametricity [28]. The method is easiest to explain with an example with high- and low-security booleans. A high-security computation can depend on a high-security input, but a low-security computation cannot.
Reference: [20] <author> E. Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Control, </journal> <volume> 93:5592, </volume> <year> 1991. </year>
Reference-contexts: They help confirm some seemingly ad hoc decisions in some calculi and have uncovered some problems and incompletenesses in others. Third, general results about DCC yield simple noninterference proofs for the individual dependency analyses. DCC is a simple extension of Moggi's computational lambda calculus <ref> [20] </ref>. Typically the computational lambda calculus has a single type constructor that is semantically associated with a monad. In DCC, this notion is extended to incorporate multiple monads, one for every level of a predetermined information lattice. The use of the computational lambda calculus in describing dependency is somewhat surprising. <p> In DCC, this notion is extended to incorporate multiple monads, one for every level of a predetermined information lattice. The use of the computational lambda calculus in describing dependency is somewhat surprising. Usually, the computational lambda calculus describes languages with side effects <ref> [20] </ref>, or forms the basis of adding side effects like I/O to pure functional languages [15]. Dependency analyses, in contrast, do not fundamentally change the values being computed. Nevertheless, there is one common idea underlying both uses of the computational lambda calculus. <p> if under the assumption (x : (t; k 1 )), the expression e has type (int; k 2 ), where k 1 6 k 2 in the powerset lattice, then e must not depend on x. 3 Dependency Core Calculus DCC is a minor extension of Moggi's computational lambda calculus <ref> [20] </ref>. Three features distinguish it from the computational lambda calculus. First, the calculus contains sum types and lifted types, as well as term recursion. Lifting allows us to model call-by-value calculi.
Reference: [21] <author> E. Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In Proceedings, Mathematical Foundations of Programming Semantics, Thirteenth Annual Conference, Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1997. </year> <note> Available from http://www.elsevier.nl/locate/entcs/. </note>
Reference-contexts: Not all aspects of dependency can be translated into DCC. For example, the binding-time analyses of Davies and Pfenning [7, 6] cannot be directly translated into DCC because DCC cannot model the coercion from run-time objects to compile-time objects. A rather different semantics due to Moggi <ref> [21] </ref> has been developed for such binding-time analyses, using the concept of a fibration to model dependency. A similar comment applies to the trust oper-ator that maps from untrusted to trusted in rbk and Palsberg's work [27].
Reference: [22] <author> A. C. Myers and B. Liskov. </author> <title> A decentralized model for information flow control. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles. </booktitle> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: This independence property is often called the noninterference property [8, 9, 17] in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus [27] and JFlow <ref> [22, 23] </ref> also appear to satisfy the noninterference property (although this is not proved).
Reference: [23] <author> A. C. Myers. </author> <title> Practical mostly-static information flow control. </title> <booktitle> In Conference Record of the Twenty-sixth Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <year> 1999. </year>
Reference-contexts: This independence property is often called the noninterference property [8, 9, 17] in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus [27] and JFlow <ref> [22, 23] </ref> also appear to satisfy the noninterference property (although this is not proved).
Reference: [24] <author> F. Nielson. </author> <title> Strictness analysis and denotational abstract interpretation. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 120131. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Low-security computations can therefore not take advantage of the distinctions between the high-security booleans. Sabelfeld and Sands develop these ideas in a recent manuscript [30]; similar constructions appear in Nielson's work on strictness analysis <ref> [24] </ref>. We formalize these ideas via a category. Recall that a complete partial order (cpo) is a poset that contains least upper bounds for every directed subset; a cpo may or may not have a least element [18].
Reference: [25] <author> H. R. Nielson and F. Nielson. </author> <title> Automatic binding time analysis for a typed l calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 10:139176, </address> <year> 1988. </year>
Reference-contexts: In call-tracking [33, 34], we wish to determine the functions that may be called during evaluation; functions that are not called can be replaced by any function of the same type without affecting the final value. In binding-time analysis <ref> [5, 25] </ref>, we wish to separate static from dynamic computations; dynamic values can be replaced by any expression of the same type without affecting the static results.
Reference: [26] <author> H. R. Nielson and F. Nielson. </author> <title> Two-Level Functional Lan--guages, </title> <booktitle> volume 34 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This property is exactly noninterference: static data cannot rely on dynamic data. Implicit in the Hatcliff-Danvy type system is a restriction on the structure of types. This restriction can be made explicit by defining a notion of well-formedness of types <ref> [26, 35] </ref>. For example, if dyn denotes dynamic binding-time with sta dyn, the types ((int; sta) ! (int; sta); dyn) and ((int; sta) fi (int; sta); dyn) are ill-formed, whereas ((int; dyn) ! (int; dyn); sta) is well-formed. Using DCC, we can give a more generic account of this system.
Reference: [27] <author> P. rbk and J. Palsberg. </author> <title> Trust in the l-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 7(6):557591, </volume> <month> November </month> <year> 1997. </year>
Reference-contexts: This independence property is often called the noninterference property [8, 9, 17] in the security literature: high-security data does not interfere with the calculation of low-security outputs. Fragments of the trust calculus <ref> [27] </ref> and JFlow [22, 23] also appear to satisfy the noninterference property (although this is not proved). <p> To simplify the setting, we consider only the functional facet of the calculus with information flow, which corresponds to a fragment of the trust calculus of rbk and Palsberg <ref> [27] </ref>. A type s is a pair consisting of a structural part, t, and a security annotation, k, denoting information flow and ranging over elements in a security lattice L, with least element L and greatest element H. <p> In the next section, we study calculi that satisfy the weaker version of noninterference. 4.1 Call-by-name Functional SLam Calculus Our first source calculus is the call-by-name, purely functional version of the SLam calculus; this calculus is essentially the trust calculus of rbk and Palsberg <ref> [27] </ref> without the coercion from high to low security. Let L denote a join semilattice of security levels and let k range over the levels of L. <p> A rather different semantics due to Moggi [21] has been developed for such binding-time analyses, using the concept of a fibration to model dependency. A similar comment applies to the trust oper-ator that maps from untrusted to trusted in rbk and Palsberg's work <ref> [27] </ref>. Other possible extensions of DCC include accounting for the spawning of concurrent threads [13] and modelling cryptographic operations in such a way that encrypting a high-security datum could produce a low-security ciphertext [1].
Reference: [28] <author> J. C. Reynolds. </author> <title> Types, abstraction and parametric polymor-phism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 513523. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1983. </year>
Reference-contexts: The rest of the operational semantics is standard and hence omitted. 3.2 Semantics The model of DCC draws on ideas from other noninterference proofs [13, 19] which use Reynolds's concept of parametricity <ref> [28] </ref>. The method is easiest to explain with an example with high- and low-security booleans. A high-security computation can depend on a high-security input, but a low-security computation cannot.
Reference: [29] <author> J. G. Riecke and R. Viswanathan. </author> <title> Isolating side effects in sequential languages. </title> <booktitle> In Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 112. </pages> <publisher> ACM, </publisher> <year> 1995. </year>
Reference: [30] <author> A. Sabelfeld and David Sands. </author> <title> A Per model of secure information flow in sequential programs. </title> <type> Unpublished manuscript, </type> <year> 1998. </year>
Reference-contexts: The low-security view, in contrast, is the everywhere true relationthat is, x is related to y for all x and y. Low-security computations can therefore not take advantage of the distinctions between the high-security booleans. Sabelfeld and Sands develop these ideas in a recent manuscript <ref> [30] </ref>; similar constructions appear in Nielson's work on strictness analysis [24]. We formalize these ideas via a category. Recall that a complete partial order (cpo) is a poset that contains least upper bounds for every directed subset; a cpo may or may not have a least element [18].
Reference: [31] <author> G. Smith and D. Volpano. </author> <title> Secure information flow in a multi-threaded imperative language. </title> <booktitle> In Conference Record of the Twenty-Fifth Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <year> 1998. </year>
Reference-contexts: For example, type systems for secure information flow trace dependencies between outputs and inputs of a computation. These type systems are meant to guarantee secrecy and integrity. In the Secure Lambda (SLam) Calculus [13] and the while-program languages of Volpano et al. <ref> [31, 38] </ref>, data may be labelled as high security or low security, and the type system ensures that all computations that depend on high-security inputs yield high-security outputs, and conversely, that low-security outputs do not depend on high-security inputs. <p> The correctness properties are the same as for the call-by-name, functional SLam calculus. 4.4 Smith-Volpano Calculus The Smith-Volpano calculus <ref> [31] </ref> is a simple language of while-programs, modified so that the types keep track of the security levels of variables and commands. Just as in the SLam calculus, the type system prevents high-security inputs from influencing low-security outputs. <p> The subtyping relation, used in the typing rules, is based on the primitive relations L H and H cmd L cmd. The typing rules for the calculus appear in Table 5. In order to keep the translation to DCC simple, we modify the original type rules <ref> [31] </ref> in two ways. First, variables have types L or H; variables of command type, possible in the original Smith-Volpano calculus, appear to have no use. <p> Low commands, in contrast, can modify high and low variables. Second, while loops may include only low expressions and low commands. Without this restriction, the type system does not satisfy the strong noninterference property. Indeed, concurrency can be used to leak information <ref> [31] </ref>. From the restriction on while loops, it follows that only low commands may diverge. The translation of the Smith-Volpano calculus into DCC depends on these two observations. <p> Dually, if (c; s 0 ) ! fl s 0 0 , then (c; s) ! fl s 0 and s 0 G L s 0 The proof of the noninterference theorem uses the semantic model of DCC, whereas the original operational proof uses a more detailed operational analysis <ref> [31] </ref>. 5 Applications II: A Weaker Version of Noninterference Not all calculi that track dependency satisfy the strong version of noninterference. For example, the original functional SLam calculus uses a call-by-value semantics rather than a call-by-name semantics.
Reference: [32] <author> C. Strachey. </author> <title> The varieties of programming language. </title> <booktitle> In Proceedings of the International Computing Symposium, </booktitle> <pages> pages 222233. </pages> <publisher> Cini Foundation, </publisher> <address> Venice, </address> <year> 1972. </year> <editor> Reprinted in Peter O'Hearn and Robert Tennent, eds., </editor> <booktitle> Algol-like Languages. </booktitle> <publisher> Birkhauser, </publisher> <year> 1997. </year>
Reference-contexts: There are three advantages to this foundational approach. First, DCC gives us a way to compare dependency analyses. This idea relates back to Strachey's conception of denotational semantics as a tool for comparing languages <ref> [32] </ref>. Second, the translations themselves yield a check on type systems for dependency analysis. They help confirm some seemingly ad hoc decisions in some calculi and have uncovered some problems and incompletenesses in others. Third, general results about DCC yield simple noninterference proofs for the individual dependency analyses.
Reference: [33] <author> Y.-M. Tang. </author> <title> SystOEemes d'effet et interpretation abstraite pour l'analyse de flot de contr ole. </title> <type> PhD thesis, </type> <institution> Ecole Nationale Superiere des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: For instance, in slicing [36, 40], the aim is to determine those parts of a program that may contribute to the output; those parts that do not contribute can be replaced by any expression of the same type. In call-tracking <ref> [33, 34] </ref>, we wish to determine the functions that may be called during evaluation; functions that are not called can be replaced by any function of the same type without affecting the final value. <p> (s 1 + s 2 ); k G; x : s i ` e i : s; k 0 G ` (case e of inj 1 (x): e 1 j inj 2 (x): e 2 ) : s; k t k 0 5.2 Call-tracking Calculus Types in the call-tracking calculus <ref> [33, 34] </ref> are given by the grammar s ::= unit j (s + s) j (s fi s) j (s k where k ranges over sets of labels. (These labels occur only on lambdas.) The typing rules appear in Table 6.
Reference: [34] <author> Y.-M. Tang and P. Jouvelot. </author> <title> Effect systems with subtyping. </title> <booktitle> In ACM Conference on Partial Evaluation and Program Manipulation, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: For instance, in slicing [36, 40], the aim is to determine those parts of a program that may contribute to the output; those parts that do not contribute can be replaced by any expression of the same type. In call-tracking <ref> [33, 34] </ref>, we wish to determine the functions that may be called during evaluation; functions that are not called can be replaced by any function of the same type without affecting the final value. <p> (s 1 + s 2 ); k G; x : s i ` e i : s; k 0 G ` (case e of inj 1 (x): e 1 j inj 2 (x): e 2 ) : s; k t k 0 5.2 Call-tracking Calculus Types in the call-tracking calculus <ref> [33, 34] </ref> are given by the grammar s ::= unit j (s + s) j (s fi s) j (s k where k ranges over sets of labels. (These labels occur only on lambdas.) The typing rules appear in Table 6.
Reference: [35] <author> P. Thiemann. </author> <title> A unified framework for binding-time analysis. </title> <editor> In M. Bidoit, editor, </editor> <booktitle> Colloquium on Formal Approaches in Software Engineering (FASE '97), volume 1214 of Lect. Notes in Computer Sci., </booktitle> <pages> pages 742756. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: This property is exactly noninterference: static data cannot rely on dynamic data. Implicit in the Hatcliff-Danvy type system is a restriction on the structure of types. This restriction can be made explicit by defining a notion of well-formedness of types <ref> [26, 35] </ref>. For example, if dyn denotes dynamic binding-time with sta dyn, the types ((int; sta) ! (int; sta); dyn) and ((int; sta) fi (int; sta); dyn) are ill-formed, whereas ((int; dyn) ! (int; dyn); sta) is well-formed. Using DCC, we can give a more generic account of this system. <p> Types in the binding-time calculus are therefore t ::= unit j (s + s) j (s fi s) j (s ! s) s ::= (t; b) The well-formed types <ref> [35] </ref> are a subset of the types defined as follows: * (unit; b) and (s 1 + s 2 ; b) are well-formed. * ((t 1 ; b 1 ) o p (t 2 ; b 2 ); b) is well-formed iff (t 1 ; b 1 ) and (t 2
Reference: [36] <author> F. </author> <title> Tip. A survey of program slicing techniques. </title> <journal> Journal of Programming Languages, </journal> <volume> 3(3):121189, </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: Correctness of these analyses is often expressed using properties analogous to noninterference. For instance, in slicing <ref> [36, 40] </ref>, the aim is to determine those parts of a program that may contribute to the output; those parts that do not contribute can be replaced by any expression of the same type. <p> More generally, if in the context (x : (t; H)) expression e has type (bool; L), then noninterference says that e must not depend on the high-security variable x, and hence must be constant with respect to x. 2.2 Why the Slicing Calculus is a Dependency Analysis In program slicing <ref> [36, 40] </ref>, we seek the dependencies of a programi.e., those subterms of the program that may contribute to its output.
Reference: [37] <author> M. Tofte and J.-P. </author> <title> Talpin. </title> <booktitle> Region-based memory management. Information and Computation, </booktitle> <address> 132(2):109176, </address> <year> 1997. </year>
Reference-contexts: The relationship of DCC to semantic dependency in the context of optimizing compilers [4, 11] and to region systems for memory management <ref> [37] </ref> should also be explored. Acknowledgements Thanks to Eugenio Moggi for discussions and to the anonymous referees for their comments. Anindya Banerjee is a member of the Church Project and is supported in part by NSF grant EIA-9806835. 6 November 1998
Reference: [38] <author> D. Volpano, G. Smith, and C. </author> <title> Irvine. A sound type system for secure flow analysis. </title> <journal> Journal of Computer Security, </journal> <volume> 4(3):1 21, </volume> <year> 1996. </year>
Reference-contexts: For example, type systems for secure information flow trace dependencies between outputs and inputs of a computation. These type systems are meant to guarantee secrecy and integrity. In the Secure Lambda (SLam) Calculus [13] and the while-program languages of Volpano et al. <ref> [31, 38] </ref>, data may be labelled as high security or low security, and the type system ensures that all computations that depend on high-security inputs yield high-security outputs, and conversely, that low-security outputs do not depend on high-security inputs. <p> For example, the original functional SLam calculus uses a call-by-value semantics rather than a call-by-name semantics. In this calculus, high-security inputs may affect the termination behaviorbut not the outputsof a low-security computation. An earlier version of the Smith-Volpano calculus, due to Volpano, Smith, and Irvine <ref> [38] </ref>, also satisfies this weaker notion of noninterference; the strong version of noninterference seems to require the restriction of while-loops to low commands. Unfortunately, it seems difficult to use DCC directly to model these languages. We must alter the syntax and semantics of DCC slightly.
Reference: [39] <author> P. Wadler. </author> <title> The marriage of effects and monads. </title> <booktitle> In Proceedings of the 1998 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 6374. </pages> <publisher> ACM, </publisher> <year> 1998. </year>
Reference-contexts: Lifting allows us to model call-by-value calculi. Second, instead of having one type constructor T semantically associated with a monad, the calculus incorporates multiple type constructors T ` , one for every element ` 2 L of a predetermined lattice L. This idea was also considered by Wadler <ref> [39] </ref>. The lattice represents different grades of information. In the security setting, the least element usually stands for low security. Type constructors T ` change the level of a type. For instance T H (bool) describes high-security booleans.
Reference: [40] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 10(4):352357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Correctness of these analyses is often expressed using properties analogous to noninterference. For instance, in slicing <ref> [36, 40] </ref>, the aim is to determine those parts of a program that may contribute to the output; those parts that do not contribute can be replaced by any expression of the same type. <p> More generally, if in the context (x : (t; H)) expression e has type (bool; L), then noninterference says that e must not depend on the high-security variable x, and hence must be constant with respect to x. 2.2 Why the Slicing Calculus is a Dependency Analysis In program slicing <ref> [36, 40] </ref>, we seek the dependencies of a programi.e., those subterms of the program that may contribute to its output.
References-found: 40

