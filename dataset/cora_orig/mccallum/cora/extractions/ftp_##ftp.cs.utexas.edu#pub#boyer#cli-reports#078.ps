URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/078.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Title: A Proved Application with Simple Real-Time Properties  
Author: Matthew Wilding 
Address: 1717 West Sixth Street, Suite 290 Austin, Texas 78703-4776  
Affiliation: Computational Logic, Inc.  
Pubnum: Technical Report  
Email: EMAIL: wilding@cli.com  
Phone: TEL: +1 512 322 9951  
Date: 78 October, 1992  
Abstract: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Albin, Hunt, and Wilding. </author> <note> Fm9001 fabrication (in preparation). Technical Report ??, CLI, </note> <year> 1992. </year>
Reference-contexts: Two other related projects have used the interpreter approach. [11] describes a verified compiler for the Pascal-like language Micro-Gypsy that generates Piton code. [6] and <ref> [1] </ref> describe a microprocessor design that is proved to satisfy the behavior formalized by the FM9001 specification. <p> Taken together these projects are known as the CLI short stack. Recent work on fabricating and making usable the FM9001 has progressed. It is possible to run a Piton program on an actual FM9001 using a specially-constructed test board. (See <ref> [1] </ref> for a description of this effort, including details of three trivial but currently unverified changes made to the Piton compiler to make the compiled Piton code usable on the FM9001 test board.) Real-time programs are programs that have real, "clock on the wall", timing requirements. <p> An FM9001 has been fabricated by LSI logic, and has run a compiled version of the Nim program. Some FM9001 code was written that allows the Piton Nim program to be run interactively. See <ref> [1] </ref> for details. The FM9001 microprocessor, the Piton compiler, and the Nim program were never tested in a conventional manner.
Reference: [2] <author> William R. Bevier, Warren A. Hunt Jr., J Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: An interpreter function serves as a precise specification for the expected behavior of a system component. This general approach to system verification is A Proved Application with Simple Real-Time Properties Technical Report #78 3 described fully in <ref> [2] </ref>. Interpreter functions can be very complex: Piton has 71 instructions and some high-level features, and the definition of P in the Nqthm logic requires about 50 pages. <p> In this project we prove that the number of Piton instructions a program executes is within a specified range. This is a natural sort of proof to accomplish given the interpreter-based approach used to formalize programming languages in <ref> [2] </ref>. We will call this kind of constraint a simple real-time property of the program since, by knowing the bounds of the Piton instruction execution times, we can in principle derive execution time bounds from bounds on the execution times of the individual instructions.
Reference: [3] <author> Charles L. Bouton. </author> <title> Nim, a game with a complete mathematical theory. </title> <journal> In Annals of Mathematics, </journal> <volume> volume 3, </volume> <pages> 1901-02. </pages>
Reference-contexts: Let (GREEN-STATEP state) = (BIGP state)&gt;0 $ (XOR-BVS state)6=0-vector. Theorem: (GREEN-STATEP state) $ (WSP state t). This remarkable property was rediscovered at Computational Logic, but has in fact been known at least since its publication in 1901 <ref> [3] </ref>. The most obvious A Proved Application with Simple Real-Time Properties Technical Report #78 12 proof uses an induction on the search tree.
Reference: [4] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Appendix A lists the program, and Appendix B lists the input to a mechanical theorem prover that constitutes a mechanical proof of the correctness theorem. 2 Background Nqthm is the name of both a logic and an associated theorem-proving system that are documented in <ref> [4] </ref>. A large number of mathematical theorems from many disparate domains have been proved using Nqthm. One of these domains is computer systems verification.
Reference: [5] <author> Martin Gardner. </author> <title> Mathematical Puzzles and Diversions. </title> <editor> Simon and Schus-ter, </editor> <address> New York, </address> <year> 1959. </year>
Reference-contexts: A Proved Application with Simple Real-Time Properties Technical Report #78 4 3 A specification for a good Nim program 3.1 Good Nim Play Nim is one of the oldest and one of the most engaging mathematical games <ref> [5] </ref>. The game is played with piles of stones and two players who alternate turns. On his turn a player removes at least one stone from exactly one pile. The player who removes the final stone loses. Figure 2 shows an example game.
Reference: [6] <author> Warren A. Hunt Jr. </author> <title> Microprocessor design verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 429-460, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Two other related projects have used the interpreter approach. [11] describes a verified compiler for the Pascal-like language Micro-Gypsy that generates Piton code. <ref> [6] </ref> and [1] describe a microprocessor design that is proved to satisfy the behavior formalized by the FM9001 specification.
Reference: [7] <author> Matt Kaufmann. </author> <title> A user's manual for an interactive enhancement to the boyer-moore theorem prover. </title> <type> Technical Report 60, </type> <institution> Institute for Computing Science, University of Texas at Austin, Austin, Texas, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: That is, that the algorithm outlined in Section 4 works. We call proofs of this kind of lemma algorithm proofs. * Some lemmas establish bounds on the clock functions. We call proofs of this kind of lemma timing proofs. The timing proofs were done using PC-Nqthm <ref> [7] </ref>, the interactive enhancement to Nqthm. All other proofs require only Nqthm. The algorithm proofs and time bound proofs are fairly standard mechanical proofs of a type done often before, so we will not discuss them in detail. <p> I PUSH-LOCAL I PUSH-LOCAL I SUB1-NAT CALL REPLACE-VALUE RET A Proved Application with Simple Real-Time Properties Technical Report #78 22 B Nim Correctness proof These events constitute a proof of the correctness of the Nim program except for some events regarding timing bounds that were proved separately using PC Nqthm <ref> [7] </ref> and are not included here. (proveall "nim" '( ;; NIM Piton proof ;; Matt Wilding 4-15-92 ;; modified 7-92 to work on Piton library ;; This script takes 10 hours to run on a 64 meg Sparc2 ;; This work is described in Technical Report #78.
Reference: [8] <author> J Strother Moore. </author> <title> A mechanically verified language implementation. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 493-518, </pages> <month> December </month> <year> 1989. </year> <note> Also published as CLI Technical Report 30. </note>
Reference-contexts: One of these domains is computer systems verification. A Proved Application with Simple Real-Time Properties Technical Report #78 2 (n Piton interpreter steps) P (P0, n) || /" LOAD (P0) || || DISPLAY (Mk) || || M0 ---------------------------&gt; Mk FM9001-DESIGN (M0, k) (k FM9001 interpreter steps) <ref> [8] </ref> describes the implementation of a compiler for the language Piton and the associated mechanically-checked correctness theorem. A formal semantics for Piton, a formal description of the FM9001 microprocessor, and the Piton compiler are introduced as Nqthm functions. <p> Piton interpreter on a "reasonable" Piton state for COMPUTER-MOVE-CLOCK "ticks" the resulting state has the program counter incremented by 1, the program status word set to 'run, and the naturals array representing the Nim state replaced by a new array with the same value as that calculated by COMPUTER-MOVE. (See <ref> [8] </ref> for a full description of the Piton interpreter P and the significance of the program status word and program counter.) 1 We use upper case for Nqthm event names such as lemma names and function definition names and lower case for the name of Piton subroutine names. <p> in COMPUTER-MOVE-IMPLEMENTED-INPUT-CONDITIONP above.) (lessp (plus (nim-piton-ctrl-stk-requirement) (nim-piton-temp-stk-requirement)) 1000) This part of the specification eliminates, for example, a table-driven implementation since there are 2 177 distinct states. 3.2.6 FM9001 Loadability We require that the program work on an FM9001 and that it meet the requirements of the compiler correctness proof of <ref> [8] </ref>. This requires among other things that the compiled Piton programs fit into the FM9001 address space and that the Piton programs be well-formed. <p> Figure 6 lists two of the routines in that appendix. 5 The Nqthm correctness proof 5.1 Different types of theorems in the proof The proof that the Piton program meets the specification uses the default arithmetic library [9] and the Piton interpreter definitions <ref> [8] </ref>. Most of the lemmas in the proof script fall into one of the following four categories or are designed specifically to support a lemma in one of the categories. <p> A modest but non-trivial application has been constructed for use on the verified CLI short stack. Its functional correctness has been verified using Nqthm. Mechanically-checked proofs of bounds on the number of executed instructions have been constructed. The formalization of a programming language with an interpreter as in <ref> [8] </ref> is particularly well-suited to proving program timing properties. An FM9001 has been fabricated by LSI logic, and has run a compiled version of the Nim program. Some FM9001 code was written that allows the Piton Nim program to be run interactively. See [1] for details.
Reference: [9] <author> Matthew Wilding. </author> <title> Proving Matijasevich's lemma with a default arithmetic strategy. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(3), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: Figure 6 lists two of the routines in that appendix. 5 The Nqthm correctness proof 5.1 Different types of theorems in the proof The proof that the Piton program meets the specification uses the default arithmetic library <ref> [9] </ref> and the Piton interpreter definitions [8]. Most of the lemmas in the proof script fall into one of the following four categories or are designed specifically to support a lemma in one of the categories.
Reference: [10] <author> Matthew Wilding. </author> <title> A verified nim strategy. Internal Note 249, Computational Logic, </title> <publisher> Inc., </publisher> <month> November </month> <year> 1991. </year>
Reference-contexts: Even so, they each worked the first time and we would have been surprised if they had not. 3 This does not include the events of the Piton compiler or arithmetic library. It does not include the time to accomplish an earlier proof related to Nim <ref> [10] </ref>. It does not include the time taken to prepare a report and a talk on this project. A Proved Application with Simple Real-Time Properties Technical Report #78 17 A Nim-playing Piton program listing This appendix contains a listing of the Nim Piton program.
Reference: [11] <author> William D. Young. </author> <title> A mechanically verified code generator. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 493-518, </pages> <month> December </month> <year> 1989. </year> <note> Also published as CLI Technical Report 30. </note> <editor> Acknowledgements: </editor> <title> I thank J Moore and Bill Bevier for many very valuable suggestions related to this work. Bill Young made a careful reading of a draft of this report and his comments improved it considerably. </title>
Reference-contexts: Interpreter functions can be very complex: Piton has 71 instructions and some high-level features, and the definition of P in the Nqthm logic requires about 50 pages. Two other related projects have used the interpreter approach. <ref> [11] </ref> describes a verified compiler for the Pascal-like language Micro-Gypsy that generates Piton code. [6] and [1] describe a microprocessor design that is proved to satisfy the behavior formalized by the FM9001 specification.
References-found: 11

