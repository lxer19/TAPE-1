URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/papers/arx_ultra.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/schedule.html
Root-URL: 
Title: ARX/ULTRA: A New Real-Time Kernel Architecture for Supporting User-Level Threads  
Author: Seongsoo Hong, Yangmin Seo, Jungkeun Park 
Abstract: In this paper we present a new real-time kernel architecture that is capable of supporting user-level threads. Although user-level threads offer an essential mechanism for structuring applications and representing concurrency, they are not widely exploited in real-time programming for the lack of capabilities for signal handling and thread scheduling. The kernel, we named ARX, provides a clean and efficient solution to this problem. First, it provides dynamic stack binding to prevent a blocked thread from preempting the entire process. Second, it offers the scheduling event upcall facility to efficiently propagate kernel events to users so that the user-level scheduler can timely handle events in an application-specific way. In order to reduce the upcall overhead, the kernel also provides a novel, lock-free implementation of thread sched-ulers. Finally, the kernel offers a reservation-based process scheduling mechanism for real-time processes. We have successfully implemented full-fledged real-time kernel ARX and user-level thread package ULTRA on an Intel Pentium PC. We have ported representative soft and hard real-time applications onto the ARX kernel, and performed extensive experiments. Our experiments clearly show that the ARX kernel mechanisms incur very low overhead and offer acceptable performance with real-time guarantees. fl The work reported in this paper was supported in part by Engineering Research Center for Advanced Control and Instrumentation (ERC-ACI) under Grant 96K3-0707-02-06-1, KOSEF under Grant 96-2037, and S.N.U. Korea Electric Power Corp. Research Fund under Grant 96-15-1135. y School of Electrical Engineering and ERC-ACI, Seoul National University, Seoul 151-742, Korea. Email: sshong@redwood.snu.ac.kr. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction In modern operating systems, threads have emerged as an essential mechanism for structuring applications and representing concurrency <ref> [1] </ref>. They are extensively substituting traditional UNIX-like processes. More and more operating systems have been modified, and even created to support threaded programming. <p> This motivates us to investigate a new kernel architecture which best optimizes this tradeoff for real-time threads. 1.1 Motivations In conventional programming, user-level threads are much more favored than kernel-level threads mainly for two reasons <ref> [1] </ref>: (1) kernel-level threads provide wrong abstraction for a programming environment, since they require that every application should be mapped onto a single thread implementation that the kernel provides; and (2) kernel-level threads incur more overhead than user-level threads, since with the kernel-level threads, processes must cross an extra user/kernel protection <p> We report the results of these experiments. 3 1.2 Related Work The ARX approach is built upon previous work on thread implementation and scheduling. In particular, we adopted several techniques presented in <ref> [1, 6] </ref> and extended them, since they presented only partial solutions to our problem. First, in [6], Govindan and Anderson proposed the split-level scheduling of real-time threads for continuous media applications. <p> It also makes it difficult to maintain separation of concerns between applications, since threads in distinct address spaces can interfere with each other. Consequently, this coupling becomes the major drawback of the split-level scheduling approach. In <ref> [1] </ref>, Anderson et al. proposed a new thread implementation mechanism to effectively manage user-level parallelism. <p> A class of scheduling algorithms that meet this requirement includes the weighted fair queuing (WFQ) algorithm [4, 13] and its variants [8, 18]. We incorporated the WFQ algorithm in the ARX kernel and used it for process scheduling. For the second goal, we adopted the scheduler activation from <ref> [1] </ref> and specialized it for real-time processing. We refer to the new scheme as dynamic stack binding. With this scheme, the kernel can instantly create a kernel stack and bind it to another ready thread. Finally, for the third goal, we devised a mechanism we named scheduling event upcall. <p> Thread A is put into the ready queue. Since thread C is still the highest priority thread, it continues it execution until t 7 when it calls thread sleep () library function to relinquish the CPU. Note that with the scheduler activation <ref> [1] </ref>, the control could not be given to thread C at t 6 ; instead, thread A would continue until it finishes up the blocked system call.
Reference: [2] <author> T. Baker and A. Shaw. </author> <title> The cyclic executive model and Ada. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1(1) </volume> <pages> 7-25, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The digital video application may be efficiently run with EDF scheduling, whereas the NC machine controller may use cyclic executive scheduling <ref> [2, 10] </ref> for deterministic responses.
Reference: [3] <author> H. Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, Washington, </address> <year> 1993. </year>
Reference-contexts: More and more operating systems have been modified, and even created to support threaded programming. For example, Sun Microsystems extended their own operating system to incorporate multithreading capability [15, 17]; many micro-kernel based operating systems including Mach and Windows NT were designed from scratch to support multithreading <ref> [3, 19] </ref>. This trend is not an exception in real-time operating systems. POSIX specifies a priority-driven thread model in its thread extension standard [5]. The reason behind such popularity is clear.
Reference: [4] <author> A. Dermers, S. Keshav, and S. Shenkar. </author> <title> Analysis and simulation of a fair queueing algorithm. </title> <journal> Journal of Internetworking Research & Experience, </journal> <pages> pages 3-12, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The ARX approach is also inspired by the recent advances of QoS (quality of service) scheduling techniques. Specifically, it relies on the weighted fair queuing (WFQ) algorithm <ref> [4, 13] </ref>, for the kernel-level process scheduling. Although the WFQ algorithm was devised for proportional bandwidth allocation in communication networks, it works for CPU scheduling, as shown in [7, 18]. <p> For the first goal, we required that the kernel scheduler should not be involved in thread scheduling, but provide an address space switching mechanism that can maintain fairness among real-time processes. A class of scheduling algorithms that meet this requirement includes the weighted fair queuing (WFQ) algorithm <ref> [4, 13] </ref> and its variants [8, 18]. We incorporated the WFQ algorithm in the ARX kernel and used it for process scheduling. For the second goal, we adopted the scheduler activation from [1] and specialized it for real-time processing. We refer to the new scheme as dynamic stack binding. <p> Finally, we present a novel, lock-free implementation of user-level schedulers that can resolve the consistency problem of shared data structures. 3.1 The Kernel Scheduler The ARX kernel makes use of the WFQ algorithm for process scheduling. The algorithm was devised by Demers, Keshav, and Shenker in <ref> [4] </ref> for bandwidth allocation in communication networks. It was originally intended to emulate a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet. <p> With the WFQ algorithm, we can bound the maximum delay that a process can experience. In <ref> [4] </ref>, the maximum delay bound of process t i is given as below. EAT (a k C k r i where EAT (a k i ) is the kth expected arrival time of process t i and C max is the maximum execution time of a quantum. <p> We measured the number of frames decoded by the three MPEG processes. Figure 5 shows the results of the experiments. We can see that the number of decoded frames is proportional to their weights. This is consistent with the analytical results of the original WFQ algorithm found in <ref> [4, 13] </ref>. 5.3 Hard Real-Time Performance We experimented with the CNC controller program to show that the ARX kernel could provide hard real-time guarantees. The CNC software was implemented using two PCs, one running the controller software, and the other simulating a plant.
Reference: [5] <institution> Institute for Electrical and Electronic Engineers. POSIX P1003.4a, threads extension for portable operating systems, </institution> <year> 1994. </year>
Reference-contexts: This trend is not an exception in real-time operating systems. POSIX specifies a priority-driven thread model in its thread extension standard <ref> [5] </ref>. The reason behind such popularity is clear. Not only threads can offer the desired level of abstraction for representing concurrency, but also it can support efficient resource management and fast context switching. This helps real-time operating systems provide short and bounded dispatch latency for real-time threads.
Reference: [6] <author> R. Govindan and D.P. Anderson. </author> <title> Scheduling and IPC mechanisms for continuous media. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating System Principles, </booktitle> <year> 1991. </year>
Reference-contexts: We report the results of these experiments. 3 1.2 Related Work The ARX approach is built upon previous work on thread implementation and scheduling. In particular, we adopted several techniques presented in <ref> [1, 6] </ref> and extended them, since they presented only partial solutions to our problem. First, in [6], Govindan and Anderson proposed the split-level scheduling of real-time threads for continuous media applications. <p> We report the results of these experiments. 3 1.2 Related Work The ARX approach is built upon previous work on thread implementation and scheduling. In particular, we adopted several techniques presented in [1, 6] and extended them, since they presented only partial solutions to our problem. First, in <ref> [6] </ref>, Govindan and Anderson proposed the split-level scheduling of real-time threads for continuous media applications. In this approach, the virtual address space of a process contains multiple real-time threads called lightweight processes (LWPs), and they are scheduled via a deadline-based scheduling policy such as EDF scheduling.
Reference: [7] <author> P. Goyal, X. Guo, and H. M. Vin. </author> <title> A hierarchical CPU scheduler for multimedia operating systems. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Specifically, it relies on the weighted fair queuing (WFQ) algorithm [4, 13], for the kernel-level process scheduling. Although the WFQ algorithm was devised for proportional bandwidth allocation in communication networks, it works for CPU scheduling, as shown in <ref> [7, 18] </ref>. The algorithm emulates a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet [7]. <p> The algorithm emulates a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet <ref> [7] </ref>. It achieves weighted fairness by introducing virtual time which advances at a rate inversely proportional to the aggregated weight of the back-logged processes. Processes are assigned virtual finish times on arrival, and they are scheduled in the increasing order of virtual finish times. <p> There are several variants of the WFQ algorithm. Goyal et al. proposed the start-time fair queuing (SFQ) algorithm in [8] to achieve weighted fairness regardless of variation in the server capacity. They applied the SFQ algorithm to CPU scheduling in <ref> [7] </ref>. Unlike the original algorithm, the SFQ algorithm tags virtual start times to the arrivals of processes and schedules them in the increasing order of start tags. This algorithm requires less computation to track the virtual time than other variants of the WFQ algorithm. <p> It was originally intended to emulate a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet. Though it was designed for communication networks, it works for CPU scheduling, as shown in <ref> [7, 18] </ref>. Conceptually, the WFQ algorithm partitions a server into multiple hypothetical ones whose capacities are proportional to the relative weights of the clients.
Reference: [8] <author> P. Goyal, H.M. Vin, and H. Cheng. </author> <title> Start-time fair queuing: A scheduling algorithm for integrated services packet switching networks. </title> <booktitle> In Proceedings of ACM SIGCOMM'96, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Processes are assigned virtual finish times on arrival, and they are scheduled in the increasing order of virtual finish times. There are several variants of the WFQ algorithm. Goyal et al. proposed the start-time fair queuing (SFQ) algorithm in <ref> [8] </ref> to achieve weighted fairness regardless of variation in the server capacity. They applied the SFQ algorithm to CPU scheduling in [7]. Unlike the original algorithm, the SFQ algorithm tags virtual start times to the arrivals of processes and schedules them in the increasing order of start tags. <p> A class of scheduling algorithms that meet this requirement includes the weighted fair queuing (WFQ) algorithm [4, 13] and its variants <ref> [8, 18] </ref>. We incorporated the WFQ algorithm in the ARX kernel and used it for process scheduling. For the second goal, we adopted the scheduler activation from [1] and specialized it for real-time processing. We refer to the new scheme as dynamic stack binding.
Reference: [9] <author> N. Kim, M. Ryu, S. Hong, M. Saksena, C. Choi, and H. Shin. </author> <title> Visual assessment of a real-time system design: A case study on a CNC controller. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 300-310, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In doing so, we selected three representative applications, one of which was a hard real-time application, and the others were soft real-time applications. Specifically, they were a control program for computerized numerical control (CNC) machines developed by Kim et al. in <ref> [9] </ref>, the Berkeley MPEG video decoder [14], and the Dhrystone Benchmark version 2.1 [20]. We ported these programs on the ARX kernel. We did not work with general time-sharing applications, since they cannot affect real-time processes.
Reference: [10] <author> C. Locke. </author> <title> Software architecture for hard real-time applications: Cyclic executives vs. fixed priority executives. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 4(1) </volume> <pages> 37-53, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The digital video application may be efficiently run with EDF scheduling, whereas the NC machine controller may use cyclic executive scheduling <ref> [2, 10] </ref> for deterministic responses.
Reference: [11] <author> T. Mathisen. </author> <title> Pentium secrets. </title> <journal> Byte, </journal> <pages> pages 191-192, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: We did not work with general time-sharing applications, since they cannot affect real-time processes. Our experimental machine was a PC with an Intel 133 MHz Pentium processor and 32M bytes of main memory. We made our measurements using a 64-bit cycle counter implemented in the Intel Pentium processor <ref> [11] </ref>. Being initialized at the bring-up time, this cycle counter increments every machine cycle. In our experimental machine, 133,000 cycles equals to 1ms. We set 2ms to the CPU time quantum and 1ms to the interval timer.
Reference: [12] <author> F. Mueller. </author> <title> A library implementation of POSIX threads under UNIX. </title> <booktitle> In 1993 Winder USENIX, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: This helps real-time operating systems provide short and bounded dispatch latency for real-time threads. Moreover, threads allow programmers to structure programs such that multiple asynchronous events in the programs can be effectively handled. Threads can be implemented in various ways and incorporated into different places in a programming environment <ref> [12] </ref>. First, they can be implemented as a set of kernel functionalities. In this implementation, the kernel can recognize individual threads and provide scheduling for them. This implementation is often called kernel-level threads. Second, threads can be implemented as a set of library functions.
Reference: [13] <author> A.K. Parekh and R.G. Gallager. </author> <title> A generalized processor sharing approach to flow control in integrated services networks: The single-node case. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(3) </volume> <pages> 344-357, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The ARX approach is also inspired by the recent advances of QoS (quality of service) scheduling techniques. Specifically, it relies on the weighted fair queuing (WFQ) algorithm <ref> [4, 13] </ref>, for the kernel-level process scheduling. Although the WFQ algorithm was devised for proportional bandwidth allocation in communication networks, it works for CPU scheduling, as shown in [7, 18]. <p> For the first goal, we required that the kernel scheduler should not be involved in thread scheduling, but provide an address space switching mechanism that can maintain fairness among real-time processes. A class of scheduling algorithms that meet this requirement includes the weighted fair queuing (WFQ) algorithm <ref> [4, 13] </ref> and its variants [8, 18]. We incorporated the WFQ algorithm in the ARX kernel and used it for process scheduling. For the second goal, we adopted the scheduler activation from [1] and specialized it for real-time processing. We refer to the new scheme as dynamic stack binding. <p> We measured the number of frames decoded by the three MPEG processes. Figure 5 shows the results of the experiments. We can see that the number of decoded frames is proportional to their weights. This is consistent with the analytical results of the original WFQ algorithm found in <ref> [4, 13] </ref>. 5.3 Hard Real-Time Performance We experimented with the CNC controller program to show that the ARX kernel could provide hard real-time guarantees. The CNC software was implemented using two PCs, one running the controller software, and the other simulating a plant.
Reference: [14] <author> K. Patel, B.C. Smith, and L.A. Rowe. </author> <title> Performance of a software MPEG video decoder. </title> <booktitle> In ACM Multimedia, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: In doing so, we selected three representative applications, one of which was a hard real-time application, and the others were soft real-time applications. Specifically, they were a control program for computerized numerical control (CNC) machines developed by Kim et al. in [9], the Berkeley MPEG video decoder <ref> [14] </ref>, and the Dhrystone Benchmark version 2.1 [20]. We ported these programs on the ARX kernel. We did not work with general time-sharing applications, since they cannot affect real-time processes. Our experimental machine was a PC with an Intel 133 MHz Pentium processor and 32M bytes of main memory.
Reference: [15] <author> M.L. Powell, S.R. Kleiman, S. Barton, D. Shah, D. Stein, and M. Weeks. </author> <title> SunOS multi-thread architecture. </title> <booktitle> In Proceedings of 1991 USENIX Winter conference, </booktitle> <pages> pages 65-79, </pages> <year> 1991. </year>
Reference-contexts: They are extensively substituting traditional UNIX-like processes. More and more operating systems have been modified, and even created to support threaded programming. For example, Sun Microsystems extended their own operating system to incorporate multithreading capability <ref> [15, 17] </ref>; many micro-kernel based operating systems including Mach and Windows NT were designed from scratch to support multithreading [3, 19]. This trend is not an exception in real-time operating systems. POSIX specifies a priority-driven thread model in its thread extension standard [5]. The reason behind such popularity is clear. <p> Sun Threads took the kernel-level thread implementation for real-time processing in that each real-time thread is associated with a kernel thread <ref> [15, 17] </ref>. In such an implementation, all real-time threads, regardless of processes to which they belong, form a flat task space which is consistent with the task model of preemptive priority scheduling. However, such a simplified scheduling mechanism seriously restricts the application model.
Reference: [16] <author> M. Ryu, S. Hong, and M. Saksena. </author> <title> Streamlining real-time controller design: From performance specifications to end-to-end timing constraints. </title> <booktitle> In Proceedings of Real-Time Applications and Technology Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Thus, it will be beneficial to develop a systematic method which can automatically translate hard or soft real-time requirements into a bandwidth requirement, given the performance specifications of the hardware platform. We have already conducted similar research for real-time control systems <ref> [16] </ref>. We are currently applying our preliminary results to this bandwidth allocation problem. We are also looking to extend our kernel for multiprocessor systems. We expect that it will be straightforward to extend the event upcall mechanism such that it can handle the concurrent executions of user-level schedulers.
Reference: [17] <author> D. Stein and D. Shah. </author> <title> Implementing lightweight threads. </title> <booktitle> In Proceedings of 1992 USENIX Summer conference, </booktitle> <pages> pages 1-9, </pages> <year> 1992. </year>
Reference-contexts: They are extensively substituting traditional UNIX-like processes. More and more operating systems have been modified, and even created to support threaded programming. For example, Sun Microsystems extended their own operating system to incorporate multithreading capability <ref> [15, 17] </ref>; many micro-kernel based operating systems including Mach and Windows NT were designed from scratch to support multithreading [3, 19]. This trend is not an exception in real-time operating systems. POSIX specifies a priority-driven thread model in its thread extension standard [5]. The reason behind such popularity is clear. <p> Sun Threads took the kernel-level thread implementation for real-time processing in that each real-time thread is associated with a kernel thread <ref> [15, 17] </ref>. In such an implementation, all real-time threads, regardless of processes to which they belong, form a flat task space which is consistent with the task model of preemptive priority scheduling. However, such a simplified scheduling mechanism seriously restricts the application model.
Reference: [18] <author> I. Stoica, H. Abdel-Wahab, K. Jeffay, S. K. Baruah, J. E. Gehrke, and C. G. Plaxton. </author> <title> A proportional share resource allocation algorithm for real-time, time-shared systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 288-299, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Specifically, it relies on the weighted fair queuing (WFQ) algorithm [4, 13], for the kernel-level process scheduling. Although the WFQ algorithm was devised for proportional bandwidth allocation in communication networks, it works for CPU scheduling, as shown in <ref> [7, 18] </ref>. The algorithm emulates a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet [7]. <p> A class of scheduling algorithms that meet this requirement includes the weighted fair queuing (WFQ) algorithm [4, 13] and its variants <ref> [8, 18] </ref>. We incorporated the WFQ algorithm in the ARX kernel and used it for process scheduling. For the second goal, we adopted the scheduler activation from [1] and specialized it for real-time processing. We refer to the new scheme as dynamic stack binding. <p> It was originally intended to emulate a hypothetical weighted round robin server where in each round a packet receives service that is infinitesimal and proportional to the weight of the packet. Though it was designed for communication networks, it works for CPU scheduling, as shown in <ref> [7, 18] </ref>. Conceptually, the WFQ algorithm partitions a server into multiple hypothetical ones whose capacities are proportional to the relative weights of the clients.
Reference: [19] <author> A. Tevanian, R. Rashid, D. B. Golub, D. L. Black, E. Cooper, and M. W. Young. </author> <title> Mach threads and the UNIX kernel: The battle for control. </title> <booktitle> In USENIX Technical Conference, </booktitle> <pages> pages 185-197, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: More and more operating systems have been modified, and even created to support threaded programming. For example, Sun Microsystems extended their own operating system to incorporate multithreading capability [15, 17]; many micro-kernel based operating systems including Mach and Windows NT were designed from scratch to support multithreading <ref> [3, 19] </ref>. This trend is not an exception in real-time operating systems. POSIX specifies a priority-driven thread model in its thread extension standard [5]. The reason behind such popularity is clear.
Reference: [20] <author> R. P. Weicker. Dhrystone: </author> <title> A synthetic systems programming benchmark. </title> <journal> Communications of the ACM, </journal> <volume> 27(10), </volume> <month> October </month> <year> 1984. </year> <month> 22 </month>
Reference-contexts: Specifically, they were a control program for computerized numerical control (CNC) machines developed by Kim et al. in [9], the Berkeley MPEG video decoder [14], and the Dhrystone Benchmark version 2.1 <ref> [20] </ref>. We ported these programs on the ARX kernel. We did not work with general time-sharing applications, since they cannot affect real-time processes. Our experimental machine was a PC with an Intel 133 MHz Pentium processor and 32M bytes of main memory.
References-found: 20

