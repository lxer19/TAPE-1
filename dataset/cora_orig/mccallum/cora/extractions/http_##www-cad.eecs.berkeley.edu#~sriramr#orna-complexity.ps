URL: http://www-cad.eecs.berkeley.edu/~sriramr/orna-complexity.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~sriramr/verisems97.html
Root-URL: 
Email: Email: harel@wisdom.weizmann.ac.il  Email: orna@eecs.berkeley.edu  Email: vardi@cs.rice.edu  
Title: On the Complexity of Verifying Concurrent Transition Systems  
Author: David Harel Orna Kupferman Moshe Y. Vardi 
Date: January 2, 1997  
Address: Rehovot 76100, Israel  Berkeley CA 94720-1770, U.S.A.  Houston TX 77251-1892, U.S.A.  
Affiliation: Department of Applied Mathematics Computer Science The Weizmann Institute  EECS Department UC Berkeley  Department of Computer Science Rice University  
Abstract: Model-checking methods suffer from the state explosion problem: In a concurrent setting, the program under consideration is typically the parallel composition of many processes, and traversing the exceedingly large state space introduced by the parallel composition cannot be avoided. Another fruitful verification methodology is implementation-specification verification. Here, we check that an implementation is correct with respect to a specification by checking whether the behaviors of a transition system that models the program's implementation correlate with the behaviors of a transition system that models its specification. In this paper we investigate the effect of concurrency on the complexity of implementation-specification verification. We consider trace-based and tree-based approaches to the verification of concurrent transition systems, with and without fairness. Our results show that in almost all cases the complexity of the problem is exponentially harder than that of the non-concurrent case. Thus, in this methodology too, the state-explosion problem cannot be avoided. 
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: We first describe implementation-specification verification in more detail. Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. <ref> [AL91] </ref>). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. [LS84, LT87, Kur94]): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. <p> The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Equiva lences for fair kripke structures. </title> <booktitle> In Proc. 21st Int. Colloquium on Automata, Languages and Programming, </booktitle> <address> Jerusalem, Israel, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the ad vantage of the trace-based approach reappears [KV96].
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> In Proc. 4th Conference on Computer Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <address> Montreal, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the ad vantage of the trace-based approach reappears [KV96].
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model check ing: 10 20 states and beyond. </title> <booktitle> In Proceedings of the 5th Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. Coping with the state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. <ref> [CG87, BCM + 90] </ref>). What about implementation-specification verification? Is the state-explosion problem unavoidable there too? This is the subject of our work. We first describe implementation-specification verification in more detail. Consider an implementation and a specification.
Reference: [BGS92] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference-contexts: The joint complexity of containment and simulation. This measure considers the complex ity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete <ref> [Mil80, BGS92] </ref>, whereas that of containment is PSPACE-complete [SVW87]. 2 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. <p> Theorem 2.3 [SVW87, VW94, KV96] 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 <ref> [Mil80, BGS92, KV96] </ref> 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 [SVW87, VW94, KV96] 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem. <p> Can we do better than this? Can we model-check a concurrent program and avoid the state-explosion problem? Unfortunately, the answer is no. Indeed, model checking of concurrent programs for LTL and CTL is PSPACE-complete even for a fixed formula <ref> [VW94, BVW94] </ref>. Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. Coping with the state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. [CG87, BCM + 90]).
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <booktitle> pages 428-437. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The temporal-logic analogy to the expressiveness advantage of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of the branching logic CTL ? , over LTL <ref> [CD88] </ref>. Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification [GL94]. 2 1. The joint complexity of containment and simulation.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. Coping with the state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. <ref> [CG87, BCM + 90] </ref>). What about implementation-specification verification? Is the state-explosion problem unavoidable there too? This is the subject of our work. We first describe implementation-specification verification in more detail. Consider an implementation and a specification.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Theorem 4.1 The simulation problem for concurrent transition systems is EXPTIME-complete. Proof (sketch): Membership in EXPTIME follows from Theorems 2.2 and 2.4. To prove hardness in EXPTIME, we carry out a reduction from alternating linear-space-bounded Turing machines, proved to be EXPTIME-hard in <ref> [CKS81] </ref>.
Reference: [DH94] <author> D. Drusinsky and D. Harel. </author> <title> On the power of bounded concurrency I: Finite automata. </title> <journal> Journal of the ACM, </journal> <volume> 41(3) </volume> <pages> 517-539, </pages> <year> 1994. </year>
Reference-contexts: To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in <ref> [Har89, DH94] </ref>, is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no con-currency, and we call it a unary transition system. <p> This approach to modeling concurrency, called bounded cooperative concurrency in [Har89, DH94], is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no con-currency, and we call it a unary transition system. By <ref> [DH94] </ref>, a concurrent transition system can be translated into a unary transition system with an exponential blow up in size. Indeed, it is the size of this unary system that is referred to in current analyses of the complexity of verification. <p> Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level. <p> of the verification problem. 2 The temporal logic analogy to this gap is the traditional belief that CTL model checking, which can be done in time linear in the length of the formula, is easier than LTL model checking, which requires exponential time. 3 Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying unary transition systems, and thus the state-explosion problem cannot be avoided. <p> Proof (sketch): Drusinsky and Harel prove the theorem with respect to automata, where the observable events are input to the machine and where equivalence is defined as agreement on the trace set <ref> [DH94] </ref>. Yet, their proof holds also for transition systems with our definition of equivalence (mutual simulation), as follows. Consider a concurrent transition system S with n components. <p> Theorem 5.4 The implementation complexity of the fair-simulation problem for concurrent transition systems is EXPTIME-complete. Proof: Membership in EXPTIME follows from Theorems 2.6 and 2.2. Hardness in EXPTIME follows from Theorem 4.2. 6 Discussion Our results are illustrated by the cube figures below, in the style of <ref> [Har89, DH94] </ref>. All the complexities denote tight bounds. We use J to denote joint complexity (and its omission to denote implementation complexity), F to denote fair transition systems (and its omission to denote non-fair ones), and C to denote concurrent transition systems (and its omission to denote unary ones).
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: We then turn to defining fair-containment and fair-simulation with respect to concurrent transition systems, and study their complexities too, employing unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in [Mil80, BGS92, KV96].
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification <ref> [GL94] </ref>. 2 1. The joint complexity of containment and simulation. This measure considers the complex ity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete [Mil80, BGS92], whereas that of containment is PSPACE-complete [SVW87]. 2 2. The implementation complexity of containment and simulation. <p> When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the ad vantage of the trace-based approach reappears [KV96]. <p> Let c and c 0 be configurations in S and S 0 , respectively. A relation H C fi C 0 is a fair-simulation relation from hS; ci to hS 0 ; c 0 i iff the following conditions hold <ref> [GL94] </ref>. 1. H (c; c 0 ). 2. For all configurations a 2 C and a 0 2 C 0 with H (a; a 0 ), we have L (a) = L (a 0 ). 3.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <journal> Sci. Comp. Prog., </journal> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. 1 We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. The basic motivation for this comes from the statecharts of <ref> [Har87] </ref>, which can be viewed as finite automata with both concurrency and hierarchy, though for simplicity we eliminate the hierarchy here. A concurrent transition system consists of components, which model the program's underlying processes. (The analogous parts of a statechart are called orthogonal components in [Har87].) Each component is a state-transition <p> comes from the statecharts of <ref> [Har87] </ref>, which can be viewed as finite automata with both concurrency and hierarchy, though for simplicity we eliminate the hierarchy here. A concurrent transition system consists of components, which model the program's underlying processes. (The analogous parts of a statechart are called orthogonal components in [Har87].) Each component is a state-transition graph. Its states correspond to the possible positions of the process it models, and each state is labeled with the events that occur, or hold, in the corresponding position.
Reference: [Har89] <author> D. Harel. </author> <title> A thesis for bounded concurrency. </title> <booktitle> In Proc. 14th Symp. on Math. Foundation of Computer Science, volume 379 of Lecture Notes in Computer Science, </booktitle> <pages> pages 35-48, </pages> <address> New York, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in <ref> [Har89, DH94] </ref>, is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no con-currency, and we call it a unary transition system. <p> Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level. <p> of the verification problem. 2 The temporal logic analogy to this gap is the traditional belief that CTL model checking, which can be done in time linear in the length of the formula, is easier than LTL model checking, which requires exponential time. 3 Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying unary transition systems, and thus the state-explosion problem cannot be avoided. <p> Theorem 5.4 The implementation complexity of the fair-simulation problem for concurrent transition systems is EXPTIME-complete. Proof: Membership in EXPTIME follows from Theorems 2.6 and 2.2. Hardness in EXPTIME follows from Theorem 4.2. 6 Discussion Our results are illustrated by the cube figures below, in the style of <ref> [Har89, DH94] </ref>. All the complexities denote tight bounds. We use J to denote joint complexity (and its omission to denote implementation complexity), F to denote fair transition systems (and its omission to denote non-fair ones), and C to denote concurrent transition systems (and its omission to denote unary ones).
Reference: [Hen85] <author> M. Hennessy. </author> <title> Algebraic theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [HH94] <author> T. Hirst and D. Harel. </author> <title> On the power of bounded concurrency II: Pushdown automata. </title> <journal> Journal of the ACM, </journal> <volume> 41(3) </volume> <pages> 540-554, </pages> <year> 1994. </year>
Reference-contexts: Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level.
Reference: [HRV90] <author> D. Harel, R. Rosner, and M.Y. Vardi. </author> <title> On the power of bounded concurrency iii: Reason ing about programs. </title> <booktitle> In Proceedings of the 5th Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level.
Reference: [Koz77] <author> D. Kozen. </author> <title> Lower bounds for natural proof systems. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 254-266, </pages> <year> 1977. </year>
Reference-contexts: Hence, T rejects the empty tape iff S T is empty. In view of the known PSPACE lower bound for emptiness in communicating finite state machines <ref> [Koz77] </ref>, our PSPACE lower bound here is not surprising. Note, however, that the bound in [Koz77] does not directly imply our bound here, since concurrent transition systems generate infinite traces. In addition, the model of communicating finite state machines assume complete synchronization between the components. <p> Hence, T rejects the empty tape iff S T is empty. In view of the known PSPACE lower bound for emptiness in communicating finite state machines <ref> [Koz77] </ref>, our PSPACE lower bound here is not surprising. Note, however, that the bound in [Koz77] does not directly imply our bound here, since concurrent transition systems generate infinite traces. In addition, the model of communicating finite state machines assume complete synchronization between the components. Our reduction, on the other hand, employs only a very humble kind of cooperation between the components.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. [AL91]). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. <ref> [LS84, LT87, Kur94] </ref>): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. At each stage the current implementation is verified to satisfy its specification. <p> One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment <ref> [Kur94] </ref> and tree-based verification corresponds to establishing simulation [Mil71]. As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. 1 We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in [Har89, DH94], is the dominating one in research on distributed systems (cf. <ref> [Kur94] </ref>). A concurrent transition system with a single component models a program with no con-currency, and we call it a unary transition system. By [DH94], a concurrent transition system can be translated into a unary transition system with an exponential blow up in size.
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Verification of fair transition systems. </title> <booktitle> In Computer Aided Verification, Proc. 8th Int. Conference, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 372-382. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. According to this measure, containment is easier than simulation <ref> [KV96] </ref>. 3. The joint complexity of fair containment and fair simulation. When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. <p> The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete <ref> [KV96] </ref>. 4. The implementation complexity of fair containment and fair simulation. Here, the ad vantage of the trace-based approach reappears [KV96]. We address the question about the power of concurrency in program verification by examining the four measures when applied to concurrent transition systems. <p> The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete <ref> [KV96] </ref>. 4. The implementation complexity of fair containment and fair simulation. Here, the ad vantage of the trace-based approach reappears [KV96]. We address the question about the power of concurrency in program verification by examining the four measures when applied to concurrent transition systems. We first define containment and simulation with respect to such systems, and then consider the complexity and the implementation complexity of detecting their presence. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. <p> of the verification problem. 2 The temporal logic analogy to this gap is the traditional belief that CTL model checking, which can be done in time linear in the length of the formula, is easier than LTL model checking, which requires exponential time. 3 Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying unary transition systems, and thus the state-explosion problem cannot be avoided. <p> This result is robust: It is independent of the verification approach and the fairness constraint under consideration, and remains valid when we consider implementation complexity too. In particular, we show that the fair-containment and fair-simulation problems for concurrent transition systems are EXPSPACE-complete. These results join those of <ref> [KV96] </ref> in questioning the computational superiority of tree-based verification. One exception to the inherent exponential power of cooperative concurrency is the fair-simulation problem for strongly-fair transition systems. While the implementation complexity of the problem is PTIME-complete for unary transition systems [KV96], we show that it is PSPACE-complete (rather than EXPTIME-complete) for <p> These results join those of <ref> [KV96] </ref> in questioning the computational superiority of tree-based verification. One exception to the inherent exponential power of cooperative concurrency is the fair-simulation problem for strongly-fair transition systems. While the implementation complexity of the problem is PTIME-complete for unary transition systems [KV96], we show that it is PSPACE-complete (rather than EXPTIME-complete) for concurrent transition systems. <p> Theorem 2.3 <ref> [SVW87, VW94, KV96] </ref> 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. <p> Theorem 2.3 [SVW87, VW94, KV96] 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 <ref> [Mil80, BGS92, KV96] </ref> 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 [SVW87, VW94, KV96] 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2. <p> The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 <ref> [SVW87, VW94, KV96] </ref> 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of fair-containment for unary transition systems is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. Theorem 2.6 [KV96] 1. The fair-simulation problem for unary transition systems is PSPACE-complete. 2. <p> Theorem 2.5 [SVW87, VW94, KV96] 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of fair-containment for unary transition systems is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. Theorem 2.6 <ref> [KV96] </ref> 1. The fair-simulation problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of fair-simulation for unary transition systems is PTIME complete. It follows that, when comparing the trace-based and the tree-based approaches to verification from a complexity-theoretic point to view, there is no clear advantageous approach. <p> Assume that S has n components. Then, following the construction described in the proof of Theorem 2.2, the system D has k = k 1 k 2 k n states and m = m 1 + m 2 m k pairs in its fairness condition. By <ref> [KV96] </ref>, we can translate D to an unconditionally-fair unary transition system U with k 2 O (m) states. Thus, the size of U is exponential in the size of S. <p> Theorem 5.3 The fair-simulation problem for concurrent transition systems is EXPSPACE-complete. 20 Proof (sketch): Membership in EXPSPACE follows from Theorems 2.6 and 2.2. To prove hardness in EXPSPACE we do a reduction from exponential-space-bounded Turing machines. Our reduction is similar to the reduction described in <ref> [KV96] </ref> for proving a lower bound to the fair-simulation problem for unary transition systems. The only change is that while there the Turing machines are polynomial-space bounded, yielding a PSPACE lower bound, here the machines are exponential-space bounded, yielding an EXPSPACE lower bound.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem.
Reference: [LPS81] <author> D. Lehman, A. Pnueli, and J. Stavi. Impartiality, </author> <title> justice, and fairness the ethics of concur rent termination. </title> <booktitle> In Proc. 8th Colloq. on Automata, Programming, and Languages (ICALP), volume 115 of Lecture Notes in Computer Science, </booktitle> <pages> pages 264-277. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1981. </year>
Reference-contexts: We then turn to defining fair-containment and fair-simulation with respect to concurrent transition systems, and study their complexities too, employing unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in [Mil80, BGS92, KV96].
Reference: [LS84] <author> S.S. Lam and A.U. Shankar. </author> <title> Protocol verification via projection. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 325-342, </pages> <year> 1984. </year>
Reference-contexts: Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. [AL91]). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. <ref> [LS84, LT87, Kur94] </ref>): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. At each stage the current implementation is verified to satisfy its specification.
Reference: [LT87] <author> N. A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. [AL91]). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. <ref> [LS84, LT87, Kur94] </ref>): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. At each stage the current implementation is verified to satisfy its specification.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings of the 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment [Kur94] and tree-based verification corresponds to establishing simulation <ref> [Mil71] </ref>. As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. 1 We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> Let c and c 0 be configurations of S and S 0 , respectively. A relation H C fi C 0 is a simulation relation from hS; ci to hS 0 ; c 0 i iff the following conditions hold <ref> [Mil71] </ref>. 1. H (c; c 0 ). 2. For all configurations a 2 C and a 0 2 C 0 with H (a; a 0 ), we have L (a) = L (a 0 ). 3.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment [Kur94] and tree-based verification corresponds to establishing simulation [Mil71]. As shown by Milner <ref> [Mil80] </ref>, while simulation implies containment, the opposite direction is not true. 1 We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> The joint complexity of containment and simulation. This measure considers the complex ity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete <ref> [Mil80, BGS92] </ref>, whereas that of containment is PSPACE-complete [SVW87]. 2 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their unary equivalents. <p> As such, S S 0 , but still, S does not simulate S 0 . Indeed, no state of S 0 can be paired, by any H , to the state labeled b of S <ref> [Mil80] </ref>. a c d c d b b We say that two concurrent transition systems S and S 0 are equivalent if they fairly simulate each other. Thus, if S S 0 and S 0 S. Note that equivalent systems agree on their trace sets. <p> Theorem 2.3 [SVW87, VW94, KV96] 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 <ref> [Mil80, BGS92, KV96] </ref> 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 [SVW87, VW94, KV96] 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrecny. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clifs, </address> <year> 1989. </year>
Reference-contexts: The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: </title> <publisher> Specifi cation. Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Since the implementation is typically much larger than the specification, this measure is of particular interest. According to this measure, containment is easier than simulation [KV96]. 3. The joint complexity of fair containment and fair simulation. When we consider fair transition systems <ref> [MP92] </ref>, which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete [KV96]. 4. <p> We then turn to defining fair-containment and fair-simulation with respect to concurrent transition systems, and study their complexities too, employing unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation-specification verification in [Mil80, BGS92, KV96].
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Proc. 12th Int. Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 15-32. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We examine the complexity of the containment and the simulation problems in four different ways: 1 The trace-based vs. tree-based dichotomy of verification is strongly related to the linear-time vs. branching-time dichotomy in temporal logic model checking <ref> [Pnu85] </ref>. The temporal-logic analogy to the expressiveness advantage of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of the branching logic CTL ? , over LTL [CD88].
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: The joint complexity of containment and simulation. This measure considers the complex ity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete [Mil80, BGS92], whereas that of containment is PSPACE-complete <ref> [SVW87] </ref>. 2 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Theorem 2.3 <ref> [SVW87, VW94, KV96] </ref> 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. <p> The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 <ref> [SVW87, VW94, KV96] </ref> 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of fair-containment for unary transition systems is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. Theorem 2.6 [KV96] 1. The fair-simulation problem for unary transition systems is PSPACE-complete. 2.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Com putation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year> <month> 23 </month>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem. <p> Can we do better than this? Can we model-check a concurrent program and avoid the state-explosion problem? Unfortunately, the answer is no. Indeed, model checking of concurrent programs for LTL and CTL is PSPACE-complete even for a fixed formula <ref> [VW94, BVW94] </ref>. Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. Coping with the state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. [CG87, BCM + 90]). <p> Theorem 2.3 <ref> [SVW87, VW94, KV96] </ref> 1. The containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. <p> The implementation complexity of containment for unary transition systems is NLOGSPACE-complete. Theorem 2.4 [Mil80, BGS92, KV96] 1. The simulation problem for unary transition systems is PTIME-complete. 2. The implementation complexity of simulation for unary transition systems is PTIME complete. Theorem 2.5 <ref> [SVW87, VW94, KV96] </ref> 1. The fair-containment problem for unary transition systems is PSPACE-complete. 2. The implementation complexity of fair-containment for unary transition systems is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. Theorem 2.6 [KV96] 1. The fair-simulation problem for unary transition systems is PSPACE-complete. 2.
References-found: 31

