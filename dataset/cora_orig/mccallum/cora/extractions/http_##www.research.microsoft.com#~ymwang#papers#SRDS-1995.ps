URL: http://www.research.microsoft.com/~ymwang/papers/SRDS-1995.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/SRDS95CR.htm
Root-URL: http://www.research.microsoft.com
Title: Maximum and Minimum Consistent Global Checkpoints and Their Applications  
Author: Yi-Min Wang 
Address: Murray Hill, NJ 07974  
Affiliation: AT&T Bell Laboratories  
Note: In Proc. IEEE the 14th Symposium on Reliable Distributed Systems, pp. 86-95, September 1995, Bad Neuenahr, Germany  
Abstract: This paper considers the problem of constructing the maximum and the minimum consistent global checkpoints that contain a target set of checkpoints, and identify it as a generic issue in recovery-related applications. We formulate the problem as a reachability analysis problem on a directed rollback-dependency graph, and develop efficient algorithms to calculate the two consistent global checkpoints for both general nondeterministic executions and piecewise deterministic executions. We also demonstrate that the approach provides a generalization and unifying framework for many existing and potential applications including software error recovery, mobile computing recovery, parallel debugging and output commits. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. M. Wang, A. Lowry, and W. K. Fuchs, </author> <title> Consistent global checkpoints based on direct dependency tracking, </title> <journal> Inform. Process. Lett., </journal> <volume> Vol. 50, No. 4, </volume> <pages> pp. 223-230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: It can be reloaded into volatile memory in case of a failure to reduce the amount of lost work. In a message-passing system consisting of N processes, a global checkpoint <ref> [1] </ref> is a set of N local checkpoints, one from each process. A global checkpoint T is consistent 1 if no message is sent after a checkpoint of T and received before another checkpoint of T [9]. Most of the literature on checkpointing and rollback recovery considers hardware failures. <p> Clearly, c i;0 cannot have any incoming edge and can have only one outgoing edge pointing to c i;1 . The edges of an R-graph can be maintained locally by each process using the following direct dependency tracking <ref> [1] </ref> mechanism: Direct dependency tracking When process P i sends a message m from the interval I i;x , the pair (i; x) is piggybacked on m. <p> In the example shown in Figure 2, the message chain m 3 m 2 m 1 results in the transitive dependency vector D 0;2 = <ref> [2; 2; 1; 1] </ref>, and so checkpoint c 0;2 knows that c 1;2 , c 2;1 and c 3;1 are the last checkpoints of P 1 , P 2 and P 3 , respectively, that can reach c 0;2 .
Reference: [2] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> Recovery in distributed systems using optimistic message logging and checkpoint-ing, </title> <journal> J. Algorithms, </journal> <volume> Vol. 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs [6] or the sender logs [7], or regenerated by the senders [8]. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints <ref> [2, 5, 10] </ref>. New applications of checkpointing, as described below, pose a different problem: given a target set of checkpoints, each from a different process, how to construct consistent global checkpoints that contain the set. <p> In the example shown in Figure 2, the message chain m 3 m 2 m 1 results in the transitive dependency vector D 0;2 = <ref> [2; 2; 1; 1] </ref>, and so checkpoint c 0;2 knows that c 1;2 , c 2;1 and c 3;1 are the last checkpoints of P 1 , P 2 and P 3 , respectively, that can reach c 0;2 .
Reference: [3] <author> R. Koo and S. Toueg, </author> <title> Checkpointing and rollback-recovery for distributed systems, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-13, No. 1, </volume> <pages> pp. 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: The second advantage of the alternative interpretation is that it demonstrates that the problem of output commits and the problem of minimal coordination, i.e., involving the minimum number of processes in coordinated checkpointing <ref> [3, 26] </ref>, are in fact the same problem. Suppose process P 0 initiates a coordinated checkpointing session by taking a local checkpoint A.
Reference: [4] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel, </author> <title> The performance of consistent checkpointing, </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 39-47, </pages> <month> Oct. </month> <year> 1992. </year>
Reference: [5] <author> Y. M. Wang, </author> <title> Space reclamation for uncoordinated check-pointing in message-passing systems. </title> <type> Ph.D. dissertation, </type> <institution> Department of Electrical and Computer Engineering, University of Illinois at Urbana-Champaign, </institution> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs [6] or the sender logs [7], or regenerated by the senders [8]. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints <ref> [2, 5, 10] </ref>. New applications of checkpointing, as described below, pose a different problem: given a target set of checkpoints, each from a different process, how to construct consistent global checkpoints that contain the set.
Reference: [6] <author> Y. M. Wang and W. K. Fuchs, </author> <title> Optimistic message logging for independent checkpointing in message-passing systems, </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 147-154, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs <ref> [6] </ref> or the sender logs [7], or regenerated by the senders [8]. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints [2, 5, 10].
Reference: [7] <author> R. E. Strom and S. Yemini, </author> <title> Optimistic recovery in distributed systems, </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> Vol. 3, No. 3, </volume> <pages> pp. 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs [6] or the sender logs <ref> [7] </ref>, or regenerated by the senders [8]. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints [2, 5, 10]. <p> One observation is that, if every checkpoint can have on-line knowledge of all the checkpoints that can reach it in the R-graph, then it is possible to develop efficient, distributed algorithms to perform the reachability analysis. One possibility to achieve that is to use transitive dependency tracking <ref> [7, 8, 11] </ref>. Transitive dependency tracking In a system with N processes, each process P i maintains a size-N transitive dependency vector D i . <p> the definition of causal distributed breakpoints to allow multiple user-specified breakpoints, and use Algorithm B 0 to compute the generalized causal distributed breakpoints. (b) for causal distributed breakpoints. 5.4 Output commit The issue of output commits has mostly been studied in the literature on hardware failure recovery under piecewise determinism <ref> [7] </ref>. When an application sends an output to the outside world which is not capable of performing rollbacks, it must ensure that the state interval S from which the output is sent must be recreatable so that under no circumstances will it revoke the output.
Reference: [8] <author> A. P. Sistla and J. L. Welch, </author> <title> Efficient distributed recovery using message logging, </title> <booktitle> in Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 223-238, </pages> <year> 1989. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs [6] or the sender logs [7], or regenerated by the senders <ref> [8] </ref>. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints [2, 5, 10]. <p> of applications satisfying the MRS model [13] (i.e., all receiving events in a checkpoint interval precede all sending events in the same interval), the concept becomes even more powerful and practically useful because it is tightly coupled with the notion of causality [14] and the technique of transitive dependency tracking <ref> [8] </ref>. The study of the MRS model is important because it includes the heavily-studied piecewise deterministic model [15] as a special case. <p> One observation is that, if every checkpoint can have on-line knowledge of all the checkpoints that can reach it in the R-graph, then it is possible to develop efficient, distributed algorithms to perform the reachability analysis. One possibility to achieve that is to use transitive dependency tracking <ref> [7, 8, 11] </ref>. Transitive dependency tracking In a system with N processes, each process P i maintains a size-N transitive dependency vector D i .
Reference: [9] <author> K. M. Chandy and L. Lamport, </author> <title> Distributed snapshots: Determining global states of distributed systems, </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> Vol. 3, No. 1, </volume> <pages> pp. 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: In a message-passing system consisting of N processes, a global checkpoint [1] is a set of N local checkpoints, one from each process. A global checkpoint T is consistent 1 if no message is sent after a checkpoint of T and received before another checkpoint of T <ref> [9] </ref>. Most of the literature on checkpointing and rollback recovery considers hardware failures.
Reference: [10] <author> B. Bhargava and S. R. Lian, </author> <title> Independent checkpointing and concurrent rollback for recovery An optimistic approach, </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 3-12, </pages> <year> 1988. </year>
Reference-contexts: In an application-level implementation, in-transit messages can be retrieved from the receiver logs [6] or the sender logs [7], or regenerated by the senders [8]. and the most recent consistent global checkpoint, called the recovery line, is uniquely determined by the volatile states of surviving processes and the nonvolatile checkpoints <ref> [2, 5, 10] </ref>. New applications of checkpointing, as described below, pose a different problem: given a target set of checkpoints, each from a different process, how to construct consistent global checkpoints that contain the set. <p> The calculation of a consistent global checkpoint can be initiated by any of the N processes or a separate watchdog process [16]. The initiating process broadcasts a request 2 Also called a local system graph in the hardware failure recovery literature <ref> [10] </ref>. rollback-dependency graph (R-graph). message to collect the existing direct dependencies from all the other processes, and constructs the complete R-graph. Each process stops its execution after it replies to the request message.
Reference: [11] <author> A. Acharya and B. R. Badrinath, </author> <title> Checkpointing distributed applications on mobile computers, </title> <booktitle> in Proc. the Third International Conference on Parallel and Distributed Information Systems, </booktitle> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: In the context of mobile computing, successive checkpoints of a process running on a mobile host may be stored in different locations as the mobile host moves between cells <ref> [11] </ref>, and the target set may consist of available or easily accessible checkpoints. For debugging applications, the target set can be defined by user-specified breakpoints [12]. <p> One observation is that, if every checkpoint can have on-line knowledge of all the checkpoints that can reach it in the R-graph, then it is possible to develop efficient, distributed algorithms to perform the reachability analysis. One possibility to achieve that is to use transitive dependency tracking <ref> [7, 8, 11] </ref>. Transitive dependency tracking In a system with N processes, each process P i maintains a size-N transitive dependency vector D i . <p> The problem translates into finding the minimum consistent global checkpoint containing checkpoints A and B, and Algorithm B can be used to obtain the global checkpoint T , as shown in Figure 4 (b). 5.2 Mobile computing recovery Acharya and Badrinath <ref> [11] </ref> described an algorithm for collecting consistent global checkpoints in distributed applications running on mobile computers. We will show that their algorithm basically computes the minimum consistent global checkpoint containing a given checkpoint.
Reference: [12] <author> J. Fowler and W. Zwaenepoel, </author> <title> Causal distributed break-points, </title> <booktitle> in Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pp. 134-141, </pages> <year> 1990. </year>
Reference-contexts: For debugging applications, the target set can be defined by user-specified breakpoints <ref> [12] </ref>. Given a target set of checkpoints S, the motivation for finding the maximum consistent global checkpoint containing S is often clear: it minimizes the total rollback distance and hence the amount of lost work. <p> The minimum consistent global checkpoint containing A, which is computed as fA; B; C; Dg by Algorithm B 00 , is one possible choice. However, Fowler and Zwaenepoel <ref> [12] </ref> argued that a distributed breakpoint containing A should reflect all the interesting states that causally affect A. <p> Since it still satisfies the MRS model, Algorithm B 00 can be used to determine the causal distributed breakpoint containing A to be fA; X; Y; Zg. Alternatively, direct dependency tracking can be used to reduce message piggybacking overhead, in which case either a depth-first search <ref> [12] </ref> or a breadth-first search [14] needs to be performed in a distributed fashion to iteratively construct the transitive dependency vector and hence the causal distributed breakpoint.
Reference: [13] <author> D. L. Russell, </author> <title> State restoration in systems of communicating processes, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-6, No. 2, </volume> <pages> pp. 183-194, </pages> <month> Mar. </month> <year> 1980. </year>
Reference-contexts: In general, it corresponds to the notions of undo as much as possible during a rollback or move forward only if absolutely necessary during a normal execution. For a special class of applications satisfying the MRS model <ref> [13] </ref> (i.e., all receiving events in a checkpoint interval precede all sending events in the same interval), the concept becomes even more powerful and practically useful because it is tightly coupled with the notion of causality [14] and the technique of transitive dependency tracking [8]. <p> Russell <ref> [13] </ref> introduced the MRS model where M stands for Mark (or checkpoint), R for Receive and S for Send. For every process in the MRS model, all message-receiving events within a checkpoint interval must precede all message-sending events in the same interval.
Reference: [14] <author> R. Schwarz and F. Mattern, </author> <title> Detecting causal relationships in distributed computations: in search of the holy grail, </title> <journal> Distributed Computing, </journal> <volume> Vol. 7, </volume> <pages> pp. 149-174, </pages> <year> 1994. </year>
Reference-contexts: For a special class of applications satisfying the MRS model [13] (i.e., all receiving events in a checkpoint interval precede all sending events in the same interval), the concept becomes even more powerful and practically useful because it is tightly coupled with the notion of causality <ref> [14] </ref> and the technique of transitive dependency tracking [8]. The study of the MRS model is important because it includes the heavily-studied piecewise deterministic model [15] as a special case. <p> 00 index ( T [k]) = max (f0; D i;x [k]g); 0 k N 1 (2) We would like to point out that Eq. (2) bears a similarity to the well-known fact that the vector timestamp of event e captures exactly the set of all events which causally precede e <ref> [14] </ref>. The main difference is that we may not have a checkpoint for every process state at any point in time; hence, the problem of finding consistent global checkpoints is in general different from that of determining consistent global states. <p> Alternatively, direct dependency tracking can be used to reduce message piggybacking overhead, in which case either a depth-first search [12] or a breadth-first search <ref> [14] </ref> needs to be performed in a distributed fashion to iteratively construct the transitive dependency vector and hence the causal distributed breakpoint.
Reference: [15] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini, </author> <title> Volatile logging in n-fault-tolerant distributed systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 44-49, </pages> <year> 1988. </year>
Reference-contexts: The study of the MRS model is important because it includes the heavily-studied piecewise deterministic model <ref> [15] </ref> as a special case. We will use several examples to show that the concept of minimum consistent global checkpoints provides a unifying framework for seemingly unrelated applications, and a systematic approach to generalizing existing techniques. This paper is organized as follows. <p> As a result, the maximum and the minimum consistent global checkpoints containing a target set can be computed by more efficient distributed algorithms. In the next section, we will also demonstrate that the study of the MRS model is important because the piecewise deterministic execution model <ref> [15, 18] </ref> that has become quite popular in the recovery literature is in fact a special case of the MRS model. Due to space limitation, the proofs in this subsection are omitted.
Reference: [16] <author> Y. Huang and C. Kintala, </author> <title> Software implemented fault tolerance: Technologies and experience, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 2-9, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: When the receiver P j receives m in the interval I j;y , the R-graph edge from c i;x to c j;y is recorded by P j . The calculation of a consistent global checkpoint can be initiated by any of the N processes or a separate watchdog process <ref> [16] </ref>. The initiating process broadcasts a request 2 Also called a local system graph in the hardware failure recovery literature [10]. rollback-dependency graph (R-graph). message to collect the existing direct dependencies from all the other processes, and constructs the complete R-graph.
Reference: [17] <author> R. H. B. Netzer and J. Xu, </author> <title> Necessary and sufficient conditions for consistent global snapshots, </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> Vol. 6, No. 2, </volume> <pages> pp. 165-169, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: From Lemma 1, T is consistent. 4 For the special case in which S contains only two checkpoints, Theorem 1 can be viewed as a generalization of Lamport's happened-before relation which is a sufficient condition for checkpoint inconsistency, but not necessary <ref> [17] </ref>. The reachability condition in the statement also provides a uniform view for the notions of zigzag paths and zigzag cycles as presented by Netzer and Xu [17]. Construction B Let T denote the set of the last checkpoint of each process that can reach S. <p> Theorem 1 can be viewed as a generalization of Lamport's happened-before relation which is a sufficient condition for checkpoint inconsistency, but not necessary <ref> [17] </ref>. The reachability condition in the statement also provides a uniform view for the notions of zigzag paths and zigzag cycles as presented by Netzer and Xu [17]. Construction B Let T denote the set of the last checkpoint of each process that can reach S. If none of the checkpoints of a process P i can reach S, then P i contributes its initial checkpoint c i;0 to T .
Reference: [18] <author> E. N. Elnozahy and W. Zwaenepoel, Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 41, No. 5, </volume> <pages> pp. 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: As a result, the maximum and the minimum consistent global checkpoints containing a target set can be computed by more efficient distributed algorithms. In the next section, we will also demonstrate that the study of the MRS model is important because the piecewise deterministic execution model <ref> [15, 18] </ref> that has become quite popular in the recovery literature is in fact a special case of the MRS model. Due to space limitation, the proofs in this subsection are omitted.
Reference: [19] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs, </author> <title> Progressive retry for software error recovery in distributed systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, process P i in Figure 3 can recreate the state interval S i;x+1 by restoring the physical checkpoint C, and replaying m x , e and m y in that order. Equivalently, it can be modeled as having an additional logical checkpoint <ref> [19] </ref> anywhere inside S i;x+1 . <p> Studies have shown that, since most software errors in production software are transient, rollback retry can often provide an effective way of bypassing software bugs <ref> [19, 22, 23] </ref>. Suppose a software error is detected at the point marked X in Figure 4 (a), possibly caused by an unexpected nondeterministic event.
Reference: [20] <author> G. Suri, Y. Huang, Y. M. Wang, W. K. Fuchs, and C. Kin-tala, </author> <title> An implementation and performance measurement of the progressive retry technique, </title> <booktitle> in Proc. IEEE International Computer Performance and Dependability Symposium, </booktitle> <pages> pp. 41-48, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: physical checkpoint have been saved onto stable storage; otherwise, it is a volatile logical checkpoint. consisting of logical checkpoint intervals. 5 Applications 5.1 Software error recovery Distributed service-providing applications typically have periodic coordinated checkpoints to bound the rollback distance, and take additional uncoordinated checkpoints 5 to further localize the recovery <ref> [20, 21] </ref>. Studies have shown that, since most software errors in production software are transient, rollback retry can often provide an effective way of bypassing software bugs [19, 22, 23].
Reference: [21] <author> Y. Huang and Y. M. Wang, </author> <title> Why optimistic message logging has not been used in telecommunications systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <year> 1995. </year>
Reference-contexts: physical checkpoint have been saved onto stable storage; otherwise, it is a volatile logical checkpoint. consisting of logical checkpoint intervals. 5 Applications 5.1 Software error recovery Distributed service-providing applications typically have periodic coordinated checkpoints to bound the rollback distance, and take additional uncoordinated checkpoints 5 to further localize the recovery <ref> [20, 21] </ref>. Studies have shown that, since most software errors in production software are transient, rollback retry can often provide an effective way of bypassing software bugs [19, 22, 23].
Reference: [22] <author> J. Gray and D. P. </author> <title> Siewiorek, </title> <journal> High-availability computer systems, IEEE Comput. Mag., </journal> <pages> pp. 39-48, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Studies have shown that, since most software errors in production software are transient, rollback retry can often provide an effective way of bypassing software bugs <ref> [19, 22, 23] </ref>. Suppose a software error is detected at the point marked X in Figure 4 (a), possibly caused by an unexpected nondeterministic event.
Reference: [23] <author> I. Lee and R. K. Iyer, </author> <title> Faults, symptoms, and software fault tolerance in the Tandem GUARDIAN90 operating system, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <year> 1993. </year>
Reference-contexts: Studies have shown that, since most software errors in production software are transient, rollback retry can often provide an effective way of bypassing software bugs <ref> [19, 22, 23] </ref>. Suppose a software error is detected at the point marked X in Figure 4 (a), possibly caused by an unexpected nondeterministic event.
Reference: [24] <author> T. Imielinski and B. R. Badrinath, </author> <title> Mobile wireless computing, </title> <journal> Commun. ACM, </journal> <volume> Vol. 37, No. 10, </volume> <pages> pp. 18-28, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: The intention is not to determine the earliest consistent global checkpoint, but to minimize the searching cost for locating the needed checkpoints by taking advantage of the simplicity and the on-line capability of Algorithm B 00 for the MRS model. A typical architecture for supporting mobile computing <ref> [24] </ref> is illustrated in Figure 5. The entire geographic area is partitioned into wireless cells and each cell is covered by a Mobile Support Station (MSS) which provides wireless in terface to communicate with mobile hosts (MH) in the cell.
Reference: [25] <author> D. B. Johnson, </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs, </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 86-95, </pages> <year> 1993. </year>
Reference-contexts: The alternative interpretation has two advantages. First, it can be readily applied to applications that contain a mix of PWD and non-PWD processes <ref> [25] </ref>. Figure 8 (a) gives an example in which processes P 0 and P 1 are PWD processes, P 2 is a non-PWD process, and P 3 starts as a PWD process but turns off PWD after a nonreplayable nondeterministic event e is encountered.
Reference: [26] <author> P. Leu and B. Bhargava, </author> <title> Concurrent robust checkpointing and recovery in distributed systems, </title> <booktitle> in Proc. Int'l Conf. on Data Engineering, </booktitle> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: The second advantage of the alternative interpretation is that it demonstrates that the problem of output commits and the problem of minimal coordination, i.e., involving the minimum number of processes in coordinated checkpointing <ref> [3, 26] </ref>, are in fact the same problem. Suppose process P 0 initiates a coordinated checkpointing session by taking a local checkpoint A.
References-found: 26

