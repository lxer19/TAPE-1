URL: http://www.research.att.com/~levy/vldb96-lcw.ps.Z
Refering-URL: http://www.research.att.com/~levy/imhome.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: levy@research.att.com  
Title: Obtaining Complete Answers from Incomplete Databases  
Author: Alon Y. Levy 
Affiliation: AT&T Research  
Abstract: We consider the problem of answering queries from databases that may be incomplete. A database is incomplete if some tuples may be missing from some relations, and only a part of each relation is known to be complete. This problem arises in several contexts. For example, systems that provide access to multiple heterogeneous information sources often encounter incomplete sources. The question we address is to determine whether the answer to a specific given query is complete even when the database is incomplete. We present a novel sound and complete algorithm for the answer-completeness problem by relating it to the problem of independence of queries from updates. We also show an important case of the independence problem (and therefore of the answer-completeness problem) that can be decided in polynomial time, whereas the best known algorithm for this case is exponential. This case involves updates that are described using a conjunction of comparison predicates. We also describe an algorithm that determines whether the answer to the query is complete in the current state of the database. Finally, we show that our treatment extends naturally to partially Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 22nd VLDB Conference Mumbai(Bombay), India, 1996 incorrect databases.
Abstract-found: 1
Intro-found: 1
Reference: [ACHK94] <author> Yigal Arens, Chin Y. Chee, Chun-Nan Hsu, and Craig A. Knoblock. </author> <title> Retrieving and integrating data from multiple information sources. </title> <journal> International Journal on Intelligent and Cooperative Information Systems, </journal> <year> 1994. </year>
Reference-contexts: The main motivation for our work stems from the context of a mediator-based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS <ref> [ACHK94] </ref>, the Internet Softbot [EW94] and the Information Manifold [LRO96a, LRO96b]). In practice, many of the sources these systems access contain only partial information.
Reference: [ASU79a] <author> Alfred Aho, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Efficient optimization of a class of relational expressions. </title> <journal> ACM Transactions on Database Systems, </journal> (4)4:435-454, 1979. 
Reference-contexts: When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [ASU79b] <author> Alfred Aho, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Equivalence of relational expressions. </title> <journal> SIAM Journal of Computing, </journal> (8)2:218-246, 1979. 
Reference-contexts: When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [BCL89] <author> J. A. Blakeley, N. Coburn, and P. A. Lar-son. </author> <title> Updating derived relations: detecting irrelevant and autonomously computable updates. </title> <journal> Transactions of Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference-contexts: in the relation Show, the answer to Q 1 is complete w.r.t. 1 and D. 2 2.2 Independence of queries from updates The insight underlying our solution to the answer-completeness problem is based on showing that it is closely related to the problem of detecting indepen-dence of queries from updates <ref> [BCL89, Elk90, LS93] </ref>. The problem of independence of queries from updates is to determine whether the answer to a query Q changes as a result of an insertion to the database or as a result of a deletion from the database. <p> Note that D satisfies , however, Q (D) 6= Q 0 (D), and therefore, the answer to Q is not complete w.r.t. . 2 Using Theorem 3.1 we can apply algorithms for de-tecting independence (e.g., <ref> [BCL89, Elk90, LS93] </ref>) to the problem of deciding answer-completeness. Levy and Sagiv [LS93] describe an algorithm for detecting independence based on checking equivalence between two queries.
Reference: [CGMH + 94] <author> Sudarshan Chawathe, Hector Garcia-Molina, Joachim Hammer, Kelly Ireland, Yannis Pa-pakonstantinou, Jeffrey Ullman, and Jennifer Widom. </author> <title> The TSIMMIS project: Integration of heterogenous information sources. </title> <booktitle> In proceedings of IPSJ, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The main motivation for our work stems from the context of a mediator-based systems that provide access to multiple distributed information sources (e.g., TSIMMIS <ref> [CGMH + 94] </ref>, SIMS [ACHK94], the Internet Softbot [EW94] and the Information Manifold [LRO96a, LRO96b]). In practice, many of the sources these systems access contain only partial information.
Reference: [CM77] <author> A.K. Chandra and P.M. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational databases. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <year> 1977. </year>
Reference-contexts: When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [CV92] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the equivalence of recursive and nonrecursive datalog programs. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 55-66, </pages> <year> 1992. </year>
Reference-contexts: For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in <ref> [CV92, CV94, Sag88, LS93] </ref>. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [CV94] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the complexity of equivalence between recursive and nonrecursive datalog programs. </title> <booktitle> In The Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 55-66, </pages> <year> 1994. </year>
Reference-contexts: For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in <ref> [CV92, CV94, Sag88, LS93] </ref>. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [EGW94] <author> Oren Etzioni, Keith Golden, and Daniel Weld. </author> <title> Tractable closed world reasoning with updates. </title> <booktitle> In Proceedings of the Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> KR-94., </address> <year> 1994. </year> <note> Extended version to appear in Artificial Intelligence. </note>
Reference-contexts: For queries that do not contain negation, the answers we obtain are guaranteed to be a subset of the answers that would have been obtained if the database were complete. However, an important question (considered originally in <ref> [Mot89, EGW94] </ref>) is whether the answer is complete even though the database is incomplete. When queries contain negation, we need to modify our query answering algorithms to guarantee that we obtain only correct answers. <p> If we cannot obtain all the answers, we need to query multiple sources, thereby considerably affecting the performance of the system. Experimental results reported by Etzioni et al. <ref> [EGW94] </ref> showed that identifying answer-completeness of queries enables pruning many redundant accesses to information sources, and therefore to significant speedups in query processing. Finally, the answer-completeness problem is also important in other contexts. <p> As a result, we obtain a better understanding of the problem, and, in particular, we obtain novel sound and complete algorithms for deciding answer-completeness. These results apply to a wider range of cases considered in <ref> [EGW94, Mot89] </ref> for this problem, and are the first ones that are guaranteed to always detect when an a query is answer-complete. * We show an important case of the problem of de-termining independence of queries from updates that can be decided in polynomial time, whereas the best previously known algorithms <p> Motro also does not consider the problem of determining answer-completeness w.r.t. a specific database instance. Recently, Etzioni et al. <ref> [EGW94] </ref> considered the problem of answer-completeness in order to avoid redundant information gathering actions in the Internet Softbot system [EW94], and demonstrated experimentally the value of detecting answer-completeness. <p> Finally, we presented an algorithm that considers the current state of the database to determine whether the answer is complete. A related question one can pose about incomplete databases (which was considered in <ref> [EGW94] </ref>) is what happens when the partial-completeness completeness information changes. In particular, is the answer to a query still complete even if parts of the database that were assumed to be complete may not be complete anymore.
Reference: [Elk90] <author> Charles Elkan. </author> <title> Independence of logic database queries and updates. </title> <booktitle> In Proceedings of the 9th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 154-160, </pages> <year> 1990. </year>
Reference-contexts: in the relation Show, the answer to Q 1 is complete w.r.t. 1 and D. 2 2.2 Independence of queries from updates The insight underlying our solution to the answer-completeness problem is based on showing that it is closely related to the problem of detecting indepen-dence of queries from updates <ref> [BCL89, Elk90, LS93] </ref>. The problem of independence of queries from updates is to determine whether the answer to a query Q changes as a result of an insertion to the database or as a result of a deletion from the database. <p> Note that D satisfies , however, Q (D) 6= Q 0 (D), and therefore, the answer to Q is not complete w.r.t. . 2 Using Theorem 3.1 we can apply algorithms for de-tecting independence (e.g., <ref> [BCL89, Elk90, LS93] </ref>) to the problem of deciding answer-completeness. Levy and Sagiv [LS93] describe an algorithm for detecting independence based on checking equivalence between two queries. <p> Theorem 6.1 has an additional interesting consequence. As shown by Elkan <ref> [Elk90] </ref>, independence from a deletion is a sufficient condition for independence from an update, i.e., In (Q; (R; C))) ) In + (Q; (R; C))): Therefore, if a query is deemed to be answer-correct, it is also answer-complete. <p> Theorem 4.1 is a case that has not been considered specifically in [LS93] for which there is a polynomial time algorithm for query independence. Elkan <ref> [Elk90] </ref> describes an algorithm for query independence whose time-complexity is polynomial in the case considered by Theorem 4.1. However, his algorithms apply only to queries with no self-joins (i.e., at most one occurrence of every relation in the query).
Reference: [EW94] <author> Oren Etzioni and Dan Weld. </author> <title> A softbot-based interface to the internet. </title> <journal> CACM, </journal> <volume> 37(7) </volume> <pages> 72-76, </pages> <year> 1994. </year>
Reference-contexts: The main motivation for our work stems from the context of a mediator-based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS [ACHK94], the Internet Softbot <ref> [EW94] </ref> and the Information Manifold [LRO96a, LRO96b]). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a university repository that contains publications authored by faculty and students of that university, but does not necessarily contain all of them. <p> Motro also does not consider the problem of determining answer-completeness w.r.t. a specific database instance. Recently, Etzioni et al. [EGW94] considered the problem of answer-completeness in order to avoid redundant information gathering actions in the Internet Softbot system <ref> [EW94] </ref>, and demonstrated experimentally the value of detecting answer-completeness. They show that answer-completeness is closed under conjunction and partial instantiation of queries, and use these properties as a basis for their algorithm for determining answer-completeness. As they show, their algorithm is not guaranteed to always detect answer-completeness when it holds.
Reference: [Gin87] <author> Matthew Ginsberg. </author> <title> Readings in Nonmono-tonic reasoning. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1987. </year>
Reference-contexts: Reasoning about local-complete information is also related to the problem of reasoning with the closed world assumption. The bulk of previous work on the topic (see <ref> [Gin87] </ref> for a collection of articles) has concerned itself with the logic of reasoning with the closed world assumption (i.e., which conclusions are appropriate to derive) rather than efficient algorithms for doing so.
Reference: [JK83] <author> D. S. Johnson and A. Klug. </author> <title> Testing containment of conjunctive queries under functional and inclusion dependecies. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (28):1:167-189, </volume> <year> 1983. </year>
Reference-contexts: When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [Klu88] <author> A. Klug. </author> <title> On conjunctive queries containing inequalities. </title> <journal> Journal of the ACM, </journal> <pages> pages 35(1): 146-160, </pages> <year> 1988. </year>
Reference-contexts: In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 3.2 follows from Theorem 3.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>. <p> Therefore, removing such tuples will not change the result of the query. 2 Detecting redundancy is a more expensive procedure than detecting satisfiability. For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is p 2 <ref> [Klu88, vdM92] </ref>, while checking satisfiability can be done in polynomial time [Ull89]. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables). <p> A variable-interval update is an update in which the updated tuples are specified by a conjunction of built-in atoms where each atom contains one constant. It should be noted that variable-interval queries are a more general class than semiinterval queries considered in <ref> [Klu88] </ref>. the algorithm completely decides independence in this case in polynomial time. Theorem 4.1 : Let Q be a conjunctive variable-interval query over the relations E 1 ; : : : ; E n and the comparison predicates &lt;; .
Reference: [LMSS95] <author> Alon Y. Levy, Alberto O. Mendelzon, Yehoshua Sagiv, and Divesh Srivastava. </author> <title> Answering queries using views. </title> <booktitle> In Proceedings of the 14th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Jose, CA, </address> <year> 1995. </year>
Reference-contexts: He describes an algorithm that finds rewritings of queries using views, but it is not always guaranteed to find one if one exists. Although complete algorithms for rewriting queries using views have been developed since (e.g., <ref> [LMSS95] </ref>), finding a rewriting of the query using views has not been shown to be a necessary condition for answer-completeness. Motro also does not consider the problem of determining answer-completeness w.r.t. a specific database instance.
Reference: [LRO96a] <author> Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. </author> <title> Query answering algorithms for information agents. </title> <booktitle> In Proceedings of the AAAI Thirteenth National Conference on Artificial Intelligence, </booktitle> <year> 1996. </year>
Reference-contexts: The main motivation for our work stems from the context of a mediator-based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS [ACHK94], the Internet Softbot [EW94] and the Information Manifold <ref> [LRO96a, LRO96b] </ref>). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a university repository that contains publications authored by faculty and students of that university, but does not necessarily contain all of them.
Reference: [LRO96b] <author> Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. </author> <title> Querying heterogeneous information sources using source descriptions. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <address> Bombay, India., </address> <year> 1996. </year>
Reference-contexts: The main motivation for our work stems from the context of a mediator-based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS [ACHK94], the Internet Softbot [EW94] and the Information Manifold <ref> [LRO96a, LRO96b] </ref>). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a university repository that contains publications authored by faculty and students of that university, but does not necessarily contain all of them.
Reference: [LS93] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Queries independent of updates. </title> <booktitle> In Proceedings of the 19th VLDB Conference, Dublin, Ireland, </booktitle> <pages> pages 171-181, </pages> <year> 1993. </year>
Reference-contexts: in the relation Show, the answer to Q 1 is complete w.r.t. 1 and D. 2 2.2 Independence of queries from updates The insight underlying our solution to the answer-completeness problem is based on showing that it is closely related to the problem of detecting indepen-dence of queries from updates <ref> [BCL89, Elk90, LS93] </ref>. The problem of independence of queries from updates is to determine whether the answer to a query Q changes as a result of an insertion to the database or as a result of a deletion from the database. <p> Note that D satisfies , however, Q (D) 6= Q 0 (D), and therefore, the answer to Q is not complete w.r.t. . 2 Using Theorem 3.1 we can apply algorithms for de-tecting independence (e.g., <ref> [BCL89, Elk90, LS93] </ref>) to the problem of deciding answer-completeness. Levy and Sagiv [LS93] describe an algorithm for detecting independence based on checking equivalence between two queries. <p> Note that D satisfies , however, Q (D) 6= Q 0 (D), and therefore, the answer to Q is not complete w.r.t. . 2 Using Theorem 3.1 we can apply algorithms for de-tecting independence (e.g., [BCL89, Elk90, LS93]) to the problem of deciding answer-completeness. Levy and Sagiv <ref> [LS93] </ref> describe an algorithm for detecting independence based on checking equivalence between two queries. Figure 1 describes an algorithm that adopts the method in [LS93] to decide answer-completeness based on equivalence checking. procedure decide-completeness (Q, ) /fl Q is a query over the relations R 1 ; : : : ; <p> Levy and Sagiv <ref> [LS93] </ref> describe an algorithm for detecting independence based on checking equivalence between two queries. Figure 1 describes an algorithm that adopts the method in [LS93] to decide answer-completeness based on equivalence checking. procedure decide-completeness (Q, ) /fl Q is a query over the relations R 1 ; : : : ; R n ; is a set of local completeness statements: LC (R 0 The procedure returns yes if and only if Q is answer-complete <p> The problem of checking query equivalence is well studied in the literature, and therefore algorithm decide-completeness can use a host of known results to decide completeness. For example, algorithms for equivalence of queries containing unions and negations are given in <ref> [SY81, LS93] </ref>. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. <p> For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in <ref> [CV92, CV94, Sag88, LS93] </ref>. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem. <p> In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 3.2 follows from Theorem 3.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>. <p> Intuitively, in this case detecting independence is equivalent to deciding when the updated tuples and the query are mutually unsatisfiable, whereas in general, detecting independence requires that we detect that the updated tuples are redundant w.r.t. the query. The following example, adopted from <ref> [LS93] </ref>, explains the difference between satisfiability and redundancy. Example 4.1: Consider a database containing the relation inCar (P erson; Car; Age). A tuple (P; C; A) is in the relation inCar if the person P , whose age is A is in car C. <p> If Q is a minimal query then procedure detect-independence will return independent if and only if Q is independent of U . The running time of procedure detect-independence is polynomial in the size of Q and C. 2 Proof Sketch: In <ref> [LS93] </ref> it is shown that Q is independent of deleting (E 1 ; C) if and only if it is independent of adding (E 1 ; C), since the update is oblivi procedure detect-independence (Q, E, C) /fl Q is conjunctive query, and E is one of the relations mentioned in <p> The bulk of previous work on the topic (see [Gin87] for a collection of articles) has concerned itself with the logic of reasoning with the closed world assumption (i.e., which conclusions are appropriate to derive) rather than efficient algorithms for doing so. Levy and Sagiv <ref> [LS93] </ref> present sound and complete algorithms for query independence for queries that are unions of conjunctive queries with comparison predicates and for recursive queries. Theorem 4.1 is a case that has not been considered specifically in [LS93] for which there is a polynomial time algorithm for query independence. <p> Levy and Sagiv <ref> [LS93] </ref> present sound and complete algorithms for query independence for queries that are unions of conjunctive queries with comparison predicates and for recursive queries. Theorem 4.1 is a case that has not been considered specifically in [LS93] for which there is a polynomial time algorithm for query independence. Elkan [Elk90] describes an algorithm for query independence whose time-complexity is polynomial in the case considered by Theorem 4.1.
Reference: [LSK95] <author> Alon Y. Levy, Divesh Srivastava, and Thomas Kirk. </author> <title> Data model and query evaluation in global information systems. </title> <journal> Journal of Intelligent Information Systems, </journal> <note> Special Issue on Networked Information Discovery and Retrieval, 5 (2), </note> <month> September </month> <year> 1995. </year>
Reference-contexts: Elkan [Elk90] describes an algorithm for query independence whose time-complexity is polynomial in the case considered by Theorem 4.1. However, his algorithms apply only to queries with no self-joins (i.e., at most one occurrence of every relation in the query). In <ref> [LSK95] </ref> an algorithm for pruning redundant sources based on sources completeness was described.
Reference: [Mot89] <author> Amihai Motro. </author> <title> Integrity = validity + completeness. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(4) </volume> <pages> 480-502, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: For queries that do not contain negation, the answers we obtain are guaranteed to be a subset of the answers that would have been obtained if the database were complete. However, an important question (considered originally in <ref> [Mot89, EGW94] </ref>) is whether the answer is complete even though the database is incomplete. When queries contain negation, we need to modify our query answering algorithms to guarantee that we obtain only correct answers. <p> As a result, we obtain a better understanding of the problem, and, in particular, we obtain novel sound and complete algorithms for deciding answer-completeness. These results apply to a wider range of cases considered in <ref> [EGW94, Mot89] </ref> for this problem, and are the first ones that are guaranteed to always detect when an a query is answer-complete. * We show an important case of the problem of de-termining independence of queries from updates that can be decided in polynomial time, whereas the best previously known algorithms <p> More importantly, this im plies that if we have a database that is partially incomplete and partially incorrect, then determining answer-correctness is enough for detecting that the answer is both correct and complete. 7 Related work Motro <ref> [Mot89] </ref> considers the problem of determining answer-correctness (which he calls validity) and answer-completeness in the presence of incorrect or incomplete databases. His approach is based on describing the complete (or valid) parts of the database as views.
Reference: [Sag88] <author> Yehoshua Sagiv. </author> <title> Optimizing datalog programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 659-698. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in <ref> [CV92, CV94, Sag88, LS93] </ref>. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. We obtain the following decid-ability results for the answer-completeness problem.
Reference: [Shm93] <author> Oded Shmueli. </author> <title> Equivalence of datalog queries is undecidable. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 231-241, </pages> <year> 1993. </year>
Reference-contexts: For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable <ref> [Shm93] </ref>. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence.
Reference: [SY81] <author> Y. Sagiv and M. Yannakakis. </author> <title> Equivalence among relational expressions with the union and difference operators. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 633-655, </pages> <year> 1981. </year>
Reference-contexts: The problem of checking query equivalence is well studied in the literature, and therefore algorithm decide-completeness can use a host of known results to decide completeness. For example, algorithms for equivalence of queries containing unions and negations are given in <ref> [SY81, LS93] </ref>. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92, CV94, Sag88, LS93]. <p> In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 3.2 follows from Theorem 3.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>.
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Volumes I, II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1989. </year>
Reference-contexts: We assume set semantics for queries (and not multisets). In our analysis it is more convenient to use the notation of conjunctive queries <ref> [Ull89] </ref>. <p> For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is p 2 [Klu88, vdM92], while checking satisfiability can be done in polynomial time <ref> [Ull89] </ref>. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables).
Reference: [vdM92] <author> Ron van der Meyden. </author> <title> The complexity of querying indefinite data about linearly ordered domains. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 331-345, </pages> <year> 1992. </year>
Reference-contexts: In fact, the lower bound on the problem of equivalence <ref> [vdM92] </ref> implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 3.2 follows from Theorem 3.1 and from decidability results for query containment [SY81, Klu88, LS93]. <p> Therefore, removing such tuples will not change the result of the query. 2 Detecting redundancy is a more expensive procedure than detecting satisfiability. For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is p 2 <ref> [Klu88, vdM92] </ref>, while checking satisfiability can be done in polynomial time [Ull89]. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables).
References-found: 25

