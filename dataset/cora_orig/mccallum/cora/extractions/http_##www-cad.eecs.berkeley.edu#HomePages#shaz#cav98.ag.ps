URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/cav98.ag.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/publications.html
Root-URL: http://www.cs.berkeley.edu
Email: Email:ftah,shaz,sriramrg@eecs.berkeley.edu  
Author: Thomas A. Henzinger Shaz Qadeer Sriram K. Rajamani 
Keyword: MOCHA.  
Address: Berkeley, CA 94720-1770, USA  
Affiliation: EECS Department, University of California at  
Abstract: You Assume, We Guarantee: Methodology and Case Studies ? Abstract. Assume-guarantee reasoning has long been advertised as an important method for decomposing proof obligations in system verification. Refinement mappings (homo-morphisms) have long been advertised as an important method for solving the language-inclusion problem in practice. When confronted with large verification problems, we therefore attempted to make use of both techniques. We soon found that rather than offering instant solutions, the success of assume-guarantee reasoning depends critically on the construction of suitable abstraction modules, and the success of refinement checking depends critically on the construction of suitable witness modules. Moreover, as abstractions need to be witnessed, and witnesses abstracted, the process must be iterated. We present here the main lessons we learned from our experiments, in form of a systematic and structured discipline for the compositional verification of reactive modules. An infrastructure to support this discipline, and automate parts of the verification, has been implemented in the tool 
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Logic in Computer Science, pages 207218. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Type-2 techniques, however, require substantial assistance from human verification experts, and their systematic application in nontrivial situations remains somewhat of a black art. We are developing a formal-verification tool, called MOCHA [AHM + 98], which is based on the system description language of reactive modules <ref> [AH96] </ref>. Reactive modules permit the modular and hierarchical description of heterogeneous systems, and have been designed explicitly to support type-2 techniques such as assume-guarantee reasoning. <p> Related work. The individual pieces of our methodology are not new; we simply advocate their disciplined use within the framework of reactive modules. In particular, assume-guarantee rules for various formalisms can be found in [Sta85,CLM89,GL94,AL95,McM97]; the rule used in this paper has been taken from <ref> [AH96] </ref>. Witnesses have appeared in various guises and forms (homomorphisms, refinement mappings, simulation relations, etc.) in different works [Lam83,LT87,AL91,BBLS92,CGL92,Kur94,LV95,McM97]. Also our choice of case studies is not new. <p> Other correctness proofs for Tomasulo's algorithm can be found in [DP97,McM98]; the sliding-window protocol is taken from [Tan92]. 2 A Verification Problem Reactive modules. Reactive modules is a formalism for the modular description of systems with heterogeneous components. The definition of reactive modules can be found in <ref> [AH96] </ref>; here we give only a brief introduction. <p> However, typically both the implementation P and the specification Q consist of the parallel composition of several modules, in which case it may be possible to reduce the problem of checking if P Q to several subproblems that involve smaller state spaces. The assume-guarantee rule for reactive modules <ref> [AH96] </ref> allows us to conclude P Q as long as each component of the specification Q is refined by the corresponding components of the implementation P within a suitable environment. The following proposition gives a slightly generalized account of the assume-guarantee rule.
Reference: [AHM + 98] <author> R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, and S. Tasiran. </author> <title> MOCHA : Modularity in model checking. </title> <editor> In A. Hu and M. Vardi, editors, </editor> <booktitle> CAV 98: Computer Aided Verification, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Type-2 techniques, however, require substantial assistance from human verification experts, and their systematic application in nontrivial situations remains somewhat of a black art. We are developing a formal-verification tool, called MOCHA <ref> [AHM + 98] </ref>, which is based on the system description language of reactive modules [AH96]. Reactive modules permit the modular and hierarchical description of heterogeneous systems, and have been designed explicitly to support type-2 techniques such as assume-guarantee reasoning.
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 82(2):253284, </address> <year> 1991. </year>
Reference: [AL95] <author> M. Abadi and L. Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3):507534, </volume> <year> 1995. </year>
Reference: [BBLS92] <editor> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. Property-preserving simulations. In G. von Bochmann and D.K. Probst, editors, </editor> <booktitle> CAV 92: Computer Aided Verification, Lecture Notes in Computer Science 663, </booktitle> <pages> pages 260273. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [CGL92] <author> E.M. Clarke, O. Grumberg, and D.E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343354. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference: [CLM89] <author> E.M. Clarke, D.E. Long, and K.L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the 4th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 353362. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference: [DP97] <author> W. Damm and A. Pnueli. </author> <title> Verifying out-of-order executions. </title> <booktitle> In Proceedings of the IFIP Working Conference on Correct Hardware Design and Verification Methods, </booktitle> <address> CHARME, </address> <year> 1997. </year>
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3):843871, </volume> <year> 1994. </year>
Reference: [HQR98] <author> T.A. Henzinger, S. Qadeer, and S.K. Rajamani. You assume, </author> <title> we guarantee: Methodology and case studies. </title> <type> Technical report, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1998. </year>
Reference-contexts: The module ISARegFile has latch variables, and so we have increased the number of state bits in the module over which we perform the transition-invariant check. Alternatively, a more complex witness for isaRegFile , which does not have any latch variables, can be produced <ref> [HQR98] </ref>. Choice of constraining modules. An important problem one faces in a compositional proof is the choice of a mimimal set of constraining modules, preferably with small state spaces. Consider one proof obligation (lemma) i Q i in the compositional proof of P Q using Proposition 3. <p> The constraining modules are chosen preferably from the specification Q, rather than from the implementation P . Alternatively, the user can force specific submodules of P or Q into i . Fairness. Though not discussed here, our methodology also supports fairness conditions on the specification and implementation <ref> [HQR98] </ref>. <p> We used the methodology outlined in Section 3 to verify implementations of a sliding-window protocol and of Tomasulo's algorithm. Space does not permit us to describe these case studies in detail; a detailed description can be found in <ref> [HQR98] </ref>. The results of our experiments are summarized in Table 1. The table on the left gives the results for the sliding-window protocol with window size 12. The table on the right gives the results for Tomasulo's algorithm with 4 registers and 4 reservation stations.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer-aided Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2):190222, </volume> <year> 1983. </year>
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137 151. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference: [LV95] <author> N.A. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations, Part I: </title> <journal> Untimed systems. Information and Computation, </journal> <volume> 121(2):214233, </volume> <year> 1995. </year>
Reference: [McM97] <author> K.L. McMillan. </author> <title> A compositional rule for hardware design refinement. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> CAV 97: Computer Aided Verification, Lecture Notes in Computer Science 1254, </booktitle> <pages> pages 2435. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference: [McM98] <author> K.L. McMillan. </author> <title> Verification of an implementation of Tomasulo's algorithm by compositional model checking. </title> <editor> In A. Hu and M. Vardi, editors, </editor> <booktitle> CAV 98: Computer Aided Verification, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference: [Sta85] <author> E. W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <booktitle> In Proceedings of the 5th Conference on Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 206, </booktitle> <pages> pages 369391. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [Tan92] <author> Andrew S. Tanenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1992. </year>
Reference-contexts: Witnesses have appeared in various guises and forms (homomorphisms, refinement mappings, simulation relations, etc.) in different works [Lam83,LT87,AL91,BBLS92,CGL92,Kur94,LV95,McM97]. Also our choice of case studies is not new. Other correctness proofs for Tomasulo's algorithm can be found in [DP97,McM98]; the sliding-window protocol is taken from <ref> [Tan92] </ref>. 2 A Verification Problem Reactive modules. Reactive modules is a formalism for the modular description of systems with heterogeneous components. The definition of reactive modules can be found in [AH96]; here we give only a brief introduction.
References-found: 18

