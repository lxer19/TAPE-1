URL: http://www.cs.jhu.edu/~sullivan/datastruct.ps
Refering-URL: http://www.cs.jhu.edu/~sullivan/ftdownload.html
Root-URL: http://www.cs.jhu.edu
Title: Certification Trails for Data Structures  
Author: Gregory F. Sullivan Gerald M. Masson Dwight S. Wilson 
Address: Baltimore, MD 21218  
Affiliation: Dept. of Computer Science, Johns Hopkins Univ.,  
Abstract: Certification trails are a recently introduced and promising approach to fault-detection and fault-tolerance [19]. In this paper, we significantly generalize the applicability of the certification trail technique. Previously, certification trails had to be customized to each algorithm application, but here we develop trails appropriate to wide classes of algorithms. These certification trails are based on common data-structure operations such as those carried out using balanced binary trees and heaps. Any algorithm using these sets of operations can therefore employ the certification trail method to achieve software fault tolerance. To exemplify the scope of the generalization of the certification trail technique provided in this paper, constructions of trails for abstract data types such as priority queues and union-find structures will be given. These trails are applicable to any data-structure implementation of the abstract data type. It will also be shown that these ideas lead naturally to monitors for data-structure operations. Keywords: Software fault tolerance, certification trails, error monitoring, design diversity, data structures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adel'son-Vel'skii, G. M., and Landis, E. M., </author> <title> "An algorithm for the organization of information", </title> <journal> Soviet Math. Dokl., </journal> <pages> pp. 1259-1262, 3, </pages> <year> 1962. </year>
Reference-contexts: Input data was generated by choosing integral rectangle heights uniformly over the range [0; 100000]. The x-coordinates of the left edges were chosen uniformly over the range [0; 90000] and the width of each rectangle was chosen uniformly over the range <ref> [1; 10000] </ref>. Timing results are based on twenty executions for each input size. Size Basic Algorithm First Execution Second Execution Speedup Percent (Also Generates Trail) (Uses Trail) Savings 1000 0.25 0.27 0.11 2.27 24.00 5000 1.71 1.79 0.58 2.95 30.70 20000 8.39 8.76 2.36 3.56 33.73 Table 7: Skyline 27
Reference: [2] <author> Anderson, T., and Lee, P., </author> <title> Fault tolerance: principles and practices, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: This output is used if the sequence of operations is ill-formed, e.g., an operation has too many arguments or an argument refers to an inappropriate object. The answer-validation problem is similar to the idea of an acceptance test which is used in the recovery-block approach <ref> [17, 2] </ref> to software fault tolerance. The main difference is that an answer-validation problem is dependent upon a sequence of answers, not just an individual answer. Hence, if an incorrect answer appears in the sequence, it may not be detected immediately.
Reference: [3] <author> Andrews, D., </author> <title> "Software fault tolerance through executable assertions," </title> <booktitle> Rec. 12th Asilo-mar Conf. Circuits, Syst., Comput., </booktitle> <pages> pp. 641-645, </pages> <year> 1978, </year> <month> Nov. </month> <pages> 6-8. </pages>
Reference: [4] <author> Andrews, D., </author> <title> "Using excutable assertions for testing and fault tolerance," </title> <booktitle> Dig. 9th Annu. Int. Symp. Fault Tolerant Comput., </booktitle> <pages> pp. 102-105, </pages> <year> 1979, </year> <month> June 20-22. </month>
Reference: [5] <author> Avizienis, A., </author> <title> "The N-version approach to fault tolerant software," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 11, </volume> <pages> pp. 1491-1501, </pages> <month> Dec., </month> <year> 1985. </year>
Reference: [6] <author> Bayer, R., and McCreight, E., </author> <title> "Organization of large ordered indexes", </title> <journal> Acta Inform., </journal> <pages> pp 173-189, 1, </pages> <year> 1972. </year>
Reference: [7] <author> Blum, M., and Kannan, S., </author> <title> "Designing programs that check their work", </title> <booktitle> Proceedings of the 1989 ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 86-97, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [8] <author> Chen, L., and Avizienis A., </author> <title> "N-version programming: a fault tolerant approach to reliability of software operation," </title> <booktitle> Digest of the 1978 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 3-9, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1978. </year>
Reference: [9] <author> Cormen, T. H., and Leiserson, C. E., and Rivest, R. L., </author> <title> Introduction to Algorithms McGraw-Hill, </title> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: Sets are listed by first giving the name of the set followed by a colon and then the contents of the set. The disjoint-set-union problem is a classic problem which has many applications <ref> [9] </ref> such as the off-line min problem, connected components, least-common ancestors, and equivalence of finite automata. Of particular interest is the time-complexity of performing a sequence of operations. Let us say the total number of operations is m, which is assumed to be greater than or equal to n.
Reference: [10] <author> Fredman, M. L., and Saks, M. E., </author> <title> "The cell probe complexity of dynamic data structures," </title> <booktitle> Proc. 21st ACM Symp. on Theo. Comp. </booktitle> <year> 1989, </year> <pages> pp. 109-122, 2, </pages> <year> 1986. </year>
Reference-contexts: Fredman and Saks gave a lower bound of (mff (m; n)) <ref> [10] </ref> in a general cell-probe model. Gabow and Tarjan show how to solve some important special cases of this problem in O (m) time [11]. We now consider the answer-validation problem for the disjoint-set-union data type.
Reference: [11] <author> Gabow, H. N., and Tarjan, R. E., </author> <title> "A linear-time algorithm for a special case of disjoint set union," </title> <journal> J. of Comp. and Sys. Sci., </journal> <volume> 30(2), </volume> <pages> pp. 209-221, </pages> <year> 1985. </year>
Reference-contexts: Fredman and Saks gave a lower bound of (mff (m; n)) [10] in a general cell-probe model. Gabow and Tarjan show how to solve some important special cases of this problem in O (m) time <ref> [11] </ref>. We now consider the answer-validation problem for the disjoint-set-union data type. We will show that this problem can be solved in O (m) time where m is the number of operations. <p> Note, this time complexity is superior to the complexity of actually performing the sequence of operations as discussed above. One method for solving this problem in O (m) time uses the powerful techniques of Gabow and Tarjan <ref> [11] </ref>. However, we shall present a simpler method with a small constant of proportionality that is tailored to this problem. To solve this problem we will build a forest based on the union operations in the sequence.
Reference: [12] <author> Guibas, L. J., and Sedgewick, R., </author> <title> "A dichromatic framework for balanced trees", </title> <booktitle> Proceedings of the Nineteenth Annual Symposium on Foundations of Computing, </booktitle> <pages> pp. 8-21, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1978. </year>
Reference: [13] <author> Huffman, D., </author> <title> "A method for the construction of minimum redundancy codes", </title> <booktitle> Proc. IRE, </booktitle> <pages> pp 1098-1101, 40, </pages> <year> 1952. </year>
Reference-contexts: This is a classic algorithmic problem and one of the original solutions was found by Huffman <ref> [13] </ref>. It has been used extensively in data compression algorithms through the design and use of so called Huffman codes. The tree structure and code design are based on frequencies of individual characters in the data to be compressed. <p> The tree structure and code design are based on frequencies of individual characters in the data to be compressed. In this paper we are concerned only with the Huffman tree, the interested reader should consult <ref> [13] </ref> for information about the coding application. The Huffman tree is built from the bottom up and the overall structure of the algorithm is based on the greedy "merging" of subtrees. An array of pointers, ptr, is used to point 25 to the subtrees as they are constructed.
Reference: [14] <author> Johnson, B., </author> <title> Design and analysis of fault tolerant digital systems Addison-Wesley, </title> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: Next, the same algorithm is executed again on the same input and the output is compared to the earlier output. If the outputs differ then an error is indicated, otherwise the output is accepted as correct. This software fault tolerance method requires additional time, so-called time redundancy <ref> [14, 18] </ref>; however, it requires no additional software. It is particularly valuable for detecting errors caused by transient fault phenomena. If such faults cause an error during only one of the executions then either the error will be detected or the output will be correct.
Reference: [15] <author> Manber U., </author> <title> Introduction to Algorithms: A Creative Approach Addison-Wesley, </title> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: problem of computing the skyline of a set of rectangular 26 Size Basic Algorithm First Execution Second Execution Speedup Percent (Also Generates Trail) (Uses Trail) Savings 500,5000 0.38 0.41 0.22 1.73 17.11 1500,15000 1.39 1.48 0.69 2.01 21.94 Table 6: Shortest Path buildings by eliminating hidden lines is discussed in <ref> [15] </ref>. The method used is divide and conquer and it constructs a skyline in O (n log (n)) time. In this paper we use a plane sweep algorithm that can be easily implemented in terms of operations on priority queues.
Reference: [16] <author> Preparata F. P., and Shamos M. I., </author> <title> Computational geometry: an introduction, </title> <publisher> Springer--Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: The method used is divide and conquer and it constructs a skyline in O (n log (n)) time. In this paper we use a plane sweep algorithm that can be easily implemented in terms of operations on priority queues. Plane sweep algorithms are widely used for computational geometry problems <ref> [16] </ref>, and typically use a priority queue for event scheduling, and may be amenable to use of certification trail techniques. Using a plane sweep algorithm, we compute the skyline as follows.
Reference: [17] <author> Randell, B., </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June, </month> <year> 1975. </year>
Reference-contexts: This output is used if the sequence of operations is ill-formed, e.g., an operation has too many arguments or an argument refers to an inappropriate object. The answer-validation problem is similar to the idea of an acceptance test which is used in the recovery-block approach <ref> [17, 2] </ref> to software fault tolerance. The main difference is that an answer-validation problem is dependent upon a sequence of answers, not just an individual answer. Hence, if an incorrect answer appears in the sequence, it may not be detected immediately.
Reference: [18] <author> Siewiorek, D., and Swarz, R., </author> <title> The theory and practice of reliable design, </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1982. </year>
Reference-contexts: Next, the same algorithm is executed again on the same input and the output is compared to the earlier output. If the outputs differ then an error is indicated, otherwise the output is accepted as correct. This software fault tolerance method requires additional time, so-called time redundancy <ref> [14, 18] </ref>; however, it requires no additional software. It is particularly valuable for detecting errors caused by transient fault phenomena. If such faults cause an error during only one of the executions then either the error will be detected or the output will be correct.
Reference: [19] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Using certification trails to achieve software fault tolerance," </title> <booktitle> Digest of the 1990 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 423-431, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In this paper we significantly generalize the novel and powerful certification-trail technique for achieving fault tolerance in systems that was introduced in <ref> [19] </ref>. Although applicable to both hardware and software, we restrict our discussion of the certification-trail technique in the following to software fault tolerance. To explain the essence of the certification-trail technique for software fault tolerance, we will first discuss a simpler fault-tolerant software method. <p> Observant readers of our earlier paper <ref> [19] </ref> in which we introduced the notion of a certification trail might have noticed that our certification-trail solution for the min-spanning tree was generalizable. The generalized technique allows one to generate a certification trail for many algorithms which use a balanced binary tree data structure. <p> The degree of diversity or independence achieved when using certification trails depends on how they are used. A fuller discussion of this and of the relationship between certification trails and other approaches to software fault tolerance is contained in the expanded version of <ref> [19] </ref>. This current paper presents asymptotic analysis which shows that the certification-trail approach is desirable even when the overhead of generating the certification-trail is included.
Reference: [20] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Certification trails for data structures," </title> <institution> Department of Computer Science Technical Report JHU 90/17, Johns Hopkins University, Baltimore, Maryland, </institution> <year> 1990. </year>
Reference: [21] <author> Tarjan, R. E., </author> <title> "Efficiency of a good but not linear set union algorithm," </title> <journal> J. ACM, </journal> <volume> 22(2), </volume> <pages> pp. 215-225, </pages> <year> 1975. </year>
Reference-contexts: Let us say the total number of operations is m, which is assumed to be greater than or equal to n. Recall, n is the number of set elements and set names. Tarjan gave the tight upper bound of O (mff (m; n)) <ref> [21, 22] </ref> for this problem. The ff refers to the inverse of Ackermann's function which is a very slowly growing function.
Reference: [22] <author> Tarjan, R. E., </author> <title> "A class of algorithms which require nonlinear time to maintain disjoint sets," </title> <journal> J. of Comp. and Sys. Sci., </journal> <volume> 18(2), </volume> <pages> pp. 110-127, </pages> <year> 1979. </year>
Reference-contexts: Let us say the total number of operations is m, which is assumed to be greater than or equal to n. Recall, n is the number of set elements and set names. Tarjan gave the tight upper bound of O (mff (m; n)) <ref> [21, 22] </ref> for this problem. The ff refers to the inverse of Ackermann's function which is a very slowly growing function.
Reference: [23] <author> Tarjan, R. E., and Leeuwen, J. van, </author> <title> "Worst-case analysis of set union algorithms," </title> <journal> J. ACM, </journal> <volume> 31(2), </volume> <pages> pp. 245-281, </pages> <year> 1984. </year>
Reference-contexts: create (4,4) 1:f1,2g,3:f3g,4:f4g create (5,5) 1:f1,2g,3:f3g,4:f4g,5:f5g union (5,3) 1:f1,2g,4:f4g,5:f3,5g union (5,1) 4:f4g,5:f1,2,3,5g find (2) 5 find (5) 5 create (6,6) 4:f4g,5:f1,2,3,5g,6:f6g union (4,6) 4:f4,6g,5:f1,2,3,5g create (7,7) 4:f4,6g,5:f1,2,3,5g,7:f7g union (4,7) 4:f4,6,7g,5:f1,2,3,5g find (6) 4 Table 1: Sequence of operations for a Disjoint Set Union and earlier solutions used a path-compression heuristic <ref> [23] </ref>. Fredman and Saks gave a lower bound of (mff (m; n)) [10] in a general cell-probe model. Gabow and Tarjan show how to solve some important special cases of this problem in O (m) time [11]. We now consider the answer-validation problem for the disjoint-set-union data type.
Reference: [24] <author> Taylor, D., </author> <title> "Error Models for robust data structures," </title> <booktitle> Dig. 20th Annu. Int. Symp. Fault Tolerant Comput., </booktitle> <pages> pp. 416-422, </pages> <year> 1990 </year> <month> June 26-28. </month>
Reference-contexts: One possible application of the answer-validation problem occurs when it is used in conjunction with a repairable data structure which allows for repair but does not automatically attempt to detect faults <ref> [24] </ref>. Suppose an abstract data type is implemented with a repairable data structure. One can use an answer-validation procedure to detect errors in the answers generated by the abstract data type. When an error is detected, a repair of the data structure can be attempted.
Reference: [25] <author> Williams, J. W. J, </author> <title> "Algorithm 232 (heapsort)," </title> <journal> Commun. of ACM, </journal> <volume> vol.7, </volume> <pages> pp. 347-348, </pages> <year> 1964. </year>
References-found: 25

