URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR433.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: jfrens@cs.indiana.edu  
Title: Matrix Inversion using Quadtrees Implemented in Gofer  
Author: Jeremy D. Frens David S. Wise 
Date: May 1995  
Address: Bloomington, Indiana 47405-4101  
Affiliation: Computer Science Department Indiana University  
Pubnum: Technical Report 433  
Abstract: 1 c fl1994 by the authors. This document is made available by the authors as a means to ensure timely dissemination of scholarly and technical work on a non-commercial basis. Copyright and all other rights are maintained by the author or by other copyright holders, notwithstanding that they have offered their work electronically. It is understood that all persons copying this information will adhere to the terms and constraints invoked by the author's copyright. This work may not be reposted without the explicit permission of the copyright holder. Permission to make digital or hard copes of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyright may be transferred without further notice and this version may no longer be accessible. 2 Research reported herein was sponsored, in part, by the National Science Foundation under Grant Number DCR 90-027092. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> J. Fasel, P. Hudak, S. Peyton Jones & P. Wadler (eds.). </editor> <title> HASKELL special issue. </title> <journal> ACM SIGPLAN Notices 27, </journal> <month> 5 (May </month> <year> 1992). </year>
Reference-contexts: Similar code for exact arithmetic [4, Section 4] has also been written in Scheme. 0.1 Overview of this Report The code presented here is written for Gofer [2], a dialect of Haskell <ref> [1] </ref>. The code is intermixed with comments to make this report by using the literate programming tool noweb [3]. Similar to Knuth's WEB, noweb is a system where documentation and code are written in the same files. These noweb files can be processed to generate code or documentation. <p> For example, mtxRMtoQ converts a row-major matrix into a quadtree matrix. Similarly, the function convALtoPM converts a reverse-Ahnentafel list into a permutation matrix. 0.4 Acknowledgments Thanks must go out to Mark Jones for Gofer [2], an implementation of Haskell <ref> [1] </ref>. Thanks must also go to Norman Ramsey for his noweb literate programming tool [3]. 2 1 Pairs and Quadtrees A pair is a homogeneous binary tuple; a quadtree is a homogeneous four-tuple. <p> Alternatively, list_to_tree splits the vector based on the pivot sizes in . The split is made so that the sum of the pivot sizes in each half are equal to the same power of 2, creating what is termed a balanced vector. For example, suppose that = <ref> [2; 1; 1] </ref>. Let [10; 20; 30] be the list being turned into a tree. Based on , the list would be converted into (10; (20; 30)). This function is used to balance itself as well as and . <p> For example, let S be a 4 fi 4 matrix which is padded with blocks of sizes 1, 2 and 1 (in that sequence) to S 0 , the padded form of S of size 8. (See the example in Appendix D.) The padding count for S 0 would be <ref> [0; 0; 1; 2] </ref> representing the number of padding blocks of size 8, 4, 2, and 1, respectively. The function addresses_padding takes such a list of counts, and computes the reverse Ahnentafel indices for each block. <p> Indices are pulled off from the right of the tree (the southeast of the decomposition, its padding). The largest blocks are processed first, working down to the smallest. Padding blocks of the same size are processed at the same time. Consider the padding list <ref> [0; 0; 1; 2] </ref> and the reverse-Ahnentafel tree in Figure 1. Level 0 of the reverse-Ahnentafel tree represents the entire matrix S 0 which is of size 8. Since there is no padding of size 8, processing moves on to the next padding size. <p> Finishing our example, given the list <ref> [0; 0; 1; 2] </ref>, addresses_padding returns the list [[]; []; [7]; [13; 9]]. 52a hAhnentafel indices 52ai addresses_padding :: Int -&gt; [Int] -&gt; [[Int]] addresses_padding _ [] = [] addresses_padding i (x:xs) = sisterL i x : addresses_padding (niece i x) xs Defines: addresses_padding, used in chunk 57a. <p> To prevent this, padding is added between elimination blocks in the triangulation. (See [4, Section 3.2].) For example, let S be a 4 fi 4 matrix. Let = <ref> [1; 2; 1] </ref>. The first pivot block (the first 1 in ) is supposed to appear in the southeast corner of the triangulation. Since the triangulation is empty, this is no problem. The next pivot block is supposed to be placed to the northwest of the first. <p> Uses PaddingLists 56b and twice 49a. The function counts_padding counts the padding in a matrix by block size. That is, in the example in Section C.2, the list <ref> [0; 0; 1; 2] </ref> is such a list, stating that the resulting 8 fi 8 matrix has no pivots of size 8 or size 4, one of size 2, and two of size 1. 59c hExpanding code 57bi+ counts_padding :: [Bool] -&gt; [Int] -&gt; Int -&gt; [Int] counts_padding pad_flagL omega full_ord
Reference: [2] <author> Mark P. Jones. </author> <title> The implementation of the Gofer functional programming system. </title> <institution> Research Report YALEU/DCS/RR-1030, Computer Science Department, Yale University (May 1994). </institution>
Reference-contexts: This code for rational arithmetic was originally written by the second author in Scheme and is published here in readable Haskell. Similar code for exact arithmetic [4, Section 4] has also been written in Scheme. 0.1 Overview of this Report The code presented here is written for Gofer <ref> [2] </ref>, a dialect of Haskell [1]. The code is intermixed with comments to make this report by using the literate programming tool noweb [3]. Similar to Knuth's WEB, noweb is a system where documentation and code are written in the same files. <p> For example, mtxRMtoQ converts a row-major matrix into a quadtree matrix. Similarly, the function convALtoPM converts a reverse-Ahnentafel list into a permutation matrix. 0.4 Acknowledgments Thanks must go out to Mark Jones for Gofer <ref> [2] </ref>, an implementation of Haskell [1]. Thanks must also go to Norman Ramsey for his noweb literate programming tool [3]. 2 1 Pairs and Quadtrees A pair is a homogeneous binary tuple; a quadtree is a homogeneous four-tuple. <p> Alternatively, list_to_tree splits the vector based on the pivot sizes in . The split is made so that the sum of the pivot sizes in each half are equal to the same power of 2, creating what is termed a balanced vector. For example, suppose that = <ref> [2; 1; 1] </ref>. Let [10; 20; 30] be the list being turned into a tree. Based on , the list would be converted into (10; (20; 30)). This function is used to balance itself as well as and . <p> For example, let S be a 4 fi 4 matrix which is padded with blocks of sizes 1, 2 and 1 (in that sequence) to S 0 , the padded form of S of size 8. (See the example in Appendix D.) The padding count for S 0 would be <ref> [0; 0; 1; 2] </ref> representing the number of padding blocks of size 8, 4, 2, and 1, respectively. The function addresses_padding takes such a list of counts, and computes the reverse Ahnentafel indices for each block. <p> Indices are pulled off from the right of the tree (the southeast of the decomposition, its padding). The largest blocks are processed first, working down to the smallest. Padding blocks of the same size are processed at the same time. Consider the padding list <ref> [0; 0; 1; 2] </ref> and the reverse-Ahnentafel tree in Figure 1. Level 0 of the reverse-Ahnentafel tree represents the entire matrix S 0 which is of size 8. Since there is no padding of size 8, processing moves on to the next padding size. <p> Finishing our example, given the list <ref> [0; 0; 1; 2] </ref>, addresses_padding returns the list [[]; []; [7]; [13; 9]]. 52a hAhnentafel indices 52ai addresses_padding :: Int -&gt; [Int] -&gt; [[Int]] addresses_padding _ [] = [] addresses_padding i (x:xs) = sisterL i x : addresses_padding (niece i x) xs Defines: addresses_padding, used in chunk 57a. <p> To prevent this, padding is added between elimination blocks in the triangulation. (See [4, Section 3.2].) For example, let S be a 4 fi 4 matrix. Let = <ref> [1; 2; 1] </ref>. The first pivot block (the first 1 in ) is supposed to appear in the southeast corner of the triangulation. Since the triangulation is empty, this is no problem. The next pivot block is supposed to be placed to the northwest of the first. <p> Uses PaddingLists 56b and twice 49a. The function counts_padding counts the padding in a matrix by block size. That is, in the example in Section C.2, the list <ref> [0; 0; 1; 2] </ref> is such a list, stating that the resulting 8 fi 8 matrix has no pivots of size 8 or size 4, one of size 2, and two of size 1. 59c hExpanding code 57bi+ counts_padding :: [Bool] -&gt; [Int] -&gt; Int -&gt; [Int] counts_padding pad_flagL omega full_ord
Reference: [3] <author> Norman Ramsey. </author> <title> Literate programming simplified. </title> <booktitle> IEEE Software 11, </booktitle> <month> 5 (Sept </month> <year> 1994). </year> <pages> pp. 97-105. </pages>
Reference-contexts: The code is intermixed with comments to make this report by using the literate programming tool noweb <ref> [3] </ref>. Similar to Knuth's WEB, noweb is a system where documentation and code are written in the same files. These noweb files can be processed to generate code or documentation. <p> Similarly, the function convALtoPM converts a reverse-Ahnentafel list into a permutation matrix. 0.4 Acknowledgments Thanks must go out to Mark Jones for Gofer [2], an implementation of Haskell [1]. Thanks must also go to Norman Ramsey for his noweb literate programming tool <ref> [3] </ref>. 2 1 Pairs and Quadtrees A pair is a homogeneous binary tuple; a quadtree is a homogeneous four-tuple. The main motivation for the pair and quadtree is so that we can use mapping functions over them, breaking a problem into subprob-lems fit for parallelization.
Reference: [4] <author> David S. Wise. </author> <title> Undulant-block pivoting and integer-preserving matrix inversion. </title> <type> Technical Report 418, </type> <institution> Computer Science Department, </institution> <note> Indiana University (January 1995). 69 </note>
Reference-contexts: : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 67 References 69 ii 0 Introduction This paper implements and explains the code described by Wise in <ref> [4] </ref> for undulant-block pivoting and rational-arithmetic matrix inversion. This code for rational arithmetic was originally written by the second author in Scheme and is published here in readable Haskell. <p> This code for rational arithmetic was originally written by the second author in Scheme and is published here in readable Haskell. Similar code for exact arithmetic <ref> [4, Section 4] </ref> has also been written in Scheme. 0.1 Overview of this Report The code presented here is written for Gofer [2], a dialect of Haskell [1]. The code is intermixed with comments to make this report by using the literate programming tool noweb [3]. <p> These data types include pair and quadtree data types, a vector definition, and matrix definitions. The last two sections implement the inversion algorithm for quadtree matrices as described in <ref> [4] </ref>. To invert a matrix A, it must be decorated, decomposed, triangulated, and then finally inverted. Decoration is handled by the decorated matrix and its support functions. <p> The first defines a project file for Gofer which will load the program files in the correct order. One program file contains definitions of elementary functions that Gofer lacks. The other program files in the appendices implement book keeping algorithms which are not covered in <ref> [4] </ref> and could be replaced with other algorithms. 0.3 Notation 0.3.1 Vectors, Lists, Tuples, and Matrices Matrices have a two-dimensional shape and so appear as blocks. Vectors are designated by the angle brackets, h and i. Lists are designated with square brackets, [ and ]. <p> the vector h8; 12; 10; 14; 9; 13; 11; 15i would be stored in the form (((8; 12); (10; 14)); ((9; 13); (11; 15))) where ((8; 12); (10; 14)) is the north half of the vector and ((9; 13); (11; 15)) is the south half. (See the formal definition in <ref> [4, Section 1.1] </ref>.) To divide a vector recursively in half like this, the vector must have a length which is a power of two. Not every vector will conform to this requirement, so padding is added to the original vector to pad it out to a power of two. <p> In order to recognize the actual vector from its padding, the length of the vector must be known. This is most important when converting from the pair representation back to a list on output. (See Footnote 2 in <ref> [4] </ref>.) 2.1 File Layout 7 hbin-vector.gs 7i hVector definition 8ai hVector inheritance 8ci hVector normalization functions 8bi hTop level vector definition 10ai hTop level vector inheritance 10bi hVector conversion functions 10ci Root chunk (not used in this document). 7 2.2 Binary Vector Data Definition The Vectr class is the finite binary <p> It has three cases (see also <ref> [4, Section 1.1] </ref>): * The ZeroV constructor is the sentinel value Z which represents a zero vector of arbitrary length. * The ScalarV constructor stores non-zero scalar data of any type. * The Vec constructor stores a pair of north and south homogeneous, equal-sized vectors. 8a hVector definition 8ai type PairV <p> Uses Vectr 8a, ZeroV 8a, and normalizePV 8b. 11 3 Quadtree Matrix Data Definitions The quadtree representation for matrices is examined in <ref> [4, Section 1.1] </ref>. The definition of a quadtree matrix is an extension of the definition of a binary vector. The matrix is divided into four quadrants where each quadrant has the same order. The four quadrants are stored in one quadtree. <p> This code is used in chunk 14a. 14 The heart of matrix inheritance comes in the Num class. For the most part, the definitions here are straight-forward and follow the definitions in <ref> [4, Section 1.4] </ref>. Note that addition and subtraction are not defined for IdentM. The identity matrix is intended only for multiplication. <p> This section deals with the permutation quadtree matrix itself. The basic permutation matrix consists of zero and identity matrices such that exactly one identity matrix is in each column and row. Permutation matrices are discussed by Wise <ref> [4, Section 1.3] </ref>. 4.1 File Layout 20a hperm-qmtx.gs 20ai hQuadtree permutation matrix definition 20bi hQuadtree permutation matrix normalization 20ci hQuadtree permutation matrix inheritance 21ai Root chunk (not used in this document). 4.2 Quadtree Permutation Matrix Data Definition The definition of the permutation quadtree matrix is similar to the other quadtree matrices, <p> The depth expresses how many levels down the pivot block is located. The location denotes which quadrant the pivot block is in. The non-signpost portion of the decoration is used to compute future decorations. The code here uses decorations to preserve stability as described in <ref> [4, Section 3.3.1] </ref>. The matrix is searched for nown-singular blocks. A quadtree matrix is nown-singular if it is a non-zero scalar, a 2fi2 nonsingular matrix, or, in general, if one of the four quadrants is 0 and the two adjacent quadrants are nown-singular. <p> The Pos data type defines the four compass points (i.e., northwest, northeast, southwest, and southeast) for matrix quadrants to give the position of the nested pivot block. (In <ref> [4, Section 3.3] </ref>, Pos is represented by two boolean values.) The depth is represented by an integer. 22b hDecoration data definition 22bi data Pos = NW | NE | SW | SE type SignPost = (Pos, Int) Defines: NE, used in chunks 23e, 27b, and 39a. <p> Uses DMatrx 24b, Dec 23b, Deco 23b, Det 23a, Detm 23a, Pos 22b, ScalarDM 24b, ZeroDM 24b, and det_lg 29c. The determinant of a general n fi n block is a bit more tricky than the 2 fi 2 case. The function det_nxn looks for a nown-singular block (see <ref> [4, Section 3.3.1] </ref>). If the quadtree is not nown-singular, its determinant is WorstDet. <p> This code is used in chunk 32a. 34 7 L + U Decomposition The remaining two sections implement the matrix decomposition and backsubstitution to do the actual inversion of a matrix as described in <ref> [4, Section 2] </ref>. The code in this section implements the decomposition algorithm described in [4, Sections 2.3, 3.1]. <p> This code is used in chunk 32a. 34 7 L + U Decomposition The remaining two sections implement the matrix decomposition and backsubstitution to do the actual inversion of a matrix as described in [4, Section 2]. The code in this section implements the decomposition algorithm described in <ref> [4, Sections 2.3, 3.1] </ref>. <p> Moving the decomposed pivot blocks in S to the main diagonal is done through permutation matrices P and Q for row and column exchanges, respectively. The permutation matrices P and Q are built from series encodings of reverse-Ahnentafel indices and which are assembled during decomposition. (See <ref> [4, Section 2.2] </ref> and Appendix C.) The triangulation of A is therefore L + U 0 = P SQ. Since the pivot blocks are not necessarily scalars, decomposition also returns a list of pivot orders . <p> for the three functions defined in Section 8 which take the triangulation and complete the inversion. 7.1 File Layout 35 hlu.gs 35i hDecomposition 36i hPivoting 38bi hInverting and determinant 43ai Root chunk (not used in this document). 35 7.2 Decomposition of a Matrix The function decompose implements Algorithm 2 of <ref> [4] </ref>. It takes the matrix A and its order, yielding the determinant of P AQ, the triangulation L + U 0 , permutation matrices P and Q, the list of pivot block orders , the amount of padding added by the permutations, and a positive/negative sign. <p> The amount of added padding is an integer denoting the amount of padding that was added to the matrix in order to get the pivot blocks onto the diagonal. (See Appendix D and <ref> [4, Section 3.2] </ref>.) 36 hDecomposition 36i decompose :: (Num A, Num (Matrx A), Num (DMatrx A)) =&gt; Int -&gt; DMatrx A -&gt; (A, Matrx A, PMatrx, PMatrx, Vectr Int, Int, Bool) decompose ord (ScalarDM n) = (n, ScalarM (fromInteger 1), IdentPM, IdentPM, ScalarV ord, 0, True) decompose ord a = let <p> This code is used in chunk 37a. Occasionally, when converting from the decomposition S to the triangulation L + U 0 , padding must be added to S. (See <ref> [4, Section 3.2] </ref> and Appendix D.) The function pad adds the extra padding to S if it needs any. 37c hDecomposition support functions 37ai+ pad :: Matrx a -&gt; Int -&gt; Int -&gt; Matrx a pad s ord new_ord | otherwise = Mtx (pad s (twice ord) new_ord, ZeroM, ZeroM, IdentM) <p> Uses IdentM 13a, Matrx 13a, ceil_lg 48b, halve 49a, normalizeQM 13b, power2 48b, and unnormalizeM 13c. 7.3 Pivoting a Matrix The function pivots starts the actual decomposition as described in Algorithm 1 of <ref> [4, Section 2.3] </ref>. It takes the height of A and A itself. It yields the determinant of P AQ, the decomposition S, the list of pivot orders , and series encodings and . (The AhnenOrdList is a list of tuples which effectively contain , and . <p> Uses AhnenOrdList 56b, DMatrx 24b, Matrx 13a, ZeroM 13a, and pvots 38c. This code is used in chunk 35. The function pvots repeatedly calls the function piv to carry out the iteration of Algorithm 1 of <ref> [4] </ref> until A is fully eliminated and the decomposition is in S. 38c hPivoting support functions 38ci pvots :: (Num (Matrx A), Num (DMatrx A)) =&gt; Int -&gt; DMatrx A -&gt; A -&gt; Matrx A -&gt; AhnenOrdList -&gt; (A, Matrx A, AhnenOrdList) pvots _ ZeroDM det s ahnen = (det, s, <p> Uses AhnenOrdList 56b, DMatrx 24b, Matrx 13a, ZeroDM 24b, piv 39a, power2 48b, and signpost 24a. This definition is continued in chunks 39-42. This code is used in chunk 38b. 38 The function piv (see <ref> [4, Section 3.1.3] </ref>) works on the quadrant which actually contains the pivot block. On iteration l, piv takes the depth and size of the pivot block, A l and S l . In the base case, A l is the pivot block. <p> The functions here are for computing new reverse-Ahnentafel indices. 39b hPivot permutation functions 39bi leftson i = 2*i rightson i = 2*i+1 Defines: leftson, used in chunk 39a. rightson, used in chunk 39a. This code is used in chunk 39a. 39 On iteration l, the function off (see <ref> [4, Section 3.1.1] </ref>) takes A l , the Gaussian pivot column, the pivot row from A l , and an index i, indexing the pivot row from the given matrix. It yields A l+1 . <p> Uses #*%% 32b 33b, DMatrx 24b, DMtx 24b, Matrx 13a, ScalarV 8a, Vec 8a, Vectr 8a, ZeroDM 24b, ZeroV 8a, decorateDQ 27b, halve 49a, qmap3 5a, and tuple4 50. This code is used in chunk 40a. 40 The function row (see <ref> [4, Section 3.1.2] </ref>) takes A l , S l , a pivot column, and an index i. The pivot column is needed for the off quadrants. The value i is used to identify the pivot row in A l . <p> Uses #+% 32b 33a, DMatrx 24b, DMtx 24b, Matrx 13a, ZeroDM 24b, decorateDQ 27b, halve 49a, normalizeQM 13b, and unnormalizeM 13c. This code is used in chunk 41a. 41 The function col (see <ref> [4, Section 3.1.2] </ref>) works on the quadrant which contains the column of the pivot block (but not the pivot block itself). It takes A l , S l , a pivot row, indices i and j, and V . V is the inverted pivot block. <p> ScalarV 8a, Vectr 8a, ZeroDM 24b, ZeroV 8a, decorateDQ 27b, halve 49a, normalizePV 8b, normalizeQM 13b, off 40a, and unnormalizeM 13c. 42 7.4 Calculating the Determinant and Inverse of a Matrix In addition to the decomposed matrix, decomposition also returns the determinant of A as described in Algorithm 3 of <ref> [4] </ref>. The function determinant implements this algorithm, returning just the determinant of A. Note the function parity which calculates the parity of a permutation matrix based on its series encoding. <p> This function is used by the top level inversion function to invert entire matrices as well as by piv to invert pivot blocks. It is based on Algorithm 6 in <ref> [4, Section 2.5] </ref>. The function inv_f, defined in Section 8, implements the function f described in [4, Section 2.5]. <p> This function is used by the top level inversion function to invert entire matrices as well as by piv to invert pivot blocks. It is based on Algorithm 6 in <ref> [4, Section 2.5] </ref>. The function inv_f, defined in Section 8, implements the function f described in [4, Section 2.5]. <p> The decomposition algorithms (especially the bookkeeping algorithms in the appendices) are long and complex; however, two-thirds of the execution for matrix inversion is spent executing the code in this section. These functions are very tight and highly parallel. (See <ref> [4, Section 2.5] </ref>.) Decomposition of A returns L + U 0 . The inversion of A is [(I + L)U ] 1 = U 1 (I + L) 1 . Traditionally, U 1 and (I + L) 1 are computed separately and then multiplied together for the final answer. <p> Traditionally, U 1 and (I + L) 1 are computed separately and then multiplied together for the final answer. However, the three functions in this section compute [(I + L)U ] 1 directly. The functions are explained in detail in <ref> [4, Section 2.5] </ref>, including correctness proofs. 8.1 File Layout 45a hcircles.gs 45ai hFunction f definition 45bi hFunction g definition 46ai hFunction h definition 46bi Root chunk (not used in this document). 8.2 The Function f The function f defined in Algorithm 6 of [4] is called inv_f here to prevent identifier <p> The functions are explained in detail in [4, Section 2.5], including correctness proofs. 8.1 File Layout 45a hcircles.gs 45ai hFunction f definition 45bi hFunction g definition 46ai hFunction h definition 46bi Root chunk (not used in this document). 8.2 The Function f The function f defined in Algorithm 6 of <ref> [4] </ref> is called inv_f here to prevent identifier confusion in noweb. <p> Uses Matrx 13a, ScalarV 8a, Vec 8a, Vectr 8a, inv_g 46a, inv_h 46b, normalizeQM 13b, and unnormalizeM 13c. This code is used in chunk 45a. 45 8.3 The Function g This is the function g defined in Algorithm 6 of <ref> [4] </ref>, called inv_g here. <p> Uses Matrx 13a, ScalarV 8a, Vec 8a, Vectr 8a, ZeroM 13a, normalizeQM 13b, and unnormalizeM 13c. This code is used in chunk 45a. 8.4 The Function h This is the function h defined in Algorithm 6 of <ref> [4] </ref>. <p> The beginning of each level continues where the previous level left off. For computational ease of moving from level to level, reverse-Ahnentafel indexing (see <ref> [4, Section 1.2] </ref>) is used for the inversion of quadtree matrices: * The root (level 0) is numbered 1. * The left child of a node i at level j is numbered by i + 2 j . * The right child of a node i at level j is numbered <p> Note that j = blg ic (see Theorem 1 of <ref> [4] </ref>). See Figure 1 for a reverse-Ahnentafel binary tree out to the third level. Reverse-Ahnentafel indexing allows indices to be built from the bottom up using addition and doubling. Descending the tree is also easy, only using quotient and remainder on 2 at each interior node. <p> For example, 001011 reverses to 001110. Reversing the bits like this allows us to switch between a reverse-Ahnentafel index and its equivalent Ahnentafel index. (See Theorem 4 and Corollary 1 in <ref> [4] </ref>.) Computing the sister of a reverse-Ahnentafel index i becomes conceptually (but not computationally) easy: convert i into its equivalent Ahnentafel index by applying reverse_bits, subtract 1 for the sister, and finally convert the new index back into a reverse-Ahnentafel index by reversing the bits. <p> The code here is based on the definition in <ref> [4, Section 1.2] </ref>. <p> The permutation matrices are constructed using series encodings and . Series encodings are lists of reverse-Ahnentafel indices, representing the location of the pivot blocks. (See <ref> [4, Sections 1.2 and 2.2] </ref>.) The function convALtoPM is the master routine to convert a reverse-Ahnentafel list to a permutation matrix. The actual permutation matrices are built by build_p and build_q which make P (for row permutations) and Q (for column permutations), respectively. <p> To prevent this, padding is added between elimination blocks in the triangulation. (See <ref> [4, Section 3.2] </ref>.) For example, let S be a 4 fi 4 matrix. Let = [1; 2; 1]. The first pivot block (the first 1 in ) is supposed to appear in the southeast corner of the triangulation. Since the triangulation is empty, this is no problem. <p> Thus, the final matrix is of size 8. In this example, the size of the matrix doubled. Due to zero and identity compression, it is not much of a problem. As mentioned in <ref> [4, Section 3.2] </ref>, such doubling occurs very rarely in practice. This task is accomplished by paddding out into a balanced vector, described in [4, Section 3.2]. A balanced vector stores integers such that the sum of them is a power of 2. <p> In this example, the size of the matrix doubled. Due to zero and identity compression, it is not much of a problem. As mentioned in <ref> [4, Section 3.2] </ref>, such doubling occurs very rarely in practice. This task is accomplished by paddding out into a balanced vector, described in [4, Section 3.2]. A balanced vector stores integers such that the sum of them is a power of 2. For a given vector which sums to 2 p , its north and south halves sum up to 2 p1 . <p> extra padding. (See the example at the beginning of this appendix.) When this happens, the reverse-Ahnentafel indices are recomputed, moving them down one level and into the left main subtree. (See Figure 1.) The function expand does ex actly this by multiplying the index by two. (See Theorem 5 of <ref> [4] </ref>.) 59b hExpanding code 57bi+ expand :: PaddingLists -&gt; PaddingLists expand (pad_flagL, pi, psi, omega) = let pi' = zipWith helper pad_flagL pi psi' = zipWith helper pad_flagL psi in (pad_flagL, pi', psi', omega) where helper True index = index helper False index = twice index + 1 Defines: expand, used <p> Uses halve 49a. This code is used in chunk 60b. 60 E Parity of a Permutation Matrix Parity is determined by looking at the series encodings for permutation matrices. (See <ref> [4, Section 2.2] </ref>.) Each of the reverse-Ahnentafel indices in the series encodings represents an identity block in the permutation matrix. The reverse-Ahnentafel indices can be used with the parity tree in Figure 2 to compute the parity of a permutation matrix represented in a series encoding.
References-found: 4

