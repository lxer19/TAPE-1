URL: http://www.cs.washington.edu/homes/hineskj/UW-CSE-96-11-04.ps
Refering-URL: http://www.cs.washington.edu/homes/hineskj/Piamain.html
Root-URL: 
Title: Pia: A Framework For Embedded System Co-simulation with Dynamic Communication Support  
Author: Ken Hines 
Date: January 10, 1997  
Pubnum: Technical Report UW-CSE-96-11-04  
Abstract: Many co-simulation techniques either suffer from poor performance when simulating communications intensive systems, or represent communications with uniformly low detail. This paper presents a technique which represents communication at multiple detail levels and gives a designer the ability to dynamically choose the appropriate level for different parts of the system. This paper also presents a tool which uses this technique and experiments which show simulation speedups. 
Abstract-found: 1
Intro-found: 1
Reference: [BCO95] <author> G. Borriello, P. Chou, and R. Ortega. </author> <title> Embedded system co-design towards portability and rapid integration. </title> <booktitle> NATO, </booktitle> <year> 1995. </year>
Reference-contexts: We are currently working on automating the generation of design of fast communication models from a high level specification. This sort of automation should be especially useful when the Pia tools are used to validate the output of automatic synthesis tools such as Chinook <ref> [BCO95] </ref>, particularly since there is usually a complete, machine readable specification available.
Reference: [Bor86] <author> Alan Borning. </author> <title> Classes versus prototypes in object-oriented languages. </title> <booktitle> In Fall Joint Computer Conference, </booktitle> <month> November </month> <year> 1986. </year> <note> 18 REFERENCES </note>
Reference-contexts: For example, we may want to use the same stream layer direct communication model for all types of network interfaces. For this reason, Pia provides a mechanism for inheritance. The semantics of Pia inheritance are rooted in prototype based object oriented inheritance, rather than class based <ref> [Bor86, Lie86] </ref>. A component or interface description actually instantiates the interface, and inheritance actually copies parts of the inherited interface into the inheriting interface. It is possible to define interfaces which never get imported or used directly. These are called abstract interfaces or templates.
Reference: [BST92] <author> D. Becker, R.K. Singh, and S. G. </author> <title> Tell. An engineering environment for hardware/software co-simulation. </title> <booktitle> In 29th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 129-134, </pages> <year> 1992. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [Buc95] <author> Joe Buck. Almagest, </author> <note> Ptolemy manual version 0.5.2. UCB, </note> <year> 1995. </year>
Reference: [KKSC96] <author> Kyuseok Kim, Yonjoo Kim, Youngsoo Shin, and Kiyoung Choi. </author> <title> An integrated hardware-software sosimulation environment with automated interface generation. </title> <booktitle> In 7th International Workshop on Rapid Systems Prototyping, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [Kle96] <author> R. Klein. </author> <title> Miami: a hardware software co-simulation environment. </title> <booktitle> In Proceedings. Seventh IEEE International Workshop on Rapid System Prototyping. Shortening the path from specification to proto-typing, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Dynamic selection of abstraction level is not unique to our technique. For example, Mentor Graphics' Miami/Seamless CVE allows both address based optimization of processor-memory transactions through a Memory Image Server (MIS) and time optimization, (turning off the simulator clock) <ref> [Kle96] </ref>.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In OOPSLA `86 Proceedings, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: For example, we may want to use the same stream layer direct communication model for all types of network interfaces. For this reason, Pia provides a mechanism for inheritance. The semantics of Pia inheritance are rooted in prototype based object oriented inheritance, rather than class based <ref> [Bor86, Lie86] </ref>. A component or interface description actually instantiates the interface, and inheritance actually copies parts of the inherited interface into the inheriting interface. It is possible to define interfaces which never get imported or used directly. These are called abstract interfaces or templates.
Reference: [Row94] <author> James Rowson. Hardware/software co-simulation. </author> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 439-440, </pages> <year> 1994. </year>
Reference-contexts: There is tension between these goals, however, because detail and accuracy cost in simulation time. It is therefore import ant for the simulator to generate only the important details and to minimize the rest. Rowson lists several common co-simulation tech niques <ref> [Row94] </ref>: * The nano-second accurate processor model. In this technique, the processor is modeled with a great deal of accuracy. Typically, only 1 to 100 instructions can be executed per second. This is probably much more detail than needed in em bedded systems. * The cycle accurate processor model.
Reference: [SY96] <author> Benny Schnaider and Einat Yogev. </author> <title> Software development in a hardware simulation environment. </title> <booktitle> In 33rd Design Automation Conference Proceedings, </booktitle> <pages> pages 684-689, </pages> <year> 1996. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [TC95] <author> D. E. Thomas and S. L. Coumeri. </author> <title> A simulation environment for hardware-software codesign. </title> <booktitle> In Proceedings, International Conference on Computer Design. </booktitle> <publisher> IEEE CS Press, </publisher> <month> October </month> <year> 1995. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [uM96] <author> Vojin Zivojnovic and Heinrich Meyr. </author> <title> Compiled hw/sw co-simulation. </title> <booktitle> In 33rd Design Automation Conference Proceedings, </booktitle> <pages> pages 690-695, </pages> <year> 1996. </year>
Reference-contexts: A processor block is a combination of a processor and some memory. This allows 4 such diverse processor models as ISA simulators, object code re-compiled for the simulator host (as in <ref> [uM96] </ref>) as well as source code compiled for the simulator host. In most cases, we expect that source code compiled for the simulator host processor will be sufficient. Unlike communication models, processor models cannot be changed during a simulation run.
Reference: [VCJ96] <author> Carlos A. Valderramma, Adel Changuel, and Ahmed A. Jerraya. </author> <title> Virtual proto-typing for modular and flexible hardware-software systems. Design Automation For Embedded Systems, </title> <year> 1996. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [VNPJ96] <author> C. A. Valderrama, Francois Nacabal, Pierre Paulin, and Ahmed Amine Jer-raya. </author> <title> Automatic generation of interfaces for distributed c-vhdl cosimulation of embedded systems: an industrial experience. </title> <booktitle> In 7th International Workshop on Rapid Systems Prototyping, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Many groups have found it worthwhile to compile the system software for the simulator host and run this software in a process of its own using operating system based primitives for communication with a hardware simulator <ref> [BST92, TC95, SY96, VCJ96, VNPJ96, KKSC96] </ref>. Techniques of this sort can yield very good performance when simulating computa-tionally intensive systems that don't require much in the way of fine grained communication. However, communication between the hardware simulator and the software is expensive, and this limits the amount of speedup possible.
Reference: [Wil94] <author> John Wilson. </author> <title> Hardware/software selected cycle solution. </title> <booktitle> In Proceedings of the international International Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: For this reason, an embedded processor can be thought of as simply a glue device which connects the hardware and the software portions of the design, as shown in Figure 1. Wilson describes a co-simulation technique called Selected Cycle Simulation <ref> [Wil94] </ref> which essentially combines the synchronizing handshake and the bus functional models of Rowson. In this technique, the system software is compiled for the host computer. For communication, the software sends a message to a bus functional unit in the hardware simulator.
References-found: 14

