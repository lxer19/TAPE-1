URL: ftp://ftp.dcs.ex.ac.uk/pub/usr/david/ycs215.ps.Z
Refering-URL: http://www.dcs.ex.ac.uk/~david/research/york.html
Root-URL: http://www.dcs.ex.ac.uk
Title: Optimising Partial Applications in TIM  
Author: David Wakeling and Alan Dix 
Date: Number 215 (November 1993)  
Address: York  
Affiliation: University of  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Argo. </author> <title> Improving the Three Instruction Machine. </title> <booktitle> In Proceedings of the 1989 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 100-115. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: We originally made this observation in March 1989, when a draft of this paper was circulated privately. Since then, there have been a number of publications about TIM (see, for example, <ref> [1, 10, 8] </ref>). Inevitably, some of the ideas presented here have been invented independently, or have been improved upon in these subsequent publications.
Reference: [2] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Although the nfib and tak programs are somewhat atypical, primes, sort and queens are all examples of more realistic programs. The folds and quad programs make extensive use of partial application, a style which is commonly advocated in textbooks on functional programming <ref> [2] </ref>. For each of these programs, we obtained two instruction profiles. These profiles are given in Appendix A and summarised in Figure 1 and Figure 2 below.
Reference: [3] <author> J. Fairbairn and S. Wray. TIM: </author> <title> A Simple, Lazy Abstract Machine to Execute Supercombinators. </title> <booktitle> In Proceedings of the 1987 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 34-45. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year> <note> LNCS 274. </note>
Reference-contexts: 1 Introduction In <ref> [3] </ref> Fairbairn and Wray introduced TIM, a simple abstract machine for executing supercombinators. Their abstract machine is an elegant design optimised for normal order evaluation. However, the addition of a mechanism to implement lazy evaluation considerably increases its complexity and imposes a significant overhead. <p> For the sake of definiteness, we take Fairbairn and Wray's 1987 paper <ref> [3] </ref> as the source of our terminology and notation, referring to the machine described there as the standard TIM . However, in addition to that paper, the reader may also wish to consult the book by Peyton Jones and Lester [8] for an excellent tutorial. <p> This compiler follows the scheme outlined by Fairbairn and Wray <ref> [3] </ref> except in the compilation of structured types. The treatment of structured types in FLIC is fundamentally different from their treatment in TIM. In FLIC they are represented as tagged-tuples and case-analysis and untupling are performed by special instructions. <p> The large number of Enter arg' and Self instructions can be reduced by performing sharing, strictness and evaluation analyses at compile-time. These analyses are well described in the original paper <ref> [3] </ref>, and we shall not consider them further here.
Reference: [4] <author> B. Goldberg. </author> <title> Detecting sharing of partial applications in functional programs. </title> <booktitle> In Proceedings of the 1987 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year> <note> LNCS 274. </note>
Reference-contexts: Each supercombinator application creates a new frame to represent a possibly shared partial application of f. Of course, if a partial application of f is unshared then the corresponding supercombinator is redundant. A sophisticated sharing analysis, such as <ref> [4] </ref>, could be used to eliminate these redundant supercombinators. As with child frame sharing, parent frame sharing eliminates the extra frame required to represent a partial application of the child combinator. In this case though, the partial application of the child shares the parent's frame rather than the child's frame. <p> At the same time, it also enables several additional optimisations. The real advantage of parent frame sharing, however, is that it allows the results of a sharing analysis, such as <ref> [4] </ref>, to be usefully applied in further improving performance. Our preference, therefore, lies with parent frame sharing. A Instruction Profiles This appendix gives two instruction profiles for each of the benchmark programs described in section 4.
Reference: [5] <author> R. J. M. Hughes. Super-combinators: </author> <title> A New Implementation Method for Applicative Languages. </title> <booktitle> In 1982 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 1-10, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: An observation about supercombinators, however, tells us that this interpretive overhead can be reduced without a separate stack for markers. 7 Supercombinators The TIM assumes that all programs have been converted either into supercombina-tors <ref> [5] </ref> or lambda-lifted combinators [6]. Let us assume conversion to supercombina-tors as described in [5]. <p> An observation about supercombinators, however, tells us that this interpretive overhead can be reduced without a separate stack for markers. 7 Supercombinators The TIM assumes that all programs have been converted either into supercombina-tors <ref> [5] </ref> or lambda-lifted combinators [6]. Let us assume conversion to supercombina-tors as described in [5]. Starting with the leftmost, innermost lambda abstraction of the program, every lambda abstraction v.E is converted into an application of a new supercombinator C to the maximal free expressions e 1 . . . e n of E.
Reference: [6] <author> T. Johnsson. </author> <title> Lambda lifting: Transforming programs to recursive equations. </title> <booktitle> In Proceedings of the 1985 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1985. </year> <note> LNCS 201. </note>
Reference-contexts: An observation about supercombinators, however, tells us that this interpretive overhead can be reduced without a separate stack for markers. 7 Supercombinators The TIM assumes that all programs have been converted either into supercombina-tors [5] or lambda-lifted combinators <ref> [6] </ref>. Let us assume conversion to supercombina-tors as described in [5]. Starting with the leftmost, innermost lambda abstraction of the program, every lambda abstraction v.E is converted into an application of a new supercombinator C to the maximal free expressions e 1 . . . e n of E.
Reference: [7] <author> T. Johnsson. </author> <title> Compiling Lazy Functional Languages. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology, S-412 96 Goteborg, </institution> <month> February </month> <year> 1987. </year> <month> 17 </month>
Reference-contexts: So the partial application of C given above is replaced by x = sqrt 64 in In our implementation, local definitions are implemented using a technique reminiscent of that used by the G-machine <ref> [7] </ref>.
Reference: [8] <author> S. L. Peyton Jones and D. Lester. </author> <title> Iplementing Functional Languages: A Tutorial. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: We originally made this observation in March 1989, when a draft of this paper was circulated privately. Since then, there have been a number of publications about TIM (see, for example, <ref> [1, 10, 8] </ref>). Inevitably, some of the ideas presented here have been invented independently, or have been improved upon in these subsequent publications. <p> However, in addition to that paper, the reader may also wish to consult the book by Peyton Jones and Lester <ref> [8] </ref> for an excellent tutorial. TIM represents all values as closures of the form &lt; c; f &gt;, where c is the code pointer and f is the frame pointer. The frame pointer points to a frame containing the arguments used by the code at c. <p> , . . . , l m )], f 1 , (&lt; Struct; f &gt;,A), F [f 7! (a 1 , . . . , a n ,t)]&gt; ) &lt; l t , f 1 , A, F&gt; This representation of structured types has similarities with the one described in <ref> [8] </ref>. 4 Instruction Profiles We used our compiler to compile seven benchmark programs written in FLIC.
Reference: [9] <author> S. L. Peyton Jones. </author> <title> FLIC a functional language intermediate code. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 23(8) </volume> <pages> 30-48, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The operation of the machine is described using state transitions of the form: &lt;PC, CF, Stack, Heap&gt; ) &lt;PC', CF', Stack', Heap'&gt; 3 A TIM Implementation We wrote a compiler to translate programs written in the Functional Language Intermediate Code, FLIC <ref> [9] </ref> into TIM code. This compiler follows the scheme outlined by Fairbairn and Wray [3] except in the compilation of structured types. The treatment of structured types in FLIC is fundamentally different from their treatment in TIM.
Reference: [10] <author> S. Wray and J. Fairbairn. </author> <title> Non-strict Languages | Programming and Implementation. </title> <journal> Computer Journal, </journal> <volume> 32(2) </volume> <pages> 142-151, </pages> <month> April </month> <year> 1989. </year> <month> 18 </month>
Reference-contexts: We originally made this observation in March 1989, when a draft of this paper was circulated privately. Since then, there have been a number of publications about TIM (see, for example, <ref> [1, 10, 8] </ref>). Inevitably, some of the ideas presented here have been invented independently, or have been improved upon in these subsequent publications. <p> It is an optimi-sation that has been suggested by several researchers, including Wray and Fairbairn 7 themselves <ref> [10] </ref>. However, without the introduction of a separate stack for markers, child frame sharing does nothing to reduce the interpretive overhead of the Take instruction, which is why the performance of the remaining programs is unchanged.
References-found: 10

