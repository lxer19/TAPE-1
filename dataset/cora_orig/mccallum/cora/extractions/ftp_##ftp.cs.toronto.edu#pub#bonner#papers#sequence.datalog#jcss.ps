URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/sequence.datalog/jcss.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  mecca@dis.uniroma1.it  
Title: Sequences, Datalog and Transducers  
Author: Anthony Bonner Giansalvatore Mecca 
Web: URL: http://www.cs.toronto.edu/~bonner/papers.html#sequence-datalog  
Note: To appear in the Journal of Computer and System Sciences (JCSS), special issue on the Fourteenth ACM International Symposium on Principles of Database Systems (PODS'95). This and related papers are available at the following  
Date: March 22, 1998  
Address: Toronto Canada M5S 1A1  Via della Tecnica, 3 85100 Potenza, Italy  
Affiliation: Department of Computer Science University of  D.I.F.A. Universita della Basilicata  
Abstract: This paper develops a query language for sequence databases, such as genome databases and text databases. The language, called Sequence Datalog, extends classical Datalog with interpreted function symbols for manipulating sequences. It has both a clear operational and declarative semantics, based on a new notion called the extended active domain of a database. The extended domain contains all the sequences in the database and all their subsequences. This idea leads to a clear distinction between safe and unsafe recursion over sequences: safe recursion stays inside the extended active domain, while unsafe recursion does not. By carefully limiting the amount of unsafe recursion, the paper develops a safe and expressive subset of Sequence Datalog. As part of the development, a new type of transducer is introduced, called a generalized sequence transducer. Unsafe recursion is allowed only within these generalized transducers. Generalized transducers extend ordinary transducers by allowing them to invoke other transducers as "subroutines." Generalized transducers can be implemented in Sequence Datalog in a straightforward way. Moreover, their introduction into the language leads to simple conditions that guarantee safety and finiteness. This paper develops two such conditions. The first condition expresses exactly the class of ptime sequence functions; and the second expresses exactly the class of elementary sequence functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley Publ. Co., </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: predicate answer is defined by the following clauses, and * is the empty sequence: answer (X ) r (X ); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). For each sequence X in r, the formula answer (X ) is true if it is possible to split X into three parts such that abc n is true. <p> by the following clauses, and * is the empty sequence: answer (X ) r (X ); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). For each sequence X in r, the formula answer (X ) is true if it is possible to split X into three parts such that abc n is true. <p> and * is the empty sequence: answer (X ) r (X ); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). For each sequence X in r, the formula answer (X ) is true if it is possible to split X into three parts such that abc n is true. <p> For example, given the sequence abcd, we want the sequence aabbccdd. We call these sequences echo sequences. The easiest way to define echo sequences is with the following program: answer (X; Y ) R (X ); echo (X; Y ): echo (*; *) true. echo (X; X <ref> [1] </ref> * X [1] * Z) echo (X [2:end]; Z). The first rule retrieves every sequence in relation R and its echo, by invoking the predicate echo (X; Y ). The last two rules specify what an echo sequence is. <p> We call these sequences echo sequences. The easiest way to define echo sequences is with the following program: answer (X; Y ) R (X ); echo (X; Y ): echo (*; *) true. echo (X; X <ref> [1] </ref> * X [1] * Z) echo (X [2:end]; Z). The first rule retrieves every sequence in relation R and its echo, by invoking the predicate echo (X; Y ). The last two rules specify what an echo sequence is. <p> In relational databases, a query language is a set of formulas representing relational queries. This leads to the notions of data complexity and expressibility of query languages <ref> [1] </ref>. These ideas can be extended to sequence databases in a natural way. A sequence query language is a set of formulas representing sequence queries. 3 A sequence query is expressible in a language if some formula in the language represents it. <p> We say that a variable, X, is guarded in a clause if X occurs in the body of the clause as an argument of some predicate. Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X ), but it is unguarded in p (X ) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses are not required to be guarded. However, the concept of guardedness will be useful in some proofs. <p> Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X ), but it is unguarded in p (X ) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses are not required to be guarded. However, the concept of guardedness will be useful in some proofs. Finally, we assume familiarity with basic notions of logic programming, such as ground terms and Herbrand universe. <p> For example, to express the transition ffi (q; a) = (q 0 ; b; !), we use the following rule, where t denotes the blank tape symbol: 4 fl k : conf (q 0 ; X l * b; X r <ref> [1] </ref>; X r [2:end] * t) conf (q; X l ; a; X r ): Finally, the following rule detects the end of a computation and returns the contents of the machine tape: fl 2 : output (X l [2:end] * S * X r ) conf (q h ; X
Reference: [2] <author> S. Abiteboul and P. Kanellakis. </author> <title> Object identity as a query language primitive. </title> <booktitle> In ACM SIGMOD International Conf. on Management of Data, </booktitle> <pages> pages 159-173, </pages> <year> 1989. </year>
Reference-contexts: The restrictions limit the creation of new sequences by forbidding recursion through transducer terms, just as object query languages sometimes forbid recursion through object creation <ref> [2] </ref>. Intuitively, this ensures that the transducer network corresponding to a program is acyclic. The syntactic restrictions are defined in terms of predicate dependency graphs. These graphs represent dependencies between predicates in rule heads and rule bodies. To keep the development simple, we assume that all programs are guarded.
Reference: [3] <author> A. Albano, L. Cardelli, and R. Orsini. </author> <title> Galileo: a strongly typed interactive conceptual language. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(2) </volume> <pages> 230-260, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15]. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: <ref> [3, 6, 7, 32, 12] </ref>). In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [4] <author> K. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kauffman, </publisher> <address> Los Altos, </address> <year> 1988. </year>
Reference-contexts: For example, if N and M are index variables, then 3, N + 3, N M , end 5 and end 5 + M are all index terms. Similarly, if S 1 and S 2 are sequence variables, and N is an index variable, then S 1 <ref> [4] </ref>, S 1 [1:N ] and ccgt * S 1 [1:end 3] * S 2 are all sequence terms. Note that (S 1 * S 2 )[1:N ] and S [1:N ][M :end] are not terms. <p> That is, we can require that programs be stratified with respect to construction. Stratified construction can be formally defined along the same lines as stratified negation in classical logic programs <ref> [4] </ref>, and can be efficiently checked. Programs with stratified construction have a finite semantics even though new sequences can be constructed (in a limited way) during query evaluation.
Reference: [5] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and Z. Zdonik. </author> <title> The object-oriented database manifesto. </title> <booktitle> In First Intern. Conference on Deductive and Object Oriented Databases (DOOD'89), </booktitle> <address> Kyoto, Japan, </address> <pages> pages 40-57, </pages> <year> 1989. </year> <month> 37 </month>
Reference-contexts: 1 Introduction Sequences represent an important feature of Next Generation Database Systems <ref> [5, 31] </ref>. In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15].
Reference: [6] <editor> P. Atzeni, editor. LOGIDATA+: </editor> <title> Deductive Databases with Complex Objects, </title> <booktitle> Lecture Notes in Computer Science 701. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15]. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: <ref> [3, 6, 7, 32, 12] </ref>). In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [7] <author> F. Bancilhon, S. Cluet, and C. Delobel. </author> <title> A query language for the O 2 object-oriented database system. </title> <booktitle> In Second Intern. Workshop on Database Programming Languages (DBPL'89), </booktitle> <pages> pages 122-138, </pages> <year> 1989. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15]. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: <ref> [3, 6, 7, 32, 12] </ref>). In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [8] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theorethic characterization of the polytime functions. </title> <booktitle> In ACM Intern. Symposium on Theory of Computing, </booktitle> <pages> pages 283-293, </pages> <year> 1992. </year>
Reference-contexts: Both theorems are concerned with transducer networks that have a single input and a single output. Such networks compute a function from sequences to sequences. Theorem 5 first characterizes the sequence functions computable in polynomial time. (Other characterizations can be found in <ref> [14, 8, 22] </ref>.) Theorem 6 then characterizes the sequence functions computable in elementary time. In these theorems, and in the rest of the paper, we assume that the alphabet is finite, and that the domain of every sequence function is a (possibly infinite) subset of fl .
Reference: [9] <author> A. J. Bonner. </author> <title> Hypothetical Datalog: complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference: [10] <author> A. J. Bonner and G. Mecca. </author> <title> Querying sequence databases with transducers. </title> <booktitle> In International Workshop on Database Programming Languages (DBPL), </booktitle> <address> Estes Park, Colorado, </address> <month> August 18-20 </month> <year> 1997. </year> <note> To appear. Available at http://poincare.inf.uniroma3.it:8080/~mecca. </note>
Reference-contexts: Each network then computes a mapping from sequence tuples to sequence tuples. When the network has only one output, the network computes a sequence function. This section presents basic results about the complexity of generalized transducer networks. For an expanded analysis see <ref> [25, 10] </ref>. The computational complexity of the sequence function computed by a transducer network depends on two parameters. The first is the diameter of the network, i:e:, the maximum length of a path in the network. <p> The theorems below characterize the complexity and expressibility of two classes of transducer networks, those of order 2 and 3, respectively. Higher order networks are investigated in <ref> [25, 10] </ref>. Our first results concern the output size of transducer networks. <p> We prove this result for programs of order k 3. In fact, we establish stronger results than mere finiteness. By considering programs of order 2 and order 3 separately, we establish tight bounds on the size of their minimal models. The proofs can be extended to higher-order programs <ref> [25, 10] </ref>. Definition 11 (Database Size) The size of a database (or a finite interpretation) is the number of sequences in its extended active domain. Theorem 8 below shows that for programs of order 2, the size of the minimal model is polynomial in the database size. <p> Proof: Follows immediately from Theorems 8 and 9, since a model is finite iff its extended active domain in finite. 2 Using a similar technique, Corollary 2 can be extended to higher-order Transducer Datalog programs <ref> [25, 10] </ref>. Thus, any safe program has a finite semantics. 8.2 Expressibility of Strongly Safe Programs Building on Theorems 8 and 9, this section establishes expressibility results for strongly safe programs.
Reference: [11] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural recursion as a query language. </title> <booktitle> In Third Intern. Workshop on Database Programming Languages (DBPL'91), </booktitle> <pages> pages 9-19, </pages> <year> 1991. </year>
Reference-contexts: A similar result is reported in [22], in which an algebra for partially ordered multi-sets (pom-sets) is defined. The algebra is obtained by extending the bag algebra of [21] with new operators to handle arbitrary pomsets, plus an iterator for performing structural recursion <ref> [11] </ref>. The authors define a tractable fragment of the language by restricting the class of structures allowed and introducing a form of bounded iterator to prevent exponential growth of query answers.
Reference: [12] <author> R. G. G. Cattel, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15]. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: <ref> [3, 6, 7, 32, 12] </ref>). In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [13] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21 </volume> <pages> 333-347, </pages> <year> 1980. </year>
Reference-contexts: Given a sequence query, Q, and a database, db, Q (db) is the result of evaluating Q over db. 2 A sequence function is a partial mapping from fl to itself. We say that the function is computable 2 Database queries are often required to be generic <ref> [13] </ref>. Although this notion can be extended to sequence databases in a straightforward way, genericity is not an issue in this paper. 7 if it is partial recursive.
Reference: [14] <author> L. S. Colby, E. L. Robertson, L. V. Saxton, and D. Van Gucht. </author> <title> A query language for list-based complex objects. </title> <booktitle> In Thirteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'94), </booktitle> <pages> pages 179-189, </pages> <year> 1994. </year>
Reference-contexts: Appendix B establishes results on a class of "guarded" programs, results used in a number of expressibility proofs in the paper. 1.1 Background Sequence query languages have been recently investigated in the context of functional and algebraic programming <ref> [14, 22] </ref>, and some sophisticated and expressive languages have been proposed. Great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. <p> Great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. In <ref> [14] </ref>, for example, a functional query language for nested lists is obtained by introducing a new form of structural recursion called list traversal, in which two different lists are used. <p> Both theorems are concerned with transducer networks that have a single input and a single output. Such networks compute a function from sequences to sequences. Theorem 5 first characterizes the sequence functions computable in polynomial time. (Other characterizations can be found in <ref> [14, 8, 22] </ref>.) Theorem 6 then characterizes the sequence functions computable in elementary time. In these theorems, and in the rest of the paper, we assume that the alphabet is finite, and that the domain of every sequence function is a (possibly infinite) subset of fl .
Reference: [15] <institution> Communications of the ACM. </institution> <note> Special issue on the Human Genome project. vol. 34(11), </note> <month> November </month> <year> 1991. </year>
Reference-contexts: In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed <ref> [15] </ref>. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: [3, 6, 7, 32, 12]).
Reference: [16] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by RS-operations: towards a unified approach to querying sequence data. </title> <booktitle> In Eleventh ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS'92), </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: In other cases, both expressiveness and finiteness were achieved, but at the expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [16, 34] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [16] is then developed based on 2 the notion of rs-operations. Each rs-operation is either a merger or an extractor. <p> In [16, 34], for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic <ref> [16] </ref> is then developed based on 2 the notion of rs-operations. Each rs-operation is either a merger or an extractor. Intuitively, given a set of patterns, an associated merger uses the patterns to "merge" a set of sequences. An extractor "retrieves" subsequences of a given sequence. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [36]. 1.2 Overview of the Language This paper builds on the works of <ref> [16, 20, 27] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics. This language, called Sequence Datalog, is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over sequences. <p> Specifically, we allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [16, 29, 17] </ref>, a transducer is defined as a machine with multiple input lines, one output line, and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> Note that for each sequence of length k over , there are at most k (k+1) 2 + 1 different contiguous subsequences (including the empty sequence). For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. Databases, Queries and Functions: As in <ref> [16, 20] </ref>, we extend the relational model so that tuples can contain sequences of symbols, instead of just single symbols. Formally, a relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a tuple of relations over . <p> Transducers support a variety of low-complexity sequence restructurings, including concatenation and complementation. For this reason, transducers have been incorporated into a number of data models and query languages for sequence databases <ref> [16, 20, 17, 29] </ref>. Unfortunately, like sequence concatenation, transducers tend to be both too powerful and too weak. As described in Section 1.1, query languages based on transducers are either highly expressive but unsafe, or safe but unexpressive. Our solution to this problem is to generalize the transducer model. <p> Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes many of the transducer models proposed in the literature (see for example <ref> [16, 29] </ref>). Definition 7 (Generalized Transducers) A generalized m-input sequence transducer of order k &gt; 0 is a 4-tuple hK; q 0 ; ; ffii where: 1.
Reference: [17] <author> G. H. Gonnet. </author> <title> Text dominated databases: Theory, practice and experience. </title> <booktitle> Tutorial presented at PODS, </booktitle> <year> 1994. </year>
Reference-contexts: Specifically, we allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [16, 29, 17] </ref>, a transducer is defined as a machine with multiple input lines, one output line, and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> Transducers support a variety of low-complexity sequence restructurings, including concatenation and complementation. For this reason, transducers have been incorporated into a number of data models and query languages for sequence databases <ref> [16, 20, 17, 29] </ref>. Unfortunately, like sequence concatenation, transducers tend to be both too powerful and too weak. As described in Section 1.1, query languages based on transducers are either highly expressive but unsafe, or safe but unexpressive. Our solution to this problem is to generalize the transducer model.
Reference: [18] <author> N. Goodman. </author> <title> Research issues in Genome databases. </title> <booktitle> Tutorial presented at PODS, </booktitle> <year> 1995. </year>
Reference-contexts: In addition, because genome-technology is rapidly evolving, new sequence operations are constantly needed, operations that cannot be anticipated in advance. Genome databases thus need to combine a declarative query language with arbitrary procedures for efficiently executing sequence operations <ref> [18] </ref>. Sequence data presents interesting challenges in the development of query languages. For instance, the query language should be expressive both in terms of pattern matching and sequence restructurings. At the same time, it should have a natural syntax and a clear semantics. Finally, it should be safe.
Reference: [19] <author> E. Graedel and M. Otto. </author> <title> Inductive definability with counting on finite structures. </title> <booktitle> In Proc. of Computer Science Logic, </booktitle> <pages> pages 231-247. </pages> <booktitle> Lecture Notes in Computer Science 702, </booktitle> <year> 1993. </year>
Reference-contexts: When restricted to relational structures, the tractable language is shown to be equivalent to first-order logic augmented with operators for counting and computing least fixpoints <ref> [19] </ref>. When restricted to lists, that is, to totally ordered structures, the language expresses exactly the class of ptime mappings over lists. In this paper, we explore a different approach to the problem, an approach based on logic programming, instead of functional programming.
Reference: [20] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In Thirteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'94), </booktitle> <pages> pages 303-312, </pages> <year> 1994. </year> <month> 38 </month>
Reference-contexts: Unfortunately, this safe sublanguage cannot express many queries for which the length of the result depends on the database. These include natural queries such as the reverse and the complement of a sequence. This problem is partially solved by the alignment logic of <ref> [20] </ref>, an elegant and expressive first-order logic for a relational model with sequences. The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of sequences. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [36]. 1.2 Overview of the Language This paper builds on the works of <ref> [16, 20, 27] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics. This language, called Sequence Datalog, is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over sequences. <p> Note that for each sequence of length k over , there are at most k (k+1) 2 + 1 different contiguous subsequences (including the empty sequence). For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. Databases, Queries and Functions: As in <ref> [16, 20] </ref>, we extend the relational model so that tuples can contain sequences of symbols, instead of just single symbols. Formally, a relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a tuple of relations over . <p> Transducers support a variety of low-complexity sequence restructurings, including concatenation and complementation. For this reason, transducers have been incorporated into a number of data models and query languages for sequence databases <ref> [16, 20, 17, 29] </ref>. Unfortunately, like sequence concatenation, transducers tend to be both too powerful and too weak. As described in Section 1.1, query languages based on transducers are either highly expressive but unsafe, or safe but unexpressive. Our solution to this problem is to generalize the transducer model.
Reference: [21] <author> S. Grumbach and T. Milo. </author> <title> Towards tractable algebras for bags. </title> <booktitle> In Twelfth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'93), </booktitle> <address> Washington, DC, </address> <pages> pages 49-58, </pages> <year> 1993. </year>
Reference-contexts: The language is then restricted to express exactly the class of ptime mappings over nested lists. A similar result is reported in [22], in which an algebra for partially ordered multi-sets (pom-sets) is defined. The algebra is obtained by extending the bag algebra of <ref> [21] </ref> with new operators to handle arbitrary pomsets, plus an iterator for performing structural recursion [11]. The authors define a tractable fragment of the language by restricting the class of structures allowed and introducing a form of bounded iterator to prevent exponential growth of query answers.
Reference: [22] <author> S. Grumbach and T. Milo. </author> <title> An algebra for POMSETS. </title> <booktitle> In Fifth International Conference on Data Base Theory, (ICDT'95), Prague, Lecture Notes in Computer Science, </booktitle> <pages> pages 191-207, </pages> <year> 1995. </year>
Reference-contexts: Appendix B establishes results on a class of "guarded" programs, results used in a number of expressibility proofs in the paper. 1.1 Background Sequence query languages have been recently investigated in the context of functional and algebraic programming <ref> [14, 22] </ref>, and some sophisticated and expressive languages have been proposed. Great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. <p> This mechanism ensures that query answers are finite. The language is then restricted to express exactly the class of ptime mappings over nested lists. A similar result is reported in <ref> [22] </ref>, in which an algebra for partially ordered multi-sets (pom-sets) is defined. The algebra is obtained by extending the bag algebra of [21] with new operators to handle arbitrary pomsets, plus an iterator for performing structural recursion [11]. <p> Both theorems are concerned with transducer networks that have a single input and a single output. Such networks compute a function from sequences to sequences. Theorem 5 first characterizes the sequence functions computable in polynomial time. (Other characterizations can be found in <ref> [14, 8, 22] </ref>.) Theorem 6 then characterizes the sequence functions computable in elementary time. In these theorems, and in the rest of the paper, we assume that the alphabet is finite, and that the domain of every sequence function is a (possibly infinite) subset of fl .
Reference: [23] <author> C. Hegelsen and P. R. Sibbald. </author> <title> PALM a pattern language for molecular biology. </title> <booktitle> In First Intern. Conference on Intelligent Systems for Molecular Biology, </booktitle> <pages> pages 172-180, </pages> <year> 1993. </year>
Reference-contexts: In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework. In other cases, (e:g: <ref> [23, 28] </ref>) query languages concentrate on pattern extraction capabilities and do not consider sequence restruc-turings. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence restructurings are equally important.
Reference: [24] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: To address this problem, we propose a new logic called Sequence Datalog for reasoning about sequences. Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical Logic Programming <ref> [24] </ref>. We show that Sequence Datalog can express all computable sequence functions. To achieve safety and finiteness, we introduce two devices. (i) We distinguish between structural recursion (which is safe) and constructive recursion (which is unsafe). <p> Moreover, if s 1 and s 2 are sequence terms, then s 1 = s 2 and s 1 6= s 2 are also atoms. From atoms, we build facts and clauses in the usual way <ref> [24] </ref>. Clauses are also referred to as rules. The head and body of a clause, fl, are denoted head (fl) and body (fl), respectively. A clause that contains a constructive term in its head is called a constructive clause. A Sequence Datalog program is a set of Sequence Datalog clauses. <p> As in classical logic programming <ref> [24] </ref>, each Sequence Datalog program, P , and database, db, has an associated "T-operator," T P;db , that maps Herbrand interpretations to Herbrand interpretations. Each application of T P;db may create new atoms, which may contain new sequences. <p> We also say that lfp (T P;db ) is the set of facts implied by program P and database db. We now show that the least fixpoint can be computed by a bottom-up iterative procedure, as in classical logic programming <ref> [24] </ref>. The first step is to show that T P;db is a continuous operator. <p> Thus 0 (head (fl)) 2 T P;db (I j ) by Definition 4. Thus ff 2 T P;db (I j ). Thus ff 2 S 2 Starting with the empty interpretation and applying T P;db repeatedly, we define the follow ing sequence of interpretations, in the usual way <ref> [24] </ref>: T P;db " 0 = f g T P;db " ! = i0 Intuitively, T P;db " ! is the set of atoms that can be derived by applying the operator T P;db some finite number of times (though some atoms may require more applications than others).
Reference: [25] <author> G. Mecca. </author> <title> From Datalog to Sequence Datalog: Languages and Techniques for Querying Sequence Databases. </title> <type> PhD thesis, </type> <institution> Universita di Roma "La Sapienza", Dipartimento di Informatica e Sistemistica, </institution> <year> 1996. </year> <note> http://poincare.inf.uniroma3.it:8080/~mecca. </note>
Reference-contexts: Each network then computes a mapping from sequence tuples to sequence tuples. When the network has only one output, the network computes a sequence function. This section presents basic results about the complexity of generalized transducer networks. For an expanded analysis see <ref> [25, 10] </ref>. The computational complexity of the sequence function computed by a transducer network depends on two parameters. The first is the diameter of the network, i:e:, the maximum length of a path in the network. <p> The theorems below characterize the complexity and expressibility of two classes of transducer networks, those of order 2 and 3, respectively. Higher order networks are investigated in <ref> [25, 10] </ref>. Our first results concern the output size of transducer networks. <p> We prove this result for programs of order k 3. In fact, we establish stronger results than mere finiteness. By considering programs of order 2 and order 3 separately, we establish tight bounds on the size of their minimal models. The proofs can be extended to higher-order programs <ref> [25, 10] </ref>. Definition 11 (Database Size) The size of a database (or a finite interpretation) is the number of sequences in its extended active domain. Theorem 8 below shows that for programs of order 2, the size of the minimal model is polynomial in the database size. <p> Proof: Follows immediately from Theorems 8 and 9, since a model is finite iff its extended active domain in finite. 2 Using a similar technique, Corollary 2 can be extended to higher-order Transducer Datalog programs <ref> [25, 10] </ref>. Thus, any safe program has a finite semantics. 8.2 Expressibility of Strongly Safe Programs Building on Theorems 8 and 9, this section establishes expressibility results for strongly safe programs.
Reference: [26] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: For instance, with one level of transducer subroutine calls, it can express any mapping from sequences to sequences computable in ptime. With two levels of subroutine calls, it can express any mapping from sequences to sequences in the elementary functions <ref> [26] </ref>. The rest of this section describes related work, and provides an introduction to Sequence Datalog and generalized transducers. Section 2 then defines preliminary notions, such as sequence database and sequence query, that are used throughout this paper. <p> The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of sequences. In its full version, alignment logic has the power of recursively enumerable sets <ref> [26] </ref>. A subset of the language called right restricted formulas is then developed. For this sublanguage, the safety problem is shown to be decidable, and complexity results related to the polynomial-time hierarchy are presented. Unfortunately, the nondeterministic nature of the computational model makes the evaluation of queries problematic. <p> Intuitively, the order of a network is the maximum depth of subtransducer nesting. We now establish a basic result about the complexity of acyclic networks. This result involves the elementary sequence functions <ref> [26] </ref>, which are defined in terms of the hyper-exponential functions, hyp i (n). These latter functions are defined recursively as follows: * hyp 0 (n) = n hyp i is called the hyper-exponential function of level i.
Reference: [27] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Eighteenth International Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: Another interesting proposal for the use of logic in querying sequences is <ref> [27] </ref>. In this case, temporal logic is used as the basis of a list query language. Conceptually, each successive position in a list is interpreted as a successive instance in time. This yields a query language in which temporal predicates are used to investigate the properties of lists. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [36]. 1.2 Overview of the Language This paper builds on the works of <ref> [16, 20, 27] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics. This language, called Sequence Datalog, is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over sequences.
Reference: [28] <author> D. B. </author> <title> Searls. String Variable Grammars: a logic grammar formalism for dna sequences. </title> <type> Technical report, </type> <institution> University of Pennsylvania, School of Medicine, </institution> <year> 1993. </year>
Reference-contexts: In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework. In other cases, (e:g: <ref> [23, 28] </ref>) query languages concentrate on pattern extraction capabilities and do not consider sequence restruc-turings. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence restructurings are equally important. <p> However, as Example 1.5 shows, constructive recursion can be unsafe, since by generating more-and-more new sequences, it can expand the active domain indefinitely, thus leading to an infinite least fixpoint. The next example provides another illustration of unsafe recursion. 1 Repetitive patterns are of great importance in Molecular Biology <ref> [28] </ref>. 5 Example 1.6 [Infinite Semantics] Suppose R is a unary relation containing a set of sequences. For each sequence, X , in R, we want the sequence obtained by repeating each symbol in X twice. For example, given the sequence abcd, we want the sequence aabbccdd. <p> Termination is therefore guaranteed for finite-length inputs. Unfortunately, ordinary transducers have very low complexity, essentially linear time. This means that they cannot perform complex operations, such as detecting context-free or context-sensitive languages, as it is often needed in genome databases <ref> [28] </ref>. We generalize this machine model by allowing one transducer to call other transducers, in the style of (non-recursive) subroutines. At each step, a generalized transducer can append a symbol 6 to its output or it can transform its output by invoking a sub-transducer.
Reference: [29] <author> D. Stott Parker, E. Simon, and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In Eighteenth International Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 115-126, </pages> <year> 1992. </year>
Reference-contexts: Specifically, we allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [16, 29, 17] </ref>, a transducer is defined as a machine with multiple input lines, one output line, and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> Transducers support a variety of low-complexity sequence restructurings, including concatenation and complementation. For this reason, transducers have been incorporated into a number of data models and query languages for sequence databases <ref> [16, 20, 17, 29] </ref>. Unfortunately, like sequence concatenation, transducers tend to be both too powerful and too weak. As described in Section 1.1, query languages based on transducers are either highly expressive but unsafe, or safe but unexpressive. Our solution to this problem is to generalize the transducer model. <p> Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes many of the transducer models proposed in the literature (see for example <ref> [16, 29] </ref>). Definition 7 (Generalized Transducers) A generalized m-input sequence transducer of order k &gt; 0 is a 4-tuple hK; q 0 ; ; ffii where: 1.
Reference: [30] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: 1 I 2 are two inter pretations, then T P;db (I 1 ) T P;db (I 2 ). 11 Proof: Follows immediately from Definition 4 and Lemma 1. 2 Because T P;db is a monotonic operator on a complete lattice, it has a least fixpoint, by the Knaster-Tarski Fixpoint Theorem <ref> [30] </ref>. That is, there is a unique minimal interpretation I such that I = T P;db (I). Let lfp (T P;db ) denote this minimal interpretation. We say that lfp (T P;db ) is the fixpoint semantics of program P over database db. <p> Because the operator is continuous, this process is complete, i:e:, any atom in the least fixpoint will eventually be derived. Formally, by the Knaster-Tarski Fixpoint Theorem <ref> [30] </ref>, lfp (T P;db ) = T P;db " ! This completes the fixpoint semantics of Sequence Datalog. An equivalent model theory is developed in Appendix A. 12 4 Expressive Power of Sequence Datalog This section studies the expressive power of Sequence Datalog programs.
Reference: [31] <author> The Committee for advanced DBMS functions. </author> <title> Third generation database systems manifesto. </title> <journal> ACM SIGMOD Record, </journal> <volume> 19(3) </volume> <pages> 31-44, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Sequences represent an important feature of Next Generation Database Systems <ref> [5, 31] </ref>. In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15].
Reference: [32] <author> S. Vandenberg and D. De Witt. </author> <title> Algebraic support for complex objects with arrays, identity and inheritance. </title> <booktitle> In ACM SIGMOD International Conf. on Management of Data, </booktitle> <pages> pages 158-167, </pages> <year> 1991. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [15]. These new applications have led to the introduction of sequence types in recent data models and query languages (e:g: <ref> [3, 6, 7, 32, 12] </ref>). In many cases, however, queries over sequences are described only by means of a set of pre-defined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [33] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Fourteenth ACM SIGACT Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1988. </year>
Reference-contexts: Given a sequence query Q, a database db, and a suitable encoding of db as a Turing machine tape, the data complexity of Q is the complexity of computing an encoding of Q (db), measured with respect to the size of db <ref> [33] </ref>. In relational databases, a query language is a set of formulas representing relational queries. This leads to the notions of data complexity and expressibility of query languages [1]. These ideas can be extended to sequence databases in a natural way.
Reference: [34] <author> X. Wang. </author> <title> Pattern matching by RS-operations: Towards a unified approach to querying sequence data. </title> <type> PhD thesis, </type> <institution> University of Southern California, </institution> <year> 1992. </year>
Reference-contexts: In other cases, both expressiveness and finiteness were achieved, but at the expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [16, 34] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [16] is then developed based on 2 the notion of rs-operations. Each rs-operation is either a merger or an extractor.
Reference: [35] <author> J. D. Watson et al. </author> <title> Molecular biology of the gene. </title> <publisher> Benjamin and Cummings Publ. Co., </publisher> <address> Menlo Park, CA, </address> <note> fourth edition, </note> <year> 1987. </year>
Reference-contexts: Likewise, the predicate protein seq (D; P ) means that D is a DNA sequence, and P is the corresponding protein sequence. 6 For simplicity, this example ignores biological complications such as intron splicing <ref> [35] </ref>, even though it can be encoded in Transducer Datalog without difficulty. 7 This grouping is analogous to the grouping of bits into bytes in computers. 8 For simplicity, this example ignores biological complications such as reading frames, ribosomal binding sites, and stop codons [35]. 26 Although the Transducer Datalog program <p> biological complications such as intron splicing <ref> [35] </ref>, even though it can be encoded in Transducer Datalog without difficulty. 7 This grouping is analogous to the grouping of bits into bytes in computers. 8 For simplicity, this example ignores biological complications such as reading frames, ribosomal binding sites, and stop codons [35]. 26 Although the Transducer Datalog program consists of only two rules, two features are worth noting: (i) all sequence restructurings performed by the program take place "inside" the transducers; and (ii) the program terminates for every database, since there is no recursion through construction of new sequences. 2 7.2 Equivalence
Reference: [36] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56, </volume> <year> 1983. </year> <month> 39 </month>
Reference-contexts: However, temporal logic cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence <ref> [36] </ref>. 1.2 Overview of the Language This paper builds on the works of [16, 20, 27] to propose a query language that is safe, expressive and has a clear declarative and operational semantics.
References-found: 36

