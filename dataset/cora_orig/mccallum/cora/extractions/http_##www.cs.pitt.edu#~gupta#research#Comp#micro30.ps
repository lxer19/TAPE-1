URL: http://www.cs.pitt.edu/~gupta/research/Comp/micro30.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/scheduling.html
Root-URL: 
Title: Resource-Sensitive Profile-Directed Data Flow Analysis for Code Optimization  
Author: Rajiv Gupta David A. Berson Jesse Z. Fang 
Address: Pittsburgh, PA 15260 Santa Clara, CA 95052  
Affiliation: Dept. of Computer Science Microcomputer Research Lab University of Pittsburgh Intel Corporation  
Abstract: Instruction schedulers employ code motion as a means of instruction reordering to enable scheduling of instructions at points where the resources required for their execution are available. In addition, driven by the profiling data, schedulers take advantage of predication and speculation for aggressive code motion across conditional branches. Optimization algorithms for partial dead code elimination (PDE) and partial redundancy elimination (PRE) employ code sinking and hoisting to enable optimization. However, unlike instruction scheduling, these optimization algorithms are unaware of resource availability and are incapable of exploiting profiling information, speculation, and predication. In this paper we develop data flow algorithms for performing the above optimizations with the following characteristics: (i) opportunities for PRE and PDE enabled by hoisting and sinking are exploited; (ii) hoisting and sinking of a code statement is driven by availability of functional unit resources; (iii) predication and speculation is incorporated to allow aggressive hoisting and sinking; and (iv) path profile information guides predication and speculation to enable optimization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ball and J. Larus, </author> <title> "Efficient Path Profiling," </title> <booktitle> 29th Annual IEEE/ACM International Symposium on Mi-croarchitecture, </booktitle> <address> Paris, France, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: Instruction schedulers for modern processor architectures exploit speculation [18] and predication [13, 14] during hoisting and sinking. In this paper we present solutions to the above problems by developing data flow analysis techniques for PRE and PDE that incorporate both resource availability and path profiling <ref> [1] </ref> information. Furthermore, the formulations of hoisting and sinking are generalized to incorporate speculation based hoisting and predication enabled sinking. <p> Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms [16, 17, 21, 5, 15] through speculative hoisting and predication enabled sinking. Finally, path profiling <ref> [1] </ref> information is used to guide speculation and predication. In particular, speculation and predication is applied only if their overall benefit in form of increased code optimization along frequently executed program paths is greater than their cost in terms of introducing additional instructions along infrequently executed program paths. <p> Frequently executed paths are optimized to a greater degree at the expense of infrequently executed paths. Path profiling information is used to evaluate the benefits and costs of speculation and predication to program paths. In the subsequent sections we describe code hoisting and sinking frameworks which use path profiling <ref> [1] </ref> information to enable speculation and predication based hoisting and sinking while inhibiting hoisting and sinking using resource availability and anticipata-bility information.
Reference: [2] <author> R. Bodik and R. Gupta, </author> <title> "Partial Dead Code Elimination using Slicing Transformations," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference: [3] <author> R. Bodik and R. Gupta, </author> <title> "Array Data-Flow Analysis for Load-Store Optimizations in Superscalar Architectures," </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol. 24, No. 6, </volume> <pages> pages 481-512, </pages> <year> 1996. </year>
Reference-contexts: The techniques we have described can also be adapted for application to other optimizations such as elimination of partially redundant loads and partially dead stores from loops <ref> [3, 8] </ref>. We are extending our algorithms to consider register pressure during optimization. Number Number of Functions of Paths 100% 95% 80% 1-5 1694 2022 2304 11-50 225 257 109 101-1000 35 10 1 % Total Max. # Exe. Time of Paths 100 1000 80 103 Integer Benchmarks.
Reference: [4] <author> P.P. Chang, S.A. Mahlke, and W-M. Hwu, </author> <title> "Using Profile Information to Assist Classic Code Optimization," </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. 21, No. 12, </volume> <pages> pages 1301-1321, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. y Supported in part by NSF PYI Award CCR-9157371, NSF grant CCR-9402226, Intel Corporation, and Hewlett Packard. <ref> [16, 6, 4, 20] </ref> and partial redundancy elimination (PRE) [17] solve a series of data flow problems to carry out sinking of assignments and hoisting of expression evaluations. The sinking of an assignment eliminates executions of the assignment that compute values that are dead, i.e., values that are never used.
Reference: [5] <author> D.M. Dhamdhere, </author> <title> "Practical Adaptation of Global Optimization Algorithm of Morel and Renvoise," </title> <journal> ACM Trans. on Prog. Languages, </journal> <volume> 13(2) </volume> <pages> 291-294, </pages> <year> 1991. </year>
Reference-contexts: Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms <ref> [16, 17, 21, 5, 15] </ref> through speculative hoisting and predication enabled sinking. Finally, path profiling [1] information is used to guide speculation and predication.
Reference: [6] <author> K. Ebcioglu, R.D. Groves, K-C. Kim, C. Silberman, and L. Ziv, </author> <title> "VLIW Compilation Techniques in a Superscalar Environment," </title> <booktitle> Proc. of Sigplan Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 36-48, </pages> <year> 1994. </year>
Reference-contexts: Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. y Supported in part by NSF PYI Award CCR-9157371, NSF grant CCR-9402226, Intel Corporation, and Hewlett Packard. <ref> [16, 6, 4, 20] </ref> and partial redundancy elimination (PRE) [17] solve a series of data flow problems to carry out sinking of assignments and hoisting of expression evaluations. The sinking of an assignment eliminates executions of the assignment that compute values that are dead, i.e., values that are never used.
Reference: [7] <author> J.A. Fisher, </author> <title> "Trace Scheduling: A Technique for Global Microcode Compaction," </title> <journal> IEEE Transactions on Computers, </journal> <volume> 30(7), </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: While generating code for VLIW and superscalar architectures, speculation and predication are routinely exploited to generate faster schedules along frequently executed paths at the expense of slower schedules along infrequently executed paths <ref> [7, 12, 11] </ref>. However, the optimization frameworks today are unable to exploit the same principle. In this section we show how to perform PRE and PDE optimizations by using speculation and predication. Frequently executed paths are optimized to a greater degree at the expense of infrequently executed paths.
Reference: [8] <author> R. Gupta, </author> <title> "Code Optimization as a Side Effect of Instruction Scheduling," </title> <booktitle> International Conference on High Performance Computing, </booktitle> <address> Bangalore, India, </address> <month> De-cember </month> <year> 1997. </year>
Reference-contexts: The techniques we have described can also be adapted for application to other optimizations such as elimination of partially redundant loads and partially dead stores from loops <ref> [3, 8] </ref>. We are extending our algorithms to consider register pressure during optimization. Number Number of Functions of Paths 100% 95% 80% 1-5 1694 2022 2304 11-50 225 257 109 101-1000 35 10 1 % Total Max. # Exe. Time of Paths 100 1000 80 103 Integer Benchmarks.
Reference: [9] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Path Profile Guided Partial Dead Code Elimination Using Predication," </title> <booktitle> International Conference on Parallel Architectures and Compilation Techniques, </booktitle> <address> San Francisco, California, </address> <month> Nevember </month> <year> 1997. </year>
Reference-contexts: Furthermore we present versions of our algorithms that apply to acyclic graphs. However, the extensions required to handle loops are straightforward and can be found in <ref> [10, 9] </ref>. Our algorithms are based upon the following analysis steps. First resource availability and anticipatabil-ity analysis is performed. Next we determine the cost and benefit of enabling speculation and predication at various spilt points and merge points in a flow graph respectively. <p> The second table shows the maximum number of paths considered among all the functions. Again this maximum value reduces sharply (from 1000 to 103) as the paths conisdered account for less than 100% of the program execution time. In <ref> [10, 9] </ref> we illustrate how the solution to cost-benefit analysis that we described earlier can be easily adapted to the situation in which only subset of paths with non-zero frequency are considered. 4 Concluding Remarks In this paper we presented a strategy for PRE and PDE code optimizations that results in
Reference: [10] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Path Profile Guided Partial Redundancy Elimination Using Speculation," </title> <type> Technical Report TR-97-13, </type> <institution> Dept. of Computer Science, University of Pittsburgh, </institution> <year> 1997. </year>
Reference-contexts: Furthermore we present versions of our algorithms that apply to acyclic graphs. However, the extensions required to handle loops are straightforward and can be found in <ref> [10, 9] </ref>. Our algorithms are based upon the following analysis steps. First resource availability and anticipatabil-ity analysis is performed. Next we determine the cost and benefit of enabling speculation and predication at various spilt points and merge points in a flow graph respectively. <p> The second table shows the maximum number of paths considered among all the functions. Again this maximum value reduces sharply (from 1000 to 103) as the paths conisdered account for less than 100% of the program execution time. In <ref> [10, 9] </ref> we illustrate how the solution to cost-benefit analysis that we described earlier can be easily adapted to the situation in which only subset of paths with non-zero frequency are considered. 4 Concluding Remarks In this paper we presented a strategy for PRE and PDE code optimizations that results in
Reference: [11] <author> R. Gupta and M.L. Soffa, </author> <title> "Region Scheduling: An Approach for Detecting and Redistributing Parallelism," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 421-431, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: While generating code for VLIW and superscalar architectures, speculation and predication are routinely exploited to generate faster schedules along frequently executed paths at the expense of slower schedules along infrequently executed paths <ref> [7, 12, 11] </ref>. However, the optimization frameworks today are unable to exploit the same principle. In this section we show how to perform PRE and PDE optimizations by using speculation and predication. Frequently executed paths are optimized to a greater degree at the expense of infrequently executed paths.
Reference: [12] <author> W.W. Hwu, S.A. Mahlke, W.Y. Chen, P.P. Chang, N.J. Warter, R.A. Bringmann, R.G. Ouellette, R.E. Hank, T. Kiyohara, G.E. Haab, J.G. Holm, </author> <title> and D.M. Lavery, "The Superblock: An Effective Technique for VLIW and Superscalar Compilation," </title> <journal> Journal of Supercomputing, </journal> <volume> Vol. A, </volume> <pages> pages 229-248, </pages> <year> 1993. </year>
Reference-contexts: While generating code for VLIW and superscalar architectures, speculation and predication are routinely exploited to generate faster schedules along frequently executed paths at the expense of slower schedules along infrequently executed paths <ref> [7, 12, 11] </ref>. However, the optimization frameworks today are unable to exploit the same principle. In this section we show how to perform PRE and PDE optimizations by using speculation and predication. Frequently executed paths are optimized to a greater degree at the expense of infrequently executed paths.
Reference: [13] <author> P. Hsu and E. Davidson, </author> <title> "Highly Concurrent Scalar Processing," </title> <booktitle> Proc. of 13th Annual International Symp. on Computer Architecture, </booktitle> <pages> pages 386-395, </pages> <year> 1986. </year>
Reference-contexts: Instruction schedulers on the other hand use profiling infor mation to drive code hoisting and sinking. * The data flow analyses do not incorporate speculation and predication to enable code hoisting and sinking. Instruction schedulers for modern processor architectures exploit speculation [18] and predication <ref> [13, 14] </ref> during hoisting and sinking. In this paper we present solutions to the above problems by developing data flow analysis techniques for PRE and PDE that incorporate both resource availability and path profiling [1] information.
Reference: [14] <author> V. Kathail, M. Schlansker, and B.R. Rau, </author> <title> "HPL Play--Doh Architecture Specification: Version 1.0," </title> <type> Technical Report HPL-93-80, </type> <institution> Computer Systems Laboratory, HP Labs, </institution> <address> Palo Alto, CA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: Instruction schedulers on the other hand use profiling infor mation to drive code hoisting and sinking. * The data flow analyses do not incorporate speculation and predication to enable code hoisting and sinking. Instruction schedulers for modern processor architectures exploit speculation [18] and predication <ref> [13, 14] </ref> during hoisting and sinking. In this paper we present solutions to the above problems by developing data flow analysis techniques for PRE and PDE that incorporate both resource availability and path profiling [1] information.
Reference: [15] <author> E. Morel and C. </author> <title> Renvoise, "Global Optimization by Suppression of Partial Redundancies," </title> <journal> Communications of the ACM, </journal> <volume> 22(2) </volume> <pages> 96-103, </pages> <year> 1979. </year>
Reference-contexts: Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms <ref> [16, 17, 21, 5, 15] </ref> through speculative hoisting and predication enabled sinking. Finally, path profiling [1] information is used to guide speculation and predication.
Reference: [16] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Partial Dead Code Elimination," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 147-158, </pages> <year> 1994. </year>
Reference-contexts: Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. y Supported in part by NSF PYI Award CCR-9157371, NSF grant CCR-9402226, Intel Corporation, and Hewlett Packard. <ref> [16, 6, 4, 20] </ref> and partial redundancy elimination (PRE) [17] solve a series of data flow problems to carry out sinking of assignments and hoisting of expression evaluations. The sinking of an assignment eliminates executions of the assignment that compute values that are dead, i.e., values that are never used. <p> Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms <ref> [16, 17, 21, 5, 15] </ref> through speculative hoisting and predication enabled sinking. Finally, path profiling [1] information is used to guide speculation and predication. <p> It also performs speculative code hoisting whenever it is useful. The remainder of this paper is organized as follows. In section 2 we first present extensions to PDE and PRE solutions developed by Knoop et al. <ref> [16, 17] </ref> to achieve resource sensitive PDE and PRE. In section 3 we present extensions to resource sensitive PDE and PRE algorithms that incorporate path profiling information to drive speculation and predication. <p> s (n) = V m2Succ (n) NRANT s (m) NRANT s (n) = FREE s (n) _ DEAD s (n)_ (XRANT s (n) ^ PRES s (n)) Assignment Sinking The assignment sinking and PDE framework that we use next is an extension of the framework developed by Knoop et al. <ref> [16] </ref>. PDE is performed in the following steps: assignment sinking followed by assignment elimination. The first step is modified to incorporate resource anticipatability information while the second step remains unchanged. Assignment sinking consists of delayability analysis followed by identification of insertion points for the statement being moved. <p> In the subsequent sections we describe code hoisting and sinking frameworks which use path profiling [1] information to enable speculation and predication based hoisting and sinking while inhibiting hoisting and sinking using resource availability and anticipata-bility information. This results in optimization algorithms that are more aggressive than traditional algorithms <ref> [16, 17] </ref> while at the same time more appropriate for VLIW and superscalar environment as they are resource sensitive and can trade-off the quality of code for frequently executed paths with that of infrequently executed paths. <p> By selectively enabling hoisting and sinking at program points based upon cost-benefit analysis, we exploit optimization opportunities that the traditional algorithms such as those by Knoop et al. <ref> [16, 17] </ref> do not exploit while inhibiting optimization opportunities that result in movement of code to program points at which the resource required for an instructions execution is not free. 3.1 Path Profile Directed PDE As mentioned earlier, the resource anticipatability analysis described in section 2.1 remains unchanged and must be
Reference: [17] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Lazy Code Motion," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 224-234, </pages> <year> 1992. </year>
Reference-contexts: Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. y Supported in part by NSF PYI Award CCR-9157371, NSF grant CCR-9402226, Intel Corporation, and Hewlett Packard. [16, 6, 4, 20] and partial redundancy elimination (PRE) <ref> [17] </ref> solve a series of data flow problems to carry out sinking of assignments and hoisting of expression evaluations. The sinking of an assignment eliminates executions of the assignment that compute values that are dead, i.e., values that are never used. <p> Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms <ref> [16, 17, 21, 5, 15] </ref> through speculative hoisting and predication enabled sinking. Finally, path profiling [1] information is used to guide speculation and predication. <p> It also performs speculative code hoisting whenever it is useful. The remainder of this paper is organized as follows. In section 2 we first present extensions to PDE and PRE solutions developed by Knoop et al. <ref> [16, 17] </ref> to achieve resource sensitive PDE and PRE. In section 3 we present extensions to resource sensitive PDE and PRE algorithms that incorporate path profiling information to drive speculation and predication. <p> = V m2Pred (n) XRAVL e (m) XRAVL e (n) = (NRAVL e (n) ^ PRES e (n)) _USED e (n) _ FREE e (n) Expression Hoisting The expression hoisting and PRE framework that we use next is a modification of the code motion framework developed by Knoop et al. <ref> [17] </ref>. PRE is performed in two steps: down-safety analysis which determines the points to which expression evaluations can be hoisted and earliestness analysis which locates the earliest points at which expression evaluations are actually placed to achieve PRE. These steps are modified to incorporate resource availability information. <p> In the subsequent sections we describe code hoisting and sinking frameworks which use path profiling [1] information to enable speculation and predication based hoisting and sinking while inhibiting hoisting and sinking using resource availability and anticipata-bility information. This results in optimization algorithms that are more aggressive than traditional algorithms <ref> [16, 17] </ref> while at the same time more appropriate for VLIW and superscalar environment as they are resource sensitive and can trade-off the quality of code for frequently executed paths with that of infrequently executed paths. <p> By selectively enabling hoisting and sinking at program points based upon cost-benefit analysis, we exploit optimization opportunities that the traditional algorithms such as those by Knoop et al. <ref> [16, 17] </ref> do not exploit while inhibiting optimization opportunities that result in movement of code to program points at which the resource required for an instructions execution is not free. 3.1 Path Profile Directed PDE As mentioned earlier, the resource anticipatability analysis described in section 2.1 remains unchanged and must be
Reference: [18] <author> S.A. Mahlke, W.Y. Chen, R.A. Bringmann, R.E. Hank, W.W. Hwu, B. Rau, and M. Schlansker, </author> <title> "Sentinel Scheduling for VLIW and Superscalar Processors," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(4) </volume> <pages> 376-408, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Instruction schedulers on the other hand use profiling infor mation to drive code hoisting and sinking. * The data flow analyses do not incorporate speculation and predication to enable code hoisting and sinking. Instruction schedulers for modern processor architectures exploit speculation <ref> [18] </ref> and predication [13, 14] during hoisting and sinking. In this paper we present solutions to the above problems by developing data flow analysis techniques for PRE and PDE that incorporate both resource availability and path profiling [1] information.
Reference: [19] <author> G. Ramalingam, </author> <title> "Data Flow Frequency Analysis," </title> <booktitle> ACM SIGPLAN Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 267-277, </pages> <year> 1996. </year>
Reference-contexts: Although the tech niques we describe are based upon path profiling in-formation they can also be adapted for edge profiles since estimates of path profiles can be computed from edge profiles <ref> [19] </ref>. Furthermore we present versions of our algorithms that apply to acyclic graphs. However, the extensions required to handle loops are straightforward and can be found in [10, 9]. Our algorithms are based upon the following analysis steps. First resource availability and anticipatabil-ity analysis is performed.
Reference: [20] <author> M.S. Schlansker and V. Kathail, </author> <title> "Critical Path Reduction for Scalar Processors," </title> <booktitle> 28th Annual IEEE/ACM International Symposium on Microarchi-tecture, </booktitle> <address> Ann Arbor, Michigan, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. y Supported in part by NSF PYI Award CCR-9157371, NSF grant CCR-9402226, Intel Corporation, and Hewlett Packard. <ref> [16, 6, 4, 20] </ref> and partial redundancy elimination (PRE) [17] solve a series of data flow problems to carry out sinking of assignments and hoisting of expression evaluations. The sinking of an assignment eliminates executions of the assignment that compute values that are dead, i.e., values that are never used.
Reference: [21] <author> B. Steffen, </author> <title> "Data Flow Analysis as Model Checking," </title> <booktitle> Proceedings TACS'91, Sendai, </booktitle> <address> Japan, </address> <publisher> Springer-Verlag, LNCS 526, </publisher> <pages> pages 346-364, </pages> <year> 1991. </year>
Reference-contexts: Moreover we are able to perform code motion more freely than existing PDE and PRE algorithms <ref> [16, 17, 21, 5, 15] </ref> through speculative hoisting and predication enabled sinking. Finally, path profiling [1] information is used to guide speculation and predication.
References-found: 21

