URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-035-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Title: Process Centered Software Development on Mobile Hosts  
Author: Peter D. Skopp 
Degree: MS Thesis Proposal  
Note: c fl1993 Peter D. Skopp  
Date: October 11, 1993  
Address: 500 West 120th St. New York, N.Y. 10027  
Affiliation: Department of Computer Science Columbia University  
Pubnum: CUCS-035-93  
Abstract: Software Development Environments have traditionally relied upon a central project database and file repository, accessible to a programmer's workstation via a high speed local area network connection. The introduction of powerful mobile computers has demonstrated the need for a new model, which allows for variable bandwidth machines as well as transient network connectivity to assist programmers in product development. A new client-server model is introduced which minimizes network traffic when bandwidth is limited. To support disconnected operation, I propose a process-based checkout model by which process information and product files that may be needed during a planned period of dis-connectivity are pre-fetched with minimal user effort. Rather than selecting each file by hand, which is tedious and error-prone, the user only informs the environment of the portion of the software development process intended to be executed while disconnected. The environment is then responsible for pre-fetching the necessary files. It is hoped that these research efforts will enable programmers to continue working on a project without continuous high speed network access. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Evan W. Adams, Masahiro Honda, and Terrence C. Miller. </author> <title> Object Management in a CASE Environment. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 154-163, </pages> <address> Pittsburgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: and by using the more powerful Laputa client, a user will be able to take advantage of mobile computers, and continue to do productive work on a project in any location, regardless of network connectivity. 4 Related Work Disconnected operation could have been achieved in the Sun Network Software Environment <ref> [1] </ref>. A user would select a software component to check out, and all of its constituent files were "acquired". The user was then able to work independently on the files in the component. Other users were free to "acquire" the same software component, increasing parallelism.
Reference: [2] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Concurrency Control in Advanced Database Applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Numerous other SDEs employ some form of checkout model for concurrency control <ref> [2] </ref>, but I know of none that either exploits the software process to assist in the selection of files to be checked out, or that permits disconnected operation. <p> These locks would be maintained persistently until later reconnection and 16 "checkin". But a more flexible approach is desirable for some software engineering applications <ref> [2] </ref>. Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concurrency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis [3, 7].
Reference: [3] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An Architecture for Multi-User Software Development Environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: The Marvel client is also responsible for invocation of external tools. The clients are coordinated by a server that incorporates the process engine, objectbase and the shared file repository <ref> [3] </ref>. The standard client/server protocol is for the client to display the repository in graphical format, and the user selects from a task menu and provides the desired arguments. The client then transmits this information to the server for any needed backward chaining. <p> By not burden-ing the server with activity invocation, as well as the added load a machine incurs from performing an activity, the server was able to operate more rapidly <ref> [3] </ref>. By distributing its computing load to client hosts, the overall power of the system was increased. 5.2 Proxy Client When attempting to operate a Marvel client over a low speed network connection, the current location of the Activity Manager is a great hindrance to performance. <p> Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concurrency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis <ref> [3, 7] </ref>. Locks in Marvel are applied to an object in the objectbase, rather than directly on the files associated with an object. These facilities are exploited to support the Laputa disconnected client. Laputa introduces a new set of persistent locks to Marvel's objectbase.
Reference: [4] <author> David Cornelius. XRemote: </author> <title> A Serial Line Protocol for X. </title> <booktitle> In 6th Annual X Technical Conference, </booktitle> <month> January </month> <year> 1992. </year> <month> 21 </month>
Reference-contexts: Low bandwidth serial line protocols such as SLIP and PPP are inadequate for maintaining a sophisticated display or transferring large files for local tool manipulation. X11 based protocols such as XRemote <ref> [4] </ref> and LBX [5] will maintain higher X11 throughput via a low bandwidth connection established between a pair of modems, but may still be too slow for interactive usage.
Reference: [5] <author> Jim Fulton and Chris Kent Kantarjiev. </author> <title> An Update on Low Bandwidth X (LBX), A Standard for X and Serial Lines. </title> <type> Technical Report P93-00001, </type> <institution> Xerox Palo Alto Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Low bandwidth serial line protocols such as SLIP and PPP are inadequate for maintaining a sophisticated display or transferring large files for local tool manipulation. X11 based protocols such as XRemote [4] and LBX <ref> [5] </ref> will maintain higher X11 throughput via a low bandwidth connection established between a pair of modems, but may still be too slow for interactive usage. <p> Furthermore, even if the X11 protocol generated from the user interface were to be compressed via LBX <ref> [5] </ref>, it would still use a greater amount of network bandwidth to operate than the proposed low bandwidth client needs. 6 Disconnected Operation Even with an efficient low bandwidth client, we would often like to work on a project in a completely disconnected mode.
Reference: [6] <author> J. S. Heideman, T. T. Page, R. G. Guy, and G. J. Popek. </author> <title> Primarily Disconnected Operation: Experiences with Ficus. </title> <booktitle> In Second Workshop on Management of Replicated Data. IEEE, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: Considerable research in disconnected file systems achieved through file pre-fetching has been done, but systems such as Ficus <ref> [6] </ref>, Coda [12] and Tait's "File System for Mobile Computing" [16] were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. Files were selected for pre-fetching either by explicit user selection, or by analyzing prior file access patterns.
Reference: [7] <author> George T. Heineman. </author> <title> A Transaction Manager Component for Cooperative Transaction Models. </title> <type> Technical Report CUCS-017-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concurrency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis <ref> [3, 7] </ref>. Locks in Marvel are applied to an object in the objectbase, rather than directly on the files associated with an object. These facilities are exploited to support the Laputa disconnected client. Laputa introduces a new set of persistent locks to Marvel's objectbase.
Reference: [8] <author> George T. Heineman, Gail E. Kaiser, Naser S. Barghouti, and Israel Z. Ben-Shaul. </author> <title> Rule chaining in marvel: Dynamic binding of parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Marvel objects map to a file repository, and each object corresponds to a directory containing file attributes. An instance of Marvel represents its process internally by a rule network, whose links indicate possible forward and backward chains between rules related by a common predicate <ref> [8] </ref>. When a user requests to execute a particular software engineering task, Marvel employs the network to enforce and automate the subprocess involving the rule corresponding to that task.
Reference: [9] <author> Gail E. Kaiser, Peter H. Feiler, and Steven S. Popovich. </author> <title> Intelligent Assistance for Software Development and Maintenance. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Marvel is a process centered software development environment in which the process is defined by a set of condition/activity/effects rules <ref> [9] </ref>. Marvel is constructed around an object oriented database (objectbase) which maintains persistent information about a process state. Marvel objects map to a file repository, and each object corresponds to a directory containing file attributes.
Reference: [10] <author> Gail E. Kaiser, Steven S. Popovich, and Israel Z. Ben-Shaul. </author> <title> A Bi-Level Language for Software Process Modeling. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 132-143, </pages> <address> Baltimore MD, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Process-based selection addresses the problems encountered with manual and heuristic selection. However, the process-based approach is not as simple as it sounds. Practical industrial-scale processes are complex, with numerous opportunities for choice or iteration <ref> [10] </ref>. Since each rule may have conditions which lead to backward chaining and effects which lead to forward chaining, we can construct a graph of a portion of the process, showing the relationships amongst specific rules.
Reference: [11] <author> Won Kim, Nat Ballou, Jorge F. Garz, and Darrell Woelk. </author> <title> A Distributed Object-Oriented Database System Supporting Shared and Private Databases. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 9(1) </volume> <pages> 31-51, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The obvious approach to concur-rency control in this context would be the "checkout" model found in most version control tools and some modern database systems (e.g., <ref> [14, 11] </ref>). In this model, each pre-fetched file would be locked in either a read only or writable mode, depending on whether the file is only needed for reading or possibly may be updated during the disconnected process fragment.
Reference: [12] <author> J. J. Kistler and M. Satyanarayanan. </author> <title> Disconnected Operation in the Coda File System. </title> <booktitle> In Proc. Thirteenth ACM Symp. on Operating System Principles, </booktitle> <pages> pages 213-225. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Considerable research in disconnected file systems achieved through file pre-fetching has been done, but systems such as Ficus [6], Coda <ref> [12] </ref> and Tait's "File System for Mobile Computing" [16] were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. Files were selected for pre-fetching either by explicit user selection, or by analyzing prior file access patterns.
Reference: [13] <author> Marcus J. Ranum. </author> <title> A network firewall. </title> <booktitle> In World Conference on Systems Management and Security, </booktitle> <year> 1992. </year>
Reference-contexts: Although wireless computing promises to give mobile computers network access regardless of location, this service will not come for free. Many companies also "firewall" their networks as a security measure, making it impossible to connect to the network <ref> [13] </ref>. In these companies, disconnected operation is the only viable option for employees who are not on-site. Since disconnected operation in Laputa is not viewed as a failure case, an alternative client will manage the explicit disconnection from the network and disconnected development.
Reference: [14] <author> M. J. Rochkind. </author> <title> The Source Code Control System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1:364-370, </volume> <booktitle> 1975. [15] 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <address> Berlin, Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The obvious approach to concur-rency control in this context would be the "checkout" model found in most version control tools and some modern database systems (e.g., <ref> [14, 11] </ref>). In this model, each pre-fetched file would be locked in either a read only or writable mode, depending on whether the file is only needed for reading or possibly may be updated during the disconnected process fragment.
Reference: [16] <author> Carl D. Tait and Dan Duchamp. </author> <title> Detection and Exploitation of File Working Sets. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year> <month> 22 </month>
Reference-contexts: Considerable research in disconnected file systems achieved through file pre-fetching has been done, but systems such as Ficus [6], Coda [12] and Tait's "File System for Mobile Computing" <ref> [16] </ref> were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. Files were selected for pre-fetching either by explicit user selection, or by analyzing prior file access patterns.
References-found: 15

