URL: http://www.daimi.aau.dk/~andrzej/papers/RfI.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Title: Recursion from Iteration  
Author: ANDRZEJ FILINSKI 
Keyword: continuations, recursion, iteration, definability, uniformity.  
Address: Pittsburgh, PA 15213-3891  
Affiliation: School of Computer Science, Carnegie Mellon University,  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal,  c 1994 Kluwer Academic Publishers Manufactured in The Netherlands  
Email: (andrzej+@cs.cmu.edu)  
Date: 7, 11-38, 1994  
Abstract: In a simply-typed, call-by-value (CBV) language with first-class continuations, the usual CBV fixpoint operator can be defined in terms of a simple, infinitely-looping iteration primitive. We first consider a natural but flawed definition, based on exceptions and "iterative deepening" of finite unfoldings, and point out some of its shortcomings. Then we present the proper construction using full first-class continuations, with both an informal derivation and a proof that the behavior of the defined operator faithfully mimics a "built-in" recursion primitive. In fact, given an additional uniformity assumption, the construction is a two-sided inverse of the usual definition of iteration from recursion. Continuing, we show that the CBV looping primitive is in fact the direct-style equivalent of a continuation-passing-style fixpoint, and that this correspondence extends all the way to traditional definitions of these operators in terms of reflexive types. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> Clinger, W. and Rees, J. </editor> <title> Revised 4 report on the algorithmic language Scheme. Lisp Pointers, </title> <type> 4, </type> <month> 3 (July </month> <year> 1991) </year> <month> 1-55. </month>
Reference-contexts: An outline of the categorical approach is sketched in section 5. In many functional programming languages, it is actually possible to write recursive functions without any "explicit" recursion. For example, the Scheme definition <ref> [1] </ref> expresses letrec in terms of set!. More fundamentally, the well-known Y-combinator provides a uniform way of introducing self-reference. <p> In particular, their denotational descriptions inherently involve reflexive domains. Consider for example the way recursion is expressed in the Scheme report <ref> [1] </ref> (essentially): fix F = let r = ref (x: fail) in (r := F (x: !r x); !r) RECURSION FROM ITERATION 33 (The j-redex around !r serves to delay evaluation until the correct value of r has been plugged in.) In such a language, where storable procedures can themselves access
Reference: 2. <author> Danvy, O. and Filinski, A. </author> <title> Representing control: A study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2, </volume> <month> 4 (December </month> <year> 1992) </year> <month> 361-391. </month>
Reference-contexts: The CPS version of the iteration equation then becomes, after some administrative simplifications (which can actually be built into the translation itself <ref> [2, 20] </ref>): loop c 0 f c = a: f c (a 0 : loop c 0 f c a 0 ) a 2fij = f c (loop c 0 f c ) I.e, loop satisfies the CBV iteration equation precisely when loop c 0 is a fixpoint combinator (with type
Reference: 3. <author> Danvy, O. and Lawall, J. L. </author> <title> Back to direct style II: First-class continuations. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, California (June 1992) 299-310. </address>
Reference-contexts: But why did we then need control operators to recover fix from loop? The reason is that in fix c 0 , the continuations are permuted in an "illegal" way, so that the term does not have a C-free direct-style counterpart <ref> [3] </ref>.
Reference: 4. <author> Duba, B. F., Harper, R., and MacQueen, D. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, Florida (Jan-uary 1991) 163-173. </address>
Reference-contexts: We will not pursue this view here, however, but adopt a self-contained presentation not directly tied to category theory or symmetry considerations. This will allow us to draw directly upon the substantial body of existing results about continuations, e.g., <ref> [4, 5, 9, 17] </ref> for reasoning about the construction. An outline of the categorical approach is sketched in section 5. In many functional programming languages, it is actually possible to write recursive functions without any "explicit" recursion. For example, the Scheme definition [1] expresses letrec in terms of set!. <p> And finally, we will use the notation :ff for the type of ff-accepting continuations. To a first approximation, readers familiar with the continuation facility in Standard ML of New Jersey <ref> [4] </ref> can simply read C as callcc, ignore * -abstractions, and read k * v as throw k v; Scheme programmers can read C RECURSION FROM ITERATION 15 as call=cc and ignore annotations of both abstractions and applications. <p> Continuations are captured with the operator callcc : (:ff ! ff) ! ff and invoked with throw : :ff ! ff ! fi. The example in the introduction would thus be written as: 2 + callcc (k: 3 + throw k 4) The details can be found in <ref> [4] </ref>; in the context of full ML, one must also worry about potential interactions with let-polymorphism [11]. <p> RECURSION FROM ITERATION 21 taken in Griffin's variant of Idealized Scheme [9] (which is actually much closer to ML than to Scheme; its only Scheme-inspired characteristic is the control operator), and it is the one we will be using in the following. 2 However, the two styles are essentially equivalent <ref> [4, 9] </ref>. In particular, we can define the SML/NJ operators as callcc = f: C ( * * throw = k: x: A (k * Conversely, given the SML/NJ primitives, we can define a C-operator. A slight problem is that ML does not have a predefined empty type 0.
Reference: 5. <author> Felleisen, M. and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103, </volume> <month> 2 </month> <year> (1992) </year> <month> 235-271. </month>
Reference-contexts: We will not pursue this view here, however, but adopt a self-contained presentation not directly tied to category theory or symmetry considerations. This will allow us to draw directly upon the substantial body of existing results about continuations, e.g., <ref> [4, 5, 9, 17] </ref> for reasoning about the construction. An outline of the categorical approach is sketched in section 5. In many functional programming languages, it is actually possible to write recursive functions without any "explicit" recursion. For example, the Scheme definition [1] expresses letrec in terms of set!. <p> RECURSION FROM ITERATION 23 Since the language we are using is a proper subset of Felleisen's untyped one, we can directly use the equational reasoning principles developed for the latter. In particular, we have the following rules taken from <ref> [5, 20] </ref>, with the addition of (A uniq ), which captures the property noted above about 0.
Reference: 6. <author> Felleisen, M., Friedman, D. P., Kohlbecker, E., and Duba, B. </author> <title> Reasoning with continuations. </title> <booktitle> In Proceedings of Symposium on Logic in Computer Science, IEEE, </booktitle> <address> Cambridge, Massachusetts (June 1986) 131-141. </address>
Reference-contexts: In general, we need an operator C such that an expression CM invokes the procedure M with a representation K of the evaluation context <ref> [6] </ref> surrounding CM . If M ever invokes K with a value V , the then current context of evaluation is abandoned, and control returns to the context represented by K, as if CM had just returned V . <p> For concreteness in the following, we will adopt Griffin's simply-typed formulation of first-class continuations [9], which uses essentially a typed variant of Felleisen's C-operator <ref> [6] </ref>; the actual choice is not critical, however. We will generally emphasize applications of continuations as k * Similarly, we will write * x: M for the syntactic representation of a continuation. And finally, we will use the notation :ff for the type of ff-accepting continuations. <p> In this setting, the details work out more smoothly if the control operator not only captures (a copy of) the surrounding evaluation context, but also removes it, so that it can only be resumed by an explicit application of the reified continuation <ref> [6] </ref>. Then the first-class continuation facility can be represented by a single operator C : ((ff ! 0) ! 0) ! ff. To apply a continuation in (i.e., to escape from) a context expecting a fi-typed result, we can use a second C to explicitly discard the inner context.
Reference: 7. <author> Filinski, A. </author> <title> Declarative continuations: An investigation of duality in programming language semantics. </title> <editor> In Pitt, D. H. et al., editors, </editor> <booktitle> Category Theory and Computer Science, </booktitle> <address> Manchester, UK (September 1989) 224-249. </address>
Reference-contexts: The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government. 12 FILINSKI terization of languages with first-class continuations <ref> [7] </ref> in terms of what could now be called "classically-typed" [9] categories. Specifically, one can interpret the difference between data-driven (or, call-by-value) and demand-driven (call-by-name) evaluation in such a language as an instance of a categorical symmetry principle called duality.
Reference: 8. <author> Greibach, S. </author> <title> Theory of Program Structures: Schemes, Semantics, Verification. </title> <booktitle> Lecture Notes in Computer Science 36 (1975). </booktitle>
Reference-contexts: Related work A fair amount is known about transforming recursive programs into iterative form, the so-called "flowchartability" problem. Most such work has been done in an explicitly procedural setting (e.g., <ref> [8] </ref>), or for first-order recursion equations [23]. However, some extensions to higher-order call-by-name functional programs are reported in [13]. Interestingly, the methods in the latter work rely heavily on a notion of contexts, but the author apparently never draws any connections to continuation-passing style, let alone first-class continuations.
Reference: 9. <author> Griffin, T. G. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California (January 1990) 47-58. </address>
Reference-contexts: The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government. 12 FILINSKI terization of languages with first-class continuations [7] in terms of what could now be called "classically-typed" <ref> [9] </ref> categories. Specifically, one can interpret the difference between data-driven (or, call-by-value) and demand-driven (call-by-name) evaluation in such a language as an instance of a categorical symmetry principle called duality. <p> We will not pursue this view here, however, but adopt a self-contained presentation not directly tied to category theory or symmetry considerations. This will allow us to draw directly upon the substantial body of existing results about continuations, e.g., <ref> [4, 5, 9, 17] </ref> for reasoning about the construction. An outline of the categorical approach is sketched in section 5. In many functional programming languages, it is actually possible to write recursive functions without any "explicit" recursion. For example, the Scheme definition [1] expresses letrec in terms of set!. <p> While potentially more complex to implement, such a facility exhibits a pleasant uniformity of behavior, which makes it superior in many ways to exceptions both for both theoretical and practical purposes. For concreteness in the following, we will adopt Griffin's simply-typed formulation of first-class continuations <ref> [9] </ref>, which uses essentially a typed variant of Felleisen's C-operator [6]; the actual choice is not critical, however. We will generally emphasize applications of continuations as k * Similarly, we will write * x: M for the syntactic representation of a continuation. <p> It can be proved (by CPS conversion back to the original case) that the latter property holds even if we extend the language with first-class continuations <ref> [9] </ref>. A similar argument works for exceptions not carrying values, or values of base type only (if we allow functional values, the domain of exceptions becomes self-referential). <p> k (3 + C ( d: k 4))) ! 6 (It is customary to abbreviate the idiom z: C ( * d: z) : 0 ! ff as A, usually pronounced "abort".) This approach to typed first-class continuations is RECURSION FROM ITERATION 21 taken in Griffin's variant of Idealized Scheme <ref> [9] </ref> (which is actually much closer to ML than to Scheme; its only Scheme-inspired characteristic is the control operator), and it is the one we will be using in the following. 2 However, the two styles are essentially equivalent [4, 9]. <p> RECURSION FROM ITERATION 21 taken in Griffin's variant of Idealized Scheme [9] (which is actually much closer to ML than to Scheme; its only Scheme-inspired characteristic is the control operator), and it is the one we will be using in the following. 2 However, the two styles are essentially equivalent <ref> [4, 9] </ref>. In particular, we can define the SML/NJ operators as callcc = f: C ( * * throw = k: x: A (k * Conversely, given the SML/NJ primitives, we can define a C-operator. A slight problem is that ML does not have a predefined empty type 0. <p> Consider now the CPS counterparts of loop and fix. We use essentially the usual CBV CPS translation [17], extended to typed C <ref> [9] </ref>, and written with continuations first for technical convenience (as in [20]). Also, when reasoning about CPS versions of terms, it becomes preferable to make :ff a separate type from the function space ff! 0 (and ensure that * -abstractions are only used with * -applications). <p> Another way of seeing this is that the type of the "loop-to-fixpoint transformer", loop2fix = loop: FIX (loop) : [(ff fi :fi ! ff fi :fi) ! :(ff fi :fi)] ! [((ff ! fi) ! ff ! fi) ! ff ! fi] is "classical" in the sense of <ref> [9] </ref>, while all pure lambda-terms have types that correspond to intuitionistically valid propositions.
Reference: 10. <author> Gunter, C. A. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> The MIT Press (1992). </publisher>
Reference-contexts: the value requirements), and unfold it a few times: fix F a = F (fix F ) a = F (F (fix F )) a = = F n (fix F ) a While we could clearly keep expanding the definition of fix ad infinitum, it can be shown (e.g., <ref> [10, 4.4] </ref>) that any finite computation needs only a fixed number of F 's. In other words, for every terminating program (closed term of base type) there exists an n such that if we replace fix F by F n (x: fail), the result is unchanged. <p> Both Plotkin's proof technique and others (e.g., taking advantage of typing to use logical relations) can be generalized to larger languages and different evaluation orders (see, e.g., <ref> [10] </ref> for examples and further references). In our proofs, we will be using Felleisen's extensions for modeling control operators. RECURSION FROM ITERATION 23 Since the language we are using is a proper subset of Felleisen's untyped one, we can directly use the equational reasoning principles developed for the latter. <p> And in fact, one can show that in the particular framework of CPO's and continuous functions, the uniformity condition is equivalent to finding least fixpoints <ref> [10, Thm. 4.18] </ref>. 26 FILINSKI Definition 2 We say that a CBV function h : ff ! fi is total if for every value a : ff, there exists a value b : fi such that h a = b.
Reference: 11. <author> Harper, R. and Lillibridge, M. </author> <title> Polymorphic type assignment and CPS conversion. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Continuations, </booktitle> <address> San Francisco, California (June 1992) 13-22. </address> <note> Revised version to appear in Lisp and Symbolic Computation (this issue). RECURSION FROM ITERATION 37 </note>
Reference-contexts: The example in the introduction would thus be written as: 2 + callcc (k: 3 + throw k 4) The details can be found in [4]; in the context of full ML, one must also worry about potential interactions with let-polymorphism <ref> [11] </ref>. The main pragmatic problem with this approach is that it is awkward to "prepend" an ordinary procedure f : ff ! fi to a continuation k : :fi and get a new continuation (k ffi f ) : :ff.
Reference: 12. <author> Hindley, J. R. and Seldin, J. P. </author> <title> Introduction to Combinators and - Calculus. Volume 1 of London Mathematical Society Student Texts, </title> <publisher> Cambridge University Press (1986). </publisher>
Reference-contexts: A more precise characterization of C will be given in section 3.1. 1.4. The problem A crucial property underlying the entire development presented here is that reduction in a simply-typed -calculus is strongly normalizing <ref> [12] </ref>, and in particular a CBV strategy is sufficient to reduce every closed term to a value. It can be proved (by CPS conversion back to the original case) that the latter property holds even if we extend the language with first-class continuations [9].
Reference: 13. <author> Kfoury, A. J. </author> <title> The Translation of Functional Programs into Tail-Recursive Form (Part I). </title> <type> BUCS Tech Report 87-003, </type> <institution> Computer Science Department, Boston University (January 1987). </institution>
Reference-contexts: Related work A fair amount is known about transforming recursive programs into iterative form, the so-called "flowchartability" problem. Most such work has been done in an explicitly procedural setting (e.g., [8]), or for first-order recursion equations [23]. However, some extensions to higher-order call-by-name functional programs are reported in <ref> [13] </ref>. Interestingly, the methods in the latter work rely heavily on a notion of contexts, but the author apparently never draws any connections to continuation-passing style, let alone first-class continuations.
Reference: 14. <author> Landin, P. J. </author> <title> A correspondence between ALGOL60 and Church's lambda notation. </title> <journal> Communications of the ACM, </journal> <note> 8 (1965) 89-101 and 158-165. </note>
Reference-contexts: Scheme has no direct counterpart, though an exception facility can be simulated using call=cc and set!. There are a number of essentially equivalent ways of introducing first-class continuations in a functional language, all tracing back to Reynolds's escape-operator [19] (or, less directly, to Landin's J-operator <ref> [14] </ref>). In general, we need an operator C such that an expression CM invokes the procedure M with a representation K of the evaluation context [6] surrounding CM .
Reference: 15. <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press (1990). </publisher>
Reference-contexts: A similar observation lets us construct fixpoints from exceptions carrying functional values. In a language with no computational effects other than named exceptions, there is a simple correspondence between exception names (expressions of type exn in SML <ref> [15] </ref>) and functions of type 1!0, because such a function must essentially have the form (): raise X for some exception expression X.
Reference: 16. <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, IEEE, </booktitle> <address> Pacific Grove, California (June 1989) 14-23. </address>
Reference-contexts: For example, Moggi's computational -calculus (a strict superset of Plotkin's v -calculus) is valid for CBV functional languages with a large variety of computational effects (state, nondeterminism, exceptions, continuations, etc.) <ref> [16] </ref>. The inherent modularity of the axiomatic approach makes feasible program-behavior theories of considerable scope and generality, e.g., [22].
Reference: 17. <author> Plotkin, G. D. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 1 </month> <year> (1975) </year> <month> 125-159. </month>
Reference-contexts: We will not pursue this view here, however, but adopt a self-contained presentation not directly tied to category theory or symmetry considerations. This will allow us to draw directly upon the substantial body of existing results about continuations, e.g., <ref> [4, 5, 9, 17] </ref> for reasoning about the construction. An outline of the categorical approach is sketched in section 5. In many functional programming languages, it is actually possible to write recursive functions without any "explicit" recursion. For example, the Scheme definition [1] expresses letrec in terms of set!. <p> An axiomatization of CBV -calculus equivalence with this property was developed by Plotkin <ref> [17] </ref>; while the theory itself is quite simple, the actual proof of the biimplication is non-trivial. (An alternative is to take the above as the declarative definition of evaluation; the challenge is then to develop an effective procedure for proving programs equal to values). <p> Consider now the CPS counterparts of loop and fix. We use essentially the usual CBV CPS translation <ref> [17] </ref>, extended to typed C [9], and written with continuations first for technical convenience (as in [20]).
Reference: 18. <author> Reynolds, J. C. </author> <title> Gedanken a simple typeless language based on the principle of completeness and the reference concept. </title> <journal> Communications of the ACM, </journal> <volume> 13, </volume> <month> 5 (May </month> <year> 1970) </year> <month> 308-319. </month>
Reference-contexts: It is perfectly possible, however, to consider such definitions in a simply-typed framework with explicit domain isomorphisms. This lets us analyze exactly what properties of our semantic domain we rely on to make the definition work. Consider the CBV Y-combinator <ref> [18] </ref>: Y F = [x: a: F (x x) a] [x: a: F (x x) a] This Y is untypable because x needs to have a type o which is itself of the form o ! .
Reference: 19. <author> Reynolds, J. C. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of 25th ACM National Conference, </booktitle> <address> Boston (August 1972) 717-740. </address>
Reference-contexts: Scheme has no direct counterpart, though an exception facility can be simulated using call=cc and set!. There are a number of essentially equivalent ways of introducing first-class continuations in a functional language, all tracing back to Reynolds's escape-operator <ref> [19] </ref> (or, less directly, to Landin's J-operator [14]). In general, we need an operator C such that an expression CM invokes the procedure M with a representation K of the evaluation context [6] surrounding CM . <p> A further simplification is made possible by the observation that there is no need to transform "trivial" (parts of) functions <ref> [19] </ref> into CPS.
Reference: 20. <author> Sabry, A. and Felleisen, M. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, California (June 1992) 288-298. </address> <note> Revised and extended version to appear in Lisp and Symbolic Computation (this issue). </note>
Reference-contexts: RECURSION FROM ITERATION 23 Since the language we are using is a proper subset of Felleisen's untyped one, we can directly use the equational reasoning principles developed for the latter. In particular, we have the following rules taken from <ref> [5, 20] </ref>, with the addition of (A uniq ), which captures the property noted above about 0. <p> Consider now the CPS counterparts of loop and fix. We use essentially the usual CBV CPS translation [17], extended to typed C [9], and written with continuations first for technical convenience (as in <ref> [20] </ref>). Also, when reasoning about CPS versions of terms, it becomes preferable to make :ff a separate type from the function space ff! 0 (and ensure that * -abstractions are only used with * -applications). <p> The CPS version of the iteration equation then becomes, after some administrative simplifications (which can actually be built into the translation itself <ref> [2, 20] </ref>): loop c 0 f c = a: f c (a 0 : loop c 0 f c a 0 ) a 2fij = f c (loop c 0 f c ) I.e, loop satisfies the CBV iteration equation precisely when loop c 0 is a fixpoint combinator (with type
Reference: 21. <author> Scott, D. S. </author> <title> Continuous lattices. </title> <booktitle> In Proceedings of 1971 Dalhousie Conference, </booktitle> <month> Springer-Verlag </month> <year> (1972) </year> <month> 97-136. </month>
Reference-contexts: This is the hallmark of a "reflexive" definition, which requires us to go from set-theoretic models to domain-theoretic ones to find a solution <ref> [21] </ref>. (In ML, we would use a parameterized datatype to define the recursive type sapp ff;fi : is the constructor; we get by pattern matching.) We can now write the Y-combinator as Y F = [s: a: F (s s) a] ( [s: a: F (s s) a]) What about loops?
Reference: 22. <author> Talcott, C. </author> <title> A theory for program and data type specification. </title> <journal> Theoretical Computer Science, </journal> <volume> 104, </volume> <month> 1 </month> <year> (1992) </year> <month> 129-159. </month>
Reference-contexts: For example, Moggi's computational -calculus (a strict superset of Plotkin's v -calculus) is valid for CBV functional languages with a large variety of computational effects (state, nondeterminism, exceptions, continuations, etc.) [16]. The inherent modularity of the axiomatic approach makes feasible program-behavior theories of considerable scope and generality, e.g., <ref> [22] </ref>. <p> term loop2fix (f: * * c) (g: g) has type ::fi ! fi and is in fact equal to C. (This does not mean, of course, that recursion cannot be implemented with a simple control stack: the particular pattern of continuation passing used here is essentially that of applicative coroutining <ref> [22] </ref> between the recursive computation and a purely iterative "controller" that needs no additional stack space). 4.2. Recursion and iteration from reflexive types Up to now, we have considered only a simply-typed language. In particular, this meant that well-known "non-recursive" definitions of recursion like the Y-combinator were not expressible.
Reference: 23. <author> Walker, S. A. and Strong, H. R. </author> <title> Characterizations of flowchartable recursions. </title> <journal> Journal of Computer and System Sciences, </journal> <month> 7 </month> <year> (1973) </year> <month> 404-447. </month>
Reference-contexts: Related work A fair amount is known about transforming recursive programs into iterative form, the so-called "flowchartability" problem. Most such work has been done in an explicitly procedural setting (e.g., [8]), or for first-order recursion equations <ref> [23] </ref>. However, some extensions to higher-order call-by-name functional programs are reported in [13]. Interestingly, the methods in the latter work rely heavily on a notion of contexts, but the author apparently never draws any connections to continuation-passing style, let alone first-class continuations.
References-found: 23

