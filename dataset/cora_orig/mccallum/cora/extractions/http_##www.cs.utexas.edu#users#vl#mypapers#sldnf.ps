URL: http://www.cs.utexas.edu/users/vl/mypapers/sldnf.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/papers.html
Root-URL: 
Email: vl@cs.utexas.edu  
Title: SLDNF, Constructive Negation and Grounding  
Author: Vladimir Lifschitz 
Address: Austin, TX 78712, USA  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: In some approaches to the declarative semantics of logic programming, a program is treated as shorthand for the propositional program Ground () whose rules are the ground instances of the rules of . We relate the success and failure of a program with a goal G under SLDNF with constructive negation to the success and failure of Ground () with ground instances of G under propositional SLDNF. As a corollary, we get a soundness theorem for SLDNF with constructive negation relative to the answer set semantics. Since this semantics is closely related to default logic and autoepistemic logic, proofs of such theorems help us understand why the computational mechanisms developed in logic programming provide partial implementations of these nonmonotonic formalisms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Krzysztof Apt and Ronald Bol. </author> <title> Logic programming and negation: a survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:9-71, </volume> <year> 1994. </year>
Reference-contexts: Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are <ref> [1] </ref>, [2], [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [2] <author> Krzysztof Apt and Kees Doets. </author> <title> A new definition of SLDNF-resolution. </title> <journal> Journal of Logic Programming, </journal> <volume> 18 </volume> <pages> 177-190, </pages> <year> 1994. </year>
Reference-contexts: Kunen defined the notion of a computed answer substitution and the notion of a failed query directly, without first introducing SLDNF derivation trees | quite complex combinatorial objects (as done, for instance, in Section 15 of [15] and in Section 2 of <ref> [2] </ref>). The closure conditions in Kunen's definition can be represented as inference rules. <p> Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], <ref> [2] </ref>, [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [3] <author> Nicole Bidoit and Christine Froidevaux. </author> <title> Minimalism subsumes default logic and circumscription. </title> <booktitle> In Proc. of LICS-87, </booktitle> <pages> pages 89-97, </pages> <year> 1987. </year>
Reference-contexts: As a corollary, we get a soundness theorem for SLDNF with constructive negation relative to the answer set ("stable model") semantics proposed by Gelfond and Lifschitz [11], [12]. The answer set semantics follows the ideas of <ref> [3] </ref> and [10], and treats a logic program essentially as a default theory in the sense of [18] or as an autoepistemic theory in the sense of [17].
Reference: [4] <author> Serenella Cerrito. </author> <title> A linear axiomatization of negation as failure. </title> <journal> Journal of Logic Programming, </journal> <volume> 12(1-2):1-24, </volume> <year> 1992. </year>
Reference-contexts: This work was partially supported by National Science Foundation under grant IRI-9306751. Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in <ref> [4] </ref>, [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [5] <author> David Chan. </author> <title> Constructive negation based on the completed database. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 111-125, </pages> <year> 1988. </year>
Reference-contexts: For instance, the first soundness theorem for the SLDNF query evaluation procedure expressed its soundness with the respect to the completion semantics [6]. An important paper on constructive negation is entitled Constructive Negation Based on the Completed Database <ref> [5] </ref>. In this note, we try to bridge these two directions in the theory of logic programming by developing a view of SLDNF and constructive negation that stresses the relationship between a schematic program and the corresponding propositional program Ground (). <p> SLD-CNF resolution, introduced by Chan <ref> [5] </ref>, uses both formulas of L = and computed answer substitutions.
Reference: [6] <author> Keith Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: The semantic idea that has had most influence on that work is the "nonpropositional" idea of predicate completion. For instance, the first soundness theorem for the SLDNF query evaluation procedure expressed its soundness with the respect to the completion semantics <ref> [6] </ref>. An important paper on constructive negation is entitled Constructive Negation Based on the Completed Database [5].
Reference: [7] <author> W lodzimierz Drabent. </author> <title> What is failure? An approach to constructive negation. </title> <journal> Acta Informatica, </journal> <volume> 32(1) </volume> <pages> 27-59, </pages> <year> 1995. </year>
Reference-contexts: can be written as follows: =j false (F P c ) j= true =j x 6= b; q (x) (SN c ) (SP c ) With derivations written in this format, the calculus from Section 4.1 seems to be particularly close to the methods of handling constructive negation proposed in <ref> [7] </ref>. SLD-CNF resolution, introduced by Chan [5], uses both formulas of L = and computed answer substitutions.
Reference: [8] <author> Melvin Fitting. </author> <title> First-order logic and automated theorem proving. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: For the definitions related to the notion of a substitution, see <ref> [8] </ref>, Sections 5.2 and 7.2. 4. A substitution is invertible if there is a substitution 1 such that both 1 and 1 equal the identity substitution *. 5. This qualification is needed in view of the fact that most Prolog systems omit the occurs check from the unification algorithm. 6.
Reference: [9] <author> Dov Gabbay and Marek Sergot. </author> <title> Negation as inconsistency. </title> <journal> Journal of Logic Programming, </journal> <volume> 3(1) </volume> <pages> 1-36, </pages> <year> 1986. </year>
Reference-contexts: Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], <ref> [9] </ref>, [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [10] <author> Michael Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 207-211, </pages> <year> 1987. </year>
Reference-contexts: As a corollary, we get a soundness theorem for SLDNF with constructive negation relative to the answer set ("stable model") semantics proposed by Gelfond and Lifschitz [11], [12]. The answer set semantics follows the ideas of [3] and <ref> [10] </ref>, and treats a logic program essentially as a default theory in the sense of [18] or as an autoepistemic theory in the sense of [17].
Reference: [11] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: As a corollary, we get a soundness theorem for SLDNF with constructive negation relative to the answer set ("stable model") semantics proposed by Gelfond and Lifschitz <ref> [11] </ref>, [12]. The answer set semantics follows the ideas of [3] and [10], and treats a logic program essentially as a default theory in the sense of [18] or as an autoepistemic theory in the sense of [17].
Reference: [12] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: As a corollary, we get a soundness theorem for SLDNF with constructive negation relative to the answer set ("stable model") semantics proposed by Gelfond and Lifschitz [11], <ref> [12] </ref>. The answer set semantics follows the ideas of [3] and [10], and treats a logic program essentially as a default theory in the sense of [18] or as an autoepistemic theory in the sense of [17].
Reference: [13] <author> Kenneth Kunen. </author> <title> Signed data dependencies in logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference-contexts: Proofs of soundness theorems like this are interesting because they explain why the computational mechanisms developed in logic programming provide partial implementations of these nonmonotonic formalisms. Our definition of SLDNF is a reformulation of the remarkably simple definition due to Kunen <ref> [13] </ref>. Kunen defined the notion of a computed answer substitution and the notion of a failed query directly, without first introducing SLDNF derivation trees | quite complex combinatorial objects (as done, for instance, in Section 15 of [15] and in Section 2 of [2]). <p> First, j= A may be not derivable in the SLDNF calculus even though A belongs to all answer sets. Second, Prolog may fail to find a derivation of j= A even though such a derivation exists. 3 SLDNF In this section, the description of SLDNF from <ref> [13] </ref> is reproduced in full generality | formulated again in terms of inference rules. 3.1 Schematic Programs Consider a first-order language L without equality that has at least one object constant and at least one predicate constant.
Reference: [14] <author> Vladimir Lifschitz, Norman McCain, Teodor Przymusinski, and Robert Stark. </author> <title> A calculus of goals for loop checking. </title> <booktitle> In Logic Programming and Non-monotonic Reasoning: Proceedings of the Third International Conference, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and [22]. In <ref> [14] </ref>, these ideas are applied to the study of loop checking. 2.
Reference: [15] <author> John Lloyd. </author> <title> Foundations of logic programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Second, extended edition. </note>
Reference-contexts: Kunen defined the notion of a computed answer substitution and the notion of a failed query directly, without first introducing SLDNF derivation trees | quite complex combinatorial objects (as done, for instance, in Section 15 of <ref> [15] </ref> and in Section 2 of [2]). The closure conditions in Kunen's definition can be represented as inference rules.
Reference: [16] <author> Grigori Mints. </author> <title> A complete calculus for pure Prolog. </title> <journal> Proc: Academy of Sciences of Estonian SSR, </journal> <volume> 35(4) </volume> <pages> 367-380, </pages> <year> 1986. </year> <note> In Russian. </note>
Reference-contexts: This work was partially supported by National Science Foundation under grant IRI-9306751. Notes 1. Similar ideas were developed earlier by Mints <ref> [16] </ref> in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [17] <author> Robert Moore. </author> <title> Semantical considerations on nonmonotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: The answer set semantics follows the ideas of [3] and [10], and treats a logic program essentially as a default theory in the sense of [18] or as an autoepistemic theory in the sense of <ref> [17] </ref>. Proofs of soundness theorems like this are interesting because they explain why the computational mechanisms developed in logic programming provide partial implementations of these nonmonotonic formalisms. Our definition of SLDNF is a reformulation of the remarkably simple definition due to Kunen [13].
Reference: [18] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year>
Reference-contexts: The answer set semantics follows the ideas of [3] and [10], and treats a logic program essentially as a default theory in the sense of <ref> [18] </ref> or as an autoepistemic theory in the sense of [17]. Proofs of soundness theorems like this are interesting because they explain why the computational mechanisms developed in logic programming provide partial implementations of these nonmonotonic formalisms.
Reference: [19] <author> John Shepherdson. </author> <title> Logics for negation as failure. </title> <editor> In Yiannis Moschovakis, editor, </editor> <booktitle> Logic from Computer Science, </booktitle> <pages> pages 521-583. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], <ref> [19] </ref> and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [20] <author> John Shepherdson. </author> <title> Mints type deductive calculi for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 56 </volume> <pages> 7-17, </pages> <year> 1992. </year>
Reference-contexts: This work was partially supported by National Science Foundation under grant IRI-9306751. Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], <ref> [20] </ref> and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [21] <author> Robert Stark. </author> <title> The declarative semantics of the Prolog selection rule. </title> <booktitle> In Proc. Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 252-261, </pages> <year> 1994. </year>
Reference-contexts: This work was partially supported by National Science Foundation under grant IRI-9306751. Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and <ref> [21] </ref>. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and [22]. In [14], these ideas are applied to the study of loop checking. 2.
Reference: [22] <author> Robert Stark. </author> <title> Input/output dependencies of normal logic programs. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(3) </volume> <pages> 249-262, </pages> <year> 1994. </year>
Reference-contexts: Notes 1. Similar ideas were developed earlier by Mints [16] in the context of pure Prolog. That work was extended in [4], [20] and [21]. Some of the other papers that anticipated, expounded and developed Kunen's approach to SLDNF are [1], [2], [9], [19] and <ref> [22] </ref>. In [14], these ideas are applied to the study of loop checking. 2.
References-found: 22

