URL: http://www.cs.wustl.edu/~schmidt/IPC_SAP-92.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/cs544/
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: IPC SAP C++ Wrappers for Efficient, Portable, and Flexible Network Programming  
Author: Douglas C. Schmidt 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Abstract: An earlier version of this paper appeared in the Novem-ber/December 1992 issue of the C++ Report magazine. An expanded version of this paper [1] that includes performance results over Ethernet and ATM networks is available at www.cs.wustl.edu/schmidt/COOTS-95.ps.Z. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: violations at compile-time. * Portability SOCK SAP provides a portable platform independent network programming interface. * Ease of use SOCK SAP greatly reduces the amount of application code and development effort expended on lower-level network programming details. * Efficient SOCK SAP enhances the software qualities listed above without sacrificing performance <ref> [1] </ref>. The SOCK SAP class category provides applications with an OO interface to the Internet-domain and UNIX-domain protocol families [6]. SOCK SAP consists of 12 C++ classes. The general structure of SOCK SAP corresponds to the taxonomy of communication services, connection roles, and communication domains shown in Figure 8. <p> The ACE SOCK Dgram Bcast class is used below to broadcast a message to all servers listening on a designated port number in a LAN subnet: int main (int argc, char *argv []) - ACE_SOCK_Dgram_Bcast b_sap (ACE_Addr::sap_any); char *msg; u_short b_port; msg = argc &gt; 1 ? argv <ref> [1] </ref> : "hello world"n"; b_port = argc &gt; 2 ? atoi (argv [2]) : 12345; if (b_sap.send (msg, strlen (msg), b_port) == -1) perror ("can't send broadcast"); return 0; - It is instructive to compare this concise example with the dozens of lines of C source code required to implement broadcasting <p> The FIFO SAP class category encapsulates the UNIX FIFO mechanism. 7 Programming with SOCK SAP C++ Wrappers This section illustrates the ACE SOCK SAP C++ wrappers by using them to develop a client/server streaming application. This application is a simplified version of the ttcp program described in <ref> [1] </ref>. For comparison, this application is also written with Sockets. Most of the error checking has been omitted in these examples to keep them short. Naturally, robust programs should check the return values of library and system calls. <p> buf, sizeof buf)) &gt; 0) for (w_bytes = 0; w_bytes &lt; r_bytes; w_bytes += n) n = write (s_sd, buf + w_bytes, r_bytes - w_bytes); /* Close down the connection. */ close (s_sd); - int main (int argc, char *argv []) - char *host = argc &gt; 1 ? argv <ref> [1] </ref> : "ics.uci.edu"; u_short port_num = htons (argc &gt; 2 ? atoi (argv [2]) : PORT_NUM); /* Send data to the server. */ send_data (host, port_num); return 0; - 12 #define PORT_NUM 10000 /* Socket server. */ void recv_data (u_short port_num) - struct sockaddr_in s_addr; int s_sd; /* Create a local <p> */ while ((r_bytes = read (n_sd, buf, sizeof buf)) &gt; 0) write (1, buf, r_bytes); /* Close the new endpoint (listening endpoint remains open) */ close (n_sd); - /* NOTREACHED */ - int main (int argc, char *argv []) - u_short port_num = htons (argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : PORT_NUM); // Receive data from clients. recv_data (port_num); return 0; - static const int PORT_NUM = 10000; static const int TIMEOUT = 5; // SOCK_SAP Client. template &lt;class CONNECTOR&gt; void send_data (CONNECTOR::PEER_ADDR peer_addr) - // Data transfer object. CONNECTOR::PEER_STREAM peer_stream; // Establish connection without blocking. <p> server (send_n () handles // "short writes" correctly). char buf [BUFSIZ]; for (int r_bytes; (r_bytes = read (0, buf, sizeof buf)) &gt; 0;) peer_stream.send_n (buf, r_bytes); // Explicitly close the connection. peer_stream.close (); - int main (int argc, char *argv []) - char *host = argc &gt; 1 ? argv <ref> [1] </ref> : "ics.uci.edu"; u_short port_num = htons (argc &gt; 2 ? atoi (argv [2]) : PORT_NUM); // Address of the server. <p> peer_stream.recv (buf, sizeof buf); if (r_bytes &gt; 0) write (1, buf, r_bytes); else break; - // Close peer_stream endpoint // (acceptor endpoint stays open). peer_stream.close (); - /* NOTREACHED */ - int main (int argc, char *argv []) - u_short port_num = argc == 1 ? PORT_NUM : atoi (argv <ref> [1] </ref>); // Port for the server. ACE_INET_Addr s_addr (port_num); // Use Socket wrappers on server's side. recv_data&lt;ACE_SOCK_Acceptor&gt; (s_addr); return 0; - hides the subtle and error-prone details that must be programmed explicitly in Figures 10 and 11. <p> msghdr send_msg; u_sd = socket (PF_UNIX, SOCK_STREAM, 0); memset ((void *) &addr, 0, sizeof addr); addr.sun_family = AF_UNIX; strcpy (addr.sun_path, "/tmp/foo"); bind (u_sd, &addr, sizeof addr.sun_family + strlen ("/tmp/foo")); 15 listen (u_sd, 5); // Accept connection. n_sd = accept (u_sd, 0, 0); // Sanity check. a [0] = 0xab; a <ref> [1] </ref> = 0xcd; iov.iov_base = (char *) a; iov.iov_len = sizeof a; send_msg.msg_iov = &iov; send_msg.msg_iovlen = 1; send_msg.msg_name = (char *) 0; send_msg.msg_namelen = 0; send_msg.msg_accrights = (char *) &n_sd; send_msg.msg_accrightslen = sizeof n_sd; // Pass the Socket handle back to caller. sendmsg (n_sd, &send_msg, 0); Combine multiple operations into
Reference: [2] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction This paper describes object-oriented (OO) techniques for encapsulating OS interprocess communication (IPC) mechanisms with C++ wrappers. The paper focuses on the C++ wrappers provided by the IPC SAP components in the ACE framework <ref> [2] </ref>. ACE is a collection of reusable C++ class libraries and OO framework components that simplify the development of portable, high-performance and real-time communication software. <p> The goals of IPC SAP are to improve the correctness, ease of use, and portability/reusability of communication software, without adversely affecting its performance. IPC SAP is distributed with the ACE framework <ref> [2] </ref> and is used on many commercial projects including Bellcore, Boeing, Lucent, Motorola, Nortel, SAIC, and Siemens. 3 Survey of Network Programming Interfaces This section surveys the behavior and limitations of conventional network programming interfaces such as Sockets and TLI. 3.1 Background In many operating systems, such as UNIX and Win32, <p> broadcast a message to all servers listening on a designated port number in a LAN subnet: int main (int argc, char *argv []) - ACE_SOCK_Dgram_Bcast b_sap (ACE_Addr::sap_any); char *msg; u_short b_port; msg = argc &gt; 1 ? argv [1] : "hello world"n"; b_port = argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : 12345; if (b_sap.send (msg, strlen (msg), b_port) == -1) perror ("can't send broadcast"); return 0; - It is instructive to compare this concise example with the dozens of lines of C source code required to implement broadcasting using the Socket interface directly. 6.2 Network Addressing Designing an efficient, general-purpose <p> += n) n = write (s_sd, buf + w_bytes, r_bytes - w_bytes); /* Close down the connection. */ close (s_sd); - int main (int argc, char *argv []) - char *host = argc &gt; 1 ? argv [1] : "ics.uci.edu"; u_short port_num = htons (argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : PORT_NUM); /* Send data to the server. */ send_data (host, port_num); return 0; - 12 #define PORT_NUM 10000 /* Socket server. */ void recv_data (u_short port_num) - struct sockaddr_in s_addr; int s_sd; /* Create a local endpoint of communication */ s_sd = socket (PF_INET, SOCK_STREAM, 0); /* Set up <p> r_bytes; (r_bytes = read (0, buf, sizeof buf)) &gt; 0;) peer_stream.send_n (buf, r_bytes); // Explicitly close the connection. peer_stream.close (); - int main (int argc, char *argv []) - char *host = argc &gt; 1 ? argv [1] : "ics.uci.edu"; u_short port_num = htons (argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : PORT_NUM); // Address of the server. ACE_INET_Addr s_addr (port_num, host) // Use SOCK SAP wrappers on client's side. send_data &lt;ACE_SOCK_Connector&gt; (s_addr); return 0; - 13 static const int PORT_NUM = 10000; // SOCK_SAP Server. template &lt;class ACCEPTOR&gt; void recv_data (ACCEPTOR::PEER_ADDR s_addr) - // Factory for passive connection establishment. <p> ACE LSOCK* classes to pass Socket handles is very concise: ACE_LSOCK_Stream stream; ACE_LSOCK_Acceptor acceptor ("/tmp/foo"); // Accept connection. acceptor.accept (stream); // Pass the Socket handle back to caller. stream.send_handle (stream.get_handle ()); versus the code that is required to implement this using the Socket interface: int n_sd; sockaddr_un addr; u_char a <ref> [2] </ref>; iovec iov; msghdr send_msg; u_sd = socket (PF_UNIX, SOCK_STREAM, 0); memset ((void *) &addr, 0, sizeof addr); addr.sun_family = AF_UNIX; strcpy (addr.sun_path, "/tmp/foo"); bind (u_sd, &addr, sizeof addr.sun_family + strlen ("/tmp/foo")); 15 listen (u_sd, 5); // Accept connection. n_sd = accept (u_sd, 0, 0); // Sanity check. a [0] = <p> This problem will be solved over time as the ANSI/ISO C++ exception handling mechanism becomes available on most OS platforms. Current Status and Future Topics: IPC SAP is available with the ACE <ref> [2] </ref> framework.
Reference: [3] <author> M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-man, </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: ACE is a collection of reusable C++ class libraries and OO framework components that simplify the development of portable, high-performance and real-time communication software. IPC SAP is a component in ACE that provides a family of OO network programming interfaces to encapsulate the Socket interface <ref> [3] </ref>, the System V transport layer interface (TLI) [4], SVR4 STREAM pipes [5], UNIX FIFOs [6], and Windows NT named pipes [7]. The C++ wrappers in IPC SAP shield developers and applications from non-portable details of native OS local and remote IPC mechanisms. <p> provides a set of high-level tools, such as IDL compilers and naming services, that shield developers from the complexities of lower-level OS system calls that transmit and receive packets across a network. 2.2 User-level Network Programming Inter faces DOC middleware is typically built upon network programming interfaces such as Sockets <ref> [3] </ref>, TLI [4], or Windows NT named pipes [7]. <p> This overhead stems from non-optimized presentation format conversions, non-optimized memory management, inefficient receiver-side de-multiplexing, stop-and-wait flow control, synchronous send-side method invocations, and non-adaptive retransmission timer schemes. Traditionally, meeting the requirements of streaming applications has involved direct access to network programming interfaces such as Sockets <ref> [3] </ref> or TLI [4]. 2.3 Kernel-level Network Programming In terfaces Lower-level network programming interfaces are available in an OS kernel's communication subsystem. <p> Therefore, a different naming scheme (such as IP host addresses) is used to uniquely identify network applications. The Socket and TLI interfaces provide similar functionality. They support a general-purpose interface to multiple communication domains <ref> [3] </ref>. A domain specifies a protocol family and an address family. Each protocol family contains a stack of protocols that implement certain types of communication in the domain. <p> Section 3.2 gives an overview on Sockets, Section 3.3 briefly outlines TLI, Section 3.4 covers STREAM pipes, and Section 3.5 discusses UNIX FIFOs. A complete discussion of these interfaces is beyond the scope of this paper (see <ref> [5, 3, 7, 6, 16] </ref> for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite [3]. <p> A complete discussion of these interfaces is beyond the scope of this paper (see [5, 3, 7, 6, 16] for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite <ref> [3] </ref>. From an application's perspective, a Socket is a local endpoint of communication that is bound to an address residing on a local or a remote host. Sockets are accessed via handles, which are are also referred to as descriptors.
Reference: [4] <author> Sun Microsystems, </author> <title> Network Interfaces Programmer's Guide, Chapter 6 (TLI Interface) ed., </title> <year> 1992. </year>
Reference-contexts: IPC SAP is a component in ACE that provides a family of OO network programming interfaces to encapsulate the Socket interface [3], the System V transport layer interface (TLI) <ref> [4] </ref>, SVR4 STREAM pipes [5], UNIX FIFOs [6], and Windows NT named pipes [7]. The C++ wrappers in IPC SAP shield developers and applications from non-portable details of native OS local and remote IPC mechanisms. <p> set of high-level tools, such as IDL compilers and naming services, that shield developers from the complexities of lower-level OS system calls that transmit and receive packets across a network. 2.2 User-level Network Programming Inter faces DOC middleware is typically built upon network programming interfaces such as Sockets [3], TLI <ref> [4] </ref>, or Windows NT named pipes [7]. <p> This overhead stems from non-optimized presentation format conversions, non-optimized memory management, inefficient receiver-side de-multiplexing, stop-and-wait flow control, synchronous send-side method invocations, and non-adaptive retransmission timer schemes. Traditionally, meeting the requirements of streaming applications has involved direct access to network programming interfaces such as Sockets [3] or TLI <ref> [4] </ref>. 2.3 Kernel-level Network Programming In terfaces Lower-level network programming interfaces are available in an OS kernel's communication subsystem.
Reference: [5] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: IPC SAP is a component in ACE that provides a family of OO network programming interfaces to encapsulate the Socket interface [3], the System V transport layer interface (TLI) [4], SVR4 STREAM pipes <ref> [5] </ref>, UNIX FIFOs [6], and Windows NT named pipes [7]. The C++ wrappers in IPC SAP shield developers and applications from non-portable details of native OS local and remote IPC mechanisms. <p> It is also possible to develop network services like routers or network file systems that reside entirely within the OS kernel <ref> [5] </ref>. However, programming at this level is usually not portable between different OS platforms. Moreover, it's often not even portable across different versions of the same OS. 2.4 Evaluation It is generally harder to program distributed applications using user-level or kernel-level network programming interfaces rather than DOC middleware. <p> Section 3.2 gives an overview on Sockets, Section 3.3 briefly outlines TLI, Section 3.4 covers STREAM pipes, and Section 3.5 discusses UNIX FIFOs. A complete discussion of these interfaces is beyond the scope of this paper (see <ref> [5, 3, 7, 6, 16] </ref> for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite [3]. <p> TLI provides basically the same set of services that Sockets does. However, it places greater emphasis on shielding applications from the details of the underlying transport provider. <ref> [5] </ref> discusses TLI in detail. 3.4 STREAM Pipes STREAM pipes are an enhancement to the original UNIX pipe mechanism. Earlier generation UNIX pipes provided a single uni-directional stream of bytes from a writer endpoint to a reader endpoint. <p> Therefore, unless fixed length messages are always used, each message sent via a FIFO must be distinguished by some form of byte count or special termination symbol. This allows a receiver to extract messages from the FIFO bytestream. FIFOs are described further in <ref> [5, 6, 16] </ref>. 4 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; const int PORT_NUM = 10000; int buggy_echo_server (void) - sockaddr s_addr; int length; // (1) uninitialized variable. char buf [BUFSIZ]; int s_fd, n_fd; // Create a local endpoint of communication. if (s_fd = socket (PF_UNIX, SOCK_DGRAM, 0) == -1) return -1; // Set <p> This makes it hard to write portable applications that access standard TCP/IP options. Likewise, subtle application-level code is necessary to handle the non-intuitive, error-prone behavior of t listen and t accept in a concurrent server with a qlen &gt; 1 <ref> [5] </ref>. 5 Solution: the IPC SAP C++ Wrap pers 5.1 Overview IPC SAP encapsulates common handle-based IPC interfaces such as Sockets, TLI, STREAM pipes, and FIFOs. <p> For example, the accept method in the ACE TLI Acceptor class encapsulates the subtle application-level code required to handle the non-intuitive, error-prone behavior of t listen and t accept in a concurrent server with a qlen &gt; 1 <ref> [5] </ref>. The accept method passively establishes client connection requests.
Reference: [6] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: IPC SAP is a component in ACE that provides a family of OO network programming interfaces to encapsulate the Socket interface [3], the System V transport layer interface (TLI) [4], SVR4 STREAM pipes [5], UNIX FIFOs <ref> [6] </ref>, and Windows NT named pipes [7]. The C++ wrappers in IPC SAP shield developers and applications from non-portable details of native OS local and remote IPC mechanisms. <p> Section 3.2 gives an overview on Sockets, Section 3.3 briefly outlines TLI, Section 3.4 covers STREAM pipes, and Section 3.5 discusses UNIX FIFOs. A complete discussion of these interfaces is beyond the scope of this paper (see <ref> [5, 3, 7, 6, 16] </ref> for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite [3]. <p> At this point, the connld module ensures that the client and server each receive a unique I/O handle identifying a non-multiplexed, bidirectional channel of communication. 3.5 The FIFO Interface UNIX FIFOs (also called named pipes <ref> [6] </ref>) are a restricted form of a STREAM pipe. Unlike STREAM pipes, FIFOs offer only a uni-directional data channel from one or more senders to a single receiver. Moreover, messages from different senders are all placed into the same communication channel. <p> Therefore, unless fixed length messages are always used, each message sent via a FIFO must be distinguished by some form of byte count or special termination symbol. This allows a receiver to extract messages from the FIFO bytestream. FIFOs are described further in <ref> [5, 6, 16] </ref>. 4 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; const int PORT_NUM = 10000; int buggy_echo_server (void) - sockaddr s_addr; int length; // (1) uninitialized variable. char buf [BUFSIZ]; int s_fd, n_fd; // Create a local endpoint of communication. if (s_fd = socket (PF_UNIX, SOCK_DGRAM, 0) == -1) return -1; // Set <p> The SOCK SAP class category provides applications with an OO interface to the Internet-domain and UNIX-domain protocol families <ref> [6] </ref>. SOCK SAP consists of 12 C++ classes. The general structure of SOCK SAP corresponds to the taxonomy of communication services, connection roles, and communication domains shown in Figure 8. <p> However, the Socket interface also provides connectionless service that uses the IP and UDP protocols in the Internet protocol suite. IP and UDP are unreliable data-gram services that do not guarantee a particular message will arrive at its destination. Connectionless service is used by applications (such as rwho daemons <ref> [6] </ref>) that can tolerate some degree of loss. In addition, IP and UDP provide a foundation for higher-layer reliable protocols like TCP and Sun RPC.
Reference: [7] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: IPC SAP is a component in ACE that provides a family of OO network programming interfaces to encapsulate the Socket interface [3], the System V transport layer interface (TLI) [4], SVR4 STREAM pipes [5], UNIX FIFOs [6], and Windows NT named pipes <ref> [7] </ref>. The C++ wrappers in IPC SAP shield developers and applications from non-portable details of native OS local and remote IPC mechanisms. The IPC mechanisms encapsulated by IPC SAP include standard connection-oriented and connectionless protocols, such as TCP, UDP, and IPX/SPX, available in UNIX/POSIX, Win32, and real-time operating systems. <p> IDL compilers and naming services, that shield developers from the complexities of lower-level OS system calls that transmit and receive packets across a network. 2.2 User-level Network Programming Inter faces DOC middleware is typically built upon network programming interfaces such as Sockets [3], TLI [4], or Windows NT named pipes <ref> [7] </ref>. <p> Section 3.2 gives an overview on Sockets, Section 3.3 briefly outlines TLI, Section 3.4 covers STREAM pipes, and Section 3.5 discusses UNIX FIFOs. A complete discussion of these interfaces is beyond the scope of this paper (see <ref> [5, 3, 7, 6, 16] </ref> for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite [3].
Reference: [8] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: DOC middleware is defined broadly to include object request brokers (ORBs) like CORBA <ref> [8] </ref> and Microsoft's DCOM [9], as well as message-oriented middleware like MQseries.
Reference: [9] <author> D. </author> <title> Box, Essential COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: DOC middleware is defined broadly to include object request brokers (ORBs) like CORBA [8] and Microsoft's DCOM <ref> [9] </ref>, as well as message-oriented middleware like MQseries.
Reference: [10] <author> S. Mungee, N. Surendran, and D. C. Schmidt, </author> <title> The Design and Performance of a CORBA Audio/Video Streaming Service, </title> <note> in submitted to the Hawaiian International Conference on System Sciences, </note> <month> Jan. </month> <year> 1999. </year>
Reference-contexts: The request-response and oneway communication mechanisms provided by DOC middleware is not well-suited for a certain class of applications, known as streaming applications <ref> [10] </ref>. Streaming applications are characterized by high-bandwidth, long-duration communication of untyped bytestreams or relatively simple datatypes that possess stringent communication performance requirements. Interactive teleconferencing, medical imaging, and video-on-demand are examples of streaming applications.
Reference: [11] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: Interactive teleconferencing, medical imaging, and video-on-demand are examples of streaming applications. The quality of service requirements of streaming applications frequently cannot tolerate the performance overhead caused by DOC middleware <ref> [11] </ref>. This overhead stems from non-optimized presentation format conversions, non-optimized memory management, inefficient receiver-side de-multiplexing, stop-and-wait flow control, synchronous send-side method invocations, and non-adaptive retransmission timer schemes.
Reference: [12] <editor> OSI Special Interest Group, </editor> <title> Transport Provider Interface Specification, </title> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, the SVR4 putmsg and getmsg system calls may be used to directly access the transport provider interface (TPI) <ref> [12] </ref> and the data-link provider interface (DLPI) [13] available in System V STREAMS [14]. It is also possible to develop network services like routers or network file systems that reside entirely within the OS kernel [5]. However, programming at this level is usually not portable between different OS platforms.
Reference: [13] <institution> OSI Special Interest Group, Data Link Provider Interface Specification, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, the SVR4 putmsg and getmsg system calls may be used to directly access the transport provider interface (TPI) [12] and the data-link provider interface (DLPI) <ref> [13] </ref> available in System V STREAMS [14]. It is also possible to develop network services like routers or network file systems that reside entirely within the OS kernel [5]. However, programming at this level is usually not portable between different OS platforms.
Reference: [14] <author> D. Ritchie, </author> <title> A Stream InputOutput System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: For example, the SVR4 putmsg and getmsg system calls may be used to directly access the transport provider interface (TPI) [12] and the data-link provider interface (DLPI) [13] available in System V STREAMS <ref> [14] </ref>. It is also possible to develop network services like routers or network file systems that reside entirely within the OS kernel [5]. However, programming at this level is usually not portable between different OS platforms. <p> Sockets and TLI are loosely modeled on the UNIX file I/O interface, which defines the open, read, write, close, ioctl, lseek, and select functions <ref> [14] </ref>. However, Sockets and TLI provide additional functionality that is not supported directly by the standard UNIX file I/O interfaces. This extra functionality stems from certain syntactic and semantic differences between file I/O and network I/O.
Reference: [15] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: Conventional network programming libraries like Sockets and TLI lack type-safe, portable, re-entrant, and extensible interfaces. For instance, Socket endpoints are implemented via weakly-typed descriptors that increase the potential for subtle errors to occur at run-time <ref> [15] </ref>. The IPC SAP components described in this paper provide a mid-point in the design space by encapsulating much of the complexity of network programming interfaces. The goals of IPC SAP are to improve the correctness, ease of use, and portability/reusability of communication software, without adversely affecting its performance.
Reference: [16] <author> W. R. Stevens, </author> <title> Advanced Programming in the UNIX Environment. </title> <address> Reading, Massachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Section 3.2 gives an overview on Sockets, Section 3.3 briefly outlines TLI, Section 3.4 covers STREAM pipes, and Section 3.5 discusses UNIX FIFOs. A complete discussion of these interfaces is beyond the scope of this paper (see <ref> [5, 3, 7, 6, 16] </ref> for additional details). 3.2 The Socket Interface The Socket interface was originally developed in BSD UNIX to provide an interface to the TCP/IP protocol suite [3]. <p> Earlier generation UNIX pipes provided a single uni-directional stream of bytes from a writer endpoint to a reader endpoint. STREAM pipes support bi-directional delivery of bytestream and prioritized message data between processes and/or threads executing on the same host machine <ref> [16] </ref>. Although the pipe system call interface remains the same, STREAM pipes offer additional functionality that is roughly equivalent to UNIX-domain SOCK STREAM Sockets. They are somewhat more flexible than UNIX-domain Sockets, however, since they enable STREAM modules to be pushed and popped to and from pipe endpoints. <p> Therefore, unless fixed length messages are always used, each message sent via a FIFO must be distinguished by some form of byte count or special termination symbol. This allows a receiver to extract messages from the FIFO bytestream. FIFOs are described further in <ref> [5, 6, 16] </ref>. 4 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; const int PORT_NUM = 10000; int buggy_echo_server (void) - sockaddr s_addr; int length; // (1) uninitialized variable. char buf [BUFSIZ]; int s_fd, n_fd; // Create a local endpoint of communication. if (s_fd = socket (PF_UNIX, SOCK_DGRAM, 0) == -1) return -1; // Set <p> SPIPE SAP also supports bi-directional delivery of bytestream and prioritized message data between processes and/or threads executing within the same host machine <ref> [16] </ref>. The FIFO SAP class category encapsulates the UNIX FIFO mechanism. 7 Programming with SOCK SAP C++ Wrappers This section illustrates the ACE SOCK SAP C++ wrappers by using them to develop a client/server streaming application. This application is a simplified version of the ttcp program described in [1].
Reference: [17] <author> D. L. Presotto and D. M. Ritchie, </author> <title> Interprocess Communication in the Ninth Edition UNIX System, UNIX Research System Papers, </title> <booktitle> Tenth Edition, </booktitle> <volume> vol. 2, no. 8, </volume> <pages> pp. 523530, </pages> <year> 1990. </year>
Reference-contexts: This is often too restrictive since multiplexing data from multiple clients over a single channel must be programmed manually. For example, each message must include an identifier that enables the receiver to determine which sender transmitted the message. By using mounted STREAM pipes and the connld module <ref> [17] </ref>, applications may dedicate a separate non-multiplexed I/O channel between a server and each instance of a client. STREAM pipes and connld work as follows. The server invokes the pipe system call, creating a bi-directional endpoint of communication. <p> Through the use of C++ default parameter values, the standard method for calling the accept method is syntactically equivalent for both TLI SAP-based and SOCK SAP-based applications. 11 6.4 SPIPE SAP and FIFO SAP The SPIPE SAP class category provides a C++ wrapper interface for mounted STREAM pipes and connld <ref> [17] </ref>. The SPIPE SAP inheritance hierarchy mirrors the one used for SOCK SAP and TLI SAP. It offers functionality that is similar to the SOCK SAP ACE LSOCK* classes (which themselves encapsulate UNIX-domain Sockets).
Reference: [18] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Rep. </type> <institution> HPL-94-34, Hewlett-Packard Laboratories, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: As shown in Section 7, the use of traits in conjunction with C++ parameterized types supports a powerful design paradigm known as generic programming <ref> [18] </ref>. 5.2.3 Increase Reusability Inheritance-based hierarchical decomposition is used in IPC SAP to increase the amount of common code shared by the various IPC mechanisms. For instance, IPC SAP provides a C++ interface to lower-level OS device control system calls like fcntl and ioctl.
Reference: [19] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: The functionality of various types of Internet-domain and UNIX-domain Sockets is achieved by inheriting mechanisms from the appropriate classes described below. These classes and their relationships are illustrated via Booch notation <ref> [19] </ref> in Figure 9. 2 Applications access the functionality of the underlying Internet-domain or UNIX-domain Socket types by inheriting or instantiating the appropriate SOCK SAP subclasses 2 Dashed clouds indicate classes and directed edges indicate inheritance relationships between these classes, e.g., ACE SOCK Stream inherits from ACE SOCK. 8 LSOCK LSOCK
Reference: [20] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Actively and Passively Initializing Network Services, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: The ACE SOCK* classes, on the other hand, use Internet Protocol (IP) addresses and port numbers and allow both intra- and inter-machine IPC. 6.1.2 Connection Establishment Communication software is typified by asymmetric connection roles between clients and servers. In general, servers listen passively for clients to initiate connections actively <ref> [20] </ref>. The structure of passive/active connection establishment and data transfer relationships are captured by the following connection-oriented SOCK SAP classes: ACE SOCK Acceptor and ACE LSOCK Acceptor: These classes are factories [21] that passively establish new endpoints of communication in response to active connection requests.
Reference: [21] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In general, servers listen passively for clients to initiate connections actively [20]. The structure of passive/active connection establishment and data transfer relationships are captured by the following connection-oriented SOCK SAP classes: ACE SOCK Acceptor and ACE LSOCK Acceptor: These classes are factories <ref> [21] </ref> that passively establish new endpoints of communication in response to active connection requests. The ACE SOCK Acceptor and ACE LSOCK Acceptor produce ACE SOCK Stream and ACE LSOCK Stream connection endpoint objects, respectively.
Reference: [22] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The following code illustrates how C++ templates may be applied to parameterize the IPC mechanisms used by an application. This code was extracted from the distributed log ging facility described in <ref> [22] </ref>. <p> ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing [23]; telecommunication systems at Bellcore <ref> [22] </ref>, Ericsson [24], Motorola [25], and Lucent; medical imaging systems at Siemens [26] and Kodak [27]; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction. All the source code described in this paper is available online at www.cs.wustl.edu/schmidt/ACE.html.
Reference: [23] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing <ref> [23] </ref>; telecommunication systems at Bellcore [22], Ericsson [24], Motorola [25], and Lucent; medical imaging systems at Siemens [26] and Kodak [27]; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction.
Reference: [24] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using Design Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing [23]; telecommunication systems at Bellcore [22], Ericsson <ref> [24] </ref>, Motorola [25], and Lucent; medical imaging systems at Siemens [26] and Kodak [27]; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction. All the source code described in this paper is available online at www.cs.wustl.edu/schmidt/ACE.html.
Reference: [25] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing [23]; telecommunication systems at Bellcore [22], Ericsson [24], Motorola <ref> [25] </ref>, and Lucent; medical imaging systems at Siemens [26] and Kodak [27]; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction. All the source code described in this paper is available online at www.cs.wustl.edu/schmidt/ACE.html. Many projects using ACE are described at www.cs.wustl.edu/schmidt/ACE-users.html.
Reference: [26] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing [23]; telecommunication systems at Bellcore [22], Ericsson [24], Motorola [25], and Lucent; medical imaging systems at Siemens <ref> [26] </ref> and Kodak [27]; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction. All the source code described in this paper is available online at www.cs.wustl.edu/schmidt/ACE.html. Many projects using ACE are described at www.cs.wustl.edu/schmidt/ACE-users.html.
Reference: [27] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year> <month> 18 </month>
Reference-contexts: ACE has been used in research and development projects at many universities and companies. For instance, ACE has been used to build real-time avionics systems at Boeing [23]; telecommunication systems at Bellcore [22], Ericsson [24], Motorola [25], and Lucent; medical imaging systems at Siemens [26] and Kodak <ref> [27] </ref>; and distributed simulation systems at SAIC/DARPA. It is also widely used for research projects and classroom instruction. All the source code described in this paper is available online at www.cs.wustl.edu/schmidt/ACE.html. Many projects using ACE are described at www.cs.wustl.edu/schmidt/ACE-users.html. In addition, comp.soft-sys.ace is a USENET newsgroup devoted to ACE-related topics.
References-found: 27

