URL: http://www.daimi.aau.dk/~tamtoft/Papers/PLILP92.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Title: Unfold/fold Transformations Preserving Termination Properties  
Author: Torben Amtoft 
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: The unfold/fold framework constitutes the spine of many program transformation strategies. However, by unrestricted use of folding the target program may terminate less often than the source program. Several authors have investigated the problem of setting up conditions of syntactic nature, i.e. not based on some well-founded ordering of the arguments, which guarantee preservation of termination properties. These conditions are typically formulated in a way which makes it hard to grasp the basic intuition why they work, and in a way which makes it hard to give elegant proofs of correctness. The aim of this paper will be to give a more unified treatment by setting up a model which enables us to reason about termination preservation in a cleaner and more algebraic fashion. The model resembles a logic language and is parametrized with respect to evaluation order, but it should not be too difficult to transfer the ideas to other languages. 
Abstract-found: 1
Intro-found: 1
Reference: [Amt92] <author> Torben Amtoft. </author> <title> Unfold/fold transformations preserving termination properties. </title> <note> To appear as a technical report from DAIMI, </note> <institution> University of Aarhus, Denmark, </institution> <year> 1992. </year>
Reference-contexts: In Sect. 5 we discuss other approaches to the problem of ensuring total correctness and relate them to our model. Section 6 concludes. Some important theorems will, due to lack of space, be given without proof (or only a loose sketch of such); these will appear in <ref> [Amt92] </ref>. 2 Two-level Semantics First the Church-Rosser property can be formulated: Theorem 1. <p> Theorem 14. As the correctness condition for folding, [TS84] and [KK90] essentially use (a special case of) A. For proofs of Theorem 20, 21 and 22 (which all elaborate on the intuition presented in section 1), see <ref> [Amt92] </ref>. Example 5. Continuing from Example 4, we by Theorem 21 can conclude that L holds which is as expected since S 2 loops on p (t) by the LR strategy iff t unifies with a iff T 2 loops on p (t) by the LR strategy.
Reference: [BD77] <author> R.M. Burstall and John Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: 1 Introduction The unfold/fold framework for program transformation dates back to (at least) <ref> [BD77] </ref> and has since been the subject of much interest, primarily aimed at making the process of finding "eureka"-definitions more systematic, e.g. [Wad90], [NN90], [PP91b]. Also supercompilation [Tur86] can be seen as a variant over the concept.
Reference: [BD91] <author> Anders Bondorf and Olivier Danvy. </author> <title> Automatic autoprojection of recursive equations with global variables and abstract data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16(2) </volume> <pages> 151-195, </pages> <year> 1991. </year>
Reference-contexts: Whether a transformation process itself terminates is beyond the scope of this paper, but e.g. [Wad90], [PP91b] address this problem for certain transformation strategies. For the related technique of partial evaluation (cf. [JSS89], <ref> [BD91] </ref>), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], [GS91], [PP91a].
Reference: [DP88] <author> John Darlington and Helen Pull. </author> <title> A program development methodology based on a unified approach to execution and transformation. </title> <editor> In D. Bjorner, A.P. Ershov, and N.D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 117-131. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: This lack of distinction between standard evaluation and symbolic evaluation comes almost for free in a logic language, but also in the functional world one gains from viewing the latter as a generalization of the former <ref> [DP88] </ref>.
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: If 2 ` C ! D, then also 1 ` C ! D. Next comes a most crucial theorem, stating that an arbitrarily mixed sequence of un-foldings and foldings is equivalent to a sequence of unfoldings followed by a sequence of foldings this bears some similarities to proof normalization <ref> [GLT89] </ref>. Theorem 4. If 1 ` C ! D with C,D pruned, there exists E such that 1 ` u C ! E, 1 ` f E ! D (and then also 1 ` u D ! E).
Reference: [Gre87] <author> Steve Gregory. </author> <title> Parallel Logic Programming in PARLOG the language and its implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: This models "or-parallelism", cf. <ref> [Gre87] </ref>. &: If t 1 is a transition from C 1 to C 0 1 , and if t 2 is a transition from C 2 to C 0 2 , then t 1 &t 2 will be a transition from C 1 &C 2 to C 0 1 &C 0
Reference: [GS91] <author> P. A. Gardner and J. C. Shepherdson. </author> <title> Unfold/fold transformations of logic programs. </title> <booktitle> In Computational Proofs: Essays in honour of Alan Robinson. </booktitle> <year> 1991. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], <ref> [GS91] </ref>, [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> This gives a nice solution to the problems arising when folding against a clause containing variables not occurring in the head a problem to which some incorrect solutions have been proposed in the literature (and yet proved correct!), for a survey see <ref> [GS91] </ref>. 1.2 An Overview of This Paper In Sect. 2 we give a semantics for the language sketched above and state some of its properties. In Sect. 3 we state some conditions ensuring preservation of semantics. <p> on unfold/fold transformations in logic languages transformation typically proceeds in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. <ref> [GS91] </ref>, [KK90], [PP91a], [Sek91], [TS84]. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. <ref> [GS91] </ref>, [KK90], [PP91a], [Sek91], [TS84]. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> It is claimed that folding is safe if the number of unfoldings is greater than the number of foldings. In some sense, this can be modeled in our framework by assigning all predicates weight 1. - <ref> [GS91] </ref> allows folding against existing clauses (recall clauses are deleted after having been unfolded) only (not allowing a clause to be folded against itself). This greatly limits the applications, since it seems impossible to arrive at recur-sive definitions of eureka-predicates.
Reference: [Han91] <author> Torben Amtoft Hansen. </author> <title> Properties of unfolding-based meta-level systems. In Partial Evaluation and Semantics-Based Program Manipulation, New Haven, </title> <journal> Con-necticut. (Sigplan Notices, </journal> <volume> vol. 26, no. 9), </volume> <year> 1991. </year>
Reference-contexts: For the related technique of partial evaluation (cf. [JSS89], [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in <ref> [Han91] </ref>, [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> Suppose all rules at level 1 satisfy L. Then L holds, and thus [[B]] L 2 1 for all B, cf. Theorem 13. More specific versions of this theorem are stated in [PP91a] and <ref> [Han91] </ref>. Theorem 22. Suppose all rules at level 1 satisfy A. Then A holds, and thus [[B]] 2 = [[B]] 1 for all strategy-independent B, cf. Theorem 14. As the correctness condition for folding, [TS84] and [KK90] essentially use (a special case of) A. <p> In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in <ref> [Han91] </ref>. On the other hand, as pointed out in [PP91b] this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") and old, where folding is allowed against new predicates only.
Reference: [Hol91] <author> Carsten Kehler Holst. </author> <title> Finiteness analysis. </title> <editor> In John Hughes, editor, </editor> <booktitle> International Conference on Functional Programming Languages and Computer Architecture. </booktitle> <publisher> Springer Verlag, LNCS no 523, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Whether a transformation process itself terminates is beyond the scope of this paper, but e.g. [Wad90], [PP91b] address this problem for certain transformation strategies. For the related technique of partial evaluation (cf. [JSS89], [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in <ref> [Hol91] </ref>. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed.
Reference: [Hon91] <author> Zhu Hong. </author> <title> How powerful are folding/unfolding transformations. </title> <type> Technical Report CSTR-91-2, </type> <institution> Department of Computer Science, Brunel University, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: For the related technique of partial evaluation (cf. [JSS89], [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], <ref> [Hon91] </ref>. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5.
Reference: [JSS89] <author> Neil D. Jones, Peter Sestoft, and Harald Sondergaard. </author> <title> Mix: A self-applicable partial evaluator for experiments in compiler generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: Whether a transformation process itself terminates is beyond the scope of this paper, but e.g. [Wad90], [PP91b] address this problem for certain transformation strategies. For the related technique of partial evaluation (cf. <ref> [JSS89] </ref>, [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91].
Reference: [KK90] <author> Tadashi Kawamura and Tadashi Kanamori. </author> <title> Preservation of stronger equivalence in unfold/fold logic program transformation. </title> <journal> Theoretical Computer Science, </journal> <volume> 75 </volume> <pages> 139-156, </pages> <year> 1990. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], <ref> [KK90] </ref>, [Sek91], [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> Theorem 13. More specific versions of this theorem are stated in [PP91a] and [Han91]. Theorem 22. Suppose all rules at level 1 satisfy A. Then A holds, and thus [[B]] 2 = [[B]] 1 for all strategy-independent B, cf. Theorem 14. As the correctness condition for folding, [TS84] and <ref> [KK90] </ref> essentially use (a special case of) A. For proofs of Theorem 20, 21 and 22 (which all elaborate on the intuition presented in section 1), see [Amt92]. Example 5. <p> unfold/fold transformations in logic languages transformation typically proceeds in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. [GS91], <ref> [KK90] </ref>, [PP91a], [Sek91], [TS84]. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> Aside from being less powerful, we also think that the step-by-step strategy conceptually is much less clean than our approach a similar view being held in [Tur86]. In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate <ref> [KK90] </ref>, [PP91a], [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. On the other hand, as pointed out in [PP91b] this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") <p> not allowed to fold against a (direct or indirect) recursive predicate <ref> [KK90] </ref>, [PP91a], [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. On the other hand, as pointed out in [PP91b] this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") and old, where folding is allowed against new predicates only.
Reference: [Kot85] <author> Laurent Kott. </author> <title> Unfold/fold program transformations. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <title> Algebraic Methods in Semantics, chapter 12. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], <ref> [Kot85] </ref>, [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> As we have seen in Sect. 3, this condition is (too) weak, since failing branches may convert to loops. - [Sek91] improves on the above, essentially by demanding that F must hold (still when new predicates have been assigned weight 0 and old predicates weight 1). - <ref> [Kot85] </ref> treats a functional language, where there apparently is no branching. The situation is that first a number of unfoldings are made, then some laws are applied (not catered for by our framework), then some foldings are made.
Reference: [Llo84] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Our framework is primarily aimed at modeling logic programming even though the machinery differs from the one usually used when treating logic languages, as done in e.g. <ref> [Llo84] </ref>, [Son89]. However, we believe that the main ideas can be carried over to other types of languages as well. 1.1 Two-level Transitions The meaning of programs will be defined in terms of a transition semantics (cf. [Plo81]). <p> Configurations. A basic configuration is a sequence of goals together with some information about which values the variables in the goals can assume. One usually represents this information as a substitution, cf. <ref> [Llo84] </ref>. As substitutions are hard to reason about from an algebraic point of view (even though e.g. [Son89] and [Pal89] show that certain sets of substitutions carry some structure), we will represent the information as a family of sets of ground values. <p> However, we shall assume that the rules are "exhaustive", excluding such behavior. As is well known, it may happen that B loops at level 1 (due to some ineffective strategy) while [[B]] 1 6=?. On the other hand, if we (cf. <ref> [Llo84] </ref>) define a fair strategy as a strategy which sooner or later unfolds any goal, we have Fact 8.
Reference: [NN90] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Eureka definitions for free! or disagreement points for fold/unfold transformations. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> ESOP 90, </booktitle> <address> Copenhagen, Denmark. </address> <publisher> LNCS 432, </publisher> <pages> pages 291-305, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The unfold/fold framework for program transformation dates back to (at least) [BD77] and has since been the subject of much interest, primarily aimed at making the process of finding "eureka"-definitions more systematic, e.g. [Wad90], <ref> [NN90] </ref>, [PP91b]. Also supercompilation [Tur86] can be seen as a variant over the concept. A major problem with the technique is that one, due to "too much folding", may risk that the program resulting from transformation (the target program) loops while the original (the source program) does not.
Reference: [Pal89] <author> Catuscia Palamidessi. </author> <title> Algebraic properties of idempotent substitutions. </title> <type> Technical Report TR-33/89, </type> <institution> University of Pisa, </institution> <year> 1989. </year>
Reference-contexts: One usually represents this information as a substitution, cf. [Llo84]. As substitutions are hard to reason about from an algebraic point of view (even though e.g. [Son89] and <ref> [Pal89] </ref> show that certain sets of substitutions carry some structure), we will represent the information as a family of sets of ground values.
Reference: [Plo81] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report FN-19, DAIMI, </type> <institution> University of Aarhus, Denmark, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: However, we believe that the main ideas can be carried over to other types of languages as well. 1.1 Two-level Transitions The meaning of programs will be defined in terms of a transition semantics (cf. <ref> [Plo81] </ref>). The reason for this is that we feel this is more appropriate for capturing the essence of unfolding and folding: unfolding corresponds to a transition being made in the "right" direction; folding corresponds to a transition being made in the "wrong" direction.
Reference: [PP91a] <author> Maurizio Proietti and Alberto Pettorossi. </author> <title> Semantics preserving transformation rules for Prolog. In Partial Evaluation and Semantics-Based Program Manipulation, New Haven, Connecticut. </title> <journal> (Sigplan Notices, </journal> <volume> vol. 26, no. 9), </volume> <year> 1991. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], [Sek91], [Kot85], [GS91], <ref> [PP91a] </ref>. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> This proposition only holds because we imposed no ordering on the elements of a configuration, which thus is a multiset and not a sequence of basic configurations. In <ref> [PP91a] </ref> one wants to model the fact the standard PROLOG explores the branches in sequential order, and therefore unfolding of the leftmost atom only is allowed (unless extra conditions are satisfied). <p> This theorem is essentially the main content of (but is more general than) [Sek91] Theorem 21. Suppose all rules at level 1 satisfy L. Then L holds, and thus [[B]] L 2 1 for all B, cf. Theorem 13. More specific versions of this theorem are stated in <ref> [PP91a] </ref> and [Han91]. Theorem 22. Suppose all rules at level 1 satisfy A. Then A holds, and thus [[B]] 2 = [[B]] 1 for all strategy-independent B, cf. Theorem 14. As the correctness condition for folding, [TS84] and [KK90] essentially use (a special case of) A. <p> transformations in logic languages transformation typically proceeds in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. [GS91], [KK90], <ref> [PP91a] </ref>, [Sek91], [TS84]. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> Aside from being less powerful, we also think that the step-by-step strategy conceptually is much less clean than our approach a similar view being held in [Tur86]. In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], <ref> [PP91a] </ref>, [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. <p> This greatly limits the applications, since it seems impossible to arrive at recur-sive definitions of eureka-predicates. On the other hand, it becomes possible to give a relatively simple proof of termination preservation. In contrast to the authors mentioned so far, <ref> [PP91a] </ref> impose an order on a sequence of goals, i.e. consider PROLOG's LR strategy. The crucial condition on folding is that the leftmost atom has been unfolded.
Reference: [PP91b] <author> Maurizio Proietti and Alberto Pettorossi. </author> <title> Unfolding Definition- Folding, in this order, for avoiding unnecessary variables in logic programs. </title> <booktitle> In Proceedings of PLILP 91, </booktitle> <address> Passau, </address> <publisher> Germany (LNCS 528), </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The unfold/fold framework for program transformation dates back to (at least) [BD77] and has since been the subject of much interest, primarily aimed at making the process of finding "eureka"-definitions more systematic, e.g. [Wad90], [NN90], <ref> [PP91b] </ref>. Also supercompilation [Tur86] can be seen as a variant over the concept. A major problem with the technique is that one, due to "too much folding", may risk that the program resulting from transformation (the target program) loops while the original (the source program) does not. <p> Whether a transformation process itself terminates is beyond the scope of this paper, but e.g. [Wad90], <ref> [PP91b] </ref> address this problem for certain transformation strategies. For the related technique of partial evaluation (cf. [JSS89], [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. <p> In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. On the other hand, as pointed out in <ref> [PP91b] </ref> this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") and old, where folding is allowed against new predicates only.
Reference: [Sek91] <author> Hirohisa Seki. </author> <title> Unfold/fold transformations of stratified programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 86(1) </volume> <pages> 107-139, </pages> <year> 1991. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. [TS84], [KK90], <ref> [Sek91] </ref>, [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> Similarly for L and A. Theorem 20. Suppose all rules at level 1 satisfy F. Then F holds, and thus [[B]] 2 = [[B]] 1 for all B, cf. Theorem 10. This theorem is essentially the main content of (but is more general than) <ref> [Sek91] </ref> Theorem 21. Suppose all rules at level 1 satisfy L. Then L holds, and thus [[B]] L 2 1 for all B, cf. Theorem 13. More specific versions of this theorem are stated in [PP91a] and [Han91]. Theorem 22. Suppose all rules at level 1 satisfy A. <p> in logic languages transformation typically proceeds in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. [GS91], [KK90], [PP91a], <ref> [Sek91] </ref>, [TS84]. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], <ref> [Sek91] </ref>, [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. <p> We can translate this into our framework: new predicates are assigned weight 0, old predicates are assigned weight 1, and A must hold. As we have seen in Sect. 3, this condition is (too) weak, since failing branches may convert to loops. - <ref> [Sek91] </ref> improves on the above, essentially by demanding that F must hold (still when new predicates have been assigned weight 0 and old predicates weight 1). - [Kot85] treats a functional language, where there apparently is no branching.
Reference: [Son89] <author> Harald Sondergaard. </author> <title> Semantics-based analysis and transformation of logic programs. </title> <type> Technical Report 89/22, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1989. </year>
Reference-contexts: Our framework is primarily aimed at modeling logic programming even though the machinery differs from the one usually used when treating logic languages, as done in e.g. [Llo84], <ref> [Son89] </ref>. However, we believe that the main ideas can be carried over to other types of languages as well. 1.1 Two-level Transitions The meaning of programs will be defined in terms of a transition semantics (cf. [Plo81]). <p> Configurations. A basic configuration is a sequence of goals together with some information about which values the variables in the goals can assume. One usually represents this information as a substitution, cf. [Llo84]. As substitutions are hard to reason about from an algebraic point of view (even though e.g. <ref> [Son89] </ref> and [Pal89] show that certain sets of substitutions carry some structure), we will represent the information as a family of sets of ground values.
Reference: [TS84] <author> Hisao Tamaki and Taisuke Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <booktitle> In Proceedings of 2nd International Logic Programming Conference, Uppsala, </booktitle> <pages> pages 127-138, </pages> <year> 1984. </year>
Reference-contexts: Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91]. Several ways to guarantee total correctness have been proposed in the literature, e.g. <ref> [TS84] </ref>, [KK90], [Sek91], [Kot85], [GS91], [PP91a]. They all work by putting forward some restrictions on the types of foldings allowed. For a more detailed description (and comparison with our approach), see Sect. 5. <p> Theorem 13. More specific versions of this theorem are stated in [PP91a] and [Han91]. Theorem 22. Suppose all rules at level 1 satisfy A. Then A holds, and thus [[B]] 2 = [[B]] 1 for all strategy-independent B, cf. Theorem 14. As the correctness condition for folding, <ref> [TS84] </ref> and [KK90] essentially use (a special case of) A. For proofs of Theorem 20, 21 and 22 (which all elaborate on the intuition presented in section 1), see [Amt92]. Example 5. <p> logic languages transformation typically proceeds in a "step by step fashion"; after a goal in the body of a clause has been unfolded the clause is deleted from the program and replaced by the clause resulting from the unfolding this is the approach taken in e.g. [GS91], [KK90], [PP91a], [Sek91], <ref> [TS84] </ref>. As pointed out in [GS91], one by applying this method loses some power to see this, consider the clause C = p (f (X)) p (X). <p> In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], [Sek91], <ref> [TS84] </ref>. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. On the other hand, as pointed out in [PP91b] this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") and old, where <p> our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], [Sek91], <ref> [TS84] </ref>. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91]. On the other hand, as pointed out in [PP91b] this is essen tially no restriction for applications. - [TS84] and [KK90] divide the predicates into two classes: the new (corresponding to "eureka-definitions") and old, where folding is allowed against new predicates only.
Reference: [Tur86] <author> Valentin F. Turchin. </author> <title> The concept of a supercompiler. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 292-325, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The unfold/fold framework for program transformation dates back to (at least) [BD77] and has since been the subject of much interest, primarily aimed at making the process of finding "eureka"-definitions more systematic, e.g. [Wad90], [NN90], [PP91b]. Also supercompilation <ref> [Tur86] </ref> can be seen as a variant over the concept. A major problem with the technique is that one, due to "too much folding", may risk that the program resulting from transformation (the target program) loops while the original (the source program) does not. <p> Aside from being less powerful, we also think that the step-by-step strategy conceptually is much less clean than our approach a similar view being held in <ref> [Tur86] </ref>. In the literature, one is typically (contrary to our framework) not allowed to fold against a (direct or indirect) recursive predicate [KK90], [PP91a], [Sek91], [TS84]. This mirrors the view that folding corresponds to abbreviation, a view also held in [Han91].
Reference: [Wad90] <author> Philip Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 231-248, </pages> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction The unfold/fold framework for program transformation dates back to (at least) [BD77] and has since been the subject of much interest, primarily aimed at making the process of finding "eureka"-definitions more systematic, e.g. <ref> [Wad90] </ref>, [NN90], [PP91b]. Also supercompilation [Tur86] can be seen as a variant over the concept. A major problem with the technique is that one, due to "too much folding", may risk that the program resulting from transformation (the target program) loops while the original (the source program) does not. <p> Whether a transformation process itself terminates is beyond the scope of this paper, but e.g. <ref> [Wad90] </ref>, [PP91b] address this problem for certain transformation strategies. For the related technique of partial evaluation (cf. [JSS89], [BD91]), the problem of ensuring termination of the partial evaluation process is addressed in [Hol91]. Upper bounds for the speedup possible by applying unfold/fold transformations have been given in [Han91], [Hon91].
References-found: 24

