URL: http://www.cs.rice.edu/CS/PLT/Publications/sipl94-sf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Email: sabry@cs.rice.edu jfield@watson.ibm.com  
Title: Reasoning about Explicit and Implicit Representations of State  
Author: Amr Sabry John Field 
Affiliation: Rice University IBM T.J. Watson Research Center  
Abstract: The semantics of imperative languages are often expressed in terms of a store-passing translation and an algebra for reasoning about stores. We axiomatize the semantics of several typical imperative languages via equational axioms by "inverting" the store-passing translation as well as the algebraic axioms for reasoning about the store. The inversion process is simple and systematic and results in theories that are similar to equational theories for imperative languages that have been derived in more complicated ways, and is likely to be applicable to languages other than those presented here.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <booktitle> Volume 103 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> North-Holland, </pages> <note> revised edition (1984). </note>
Reference-contexts: In other words, the development results in a complete equational correspondence between the theories for the source and target languages. This technique is not specific to logics of imperative languages, and is similar to the method used to establish the correspondence between the -calculus and combinatory logic <ref> [1, 5] </ref>, and the correspondence between the computational -calculus [13] for call by-value languages and the -calculus for continuation-passing terms [15]. 3 Strict Assignments, Call-by-Reference We begin by considering a pure functional language R 1 extended with simple imperative facilities.
Reference: [2] <author> Boehm, H.-J. </author> <title> Side effects and aliasing can have simple axiomatic descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7, </volume> <month> 4 (October </month> <year> 1985) </year> <month> 637-655. </month>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages. <p> We choose the following common representation <ref> [2, 12, 14] </ref>.
Reference: [3] <author> Cartwright, R. and Felleisen, M. </author> <title> The semantics of program dependence. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Programming Language Design and Implementation (1989) 13-27. </booktitle>
Reference-contexts: follows: ref = x:(letref A ((setref! A x) ; A)): 10 5.1 Lazy Store We extend G 2 with a lazy store update operation in addition to the conventional strict operation: S ::= : : : j (upd ` W P ) The lazy store semantics generalizes the strict semantics <ref> [3] </ref> and can be used to justify many optimizations in imperative languages that would be inconsistent with strict store semantics [3, 9]. Intuitively, the evaluation of a program may terminate in the lazy store semantics but diverge in the strict store semantics. <p> lazy store update operation in addition to the conventional strict operation: S ::= : : : j (upd ` W P ) The lazy store semantics generalizes the strict semantics [3] and can be used to justify many optimizations in imperative languages that would be inconsistent with strict store semantics <ref> [3, 9] </ref>. Intuitively, the evaluation of a program may terminate in the lazy store semantics but diverge in the strict store semantics. However, if both evaluations terminate then the two semantics agree on the final answer.
Reference: [4] <author> Crank, E. and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. In Conference Record of the 18th ACM Symposium on Principles of Programming Languages (1991) 233-244. 3 It is possible to use a type system that rejects the above program and that guarantees that the evaluation of "simply typed" programs terminates [17]. With such restrictions, it may be possible to axiomatize the observational equivalence relation. </title> <type> 13 </type>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages. <p> First, in contrast with calculi derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in <p> derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in the program text that contains the most recent value associated with a particular location: setref! expressions modify this current value and lookup operations copy this current value.
Reference: [5] <author> Curry, H. B. and Feys, R. </author> <title> Combinatory Logic, Volume I. </title> <publisher> North-Holland, </publisher> <address> Amsterdam (1958). </address>
Reference-contexts: In other words, the development results in a complete equational correspondence between the theories for the source and target languages. This technique is not specific to logics of imperative languages, and is similar to the method used to establish the correspondence between the -calculus and combinatory logic <ref> [1, 5] </ref>, and the correspondence between the computational -calculus [13] for call by-value languages and the -calculus for continuation-passing terms [15]. 3 Strict Assignments, Call-by-Reference We begin by considering a pure functional language R 1 extended with simple imperative facilities.
Reference: [6] <author> Demers, A. and Donahue, J. </author> <title> Making variables abstract: An equational theory for Rus-sell. </title> <booktitle> In Conference Record of the 10th ACM Symposium on Principles of Programming Languages (1983) 59-72. </booktitle>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages.
Reference: [7] <author> Felleisen, M. and Friedman, </author> <title> D.P. A calculus for assignments in higher-order languages. </title> <booktitle> In Conference Record of the 14th ACM Symposium on Principles of Programming Languages (1987) 314-325. </booktitle>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages.
Reference: [8] <author> Felleisen, M. and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 102 </month> <year> (1992) </year> <month> 235-271. </month> <type> Technical Report 89-100, </type> <institution> Rice University. </institution>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages. <p> new construct is the following: (W (alloc A P )) = (alloc A (W P )) A 62 F V (W ) (Q 4 ) (alloc A P ) = P A 62 F V (P ) (Q 5 ) The first axiom uses an idea of Felleisen et al. <ref> [8] </ref>; it "lifts" the binding of the location A to permit the evaluation of the application (W P ). <p> of the language R 2 extends the one for R 1 with the following clause: V ::= : : : j (letref A M ) 1 Our approach to dynamic allocation has the advantage of simplicity and abstractness, but relies on the meta-operation of renaming to ensure uniqueness of addresses <ref> [8] </ref>. <p> First, in contrast with calculi derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in <p> derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in the program text that contains the most recent value associated with a particular location: setref! expressions modify this current value and lookup operations copy this current value.
Reference: [9] <author> Field, J. </author> <title> A simple rewriting semantics for realistic imperative programs and its application to program analysis (preliminary report). In ACM Sigplan Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </title> <type> Technical Report RR-909, </type> <institution> Yale University (1992) 98-107. </institution>
Reference-contexts: The resulting store constructs typically have a simple semantics that is easy to reason about. Furthermore, such a store and its related operations can yield a natural "store algebra" that can be used for optimization purposes <ref> [9] </ref>. Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages [2, 4, 6, 7, 8, 10, 11, 17]. <p> lazy store update operation in addition to the conventional strict operation: S ::= : : : j (upd ` W P ) The lazy store semantics generalizes the strict semantics [3] and can be used to justify many optimizations in imperative languages that would be inconsistent with strict store semantics <ref> [3, 9] </ref>. Intuitively, the evaluation of a program may terminate in the lazy store semantics but diverge in the strict store semantics. However, if both evaluations terminate then the two semantics agree on the final answer. <p> This is the approach taken in the logic Pim <ref> [9] </ref>, and we consider a few similar extensions here.
Reference: [10] <author> Hoare, C., Hayes, I., Jifeng, H., Morgan, C., Roscoe, A., Sanders, J., Sorensen, I., Spivey, J., and Sufrin, B. </author> <title> Laws of programming. </title> <journal> Communications of the ACM, </journal> <volume> 30, </volume> <month> 8 </month> <year> (1987) </year> <month> 672-686. </month>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages.
Reference: [11] <author> Mason, I. and Talcott, C. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1, </volume> <month> 3 (July </month> <year> 1991) </year> <month> 287-327. </month>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages. <p> First, in contrast with calculi derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in <p> derived from abstract machines for the source imperative language <ref> [4, 8, 11] </ref>, our equational theory never eliminates an expression of the form (setref! V 1 V 2 ) (cf. Section 5). These expressions simply migrate from point to point within the program to allow lookup operations. In the other calculi [4, 8, 11], there is typically a distinguished position in the program text that contains the most recent value associated with a particular location: setref! expressions modify this current value and lookup operations copy this current value.
Reference: [12] <author> Mason, I.A. and Talcott, C. </author> <title> Inferring the equivalence of functional programs that mutate data. </title> <journal> Theoretical Computer Science, </journal> <volume> 105, </volume> <month> 2 </month> <year> (1992) </year> <month> 167-215. </month> <note> Preliminary version in Proceedings of the 4th IEEE Symposium on Logic in Computer Science 1989. </note>
Reference-contexts: We choose the following common representation <ref> [2, 12, 14] </ref>.
Reference: [13] <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <note> In Proceedings of the 4th IEEE Symposium on Logic in Computer Science (1989) 14-23. Also appeared as: </note> <institution> LFCS Report ECS-LFCS-88-86, University of Edinburgh, </institution> <year> 1988. </year>
Reference-contexts: This technique is not specific to logics of imperative languages, and is similar to the method used to establish the correspondence between the -calculus and combinatory logic [1, 5], and the correspondence between the computational -calculus <ref> [13] </ref> for call by-value languages and the -calculus for continuation-passing terms [15]. 3 Strict Assignments, Call-by-Reference We begin by considering a pure functional language R 1 extended with simple imperative facilities. The functional subset includes values V and applications (M N ). <p> 62 F V (V 2 ) (setref! A V 1 ) ; (setref! A V 2 ) = (setref! A V 2 ) 5.3 Extensions to the Functional Fragment We can also extend the axioms for the functional fragments to a more powerful call-by-value logic such as the computational -calculus <ref> [13] </ref>. Because the sequencing operation can be expressed using procedures, extensions to the functional fragment prove more equations between imperative terms. <p> Because the sequencing operation can be expressed using procedures, extensions to the functional fragment prove more equations between imperative terms. The following example shows the effect of adding the axiom fi lift <ref> [13, 15] </ref>: (setref! ` A M ) ; (deref A) ; (deref A 1 ) = ((x:(setref! A x) ; (deref A)) M ) ; (deref A 1 ) (I 11 ) = ((x:(setref! A x) ; x) M ) ; (deref A 1 ) (I 5 ) = ((x:(setref! A
Reference: [14] <author> Odersky, M., Rabin, D., and Hudak, P. </author> <title> Call by name, assignment, and the lambda calculus. </title> <booktitle> In Conference Record of the 20th ACM Symposium on Principles of Programming Languages (January 1993) 43-56. </booktitle>
Reference-contexts: We choose the following common representation <ref> [2, 12, 14] </ref>. <p> The R 2 -calculus is closer in spirit to the theory var <ref> [14] </ref> and the Imperative Lambda Calculus (ILC) [17] but differs in several technical respects. The theory var uses a call-by-name semantics for procedures and has an additional pure construct.
Reference: [15] <author> Sabry, A. and Felleisen, M. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> Lisp and Functional Programming (1993). To appear. Preliminary version in Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1992. </year> <type> Also Technical Report 92-180, </type> <institution> Rice University. </institution>
Reference-contexts: This technique is not specific to logics of imperative languages, and is similar to the method used to establish the correspondence between the -calculus and combinatory logic [1, 5], and the correspondence between the computational -calculus [13] for call by-value languages and the -calculus for continuation-passing terms <ref> [15] </ref>. 3 Strict Assignments, Call-by-Reference We begin by considering a pure functional language R 1 extended with simple imperative facilities. The functional subset includes values V and applications (M N ). <p> Because the sequencing operation can be expressed using procedures, extensions to the functional fragment prove more equations between imperative terms. The following example shows the effect of adding the axiom fi lift <ref> [13, 15] </ref>: (setref! ` A M ) ; (deref A) ; (deref A 1 ) = ((x:(setref! A x) ; (deref A)) M ) ; (deref A 1 ) (I 11 ) = ((x:(setref! A x) ; x) M ) ; (deref A 1 ) (I 5 ) = ((x:(setref! A
Reference: [16] <author> Strachey, C. </author> <title> Towards a formal semantics. In Steel, T.B., editor, Formal Language Description Languages for Computer Programming, </title> <publisher> North-Holland (1966) 197-220. </publisher>
Reference: [17] <author> Swarup, V., Reddy, U., and Ireland, E. </author> <title> Assignments for applicative languages. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture (1991) 192-214. </booktitle> <pages> 14 </pages>
Reference-contexts: Since it is often the case that one wishes to reason about languages directly rather than by translation, there have been many proposals for logics for imperative languages <ref> [2, 4, 6, 7, 8, 10, 11, 17] </ref>. Although each of these was designed independently, and differs from the others in subtle ways, the similarities between them suggest the existence of a systematic way to derive equational logics from the semantics of the languages. <p> The R 2 -calculus is closer in spirit to the theory var [14] and the Imperative Lambda Calculus (ILC) <ref> [17] </ref> but differs in several technical respects. The theory var uses a call-by-name semantics for procedures and has an additional pure construct.
References-found: 17

