URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR390.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: e-mail: -celisi, jwmills-@cs.indiana.edu  
Phone: phone  
Title: Dynamic Statistics of Sequential Prolog  
Author: Ignacio Celis and Jonathan W. Mills 
Keyword: Implementations and Architectures  
Address: Lindley Hall 215 Bloomington, IN 47405  (812)-857-7038  
Affiliation: Computer Science Dept. Indiana University  
Abstract: This paper presents dynamic statistics taken by simulating sequential Prolog programs. We used the Warren's Abstract Machine (WAM) as the abstract machine to simulate these programs. We show the dynamic data for the following areas: Dereferencing Chain, Unification, Trailing, Untrailing, Choice Point Creation, Environment Creation, Backtracking, etc. This information can be useful for compiler writers and special purpose hardware designers to concentrate their effort toward those features of Prolog that are more frequently used. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> Hassan Ait-Kaci Warren's Abstract Machine, </editor> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts (1991). </address>
Reference: 2. <author> Tep P. Dobry, Yale N. Patt, and Alvin M. </author> <title> Despain Performance studies of a Prolog machine architecture. </title> <booktitle> In Proceedings of the 12th International Symposium on Computer Architecture, </booktitle> <address> Boston, Massachusetts, </address> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, D.C., </address> <month> June </month> <year> 1985, </year> <pages> pp. 180-190. </pages>
Reference: 3. <author> Tep P. </author> <title> Dobry A High Performance Architecture for Prolog, Kluwer Academic Publishers, </title> <booktitle> Parallel Processing and Fifth Generation Computing(1990). </booktitle>
Reference-contexts: First, we gathered Prolog programs that would execute large amounts of instructions to get a more realistic information (almost all of them are known Prolog benchmarks). Then, we used the PLM [14] Prolog compiler, as defined in <ref> [3] </ref> with some modifications done by Touati [13] and some others done by us, to generate WAM code. This WAM code was taken as input to our WAM simulator, which yielded the statistics presented in this paper. Figure 1 shows this process.
Reference: 4. <author> Barry S. </author> <title> Fagin and Tep Dobry The Berkeley PLM Instruction Set: An Instruction Set for Prolog. </title> <type> Tech. </type> <institution> Rept. No. UCB/CSD 86/257Computer Science Division (EECS), University of California, Berkeley, </institution> <month> September, </month> <year> 1986. </year>
Reference: 5. <author> John Gabriel, Tim Lindholm, and Ewing L. Lusk, and Ross A. </author> <title> Overbeek A tutorial on the Warren abstract machine for computational logic. </title> <institution> ANL-84-84. Argonne National Laboratory, Argonne, Illinois (1984). </institution>
Reference: 6. <author> Bruce K. </author> <title> Holmer A Detailed Description of the VLSI-PLM Instruction Set: A WAM Based Processor for Prolog. </title> <type> Tech. </type> <institution> Rept. No. UCB/CSD 90/610Computer Science Division (EECS), University of California, Berkeley, Berkeley, </institution> <address> Califronia 94720, </address> <month> March, </month> <year> 1989. </year>
Reference: 7. <author> Bruce K. Holmer, Barton Sano, Michael Carlton, Peter Van Roy, Ralph Haygood, Alvin M. Despain William R. Bush, Joan M. Pendleton, and Tep P. </author> <title> Dobry Fast Prolog with an Extended General Purpose Architecture. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <address> Seattle, Washington, </address> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, D.C., </address> <month> June </month> <year> 1990, </year> <pages> pp. 282-291. </pages>
Reference-contexts: Table 12 shows the occurrence in percentage for unification with a constant. Table 11. Relative Percentage for each kind of Unification. Table 12. Unifications with a constant. Holmer et. al <ref> [7] </ref> gives statistics for the general unifier.
Reference: 8. <author> Rikio Onai, H. Shimizu, Kanae Masuda, </author> <title> and Morithoshi Aso Analysis of sequential Prolog programs. </title> <journal> Journal of Logic Programming 2(1986), </journal> <pages> 119-141. </pages>
Reference: 9. <editor> Evan Tick Memory Performance of Lisp and Prolog Programs. </editor> <booktitle> In Proceedings Third International Conference on Logic Programming. In Lecture Notes in Computer Science 225, </booktitle> <editor> Ehud Shapiro, </editor> <publisher> Springer-Verlag, </publisher> <month> July 14-18 </month> <year> 1986, </year> <pages> pp. 642-649. </pages>
Reference: 10. <editor> Evan Tick Memory Performance of Prolog Architectures, </editor> <publisher> Kluwer Academic Publishers (1987). </publisher>
Reference-contexts: This is because when unifying structures, the entire structures are pushed into the PDL, however if the unification fails they will be discarded and never read. On average there are 2.1 memory references per WAM instruction. These statistics differ slightly from those presented by Tick <ref> [10] </ref>. References to the Heap are less frequent (23%) and Environment references are more frequent (19.2%). This could be due to the different mix of programs. Graph 2 Percentage of Memory References by Area. 8 Dereferencing Chain Table 5 shows the dereferencing chain length for all the programs. <p> A total of 7,417,127 read-dereferences (a dereference that starts in a memory word) were executed. The average length of the dereferencing chain is 0.22 dereferences. Graph 3 plots the percentage for the length of the dereferencing chain. Table 5 Graph 3 Tick <ref> [10] </ref> states that the average length of the dereferencing chain is 0.32 and 67% of dereferencing is of length 0 and 32.3% is of length 1. The length for dereferencing given by Touati and Despain are: 63.5% are of length 0, 36.3% of length 1, and 0.2% of length 2.
Reference: 11. <institution> Evan Tick Parallel Logic Programming, MIT Press, </institution> <address> Cambridge, Massachusetts (1991). </address>
Reference-contexts: Most of the programs are known as toy benchmarks. The input of nrev450 and qs2000 were made bigger than the original benchmark programs. The programs prover, sdda, circuit, differen, mumath, query, serialize were executed 10 times by a loop. Some of the benchmarks are explained in Parallel Logic Programming <ref> [11] </ref>. We now present the statistics gathered by simulating the Prolog Programs. The most relevant points of these statistics are: Most the memory references are reads and writes to the choice 4 point (45%). Dereferencing chains are short. Ninety percent of all choice points have less than four arguments.
Reference: 12. <author> Herv Touati and Alvin M. </author> <title> Despain An Empirical Study of The Warren Abstract Machine. </title> <booktitle> In Proceedings of the 1987 Symposium on Logic Programming, </booktitle> <address> San Francisco, California, </address> <month> August </month> <year> 1987, </year> <pages> pp. 114-124. </pages>
Reference: 13. <institution> Herv Touati A Prolog Garbage Collector for Aquarius. Tech. Rept. No. UCB/CSD 90/610Computer Science Division (EECS), University of California, Berkeley, Berkeley, </institution> <address> Califronia 94720, </address> <month> August, </month> <year> 1988. </year>
Reference-contexts: First, we gathered Prolog programs that would execute large amounts of instructions to get a more realistic information (almost all of them are known Prolog benchmarks). Then, we used the PLM [14] Prolog compiler, as defined in [3] with some modifications done by Touati <ref> [13] </ref> and some others done by us, to generate WAM code. This WAM code was taken as input to our WAM simulator, which yielded the statistics presented in this paper. Figure 1 shows this process.
Reference: 14. <author> Peter Van Roy A Prolog Compiler for the PLM. </author> <type> Master's Report Plan II, Masters thesis, </type> <note> Also techreport 84/203, </note> <institution> Computer Science Division, University of California, Berkeley, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: First, we gathered Prolog programs that would execute large amounts of instructions to get a more realistic information (almost all of them are known Prolog benchmarks). Then, we used the PLM <ref> [14] </ref> Prolog compiler, as defined in [3] with some modifications done by Touati [13] and some others done by us, to generate WAM code. This WAM code was taken as input to our WAM simulator, which yielded the statistics presented in this paper. Figure 1 shows this process.
Reference: 15. <author> David H.D. </author> <title> Warren An abstract Prolog instruction set. </title> <type> Tech. </type> <institution> Rept. 309SRI International, Stanford, California, </institution> <month> October, </month> <year> 1983. </year> <month> 15 </month>
Reference-contexts: Introduction In this paper we present the run time data of sequential Prolog. This information can be useful for compiler writers and special purpose hardware designers. We used Warren's Abstract Machine (WAM) described in the paper "An Abstract Prolog Instruction Set" <ref> [15] </ref>. Almost all implementations of Prolog are based on this machine. We assume familiarity with Prolog and the WAm, for a description of the WAM the reader is referred to [1,5,15].
References-found: 15

