URL: http://www.cs.ucsb.edu/conferences/java98/papers/rmi.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Title: Java RMI Performance and Object Model Interoperability: Experiments with Java/HPC++  
Author: Fabian Breg, Shridhar Diwan, Juan Villacis, Jayashree Balasubramanian, Esra Akman, Dennis Gannon 
Affiliation: Department of Computer Science Indiana University  
Abstract: Java RMI provides an elegant and powerful model for invoking member functions on objects that exist in remote address spaces. Unfortunately, it is a Java-to-Java communication model, and in many of the scientific applications we would like Java objects to interact with modules written in C++ or Fortran. This paper explores the design of RMI and extracts a subset of the RMI object model that is compatible with C++ and HPC++ remote object semantics. This RMI subset has been implemented to run over the Nexus runtime system and is being used as part of the LSA distributed linear system analyzer project.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aart J. C. Bik, J. E. Villacis, and D. B. Gannon. </author> <note> The JAVAR manual, 1997. see http://www.extreme.indiana.edu/hpjava/. </note>
Reference-contexts: However, we are confident that Java based solutions will eventually emerge as the solution. Acknowledgments We would like to thank Aart J.C. Bik who is the author of the javar compiler <ref> [1] </ref> and various routines that read bytecode representations, which we used as a basis for our Nexus RMI compiler
Reference: [2] <author> Fabian Breg. </author> <title> Compiler Support for an RMI Implementation using NexusJava. </title> <type> Technical report, </type> <institution> Computer Science Dept., Indiana University, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: A more detailed description of the RMI architecture can be found in [10]. 2.2 Nexus RMI Nexus RMI is our implementation of Java RMI on top of NexusJava, which is a Java interface to the Nexus communication library <ref> [2] </ref>. The Nexus communication library provides dynamic resource management, multi-threading and multiple methods for communication, allowing it to operate in a heterogeneous environment. NexusJava currently implements a subset of Nexus in Java. The interface to NexusJava is organized around six basic abstractions. A node represents a physical processing resource.
Reference: [3] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation, </title> <booktitle> 1993. In Research Directions in Concurrent Object Oriented Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: Each node is a shared-memory multiprocessor (SMP) and may have several contexts, or virtual address spaces. The central problem associated with multi-context computation is the communication and synchronization of events between two contexts. HPC++ is based on the CC++ <ref> [3] </ref> global pointer concept and the library implements this with a GlobalP tr &lt; T &gt; template as is done in the MPC++ Template Library [9]. A global pointer generalizes the C pointer type to support pointers to objects that exist in other address spaces.
Reference: [4] <author> I. Foster, C. Kesselman, and S. Tuecke. </author> <title> The Nexus Approach to Integrating Multithreading and Communication. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 37 </volume> <pages> 70-82, </pages> <year> 1996. </year>
Reference-contexts: As a first step towards implementing a Java RMI to HPC++ communication system, we implemented a Java to Java RMI system on top of NexusJava [5], a Java interface to the Nexus communication library <ref> [4] </ref>. This system is called Nexus RMI. Next we extended the communication mechanism underlying HPC++ so that it became compatible with the Nexus RMI communication mechanism. This established the communication link between Nexus RMI and HPC++. The rest of the section is organized as follows.
Reference: [5] <author> I. Foster and S. Tuecke. </author> <title> Enabling technologies for web-based ubiquitous supercomputing. </title> <booktitle> In Proc. 5th IEEE Symp. on High Performance Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: As a first step towards implementing a Java RMI to HPC++ communication system, we implemented a Java to Java RMI system on top of NexusJava <ref> [5] </ref>, a Java interface to the Nexus communication library [4]. This system is called Nexus RMI. Next we extended the communication mechanism underlying HPC++ so that it became compatible with the Nexus RMI communication mechanism. This established the communication link between Nexus RMI and HPC++.
Reference: [6] <author> D. Gannon, P. Beckman, E. Johnson, and T. Green. </author> <title> Compilation Issues on Distributed Memory Systems, chapter 3 HPC++ and the HPC++Lib Toolkit. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Java is used to program the front end of the system which serves as the graphical environment for composing computation components. The components are Fortran modules that run on sequential servers or, with the help of MPI, on parallel systems. These modules are encapsulated with HPC++ <ref> [6] </ref>, which is a library based extension to C++ to support multi-threaded computation and remote method calls on distributed objects.
Reference: [7] <author> D. Gannon, R. Bramley, T. Stuckey, J. Villacis, J. Balasubramanian, E. Akman, F. Breg, S. Diwan, and M. Govindaraju. </author> <title> Component Architectures for Distributed Scientific Problem Solving. </title> <type> Technical report, </type> <institution> Indiana University, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: While some of the components in these systems will be built as Java clients and servers, many others will be built using Fortran and C++. In one such system, the Linear System Analyzer (LSA) <ref> [7] </ref>, about 22% of the source is Java, 15% is C++ and 63 % is Fortran. Java is used to program the front end of the system which serves as the graphical environment for composing computation components.
Reference: [8] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and specification, </title> <month> July </month> <year> 1995. </year> <note> Revision 2.0. </note>
Reference-contexts: Use a low level socket model or simple RPC mechanisms built on that. 2. Use the emerging Java CORBA <ref> [8] </ref> standard. 3. Find a way to allow the Java programmer to use a subset of the standard Java Remote Method Invocation (RMI) mechanism that can interoperate with the corresponding HPC++ remote object model. Our first implementation followed the first solution, but that approach proved to be awkward.
Reference: [9] <author> Yutaka Ishikawa. </author> <title> Multiple Threads Template Library. </title> <type> Technical Report TR-96-012, </type> <institution> Real World Computing Partnership, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: The central problem associated with multi-context computation is the communication and synchronization of events between two contexts. HPC++ is based on the CC++ [3] global pointer concept and the library implements this with a GlobalP tr &lt; T &gt; template as is done in the MPC++ Template Library <ref> [9] </ref>. A global pointer generalizes the C pointer type to support pointers to objects that exist in other address spaces. It is closely linked to the idea of a global reference which is an object that acts as proxy for a remote object.
Reference: [10] <author> JavaSoft. </author> <title> Java Remote Method Invocation (RMI), </title> <note> 1997. in The JDK 1.1 RMI Specification see http://www.javasoft.com/products/jdk/1.1/docs/guide/rmi/index.html. 10 </note>
Reference-contexts: While it is extremely fast in some cases, it is subject to non-linear anomalies in others. We demonstrate that our Java-to-HPC++ prototype is able to avoid these performance problems. 2 A Java - HPC++ RMI System Java RMI <ref> [10] </ref> provides a mechanism for making method invocations on Java objects residing in different virtual machines. Java RMI is specifically designed to operate in the Java environment and so it seamlessly integrates a distributed object model into the Java language. <p> RMI servers can register their objects at the registry after which clients can obtain a reference to these remote objects. A more detailed description of the RMI architecture can be found in <ref> [10] </ref>. 2.2 Nexus RMI Nexus RMI is our implementation of Java RMI on top of NexusJava, which is a Java interface to the Nexus communication library [2]. The Nexus communication library provides dynamic resource management, multi-threading and multiple methods for communication, allowing it to operate in a heterogeneous environment.
References-found: 10

