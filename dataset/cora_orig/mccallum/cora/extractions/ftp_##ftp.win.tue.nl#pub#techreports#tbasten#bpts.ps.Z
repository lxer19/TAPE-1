URL: ftp://ftp.win.tue.nl/pub/techreports/tbasten/bpts.ps.Z
Refering-URL: http://wwwis.win.tue.nl/~tbasten/publications.html
Root-URL: http://www.win.tue.nl
Email: email: tbasten@win.tue.nl  
Title: Breakpoints and Time in Distributed Computations  
Author: Twan Basten 
Keyword: Key words: Breakpoints Vector time Global states Causality- Distributed debugging  
Address: Netherlands  
Affiliation: Dept. of Computing Science, Eindhoven University of Technology, The  
Abstract: This paper investigates how vector time can be used to set breakpoints in distributed computations for the purpose of analyzing and debugging distributed programs. A breakpoint is represented by a set of events in one or more processes. One interesting state in which a distributed computation can be halted is the earliest global state reflecting all events in a breakpoint. A simple expression in terms of vector time is derived to determine this state. Another state of interest is the global state reflecting only events preceding any of the breakpoint events, but reflecting none of the breakpoint events themselves. Two alternative expressions are presented for this state. The first one is in terms of vector time and a derived notion called reversed vector time. The second expression uses vector time and the convex closure of a set of events. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.A. Basten. </author> <title> Event Abstraction in Modeling Distributed Computations. </title> <editor> In K. Ecker, editor, </editor> <booktitle> Proceedings of the Workshop on Parallel Processing, </booktitle> <address> Lessach, Aus-tria, </address> <month> September </month> <year> 1993. </year> <note> Informatik-Bericht 94/1, </note> <institution> Technische Universitat Clausthal, Germany, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In [7, 16], algorithms are given for detecting arbitrary predicates in an event-based environment. In <ref> [1, 3, 12, 15, 19] </ref>, specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them. In both approaches a breakpoint can always be translated to a set of events.
Reference: 2. <author> A.A. Basten, T. Kunz, J.P. Black, M.H. Coffin, </author> <title> and D.J. Taylor. Time and the Order of Abstract Events in Distributed Computations. </title> <note> Computing Science Note 94/06, </note> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, Eindhoven, </institution> <address> The Netherlands, </address> <month> February </month> <year> 1994. </year> <note> Submitted 01-02-1994 to Distributed Computing, 29pp in ms. </note>
Reference-contexts: For any event e 2 E and process i 2 P, T:e:i = jp i ej. An algorithm for calculating vector timestamps for the model of distributed computations used in this paper can be found in <ref> [2] </ref>. During a debugging session, vector timestamps can be calculated after a distributed program has been executed and event information has been recorded. This means that the timestamps are available when a computation is replayed. Mattern and Fidge introduced vector timestamps to characterize the precedence relation. <p> For this expression, reversed timestamps are not necessary, reducing the amount of storage needed. Calculating the convex closure, however, slows down the detection of a breakpoint. The results derived in this paper can also be used for other purposes. One important application is event abstraction. In <ref> [2] </ref>, a theoretical treatment of the relationship between vector time and causality among abstract events is given. The expressions derived for the earliest and preceding global state of a breakpoint can also be used to determine causality among abstract events.
Reference: 3. <author> P.C. Bates. </author> <title> Debugging Heterogeneous Distributed Systems using Event-Based Models of Behavior. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 11-22, </pages> <month> January </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, Wisconsin, </address> <month> May, </month> <year> 1988. </year>
Reference-contexts: During the original execution, information essential for a deterministic replay is collected, minimizing interference with the non-deterministic program behavior. Deterministic replays will then be used to analyze program behavior. To overcome the need for determining the global state of a distributed computation, many researchers <ref> [3, 8, 20, 21] </ref> have chosen an event-based approach. Event information can be captured relatively easily compared to state information. In addition, states of a computation can always be restored from event information. <p> On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In [7, 16], algorithms are given for detecting arbitrary predicates in an event-based environment. In <ref> [1, 3, 12, 15, 19] </ref>, specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them. In both approaches a breakpoint can always be translated to a set of events.
Reference: 4. <author> K.M. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: Miller and Choi [19] and Haban and Weigel [12] use behavioral patterns to specify breakpoints. As soon as an occurrence of a pattern is detected, a halting algorithm is initiated. They use halting algorithms based on Chandy and Lamport's global snapshot algorithm <ref> [4] </ref>. As soon as the occurrence of an event in some process completes the detection of a breakpoint, a halting message is sent to all neighboring processes and the process itself is suspended. Every process that receives a halting message forwards it to its neighbors and then suspends its execution.
Reference: 5. <author> B. Charron-Bost. </author> <title> Combinatorics and Geometry of Consistent Cuts: Application to Concurrency Theory. </title> <editor> In J.-C. Bermond and M. Raynal, editors, </editor> <booktitle> Distributed Algorithms, volume 392 of Lecture Notes in Computer Science, </booktitle> <pages> pages 45-56. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year> <booktitle> Proceedings of WDAG '89, </booktitle> <address> Nice, France, </address> <month> Septem-ber </month> <year> 1989. </year>
Reference-contexts: The appendix contains some formal proofs of results in Section 5. Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern [17, 18], Charron-Bost <ref> [5, 6] </ref>, and Fidge [10]. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport [14]. A distributed computation consists of a set of local computations, one for each process.
Reference: 6. <author> B. Charron-Bost, F. Mattern, and G. Tel. </author> <title> Synchronous and Asynchronous Communication in Distributed Computations. </title> <type> Technical Report LITP 91.55, </type> <institution> Institut Blaise Pascal, Universite Paris 7, Paris, France, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The appendix contains some formal proofs of results in Section 5. Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern [17, 18], Charron-Bost <ref> [5, 6] </ref>, and Fidge [10]. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport [14]. A distributed computation consists of a set of local computations, one for each process.
Reference: 7. <author> R. Cooper and K. Marzullo. </author> <title> Consistent Detection of Global Predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163-173, </pages> <address> Santa Cruz, California, </address> <month> May </month> <year> 1991. </year> <note> The proceedings appeared also as ACM SIGPLAN Notices, 26(12), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: This does not mean that the first aspect is not important. On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In <ref> [7, 16] </ref>, algorithms are given for detecting arbitrary predicates in an event-based environment. In [1, 3, 12, 15, 19], specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them.
Reference: 8. <author> I.J.P. Elshoff. </author> <title> A Distributed Debugger for Amoeba. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 1-10, </pages> <address> Madison, Wisconsin, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: During the original execution, information essential for a deterministic replay is collected, minimizing interference with the non-deterministic program behavior. Deterministic replays will then be used to analyze program behavior. To overcome the need for determining the global state of a distributed computation, many researchers <ref> [3, 8, 20, 21] </ref> have chosen an event-based approach. Event information can be captured relatively easily compared to state information. In addition, states of a computation can always be restored from event information.
Reference: 9. <author> C.J. Fidge. </author> <title> Dynamic Analysis of Event Orderings in Message-Passing Systems. </title> <type> PhD thesis, </type> <institution> Australian National University, Department of Computer Science, Canberra, Australia, </institution> <year> 1989. </year>
Reference-contexts: Since cyclic causal relationships cannot occur in a distributed computation, we require that the precedence relation is a partial order. It extends the "happens before" relation as defined by Lamport [14] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [9, 10] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously. A distributed computation can be visualized in a so-called time diagram. In Figure 1, the vertical lines represent processes. Time increases along these lines from top to bottom. Events are depicted as dots. <p> The first step is to find an expression for the global time of the causal past of an event. For this purpose, vector timestamps as introduced by Mattern [17, 18] and Fidge <ref> [9, 10] </ref> can be used. A vector of size N is assigned to every event in E such that every component i 2 P of the vector is equal to the number of predecessors of the event in process i.
Reference: 10. <author> C.J. Fidge. </author> <title> Logical Time in Distributed Computing Systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The global state in which the computation is restored is the earliest state that exactly reflects all events preceding the breakpoint. Manabe and Imase [15] propose a similar approach for patterns slightly more general than a single event, but still fairly restricted. In this paper, we use vector time <ref> [10, 18] </ref> to enhance the results of Fowler and Zwaenepoel, and Manabe and Imase. Vector time can be used to represent global states of a distributed computation. Interesting global states can be found and restored using the following general strategy. During the original execution, event information is collected, minimizing perturbation. <p> The appendix contains some formal proofs of results in Section 5. Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern [17, 18], Charron-Bost [5, 6], and Fidge <ref> [10] </ref>. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport [14]. A distributed computation consists of a set of local computations, one for each process. <p> Since cyclic causal relationships cannot occur in a distributed computation, we require that the precedence relation is a partial order. It extends the "happens before" relation as defined by Lamport [14] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [9, 10] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously. A distributed computation can be visualized in a so-called time diagram. In Figure 1, the vertical lines represent processes. Time increases along these lines from top to bottom. Events are depicted as dots. <p> The first step is to find an expression for the global time of the causal past of an event. For this purpose, vector timestamps as introduced by Mattern [17, 18] and Fidge <ref> [9, 10] </ref> can be used. A vector of size N is assigned to every event in E such that every component i 2 P of the vector is equal to the number of predecessors of the event in process i.
Reference: 11. <author> J. Fowler and W. Zwaenepoel. </author> <title> Causal Distributed Breakpoints. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 134-141, </pages> <address> Paris, France, </address> <month> May/June </month> <year> 1990. </year>
Reference-contexts: In this way, every process will, eventually, be suspended. Obviously, the global state in which the computation is halted is, in general, not the earliest global state. This observation has motivated Fowler and Zwaenepoel <ref> [11] </ref> to introduce the notion of causal distributed breakpoints as a natural extension of breakpoints in sequential programs. A causal distributed breakpoint consists of a single event. The global state in which the computation is restored is the earliest state that exactly reflects all events preceding the breakpoint. <p> Corollary 4.6 implies that for an event e, egs:feg is equal to T:e. This means that we have found a simple expression for the earliest global state reflecting a single event. This result is similar to the results given by Fowler and Zwaenepoel <ref> [11] </ref> for causal distributed breakpoints. The following derivation yields the desired result for arbitrary sets of events. Let A be a subset of E.
Reference: 12. <author> D. Haban and W. Weigel. </author> <title> Global Events and Global Breakpoints in Distributed Systems. </title> <booktitle> In Proceedings of the 21st Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 166-175, </pages> <address> Kailua-Kona, Hawaii, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In [7, 16], algorithms are given for detecting arbitrary predicates in an event-based environment. In <ref> [1, 3, 12, 15, 19] </ref>, specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them. In both approaches a breakpoint can always be translated to a set of events. <p> This means that the computation is halted in the earliest state in which the condition is true. In distributed computations, there is no global notion of time. In particular, it is not straightforward to define the notion of earliest state. Miller and Choi [19] and Haban and Weigel <ref> [12] </ref> use behavioral patterns to specify breakpoints. As soon as an occurrence of a pattern is detected, a halting algorithm is initiated. They use halting algorithms based on Chandy and Lamport's global snapshot algorithm [4].
Reference: 13. <author> Thomas Kunz. </author> <title> Abstract Behaviour of Distributed Executions with Applications to Visualization. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Technical University of Darmstadt, Darmstadt, Germany, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The current prototype records event information for the purpose of visualization. It has tools for visualizing events and their causal relationships. It also has some tools for determining and visualizing abstract program behavior <ref> [13] </ref>. Since most tools use vector time, much effort is put into an efficient algorithm for calculating and storing timestamps. An earlier version of the prototype also had a replay facility. It is planned to add such a facility to the current prototype as well. <p> One important application is event abstraction. In [2], a theoretical treatment of the relationship between vector time and causality among abstract events is given. The expressions derived for the earliest and preceding global state of a breakpoint can also be used to determine causality among abstract events. In <ref> [13] </ref>, an event-abstraction tool is described that uses a timestamp for convex abstract events that is essentially the same as our second expression for the global state preceding a breakpoint. A prototype of this tool has been implemented and the results appear to be very promising.
Reference: 14. <author> L. Lamport. </author> <title> Time, Clocks and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern [17, 18], Charron-Bost [5, 6], and Fidge [10]. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport <ref> [14] </ref>. A distributed computation consists of a set of local computations, one for each process. For the sake of simplicity, it is assumed that the number of processes is constant and known in advance. <p> Since cyclic causal relationships cannot occur in a distributed computation, we require that the precedence relation is a partial order. It extends the "happens before" relation as defined by Lamport <ref> [14] </ref> to synchronous communication in a natural way. The condition C2, originally given by Fidge [9, 10], means that a synchronous communication can be interpreted as if it occurred instantaneously. A distributed computation can be visualized in a so-called time diagram. In Figure 1, the vertical lines represent processes.
Reference: 15. <author> Y. Manabe and M. Imase. </author> <title> Global Conditions in Debugging Distributed Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 15(1) </volume> <pages> 62-69, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In [7, 16], algorithms are given for detecting arbitrary predicates in an event-based environment. In <ref> [1, 3, 12, 15, 19] </ref>, specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them. In both approaches a breakpoint can always be translated to a set of events. <p> A causal distributed breakpoint consists of a single event. The global state in which the computation is restored is the earliest state that exactly reflects all events preceding the breakpoint. Manabe and Imase <ref> [15] </ref> propose a similar approach for patterns slightly more general than a single event, but still fairly restricted. In this paper, we use vector time [10, 18] to enhance the results of Fowler and Zwaenepoel, and Manabe and Imase.
Reference: 16. <author> K. Marzullo and G. Neiger. </author> <title> Detection of Global State Predicates. </title> <editor> In S. Toueg, P.G. Spirakis, and L.Kirousis, editors, </editor> <booktitle> Distributed Algorithms, volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272, </pages> <address> Berlin, Germany, </address> <year> 1991. </year> <title> Springer Verlag. </title> <booktitle> Proceedings of WDAG '91, Delphi, </booktitle> <address> Greece, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: This does not mean that the first aspect is not important. On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In <ref> [7, 16] </ref>, algorithms are given for detecting arbitrary predicates in an event-based environment. In [1, 3, 12, 15, 19], specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them.
Reference: 17. <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Else-vier Science Publishers B.V., Amsterdam, North-Holland, </publisher> <address> The Netherlands, </address> <year> 1989. </year> <booktitle> Proceedings of the International Workshop held in Gers, </booktitle> <address> France, </address> <month> October, </month> <year> 1988. </year>
Reference-contexts: The appendix contains some formal proofs of results in Section 5. Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern <ref> [17, 18] </ref>, Charron-Bost [5, 6], and Fidge [10]. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport [14]. A distributed computation consists of a set of local computations, one for each process. <p> Fig. 1. The time diagram of a distributed computation. 3 Global States and Time In this section, we formalize the notion of global states of a distributed computation and introduce a notion of time. The definitions and results in this section are due to Mattern <ref> [17, 18] </ref>. The event-based equivalent of a global state is a so-called cut. <p> The first step is to find an expression for the global time of the causal past of an event. For this purpose, vector timestamps as introduced by Mattern <ref> [17, 18] </ref> and Fidge [9, 10] can be used. A vector of size N is assigned to every event in E such that every component i 2 P of the vector is equal to the number of predecessors of the event in process i.
Reference: 18. <author> F. Mattern. </author> <title> On the Relativistic Structure of Logical Time in Distributed Systems. </title> <journal> Bigre, </journal> <volume> 78 </volume> <pages> 3-20, </pages> <month> March </month> <year> 1992. </year> <booktitle> Proceedings of the workshop: Datation et Controle des Executions Reparties, December 4th, 1991, Rennes, </booktitle> <address> France. </address>
Reference-contexts: The global state in which the computation is restored is the earliest state that exactly reflects all events preceding the breakpoint. Manabe and Imase [15] propose a similar approach for patterns slightly more general than a single event, but still fairly restricted. In this paper, we use vector time <ref> [10, 18] </ref> to enhance the results of Fowler and Zwaenepoel, and Manabe and Imase. Vector time can be used to represent global states of a distributed computation. Interesting global states can be found and restored using the following general strategy. During the original execution, event information is collected, minimizing perturbation. <p> The appendix contains some formal proofs of results in Section 5. Finally, Section 6 summarizes the results. 2 Distributed Computations The model of distributed computations used in this paper is based mainly on definitions of Mattern <ref> [17, 18] </ref>, Charron-Bost [5, 6], and Fidge [10]. The precedence relation, which is defined below, essentially is the "happens before" relation introduced by Lamport [14]. A distributed computation consists of a set of local computations, one for each process. <p> Fig. 1. The time diagram of a distributed computation. 3 Global States and Time In this section, we formalize the notion of global states of a distributed computation and introduce a notion of time. The definitions and results in this section are due to Mattern <ref> [17, 18] </ref>. The event-based equivalent of a global state is a so-called cut. <p> Since the union of consistent cuts is a consistent cut, the causal past of a set of events also is a consistent cut. Definitions 3.2 and 4.1 yield that the causal past of an event is the earliest consistent cut containing the event. Corollary 4.2. <ref> [18] </ref> For any event e and consistent cut C, e 2 C , pe C. Definition 4.1 and Corollary 4.2 yield that the causal past of a set of events is the earliest consistent cut containing every element in the set. Corollary 4.3. <p> The first step is to find an expression for the global time of the causal past of an event. For this purpose, vector timestamps as introduced by Mattern <ref> [17, 18] </ref> and Fidge [9, 10] can be used. A vector of size N is assigned to every event in E such that every component i 2 P of the vector is equal to the number of predecessors of the event in process i. <p> For our purposes, the following corollary is of greater importance. It follows from Definitions 3.5 (Global time of a cut), 4.1 (Causal past), and 4.5 (Timestamp function). Corollary 4.6. <ref> [18] </ref> For any event e 2 E, T :pe = T:e. Corollary 4.6 implies that for an event e, egs:feg is equal to T:e. This means that we have found a simple expression for the earliest global state reflecting a single event.
Reference: 19. <author> B.P. Miller and J.-D. Choi. </author> <title> Breakpoints and Halting in Distributed Programs. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 316-323, </pages> <address> San Jose, California, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: On the contrary, specification and detection of breakpoints is at least as important as halting the computation and it definitely is a complex task. However, the literature already suggest several approaches. In [7, 16], algorithms are given for detecting arbitrary predicates in an event-based environment. In <ref> [1, 3, 12, 15, 19] </ref>, specification formalisms and detection algorithms are described based on the notion of behavioral patterns. A behavioral pattern is a specification of a set of events and the causal relations among them. In both approaches a breakpoint can always be translated to a set of events. <p> This means that the computation is halted in the earliest state in which the condition is true. In distributed computations, there is no global notion of time. In particular, it is not straightforward to define the notion of earliest state. Miller and Choi <ref> [19] </ref> and Haban and Weigel [12] use behavioral patterns to specify breakpoints. As soon as an occurrence of a pattern is detected, a halting algorithm is initiated. They use halting algorithms based on Chandy and Lamport's global snapshot algorithm [4].
Reference: 20. <author> E.T. Smith. </author> <title> Debugging Tools for Message-Based Communication Processes. </title> <booktitle> In Proceedings of the 4th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 303-310, </pages> <address> San Fransisco, California, </address> <year> 1984. </year>
Reference-contexts: During the original execution, information essential for a deterministic replay is collected, minimizing interference with the non-deterministic program behavior. Deterministic replays will then be used to analyze program behavior. To overcome the need for determining the global state of a distributed computation, many researchers <ref> [3, 8, 20, 21] </ref> have chosen an event-based approach. Event information can be captured relatively easily compared to state information. In addition, states of a computation can always be restored from event information.
Reference: 21. <author> D.J. Taylor. </author> <title> A Prototype Debugger for Hermes. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 29-42, </pages> <address> Toronto, Ontario, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies. </institution>
Reference-contexts: During the original execution, information essential for a deterministic replay is collected, minimizing interference with the non-deterministic program behavior. Deterministic replays will then be used to analyze program behavior. To overcome the need for determining the global state of a distributed computation, many researchers <ref> [3, 8, 20, 21] </ref> have chosen an event-based approach. Event information can be captured relatively easily compared to state information. In addition, states of a computation can always be restored from event information. <p> The strategy outlined here can be used with any kind of breakpoint-detection algorithm. The research described in this paper is part of a project at the University of Waterloo to design and implement a distributed debugger <ref> [21] </ref>. The current prototype records event information for the purpose of visualization. It has tools for visualizing events and their causal relationships. It also has some tools for determining and visualizing abstract program behavior [13].
References-found: 21

