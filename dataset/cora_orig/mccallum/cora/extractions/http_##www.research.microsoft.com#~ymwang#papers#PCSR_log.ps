URL: http://www.research.microsoft.com/~ymwang/papers/PCSR_log.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/WORKSHOP94CR.htm
Root-URL: http://www.research.microsoft.com
Title: Optimal Message Log Reclamation for Uncoordinated Checkpointing  
Author: Yi-Min Wang and W. Kent Fuchs W. Kent Fuchs 
Keyword: 2: Checkpointing and recovery protocol  
Address: Murray Hill, New Jersey  1308 West Main Street, Urbana, IL 61801  
Note: 1: Introduction  This research was supported in part by the National Aeronautics and Space Administration (NASA) under Grant NASA NAG 1-613, in cooperation with the  Systems and Software (ICLASS), and in part by the Department of the Navy and managed by the Office of the Chief of Naval Research under Grant N00014-91-J-1283. Yi-Min Wang is now with AT&T Bell  is with  
Affiliation: Coordinated Science Laboratory University of Illinois at Urbana-Champaign  Illinois Computer Laboratory for Aerospace  Laboratories,  Coordinated Science Laboratory, University of Illinois,  
Abstract: An algorithm is presented for identifying all garbage message logs in systems requiring message logging to record in-transit messages. The approach is based on a previously derived method for identifying garbage checkpoints by means of recovery line transformation and decomposition. Numerous checkpointing and recovery techniques for message-passing systems have been proposed in the literature. They can be classified into three primary categories: uncoordinated checkpointing [1], coordinated checkpointing [2], and log-based techniques [4]. The focus of this paper is on the space overhead problem of uncoordinated checkpointing. Traditionally, garbage collection has been based on the notion of obsolete checkpoints and message logs: the global recovery line which suffices to recover from the failure of the entire system is computed, and all the obsolete checkpoints and message logs before that recovery line are no longer useful and can be discarded. In contrast, all the nonobsolete checkpoints and message logs have been assumed to be possibly useful for some future recovery and should be retained. With the possibility of domino effects, the space overhead may become prohibitively high. Motivated by the observation that being obsolete is simply a sufficient condition for being garbage, we previously derived the necessary and sufficient condition for identifying all garbage checkpoints, which leads to an optimal checkpoint reclamation algorithm [5]. In this paper, we apply the same approach to solving the problem of optimal message log reclamation. We note that the message logs considered in this paper are used to record the state of the channels [2], and are different from the message logs used for deterministic replay in log-based techniques [4]. While both message contents and ordinal positions are important in the latter, only message contents are needed in the former. The system considered in this paper consists of a number of concurrent processes for which all process communication is through message passing. Processes are assumed to run 
Abstract-found: 1
Intro-found: 0
Reference: [1] <author> B. Bhargava and S. R. Lian. </author> <title> Independent checkpointing and concurrent rollback for recovery An optimistic approach. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: 1: Introduction Numerous checkpointing and recovery techniques for message-passing systems have been proposed in the literature. They can be classified into three primary categories: uncoordinated checkpointing <ref> [1] </ref>, coordinated checkpointing [2], and log-based techniques [4]. The focus of this paper is on the space overhead problem of uncoordinated checkpointing. <p> When any process initiates a rollback, it starts a similar procedure for recovery. The current volatile states of the surviving processes are treated as additional virtual checkpoints <ref> [1] </ref> for constructing an extended checkpoint graph of which the recovery line is called the local recovery line and indicates the consistent rollback state. 3: Optimal message log reclamation Since the purpose of message logging is to record in-transit messages needed for rollback recovery, a message log is nongarbage if and <p> We model a process execution as consisting of a number of operational sessions <ref> [1] </ref> and recovery sessions, where an operational session is the interval between the start of normal execution and the instance of rollback initiation, and between two consecutive operational sessions is a recovery session. 3.1: Recovery Line Transformation and Decomposition Based on the previous description of checkpoint consistency, we define a consistent
Reference: [2] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: 1: Introduction Numerous checkpointing and recovery techniques for message-passing systems have been proposed in the literature. They can be classified into three primary categories: uncoordinated checkpointing [1], coordinated checkpointing <ref> [2] </ref>, and log-based techniques [4]. The focus of this paper is on the space overhead problem of uncoordinated checkpointing. <p> In this paper, we apply the same approach to solving the problem of optimal message log reclamation. We note that the message logs considered in this paper are used to record the state of the channels <ref> [2] </ref>, and are different from the message logs used for deterministic replay in log-based techniques [4].
Reference: [3] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Commun. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Two checkpoints c i;x+1 and c j;y are then considered inconsistent if there is any message sent by p j after c j;y and processed by p i before c i;x+1 (or equivalently c j;y happened-before c i;x+1 <ref> [3] </ref>) or vice versa.
Reference: [4] <author> R. E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: 1: Introduction Numerous checkpointing and recovery techniques for message-passing systems have been proposed in the literature. They can be classified into three primary categories: uncoordinated checkpointing [1], coordinated checkpointing [2], and log-based techniques <ref> [4] </ref>. The focus of this paper is on the space overhead problem of uncoordinated checkpointing. <p> We note that the message logs considered in this paper are used to record the state of the channels [2], and are different from the message logs used for deterministic replay in log-based techniques <ref> [4] </ref>. While both message contents and ordinal positions are important in the latter, only message contents are needed in the former. 2: Checkpointing and recovery protocol The system considered in this paper consists of a number of concurrent processes for which all process communication is through message passing.
Reference: [5] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs. </author> <title> Checkpoint space reclamation for uncoordinated checkpointing in message-passing systems. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 6(5) </volume> <pages> 546-554, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: With the possibility of domino effects, the space overhead may become prohibitively high. Motivated by the observation that being obsolete is simply a sufficient condition for being garbage, we previously derived the necessary and sufficient condition for identifying all garbage checkpoints, which leads to an optimal checkpoint reclamation algorithm <ref> [5] </ref>. In this paper, we apply the same approach to solving the problem of optimal message log reclamation. <p> A garbage collection procedure can be periodically invoked by any process p i . First, p i collects the direct dependency information from all the other processes to construct the checkpoint graph <ref> [5] </ref>. Then the rollback propagation algorithm is applied to the checkpoint graph to determine the global recovery line, before which all the checkpoints and message logs are obsolete and can be discarded. When any process initiates a rollback, it starts a similar procedure for recovery. <p> The example shown in Figure 2 will be used to illustrate the transformation and decomposition throughout this paper. (Formal proofs can be found elsewhere <ref> [5] </ref>.) Suppose G in shows the extended checkpoint graph when p 3 later initiates the first rollback, and G c is the checkpoint graph immediately after the recovery. Figure 2 (d) shows another possible extended checkpoint graph when p 0 initiates a second rollback. <p> n 3 ) [ RL ( ^ G n 4 )) 3.2: Message Log Reclamation Based on recovery line transformation and decomposition, it has been shown that the union of the N recovery lines RL ( ^ G n i ); 0 i N 1, contains all the nongarbage checkpoints <ref> [5] </ref>. For the example shown in Figure 3, while all the checkpoints in G are nonobsolete, only the shaded checkpoints in Figure 3 (f) are nongarbage and need to be retained.
Reference: [6] <author> Y. M. Wang, A. Lowry, and W. K. Fuchs. </author> <title> Consistent global checkpoints based on direct dependency tracking. </title> <journal> Inform. Process. Lett., </journal> <volume> 50(4) </volume> <pages> 223-230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i , denoted by (i; x). Each message is tagged with the process number and the current checkpoint interval number of the sender, and each receiver p i performs direct dependency tracking <ref> [6] </ref> as follows: if a message sent from p j during (j; y) is processed by p i during (i; x), the direct dependency of c i;x+1 on c j;y is recorded. A garbage collection procedure can be periodically invoked by any process p i .
References-found: 6

