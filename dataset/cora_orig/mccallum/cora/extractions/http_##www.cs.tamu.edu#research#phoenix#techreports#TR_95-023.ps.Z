URL: http://www.cs.tamu.edu/research/phoenix/techreports/TR_95-023.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/phoenix/papers_bib.html
Root-URL: 
Title: Fault Tolerant Objects in Distributed Systems Using Hot Replication  
Author: Ganesha Beedubail, Anish Karmarkar, Anil Gurijala, Willis Marti and Udo Pooch 
Address: College Station, TX 77843.  
Affiliation: Department of Computer Science, Texas A&M University,  
Abstract: Technical Report (TR 95-023) April 1995 1 . Abstract This paper presents a new algorithm for supporting fault tolerant objects in distributed systems. The fault tolerance provided by the algorithm is fully user transparent. The algorithm uses a variation of object replication scheme, which we call the Hot Replication Scheme. The algorithm supports nested object invocations. The chief advantages of the scheme are : a) No action is needed in the case of failure of a secondary replica, b) The time to recover from a primary failure is minimal, c) Separation of replication protocol and reliable communication protocol. To recover from a primary failure the system need to (detect the failure and) select one of the secondaries to become the primary. The designated secondary can become primary once it has made sure that its current state is equivalent to the state of the failed primary (it can do so by processing outstanding requests, if any). This is in contrast with the checkpointing and rollback recovery scheme, where the recovery time can be substantial. Our Algorithm exploits the general features and concepts associated with the notion of the objects and object interactions to its advantage. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Strom and S. A. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 3, no. 3, </volume> <pages> pp. 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems.
Reference: [2] <author> E. C. Cooper, </author> <title> "Replicated distributed programs," </title> <booktitle> In ACM Symp. on Oper. Syst. Princ., </booktitle> <pages> pp. 63-78, </pages> <year> 1985. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems. <p> The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client <ref> [2, 3, 12, 13, 14] </ref>). The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols. <p> The primary forwards the request and reply/results it gets to its secondary/backup. In [13], Fred Schneider presents a detailed model, which he calls a state machine approach for implementing fault tolerant services. They discuss the message agreement and message order requirements for this method. Eric Cooper describes <ref> [2] </ref> replicated procedure call (RPC) mechanisms for constructing highly available distributed programs. Replicated remote procedure call combines RPC with replication of a program module for providing fault tolerance.
Reference: [3] <author> T. Joseph and K. Birman, </author> <title> "Exploiting replication in distributed systems," In Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 319-367, </pages> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems. <p> The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client <ref> [2, 3, 12, 13, 14] </ref>). The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols.
Reference: [4] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> "Fault tolerance under UNIX," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems.
Reference: [5] <author> P. Jalote, </author> <title> "Fault tolerant processes," </title> <booktitle> Distributed Computing, </booktitle> <pages> pp. 187-195, </pages> <year> 1989. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems.
Reference: [6] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Recovery in distributed systems using optimistic message logging and checkpointing," </title> <journal> Journal of Algorithms, </journal> <volume> vol. 11, </volume> <pages> pp. 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The revised version appears in the Proceedings of the Fifteenth International Phoenix Conference on Computers and Communications (IPCCC'96), Phoenix, AZ, March 1996. 1 Various schemes for providing fault tolerant services in distributed systems do exist in the literature <ref> [1, 2, 3, 4, 5, 6] </ref>. However, most of these systems use process and message passing models of distributed systems. But currently the object oriented technology is getting widespread acceptance (for many of the advantages seen in this technology), in the design of distributed systems.
Reference: [7] <author> G. Beedubail et al., </author> <title> "An algorithm for supporting fault tolerant objects in distributed object oriented operating systems," </title> <booktitle> In Proc. of International Workshop on Object-Orientation in Operating Systems, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: In the Object Replication or Modular redundancy approach, multiple copies (instances) of the object (service) 2 We will not go into the details of this approach. For additional details on checkpointing the reader can refer to <ref> [7] </ref>. are used to provide the resiliency against host failures. Object Replication (or Modular Redundancy) approach for fault tolerance generally assumes a client-server based distributed system. The server is (usually) replicated.
Reference: [8] <author> K. P. Birman et al., </author> <title> "Implementing fault-tolerant distributed objects," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 6, no. 11, </volume> <pages> pp. 502-508, </pages> <year> 1985. </year>
Reference-contexts: The server is (usually) replicated. In this approach, the copies of the objects are usually arranged in two main schemes: primary backup and active replication. In the case of primary backup scheme, one of the replica is considered as the primary and the other replicas as backups or secondaries <ref> [8, 9, 10, 11] </ref>. Only the primary interacts with the client and other objects. The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. <p> Their system assumes closely synchronized clocks in the system. They classify the primary-backup algorithms as blocking and non-blocking and provide lower bounds (under various failure conditions) on the degree of replication, blocking time and failover time for any primary-backup algorithm. In <ref> [8] </ref>, Birman et. al. describe a technique to implement k-resilient distributed objects. They use a coordinator-cohort scheme, a variation of the primary-backup scheme. The coordinator services the client requests and periodically checkpoints its state to the cohorts.
Reference: [9] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resrources," </title> <booktitle> In Proc. Of Second Intl' Conf. on software Engg., </booktitle> <address> San Francisco, CA., </address> <pages> pp. 562-570, </pages> <year> 1976. </year>
Reference-contexts: The server is (usually) replicated. In this approach, the copies of the objects are usually arranged in two main schemes: primary backup and active replication. In the case of primary backup scheme, one of the replica is considered as the primary and the other replicas as backups or secondaries <ref> [8, 9, 10, 11] </ref>. Only the primary interacts with the client and other objects. The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. <p> In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client [2, 3, 12, 13, 14]). The client selects the results depending on the assumed failure modes. Alsberg and Day <ref> [9] </ref> proposed one of the earliest primary-backup protocols. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept to n hosts. In [10], Budhiraja et. al. present some theoretical aspects of the primary backup approach.
Reference: [10] <author> N. Budhiraja et al., </author> <title> "The primary-backup approach," In Distributed Systems, 2ed Edition, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 199-216, </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The server is (usually) replicated. In this approach, the copies of the objects are usually arranged in two main schemes: primary backup and active replication. In the case of primary backup scheme, one of the replica is considered as the primary and the other replicas as backups or secondaries <ref> [8, 9, 10, 11] </ref>. Only the primary interacts with the client and other objects. The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. <p> The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept to n hosts. In <ref> [10] </ref>, Budhiraja et. al. present some theoretical aspects of the primary backup approach. Their system assumes closely synchronized clocks in the system.
Reference: [11] <author> K. Yap, P. Jalote, and S. Tripati, </author> <title> "Fault tolerant remote procedure call," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 48-54, </pages> <year> 1988. </year>
Reference-contexts: The server is (usually) replicated. In this approach, the copies of the objects are usually arranged in two main schemes: primary backup and active replication. In the case of primary backup scheme, one of the replica is considered as the primary and the other replicas as backups or secondaries <ref> [8, 9, 10, 11] </ref>. Only the primary interacts with the client and other objects. The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. <p> The coordinator also forwards the result of any external action to the cohorts (called retained results). Thus the cohorts will have all the information to take over as a coordinator if the original coordinator fails. In the scheme proposed by Yap et.al <ref> [11] </ref> for implementing the fault tolerant remote procedure call, the replicas (also called incarnations) are organized as a chain. The first replica acts as the primary, the second replica acts as the backup for to the primary. <p> These stored messages can be discarded after a suitable time-out period. The final comment is about the performance of the hot replication algorithm. To the best of our knowledge, only two previous works <ref> [11, 12] </ref> deal with the problem of fault tolerance of the objects supporting nested object invocations (arbitrary level of nesting) using replication mechanism. (We exclude the checkpointing schemes here, because in situations where we can not use checkpointing, maybe due to the recovery time involved, we have to use replication based <p> The algorithm <ref> [11] </ref> can be compared to hot replication scheme, as given below. The main difference between our scheme and the scheme proposed by Yap et.al [11] is that we arrange all the secondary copies as a single group. <p> The algorithm <ref> [11] </ref> can be compared to hot replication scheme, as given below. The main difference between our scheme and the scheme proposed by Yap et.al [11] is that we arrange all the secondary copies as a single group. The primary reliably multicasts the requests and results it receives to the secondaries (hot replicas). In [11] the secondaries are arranged as a chain, replica i + 1 acts as a backup for replica i. <p> The main difference between our scheme and the scheme proposed by Yap et.al <ref> [11] </ref> is that we arrange all the secondary copies as a single group. The primary reliably multicasts the requests and results it receives to the secondaries (hot replicas). In [11] the secondaries are arranged as a chain, replica i + 1 acts as a backup for replica i. In this case the object response time is linearly proportional to the number of replicas. Also the communication protocol and replication protocol are tightly coupled.
Reference: [12] <author> P. Jalote, </author> <title> "Resilient objects in broadcast networks," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 15, no. 1, </volume> <pages> pp. 68-72, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client <ref> [2, 3, 12, 13, 14] </ref>). The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols. <p> They discuss the message agreement and message order requirements for this method. Eric Cooper describes [2] replicated procedure call (RPC) mechanisms for constructing highly available distributed programs. Replicated remote procedure call combines RPC with replication of a program module for providing fault tolerance. In <ref> [12] </ref>, Jalote describes an algorithm for resilient objects in broadcast networks, which reduces the number of messages required to keep copies of the object in a consistent state. The Arjuna 3 system uses the facilities of atomic transactions and naming and binding services for providing the replicated objects [14]. <p> This request give rise to another request from object A to another object B (maybe replicated). Now all the replicas of object A generate this request to object B. These requests are called the images <ref> [12] </ref> of independent requests (toplevel requests). At object B only one of these images should get executed. The scheme [12] proposed by Jalote, uses a unique identifier for the same images (image set) of the independent top level requests. Only one image having this unique identifier is executed. <p> Now all the replicas of object A generate this request to object B. These requests are called the images <ref> [12] </ref> of independent requests (toplevel requests). At object B only one of these images should get executed. The scheme [12] proposed by Jalote, uses a unique identifier for the same images (image set) of the independent top level requests. Only one image having this unique identifier is executed. <p> The server objects are replicated. For obtaining any service the client (this is a non-replicated client) makes an invocation to a replicated object. In the system this client request can be uniquely identifiable, say by a transaction identifier <ref> [12] </ref>. The algorithm attaches a sequence number to every message it handles. We assume that the algorithm for generating the sequence number is deterministic. <p> These stored messages can be discarded after a suitable time-out period. The final comment is about the performance of the hot replication algorithm. To the best of our knowledge, only two previous works <ref> [11, 12] </ref> deal with the problem of fault tolerance of the objects supporting nested object invocations (arbitrary level of nesting) using replication mechanism. (We exclude the checkpointing schemes here, because in situations where we can not use checkpointing, maybe due to the recovery time involved, we have to use replication based <p> problem of fault tolerance of the objects supporting nested object invocations (arbitrary level of nesting) using replication mechanism. (We exclude the checkpointing schemes here, because in situations where we can not use checkpointing, maybe due to the recovery time involved, we have to use replication based schemes.) The algorithm in <ref> [12] </ref> can not be meaningfully compared to our algorithm, since it uses a specific broadcast based network (otherwise it requires an ordered reliable broadcast implementation, which will be quite expensive). The algorithm [11] can be compared to hot replication scheme, as given below.
Reference: [13] <author> F. Schneider, </author> <title> "Implementing fault tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client <ref> [2, 3, 12, 13, 14] </ref>). The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols. <p> The first replica acts as the primary, the second replica acts as the backup for to the primary. The replica (incarnation) i + 1 acts as a backup for replica (incarnation) i. The primary forwards the request and reply/results it gets to its secondary/backup. In <ref> [13] </ref>, Fred Schneider presents a detailed model, which he calls a state machine approach for implementing fault tolerant services. They discuss the message agreement and message order requirements for this method. Eric Cooper describes [2] replicated procedure call (RPC) mechanisms for constructing highly available distributed programs.
Reference: [14] <author> M. C. Little, </author> <title> Object Replication in a Distributed System, </title> <type> PhD thesis, </type> <institution> Computer Science Dept., University of Newcastle upon Tyne, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The primary propagates all the necessary information (request/reply messages) to the secondary, so that the secondaries are kept synchronized with the primary. In the case of active replication scheme, all the copies of the objects execute the client request simultaneously and return the result to the client <ref> [2, 3, 12, 13, 14] </ref>). The client selects the results depending on the assumed failure modes. Alsberg and Day [9] proposed one of the earliest primary-backup protocols. <p> In [12], Jalote describes an algorithm for resilient objects in broadcast networks, which reduces the number of messages required to keep copies of the object in a consistent state. The Arjuna 3 system uses the facilities of atomic transactions and naming and binding services for providing the replicated objects <ref> [14] </ref>. The active replication approach for fault tolerance gets complicated when objects can make nested invocations of other objects. Consider a client making a request (top level request) to a replicated object (say object A).
Reference: [15] <author> J. Mitchel et al., </author> <title> "An overview of the spring system," </title> <booktitle> In Proceedings of of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: The objects interact with each other and with the outside world through well defined interfaces. The object interfaces are defined in such a system using some standard interface definition language (IDL), though this fact is not necessary (or assumed). Systems such as SPRING <ref> [15, 16] </ref> provide such features. The objects in the system are active (i.e. the object is always executing for providing services). Objects basically contain the data (also called object state) and code (procedure or methods) to manipulate the object state. <p> Note that even in the checkpointing scheme, for an actual implementation of the assumed stable storage abstraction, we may have to pay this price. As a part of our ongoing Phoenix project, we are implementing this algorithm on the SPRING <ref> [15, 16] </ref> Object Oriented Operating System. 14
Reference: [16] <author> G. Hamilton and P. Kougiouris, </author> <title> "The spring nucleus: A microkernel for objects," </title> <booktitle> In Proc. of 1993 Summer Usenix Conference, </booktitle> <month> June </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: The objects interact with each other and with the outside world through well defined interfaces. The object interfaces are defined in such a system using some standard interface definition language (IDL), though this fact is not necessary (or assumed). Systems such as SPRING <ref> [15, 16] </ref> provide such features. The objects in the system are active (i.e. the object is always executing for providing services). Objects basically contain the data (also called object state) and code (procedure or methods) to manipulate the object state. <p> Note that even in the checkpointing scheme, for an actual implementation of the assumed stable storage abstraction, we may have to pay this price. As a part of our ongoing Phoenix project, we are implementing this algorithm on the SPRING <ref> [15, 16] </ref> Object Oriented Operating System. 14
References-found: 16

