URL: http://www.dfki.uni-kl.de/~vega/relfun+/domexc/domexc.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: boley@informatik.uni-kl.de  
Title: Finite Domains and Exclusions as First-Class Citizens  
Author: Harold Boley 
Note: FUN meta-unify function (and implemented in pure LISP). 1  
Address: Box 2080, 67608 Kaiserslautern, Germany  
Affiliation: DFKI  
Abstract: Languages based on logical variables can regard finite domains, finite exclusions, and, generally, types as values. Like a variable can be bound to a non-ground structure which can be later specialized through in-place assignment of some inner variables, it can also be bound to, say, a domain structure which can be specialized later through `in-place deletion' of some of its elements (e.g. by intersection with other domain structures). While finite domains prescribe the elements of a disjunctive structure, the complementary finite exclusions forbid the elements of a conjunctive structure. Domains and exclusions can be values of variables or occur inside clauses as/in terms or within an occurrence-binding construct (useful to name arbitrary terms). In a relational-functional language (e.g., RELFUN) they can also be returned as values of functions. Altogether, domains and exclusions become first-class citizens. Because they are completely handled by an extended unification routine, they do not require delay techniques needed in (more expressive) constraint systems. Still, their backtracking-superseding `closed' representation leads to smaller proof trees (efficiency), and abstracted, intensional answers (readability). Anti-unification (for generalization) exchanges the roles of domains and exclusions. The operational semantics of domains, exclusions, and occurrence bindings is specified by a REL 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Harold Boley. </author> <title> A Relational/Functional Language and its Compilation into the WAM. </title> <type> Technical Report SEKI SR-90-05, </type> <institution> University of Kaiserslautern, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The second symmetrically `excludes' 2 through 5 from dom [1,2,3], ultimately binding X and Y to dom <ref> [1] </ref> or 1. The third leads to X and Y being bound to the united exclusion exc [1,2,3,4,5]. Note that an exclusion can result from unification only if both respective unification partners are exc structures. <p> On the unification side, an efficient WAM compiler/emulator extension for our (variable-length!) finite domains and exclusions should be written, building on the RELational/FUNctional machine <ref> [1] </ref>, FIDO III [7, 15], and FLIP [14], all in COMMON LISP: WAM instructions for unifying constants such as get constant would need a membership/non-membership test case for dom/exc structures, new instructions get dom/get exc could unify dom/exc structures, performing, e.g., intersection/union for other dom/exc structures (perhaps maintaining canonically ordered elements), <p> Finally, let us explore a possible non-ground extension of the treatment of solved disequations, e.g. X 6= 1, as exclusion bindings, e.g. X is exc <ref> [1] </ref>, if only to confirm that ground exclusions in fact constitute the `local optimum' suggested by section 3: Can we treat unsolved disequations, e.g. X 6= Y, as exclusion bindings with non-ground rhs's, e.g. <p> If further computation instantiates Y to a constant, say 1, perhaps via a binding chain, the disequation reduces to a solved form, X is exc <ref> [1] </ref>, treated as usual. If X thus specializes to a constant, 1, we can `swap' the disequation to a solved form, Y is exc [1], within the substitution. <p> If further computation instantiates Y to a constant, say 1, perhaps via a binding chain, the disequation reduces to a solved form, X is exc <ref> [1] </ref>, treated as usual. If X thus specializes to a constant, 1, we can `swap' the disequation to a solved form, Y is exc [1], within the substitution. For an added disequation, say the unsolved X is exc [Z], the two bindings may be simplified to one, here X is exc [Y,Z].
Reference: 2. <author> Harold Boley. </author> <title> Extended Logic-plus-Functional Programming. </title> <booktitle> In Proceedings of the 2nd International Workshop on Extensions of Logic Programming, ELP '91, Stockholm 1991, volume 596 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: The final step then is to allow domain and exclusion terms also as values returned by functions of functional LP extensions such as RELFUN <ref> [2] </ref>. Altogether, domains and exclusions become first-class citizens of cleanly extended relational, functional, and relational-functional languages. 2 Domain Terms As the predefined term for finite domains we will use variable-length dom structures. <p> types) can treat a larger class of constraints as bindings directly put into the substitution, unlike constraints as delayed goals, they will thus require very careful substitution updates and uses. 21 A The RELFUN Meta-unify Since this RELFUN unification meta-specification in RELFUN is deterministic (fortunately), there are many cuts (unfortunately) <ref> [2] </ref>, which are, however, not needed for obtaining the first (and only) solution, just for preventing (meaningless) attempts to search for more solutions.
Reference: 3. <author> Harold Boley, Ulrich Buhrmann, and Christof Kremer. </author> <title> Towards a Sharable Knowledge Base on Recyclable Plastics. </title> <month> November </month> <year> 1993. </year> <note> To appear in: TMS'94 Symposium on Knowledge-Based Applications in Material Science and Engineering, </note> <institution> Feb/Mar 1994, </institution> <address> San Francisco, USA, TMS, Warrendale PA. </address>
Reference-contexts: Also, if only exclusions are involved, the right-most result of exclusion specializations still is a `negative answer' such as exc [1,2,3,4,5]; if all intermediate values are identical singleton exclusions, a `negative singleton answer' such as exc <ref> [3] </ref> arises. Exclusions can also be used anonymously, with the same advantages as mentioned for anonymous domains (see end of section 2). <p> could extract this from three multiplied out functional clauses): dom [fac,fib,exp](0) :-& 1. % F:dom [exp,sin](0) gives 1, F=exp 20 It will be instructive to observe which particular use of our domain/exclusion extension of LP is most profitable for a real-world representation task, e.g. in the areas of materials engineering <ref> [3] </ref> or calendar management (e.g. just unify two agents' restrictions, "All dates except May 12 and 23" and "Only May 9-13": exc [12-may,23-may] is dom [9-may,...,13-may]).
Reference: 4. <author> Alain Colmerauer. </author> <title> Introduction to Prolog III. </title> <booktitle> In ESPRIT '87, </booktitle> <pages> pages 611-629. </pages> <publisher> North Holland, </publisher> <year> 1987. </year>
Reference-contexts: Thus, while a domain corresponds to a disjunction of solved equalities, an exclusion corresponds to a conjunction of solved disequalities, where `solved' stands for single-variable constraints. General dis-equality constraints were introduced to LP by PROLOG II/III <ref> [4] </ref>. By considering only the special case of solved (dis)equalities we can regard constraints as typed logical variables: all their value specializations can be handled as part of the unification routine of LP languages, without need for the goal-delaying mechanisms on which constraint languages are often based.
Reference: 5. <author> Cornelia Fischer. </author> <title> PANTUDE | An Anti-Unification Algorithm for Expressing Refined Generalizations. </title> <institution> DFKI Kaiserslautern, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: For ease of presentation we will assume that clauses are represented as structures, e.g. regarding an atom (fact) as a structure whose constructor stands for the predicate. Domain anti-unification of two structures works like classic anti-unification [11] (in our implementation, <ref> [5] </ref>, (nested) structures having different constructors or arities yield a new variable) with the following modifications. For a (named or anonymous) variable and a domain it yields a variable in the manner classic anti-unification handles variable/constant pairings. <p> Concerning domain/exclusion anti-unification, it will be interesting to see how further inductive-LP or machine-learning methods based on classic anti-unification may profit from the domain/exclusion extension, using our recent LISP implementation <ref> [5] </ref> of the rules introduced in section 7.
Reference: 6. <author> Philipp Hanschke. </author> <title> A Declarative Integration of Terminological, Constraint-based, Data-driven, and Goal-directed Reasoning. </title> <institution> Research Report RR-93-46, DFKI Kaiserslautern, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Also, it could be studied how our specialized finite domains/exclusions could be fruitfully characterized as a CLP (F D)-like instance of the constraint-logic programming scheme [8], and if they could be usefully combined with our RELFUN-implemented finite-domain constraints FINDOM [13] or those in FIDO [10], or with concrete domains <ref> [6] </ref>, or other, more general constraint formalisms. Finally, let us explore a possible non-ground extension of the treatment of solved disequations, e.g. X 6= 1, as exclusion bindings, e.g.
Reference: 7. <author> Hans-Gunter Hein. </author> <title> Propagation Techniques in WAM-based Architectures | The FIDO-III Approach. </title> <note> DFKI Technical Memo TM-93-04, DFKI Kaiserslautern, Oc-tober 1993. </note>
Reference-contexts: On the unification side, an efficient WAM compiler/emulator extension for our (variable-length!) finite domains and exclusions should be written, building on the RELational/FUNctional machine [1], FIDO III <ref> [7, 15] </ref>, and FLIP [14], all in COMMON LISP: WAM instructions for unifying constants such as get constant would need a membership/non-membership test case for dom/exc structures, new instructions get dom/get exc could unify dom/exc structures, performing, e.g., intersection/union for other dom/exc structures (perhaps maintaining canonically ordered elements), etc.
Reference: 8. <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Munich, Germany, </address> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: Also, it could be studied how our specialized finite domains/exclusions could be fruitfully characterized as a CLP (F D)-like instance of the constraint-logic programming scheme <ref> [8] </ref>, and if they could be usefully combined with our RELFUN-implemented finite-domain constraints FINDOM [13] or those in FIDO [10], or with concrete domains [6], or other, more general constraint formalisms. Finally, let us explore a possible non-ground extension of the treatment of solved disequations, e.g.
Reference: 9. <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Hei-delberg, New York, </address> <year> 1987. </year>
Reference-contexts: However, this would lose the combinatorial efficiency advantage of finite domains. Also, their complementarity with finite exclusions, not allowing this treatment, would become occluded. For a model-theoretic characterization <ref> [9] </ref> of programs containing first-class finite domains, the multout transformation could also be exploited semantically. Of course, a characterization via a domain-extended Herbrand base would be more `direct'. <p> An area for further theoretical work would be the extension of Herbrand models for finite domains and, more demanding (perhaps via T P # ! <ref> [9] </ref>), finite exclusions. Concerning domain/exclusion anti-unification, it will be interesting to see how further inductive-LP or machine-learning methods based on classic anti-unification may profit from the domain/exclusion extension, using our recent LISP implementation [5] of the rules introduced in section 7.
Reference: 10. <author> Manfred Meyer and Jorg Muller. </author> <title> Solving Configuration Tasks Efficiently Using Finite Domain Consistency Techniques. </title> <journal> International Journal of Applied Intelligence, </journal> <note> 1994. To appear. </note>
Reference-contexts: Also, it could be studied how our specialized finite domains/exclusions could be fruitfully characterized as a CLP (F D)-like instance of the constraint-logic programming scheme [8], and if they could be usefully combined with our RELFUN-implemented finite-domain constraints FINDOM [13] or those in FIDO <ref> [10] </ref>, or with concrete domains [6], or other, more general constraint formalisms. Finally, let us explore a possible non-ground extension of the treatment of solved disequations, e.g. X 6= 1, as exclusion bindings, e.g.
Reference: 11. <author> Gordon D. Plotkin. </author> <title> A Note on Inductive Generalization. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 5, </volume> <pages> pages 153-163. </pages> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1970. </year>
Reference-contexts: For ease of presentation we will assume that clauses are represented as structures, e.g. regarding an atom (fact) as a structure whose constructor stands for the predicate. Domain anti-unification of two structures works like classic anti-unification <ref> [11] </ref> (in our implementation, [5], (nested) structures having different constructors or arities yield a new variable) with the following modifications. For a (named or anonymous) variable and a domain it yields a variable in the manner classic anti-unification handles variable/constant pairings.
Reference: 12. <author> Luc De Raedt. </author> <title> Interactive Theory Revision An Inductive Logic Programming Approach. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1992. </year>
Reference-contexts: This may be exploited for `theory revision' <ref> [12] </ref> of knowledge bases containing exclusion terms. 8 Operational Semantics Since all user-defined relations and functions are invoked through unification, we were able to handle the relational-functional domain extensions in a uniform, efficient manner by building our first-class domain and exclusion notions, as well as the larger part of our bnds,
Reference: 13. <author> Michael Sintek. </author> <title> FINDOM | Finite Domains in RELFUN Via Simulated Reassignment Variables. </title> <institution> DFKI Kaiserslautern, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Also, it could be studied how our specialized finite domains/exclusions could be fruitfully characterized as a CLP (F D)-like instance of the constraint-logic programming scheme [8], and if they could be usefully combined with our RELFUN-implemented finite-domain constraints FINDOM <ref> [13] </ref> or those in FIDO [10], or with concrete domains [6], or other, more general constraint formalisms. Finally, let us explore a possible non-ground extension of the treatment of solved disequations, e.g. X 6= 1, as exclusion bindings, e.g.
Reference: 14. <author> Michael Sintek. </author> <title> FLIP: Functional-plus-Logic Programming on an Integrated Platform. </title> <booktitle> 3rd Workshop on Functional Logic Programming, </booktitle> <address> Schwarzenberg, Germany, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: On the unification side, an efficient WAM compiler/emulator extension for our (variable-length!) finite domains and exclusions should be written, building on the RELational/FUNctional machine [1], FIDO III [7, 15], and FLIP <ref> [14] </ref>, all in COMMON LISP: WAM instructions for unifying constants such as get constant would need a membership/non-membership test case for dom/exc structures, new instructions get dom/get exc could unify dom/exc structures, performing, e.g., intersection/union for other dom/exc structures (perhaps maintaining canonically ordered elements), etc.
Reference: 15. <author> Werner Stein. </author> <title> Nutzung globaler Analysetechniken in einem optimierenden Compiler fur die Constraint-Logic-Programming-Sprache FIDO III. </title> <institution> Diplomarbeit, Uni-versitat Kaiserslautern, FB Informatik, </institution> <month> Juli </month> <year> 1993. </year>
Reference-contexts: On the unification side, an efficient WAM compiler/emulator extension for our (variable-length!) finite domains and exclusions should be written, building on the RELational/FUNctional machine [1], FIDO III <ref> [7, 15] </ref>, and FLIP [14], all in COMMON LISP: WAM instructions for unifying constants such as get constant would need a membership/non-membership test case for dom/exc structures, new instructions get dom/get exc could unify dom/exc structures, performing, e.g., intersection/union for other dom/exc structures (perhaps maintaining canonically ordered elements), etc.

References-found: 15

