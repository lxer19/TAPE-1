URL: http://www.research.microsoft.com/~ymwang/papers/FTCS-1995-C.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/FTCS95CR.htm
Root-URL: http://www.research.microsoft.com
Title: Checkpointing and Its Applications  
Author: Yi-Min Wang, Yennun Huang, Kiem-Phong Vo, Pi-Yu Chung and Chandra Kintala 
Date: 22-31, June 1995.  
Note: in Proc. IEEE Fault-Tolerant Computing Symp. (FTCS-25), pp.  
Abstract: This paper describes our experience with the implementation and applications of the Unix checkpointing library libckp, and identifies two concepts that have proven to be the key to making checkpointing a powerful tool. First, including all persistent state, i.e., user files, as part of the process state that can be checkpointed and recovered provides a truly transparent and consistent rollback. Second, excluding part of the persistent state from the process state allows user programs to process future inputs from a desirable state, which leads to interesting new applications of checkpointing. We use real-life examples to demonstrate the use of libckp for bypassing premature software exits, for fast initialization and for memory rejuvenation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Litzkow and M. Solomon, </author> <title> Supporting checkpointing and process migration ouside the Unix, </title> <booktitle> in Proc. Usenix Winter Conference, </booktitle> <year> 1992. </year>
Reference-contexts: To our knowledge, existing Unix checkpoint libraries handle only active files, i.e., opened and not yet closed, at the time when a checkpoint is taken <ref> [1, 2] </ref>. Therefore, only part of the persistent state is included in the process state, as shown in Figure 1 (a). Moreover, what part of the persistent state is checkpointed depends on when the checkpoint is taken. <p> It saves and restores the data segments of user applications as well as dynamic shared libraries, stack segment and pointer, program counter, file descriptors, signal masks and handlers, etc. Compared with other existing Unix checkpoint libraries <ref> [1, 2] </ref>, libckp has the following unique features which we have found crucial for making check-pointing and recovery an attractive tool to the users. 1. The library includes user files as part of the process state that is checkpointed and recovered.
Reference: [2] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li, Libckpt: </author> <title> Transparent checkpointing under Unix, </title> <booktitle> in Proc. Usenix Technical Conference, </booktitle> <pages> pp. 213-224, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: To our knowledge, existing Unix checkpoint libraries handle only active files, i.e., opened and not yet closed, at the time when a checkpoint is taken <ref> [1, 2] </ref>. Therefore, only part of the persistent state is included in the process state, as shown in Figure 1 (a). Moreover, what part of the persistent state is checkpointed depends on when the checkpoint is taken. <p> It saves and restores the data segments of user applications as well as dynamic shared libraries, stack segment and pointer, program counter, file descriptors, signal masks and handlers, etc. Compared with other existing Unix checkpoint libraries <ref> [1, 2] </ref>, libckp has the following unique features which we have found crucial for making check-pointing and recovery an attractive tool to the users. 1. The library includes user files as part of the process state that is checkpointed and recovered.
Reference: [3] <author> R. E. Strom, , S. A. Yemini, and D. F. Bacon, </author> <title> A recoverable object store, </title> <booktitle> in Proc. Hawaii International Conference on System Sciences, </booktitle> <pages> pp. </pages> <address> II-215-II-221, </address> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Section 4 gives examples to illustrate how transient software failures can be recovered by automatic environment diversity, and how permanent software failures can also be recovered by intro 3 Strom et al. described a disk checkpoint manager for checkpointing disk files in a self-recovering distributed operating system <ref> [3] </ref>. In contrast, our approach has focused on developing application-level techniques that can be incorporated into existing standard Unix applications. ducing environment diversity, for example, through process migration [5]. <p> If a failure occurs later on, the shadow copy and the recorded size can be used to restore fileapp to have both correct contents and correct size. A natural optimization to further reduce both run-time and space overhead is to perform the shadowing on a page-by-page basis <ref> [3] </ref>. 4 Bypassing Premature Software Exits Design diversity [15, 16] and data diversity [17] are two well-known approaches to software fault tolerance.
Reference: [4] <author> Y. M. Wang and W. K. Fuchs, </author> <title> Lazy checkpoint coordination for bounding rollback propagation, </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 78-85, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The key concept behind this technique is that checkpointing a single-process application can no longer be achieved with a single snapshot, and lazy checkpoint coordination <ref> [4] </ref> can be used to make globally consistent checkpointing feasible. restarts from a checkpoint, it can have a different behavior if the OS environment is different. <p> By means of dependency tracking for file operations, we use lazy checkpoint coordination <ref> [4] </ref> to make checkpointing persistent state feasible. The basic concept of lazy coordination is that checkpoints for coordination purpose need not be taken at the time of checkpoint initiation by the initiating process; they can be delayed until the state inconsistency due to message dependency is about to occur.
Reference: [5] <author> F. Douglis and J. Ousterhout, </author> <title> Transparent process migration: Design alternatives and the Sprite implementation, </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 21, No. 8, </volume> <pages> pp. 757-785, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: In contrast, our approach has focused on developing application-level techniques that can be incorporated into existing standard Unix applications. ducing environment diversity, for example, through process migration <ref> [5] </ref>. When a checkpoint includes all volatile state and persistent state, the recovered process is expected to perform basically the same functions as was the failed process (except for the possibly different execution for bypassing software bugs).
Reference: [6] <author> G. S. Fowler, D. G. Korn, J. J. Snyder, and K.-P. Vo, </author> <title> Feature-based portability, </title> <booktitle> in Proc. VHLL Usenix Symposium on Very High Level Languages, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: They together provide powerful execution controls for many interesting applications. 4. To maximize the portability, we use a feature extrac-tion tool IFFE (IF Features Exist) <ref> [6] </ref> at compilation time to determine which part of the code to activate, and a dynamic probing technique at run time to deter mine the boundaries of the stack and data segments.
Reference: [7] <author> W.-J. Sun and C. Sechen, </author> <title> Efficient and effective placement for very large circuits, </title> <booktitle> in Proc. IEEE International Conference on Computer-Aided-Design, </booktitle> <pages> pp. 170-177, </pages> <year> 1993. </year>
Reference-contexts: Table 1 shows the overhead measurement for 14 long-running programs including CAD applications, simulation programs and signal processing applications. TimberWolf <ref> [7] </ref> is a complete timing-driven placement and global routing package applicable to row-based and building-block design styles.
Reference: [8] <author> H. Kriplani, F. Najm, and I. Hajj, </author> <title> Pattern independent maximum current estimation in power and ground buses of CMOS VLSI circuits: Algorithms, signal correlations and their resolution. </title> <journal> submitted to IEEE Transactions on Computer-Aided Design, </journal> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Table 1 shows the overhead measurement for 14 long-running programs including CAD applications, simulation programs and signal processing applications. TimberWolf [7] is a complete timing-driven placement and global routing package applicable to row-based and building-block design styles. Vdrop <ref> [8] </ref> is a maximum voltage drop verification package. (The simulated annealing part of the package was used in the experiments.) ACCORD (Automatic Checking and CORrection of Design errors) [9] is a tool to verify a logic circuit implementation and correct logic design errors by formal methods.
Reference: [9] <author> P. Y. Chung, Y. M. Wang, and I. N. Hajj, </author> <title> Diagnosis and correction of logic design errors in digital circuits, </title> <booktitle> in Proc. the 30th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 503-508, </pages> <year> 1993. </year>
Reference-contexts: TimberWolf [7] is a complete timing-driven placement and global routing package applicable to row-based and building-block design styles. Vdrop [8] is a maximum voltage drop verification package. (The simulated annealing part of the package was used in the experiments.) ACCORD (Automatic Checking and CORrection of Design errors) <ref> [9] </ref> is a tool to verify a logic circuit implementation and correct logic design errors by formal methods. Galant [10] is a delay-area optimization package for ASIC design using a standard-cell library approach. Simulated annealing was used to implement the optimizer. CADsyn is a commercial CAD synthesis program.
Reference: [10] <author> W. Chuang, S. S. Sapatnekar, and I. N. Hajj, </author> <title> Timing and area optimization for standard-cell VLSI circuit design, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <note> to appear. </note>
Reference-contexts: Vdrop [8] is a maximum voltage drop verification package. (The simulated annealing part of the package was used in the experiments.) ACCORD (Automatic Checking and CORrection of Design errors) [9] is a tool to verify a logic circuit implementation and correct logic design errors by formal methods. Galant <ref> [10] </ref> is a delay-area optimization package for ASIC design using a standard-cell library approach. Simulated annealing was used to implement the optimizer. CADsyn is a commercial CAD synthesis program.
Reference: [11] <author> D. Hill, D. Shugard, J. Fishburn, and K. Keutzer, </author> <title> Algorithms and Techniques for VLSI Layout Synthesis. </title> <publisher> Kluwer, </publisher> <year> 1989. </year>
Reference-contexts: Galant [10] is a delay-area optimization package for ASIC design using a standard-cell library approach. Simulated annealing was used to implement the optimizer. CADsyn is a commercial CAD synthesis program. TILOS <ref> [11] </ref> is a commercial transistor sizing package for minimizing the sum of transistor sizes in synchronous CMOS circuits according to performance specifications. (The input circuit used for the experiment is a 15,498-transistor subcircuit of a commercial microprocessor.) DBsim is a program for simulating database creation, traversal and reorganization.
Reference: [12] <author> A. Flora-Holmquist and M. Staskauskas, </author> <title> Software design technology for communication systems reliability, </title> <booktitle> in Proc. 1994 International Conference on Communication Technology, </booktitle> <month> June </month> <year> 1994. </year> <note> (a) </note>
Reference-contexts: Csim is a simulation program for coded channel in wireless communications. LPC2TD is a speech processing program for efficient coding of LPC (Linear Predictive Coding) parameters by temporal decomposition. HERest is a model training program for speech recognition. VFSM (Virtual Finite State Machine) <ref> [12] </ref> validator is a program that exhaustively generates possible execution sequences of a network of communicating processes, checking for errors in process interaction such as deadlock, livelock and unexpected inputs. (The example used in the experiment consisted of three VFSMs representing a protocol for signalling the digits of a telephone number
Reference: [13] <author> K. M. Chandy and L. Lamport, </author> <title> Distributed snapshots: Determining global states of distributed systems, </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> Vol. 3, No. 1, </volume> <pages> pp. 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: size 0.3M 2.8M 17M 9M Checkpoint type local local remote remote Overhead (time) 5m 0 9m 17m Overhead (%) 1.45% 0% 3.07% 4.7% of persistent state. volatile state and the persistent state as a multiple-process system, the file operations as inter-process communications, and the consistency problem as a checkpoint coordination <ref> [13, 14] </ref> problem. By means of dependency tracking for file operations, we use lazy checkpoint coordination [4] to make checkpointing persistent state feasible.
Reference: [14] <author> R. Koo and S. Toueg, </author> <title> Checkpointing and rollback-recovery for distributed systems, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-13, No. 1, </volume> <pages> pp. 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: size 0.3M 2.8M 17M 9M Checkpoint type local local remote remote Overhead (time) 5m 0 9m 17m Overhead (%) 1.45% 0% 3.07% 4.7% of persistent state. volatile state and the persistent state as a multiple-process system, the file operations as inter-process communications, and the consistency problem as a checkpoint coordination <ref> [13, 14] </ref> problem. By means of dependency tracking for file operations, we use lazy checkpoint coordination [4] to make checkpointing persistent state feasible.
Reference: [15] <author> A. Avizienis, </author> <title> The N-version approach to fault-tolerant software, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-11, No. 12, </volume> <pages> pp. 1491-1501, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: A natural optimization to further reduce both run-time and space overhead is to perform the shadowing on a page-by-page basis [3]. 4 Bypassing Premature Software Exits Design diversity <ref> [15, 16] </ref> and data diversity [17] are two well-known approaches to software fault tolerance.
Reference: [16] <author> B. Randell, </author> <title> System structure for software fault tolerance, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-1, No. 2, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: A natural optimization to further reduce both run-time and space overhead is to perform the shadowing on a page-by-page basis [3]. 4 Bypassing Premature Software Exits Design diversity <ref> [15, 16] </ref> and data diversity [17] are two well-known approaches to software fault tolerance.
Reference: [17] <author> P. E. Ammann and J. C. Knight, </author> <title> Data diversity: An approach to software fault-tolerance, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 37, No. 4, </volume> <pages> pp. 418-425, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: A natural optimization to further reduce both run-time and space overhead is to perform the shadowing on a page-by-page basis [3]. 4 Bypassing Premature Software Exits Design diversity [15, 16] and data diversity <ref> [17] </ref> are two well-known approaches to software fault tolerance.
Reference: [18] <author> D. Fell, </author> <title> The Essential Gardener. </title> <address> Avenel, NJ: </address> <publisher> Crescent Books, </publisher> <year> 1993. </year>
Reference-contexts: This feature has been used in a database simulator to save 40% of the total execution time. 6 Memory Rejuvenation Ordinary trees need selective pruning to make them grow better; overgrown and untidy old shrubs need rejuvenation, a drastic take it to the ground pruning technique <ref> [18] </ref>. Similarly, normal program executions need careful resource management to maintain performance; long-running applications with accumulated undesirable resource states need rejuvenation, a drastic total recall resource dealloca-tion technique.
Reference: [19] <author> K.-P. Vo, </author> <title> Writing reusable libraries with disciplines and methods, </title> <booktitle> in submitted to ACM SIGSOFT Symposium on Software Reusability, </booktitle> <year> 1995. </year>
Reference-contexts: all useful state that still remains in memory is flushed to the disk and the volatile state is rolled back to init state except that the loop index i retains its value to ensure correct progress. 4 This is a reason why a new Virtual Memory ALLOCation package (or vmalloc) <ref> [19] </ref> allows specifying exception handlers that will be called when memory space is out so that garbage collection can be performed at program; (b) with rejuvenation. On-line memory rejuvenation as shown in Figure 8 (b) is particularly valuable for applications requiring a long initialization procedure.
Reference: [20] <author> R. Hastings and B. Joyce, Purify: </author> <title> Fast detection of memory leaks and access errors, </title> <booktitle> in Proc. Winter Usenix Conference, </booktitle> <pages> pp. 125-136, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: For example, it would certainly be desirable if memory leakage problem can be identified and corrected, and there exist several commercial software tools such as Purify <ref> [20] </ref> and Sentinel [21] to help software developers to detect the problem.
Reference: [21] <author> A. S. Corporation, </author> <title> SENTINEL run-time analysis tool: User's guide. </title> <year> 1994. </year>
Reference-contexts: For example, it would certainly be desirable if memory leakage problem can be identified and corrected, and there exist several commercial software tools such as Purify [20] and Sentinel <ref> [21] </ref> to help software developers to detect the problem. But when an application is using an imported software package and memory leakage is inside that package, the problem may be detectable but may not be correctable due to the unavailability of source code or limited knowledge of the program structure.
Reference: [22] <author> H.-J. Boehm and M. Weiser, </author> <title> Garbage collection in an uncooperative environment, </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 18, No. 9, </volume> <pages> pp. 807-820, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: But when an application is using an imported software package and memory leakage is inside that package, the problem may be detectable but may not be correctable due to the unavailability of source code or limited knowledge of the program structure. Garbage collectors <ref> [22] </ref> can be used to perform on-line garbage collection to alleviate the memory leakage problem, but it has certain limitations 5 and also cannot solve the problem caused by memory caching. Memory rejuvenation is essentially a user-invoked garbage collector which exploits application-specific information to perform drastic and effective memory reclamation.
References-found: 22

