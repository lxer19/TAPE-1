URL: http://www.cs.cornell.edu/kozen/686/Vardi/cav972.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: http://www.cs.umass.edu/~immerman, immerman@cs.umass.edu  http://www.cs.rice.edu/~vardi, vardi@cs.rice.edu  
Phone: 2  
Title: Model Checking and Transitive-Closure Logic  
Author: Neil Immerman ?? and Moshe Y. Vardi ??? 
Address: Amherst, MA 01003,  Houston, TX 77005-1892,  
Affiliation: 1 Computer Science Dept., University of Massachusetts,  Computer Science Dept., Rice University,  
Abstract: We give a linear-time algorithm to translate any formula from computation tree logic (CTL or CTL*) into an equivalent expression in a variable-confined fragment of transitive-closure logic FO(TC). Traditionally, CTL and CTL ? have been used to express queries for model checking and then translated into -calculus for symbolic evaluation. Evaluation of -calculus formulas is, however, complete for time polynomial in the (typically huge) number of states in the Kripke structure. Thus, this is often not feasible, not parallelizable, and efficient incremental strategies are unlikely to exist. By contrast, evaluation of any formula in FO(TC) requires only NSPACE[log n]. This means that the space requirements are manageable, the entire computation is paralleliz able, and efficient dynamic evaluation is possible.
Abstract-found: 1
Intro-found: 1
Reference: [BBG94] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman and M. Yoel, </author> <title> "Methodology and System for Practical Formal Verification of Reactive Hardware," </title> <booktitle> in Computer Aided Verification, Proc. 6th Int. Conference, </booktitle> <editor> D. L. Dill, ed., </editor> <publisher> LNCS 818, </publisher> <address> 1994, </address> <publisher> Springer-Verlag, </publisher> <pages> 182-193. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in [BCM92, CES86, LP85, QS81, VW86] has been gaining widespread acceptance lately (see <ref> [BBG94] </ref>). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi and P. Wolper, </author> <title> "An Automata-Theoretic Approach to Branching-Time Model Checking," </title> <booktitle> in Computer Aided Verification, Proc. 6th Int. Conference, </booktitle> <editor> D. L. Dill, ed., </editor> <publisher> LNCS 818, </publisher> <address> 1994, </address> <publisher> Springer-Verlag, </publisher> <pages> 142-155. </pages>
Reference-contexts: Consider the model checking problem for CTL ? in which we fix a query ' 2 CTL ? and vary the Kripke structure K. The complexity of this problem, called program complexity in [VW86] and data complexity in [Var82], is known to be NSPACE [log n] <ref> [BVW94] </ref> for CTL ? . Here n is the size of the Kripke structure as we have mentioned, n is often exponential in the size of the design being verified. <p> The standard way to perform symbolic model checking using CTL ? is to translate the query to the modal -calculus [Koz83, EL86]. A problem with this is that the data complexity of the modal -calculus is polynomial-time complete <ref> [BVW94] </ref> (cf. [I86, Var82]). This means that evaluation of modal -calculus queries most likely requires polynomial space, is not parallelizable, and efficient incremental evaluation strategies are unlikely to exist. <p> Fact 4 ([I86, Var82]) The queries computable in polynomial time are exactly those expressible in FO (LFP). While the modal -calculus is a proper subset of FO (LFP), it still contains problems complete for polynomial-time <ref> [BVW94] </ref>. Since the model checking problem for CTL ? is contained in NSPACE [log n], it would be much better to interpret CTL ? in a logic with this lower complexity. <p> It is not hard to see that Fact 12 NSPACE [n] = MSO (TC): Thus, the CTL and CTL ? queries are all checkable in nondeterministic linear space <ref> [BVW94] </ref>. Here the space is linear in n, the size of the design of the circuit or protocol to be verified, not 2 n , the size of the Kripke structure K (A). It is important in our simulations that we used as few variables as possible.
Reference: [BCM92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill and L.J. Hwang, </author> <title> "Symbolic Model Checking: 10 20 States and Beyond," </title> <booktitle> Information and Computation 98(2) (1992), </booktitle> <pages> 142-170. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in <ref> [BCM92, CES86, LP85, QS81, VW86] </ref> has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K. <p> The model checking performed using these symbolic representations is called symbolic model checking <ref> [BCM92, McM93] </ref>. The correctness conditions ' i described above can be thought of as queries to the Kripke structure. In fact, in this paper we emphasize the close relationship between model checking and database query evaluation (cf. [Var97]). Optimization of the queries is crucial.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson, </author> <title> "Design and Synthesis of Synchronization Skeletons Using Branching Time Temporal Logic," </title> <booktitle> in Proc. Workshop on Logic of Programs, LNCS 131, 1981, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 52-71. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in <ref> [CE81] </ref> and developed further in [BCM92, CES86, LP85, QS81, VW86] has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson and A.P. Sistla, "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) (1986), </volume> <pages> 244-263. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in <ref> [BCM92, CES86, LP85, QS81, VW86] </ref> has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K.
Reference: [EF95] <author> H.-D. Ebbinghaus, J. Flum, </author> <title> Finite Model Theory 1995, </title> <publisher> Springer 1995. </publisher>
Reference-contexts: This has been studied in great detail. See for example <ref> [EF95, I89, LR96, Var82] </ref>. Let FO be the set of first-order expressible properties.
Reference: [Eme90] <author> E.A. Emerson, </author> <title> "Temporal and modal logic," </title> <booktitle> in Handbook of theoretical computer science, </booktitle> <year> 1990, </year> <pages> 997-1072. </pages>
Reference-contexts: For any first-order formula ', we will use the notation K ? j= ' to mean that ' is true in K ? . We use in this paper the computation tree logics CTL and CTL ? . For definitions of syntax and semantics of these logics see <ref> [Eme90] </ref>. The modal -calculus is a propositional modal logic that includes the least fixed point operator () [Koz83, Eme97]. The modal -calculus is strictly more expressive than CTL ? , and has polynomial-time data complexity (see next section).
Reference: [Eme97] <author> E. A. Emerson, </author> <title> "Model Checking and the Mu-Calculus," in Descriptive Complexity and Finite Models, </title> <editor> N. Immerman and Ph. Kolaitis, eds., </editor> <booktitle> 1997, </booktitle> <publisher> American Mathematical Society. </publisher>
Reference-contexts: We use in this paper the computation tree logics CTL and CTL ? . For definitions of syntax and semantics of these logics see [Eme90]. The modal -calculus is a propositional modal logic that includes the least fixed point operator () <ref> [Koz83, Eme97] </ref>. The modal -calculus is strictly more expressive than CTL ? , and has polynomial-time data complexity (see next section). <p> As an example, we can write the CTL formula EFp as a least fixed point, EFp Y (p _ hRiY ) (1) Equation 1 can be generalized to show that all of CTL ? can be interpreted in the modal -Calculus. See <ref> [Eme97, Var97] </ref> for details. Fact 2 * There is a linear time algorithm that translates any formula in CTL into an equivalent formula in the modal -calculus. * There is an exponential time algorithm that translates any formula in CTL ? into an equivalent formula in the modal -calculus.
Reference: [EL86] <author> E.A. Emerson and C.-L. Lei, </author> <title> "Efficient Model Checking in Fragments of the Propositional mu-Calculus," </title> <booktitle> Proc. 1st Symp. on Logic in Computer Science (1986), </booktitle> <pages> 267-278. </pages>
Reference-contexts: Here n is the size of the Kripke structure as we have mentioned, n is often exponential in the size of the design being verified. The standard way to perform symbolic model checking using CTL ? is to translate the query to the modal -calculus <ref> [Koz83, EL86] </ref>. A problem with this is that the data complexity of the modal -calculus is polynomial-time complete [BVW94] (cf. [I86, Var82]). This means that evaluation of modal -calculus queries most likely requires polynomial space, is not parallelizable, and efficient incremental evaluation strategies are unlikely to exist.
Reference: [EVW97] <author> K. Etessami, M.Y. Vardi, and T. Wilke, </author> <title> "First-Order Logic with Two Variables and Unary Temporal Logic," </title> <booktitle> Proc. 12th IEEE Symp. on Logic in Computer Science, </booktitle> <month> July </month> <year> 1997. </year>
Reference-contexts: It is an interesting open open question how many boolean variables are needed in the worst case. (For example, in the context of linear temporal logic, analogous translations are known that use no boolean variables <ref> [EVW97] </ref>.) Experiments need to be performed concerning practical aspects of using FO (TC) as a language for expressing correctness queries. While the straightforward approach for adopting transitive-clousre algorithms to symbolic model checking have failed [TBK95], more sophisticated transitive-closure algorithms (see [Ya90]) might be quite useful for symbolic model checking.
Reference: [I86] <author> N. Immerman, </author> <title> "Relational Queries Computable in Polynomial Time," </title> <journal> Information and Control, </journal> <volume> 68 (1986), </volume> <pages> 86-104. </pages>
Reference-contexts: The standard way to perform symbolic model checking using CTL ? is to translate the query to the modal -calculus [Koz83, EL86]. A problem with this is that the data complexity of the modal -calculus is polynomial-time complete [BVW94] (cf. <ref> [I86, Var82] </ref>). This means that evaluation of modal -calculus queries most likely requires polynomial space, is not parallelizable, and efficient incremental evaluation strategies are unlikely to exist.
Reference: [I87] <author> N. Immerman, </author> <title> "Languages That Capture Complexity Classes," </title> <journal> SIAM J. Comput. </journal> <volume> 16(4) (1987), </volume> <pages> 760-778. </pages>
Reference-contexts: In fact, the resulting formulas have only two first-order variables. The resulting logic, denoted FO 2 (TC), is known to have a data complexity of NSPACE [log n] <ref> [I87, Var82] </ref>. This means that the space requirements are manageable, the entire computation is parallelizable, and entire computation is parallelizable, and efficient incremental evaluation is possible (see, for example, [PI94, ZSS94]).
Reference: [I88] <author> N. Immerman, </author> <title> "Nondeterministic Space is Closed Under Complementation," </title> <journal> SIAM J. Comput. </journal> <volume> 17(5) (1988), </volume> <pages> 935-938. </pages>
Reference: [I89] <author> N. Immerman, </author> <title> "Descriptive and Computational Complexity,"in Computational Complexity Theory, </title> <editor> ed. J. Hartmanis, </editor> <booktitle> Lecture Notes for AMS Short Course on Computational Complexity Theory, Proc. Symp. in Applied Math. 38, American Mathematical Society (1989), </booktitle> <pages> 75-91. </pages>
Reference-contexts: This has been studied in great detail. See for example <ref> [EF95, I89, LR96, Var82] </ref>. Let FO be the set of first-order expressible properties. <p> Even within FO (TC), there is a hierarchy of how many varables we need, and how many boolean variables in FO 2 (TC). There is a well-developed theory in the context of finite-model theory of the relationship between descriptive complexity and computational complexity <ref> [I89] </ref>. This understanding could be also important in computer-aided verification. 6 Conclusions and Future Work We have shown that every formula in CTL ? may be translated in linear time to an equivalent formula in transitive closure-logic, FO (TC).
Reference: [I89a] <author> N. Immerman, </author> <title> Expressibility and Parallel Complexity, </title> <journal> SIAM J. of Comput 18 (1989), </journal> <pages> 625-638. </pages>
Reference-contexts: The class FO captures the complexity class AC 0 consisting of those properties checkable by bounded depth polynomial-size circuits. This is equal to the set of properties computable in constant time on a concurrent parallel random access machine that has at most polynomially many processors <ref> [I89a] </ref>. To obtain a richer class of queries, let FO (LFP) be first-order logic extended by a least-fixed-point operator. This is the closure of first-order logic under the power to define new relations by induction.
Reference: [I91] <author> N. Immerman, </author> <title> "DSPACE[n k ] = VAR[k + 1]," </title> <booktitle> Sixth IEEE Structure in Complexity Theory Symp. </booktitle> <month> (July, </month> <year> 1991), </year> <pages> 334-340. </pages>
Reference-contexts: Boolean variables are essentially first-order variables that are restricted to range only over the first two elements of the universe, which we fix as 0 and 1. Including also boolean variables makes the definition of FO k more robust <ref> [I91] </ref>.
Reference: [Koz83] <author> D. Kozen, </author> <title> "Results on the Propositional -Calculus," </title> <booktitle> Theoretical Computer Science, 27 (1983), </booktitle> <pages> 333-354. </pages>
Reference-contexts: Here n is the size of the Kripke structure as we have mentioned, n is often exponential in the size of the design being verified. The standard way to perform symbolic model checking using CTL ? is to translate the query to the modal -calculus <ref> [Koz83, EL86] </ref>. A problem with this is that the data complexity of the modal -calculus is polynomial-time complete [BVW94] (cf. [I86, Var82]). This means that evaluation of modal -calculus queries most likely requires polynomial space, is not parallelizable, and efficient incremental evaluation strategies are unlikely to exist. <p> We use in this paper the computation tree logics CTL and CTL ? . For definitions of syntax and semantics of these logics see [Eme90]. The modal -calculus is a propositional modal logic that includes the least fixed point operator () <ref> [Koz83, Eme97] </ref>. The modal -calculus is strictly more expressive than CTL ? , and has polynomial-time data complexity (see next section).
Reference: [LR96] <author> R. Lassaigne and M. de Rougemont, Logique et Complexite, </author> <year> 1996, </year> <pages> Hermes. </pages>
Reference-contexts: This has been studied in great detail. See for example <ref> [EF95, I89, LR96, Var82] </ref>. Let FO be the set of first-order expressible properties.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli, </author> <title> "Checking that Finite State Concurrent Programs Satisfy their Linear Specification" Proc. </title> <booktitle> 12th ACM Symp. on Principles of Programming Languages (1985), </booktitle> <pages> 97-107. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in <ref> [BCM92, CES86, LP85, QS81, VW86] </ref> has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K.
Reference: [McM93] <author> K. McMillan, </author> <title> Symbolic Model Checking, 1993, </title> <publisher> Kluwer. </publisher>
Reference-contexts: The model checking performed using these symbolic representations is called symbolic model checking <ref> [BCM92, McM93] </ref>. The correctness conditions ' i described above can be thought of as queries to the Kripke structure. In fact, in this paper we emphasize the close relationship between model checking and database query evaluation (cf. [Var97]). Optimization of the queries is crucial. <p> Symbolic model checking is typically carried out by first translating the CTL correctness condition into the -calculus <ref> [McM93] </ref>. A drawback of this approach is that model checking of the -calculus uses space polynomial in the size of the usually huge Kripke structure. In the next section we describe transitive-closure logic.
Reference: [Ott] <author> M. Otto, </author> <title> private communication. </title>
Reference-contexts: The use of the finiteness of the Kripke structures, K ? , in our proofs of Theo rems 6 and 9 is crucial. It is known that CTL cannot be translated to FO (TC) over all structures <ref> [Ott] </ref>. 5 Applications to Symbolic Model Checking The main application of this work is to symbolic model checking. In this situation, the Kripke model is too large to be represented in memory and is instead represented symbolically, often via an OBDD.
Reference: [PI94] <author> S. Patnaik and N. Immerman, </author> <title> "Dyn-FO: A Parallel, Dynamic Complexity Class," </title> <booktitle> Proc. ACM Symp. on Principles of Database Systems (1994), </booktitle> <pages> 210-221. </pages>
Reference-contexts: The resulting logic, denoted FO 2 (TC), is known to have a data complexity of NSPACE [log n] [I87, Var82]. This means that the space requirements are manageable, the entire computation is parallelizable, and entire computation is parallelizable, and efficient incremental evaluation is possible (see, for example, <ref> [PI94, ZSS94] </ref>).
Reference: [QS81] <author> J.P. Queille and J. Sifakis, </author> <title> "Specification and Verification of Concurrent Systems in Cesar," </title> <booktitle> Proc. 5th Int'l Symp. on Programming, LNCS 137, 1981, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 337-351. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in <ref> [BCM92, CES86, LP85, QS81, VW86] </ref> has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K.
Reference: [TBK95] <author> H. J. Touati, R. K. Brayton, and R. P. Kurshan, </author> <title> "Testing language containment for !-automata using BDD's," </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 101-109, </pages> <year> 1995. </year>
Reference-contexts: While the straightforward approach for adopting transitive-clousre algorithms to symbolic model checking have failed <ref> [TBK95] </ref>, more sophisticated transitive-closure algorithms (see [Ya90]) might be quite useful for symbolic model checking. This work suggests a new paradigm for model checking: One can write the conditions to be checked in a very expressive language, e.g., second-order logic or first-order logic with least-fixed point operators or FO (LFP).
Reference: [Var82] <author> M.Y. Vardi, </author> <title> "Complexity of Relational Query Languages," </title> <booktitle> ACM Symp. Theory Of Comput. </booktitle> <year> (1982), </year> <pages> 137-146. </pages>
Reference-contexts: Consider the model checking problem for CTL ? in which we fix a query ' 2 CTL ? and vary the Kripke structure K. The complexity of this problem, called program complexity in [VW86] and data complexity in <ref> [Var82] </ref>, is known to be NSPACE [log n] [BVW94] for CTL ? . Here n is the size of the Kripke structure as we have mentioned, n is often exponential in the size of the design being verified. <p> The standard way to perform symbolic model checking using CTL ? is to translate the query to the modal -calculus [Koz83, EL86]. A problem with this is that the data complexity of the modal -calculus is polynomial-time complete [BVW94] (cf. <ref> [I86, Var82] </ref>). This means that evaluation of modal -calculus queries most likely requires polynomial space, is not parallelizable, and efficient incremental evaluation strategies are unlikely to exist. <p> In fact, the resulting formulas have only two first-order variables. The resulting logic, denoted FO 2 (TC), is known to have a data complexity of NSPACE [log n] <ref> [I87, Var82] </ref>. This means that the space requirements are manageable, the entire computation is parallelizable, and entire computation is parallelizable, and efficient incremental evaluation is possible (see, for example, [PI94, ZSS94]). <p> This has been studied in great detail. See for example <ref> [EF95, I89, LR96, Var82] </ref>. Let FO be the set of first-order expressible properties.
Reference: [Var97] <author> M.Y. Vardi, </author> <title> "Why is Modal Logic So Robustly Decidable?"in Descriptive Complexity and Finite Models, </title> <editor> N. Immerman and Ph. Kolaitis, eds., </editor> <booktitle> 1997, </booktitle> <publisher> American Mathematical Society. </publisher>
Reference-contexts: The correctness conditions ' i described above can be thought of as queries to the Kripke structure. In fact, in this paper we emphasize the close relationship between model checking and database query evaluation (cf. <ref> [Var97] </ref>). Optimization of the queries is crucial. For this reason, the tradeoff between the expressive power of the query language and the complexity of doing model checking is important. A powerful query language for model checking is the branching-time logic CTL ? . <p> As an example, we can write the CTL formula EFp as a least fixed point, EFp Y (p _ hRiY ) (1) Equation 1 can be generalized to show that all of CTL ? can be interpreted in the modal -Calculus. See <ref> [Eme97, Var97] </ref> for details. Fact 2 * There is a linear time algorithm that translates any formula in CTL into an equivalent formula in the modal -calculus. * There is an exponential time algorithm that translates any formula in CTL ? into an equivalent formula in the modal -calculus. <p> Let LFP r be the restriction of LFP to act only on inductive definitions of arity at most r. Then there is a linear-time mapping of each formula from the modal-mu calculus to an equivalent formula in FO 2 (LFP 1 ) <ref> [Var97] </ref>. As an example, consider the -calculus formula, Y (p _ hRiY ). Recall from Equation 1 that is equivalent to the CTL formula EFp.
Reference: [VW84] <author> M.Y. Vardi and P. Wolper, </author> <title> "Yet Another Process Logic," in Logics of Programs, </title> <publisher> LNCS 164, </publisher> <address> 1984, </address> <publisher> Springer-Verlag, </publisher> <pages> 501-512. </pages>
Reference: [VW86] <author> M.Y. Vardi and P. Wolper, </author> <title> "An Automata-Theoretic Approach to Automatic Program Verification," </title> <booktitle> Proc. 1st Symp. on Logic in Computer Science (1986), </booktitle> <pages> 322-331. </pages>
Reference-contexts: 1 Introduction Model checking, proposed first as a paradigm for computer-aided verification of finite-state programs in [CE81] and developed further in <ref> [BCM92, CES86, LP85, QS81, VW86] </ref> has been gaining widespread acceptance lately (see [BBG94]). The approach is especially appropriate for the design and verification of circuits and distributed protocols. The detailed, low-level design can be automatically translated into a logical structure called a Kripke structure K. <p> A powerful query language for model checking is the branching-time logic CTL ? . Consider the model checking problem for CTL ? in which we fix a query ' 2 CTL ? and vary the Kripke structure K. The complexity of this problem, called program complexity in <ref> [VW86] </ref> and data complexity in [Var82], is known to be NSPACE [log n] [BVW94] for CTL ? . Here n is the size of the Kripke structure as we have mentioned, n is often exponential in the size of the design being verified.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper, </author> <title> "Reasoning about Infinite Computations," </title> <booktitle> Information and Computation 115(1) (1994), </booktitle> <pages> 1-37. </pages>
Reference-contexts: We introduce a boolean variable b ff for each ff 2 cl ('). Intuitively, we use the boolean variables to encode the state of the automaton that runs along a path and checks that the path satisfies a path formula (see <ref> [VW94] </ref>). We inductively define a mapping g from state formulas E (') in CTL ? to equivalent formulas in FO 2 (TC). Let b be a tuple of all the boolean variables b ff , for ff 2 cl ('). <p> Essentially, the boolean variables encode only the states of the "local automaton" in <ref> [VW94] </ref>, which does not guarantee the satisfaction of "Until" formulas. In order to solve this problem, let m be a tuple of bits m ffUfi , one for each "Until" formula, ffUfi 2 cl ('). <p> We do this by starting the cycle with m ffUfi being false and only letting it become true when fi holds. Essentially, the memory bits encode the state of the "eventuality automaton" in <ref> [VW94] </ref>.
Reference: [Ya90] <author> M. Yannakakis, </author> <title> "Graph-theoretic methods in database theory", </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <pages> 230-242, </pages> <year> 1990. </year>
Reference-contexts: While the straightforward approach for adopting transitive-clousre algorithms to symbolic model checking have failed [TBK95], more sophisticated transitive-closure algorithms (see <ref> [Ya90] </ref>) might be quite useful for symbolic model checking. This work suggests a new paradigm for model checking: One can write the conditions to be checked in a very expressive language, e.g., second-order logic or first-order logic with least-fixed point operators or FO (LFP).
Reference: [ZSS94] <author> S. Zhang, S.A. Smolka, and O. Sokolsky, </author> <title> "On the Parallel Complexity of Model Checking in the Modal -Calculus," </title> <booktitle> Proc. 9th IEEE Symp. on Logic in Computer Science, </booktitle> <year> 1994, </year> <month> 154-163. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The resulting logic, denoted FO 2 (TC), is known to have a data complexity of NSPACE [log n] [I87, Var82]. This means that the space requirements are manageable, the entire computation is parallelizable, and entire computation is parallelizable, and efficient incremental evaluation is possible (see, for example, <ref> [PI94, ZSS94] </ref>).
References-found: 31

