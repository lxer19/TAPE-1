URL: http://www.research.att.com/~levy/semistruct97.ps
Refering-URL: http://www.research.att.com/~levy/strudel.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Query Language and Processor for a Web-Site Management System  
Author: Mary Fernandez Daniela Florescu Alon Levy Dan Suciu 
Date: April 18, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [BDHS96] <author> Peter Buneman, Susan Davidson, Gerd Hillebrand, and Dan Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: The ability to compute the transitive closure of an input graph does not imply the ability to compute the transitive closure of an arbitrary binary or 2n-ary relation. This is proven formally for UnQL <ref> [BDHS96] </ref>. Surprisingly, StruQL can express transitive closure of an arbitrary relation as the composition of two queries 2 . For example, consider the tree-encoding of a binary relation R (A; B) with attributes A and B, as shown below. <p> The first constructs the graph corresponding to the relation R (A; B), and the second uses the regular expression fl to find all nodes accessible from the root. input is a keyword that specifies the input to a query: 2 It follows from the result in <ref> [BDHS96] </ref> that a single where link query cannot express transitive closure. input ( where Root (r); r "tup" s1; r "tup"s2; s1 "A" x1; s1 "B" y1 y1 = x2 create N (y1); N (x2) link N (y1) "bogus" N (x2) collect N ewRoot (N ("x"))) where N ewRoot (x); x <p> Related languages. The query stage of StruQL is similar to LOREL [QRS + 95], but unlike LOREL, StruQL can construct a new output graph. This feature is strictly necessary in our application. Compared to UnQL <ref> [BDHS96] </ref>, which can also construct new graphs, the construction part of StruQL is more powerful, as explained above. <p> Assuming that all data is materialized in data graphs, we could apply query evaluation strategies for other semi-structured languages <ref> [QRS + 95, BDHS96, MMM96] </ref> to StruQL and use optimization techniques that minimize or eliminate graph traversal [FS96].
Reference: [CM97] <author> Sophie Cluet and Guido Moerkotte. </author> <title> Query processing in the schemaless and semistructured context. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: At the end it has to join the two results based on Y . Cluet and Moerkotte describe an algebra for querying semi-structured data <ref> [CM97] </ref>. They consider regular expressions as atomic operators in their algebra (as part of the tree patterns in the scan operator). This enables them to optimize queries at the select-project-join level.
Reference: [CMW87] <author> I. Cruz, A.O. Mendelzon, and P.T Wood. </author> <title> A graphical query language supporting recursion. </title> <booktitle> In Proceedings of ACM SIGMOD Conf., </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: This feature is strictly necessary in our application. Compared to UnQL [BDHS96], which can also construct new graphs, the construction part of StruQL is more powerful, as explained above. G <ref> [CMW87, CMW88, Woo88] </ref> is also a query language for graphs with regular path expressions, graph construction, and active-domain semantics: the graph construction part of G corresponds to the restriction of StruQL to unary Skolem functions. 3 Query Evaluation and Optimization A naive evaluation strategy based on our active-domain semantics is prohibitively
Reference: [CMW88] <author> I. Cruz, A.O. Mendelzon, and P.T Wood. G+: </author> <title> recursive queries without recursion. </title> <booktitle> In Proc. Second Int'l Conf. on Expert Database System, </booktitle> <address> Tysons Corner, Virginia, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: This feature is strictly necessary in our application. Compared to UnQL [BDHS96], which can also construct new graphs, the construction part of StruQL is more powerful, as explained above. G <ref> [CMW87, CMW88, Woo88] </ref> is also a query language for graphs with regular path expressions, graph construction, and active-domain semantics: the graph construction part of G corresponds to the restriction of StruQL to unary Skolem functions. 3 Query Evaluation and Optimization A naive evaluation strategy based on our active-domain semantics is prohibitively
Reference: [FFK + 97] <author> M. Fernandez, D. Florescu, J. Kang, A. Levy, and D. Suciu. </author> <title> STRUDEL a web-site management system. </title> <booktitle> In SIGMOD, </booktitle> <address> Tucson, Arizona, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: 1 Introduction We have designed a system, called Strudel (to be demonstrated at SIGMOD-97 <ref> [FFK + 97] </ref>), which applies familiar concepts from database management systems, to the process of building web sites.
Reference: [Flo96] <author> Daniela D. Florescu. </author> <title> Design and Implementation of the Flora Object Oriented Query Optimizer. </title> <type> PhD thesis, </type> <institution> Institut National de Recherche en Informatique et Automatique (INRIA), </institution> <year> 1996. </year>
Reference-contexts: We show some examples of optimizations at each level, which essentially rewrite a query into an equivalent representation at the same level and/or translate the query into the representation at the next level. It is possible to combine such isolated optimization strategies using the techniques in <ref> [Flo96] </ref>. Abstract syntax level. At this level, we apply source-to-source transformations to reduce the number of edges that must be traversed in the input graph. We do this by finding common prefixes in multiple regular path expressions.
Reference: [FS96] <author> Mary Fernandez and Dan Suciu. </author> <title> Query optimizations for semi-structured data using graph schema (full version), </title> <note> 1996. Manuscript available from http://www.research.att.com/info/fmff,suciug. </note>
Reference-contexts: Assuming that all data is materialized in data graphs, we could apply query evaluation strategies for other semi-structured languages [QRS + 95, BDHS96, MMM96] to StruQL and use optimization techniques that minimize or eliminate graph traversal <ref> [FS96] </ref>. Strudel data, however, may be stored in external sources, and therefore, we want evaluation strategies that adhere to limitations of external sources and can use the query capabilities of the sources whenever possible.
Reference: [Imm87] <author> Neil Immerman. </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16 </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: N (y1) "bogus" N (x2) collect N ewRoot (N ("x"))) where N ewRoot (x); x fl N (y) collect Result (y) A B "y" "z" "A" "B" "A" "B" "A" "B" We can prove that StruQL has precisely the same expressive power as first order logic extended with transitive closure <ref> [Imm87] </ref>, FO+T C.
Reference: [LRO96] <author> Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. </author> <title> Querying heterogeneous information sources using source descriptions. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <address> Bombay, India., </address> <year> 1996. </year>
Reference-contexts: In our data model, this translates into certain edges being traversable in one direction (note that this is a generalization of the problem of limitation on binding patterns considered in <ref> [RSU95, LRO96] </ref>). We believe that to address all these requirements, it is advantageous to apply different optimization strategies to different representations of a query, with the hope that at each level we can express different kinds of optimizations.
Reference: [MMM96] <author> A. Mendelzon, G. Mihaila, and T. Milo. </author> <title> Querying the world wide web. </title> <booktitle> In Proceedings of the Fourth Conference on Parallel and Distributed Information Systems, </booktitle> <address> Miami, Florida, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: Assuming that all data is materialized in data graphs, we could apply query evaluation strategies for other semi-structured languages <ref> [QRS + 95, BDHS96, MMM96] </ref> to StruQL and use optimization techniques that minimize or eliminate graph traversal [FS96].
Reference: [PAGM96] <author> Y. Papakonstantinou, S. Abiteboul, and H. Garcia-Molina. </author> <title> Object fusion in mediator systems. </title> <booktitle> In Proceedings of VLDB, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: A simple strategy is to materialize external sources as data graphs and evaluate queries on the materialized graphs. A better strategy is to delay fetching of external data by pushing queries to the external sources. This is the approach taken by TSIMMIS using MSL <ref> [PGMU95, PAGM96] </ref>, an integration language related to Datalog. For StruQL the problem is harder due to the presence of regular path expressions. Exploit indexes. Indexes may be available for data graphs materialized in the data repository and for the external sources.
Reference: [PGMU95] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Ullman. Medmaker: </author> <title> A mediation system based on declarative specifications. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 132-141, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: A simple strategy is to materialize external sources as data graphs and evaluate queries on the materialized graphs. A better strategy is to delay fetching of external data by pushing queries to the external sources. This is the approach taken by TSIMMIS using MSL <ref> [PGMU95, PAGM96] </ref>, an integration language related to Datalog. For StruQL the problem is harder due to the presence of regular path expressions. Exploit indexes. Indexes may be available for data graphs materialized in the data repository and for the external sources.
Reference: [PGMW95] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: At the bottom-most level, data is stored in Strudel's data graph repository or in external sources. External sources may have a variety of formats, but each is translated into the graph data model by a wrapper (see Figure 1). Strudel's graph model is similar to that of OEM <ref> [PGMW95] </ref>. A data graph contains objects connected by directed edges labeled with string-valued attribute names. Objects are either nodes, carrying a unique object identifier (oid), or are atomic values, such as integers, strings, files, etc.
Reference: [QRS + 95] <author> D. Quass, A. Rajaraman, Y. Sagiv, J. Ullman, and J. Widom. </author> <title> Querying semistructure heterogeneous information. </title> <booktitle> In International Conference on Deductive and Object Oriented Databases, </booktitle> <year> 1995. </year>
Reference-contexts: Related languages. The query stage of StruQL is similar to LOREL <ref> [QRS + 95] </ref>, but unlike LOREL, StruQL can construct a new output graph. This feature is strictly necessary in our application. Compared to UnQL [BDHS96], which can also construct new graphs, the construction part of StruQL is more powerful, as explained above. <p> Assuming that all data is materialized in data graphs, we could apply query evaluation strategies for other semi-structured languages <ref> [QRS + 95, BDHS96, MMM96] </ref> to StruQL and use optimization techniques that minimize or eliminate graph traversal [FS96].
Reference: [RSU95] <author> Anand Rajaraman, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Answering queries using templates with binding patterns. </title> <booktitle> In Proceedings of the 14th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Jose, CA, </address> <year> 1995. </year>
Reference-contexts: In our data model, this translates into certain edges being traversable in one direction (note that this is a generalization of the problem of limitation on binding patterns considered in <ref> [RSU95, LRO96] </ref>). We believe that to address all these requirements, it is advantageous to apply different optimization strategies to different representations of a query, with the hope that at each level we can express different kinds of optimizations.
Reference: [Woo88] <author> Peter T. Wood. </author> <title> Queries on Graphs. </title> <type> PhD thesis, </type> <institution> University of Toronto, Toronto, Canada, M5S 1A1, </institution> <month> December </month> <year> 1988. </year> <note> Available as University of Toronto Technical Report CSRI-223. </note>
Reference-contexts: This feature is strictly necessary in our application. Compared to UnQL [BDHS96], which can also construct new graphs, the construction part of StruQL is more powerful, as explained above. G <ref> [CMW87, CMW88, Woo88] </ref> is also a query language for graphs with regular path expressions, graph construction, and active-domain semantics: the graph construction part of G corresponds to the restriction of StruQL to unary Skolem functions. 3 Query Evaluation and Optimization A naive evaluation strategy based on our active-domain semantics is prohibitively
References-found: 16

