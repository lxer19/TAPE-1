URL: http://www.cs.concordia.ca/~faculty/grogono/oopissue.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: grogono@concour.cs.concordia.ca  
Phone: Tel: (514) 848-3000  
Title: Issues in the Design of an Object Oriented Programming Language  
Author: Peter Grogono 
Date: January 1991.  
Note: Published in Structured Programming,  
Address: 1455 deMaisonneuve Blvd. West, Montreal, Quebec Canada H3G 1M8  
Affiliation: Department of Computer Science, Concordia University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Nygaard and O-J. Dahl. </author> <title> The development of the SIMULA language. </title> <editor> In R. Wexelblat, editor, </editor> <booktitle> History of Programming Languages, chapter IX, </booktitle> <pages> 30 pages 439-493. </pages> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction The goal of structured programming is to find abstractions that enable us to build correct and efficient computer programs. The idea that an object is a useful abstraction emerged in the design of SIMULA 67 <ref> [1] </ref>, inspired Smalltalk [2], and recently has achieved widespread popularity. Despite its antiquity, the notion of an object is still fluid and the subject of vigorous debate. Structured programming is strictly unnecessary because we could, in principle, write all our programs in machine language.
Reference: [2] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: 1 Introduction The goal of structured programming is to find abstractions that enable us to build correct and efficient computer programs. The idea that an object is a useful abstraction emerged in the design of SIMULA 67 [1], inspired Smalltalk <ref> [2] </ref>, and recently has achieved widespread popularity. Despite its antiquity, the notion of an object is still fluid and the subject of vigorous debate. Structured programming is strictly unnecessary because we could, in principle, write all our programs in machine language.
Reference: [3] <author> D. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Comm. ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: The difference leads directly to one of the major issues of structured programming. Is the greater generality of modules necessary? Do the restrictions on classes unduly limit the expressiveness of the language? Two other research topics of the seventies contributed to the development of classes and objects. Information hiding <ref> [3] </ref> demonstrates the importance of the module interface as a contract between client and supplier. The development of abstract data types [4] demonstrates the importance and usefulness 2 of separating specification and implementation. The philosopher's stone of programming is reusable code.
Reference: [4] <author> B. Liskov and S. Zilles. </author> <title> Programming with abstract data types. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 9(4) </volume> <pages> 50-9, </pages> <month> April </month> <year> 1974. </year>
Reference-contexts: Information hiding [3] demonstrates the importance of the module interface as a contract between client and supplier. The development of abstract data types <ref> [4] </ref> demonstrates the importance and usefulness 2 of separating specification and implementation. The philosopher's stone of programming is reusable code. All programmers have experienced deja vu as they write yet another slight variation on a table search. The key to reuse is abstraction and parametrization [5].
Reference: [5] <author> J. Goguen. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: The philosopher's stone of programming is reusable code. All programmers have experienced deja vu as they write yet another slight variation on a table search. The key to reuse is abstraction and parametrization <ref> [5] </ref>. The object oriented paradigm provides both. Most object oriented languages support inheritance, a mechanism which enables the common features of a group of classes to be abstracted into a parent class. Some object oriented languages also support parameterized classes, which enable one class to do the work of many.
Reference: [6] <author> P. Grogono. </author> <title> The book of Dee. </title> <type> Technical Report OOP-90-3, </type> <institution> Department of Computer Science, Concordia University, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: Some object oriented languages also support parameterized classes, which enable one class to do the work of many. In this paper, we describe the design of a simple object oriented language <ref> [6] </ref>. The language is called "Dee", after the British mathematician and philosopher John Dee, 1527-1608. Dee is a strongly typed, object oriented language with facilities for developing and maintaining programs [7].
Reference: [7] <author> P. Grogono and B. Cheung. </author> <title> Database support for browsing. </title> <type> Technical Report OOP-91-1, </type> <institution> Department of Computer Science, Concordia University, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: In this paper, we describe the design of a simple object oriented language [6]. The language is called "Dee", after the British mathematician and philosopher John Dee, 1527-1608. Dee is a strongly typed, object oriented language with facilities for developing and maintaining programs <ref> [7] </ref>. In fact, the primary objective in the design of Dee was that programs written in it should be easy to maintain. A second objective was to keep the language simple.
Reference: [8] <author> I. Sommerville. </author> <title> Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1989. </year>
Reference-contexts: During that time, it will be maintained, probably by many different programmers. Three kinds of maintenance are recognized in software engineering: perfective, adaptive, and corrective <ref> [8, Chapter 27] </ref>. Perfective maintenance improves the program without changing its functionality. Adaptive maintenance responds to changing requirements and compensates for changes in the environment in which the program is used. Corrective maintenance diagnoses and rectifies 3 previously undiscovered errors.
Reference: [9] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comp. and Sys. Science, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Strong typing is motivated by the principle that semantic analysis should be simple, but there are other reasons for desiring it. While it is true that, if a language is suitably designed, the compiler can infer types in the absence of type declarations <ref> [9, 10] </ref>, and that type inference is convenient for interactive and prototyping languages [11], untyped programs are not suitable for production software. The benefit from automatic type inference is that programs are slightly shorter. The loss is that programs are harder to understand and compile.
Reference: [10] <author> A. Ohori and P. Buneman. </author> <title> Static type inference for parametric classes. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 445-456, </pages> <year> 1989. </year>
Reference-contexts: Strong typing is motivated by the principle that semantic analysis should be simple, but there are other reasons for desiring it. While it is true that, if a language is suitably designed, the compiler can infer types in the absence of type declarations <ref> [9, 10] </ref>, and that type inference is convenient for interactive and prototyping languages [11], untyped programs are not suitable for production software. The benefit from automatic type inference is that programs are slightly shorter. The loss is that programs are harder to understand and compile.
Reference: [11] <author> A. Goldberg. </author> <title> The influence of an object-oriented language on the programming environment. </title> <editor> In D. Barstow, H. Shrobe, and E. Sandewall, editors, </editor> <booktitle> Interactive Programming Environments, chapter 8, </booktitle> <pages> pages 141-174. </pages> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: While it is true that, if a language is suitably designed, the compiler can infer types in the absence of type declarations [9, 10], and that type inference is convenient for interactive and prototyping languages <ref> [11] </ref>, untyped programs are not suitable for production software. The benefit from automatic type inference is that programs are slightly shorter. The loss is that programs are harder to understand and compile.
Reference: [12] <author> N. Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer, </publisher> <year> 1982. </year>
Reference-contexts: The first is that they need to write low-level, machine-oriented programs. This requirement can be accomodated by a relatively small number of carefully designed features, as Wirth demonstrated in the design of Modula-2 <ref> [12] </ref>.
Reference: [13] <author> J. Bentley. </author> <title> Writing Efficient Programs. </title> <publisher> Prentice-Hall, </publisher> <year> 1982. </year> <month> 31 </month>
Reference-contexts: If these conditions are satisfied, the additional improvement that can be obtained by writing tricky code is usually small and is often outweighed by the extra work of debugging and maintaining the program <ref> [13] </ref>. 5 The ideal programming language would be both simple and efficient. There are situations in which the desire for simplicity and efficiency work together. Some of the most interesting issues in language design arise, however, when it is necessary to establish a balance between simplicity and efficiency.
Reference: [14] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall Inter--national, </publisher> <year> 1988. </year>
Reference-contexts: The language designer's choices include the following. * Represent all objects by references, as in LISP and its descendants. This strategy is simple to implement but potentially inefficient. * Represent objects of a few basic classes by values and all others by references, as in early versions of Eiffel <ref> [14] </ref>. This strategy is likely to lead to semantic inconsistencies of the kind already described. * Give the programmer full control over the representation, as in C++ [15]. This strategey complicates both the language definition and the pro grammer's task. * Let the compiler choose the appropriate representation. <p> It is not an ancestor of every class and it has only a small number of attributes, unlike the class ANY of Eiffel. The kind of polymorphism exhibited by Table, in which class parameters are restricted, is called "bounded parameteric polymorphism" [20] or "constrained genericity" <ref> [14] </ref>. The concepts class and type in Dee are closely related. For basic classes, they are essentially identical. It does not matter whether we read n:Int as "n belongs to class Int" or "n has type Int". <p> From the point of view of type theory, Int fi Int ! Int is not a subtype of RingElem fi RingElem ! RingElem [23]. In Eiffel, the type of the second argument of + is declared to be like current. Meyer calls this declaration by association <ref> [14] </ref>. Cook has shown that declaration by association is insecure [18]. Alternatively, we can use the signature Int fi RingElem ! Int for + in Int and dispatch a second message with the second argument as receiver to complete the operation. This technique is called double dispatching. <p> Like all good things, inheritance can be overused. The strict interpretation of inheritance in Dee is intended to prevent the use of inheritance as a trick to achieve conciseness and efficiency with no regard for meaning. Consider, for example, the implementation of a stack using an array in Eiffel <ref> [14, pages 241-2] </ref>. class FIXED STACK [T ] : : : inherit STACK [T ]; ARRAY [T ]; : : : The required stack behaviour in the class FIXED STACK is obtained by renaming array operations as stack operations. <p> This suggests that we should combine declaration and initialization in a single statement [27]. Combining declaration and initialization, however, leads to other problems <ref> [14, page 77] </ref>. First, it forces bottom-up construction of composite objects, which may not always be practical.
Reference: [15] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: This strategy is likely to lead to semantic inconsistencies of the kind already described. * Give the programmer full control over the representation, as in C++ <ref> [15] </ref>. This strategey complicates both the language definition and the pro grammer's task. * Let the compiler choose the appropriate representation. This strategy is likely to complicate the compiler, perhaps to the point of infeasibility.
Reference: [16] <author> P. Grogono and A. Bennett. </author> <title> Polymorphism and type checking in object-oriented languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(11) </volume> <pages> 109-115, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The owner is responsible for a single document called the canonical document of the class. No person other than the owner of the class should need to see the canonical document in its entirety. Within the canonical document, there are three levels of text <ref> [16] </ref>. The criterion that separates the levels is the extent to which the text can be processed automatically. The lowest level is source text, which can be compiled into machine code and can therefore be considered to be fully processed.
Reference: [17] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 353-361, </pages> <year> 1989. </year>
Reference-contexts: A view is a human-readable text intended for a programmer who wants to use, extend, or inherit a class which he or she does not own. This definition is consistent with Shilling and Sweeney, who define a view to be "a simplifying abstraction of a complex structure" <ref> [17] </ref>. The client view contains information of the kind that would be found in a specification module in Modula-2. The descendant view contains additional information, reflecting the fact that the descendant relation is more intimate than the client relation. In each case, the view contains selected documentation.
Reference: [18] <author> W. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <journal> Computer Journal, </journal> <volume> 32(4) </volume> <pages> 305-311, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The basic classes Int, Float, Bool, and String are pure classes. A program which uses pure classes is, for all intents and purposes, a functional program. 4.2 Classes and Types Dee is strongly typed and follows the convention that each class defines a type. Since inheritance and subtyping conflict <ref> [18] </ref>, Dee provides two kinds 11 of subclass, described in Section 4.3 below. Inheritance provides two of the features we need in order to build reusable software components: polymor-phism and overloading. Class parameters are not required in principle but they enhance the expressiveness of the language [19]. <p> At run-time, the object corresponding to f is an Apple, and therefore the method make of the class Apple is invoked. Its argument, g, is a Fruit. The conformance rules for parameterized classes are more complicated, as shown by Cook <ref> [18] </ref>. Consider the following simplified code for a generic class for sets. class Set [T:Comparable] proc insert (x:T) func arb:T The procedure insert adds a new object of type T to the set. The function arb returns an arbitrary member of the set, failing if the set is empty. <p> In Eiffel, the type of the second argument of + is declared to be like current. Meyer calls this declaration by association [14]. Cook has shown that declaration by association is insecure <ref> [18] </ref>. Alternatively, we can use the signature Int fi RingElem ! Int for + in Int and dispatch a second message with the second argument as receiver to complete the operation. This technique is called double dispatching.
Reference: [19] <author> B. Meyer. </author> <title> Genericity versus inheritance. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 391-405, </pages> <year> 1986. </year>
Reference-contexts: Inheritance provides two of the features we need in order to build reusable software components: polymor-phism and overloading. Class parameters are not required in principle but they enhance the expressiveness of the language <ref> [19] </ref>. In Dee, a class parameter must be qualified. For example, the declaration class Table [KeyType:Ordered; InfoType:Any] introduces a class Table. The class Table is parameterized by a class of keys, which must be ordered, and by a class of objects of arbitrary type.
Reference: [20] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: It is not an ancestor of every class and it has only a small number of attributes, unlike the class ANY of Eiffel. The kind of polymorphism exhibited by Table, in which class parameters are restricted, is called "bounded parameteric polymorphism" <ref> [20] </ref> or "constrained genericity" [14]. The concepts class and type in Dee are closely related. For basic classes, they are essentially identical. It does not matter whether we read n:Int as "n belongs to class Int" or "n has type Int".
Reference: [21] <author> P. Grogono. </author> <title> Design criteria for a simple object-oriented language. </title> <type> Technical Report OOP-89-5, </type> <institution> Department of Computer Science, Concordia University, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Determining the particular entity denoted is called resolving the overloaded name. Most object oriented languages resolve overloaded names by examining the class of the first argument (or receiver ) at run-time; the other arguments, if any, are not examined. This asymmetry complicates type checking <ref> [21] </ref>. It is, of course, possible to resolve overloaded names by examining the classes of all arguments of the method, as in CLOS [22], but most object oriented languages use the first argument only.
Reference: [22] <author> D. Moon. </author> <title> The common lisp object-oriented programming language standard. </title> <editor> In W. Kim and F. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, chapter 4, </booktitle> <pages> pages 49-78. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: This asymmetry complicates type checking [21]. It is, of course, possible to resolve overloaded names by examining the classes of all arguments of the method, as in CLOS <ref> [22] </ref>, but most object oriented languages use the first argument only. Suppose that we define an abstract class RingElem whose instances are ring elements with a binary operator +. Assume that RingElem has two descendants, Int and Float.
Reference: [23] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. Mc-Queen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science 173, 1984. 32 </note>
Reference-contexts: From the point of view of type theory, Int fi Int ! Int is not a subtype of RingElem fi RingElem ! RingElem <ref> [23] </ref>. In Eiffel, the type of the second argument of + is declared to be like current. Meyer calls this declaration by association [14]. Cook has shown that declaration by association is insecure [18].
Reference: [24] <author> D. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 347-349, </pages> <year> 1986. </year>
Reference-contexts: Alternatively, we can use the signature Int fi RingElem ! Int for + in Int and dispatch a second message with the second argument as receiver to complete the operation. This technique is called double dispatching. It was proposed by Ingalls for Smalltalk <ref> [24] </ref> and has subsequently been refined by Hebel and Johnson for Typed Smalltalk [25]. Double dispatching has three apparent disadvantages. First, it requires a large number of methods, many of which will be trivial.
Reference: [25] <author> K. Hebel and R. Johnson. </author> <title> Arithmetic and double dispatching in Smalltalk. </title> <journal> J. Object-Oriented Programming, </journal> <volume> 2(6) </volume> <pages> 40-44, </pages> <month> March/April </month> <year> 1990. </year>
Reference-contexts: This technique is called double dispatching. It was proposed by Ingalls for Smalltalk [24] and has subsequently been refined by Hebel and Johnson for Typed Smalltalk <ref> [25] </ref>. Double dispatching has three apparent disadvantages. First, it requires a large number of methods, many of which will be trivial. If RingElem has n subclasses, each subclass must have n + 1 methods just to implement +. Second, double dispatching will slow execution. <p> By code optimization, they reduce the overhead of double dispatching to an acceptable level. For a complete arithmetic hierarchy with 36 classes and 5 binary operations in each class, we would expect to need 6660 methods using double dispatching. With inheritance, only 401 methods are actually needed <ref> [25] </ref>. 4.3 Inheritance Disciplined use of inheritance is a key component of object oriented design. Like all good things, inheritance can be overused.
Reference: [26] <author> D. Ingalls. </author> <title> The Smalltalk-76 programming system: </title> <booktitle> Design and implementation. In Proc. Fifth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 9-15. </pages> <publisher> ACM, </publisher> <year> 1978. </year>
Reference-contexts: Partially abstract classes, under various names, have been part of object oriented programming from the beginning. For example, Ingalls describes the class Number in Smalltalk-76 <ref> [26] </ref>: it implements the methods , , 6=, max:, and min: using the abstract methods &lt;, &gt;, and =. The methods &lt;, &gt;, and = must be provided by any concrete descendant of Number. It does not make sense for an abstract or partially abstract class to have instances.
Reference: [27] <author> B. Stroustrup. </author> <booktitle> What is "object-oriented programming"? In European Conf. on Object Oriented Programming, </booktitle> <pages> pages 53-70. </pages> <publisher> Springer LNCS 276, </publisher> <year> 1987. </year>
Reference-contexts: The first is that it permits the existence of undefined objects: the object x above is accessible within the scope of the declaration x:C but is undefined until the new statement has been executed. This suggests that we should combine declaration and initialization in a single statement <ref> [27] </ref>. Combining declaration and initialization, however, leads to other problems [14, page 77]. First, it forces bottom-up construction of composite objects, which may not always be practical.
Reference: [28] <author> N. Wirth. </author> <title> Algorithms + Data Structures = Programs. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: We often need to traverse a collection: that is, to perform an operation on each of its components in turn. The traditional structured programming approach to traversal is to exploit the natural correspondence between data structures and control structures <ref> [28, pages 162-3] </ref>. In object oriented programming, however, we want to decouple the representation of the data structure and the control structure used to traverse it. That is, we want to write generic methods which traverse collections without knowing how the collections are represented.
Reference: [29] <author> B. Liskov, E. Moss, C. Schaffert, and A. Snyder. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Comm. ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: It follows that the mechanism for performing the traversal must be hidden within the class but that the interface to it must be shared by all collection classes. This kind of abstraction was introduced in CLU and is called an iterator <ref> [29] </ref>. In CLU, traversals have the following basic form: for x in C.I do S end In this statement, C is a collection, I denotes an iterator for C, and S is a statement sequence.
Reference: [30] <author> B. Liskov and A. Snyder. </author> <title> Exception handling in CLU. </title> <journal> IEEE Trans. Soft. Engrg., </journal> <volume> SE-5(6):547-558, </volume> <month> November </month> <year> 1979. </year>
Reference-contexts: The type of stoi is String ! Int. If we adopt a convention such as "a result of 99 indicates failure" we have made matters worse rather than better. The mechanism for exception handling in Dee is based on the exception handling mechanisms of CLU <ref> [30] </ref> and ML [31]. Koenig and Stroustrup have proposed a similar mechanism for C++ [32]. The statement raise x signals an exception. The object x is called the exception object and may be a member of any class. Figure 11 shows the syntax of a statement containing an exception handler.
Reference: [31] <author> B. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The type of stoi is String ! Int. If we adopt a convention such as "a result of 99 indicates failure" we have made matters worse rather than better. The mechanism for exception handling in Dee is based on the exception handling mechanisms of CLU [30] and ML <ref> [31] </ref>. Koenig and Stroustrup have proposed a similar mechanism for C++ [32]. The statement raise x signals an exception. The object x is called the exception object and may be a member of any class. Figure 11 shows the syntax of a statement containing an exception handler.
Reference: [32] <author> A. Koenig and B. Stroustrup. </author> <title> Exception handling for C++. </title> <journal> J. Object-Oriented Programming, </journal> <volume> 3(2) </volume> <pages> 16-33, </pages> <month> July/August </month> <year> 1990. </year>
Reference-contexts: The mechanism for exception handling in Dee is based on the exception handling mechanisms of CLU [30] and ML [31]. Koenig and Stroustrup have proposed a similar mechanism for C++ <ref> [32] </ref>. The statement raise x signals an exception. The object x is called the exception object and may be a member of any class. Figure 11 shows the syntax of a statement containing an exception handler.
Reference: [33] <author> K. Lieberherr, I. Holland, and A. Riel. </author> <title> Object-oriented programming: an objective sense of style. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 323-334. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Dee is no exception. As an object oriented language, Dee supports an object oriented style of programming which has been widely discussed <ref> [33, 34] </ref>. In this section, we discuss some aspects of object oriented programming which have received little attention. The traditional approach to software development recommends interleaved refinement of control and data structures.

References-found: 33

