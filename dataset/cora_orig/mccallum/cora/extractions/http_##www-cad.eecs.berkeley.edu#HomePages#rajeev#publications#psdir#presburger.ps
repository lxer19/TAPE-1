URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/psdir/presburger.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/publications.html
Root-URL: http://www.cs.berkeley.edu
Email: fshiple,rajeevrg@synopsys.com  kukula@synopsys.com  
Phone: 2  
Title: A Comparison of Presburger Engines for EFSM Reachability  
Author: Thomas R. Shiple James H. Kukula Rajeev K. Ranjan 
Keyword: Computer Aided Verification  
Date: 280-292.  
Note: '98, Vancouver, pp.  
Address: Mountain View, CA.  OR.  
Affiliation: 1 Synopsys, Inc.,  Synopsys, Inc., Beaverton,  
Abstract: Implicit state enumeration for extended finite state machines relies on a decision procedure for Presburger arithmetic. We compare the performance of two Presburger packages, the automata-based Shasta package and the polyhedra-based Omega package. While the raw speed of each of these two packages can be superior to the other by a factor of 50 or more, we found the asymptotic performance of Shasta to be equal or superior to that of Omega for the experiments we performed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> T. Amon, G. Borriello, T. Hu, and J. Liu. </author> <title> Symbolic timing verification of timing diagrams using Presburger formulas. </title> <booktitle> In Proc. 34th Design Automat. Conf., </booktitle> <pages> pages 226237, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. <ref> [1] </ref> use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) [3, 8, 9, 12].
Reference: 2. <author> M. Biehl, N. Klarlund, and T. Rauhe. Mona: </author> <title> Decidable arithmetic in practice. </title> <editor> In B. Jonsson and J. Parrow, editors, </editor> <booktitle> Fourth International Symposium Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 1135 of LNCS, </booktitle> <address> Uppsala, Sweden, 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Does the implementation of Shasta reflect the true potential of the automata-based approach? Fortunately, we were able to answer this question to some degree by comparing Shasta directly to Mona, a second-generation automata package that supports the logic WS1S <ref> [2, 14] </ref>. Rather than trying to integrate Mona into VIS, we just manually coded two examples (sdiv and euclid) in Mona's WS1S language, using the embedding suggested by B uchi. We also hardcoded the reachability computation out to a fixed number of steps for each example.
Reference: 3. <author> B. Boigelot and P. Wolper. </author> <title> Symbolic verification with periodic sets. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 818 of LNCS, </booktitle> <pages> pages 5567, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) <ref> [3, 8, 9, 12] </ref>. An EFSM is a system with a finite state controller interacting with an integer dat-apath of unbounded width [9].
Reference: 4. <author> A. Boudet and H. Comon. </author> <title> Diophantine equations, Presburger arithmetic and finite automata. </title> <editor> In H. Kirchner, editor, </editor> <booktitle> Trees and Algebra in Programming - CAAP, volume 1059 of LNCS, </booktitle> <pages> pages 3043. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: An EFSM. Two basic approaches have emerged for representing, manipulating, and checking the satisfiability of Presburger formulas: automata-based and polyhedra-based. In the automata-based approach, the naturals are encoded as bit strings using base 2 encoding <ref> [4, 6, 19] </ref>. For a Presburger formula defined over k variables, a technique has been developed to directly translate the formula into a deterministic, finite state automaton (DFA) that accepts a k-tuple of bit strings if and only if the k-tuple is a solution to the given formula [4]. <p> For a Presburger formula defined over k variables, a technique has been developed to directly translate the formula into a deterministic, finite state automaton (DFA) that accepts a k-tuple of bit strings if and only if the k-tuple is a solution to the given formula <ref> [4] </ref>. Since minimum state DFAs are unique, automata provide a canonical form for Presburger formulas. In the polyhedra-based approach, Fourier-Motzkin variable elimination is used to eliminate the quantifiers from a Presburger formula [13, 17]. <p> The contribution of this work is to perform such a comparison. For the polyhedra approach, we use the Omega package of Pugh et al. [15, 17]. For the automata approach, we developed the Shasta package, which incorporates the procedure of Boudet and Comon <ref> [4] </ref> for translating linear equalities and inequalities to automata, and also uses the automaton data structure of Henriksen et al. [14]. The context for our comparison is state reachability for EFSMs. It is not clear a priori which approach would be better.
Reference: 5. <author> R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. K. Ranjan, S. Sarwary, T. R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A system for verification and synthesis. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 1102 of LNCS, </booktitle> <pages> pages 428432, </pages> <address> New Brunswick, NJ, July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In particular, each example is specified as a multi-level circuit, where the components can be adders, subtractors, multiplexors, comparators, Boolean logic gates, and Boolean and integer valued flip-flops. There is a single clock that drives all the flip-flops. We incorporated EFSM reachability into the VIS program <ref> [5] </ref> by making several modifications and additions to VIS. First, we added a generic Presburger engine interface which, at the flip of a runtime switch, can use either the Shasta or Omega engines. This way we perform the same sequence of elementary operations with both engines, ensuring a fair comparison.
Reference: 6. <author> J. R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> In Proc. Int. Congress Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 111, </pages> <address> Berkeley, CA, 1960. </address> <publisher> Stanford University Press. </publisher>
Reference-contexts: An EFSM. Two basic approaches have emerged for representing, manipulating, and checking the satisfiability of Presburger formulas: automata-based and polyhedra-based. In the automata-based approach, the naturals are encoded as bit strings using base 2 encoding <ref> [4, 6, 19] </ref>. For a Presburger formula defined over k variables, a technique has been developed to directly translate the formula into a deterministic, finite state automaton (DFA) that accepts a k-tuple of bit strings if and only if the k-tuple is a solution to the given formula [4]. <p> The atomic formulas of Presburger arithmetic are linear equalities and inequalities. B uchi indirectly showed how these formulas can be represented by automata by demonstrating how they can be embedded in the logic WS1S <ref> [6] </ref>. Recently, Boudet and Comon developed a direct method for translating an atomic formula into an automaton; the Shasta package uses this algorithm. Figure 2 shows the automaton that recognizes the natural number tuples satisfying the linear equality x 1 + x 2 = x 3 .
Reference: 7. <author> T. Bultan, R. Gerber, and C. League. </author> <title> Verifying systems with integer constraints and boolean predicates: A composite approach. </title> <booktitle> In Proceedings of the 1998 International Symposium on Software Testing and Analysis (ISSTA '98), </booktitle> <year> 1998. </year>
Reference-contexts: Furthermore, Shasta's superiority in reachability on shiftbooln cannot be explained simply by the presence of Boolean variables, since it similarly outperforms Omega on shiftintn, which has no Boolean variables. Recently, Bultan et al. <ref> [7] </ref> proposed a variant of Omega, where a Presburger formula with integer and Boolean variables is represented by a set of Omega and BDD pairs. They observed a drastic improvement over 3 For runtimes of more than 7 seconds, significantly means, here and throughout, more than a factor of 3.
Reference: 8. <author> T. Bultan, R. Gerber, and W. Pugh. </author> <title> Symbolic model checking of infinite state programs using Presburger arithmetic. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 1254 of LNCS, </booktitle> <pages> pages 400411, </pages> <address> Haifa, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) <ref> [3, 8, 9, 12] </ref>. An EFSM is a system with a finite state controller interacting with an integer dat-apath of unbounded width [9]. <p> The circuits are briefly characterized in Table 1; sequential depth refers to the greatest lower bound on the path length from an initial state to any reachable state. A brief description of each example follows. ticket is the ticket mutual-exclusion algorithm from <ref> [8] </ref>, with 2 clients. A client can enter the critical section when its local ticket number becomes equal to the last used ticket number, plus one. An extra Boolean input is used to model the interleaving semantics used in [8]. perfect reads a number a and then computes the sum of <p> of each example follows. ticket is the ticket mutual-exclusion algorithm from <ref> [8] </ref>, with 2 clients. A client can enter the critical section when its local ticket number becomes equal to the last used ticket number, plus one. An extra Boolean input is used to model the interleaving semantics used in [8]. perfect reads a number a and then computes the sum of all the divisors of a (excluding a itself). If the sum equals a, then a is called perfect. sdiv is a serial divider.
Reference: 9. <author> K.-T. Cheng and A. Krishnakumar. </author> <title> Automatic functional test generation using the extended finite state machine model. </title> <booktitle> In Proc. 30th Design Automat. Conf., </booktitle> <pages> pages 8691, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) <ref> [3, 8, 9, 12] </ref>. An EFSM is a system with a finite state controller interacting with an integer dat-apath of unbounded width [9]. <p> Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) [3, 8, 9, 12]. An EFSM is a system with a finite state controller interacting with an integer dat-apath of unbounded width <ref> [9] </ref>. Each transition of the controller has a gating predicate over the integer variables, and an update function specifying the new values of the integer variables when the transition is taken.
Reference: 10. <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of LNCS, </booktitle> <pages> pages 365373. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Nonetheless, the BFS-based implicit state enumeration technique used for FSMs <ref> [10] </ref> can be carried directly over to the EFSM domain.
Reference: 11. <author> S. Devadas. </author> <title> Comparing two-level and ordered binary decision diagram representations of logic functions. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> 12(5):722723, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: The context for our comparison is state reachability for EFSMs. It is not clear a priori which approach would be better. In the Boolean domain, experience shows that BDDs are generally superior to SOPs, but there are cases where SOPs are exponentially more compact than BDDs <ref> [11] </ref>. In the final analysis, our experiments show that while the raw speed of each Presburger engine can be superior to the other by a factor of 50 or more, the asymptotic performance of Shasta is equal or superior to that of Omega. <p> In addition, while we have not observed any cases where Shasta has worse asymptotic performance, in the Boolean domain cases are known to exist where a SOP representation is superior to BDDs <ref> [11] </ref>. Thus, we expect that similar situations exist in the Presburger domain where Omega will outperform Shasta not only in raw terms, but also in asymptotic performance.
Reference: 12. <author> S. Devadas, K. Keutzer, and A. Krishnakumar. </author> <title> Design verification and reachability analysis using algebraic manipulation. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <pages> pages 250258, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) <ref> [3, 8, 9, 12] </ref>. An EFSM is a system with a finite state controller interacting with an integer dat-apath of unbounded width [9].
Reference: 13. <author> H. B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: 1 Introduction Peano arithmetic, the theory of arithmetic with multiplication and addition, is undecidable. However, decision procedures do exist for the subset of arithmetic, known as Presburger arithmetic, that excludes multiplication <ref> [13] </ref>. Presburger formulas are built up from natural number constants, natural number variables, addition, equality, inequality, and the first order logical connectives. <p> Since minimum state DFAs are unique, automata provide a canonical form for Presburger formulas. In the polyhedra-based approach, Fourier-Motzkin variable elimination is used to eliminate the quantifiers from a Presburger formula <ref> [13, 17] </ref>. The result is a union of convex polyhedra that is typically represented by a set of matrices; this representation is not canonical. <p> The next step is to existentially quantify any free variables. If the resulting formula, involving only constants, is true, then the original formula is satisfiable. Thus, we need to construct, for any Presburger formula, a representation in the form of Equation 1 <ref> [13] </ref>. As mentioned in Section 2, Presburger formulas are built up from linear equalities and inequalities using conjunction, complementation, and quantification. Linear equalities and inequalities are just trivial instances of the representation in Equation 1. Any conjunction can be simply distributed over the disjunctions to produce a new disjunctive form.
Reference: 14. <author> J. G. Henriksen, J. Jensen, M. Jrgensen, N. Klarlund, R. Paige, T. Rauhe, and A. Sandholm. Mona: </author> <title> Monadic second-order logic in practice. In Tools and Algorithms for the Construction and Analysis of Systems, </title> <booktitle> First International Workshop, TACAS '95, volume 1019 of LNCS, </booktitle> <pages> pages 89110. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: For the automata approach, we developed the Shasta package, which incorporates the procedure of Boudet and Comon [4] for translating linear equalities and inequalities to automata, and also uses the automaton data structure of Henriksen et al. <ref> [14] </ref>. The context for our comparison is state reachability for EFSMs. It is not clear a priori which approach would be better. In the Boolean domain, experience shows that BDDs are generally superior to SOPs, but there are cases where SOPs are exponentially more compact than BDDs [11]. <p> The automaton representing x 1 + x 2 = x 3 . need to be determinized and minimized (Shasta automatically applies state minimization after every operation). Given a minimized automaton, satisfiability can be checked in constant time. The Shasta package incorporates the automaton data structure of Henriksen et al. <ref> [14] </ref>. Rather then having 2 k labels annotating the outgoing transitions of each state, a BDD with multiple terminals is used. Specifically, each state of an automaton points to a BDD that determines the next state as a function of the incoming bit vector. <p> Does the implementation of Shasta reflect the true potential of the automata-based approach? Fortunately, we were able to answer this question to some degree by comparing Shasta directly to Mona, a second-generation automata package that supports the logic WS1S <ref> [2, 14] </ref>. Rather than trying to integrate Mona into VIS, we just manually coded two examples (sdiv and euclid) in Mona's WS1S language, using the embedding suggested by B uchi. We also hardcoded the reachability computation out to a fixed number of steps for each example.
Reference: 15. <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman, and D. Wonnacott. </author> <title> The Omega library (Version 1.1.0) interface guide. </title> <address> http://www.cs.umd.edu/ projects/omega, </address> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: To the best of our knowledge, a direct experimental comparison of the performance of these two basic approaches has never been made. The contribution of this work is to perform such a comparison. For the polyhedra approach, we use the Omega package of Pugh et al. <ref> [15, 17] </ref>. For the automata approach, we developed the Shasta package, which incorporates the procedure of Boudet and Comon [4] for translating linear equalities and inequalities to automata, and also uses the automaton data structure of Henriksen et al. [14]. The context for our comparison is state reachability for EFSMs. <p> These tactics can get very expensive and one cannot tell in advance whether they will succeed in reducing the size of the representation. At the same time very simple tactics can be quite effective. The Omega package <ref> [15, 17] </ref> uses sophisticated versions of these techniques to provide a complete set of Presburger arithmetic operations. It offers user control over when, and to what degree, minimization of formulas should be applied.
Reference: 16. <author> D. Oppen. </author> <title> A 2 2 2 pn upper bound on the complexity of Presburger arithmetic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(3):323332, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: An example of such a formula is 1 9x (y = 2x + 1): Even though the best known procedure for deciding Presburger arithmetic is triply exponential in the length of the formula <ref> [16] </ref>, several practical applications for Presburger arithmetic have been found. Pugh [17] uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams.
Reference: 17. <author> W. Pugh. </author> <title> A practical algorithm for exact array dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8):102114, </volume> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: An example of such a formula is 1 9x (y = 2x + 1): Even though the best known procedure for deciding Presburger arithmetic is triply exponential in the length of the formula [16], several practical applications for Presburger arithmetic have been found. Pugh <ref> [17] </ref> uses Presburger arithmetic for data dependence analysis in optimizing compilers. Amon et al. [1] use Presburger arithmetic to perform symbolic verification of timing diagrams. Another application, and the one on which we will be focusing, is reachability analysis of extended finite state machines (EFSMs) [3, 8, 9, 12]. <p> Since minimum state DFAs are unique, automata provide a canonical form for Presburger formulas. In the polyhedra-based approach, Fourier-Motzkin variable elimination is used to eliminate the quantifiers from a Presburger formula <ref> [13, 17] </ref>. The result is a union of convex polyhedra that is typically represented by a set of matrices; this representation is not canonical. <p> To the best of our knowledge, a direct experimental comparison of the performance of these two basic approaches has never been made. The contribution of this work is to perform such a comparison. For the polyhedra approach, we use the Omega package of Pugh et al. <ref> [15, 17] </ref>. For the automata approach, we developed the Shasta package, which incorporates the procedure of Boudet and Comon [4] for translating linear equalities and inequalities to automata, and also uses the automaton data structure of Henriksen et al. [14]. The context for our comparison is state reachability for EFSMs. <p> These tactics can get very expensive and one cannot tell in advance whether they will succeed in reducing the size of the representation. At the same time very simple tactics can be quite effective. The Omega package <ref> [15, 17] </ref> uses sophisticated versions of these techniques to provide a complete set of Presburger arithmetic operations. It offers user control over when, and to what degree, minimization of formulas should be applied.
Reference: 18. <author> B. L. van der Waerden. </author> <booktitle> Modern Algebra, </booktitle> <volume> volume 1. </volume> <pages> Ungar, </pages> <year> 1953. </year>
Reference-contexts: Presburger arithmetic is strictly defined over just the naturals, not all the integers. The Shasta package follows this definition. However, it is possible to extend Presburger arithmetic to the integers by encoding each integer as a pair of natural numbers <ref> [18] </ref>. 3 Polyhedra Approach for Solving Presburger Arithmetic The set of solutions to a Presburger formula can be represented in a sum of products form, whose primitive formulas are linear equalities, inequalities, and congruences: _ 2 ^ (0 = a 0jk + i ^ (0 &lt; b 0jk + i ^
Reference: 19. <author> P. Wolper and B. Boigelot. </author> <title> An automata-theoretic approach to Presburger arithmetic constraints. </title> <booktitle> In Proc. of Static Analysis Symposium, volume 983 of LNCS, </booktitle> <pages> pages 2132. </pages> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: An EFSM. Two basic approaches have emerged for representing, manipulating, and checking the satisfiability of Presburger formulas: automata-based and polyhedra-based. In the automata-based approach, the naturals are encoded as bit strings using base 2 encoding <ref> [4, 6, 19] </ref>. For a Presburger formula defined over k variables, a technique has been developed to directly translate the formula into a deterministic, finite state automaton (DFA) that accepts a k-tuple of bit strings if and only if the k-tuple is a solution to the given formula [4].
References-found: 19

