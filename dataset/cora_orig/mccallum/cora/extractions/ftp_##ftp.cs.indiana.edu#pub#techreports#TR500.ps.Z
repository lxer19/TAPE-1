URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR500.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Title: Compiler support for an RMI implementation using NexusJava  
Author: Fabian Breg Dennis Gannon 
Date: December 16, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. Beckman, D. Gannon, and E. Johnson. </author> <title> Portable Parallel Programming in HPC++. </title> <year> 1996. </year>
Reference-contexts: This project is part of a larger project, which aims at inter-operability between various distributed object models. Our goal is to have (a subset of) our RMI implementation talk to remote objects written in HPC++ <ref> [1] </ref>, which are built on top of the Nexus communication library. Since Nexus and NexusJava are already fully inter-operable and both portable, these libraries provide an excellent basis for communication in our project.
Reference: [2] <author> A.J.C. Bik and D.B. Gannon. </author> <title> Automatically Exploiting Implicit Parallelism in Java. </title> <journal> Con-currency, Practice and Experience, </journal> <volume> 9(6), </volume> <year> 1997. </year>
Reference-contexts: The same holds if a variable is declared to be of type array. Note, however, that types contained in arrays or final classes may still have to be handled dynamically. 5.3 Compiler implementation The original javar compiler [3] was developed to experiment with restructuring transformations on Java Programs <ref> [2] </ref>. Although it does not provide a full front end (little semantic analysis is included), it is capable of parsing a Java source file and building a syntax tree representation from it. Furthermore, it provides functions to traverse over the statements and expressions in the syntax tree.
Reference: [3] <author> A.J.C. Bik, J.E. Villacis, and D.B. Gannon. </author> <title> JAVAR manual. </title> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <note> This manual and the complete source of javar is made available at http://www.extreme.indiana.edu/hpjava/. </note>
Reference-contexts: The same holds if a variable is declared to be of type array. Note, however, that types contained in arrays or final classes may still have to be handled dynamically. 5.3 Compiler implementation The original javar compiler <ref> [3] </ref> was developed to experiment with restructuring transformations on Java Programs [2]. Although it does not provide a full front end (little semantic analysis is included), it is capable of parsing a Java source file and building a syntax tree representation from it.
Reference: [4] <author> K.M. Chandy. </author> <title> Caltech Infospheres Project Overview: Information Infrastructures for Task Forces. </title> <institution> Technical Report Computer Science 256-80, California Institute of Technology, </institution> <month> nov </month> <year> 1996. </year>
Reference-contexts: Because, however, there is a growing demand for distributed applications, a number of distributed object models have been developed for the Java programming language that simplify distributed programming in an object oriented environment. Examples of such distributed object models are Voyager [9], Infospheres <ref> [4] </ref> and Java RMI [10]. While the former two aim at a flexible and highly dynamic framework, the last one aims at providing a syntax for remote method invocation identical to the syntax for method invocation on local objects.
Reference: [5] <author> I. Foster, J. Geisler, C. Kesselman, and S. Tuecke. </author> <title> Managing multiple communication methods in high-performance networked computing systems. </title> <journal> Journal of parallel and Distributed Computing, </journal> <note> page to appear, </note> <year> 1997. </year>
Reference-contexts: This way, the stub and skeleton objects, and thus the entire communication, are completely shielded from the programmer. 2.2 NexusJava Nexus <ref> [5] </ref> is a communication library, providing dynamic resource management, multithreading and multiple methods for communication, allowing it to operate in a heterogeneous environment. NexusJava [6] is an implementation of a subset of Nexus in Java. The Nexus interface is organized around six basic abstractions, which are illustrated in Figure 3.
Reference: [6] <author> I. Foster, G.K. Thiruvathukal, and S. Tuecke. </author> <title> Technologies for ubiquitous supercomputing: a Java interface to the Nexus communication system. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 465-475, </pages> <month> jun </month> <year> 1997. </year>
Reference-contexts: This way, the stub and skeleton objects, and thus the entire communication, are completely shielded from the programmer. 2.2 NexusJava Nexus [5] is a communication library, providing dynamic resource management, multithreading and multiple methods for communication, allowing it to operate in a heterogeneous environment. NexusJava <ref> [6] </ref> is an implementation of a subset of Nexus in Java. The Nexus interface is organized around six basic abstractions, which are illustrated in Figure 3. A node represents a physical processing resource.
Reference: [7] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley Developers Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Java <ref> [7] </ref> is a portable, object oriented programming language. Its portability is obtained by compiling Java source code into bytecode which can be directly executed by a Java Virtual Machine (JVM) running on any host. The main operation in the Java language is the invocation of a method on an object.
Reference: [8] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <month> jul </month> <year> 1995. </year>
Reference-contexts: Another goal when designing distributed object technology is to provide inter-operability between different languages. The CORBA project <ref> [8] </ref> is designed to enable objects written in any language to invoke methods on remote objects written in any other language. In this report we take a look at our implementation of Java RMI on top of the Nexus communication library.
Reference: [9] <author> Objectspace. </author> <title> Objectspace Voyager Core Package Technical Overview, </title> <year> 1997. </year>
Reference-contexts: Because, however, there is a growing demand for distributed applications, a number of distributed object models have been developed for the Java programming language that simplify distributed programming in an object oriented environment. Examples of such distributed object models are Voyager <ref> [9] </ref>, Infospheres [4] and Java RMI [10]. While the former two aim at a flexible and highly dynamic framework, the last one aims at providing a syntax for remote method invocation identical to the syntax for method invocation on local objects.
Reference: [10] <author> Sun Microsystems. </author> <title> Java Remote Method Invocation Specification, </title> <month> feb </month> <year> 1997. </year> <month> 20 </month>
Reference-contexts: Because, however, there is a growing demand for distributed applications, a number of distributed object models have been developed for the Java programming language that simplify distributed programming in an object oriented environment. Examples of such distributed object models are Voyager [9], Infospheres [4] and Java RMI <ref> [10] </ref>. While the former two aim at a flexible and highly dynamic framework, the last one aims at providing a syntax for remote method invocation identical to the syntax for method invocation on local objects. Another goal when designing distributed object technology is to provide inter-operability between different languages. <p> Section 6 concludes this report. 1 2 Preliminaries This section first gives an overview of Java RMI, describing the most important classes and methods involved with an example. For a more rigorous description of the RMI interface we refer to <ref> [10] </ref>. After that we will describe the NexusJava library for communication, describing the most important classes and methods with a simple example. 2.1 Java RMI To provide communication between objects in different JVM's, the Java API contains classes that implement the socket mechanism. <p> This method can extract the data from the GetBuffer with the various get -methods of the GetBuffer class. Eventually, the method returns a message to the client startpoint. 3 RMI classes Implementing the RMI protocol involves implementing the classes from the RMI interface as described in <ref> [10] </ref>.
References-found: 10

