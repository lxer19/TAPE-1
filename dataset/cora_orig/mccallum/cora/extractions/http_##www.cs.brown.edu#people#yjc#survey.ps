URL: http://www.cs.brown.edu/people/yjc/survey.ps
Refering-URL: http://www.cs.brown.edu/people/yjc/
Root-URL: http://www.cs.brown.edu/
Email: (yjc@cs.brown.edu, rt@cs.brown.edu)  
Title: Dynamic Algorithms in Computational Geometry (Revised Version)  
Author: Yi-Jen Chiang Roberto Tamassia 
Note: (September 1992) Research supported in part by the National Science Foundation under grant CCR-9007851, and by the U.S. Army Research Office under grant DAAL03-91-G-0035.  
Address: Providence, RI 02912-1910  
Affiliation: Department of Computer Science Brown University  
Abstract: Research on dynamic algorithms for geometric problems has received increasing attention in the last years, and is motivated by many important applications in circuit layout, computer graphics, and computer-aided design. In this paper we survey dynamic algorithms and data structures in the area of computational geometry. Our work has a twofold purpose: it introduces the area to the nonspecialist and reviews the state-of-the-art for the specialist. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.M. </author> <title> Adel'son-Vel'skii and E.M. Landis, "An Information Organization Algorithm," </title> <journal> Doklady Akad. Nauk SSSR 146 (1962), </journal> <pages> 263-266. </pages>
Reference-contexts: In the former, one balances the height of the subtrees of each node, while in the latter, one balances the number of nodes in the subtrees of each node. Examples of height balanced trees are AVL trees <ref> [1] </ref> and red-black trees [75]. Weight-balanced trees were first presented in [119] and 2 include BB [ff] trees [25]. All of these trees use O (n) space and support each operation of the above repertory in time O (log n).
Reference: [2] <author> P. Agarwal and M. Sharir, </author> <title> "Applications of a New Space Partitioning Technique," </title> <booktitle> Lecture Notes in Computer Science 519 (1991), </booktitle> <pages> 379-391. </pages>
Reference-contexts: The actual performance bounds are obtained by combining the results on constructing a spanning tree of low stabbing number. For example, Matousek [105] gives an algorithm with ST (n) = O (n n log 2 n) and c (n) = O ( n), Agarwal and Sharir <ref> [2] </ref> give a method with ST (n) = O (n log n) and c (n) = O (n 2 +* ) for any * &gt; 0, and Matousek [106] presents a result with ST (n) = O (n log n) and c (n) = O ( n2 O (log fl n) <p> In addition to giving an algorithm for constructing a spanning tree of low stabbing number, Agarwal and Sharir <ref> [2] </ref> also show how to perform segment intersection and ray-shooting in the plane dynamically, based on the space partitioning technique of Chazelle, Sharir and Welzl [35].
Reference: [3] <author> P.K. Agarwal, </author> <title> "Ray Shooting and Other Applications of Spanning Trees with Low Stabbing Number," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1989), </booktitle> <pages> 315-325. </pages>
Reference-contexts: Cheng and Janardan [40] improve and dynamize the static techniques of <ref> [3] </ref> for segment intersection and ray-shooting. Their method makes extensive use of a spanning path of low stabbing number, which is similar in concept to a spanning tree of low stabbing number, illustrated as follows: Let S 0 be a set of n points in the plane.
Reference: [4] <author> P.K. Agarwal and M. Sharir, </author> <title> "Planar Geometric Location Problems and Maintaining the Width of a Planar Set," Computational Geometry: </title> <booktitle> Theory and Applications 1 (2) (1991), </booktitle> <pages> 65-78. </pages>
Reference-contexts: The complete data structure resembles the range tree, and updates can be performed by rotations. Moreover, dynamic fractional cascading can be applied. The width of a point set is the minimum width of a strip (formed by two parallel lines) that encloses all the points. Agarwal and Sharir <ref> [4] </ref> study the following problem of off-line dynamic maintenance of width: given a real W &gt; 0 and a sequence of n insert/delete operations on the point set S, determine whether there is any i such that after the i-th operation, the width of S is at most W .
Reference: [5] <author> A. Aggarwal, L. Guibas, J. Saxe, and P.W. Shor, </author> <title> "A Linear-time Algorithm for Computing the Voronoi Diagram of a Convex Polygon," </title> <booktitle> Discrete and Computational Geometry 4 (1989), </booktitle> <pages> 591-604. </pages>
Reference-contexts: If we represent the Voronoi diagram with a point-location data structure, closest point queries take O (log n) time (see [133]). Also, given the Voronoi diagram of S, the all-nearest-neighbors problem can be solved in O (n) time [148]. Aggarwal et al. <ref> [5] </ref> show that in a planar Voronoi diagram, points can be inserted and deleted in O (n) time; this also leads to an update time of O (n) for maintaining the minimal distance of a point set, using O (n) space.
Reference: [6] <author> A. Andersson, </author> <title> "Improving Partial Rebuilding by Using Simple Balance Criteria," </title> <booktitle> Proc. WADS' 89, LNCS 382 (1989), </booktitle> <pages> 393-402. </pages>
Reference: [7] <author> A. Andersson, </author> <title> "Efficient Search Trees," </title> <institution> Dept. of Computer Science, Lund Univ., Sweden, </institution> <type> Ph.D. dissertation, </type> <year> 1990. </year>
Reference: [8] <author> C. Aragon and R.G. Seidel, </author> <title> "Randomized Search Trees," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 540-545. </pages>
Reference-contexts: The time complexity of these operations is O (log n), where n is the size of P . Details on balanced trees can be found in textbooks such as [46,110,160]. New techniques for rebuilding balanced tree structures are presented by Andersson [6,7]. Aragon and Seidel <ref> [8] </ref> present randomized search trees, whose balancing strategy is based on randomization. The performance bounds are expected-case, where the expectation is taken over all possible sequences of "coin flips" in the update algorithms, and does not rely on any assumptions about the input.
Reference: [9] <author> F. Aurenhammer and O. Schwarzkopf, </author> <title> "A Simple Online Randomized Incremental Algorithm for Computing Higher Order Voronoi Diagrams," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 142-151. </pages>
Reference-contexts: The expected running time over a random sequence of n insertions is O (k 2 n + n log n) for d = 2 and O (k dd=2e+1 n dd=2e ) for d &gt; 2. For d = 2, Aurenhammer and Schwarzkopf <ref> [9] </ref> give an on-line algorithm for maintaining k-th order Voronoi diagrams with O (k 2 n log n + kn log 3 n) expected running time and optimal space O (k (n k)).
Reference: [10] <author> H. Baumgarten, H. Jung, and K. Mehlhorn, </author> <title> "Dynamic Point Location in General Subdivisions," </title> <booktitle> Proc. of ACM-SIAM Symp. on Discrete Algorithms (1992), </booktitle> <pages> 250-258. </pages>
Reference-contexts: The data structure requires O (n + a) expected space and supports queries in O (log n) expected time. A segment can be inserted in O (log n + a=n) expected time and deleted in O ((1 + a=n) log log n) expected time. Baumgarten, Jung and Mehlhorn <ref> [10] </ref> give a fully dynamic data structure for planar point location in general subdivisions, where the updates consist of insertions and deletions of nonintersecting, except possibly at endpoints, line segments.
Reference: [11] <author> S.W. Bent, </author> <title> "Dynamic Weighted Data Structures," </title> <institution> Stanford Univ., </institution> <type> Ph.D. Dissertation, Report STAN-CS-82-916, </type> <year> 1982. </year>
Reference-contexts: access probabilities of the items are not known a priori, and the tree is updated after each access so that the access time of the i-th item with searching frequency w i is O (log w=w i ), where w is the sum of the frequencies of all items (see <ref> [11] </ref>). It is shown that the total rebalancing time for a mixed sequence of m accesses, insertions and (restricted) deletions in a self-organizing balanced binary tree initially storing n items is O (n + m).
Reference: [12] <author> S.W. Bent, D.D. Sleator, and R.E. Tarjan, </author> <title> "Biased Search Trees," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 545-568. </pages>
Reference-contexts: Analogous time bounds can be achieved for update operations. See, e.g., the biased search trees of Bent, Sleator and Tarjan <ref> [12] </ref>. Several data structures for computational geometry are obtained by augmenting a balanced tree with secondary structures stored at its nodes, thus the cost to perform a rotation is no longer O (1) since we also have to update the secondary structures.
Reference: [13] <author> J.L. Bentley, </author> <title> "Multidimensional Binary Search Trees Used for Associative Searching," </title> <booktitle> Comm. ACM 18 (1975), </booktitle> <pages> 509-517. </pages>
Reference-contexts: The technique of [172] modifies the first-generation k-fold tree of Bentley and Shamos [21] and achieves O (log d n) query and update time, with space O (n (log n= log log n) d1 ). The idea of k-dimensional binary trees, or kd-trees, was first presented in <ref> [13] </ref>. It is a k-dimensional generalization of balanced search trees. For simplicity, consider the case k = 2. First, the point set is partitioned evenly by the vertical line through the median of the x-coordinates.
Reference: [14] <author> J.L. Bentley, </author> <title> "Algorithms for Klee's Rectangle Problems," </title> <institution> Dept. of Computer Science, Carnegie-Mellon Univ., </institution> <note> unpublished notes, 1977 . 37 </note>
Reference-contexts: [15] and [121] to get a data structure with O (n) space, O (n 11=d (log n) O (1) ) query time, O (log n) amortized deletion time and O (log 2 n) amortized insertion time. 5 Intersections 5.1 Segment Tree The segment tree data structure was introduced by Bentley <ref> [14] </ref>. Let X be a set of N points on a line, and S a set of n segments with endpoints in X.
Reference: [15] <author> J.L. Bentley, </author> <title> "Decomposable Searching Problems," </title> <booktitle> Information Processing Letters 8 (1979), </booktitle> <pages> 244-251. </pages>
Reference-contexts: The equal block method is developed by Maurer and Ottmann [107], van Leeuwen and Wood [99] and van Leeuwen and Maurer [97]. The simple version stated here is based on van Leeuwen and Overmars [98]. The first version of the logarithmic method is given by Bentley <ref> [15] </ref>. It is extended by Bentley and Saxe [20] who describe some more general methods and by Overmars and van 5 Leeuwen [123,127] who show how to turn this insertion-only method to fully dynamic. Several variations of dynamization methods for decomposable problems are reported in [53,71,112,120,121, 125,126,140,152,169]. <p> He proposes an efficient partition scheme for point sets, and applies the dynamization techniques for decomposable searching problems of <ref> [15] </ref> and [121] to get a data structure with O (n) space, O (n 11=d (log n) O (1) ) query time, O (log n) amortized deletion time and O (log 2 n) amortized insertion time. 5 Intersections 5.1 Segment Tree The segment tree data structure was introduced by Bentley [14].
Reference: [16] <author> J.L. Bentley, </author> <title> "Multidimensional Divide-and-Conquer," </title> <booktitle> Communication ACM 23 (1980), </booktitle> <pages> 214-228. </pages>
Reference-contexts: Hence, the space requirement is O (n log n). By presorting the points both by x- and y-coordinate, O (n log n) preprocessing time can be achieved <ref> [16] </ref>. Let R = (x 1 ; x 2 ) fi (y 1 ; y 2 ) be the query range.
Reference: [17] <author> J.L. Bentley, </author> <title> "K-d Trees for Semidynamic Point Sets," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1990). </booktitle>
Reference-contexts: Bentley [17,18] considers several proximity searching problems in a semi-dynamic point set. In <ref> [17] </ref>, kd-trees are used to support the nearest neighbour query and the fixed-radius nearest neighbour query, which asks for reporting all points within a fixed radius of a given query point.
Reference: [18] <author> J.L. Bentley, </author> <title> "Fast Algorithms for Geometric Traveling Salesman Problems," </title> <institution> AT & T Bell Lab., </institution> <note> Computing Science Technical Report No. 151, </note> <year> 1990 </year> . 
Reference-contexts: Also, a sampling technique reduces the time to build a tree from O (kn log n) to O (kn + n log n). <ref> [18] </ref> shows how proximity searches in semi-dynamic point sets are able to yield efficient practical algorithms for problems such as minimum spanning trees, approximate matchings, and a wide variety of traveling salesman heuristics. Closest point searching with updates restricted to insertions only is a decomposable searching problem.
Reference: [19] <author> J.L. Bentley and H.A. Mauer, </author> <title> "Efficient Worst-case Data Structures for Range Searching," </title> <journal> Acta Informatica 13 (1980), </journal> <pages> 155-168. </pages>
Reference-contexts: This decomposition process is represented by a binary tree. Detailed discussion on kd-trees can be found in [13,84,96,133]. Dynamic k-d trees are discussed in Overmars' thesis [121] (section 5.3.2). A local reorganization technique improving the performance of kd-trees is presented in [47]. Bentlely and Mauer <ref> [19] </ref> and Willard [171] describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19]. <p> Detailed discussion on kd-trees can be found in [13,84,96,133]. Dynamic k-d trees are discussed in Overmars' thesis [121] (section 5.3.2). A local reorganization technique improving the performance of kd-trees is presented in [47]. Bentlely and Mauer <ref> [19] </ref> and Willard [171] describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19]. <p> Bentlely and Mauer <ref> [19] </ref> and Willard [171] describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19]. All these data structures have no worse than O (log 2 n) update time under the static-to-dynamic transformation. 11 A functional approach that results in dynamic data structures with linear size for aggregate query, range counting and range reporting is given by Chazelle [30].
Reference: [20] <author> J.L. Bentley and J. Saxe, </author> <title> "Decomposable Searching Problems I: Static to Dynamic Transformations," </title> <editor> J. </editor> <booktitle> Algorithms 1 (1980), </booktitle> <pages> 301-358. </pages>
Reference-contexts: The simple version stated here is based on van Leeuwen and Overmars [98]. The first version of the logarithmic method is given by Bentley [15]. It is extended by Bentley and Saxe <ref> [20] </ref> who describe some more general methods and by Overmars and van 5 Leeuwen [123,127] who show how to turn this insertion-only method to fully dynamic. Several variations of dynamization methods for decomposable problems are reported in [53,71,112,120,121, 125,126,140,152,169]. <p> By treating range searching as a decomposable searching problem and applying the static-to-dynamic transformation of Bentley and Saxe <ref> [20] </ref>, one gets a technique with query time O (log d+1 n), amortized update time O (log d n), and space O (n log d1 n).
Reference: [21] <author> J.L. Bentley and M.I. Shamos, </author> <title> "A Problem in Multivariate Statistics: Algorithms, Data Structure, </title> <booktitle> and Applications," Proc. 15th Allerton Conference on Communication, Control, and Computing (1977), </booktitle> <pages> 193-201. </pages>
Reference-contexts: An aggregate query consists of computing the semigroup sum of the values of the points in the query range. The technique of [172] modifies the first-generation k-fold tree of Bentley and Shamos <ref> [21] </ref> and achieves O (log d n) query and update time, with space O (n (log n= log log n) d1 ). The idea of k-dimensional binary trees, or kd-trees, was first presented in [13]. It is a k-dimensional generalization of balanced search trees.
Reference: [22] <author> M. de Berg, </author> <title> "Dynamic Output-Sensitive Hidden Surface Removal for c-Oriented Polyhedra," </title> <institution> Dept. of Computer Science, Utrecht Univ., Report RUU-CS-91-6, </institution> <year> 1991. </year>
Reference-contexts: This structure is used to perform hidden-line elimination in time O ((n + k) log 2 n) for terrains, where k is the number of edges of the display. De Berg <ref> [22] </ref> presents an output-sensitive algorithm to maintain the view of a set of c-oriented polyhedra under insertions and deletions, where a set of polyhedra is c-oriented if the number of different orientations of its edges is bounded by some constant c.
Reference: [23] <author> A.M. Berman, M.C. Paull, and B.G. Ryder, </author> <title> "Proving Relative Lower Bounds for Incremental Algorithms," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 665-683. </pages>
Reference: [24] <author> M. Bern, </author> <title> "Hidden Surface Removal for Rectangles," </title> <journal> J. Computer and System Sciences (1990), </journal> <pages> 49-69. </pages>
Reference-contexts: Their data structure also supports the maintenance of the measure of the union, which can be reported in O (1) time. 9.3 Hidden Line or Surface Elimination Bern <ref> [24] </ref> considers a hidden-line removal problem in which the scene consists of n rectangles with sides parallel to the coordinate axes, and the viewpoint at z = 1. In [24] two methods are given for this problem. <p> of the measure of the union, which can be reported in O (1) time. 9.3 Hidden Line or Surface Elimination Bern <ref> [24] </ref> considers a hidden-line removal problem in which the scene consists of n rectangles with sides parallel to the coordinate axes, and the viewpoint at z = 1. In [24] two methods are given for this problem. The first is for static scenes, based on segment tree and heap structures, 32 with running time O (n log n + k log n), using space O (n log n), where k is the number of line segments in the output.
Reference: [25] <author> N. Blum and K. Mehlhorn, </author> <title> "On the Average Number of Rebalancing Operations in Weight-Balanced Trees," </title> <booktitle> Theoretical Computer Science 11 (1980), </booktitle> <pages> 303-320. </pages>
Reference-contexts: Examples of height balanced trees are AVL trees [1] and red-black trees [75]. Weight-balanced trees were first presented in [119] and 2 include BB [ff] trees <ref> [25] </ref>. All of these trees use O (n) space and support each operation of the above repertory in time O (log n). An important variation of balanced trees stores weighted items, where the weight of an item is usually associated with its access frequency in membership queries.
Reference: [26] <author> P. van Emde Boas, </author> <title> "Preserving Order in a Forest in less than Logarithmic Time," </title> <booktitle> Proc. 16th Symp. on Foundations of Computer Science (1975), </booktitle> <pages> 75-84. </pages>
Reference: [27] <author> P. van Emde Boas, </author> <title> "Preserving Order in a Forest in less than Logarithmic Time and Linear Space," </title> <booktitle> Information Processing Letters 6 (1977), </booktitle> <pages> 80-82. </pages>
Reference: [28] <author> J.D. Boissonnat, O. Devillers, R. Schott, M. Teillaud, and M. Yvinec, </author> <title> "Applications of Random Sampling to On-line Algorithms in Computational Geometry," </title> <note> Discrete and Computational Geometry (to appear). </note>
Reference-contexts: Devillers, Teillaud and Yvinec [48] describe a randomized algorithm for dynamic point location in an arrangement of line segments in the plane. They generalize the influence graph data structure of <ref> [28] </ref> to dynamically maintain the trapezoidal map of an arrangement of segments, and assume that the insertion sequences are evenly distributed among the n! possible sequences of n segments, and any already inserted segment can be deleted with the same probability. Let a denote the current size of the arrangement.
Reference: [29] <author> B. Chazelle, </author> <title> "On the Convex Layers of a Planar Set," </title> <journal> IEEE Trans. Inf. Theory IT-31 (4) (1985), </journal> <pages> 509-517. </pages>
Reference-contexts: Hence, finding the supporting vertices and updating the convex hull takes O (log n) time. Some deletion-only data structures with linear size and O (log n) amortized deletion time for planar convex hulls are given by Chazelle <ref> [29] </ref> and by Hershberger and Suri [77]. 25 7.2 Fully Dynamic Maintenance of Planar Convex Hulls Now we describe the fully dynamic convex hull technique of Overmars and van Leeuwen [124].
Reference: [30] <author> B. Chazelle, </author> <title> "A Functional Approach to Data Structures and its Use in Multidimensional Searching," </title> <note> SIAM J. Computing 17 (3) (1988), 427-462. </note>
Reference-contexts: All these data structures have no worse than O (log 2 n) update time under the static-to-dynamic transformation. 11 A functional approach that results in dynamic data structures with linear size for aggregate query, range counting and range reporting is given by Chazelle <ref> [30] </ref>. The query and update time are both O (log 4 n) for aggregate query, both O (log 2 n) for range counting, and respectively O (k (log (2n=k)) 2 ) and O (log 2 n) for range reporting. Van Kreveld and Overmars [92,93] give two methods for range searching.
Reference: [31] <author> B. Chazelle, </author> <title> "Triangulating a Simple Polygon in Linear Time," </title> <booktitle> Proc. of IEEE Symp. on Foundation of Computer Science (1990), </booktitle> <pages> 220-230. 38 </pages>
Reference-contexts: Optimal solutions for static planar point location are presented in [57,89,142]. All of them have O (log n) query time, O (n log n) preprocessing time, and O (n) space requirement; by Chazelle's triangulation result <ref> [31] </ref>, the preprocessing time of [57] and [89] can be further improved to O (n) for connected subdivisions. Update operations for planar point location consist of inserting or deleting a vertex or an edge into the subdivision.
Reference: [32] <author> B. Chazelle, </author> <title> "Lower Bounds for Orthogonal Range Search II. The Arithmetic Model," </title> <journal> Journal of ACM 37 (1990), </journal> <pages> 439-463. </pages>
Reference: [33] <author> B. Chazelle and L.J. Guibas, </author> <title> "Fractional Cascading: II. </title> <booktitle> Applications," Algorithmica 1 (1986), </booktitle> <pages> 163-191. </pages>
Reference: [34] <author> B. Chazelle and L.J. Guibas, "Fractional Cascading: I. </author> <title> A Data Structuring Technique," </title> <booktitle> Al-gorithmica 1 (1986), </booktitle> <pages> 133-162. </pages>
Reference-contexts: Let k denote the size of the query tree T . The static fractional cascading technique of Chazelle and Guibas [33,34] achieves O (log n + k) query time. Regarding dynamic fractional cascading, Chazelle and Guibas <ref> [34] </ref> show that insertions and deletions of elements can be supported in O (log n) amortized time, such that the query time is O (log n + k log log n). <p> A variation of this method supports updates in a semi-dynamic environment in which only insertions are performed. In this case the centroid decomposition of the dual tree is explicitly maintained in a BB [ff] tree [110], and a simple version of fractional cascading <ref> [34] </ref> is applied to improve the query time to O (log n log log n) while also improving the complexity of updates to O (1) amortized time. Chiang and Tamassia [42] present a fully dynamic data structure for point location in a monotone subdivision, based on the trapezoid method [131].
Reference: [35] <author> B. Chazelle, M. Sharir, and E. Welzl, </author> <title> "Quasi-optimal Upper Bounds for Simplex Range Searching and New Zone Theorems," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1990), </booktitle> <pages> 23-33. </pages>
Reference-contexts: In addition to giving an algorithm for constructing a spanning tree of low stabbing number, Agarwal and Sharir [2] also show how to perform segment intersection and ray-shooting in the plane dynamically, based on the space partitioning technique of Chazelle, Sharir and Welzl <ref> [35] </ref>.
Reference: [36] <author> B. Chazelle and E. Welzl, </author> <title> "Quasi-optimal range searching in space with finite VC-dimension," </title> <booktitle> Discrete and Computational Geometry 4 (1989), </booktitle> <pages> 467-489. </pages>
Reference-contexts: Let ST (n) be the time required to construct such a tree. It is shown in <ref> [36] </ref> that a spanning tree of stabbing number c (n) can be transformed in linear time into a possibly self-intersecting spanning path with stabbing number at most 2c (n), thus the time SP (n) to construct such a path is O (ST (n)).
Reference: [37] <author> S.W. Cheng and R. Janardan, </author> <title> "Efficient Dynamic Algorithms for Some Geometric Intersection Problems," </title> <booktitle> Information Processing Letters 36 (1990), </booktitle> <pages> 251-258. </pages>
Reference-contexts: Updates are restricted to a fixed set of O (n) coordinates for the segment endpoints. This restriction can be removed by using a BB [ff] tree for the primary interval tree. Cheng and Janardan <ref> [37] </ref> give an algorithm for orthogonal segment intersection queries in the plane, with O (n) space, O (log 2 n + k) query time and O (log n) insertion/deletion time. <p> Cheng and Janardan <ref> [37] </ref> consider two special kinds of segment intersection problems: given a set S of nonintersecting but possibly touching line segments in the plane under insertions and deletions, report the k segments that are intersected by (i) a query segment of fixed slope; (ii) a query segment whose supporting line passes through
Reference: [38] <author> S.W. Cheng and R. Janardan, </author> <title> "New Results on Dynamic Planar Point Location," </title> <booktitle> Proc. 31st IEEE Symp. on Foundations of Computer Science (1990), </booktitle> <pages> 96-105. </pages>
Reference-contexts: Finally, by setting b (n) = n * , we obtain O (log n) query time and O (n * log n) update time. Cheng and Janardan <ref> [38] </ref> present two methods for dynamic planar point-location in connected subdivisions. Their first method achieves O (log 2 n) query time, O (log n) time for inserting/deleting a vertex, and O (k log n) time for inserting/deleting a chain of k edges. <p> Baumgarten, Jung and Mehlhorn [10] give a fully dynamic data structure for planar point location in general subdivisions, where the updates consist of insertions and deletions of nonintersecting, except possibly at endpoints, line segments. They combine interval trees, segment trees, fractional cascading and the data structure of <ref> [38] </ref>, and achieve O (n) space, O (log n log log n) query and insertion time and O (log 2 n) deletion time, where the time bounds for updates are amortized.
Reference: [39] <author> S.W. Cheng and R. Janardan, </author> <title> "Efficient Maintenance of the Union of Intervals on a Line, with Applications," </title> <editor> J. </editor> <booktitle> Algorithms 12 (1991), </booktitle> <pages> 57-74. </pages>
Reference-contexts: Cheng and Janardan <ref> [39] </ref> improve the update time to O (log n), while the time for queries increases by replacing the log k terms with log n.
Reference: [40] <author> S.W. Cheng and R. Janardan, </author> <title> "Algorithms for Ray-shooting and Intersection Searching," </title> <type> manuscript, </type> <year> 1991. </year> <title> See also: "Space-efficient Ray-shooting and Intersection Searching: Algorithms, </title> <booktitle> Dynamization, and Applications," Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 7-16. </pages>
Reference-contexts: Cheng and Janardan <ref> [40] </ref> improve and dynamize the static techniques of [3] for segment intersection and ray-shooting. <p> Let w (n) be the working storage needed to construct a spanning path 17 of stabbing number c (n). The data structure of <ref> [40] </ref> uses space O (n log 2 n + w (n)) and supports segment intersection and ray-shooting queries in O (c (n) log 2 n + k log 2 n) and O (c (n) log 2 n) time, respectively.
Reference: [41] <author> Y.-J. Chiang, F.P. Preparata, and R. Tamassia, </author> <title> "A Unified Approach to Dynamic Point Location, Ray Shooting and Shortest Paths in Planar Maps," </title> <institution> Dept. of Computer Science, Brown Univ., </institution> <type> Technical Report No. </type> <institution> CS-92-07, </institution> <year> 1992. </year>
Reference-contexts: Since the orthogonal segment intersection queries (see Section 5.4) are a special case of the queries of the first kind, they are also solved within the same complexity bounds. Chiang, Preparata and Tamassia <ref> [41] </ref> present a fully dynamic technique for ray-shooting and segment intersection in a connected planar subdivision, using a unified approach (see Section 6.2). <p> They combine interval trees, segment trees, fractional cascading and the data structure of [38], and achieve O (n) space, O (log n log log n) query and insertion time and O (log 2 n) deletion time, where the time bounds for updates are amortized. Chiang, Preparata and Tamassia <ref> [41] </ref> present a fully dynamic technique for planar point location in connected subdivisions, where the update operations are insertions and deletions of vertices and edges. <p> Chiang, Preparata and Tamassia <ref> [41] </ref> use a unified approach (see Section 6.2) to solve the dynamic shortest path problem in a connected planar subdivision M , where each region of M is a simple polygon; the updates consist of insertions and deletions of vertices and edges.
Reference: [42] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamization of the Trapezoid Method for Planar Point Location," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 61-70. </pages>
Reference-contexts: Chiang and Tamassia <ref> [42] </ref> present a fully dynamic data structure for point location in a monotone subdivision, based on the trapezoid method [131]. The operations supported are insertion and deletion of vertices and edges, and horizontal translation of vertices. <p> Moreover, a hull structure, which is a modification of the dynamic convex hull structure of Overmars and van Leeuwen [124], is augmented to the normalization structure, so that the spanning tangents introduced in Chiang and Tamassia <ref> [42] </ref> can be computed efficiently. Point location queries are 23 supported by a separate location structure, which is a dynamic version of the trapezoid tree [131]: it is not explicitly balanced but instead represented by a dynamic tree [149].
Reference: [43] <author> Y.T. Ching, K. Mehlhorn, and M.H.M. Smid, </author> <title> "Dynamic Deferred Data Structuring," </title> <booktitle> Information Processing Letters 35 (1990), </booktitle> <pages> 37-40. </pages>
Reference-contexts: Several dynamic deferred data structuring methods for some membership problems are given by Smid [151] and Ching, Mehlhorn and Smid <ref> [43] </ref>. An off-line dynamic convex hull problem is studied by Hershberger and Suri [78]. They show that a sequence of n operations, each an insertion, deletion, or query, can be processed in time O (n log n) using O (n) space, provided all the operations are known in advance.
Reference: [44] <author> R.F. Cohen, G. Di Battista, R. Tamassia, I.G. Tollis, and P. Bertolazzi, </author> <title> "A framework for dynamic graph drawing," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1992), </booktitle> <pages> 261-270. </pages>
Reference-contexts: Graph drawing algorithms are surveyed in [52]. In the following we denote with n and m the number of vertices and edges of a given graph. Cohen et al. <ref> [44] </ref> describe a framework for dynamic graph drawing algorithms. At a first glance, it appears that updating a drawing may require (n+m) time in the worst case, since one may have to change the coordinates of all vertices and edges. <p> Work on dynamic graph drawing is as follows. Moen [113] considers trees and presents a technique that restructures the drawing of a tree in time proportional to its height, and hence linear in the worst case. Cohen et al. <ref> [44] </ref> present several techniques for dynamic drawing of trees and planar graphs.
Reference: [45] <author> R.F. Cohen and R. Tamassia, </author> <title> "Dynamic Expression Trees and their Applications," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 52-61. </pages>
Reference-contexts: CSG representations are a fundamental tool in computer graphics. Several efficient algorithms are given in [69] for CSG classification problems, such as determining whether a query point is inside a compound object. Cohen and Tamassia <ref> [45] </ref> study a dynamic point inclusion problem in which a collection of compound objects is modified by changing their primitive constituents and by update operations, such as link and cut, on their CSG-trees. Queries consist of reporting whether a given compound object contains a fixed point p.
Reference: [46] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, MIT Press, </publisher> <year> 1990. </year>
Reference: [47] <author> W. Cunto, G. Lau, and P. Flajolet, </author> <title> "Analysis of KDT-Trees: KD-Trees Improved by Local Reorganizations," </title> <booktitle> Proc. WADS' 89, LNCS 382 (1989), </booktitle> <pages> 24-38. </pages>
Reference-contexts: This decomposition process is represented by a binary tree. Detailed discussion on kd-trees can be found in [13,84,96,133]. Dynamic k-d trees are discussed in Overmars' thesis [121] (section 5.3.2). A local reorganization technique improving the performance of kd-trees is presented in <ref> [47] </ref>. Bentlely and Mauer [19] and Willard [171] describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19].
Reference: [48] <author> O. Devillers, M. Teillaud, and M. Yvinec, </author> <title> "Dynamic Location in an Arrangement of Line Segments in the Plane," </title> <booktitle> Algorithms Review 2 (3) (1992), </booktitle> <pages> 89-103. 39 </pages>
Reference-contexts: The algoritm is based on random sampling and achieves ~ O (log 2 n) query time, with the expected running time on a random (N; ffi)-sequence of updates (see Section 4.4) close to optimal. Devillers, Teillaud and Yvinec <ref> [48] </ref> describe a randomized algorithm for dynamic point location in an arrangement of line segments in the plane.
Reference: [49] <author> M.T. </author> <title> Dickerson and R.S. Drysdale, "Enumerating k distances for n points in the plane," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 234-238. </pages>
Reference: [50] <author> P.F. Dietz and R. Raman, </author> <title> "Persistence, Amortization and Randomization," </title> <booktitle> Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 78-88. </pages>
Reference-contexts: Mehlhorn and Naher's dynamic fractional cascading data structure [111] improves the update time down to O (log log n) amortized. Also, if only insertions or deletions are allowed, the O (log log n) factor in the query and update time decreases to O (1). Dietz and Raman <ref> [50] </ref> eliminate the amortization and show how to obtain O (log log n) worst-case update time. 3 General Dynamization Methods Several general techniques have been developed for constructing dynamic data structures from static ones. Overmars' thesis [121] describes in detail the results in this area until 1983.
Reference: [51] <author> D. Dobkin and S. Suri, </author> <title> "Dynamically Computing the Maxima of Decomposable Functions, with Applications," </title> <booktitle> Proc. 30th IEEE Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 488-493. </pages>
Reference-contexts: This can be applied to all data structures for decomposable search problems. Dobkin and Suri <ref> [51] </ref> have recently presented a general technique for maintaining the maximum value of a symmetric function f (x; y) over pairs of elements of a dynamic set S. <p> The semi-on-line model lies between the o*ine and on-line models, in the sense that it assumes no knowledge of the insertions and partial knowledge of the deletions. The main result of <ref> [51] </ref> can be expressed as follows: If the function f admits a static data structure that can be constructed in time P (n) and allows one to find the maximum of f (x; y) over all y 2 S for a given x 2 S in time Q (n), then the <p> Supowit [158] shows how to dynamize heuristic algorithms for closest-point and farthest-point problems in the presence of deletions. Maintaining the minimum and maximum distance between points under a semi-on-line sequence of updates can be handled using the general technique of Dobkin and Suri <ref> [51] </ref> (see Section 3). They show that in the plane, such updates can be performed in O (log 2 n) amortized time. Using [152], this update time can be made worst-case. <p> In [155], an algorithm is given that uses linear space and supports insertions only, in O (log d1 n) amortized time. It only uses algebraic functions and thus is optimal for the planar case. Another method of [155] is a variation of Dobkin and Suri <ref> [51] </ref>, and gives a linear size data structure that supports each semi-on-line update in O (log 2 n) time for arbitrary fixed dimension. If only insertions take place, the update time can be improved to O (log 2 n= log log n).
Reference: [52] <author> P. Eades and R. Tamassia, </author> <title> "Algorithms for Automatic Graph Drawing: An Annotated Bibliography," </title> <institution> Dept. of Computer Science, Brown Univ., </institution> <type> Technical Report CS-89-09, </type> <year> 1989. </year>
Reference-contexts: An upward drawing of an acyclic digraph has all the edges flowing in the same direction, e.g., from bottom to top. A visibility representation maps vertices into horizontal segments and edges into vertical segments that intersect only the two corresponding vertex segments. Graph drawing algorithms are surveyed in <ref> [52] </ref>. In the following we denote with n and m the number of vertices and edges of a given graph. Cohen et al. [44] describe a framework for dynamic graph drawing algorithms.
Reference: [53] <author> H. Edelsbrunner, </author> <title> "Optimizing the Dynamization of Decomposable Searching Problems," </title> <institution> IIG, Technische Univ. Graz, Austria, </institution> <note> Rep 35 (1979). </note>
Reference: [54] <author> H. Edelsbrunner, </author> <title> "A New Approach to Rectangle Intersections, Part II," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 221-229. </pages>
Reference: [55] <author> H. Edelsbrunner, </author> <title> "A New Approach to Rectangle Intersections, Part I," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 209-219. </pages>
Reference-contexts: This method is based on a new union-copy data structure for sets, which generalizes the well-known union-find structure. 5.3 Interval Tree Here we present the interval tree, a data structure due to Edelsbrunner <ref> [55] </ref>, which is called a 1-fold rectangle tree in the original paper. Let X be a set of N points on a line, and S a set of n segments with endpoints in X.
Reference: [56] <author> H. Edelsbrunner, </author> <title> Algorithms in Combinatorial Geometry, </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Section 10 concludes the paper with open problems. Previous tutorial and survey work in the area is as follows. A recent overview of major topics in computational geometry is given by F. Yao [175]. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner <ref> [56] </ref>, Mehlhorn [109] and by Preparata and Shamos [133]. Iyengar et al. [84] survey dynamic data structures for multidimensional searching. Overmars' thesis [121] is an excellent reference for dynamic computational geometry results up to 1983.
Reference: [57] <author> H. Edelsbrunner, L.J. Guibas, and J. Stolfi, </author> <title> "Optimal Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing 15 (1986), </journal> <pages> 317-340. </pages>
Reference-contexts: Optimal solutions for static planar point location are presented in [57,89,142]. All of them have O (log n) query time, O (n log n) preprocessing time, and O (n) space requirement; by Chazelle's triangulation result [31], the preprocessing time of <ref> [57] </ref> and [89] can be further improved to O (n) for connected subdivisions. Update operations for planar point location consist of inserting or deleting a vertex or an edge into the subdivision.
Reference: [58] <author> H. Edelsbrunner, G. Haring, and D. </author> <title> Hilbert, "Rectangular Point Location in d Dimensions with Applications," </title> <journal> The Computer Journal 29 (1986), </journal> <pages> 76-82. </pages>
Reference-contexts: Smid [155] considers the d-dimensional rectangular point location problem, where a set of n nonoverlapping d-dimensional axes-parallel hyperrectangles, or d-boxes, are stored in a data structure to support point location queries. The proposed data structure is based on the skewer tree of Edelsbrunner, Haring and Hilbert <ref> [58] </ref> and uses dynamic fracional cascading [111]. It uses linear space, answers queries in O (log d1 n log log n) time, and supports insertion, deletion, splitting and merging of d-boxes in O (log 2 n log log n) amortized time.
Reference: [59] <author> S. Fortune, </author> <title> "Stable Maintenance of Point-set Triangulations in Two Dimensions," </title> <booktitle> Proc. 30th Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 494-499. </pages>
Reference-contexts: trees to the technique of [69], they show that the dynamic point inclusion problem on a collection of compound objects defined by CSG-trees of total size n can be solved using an O (n)-space data structure that supports query and update operations in O (log n) time. 9.6 Approximation Fortune <ref> [59] </ref> considers geometric algorithms implemented using approximate arithmetic. An algorithm is robust if it always produces an output that is correct for some perturbation of its input; it is stable if the perturbation is small. An assertion of stability should be accompanied by a measure of the relative perturbation bound. <p> An assertion of stability should be accompanied by a measure of the relative perturbation bound. Perturbation can be measured as a function of the problem size n and the relative accuracy " of the approximate arithmetic. In <ref> [59] </ref> a technique to maintain the triangulation of a planar point set is presented, in which the triangulation is stored as a combinatorial planar graph embedding. The following operations are supported: point location, adding and deleting points, and changing edges.
Reference: [60] <author> P.G. Franciosa and M. Talamo, </author> <title> "An On-Line Convex Hull Algorithm on Reals," </title> <booktitle> ALCOM Workshop on Data Structure, Graph Algorithms, and Computational Geometry, </booktitle> <address> Berlin (Ger-many), </address> <month> October, </month> <year> 1990 </year> . 
Reference-contexts: The following operations are supported: point location, adding and deleting points, and changing edges. It achieves the stability assertion that, at any time, there is a relative perturbation of the points of size at most O (n 2 ") that makes the embedding actually planar. Franciosa and Talamo <ref> [60] </ref> study the problem of approximating the convex hull of a set of 34 points whose coordinates are real numbers, and thus may be of infinite length. They define an "-approximated convex hull, whose vertices are within distance " from the corresponding ones of the convex hull, and vice versa.
Reference: [61] <author> G. Frederickson and S. Rodger, </author> <title> "A New Approach to the Dynamic Maintenance of Maximal Points in a Plane," </title> <booktitle> Discrete and Computational Geometry 5 (1990), </booktitle> <pages> 365-374. </pages>
Reference-contexts: One can test if a point is maximal by performing a range query, using, e.g., the data structure of Willard and Lueker [169] or the priority search tree [108]. Frederickson and Rodger <ref> [61] </ref> consider the problem of maintaining the m-contour of S. Their data structure consists of a balanced tree that stores the points sorted by x-coordinate, plus several additional pointers. It uses O (n) space, supports insertions in O (log n) time and deletions in O (log 2 n) time. <p> Testing whether a point is inside, on, or outsided the m-contour takes O (log n) time. The m-contour can be reported in time O (m), where m is the number of points on the contour. Janardan [85] gives a technique that supports all operations of <ref> [61] </ref> within the same space and time bounds. In addition, it can report the m-contour of the points of S that lie to the left of a vertical query line, in O (log n + k) time, where k is the size of the answer.
Reference: [62] <author> M.L. Fredman, </author> <title> "The Inherent Complexity of Dynamic Data Structures Which Accomodate Range Queries," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1980), </booktitle> <pages> 191-199. </pages>
Reference-contexts: also given in [32,62,63,173]. [164] gives an upper bound that precisely matches the lower bounds of [63] and [173]; the difference between these two is that they obtain the same quantitative lower bounds under different models of computation. [88] gives an upper bound that nearly matches the lower bound of <ref> [62] </ref>. Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds.
Reference: [63] <author> M.L. Fredman, </author> <title> "A Lower Bound on the Complexity of Orthogonal Range Queries," </title> <journal> Journal of ACM 28 (1981), </journal> <pages> 696-706. </pages>
Reference-contexts: updates in O (log n) time and drawing queries in O (k log n) time. 9.8 Lower Bounds General lower bound techniques for dynamic algorithms are discussed in [23,64]; some relevant lower bounds are also given in [32,62,63,173]. [164] gives an upper bound that precisely matches the lower bounds of <ref> [63] </ref> and [173]; the difference between these two is that they obtain the same quantitative lower bounds under different models of computation. [88] gives an upper bound that nearly matches the lower bound of [62]. Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds.
Reference: [64] <author> M.L. Fredman and M.E. Saks, </author> <title> "The Cell Probe Complexity of Dynamic Data Structures," </title> <booktitle> Proc. 21st ACM Symp. on Theory of Computing (1989), </booktitle> <pages> 345-354. </pages>
Reference: [65] <author> M.L. Fredman and D.E. Willard, </author> <title> "Blasting through the Information Theoretic Barrier with Fusion Trees," </title> <booktitle> Proc. ACM Symp. on Theory of Computing (1990), </booktitle> <pages> 1-7. 40 </pages>
Reference: [66] <author> O. Fries, </author> <note> "Suchen in dynamischen planaren Unterteilungen," </note> <institution> Univ. des Saarlandes, </institution> <type> Ph.D. Thesis, </type> <year> 1990. </year>
Reference: [67] <author> O. Fries, K. Mehlhorn, and S. Naeher, </author> <title> "Dynamization of Geometric Data Structures," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1985), </booktitle> <pages> 168-176. </pages>
Reference: [68] <author> H.N. Gabow and R.E. Tarjan, </author> <title> "A Linear Time Algorithm for a Special Case of Disjoint Set Union," </title> <journal> J. </journal> <note> Computer and System Sciences 30 (1985). </note>
Reference-contexts: Imai and Asano [82,83] give two semi-dynamic techniques for the case in which updates are restricted to insertions only or deletions only, respectively; both techniques require that the y-coordinates of the segments be known in advance. The linear-time set-union and set-splitting algorithms of Gabow and Tarjan <ref> [68] </ref> are used for the secondary structures of the segment tree. They achieve O (n log n) space, O (log n + k) query time, and O (log n) amortized update time.
Reference: [69] <author> M.T. Goodrich, </author> <title> "Applying Parallel Processing Techniques to Classification Problems in Constructive Solid Geometry," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 118-128. </pages>
Reference-contexts: The resulting compound object is described by a CSG-tree whose leaves are the primitive objects and whose internal nodes are set operators. CSG representations are a fundamental tool in computer graphics. Several efficient algorithms are given in <ref> [69] </ref> for CSG classification problems, such as determining whether a query point is inside a compound object. <p> Queries consist of reporting whether a given compound object contains a fixed point p. By applying their dynamic expression trees to the technique of <ref> [69] </ref>, they show that the dynamic point inclusion problem on a collection of compound objects defined by CSG-trees of total size n can be solved using an O (n)-space data structure that supports query and update operations in O (log n) time. 9.6 Approximation Fortune [59] considers geometric algorithms implemented using
Reference: [70] <author> M.T. Goodrich and R. Tamassia, </author> <title> "Dynamic Trees and Dynamic Point Location," </title> <booktitle> Proc. 23th ACM Symp. on Theory of Computing (1991), </booktitle> <pages> 523-533. </pages>
Reference-contexts: As emphasized by the authors, such methods are mainly of theoretical interest, because they involve rather complex manipulations of data structures. Goodrich and Tamassia <ref> [70] </ref> show how to maintain a monotone subdivision dynamically so as to achieve O (n) space, O (log 2 n) query time, O (log n) time for vertex insertion/deletion, and O (log n+k) time for the insertion/deletion of a monotone chain with k edges.
Reference: [71] <author> G. Gowda and D.G. Kirkpatrick, </author> <title> "Exploiting Linear Merging and Extra Storage in the Maintenance of Fully Dynamic Geometric Data Structures," </title> <booktitle> Proc. 18th Annual Allerton Conf. on Communication, Control, and Computing (1980), </booktitle> <pages> 1-10. </pages>
Reference: [72] <author> I.G. Gowda, D.G. Kirkpatrick, D.T. Lee, and A. Naamad, </author> <title> "Dynamic Voronoi Diagrams," </title> <journal> IEEE Trans. Information Theory IT-29 (5) (1983), </journal> <pages> 724-731. </pages>
Reference: [73] <author> L.J. Guibas and J. Hershberger, </author> <title> "Optimal Shortest Path Queries in a Simple Polygon," </title> <booktitle> Proc. 3rd ACM Symposium on Computational Geometry (1987), </booktitle> <pages> 50-63. </pages>
Reference-contexts: For the static case, an optimal algorithm is given by Guibas and Hershberger <ref> [73] </ref> that supports shortest path and shortest path length queries in O (log n + k) and O (log n) time, respectively, with O (n) space and O (n) preprocessing time, where k is the number 33 of edges in the reported answer. <p> The hull structure is used to dynamically maintain the hourglasses introduced in <ref> [73] </ref> from which the shortest path can be computed. Moreover, efficient updates are ensured by the normalization structure.
Reference: [74] <author> L.J. Guibas, D.E. Knuth, and M. Sharir, </author> <title> "Randomized Incremental Construction of Delauney and Voronoi Diagrams," Automata, </title> <booktitle> Languages and Programming (Proc. 17th ICALP), Lecture Notes in Computer Science (1990), </booktitle> <pages> 414-431. </pages>
Reference-contexts: Aggarwal et al. [5] show that in a planar Voronoi diagram, points can be inserted and deleted in O (n) time; this also leads to an update time of O (n) for maintaining the minimal distance of a point set, using O (n) space. Guibas, Knuth, and Sharir <ref> [74] </ref> present an algorithm that incrementally constructs the Voronoi diagram of n sites in the plane by adding the sites one at a time in random order (and by updating the diagram each time) in total expected time O (n log n) using O (n) space.
Reference: [75] <author> L.J. Guibas and R. Sedgewick, </author> <title> "A Dichromatic Framework for Balanced Trees," </title> <booktitle> Proc. 19th IEEE Symp. on Foundations of Computer Science (1978), </booktitle> <pages> 8-21. </pages>
Reference-contexts: In the former, one balances the height of the subtrees of each node, while in the latter, one balances the number of nodes in the subtrees of each node. Examples of height balanced trees are AVL trees [1] and red-black trees <ref> [75] </ref>. Weight-balanced trees were first presented in [119] and 2 include BB [ff] trees [25]. All of these trees use O (n) space and support each operation of the above repertory in time O (log n).
Reference: [76] <author> L.J. Guibas and J. Stolfi, </author> <title> "Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams ," ACM Trans. </title> <booktitle> on Graphics 4(2) (1985), </booktitle> <pages> 75-123. </pages>
Reference-contexts: While edge insertion is uniquely defined, vertex insertion can be performed either by creating an isolated vertex, or by inserting a vertex along an existing edge, which is split into two edges. The dual operations of edge insertion and deletion are also useful <ref> [76] </ref>: an expansion splits a vertex v into two new vertices connected by an edge; each new vertex inherits a subsequence of the edges formerly incident on v.
Reference: [77] <author> J. Hershberger and S. Suri, </author> <title> "Applications of a Semi-Dynamic Convex Hull Algorithm," </title> <booktitle> Proc. SWAT'90, Lecture Notes in Computer Science 447 (1990), </booktitle> <pages> 380-392. </pages>
Reference-contexts: Hence, finding the supporting vertices and updating the convex hull takes O (log n) time. Some deletion-only data structures with linear size and O (log n) amortized deletion time for planar convex hulls are given by Chazelle [29] and by Hershberger and Suri <ref> [77] </ref>. 25 7.2 Fully Dynamic Maintenance of Planar Convex Hulls Now we describe the fully dynamic convex hull technique of Overmars and van Leeuwen [124].
Reference: [78] <author> J. Hershberger and S. Suri, </author> <title> "O*ine Maintenance of Planar Configurations," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 32-41. </pages>
Reference-contexts: Several dynamic deferred data structuring methods for some membership problems are given by Smid [151] and Ching, Mehlhorn and Smid [43]. An off-line dynamic convex hull problem is studied by Hershberger and Suri <ref> [78] </ref>. They show that a sequence of n operations, each an insertion, deletion, or query, can be processed in time O (n log n) using O (n) space, provided all the operations are known in advance. <p> Alternatively, a sequence of n insert and delete operations can be preprocessed in O (n log n) time and space such that queries in history (i.e., with respect to the point-set at a given time in the past) can be answered in O (log n) time. The method of <ref> [78] </ref> can be extended to the problems of maintaining off-line the maxima of a point-set, the intersection of a set of half-spaces, and the kernel of a simple polygon.
Reference: [79] <author> S. Huddleston and K. Mehlhorn, </author> <title> "Robust Balancing in B-Trees," </title> <booktitle> Lecture Notes in Computer Science 104 (1981), </booktitle> <pages> 234-244. </pages>
Reference: [80] <author> S. Huddleston and K. Mehlhorn, </author> <title> "A New Data Structure for Representing Sorted Lists," </title> <journal> Acta Informatica 17 (1982), </journal> <pages> 157-184. </pages>
Reference: [81] <author> C. Icking, R. Klein, and T. Ottmann, </author> <title> "Priority Search Trees in Secondary Memory," </title> <booktitle> Graph-Theoretic Concepts in Computer Science (Proc. Int. Workshop WG '87, </booktitle> <address> Kloster Banz, </address> <month> June </month> <year> 1987) (1988), </year> <pages> 84-93. </pages>
Reference-contexts: They give a dynamic data structure based on priority search trees, and achieve O (n) space, O (log n) update time and O (log n + k) query time for fixed polygonal window W , where k is the size of the reported answers. Icking, Klein and Ottman <ref> [81] </ref> have studied the problem of realizing priority search trees in external memory, where data are transferred in blocks of size B. They present two techniques derived from B-trees and a generalized version of red-black trees.
Reference: [82] <author> H. Imai and T. Asano, </author> <title> "Efficient Algorithms for Geometric Graph Search Problems," </title> <journal> SIAM J. Computing 15 (1986), </journal> <pages> 478-494. 41 </pages>
Reference: [83] <author> H. Imai and T. Asano, </author> <title> "Dynamic Orthogonal Segment Intersection Search," </title> <editor> J. </editor> <booktitle> Algorithms 8 (1987), </booktitle> <pages> 1-18. </pages>
Reference: [84] <author> S.S. Iyengar, R.L. Kashyap, V.K. Vaishnavi, and N.S.V. Rao, </author> <title> "Multidimensional Data Structures: Review and Outlook," </title> <booktitle> Advances in Computers 27 (1988), </booktitle> <pages> 69-94. </pages>
Reference-contexts: Previous tutorial and survey work in the area is as follows. A recent overview of major topics in computational geometry is given by F. Yao [175]. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner [56], Mehlhorn [109] and by Preparata and Shamos [133]. Iyengar et al. <ref> [84] </ref> survey dynamic data structures for multidimensional searching. Overmars' thesis [121] is an excellent reference for dynamic computational geometry results up to 1983.
Reference: [85] <author> R. Janardan, </author> <title> "On the Dynamic Maintenance of Maximal Points in the Plane," </title> <type> manuscript, </type> <year> 1991. </year>
Reference-contexts: Testing whether a point is inside, on, or outsided the m-contour takes O (log n) time. The m-contour can be reported in time O (m), where m is the number of points on the contour. Janardan <ref> [85] </ref> gives a technique that supports all operations of [61] within the same space and time bounds.
Reference: [86] <author> R. Janardan, </author> <title> "On Maintaining the Width and Diameter of a Planar Point-set Online," </title> <type> manuscript, </type> <year> 1991. </year>
Reference-contexts: They make use of the dynamic convex hull technique of Overmars and van Leeuwen [124] (as discussed in Section 7.2), so that the answer can be computed in O (n log 3 n) time, using O (n) space. Janardan <ref> [86] </ref> presents two approximation algorithms to respectively compute the width and the Euclidean distance between the furthest points (the diameter) of a planar point set S, under insertions and deletions.
Reference: [87] <author> R. Karp, R. Motwani, and P. Raghavan, </author> <title> "Deferred Data Structuring," </title> <journal> SIAM J. Computing 17(5) (1988), </journal> <pages> 883-902. </pages>
Reference-contexts: A tree-based data structure for planar convex hulls that implements these ideas is presented in [124], as described in the previous section. Karp, Motwani, and Raghavan <ref> [87] </ref> consider the problem of answering a sequence of on-line queries on a static data set. Let t be the number of queries, which is not known in advance. <p> This method may be wasteful when t is small. Namely, if t = o (log n), it is more convenient to avoid preprocessing and execute each query with an O (n)-time algorithm. In the deferred data structuring method of <ref> [87] </ref> the processing is query-driven, and builds up the data structure piece by piece, only when required for answering a query.
Reference: [88] <author> M.D. Katz and D.J. Volper, </author> <title> "Data Structures for Retrieval on Square Grids," </title> <journal> SIAM J. Computing 15 (1986), </journal> <pages> 919-931. </pages>
Reference-contexts: for dynamic algorithms are discussed in [23,64]; some relevant lower bounds are also given in [32,62,63,173]. [164] gives an upper bound that precisely matches the lower bounds of [63] and [173]; the difference between these two is that they obtain the same quantitative lower bounds under different models of computation. <ref> [88] </ref> gives an upper bound that nearly matches the lower bound of [62]. Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds.
Reference: [89] <author> D.G. Kirkpatrick, </author> <title> "Optimal Search in Planar Subdivisions," </title> <journal> SIAM J. Computing 12 (1983), </journal> <pages> 28-35. </pages>
Reference-contexts: Optimal solutions for static planar point location are presented in [57,89,142]. All of them have O (log n) query time, O (n log n) preprocessing time, and O (n) space requirement; by Chazelle's triangulation result [31], the preprocessing time of [57] and <ref> [89] </ref> can be further improved to O (n) for connected subdivisions. Update operations for planar point location consist of inserting or deleting a vertex or an edge into the subdivision.
Reference: [90] <author> D.G. Kirkpatrick and R. Seidel, </author> <title> "The Ultimate Planar Convex Hull Algorithm?," </title> <journal> SIAM J. Computing 15 (1986), </journal> <pages> 287-299. </pages>
Reference-contexts: It is shown that t convex hull membership queries can be performed in optimal time O ((n + t) log min (n; t)), using as a subroutine the Kirkpatrick-Seidel top-down convex hull algorithm <ref> [90] </ref>. Several dynamic deferred data structuring methods for some membership problems are given by Smid [151] and Ching, Mehlhorn and Smid [43]. An off-line dynamic convex hull problem is studied by Hershberger and Suri [78].
Reference: [91] <author> R. Klein, O. Nurmi, T. Ottman, and D. Wood, </author> <title> "A Dynamic Fixed Windowing Problem," </title> <booktitle> Algorithmica 4 (1989), </booktitle> <pages> 535-550. </pages>
Reference-contexts: They describe two classes of data structures for this problem, and dynamize them by using a new type of weight-balanced multiway trees as underlying structures. They thus obtain efficient dynamic data structures for orthogonal range searching, with trade-offs. Klein et al <ref> [91] </ref> study the following dynamic fixed windowing problem for planar point set: for a given planar point set S under insertions and deletions and a fiexed window W (a fixed planar region), perform the window-queries, that is, for an arbitrary query translate W q = W + q, report all points
Reference: [92] <author> M. van Kreveld and M.H. Overmars, </author> <title> "Divided K-D Trees," </title> <type> Tech. Report RUU-CS-88-28, </type> <institution> Dept. of Computer Science, Univ. of Utrecht, </institution> <address> Netherlands (1988). </address>
Reference-contexts: In <ref> [92] </ref>, they present a variant of the k-d tree, called divided k-d tree, to achieve the following performance: in the plane, O ( p n log n + k) time for range queries, O (log n) time for insertions/deletions, using O (n) space; in the d-dimensional case, range queries take O
Reference: [93] <author> M. van Kreveld and M.H. Overmars, </author> <title> "Concatenable Structures for Decomposable Problems," </title> <type> Tech. Report RUU-CS-89-16, </type> <institution> Dept. of Computer Science, Univ. of Utrecht, </institution> <address> Netherlands (1989). </address>
Reference-contexts: n, the dynamic query time and space requirement are the same as those of the static data structure, while the update time is guaranteed to be asymptotically smaller than the static preprocessing time. (Note that this is true for range counting but not for range searching.) Van Kreveld and Overmars <ref> [93] </ref> show how to obtain concatenable data structures from existing data structures, based on a technique called the ordered equal block method. This can be applied to all data structures for decomposable search problems. <p> Van Kreveld and Overmars [92,93] give two methods for range searching. In <ref> [93] </ref>, they study techniques to make existing data structures concatenable, and obtain a d-dimensional data structure for range searching that supports queries in O (n 11=d log n + k) time, insertions and deletions in O (log n) time, and splits and concatenations on all coordinates in O (n 11=d log <p> The interval tree can be modified to support one-dimensional segment intersection queries, which consist of reporting the segments intersected by a given query segment. The technique of making data structures concatenable due to van Kreveld and Overmars <ref> [93] </ref> results in a concatenable interval tree that supports stabbing queries in O ( p n log n + k) time, insertions, deletions, splits, and concatenations in O ( p n log n) time, with O (n) space. 15 5.4 Orthogonal Segment Intersection Queries Consider a set S of n horizontal <p> The method of [78] can be extended to the problems of maintaining off-line the maxima of a point-set, the intersection of a set of half-spaces, and the kernel of a simple polygon. The technique of van Kreveld and Overmars <ref> [93] </ref> to make data structures concatenable provides a data structure for reporting the convex hull within a query rectangle in time O ( p insertions and deletions take O (log 2 n) time and the space complexity is O (n).
Reference: [94] <author> M.J. van Kreveld and M.H. Overmars, </author> <title> "Union-copy Structures and Dynamic Segment Trees," </title> <institution> Dept. of Computer Science, Utrecht Univ., </institution> <note> Report RUU-CS-91-5, 1991. See also: </note> <editor> "Concaten-able Segment Trees," </editor> <booktitle> Proc. STACS 89, Lecture Notes in Computer Science,349 (1989), </booktitle> <pages> 493-504. </pages>
Reference-contexts: Hence, rebalancing takes O (log n) amortized time, and update operations take O (log n) amortized time. 5.2 Concatenable Segment Tree A concatenable version of the segment tree is given by van Kreveld and Overmars <ref> [94] </ref>, which can be used to answer the following one-dimensional stabbing queries: given a query segment s on the same line where the segments of S lie, report the k segments in S intersected by s.
Reference: [95] <author> D.T. Lee and F.P. Preparata, </author> <title> "Location of a Point in a Planar Subdivision and its Applications," </title> <journal> SIAM J. Computing 6 (1977), </journal> <pages> 594-606. </pages>
Reference-contexts: Fries and Mehlhorn [66,67] present a data structure for connected subdivisions with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time, using an approach based on the static chain-method <ref> [95] </ref>. The update operations supported are inserting and deleting edges and isolated vertices. If only insertions are performed, the update time is reduced to O (log 2 n) [109 (pp. 135-143)]. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively [135,136]. <p> If only insertions are performed, the update time is reduced to O (log 2 n) [109 (pp. 135-143)]. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively [135,136]. The data structure for monotone subdivisions [135] is based on the chain-method <ref> [95] </ref>. The repertory of update operations includes inserting vertices on edges, inserting monotone chains of edges, and their inverses. The space requirement is O (n). The query time is O (log 2 n).
Reference: [96] <author> D.T. Lee and C.K. Wong, </author> <title> "Worst-case Analysis of Region and Partial Region Searches in Multi-dimensional Binary Search Trees and Balance Quad Trees," </title> <journal> Acta Informatica 9 (1977), </journal> <pages> 23-29. </pages>
Reference: [97] <author> J. van Leeuwen and H.A. Maurer, </author> <title> "Dynamic Systems of Static Data Structures," </title> <type> Inst. f. Informationsverarbeitung, TU Graz, Tech. Report No. 42, </type> <year> 1980. </year>
Reference-contexts: The equal block method is developed by Maurer and Ottmann [107], van Leeuwen and Wood [99] and van Leeuwen and Maurer <ref> [97] </ref>. The simple version stated here is based on van Leeuwen and Overmars [98]. The first version of the logarithmic method is given by Bentley [15].
Reference: [98] <editor> J. van Leeuwen and M.H. Overmars, </editor> <booktitle> "The Art of Dynamizing," Proc. Symp. on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science 118 (1981), </booktitle> <pages> 121-131. 42 </pages>
Reference-contexts: The equal block method is developed by Maurer and Ottmann [107], van Leeuwen and Wood [99] and van Leeuwen and Maurer [97]. The simple version stated here is based on van Leeuwen and Overmars <ref> [98] </ref>. The first version of the logarithmic method is given by Bentley [15]. It is extended by Bentley and Saxe [20] who describe some more general methods and by Overmars and van 5 Leeuwen [123,127] who show how to turn this insertion-only method to fully dynamic.
Reference: [99] <author> J. van Leeuwen and D. Wood, </author> <title> "Dynamization of Decomposable Searching Problems," </title> <booktitle> Infor--mation Processing Letters 10 (1980), </booktitle> <pages> 51-56. </pages>
Reference-contexts: The equal block method is developed by Maurer and Ottmann [107], van Leeuwen and Wood <ref> [99] </ref> and van Leeuwen and Maurer [97]. The simple version stated here is based on van Leeuwen and Overmars [98]. The first version of the logarithmic method is given by Bentley [15].
Reference: [100] <author> W. Lipski, </author> <title> "Finding a Manhattan Path and Related Problems," </title> <booktitle> Networks 13 (1983), </booktitle> <pages> 399-409. </pages>
Reference: [101] <author> W. Lipski, </author> <title> "An O(n log n) Manhattan Path Algorithm," </title> <booktitle> Information Processing Letters 19 (1984), </booktitle> <pages> 99-102. </pages>
Reference: [102] <author> G. Lueker and D.E. Willard, </author> <title> "A Data Structure for Dynamic Range Queries," </title> <booktitle> Information Processing Letters 15 (1982), </booktitle> <pages> 209-213. </pages>
Reference-contexts: By treating range searching as a decomposable searching problem and applying the static-to-dynamic transformation of Bentley and Saxe [20], one gets a technique with query time O (log d+1 n), amortized update time O (log d n), and space O (n log d1 n). Lueker and Willard <ref> [102] </ref> illustrate an ad hoc construction using the Nievergelt-Reingold [119] notion of bounded balance, which gives a data structure with O (log d n) query time and amortized update time, using space O (n log d1 n). <p> Willard and Lueker [169] give a general transformation method that adds range searching capability to any dynamic data structure for a decomposable searching problem with a factor of O (log n) increase in time and space usage; their method improves the update time of <ref> [102] </ref> from amortized to worst-case, while all the other bounds remain the same. The query and update time can be further improved by using fractional cascading, as described in Section 4.2.
Reference: [103] <author> G.S. Lueker, </author> <title> "A Data Structure for Orthogonal Range Queries," </title> <booktitle> Proc. 19th IEEE Symp. on Foundations of Computer Science (1978), </booktitle> <pages> 28-34. </pages>
Reference: [104] <author> D. Maier and S.C. Salveter, </author> <note> "Hysterical B-Trees ," Information Processing Letters 12 (1981), 199-202. </note>
Reference: [105] <author> J. Matousek, </author> <title> "More on cutting arrangements and spanning trees with low crossing number," </title> <institution> Dept. of Computer Science, Charles Univ. Czechoslovakia, Tech. Report B-90-2, </institution> <year> 1990. </year>
Reference-contexts: The actual performance bounds are obtained by combining the results on constructing a spanning tree of low stabbing number. For example, Matousek <ref> [105] </ref> gives an algorithm with ST (n) = O (n n log 2 n) and c (n) = O ( n), Agarwal and Sharir [2] give a method with ST (n) = O (n log n) and c (n) = O (n 2 +* ) for any * &gt; 0, and
Reference: [106] <author> J. Matousek, </author> <title> "Efficient Partition Trees," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 1-9. </pages>
Reference-contexts: Let k be the number of points that lie in the query half space. The expected query time is O (k log n), and the total expected cost of maintaining the data structure over a random (N; ffi)-sequence is O (m bd=2c+* ) for any * &gt; 0. Matousek <ref> [106] </ref> consider the following simplex range searching problem: given a set of points in R d , each with a semigroup weight, report the points or compute the cumulative weight of the points that lie in a given query simplex. <p> an algorithm with ST (n) = O (n n log 2 n) and c (n) = O ( n), Agarwal and Sharir [2] give a method with ST (n) = O (n log n) and c (n) = O (n 2 +* ) for any * &gt; 0, and Matousek <ref> [106] </ref> presents a result with ST (n) = O (n log n) and c (n) = O ( n2 O (log fl n) ).
Reference: [107] <author> H.A. Maurer and T. Ottmann, </author> <title> "Dynamic Solutions of Decomposable Searching Problems," </title> <booktitle> Discrete Structures and Algorithms (1979), </booktitle> <pages> 17-24. </pages>
Reference-contexts: The equal block method is developed by Maurer and Ottmann <ref> [107] </ref>, van Leeuwen and Wood [99] and van Leeuwen and Maurer [97]. The simple version stated here is based on van Leeuwen and Overmars [98]. The first version of the logarithmic method is given by Bentley [15].
Reference: [108] <author> E.M. McCreight, </author> <title> "Priority Search Trees," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 257-276. </pages>
Reference-contexts: we get a range tree of size O (n (log n= log log n) d1 ), with query time O (log d+* n=(log log n) d1 + k) and amortized update time O (log d n=(log log n) d1 ). 4.3 Priority Search Tree The priority search tree of McCreight <ref> [108] </ref> efficiently supports a restricted type of range queries, where the query rectangle has at least one side at infinity. It is a hybrid of a heap (for the y-coordinates) and of a balanced search tree (for the x-coordinates). <p> The linear-time set-union and set-splitting algorithms of Gabow and Tarjan [68] are used for the secondary structures of the segment tree. They achieve O (n log n) space, O (log n + k) query time, and O (log n) amortized update time. McCreight <ref> [108] </ref> gives an O (n)-space data structure for orthogonal segment intersection with O (log 2 n + k) query time and O (log n) update time, using priority search trees as the secondary structure of an interval tree [108]. <p> McCreight <ref> [108] </ref> gives an O (n)-space data structure for orthogonal segment intersection with O (log 2 n + k) query time and O (log n) update time, using priority search trees as the secondary structure of an interval tree [108]. Updates are restricted to a fixed set of O (n) coordinates for the segment endpoints. This restriction can be removed by using a BB [ff] tree for the primary interval tree. <p> at the expense of increasing vertex insertion/deletion time to O (log n log log n) and increasing the query time to O (log 2 n log log n). 21 Both of their methods use O (n) space and are based on a search strategy derived from the pri-ority search tree <ref> [108] </ref> (see Section 4.3). <p> One can test if a point is maximal by performing a range query, using, e.g., the data structure of Willard and Lueker [169] or the priority search tree <ref> [108] </ref>. Frederickson and Rodger [61] consider the problem of maintaining the m-contour of S. Their data structure consists of a balanced tree that stores the points sorted by x-coordinate, plus several additional pointers. <p> This method uses a variation of the dynamic convex hull data structure of Overmars and van Leeuwen [124] (as discussed in Section 7.2) combined with the priority search tree <ref> [108] </ref>, plus some additional pointers. 9.2 Union of Intervals Given a set of intervals on a line, which is dynamically updated by insertions and deletions, we consider the problems of answering the following queries: * report the union of the intervals as a sequence of k disjoint intervals sorted from left <p> Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds. For instance, [174] shows that one can speed up the priority trees of <ref> [108] </ref> by a factor of log log n. 10 Open Problems Despite the increasing interest in the area of incremental computation, efficient dynamic algorithms are not known for many geometric problems.
Reference: [109] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 3: Multi-dimensional Searching and Computational Geometry, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Section 10 concludes the paper with open problems. Previous tutorial and survey work in the area is as follows. A recent overview of major topics in computational geometry is given by F. Yao [175]. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner [56], Mehlhorn <ref> [109] </ref> and by Preparata and Shamos [133]. Iyengar et al. [84] survey dynamic data structures for multidimensional searching. Overmars' thesis [121] is an excellent reference for dynamic computational geometry results up to 1983. <p> Mehlhorn <ref> [109] </ref> intorduces a variation of the above data structure, the range tree with slack parameter m: instead of augmenting each node with a secondary structure, only the nodes with depth divisible by m have secondary structures.
Reference: [110] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 1: Sorting and Searching, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: If f (`) = O (` log c `), with c 0, then the amortized rebalancing time of an update operation is O (log c+1 n); if f (`) = O (` a ), with a &lt; 1, then the amortized rebalancing time of an update operation is O (1) <ref> [110] </ref>. That is, even if a rotation may need considerable time to rebuild the secondary structures involved, the amortized cost per insertion/deletion is still fairly small, because expensive rebalancing actions are guaranteed not to occur too often. This property has been extensively used by a variety of geometric data structures. <p> A dynamic multidimensional file structure, called multidimensional (a, b)-tree, which is a multidimensional generalization of (a, b)-trees of <ref> [110] </ref> is presented in [166]. It is shown that a weak d-dimensional (a, b)-tree (with b 2a) of size n requires O (d (m + n)) time for a mixed sequence of m insertions and deletions. <p> They dynamize this approach with the BB [ff] tree data structure <ref> [110] </ref>, using the approach of Willard and Lueker [169] to spread local updates over future operations, and the method of Overmars [121] to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced. <p> A variation of this method supports updates in a semi-dynamic environment in which only insertions are performed. In this case the centroid decomposition of the dual tree is explicitly maintained in a BB [ff] tree <ref> [110] </ref>, and a simple version of fractional cascading [34] is applied to improve the query time to O (log n log log n) while also improving the complexity of updates to O (1) amortized time.
Reference: [111] <author> K. Mehlhorn and S. Naher, </author> <title> "Dynamic fractional cascading," </title> <booktitle> Algorithmica 5 (1990), </booktitle> <pages> 215-241. </pages>
Reference-contexts: Regarding dynamic fractional cascading, Chazelle and Guibas [34] show that insertions and deletions of elements can be supported in O (log n) amortized time, such that the query time is O (log n + k log log n). Mehlhorn and Naher's dynamic fractional cascading data structure <ref> [111] </ref> improves the update time down to O (log log n) amortized. Also, if only insertions or deletions are allowed, the O (log log n) factor in the query and update time decreases to O (1). <p> In the static case we obtain O (log n + k) query time [103,168,170]. In the dynamic case we have O (log n log log n + k) query time and O (log n log log n) update time <ref> [111] </ref>. <p> Dynamic fractional cascading eliminates these restrictions and achieves O (n log n) space, O (log n log log n+ k) query time, and O (log n log log n) update time <ref> [111] </ref> for the general problem. Imai and Asano [82,83] give two semi-dynamic techniques for the case in which updates are restricted to insertions only or deletions only, respectively; both techniques require that the y-coordinates of the segments be known in advance. <p> The proposed data structure is based on the skewer tree of Edelsbrunner, Haring and Hilbert [58] and uses dynamic fracional cascading <ref> [111] </ref>. It uses linear space, answers queries in O (log d1 n log log n) time, and supports insertion, deletion, splitting and merging of d-boxes in O (log 2 n log log n) amortized time.
Reference: [112] <author> K. Mehlhorn and M.H. Overmars, </author> <title> "Optimal Dynamization of Decomposable Searching Problems," </title> <booktitle> Information Processing Letters 12 (1981), </booktitle> <pages> 93-98. </pages>
Reference: [113] <author> S. Moen, </author> <title> "Drawing Dynamic Trees," </title> <booktitle> IEEE Software 7 (1990), </booktitle> <pages> 21-28. </pages>
Reference-contexts: On the other hand, if we want to guarantee optimal drawings with respect to some aesthetic criteria, e.g., planarity, symmetry, etc., the update/query operations may require high time complexity. Work on dynamic graph drawing is as follows. Moen <ref> [113] </ref> considers trees and presents a technique that restructures the drawing of a tree in time proportional to its height, and hence linear in the worst case. Cohen et al. [44] present several techniques for dynamic drawing of trees and planar graphs.
Reference: [114] <author> K. Mulmuley, </author> <title> "On Levels in Arrangements and Voronoi Diagrams," </title> <note> Discrete and Computational Geometry 6 (4) (1991). </note>
Reference-contexts: Note that the worst-case time for the incremental construction is fi (n 2 ). Mulmuley <ref> [114] </ref> gives an randomized incremental algorithm, which can be made on-line without changing the running time, for constructing Voronoi diagrams of order 1 to k in R d .
Reference: [115] <author> K. Mulmuley, </author> <title> "Randomized Multidimensional Search Trees: Further Results in Dynamic Sampling," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1991), </booktitle> <pages> 216-227. </pages>
Reference-contexts: Mulmuley <ref> [115] </ref> gives a randomized algorithm for the half space range queries, under the "com-minust" model, where a random sequence of insertions and deletions is defined as follows. <p> Mulmuley <ref> [115] </ref> presents a dynamic point location algorithm in three dimensional partitions induced by a set of possibly intersecting polygons in R 3 . This is a generalization of the randomized algorithm for the planar case given in [117]. <p> A randomized algorithm for dynamically maintaining a data structure to support point location queries in planar Voronoi diagrams, based on dynamic sampling, is also given in [117]. Mulmuley <ref> [115] </ref> shows how to build a dynamic data structure that can be used to answer k-nearest neighbour queries in R d for any d, with O (k log n) expected query time and O (m dd=2e+* ) expected time for executing a random (N; ffi)-sequence, for any * &gt; 0, where
Reference: [116] <author> K. Mulmuley, </author> <title> "Randomized Multidimensional Search Trees: Lazy Balancing and Dynamic Shu*ing," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1991), </booktitle> <pages> 180-196. </pages>
Reference-contexts: The probability and the expectation are solely with respect to randomization in the data structure. They also give a related algorithm that supports queries in optimal ~ O (log n) time, with expected O (n d ) space and amortized O (n d1 ) expected update time. Mulmuley <ref> [116] </ref> gives yet another algorithm for the same problem, based on dynamic shu*ing, with ~ O (polylog (n)) query time, O (n d ) space (deterministic), and O (n d1 ) expected update time, where the expectation is again solely with respect to randomization in the data structure. <p> Seidel [147] gives a randomized incremental semi-dynamic algorithm for constructing convex hulls, which takes expected O (n log n) time for d = 2; 3, and O (n bd=2c ) time for d &gt; 3, to execute a random sequence of insertions. Mulmuley <ref> [116] </ref> presents a fully dynamic randomized algorithm for maintaining convex hulls, which takes expected O (log n) time for d = 2; 3, and O (n bd=2c1 ) time for d &gt; 3, to execute an update of a random (N; ffi)-sequence (see Section 4.4). 8 Proximity In this section, we <p> For d = 2, Aurenhammer and Schwarzkopf [9] give an on-line algorithm for maintaining k-th order Voronoi diagrams with O (k 2 n log n + kn log 3 n) expected running time and optimal space O (k (n k)). Mulmuley <ref> [116] </ref> gives a dynamic algorithm for maintaining Voronoi diagrams of order 1 to k in R d .
Reference: [117] <author> K. Mulmuley, </author> <title> "Randomized Multidimensional Search Trees: Dynamic Sampling," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 121-131. 43 </pages>
Reference-contexts: Mulmuley [115] presents a dynamic point location algorithm in three dimensional partitions induced by a set of possibly intersecting polygons in R 3 . This is a generalization of the randomized algorithm for the planar case given in <ref> [117] </ref>. The algoritm is based on random sampling and achieves ~ O (log 2 n) query time, with the expected running time on a random (N; ffi)-sequence of updates (see Section 4.4) close to optimal. <p> A randomized algorithm for dynamically maintaining a data structure to support point location queries in planar Voronoi diagrams, based on dynamic sampling, is also given in <ref> [117] </ref>.
Reference: [118] <author> K. Mulmuley and S. Sen, </author> <title> "Dynamic Point Location in Arrangements of Hyperplanes," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991), </booktitle> <pages> 132-141. </pages> <note> Revised version: technical report, </note> <institution> Univ. of Chicago, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: It uses linear space, answers queries in O (log d1 n log log n) time, and supports insertion, deletion, splitting and merging of d-boxes in O (log 2 n log log n) amortized time. Several randomized algorithms are given by Mulmuley and Sen <ref> [118] </ref> and Mulmuley [115,116]. [118] presents two algorithms for dynamic point location in arrangements of d-dimensional hyper 22 planes, where the updates consist of insertions and deletions of hyperplanes. <p> It uses linear space, answers queries in O (log d1 n log log n) time, and supports insertion, deletion, splitting and merging of d-boxes in O (log 2 n log log n) amortized time. Several randomized algorithms are given by Mulmuley and Sen <ref> [118] </ref> and Mulmuley [115,116]. [118] presents two algorithms for dynamic point location in arrangements of d-dimensional hyper 22 planes, where the updates consist of insertions and deletions of hyperplanes.
Reference: [119] <author> J. Nievergelt and E.M. Reingold, </author> <title> "Binary Search Trees of Bounded Balance," </title> <journal> SIAM J. Computing 2 (1973), </journal> <pages> 33-43. </pages>
Reference-contexts: In the former, one balances the height of the subtrees of each node, while in the latter, one balances the number of nodes in the subtrees of each node. Examples of height balanced trees are AVL trees [1] and red-black trees [75]. Weight-balanced trees were first presented in <ref> [119] </ref> and 2 include BB [ff] trees [25]. All of these trees use O (n) space and support each operation of the above repertory in time O (log n). <p> Lueker and Willard [102] illustrate an ad hoc construction using the Nievergelt-Reingold <ref> [119] </ref> notion of bounded balance, which gives a data structure with O (log d n) query time and amortized update time, using space O (n log d1 n).
Reference: [120] <author> M.H. Overmars, </author> <title> "Dynamization of Order Decomposable Set Problems," </title> <editor> J. </editor> <booktitle> Algorithms 2 (1981), </booktitle> <pages> 245-260. </pages>
Reference-contexts: a sequence of k disjoint intervals sorted from left to right; * test if a query point is inside the union; * test if a query interval is contained in the union; * find all the ` intervals in the union intersected by a query interval; The technique of Overmars <ref> [120] </ref> uses O (n) space, supports updates in time O (log 2 n), and answers these queries in time O (k), O (log k), O (log k), and O (log k + `), respectively.
Reference: [121] <author> M.H. Overmars, </author> <title> "The Design of Dynamic Data Structures," </title> <booktitle> Lecture Notes in Computer Science 156 (1983). </booktitle>
Reference-contexts: A recent overview of major topics in computational geometry is given by F. Yao [175]. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner [56], Mehlhorn [109] and by Preparata and Shamos [133]. Iyengar et al. [84] survey dynamic data structures for multidimensional searching. Overmars' thesis <ref> [121] </ref> is an excellent reference for dynamic computational geometry results up to 1983. <p> Dietz and Raman [50] eliminate the amortization and show how to obtain O (log log n) worst-case update time. 3 General Dynamization Methods Several general techniques have been developed for constructing dynamic data structures from static ones. Overmars' thesis <ref> [121] </ref> describes in detail the results in this area until 1983. <p> Partial rebuilding is an alternative technique that proceeds by reconstructing entire subtrees when they become out of balance. It is typically applied to weight-balanced trees. Global rebuilding is a method that periodically reconstructs the entire data structure <ref> [121] </ref>. It is best used in conjunction with data structures that support "weak" forms of update, where an item is inserted or deleted quickly at the expense of slightly deteriorating the balance of the structure. <p> This decomposition process is represented by a binary tree. Detailed discussion on kd-trees can be found in [13,84,96,133]. Dynamic k-d trees are discussed in Overmars' thesis <ref> [121] </ref> (section 5.3.2). A local reorganization technique improving the performance of kd-trees is presented in [47]. <p> Schipper and Overmars [143] give a technique for the planar case, by supporting weak deletions on the conjugation tree and then applying the global rebuilding technique of Overmars <ref> [121] </ref>. <p> He proposes an efficient partition scheme for point sets, and applies the dynamization techniques for decomposable searching problems of [15] and <ref> [121] </ref> to get a data structure with O (n) space, O (n 11=d (log n) O (1) ) query time, O (log n) amortized deletion time and O (log 2 n) amortized insertion time. 5 Intersections 5.1 Segment Tree The segment tree data structure was introduced by Bentley [14]. <p> They dynamize this approach with the BB [ff] tree data structure [110], using the approach of Willard and Lueker [169] to spread local updates over future operations, and the method of Overmars <ref> [121] </ref> to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced. As emphasized by the authors, such methods are mainly of theoretical interest, because they involve rather complex manipulations of data structures. <p> This property allows one to apply the dynamization technique for order-decomposable problems. Hence, planar convex hulls can be dynamically maintained using O (n) space, O (log 2 n) update time, O (log n) time for a find-query, and O (k) for a report-query <ref> [121] </ref>. For three-dimensional convex hulls, the space requirement is O (n log log n), the update time is O (n), and the query time is O (log n) for a find-query, and O (k) for a report-query. <p> Hence, the logarithmic method presented in Section 3 can be applied to yield O (n) space and O (log 2 n) query and update times. Earlier results in this direction are presented in [20,72,99]. By [150], based on the method of Overmars' thesis <ref> [121] </ref>, the time for insertions and queries can be improved to O (log 2 n= log log n) as follows. Two Voronoi diagrams can be merged in linear time. Therefore, we can apply the logarithmic method with P (n) = O (n).
Reference: [122] <author> M.H. Overmars, </author> <title> "Range Searching in a Set of Line Segments," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1985), </booktitle> <pages> 177-185. </pages>
Reference-contexts: It is reported in Overmars <ref> [122] </ref>. The update operations supported are inserting and deleting edges with at least one endpoint vertex already in the subdivision. This method uses O (n log n) space and has O (log 2 n) query and update times. <p> This takes O (log n) time since each region has O (n) edges. Adding and removing edges correspond to performing O (1) concatenable-queue operations on the boundary trees, which take time O (log n). 20 6.2 Overview of Dynamic Point Location Techniques The dynamic point-location technique of Overmars <ref> [122] </ref> is described in the previous section. As presented in the original paper, it deals with subdivisions whose regions have a bounded number of edges, such as triangulations. However, this restriction can be removed by using the boundary trees as discussed above.
Reference: [123] <author> M.H. Overmars and J. van Leeuwen, </author> <title> "Two General Method for Dynamizing Decomposable Searching Problems," </title> <booktitle> Computing 26 (1981), </booktitle> <pages> 155-166. </pages>
Reference: [124] <author> M.H. Overmars and J. van Leeuwen, </author> <title> "Maintenance of Configurations in the Plane," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 23 (1981), </booktitle> <pages> 166-204. </pages>
Reference-contexts: To achieve the first extension, it introduces a new type of partitioning objects, called spanning tangents, and modifies the dynamic convex hull technique of Overmars and van Leeuwen <ref> [124] </ref> to compute and maintain the spanning tangents. To achieve the second extension, a BB [ff] tree is used to control the cost of rebuilding the secondary structures involved in updates. <p> A variation of the dynamic tree of Sleator and Tarjan [149] is used to maintain the normalization structure, where each solid path is represented by double threads. Moreover, a hull structure, which is a modification of the dynamic convex hull structure of Overmars and van Leeuwen <ref> [124] </ref>, is augmented to the normalization structure, so that the spanning tangents introduced in Chiang and Tamassia [42] can be computed efficiently. <p> data structures with linear size and O (log n) amortized deletion time for planar convex hulls are given by Chazelle [29] and by Hershberger and Suri [77]. 25 7.2 Fully Dynamic Maintenance of Planar Convex Hulls Now we describe the fully dynamic convex hull technique of Overmars and van Leeuwen <ref> [124] </ref>. <p> Given the convex hulls of S 1 and S 2 , the convex hull of S can be computed in O (log n) time in two dimensions <ref> [124] </ref> (the bridging of the previous section), and in O (n) time in three dimensions [132]. This property allows one to apply the dynamization technique for order-decomposable problems. <p> A tree-based data structure for planar convex hulls that implements these ideas is presented in <ref> [124] </ref>, as described in the previous section. Karp, Motwani, and Raghavan [87] consider the problem of answering a sequence of on-line queries on a static data set. Let t be the number of queries, which is not known in advance. <p> They make use of the dynamic convex hull technique of Overmars and van Leeuwen <ref> [124] </ref> (as discussed in Section 7.2), so that the answer can be computed in O (n log 3 n) time, using O (n) space. <p> This method uses a variation of the dynamic convex hull data structure of Overmars and van Leeuwen <ref> [124] </ref> (as discussed in Section 7.2) combined with the priority search tree [108], plus some additional pointers. 9.2 Union of Intervals Given a set of intervals on a line, which is dynamically updated by insertions and deletions, we consider the problems of answering the following queries: * report the union of <p> Preparata and Vitter [138] consider the problem of hidden-line elimination in terrains. Their main data structure implicitly maintains a lower convex hull. At any time, the current convex hull can be printed in time linear in its size. It is simpler than the structure of Overmars and van Leeuwen <ref> [124] </ref>, since it requires fewer balanced trees (one rather than a linear number) and still supports the same applications. This structure is used to perform hidden-line elimination in time O ((n + k) log 2 n) for terrains, where k is the number of edges of the display.
Reference: [125] <author> M.H. Overmars and J. van Leeuwen, </author> <title> "Dynamization of Decomposable Searching Problems Yielding Good Worst-case Bounds," </title> <booktitle> Lecture Notes in Computer Science 104 (1981), </booktitle> <pages> 224-233. </pages>
Reference: [126] <author> M.H. Overmars and J. van Leeuwen, </author> <title> "Worst-case Optimal Insertion and Deletion Methods for Decomposable Searching Problems," </title> <booktitle> Information Processing Letters 12 (1981), </booktitle> <pages> 168-173. </pages>
Reference: [127] <author> M.H. Overmars and J. van Leeuwen, </author> <title> "Some Principles for Dynamizing Decomposable Searching Problems," </title> <booktitle> Information Processing Letters 12 (1981), </booktitle> <pages> 49-54. </pages>
Reference: [128] <author> M.H. Overmars, M. Smid, M.T. de Berg, and M.J. van Kreveld, </author> <title> "Maintaining Range Trees in Secondary Memory, Part I: Partitions," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 423-452. </pages>
Reference-contexts: Icking, Klein and Ottman [81] have studied the problem of realizing priority search trees in external memory, where data are transferred in blocks of size B. They present two techniques derived from B-trees and a generalized version of red-black trees. Smid [151], Overmars, Smid, de Berg and van Kreveld <ref> [128] </ref> and Smid and Overmars [157] consider the problem of maintaining range trees in secondary memory.
Reference: [129] <author> F. P. Preparata, J. S. Vitter, and M. Yvinec, </author> <title> "Output-Sensitive Generation of the Perspective View of Isothetic Parallelepipeds," </title> <institution> Brown University, Department of Computer Science, </institution> <type> Technical Report 89-50, </type> <year> 1989. </year>
Reference-contexts: The algorithm is scene-sensitive and runs in time O (n log 2 n + k log n), where n is the number of the 3D-rectangles and k is the number of edges of the display. In <ref> [129] </ref>, the scene is formed from a perspective view. The primary data structure is a simple alternative to dynamic fractional cascading for use with augmented segment trees and range trees when the universe is fixed beforehand.
Reference: [130] <author> F.P. Preparata, </author> <title> "An Optimal Real Time Algorithm for Planar Convex Hulls," </title> <booktitle> Comm. ACM 22 (1979), </booktitle> <pages> 402-405. </pages>
Reference-contexts: an external query point; * find the intersection of the convex hull H of S with a given query line; * report the points on the convex hull H of S. 7.1 Semi-Dynamic Maintenance of Planar Convex Hulls In this section we present a variation of the technique of Preparata <ref> [130] </ref> for maintaining the convex hull H of a set of points S in the plane under a sequence of insertions. The space requirement is O (n).
Reference: [131] <author> F.P. Preparata, </author> <title> "A New Approach to Planar Point Location," </title> <journal> SIAM J. Computing 10 (1981), </journal> <pages> 473-483. </pages>
Reference-contexts: All bounds are worst-case [135]. As shown in [134,137], the data structure can also be extended to support expansion and contraction operations in time O (log 2 n), with applications to three-dimensional point location. The data structure for convex subdivisions [136] is based on the trapezoid method <ref> [131] </ref>. It further assumes that the vertices lie on a fixed set of N horizontal lines and achieves space O (N + n log N ), query time O (log n + log N ), and update time O (log n log N ) [136]. <p> Chiang and Tamassia [42] present a fully dynamic data structure for point location in a monotone subdivision, based on the trapezoid method <ref> [131] </ref>. The operations supported are insertion and deletion of vertices and edges, and horizontal translation of vertices. <p> Point location queries are 23 supported by a separate location structure, which is a dynamic version of the trapezoid tree <ref> [131] </ref>: it is not explicitly balanced but instead represented by a dynamic tree [149].
Reference: [132] <author> F.P. Preparata and S.J. Hong, </author> <title> "Convex Hulls of Finite Sets of Points in Two and Three Dimensions," </title> <booktitle> Comm. ACM 2(20) (1977), </booktitle> <pages> 87-93. </pages>
Reference-contexts: Given the convex hulls of S 1 and S 2 , the convex hull of S can be computed in O (log n) time in two dimensions [124] (the bridging of the previous section), and in O (n) time in three dimensions <ref> [132] </ref>. This property allows one to apply the dynamization technique for order-decomposable problems. Hence, planar convex hulls can be dynamically maintained using O (n) space, O (log 2 n) update time, O (log n) time for a find-query, and O (k) for a report-query [121].
Reference: [133] <author> F.P. Preparata and M.I. Shamos, </author> <title> Computational Geometry, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Previous tutorial and survey work in the area is as follows. A recent overview of major topics in computational geometry is given by F. Yao [175]. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner [56], Mehlhorn [109] and by Preparata and Shamos <ref> [133] </ref>. Iyengar et al. [84] survey dynamic data structures for multidimensional searching. Overmars' thesis [121] is an excellent reference for dynamic computational geometry results up to 1983. <p> The Voronoi diagram of S uses O (n) space and can be constructed in O (n log n) time. If we represent the Voronoi diagram with a point-location data structure, closest point queries take O (log n) time (see <ref> [133] </ref>). Also, given the Voronoi diagram of S, the all-nearest-neighbors problem can be solved in O (n) time [148].
Reference: [134] <author> F.P. Preparata and R. Tamassia, </author> <title> "Efficient Spatial Point Location," </title> <booktitle> Algorithms and Data Structures (Proc. WADS '89) (1989), </booktitle> <pages> 3-11. 44 </pages>
Reference: [135] <author> F.P. Preparata and R. Tamassia, </author> <title> "Fully Dynamic Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing 18 (1989), </journal> <pages> 811-830. </pages>
Reference-contexts: If only insertions are performed, the update time is reduced to O (log 2 n) [109 (pp. 135-143)]. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively [135,136]. The data structure for monotone subdivisions <ref> [135] </ref> is based on the chain-method [95]. The repertory of update operations includes inserting vertices on edges, inserting monotone chains of edges, and their inverses. The space requirement is O (n). The query time is O (log 2 n). <p> Vertices can be inserted or deleted in time O (log n), and a monotone chain with k edges can be inserted or deleted in time O (log 2 n + k) (thus inserting or deleting a single edge takes O (log 2 n) time). All bounds are worst-case <ref> [135] </ref>. As shown in [134,137], the data structure can also be extended to support expansion and contraction operations in time O (log 2 n), with applications to three-dimensional point location. The data structure for convex subdivisions [136] is based on the trapezoid method [131].
Reference: [136] <author> F.P. Preparata and R. Tamassia, </author> <title> "Dynamic Planar Point Location with Optimal Query Time," </title> <booktitle> Theoretical Computer Science 74 (1990), </booktitle> <pages> 95-114. </pages>
Reference-contexts: All bounds are worst-case [135]. As shown in [134,137], the data structure can also be extended to support expansion and contraction operations in time O (log 2 n), with applications to three-dimensional point location. The data structure for convex subdivisions <ref> [136] </ref> is based on the trapezoid method [131]. <p> It further assumes that the vertices lie on a fixed set of N horizontal lines and achieves space O (N + n log N ), query time O (log n + log N ), and update time O (log n log N ) <ref> [136] </ref>. Tamassia presents a technique for point location in triangulations that allows a tradeoff between query and update time, and can be used in conjunction with any of the known static point location data structures [159]. It is based on the dynamization methods for decomposable search problems [20,121]. <p> The operations supported are insertion and deletion of vertices and edges, and horizontal translation of vertices. It extends the previous dynamic trapezoid method of Preparata and Tamassia <ref> [136] </ref> in two aspects: it supports monotone subdivisions instead of convex subdivisions, and removes the restriction that the vertices lie on a fixed set of horizontal lines.
Reference: [137] <author> F.P. Preparata and R. Tamassia, </author> <title> "Efficient Point Location in a Convex Spatial Cell Complex," </title> <journal> SIAM J. Computing 21 (1992), </journal> <pages> 267-280. </pages>
Reference: [138] <author> F.P. Preparata and J. S. Vitter, </author> <title> "A Simplified Technique for Hidden-Line Elimination in Terrains," </title> <booktitle> Proc. 1992 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science (1992). </booktitle>
Reference-contexts: The algorithm is scene-sensitive and runs in time O ((n + k) log n log log n), where n is the number of the 3D-rectangles and k is the number of edges of the display. Preparata and Vitter <ref> [138] </ref> consider the problem of hidden-line elimination in terrains. Their main data structure implicitly maintains a lower convex hull. At any time, the current convex hull can be printed in time linear in its size.
Reference: [139] <author> F.P. Preparata, J.S. Vitter, and M. Yvinec, </author> <title> "Computation of the Axial View of a Set of Isothetic Parallelepipeds," </title> <journal> ACM Transactions on Graphics 3 (1990), </journal> <pages> 278-300. </pages>
Reference-contexts: Also, the visible rectangle in the display containing a given query point can be found in time O (log n log log n). Preparata, Vitter and Yvinec [129,139] give two hidden-line elimination techniques for displaying a scene of three-dimensional isothetic parallelepipeds (3D-rectangles). The method of <ref> [139] </ref> considers the case where the scene is viewed from infinity along one of the coordinate axes (axial view).
Reference: [140] <author> N.S.V. Rao, V.K. Vaishnavi, and S.S. Iyengar, </author> <booktitle> "On the Dynamization of Data Structures," BIT 28 (1988), </booktitle> <pages> 37-53. </pages>
Reference-contexts: Several variations of dynamization methods for decomposable problems are reported in [53,71,112,120,121, 125,126,140,152,169]. The dynamization technique of Rao Vaishnavi Iyengar <ref> [140] </ref> considers either semi-dynamic decomposable search problems where only insertions are performed, or deletion-decomposable search problems, where the answer of a query on a set S 0 can be computed in time proportional to computing the answers to queries on S 0 [ S 00 and S 00 .
Reference: [141] <author> J.S. Salowe, </author> <title> "Shallow Interdistance Selection and Interdistance Enumeration," </title> <booktitle> Lecture Notes in Computer Science 519 (1991), </booktitle> <pages> 117-128. </pages>
Reference: [142] <author> N. Sarnak and R.E. Tarjan, </author> <title> "Planar Point Location Using Persistent Search Trees," </title> <booktitle> Communications ACM 29 (1986), </booktitle> <pages> 669-679. </pages>
Reference: [143] <author> H. Schipper and M.H. Overmars, </author> <title> "Dynamic Partition Trees," </title> <booktitle> Proc. SWAT'90, Lecture Notes in Computer Science 447 (1990), </booktitle> <pages> 404-417. </pages>
Reference-contexts: The half space range query problem is the following: Given a set of points in R d , and given a query half space, report all the points that lie in the query half space. Schipper and Overmars <ref> [143] </ref> give a technique for the planar case, by supporting weak deletions on the conjugation tree and then applying the global rebuilding technique of Overmars [121]. <p> Segment intersection queries ask one to report the segments of S intersected by an arbitrary query segment. Ray-shooting queries ask one to determine the first segment hit by an arbitrarily-directed ray r emanating from a query point q. Schipper and Overmars <ref> [143] </ref> give a technique for segment intersection queries that works for the case where the segments in S do not intersect each other.
Reference: [144] <author> H.W. Scholten and M.H. Overmars, </author> <title> "General Methods for Adding Range Restrictions to Decomposable Searching Problems," </title> <editor> J. </editor> <booktitle> Symbolic Computation 7 (1989), </booktitle> <pages> 1-10. </pages>
Reference-contexts: Scholten and Overmars <ref> [144] </ref> considers general methods for adding range restrictions to decomposable searching problems. They describe two classes of data structures for this problem, and dynamize them by using a new type of weight-balanced multiway trees as underlying structures. They thus obtain efficient dynamic data structures for orthogonal range searching, with trade-offs.
Reference: [145] <author> C. Schwarz and M. Smid, </author> <title> "An O(n log n log log n) Algorithm for the On-line Closest Pair Problem," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1992), </booktitle> <pages> 280-285. </pages>
Reference-contexts: They show that in the plane, such updates can be performed in O (log 2 n) amortized time. Using [152], this update time can be made worst-case. Smid [155], Schwarz and Smid <ref> [145] </ref>, and Schwarz, Smid and Snoeyink [146] give several techniques for maintaining the closest pair of a point set under insertions only or under a semi-on-line sequence of updates. In [155], an algorithm is given that uses linear space and supports insertions only, in O (log d1 n) amortized time. <p> If only insertions take place, the update time can be improved to O (log 2 n= log log n). The data structure of <ref> [145] </ref> has linear size and supports insertion-only updates in O (log n log log n) amortized time for arbitrary fixed dimension; it is also shown that the technique can be extended to support semi-on-line updates in O (log 2 n) worst-case time. [146] gives an algorithm for any fixed dimension that
Reference: [146] <author> C. Schwarz, M. Smid, and J. Snoeyink, </author> <title> "An Optimal Algorithm for the On-line Closest-Pair Problem," </title> <note> Proc. ACM Symp. on Computational Geometry (1992), to appear. </note>
Reference-contexts: They show that in the plane, such updates can be performed in O (log 2 n) amortized time. Using [152], this update time can be made worst-case. Smid [155], Schwarz and Smid [145], and Schwarz, Smid and Snoeyink <ref> [146] </ref> give several techniques for maintaining the closest pair of a point set under insertions only or under a semi-on-line sequence of updates. In [155], an algorithm is given that uses linear space and supports insertions only, in O (log d1 n) amortized time. <p> The data structure of [145] has linear size and supports insertion-only updates in O (log n log log n) amortized time for arbitrary fixed dimension; it is also shown that the technique can be extended to support semi-on-line updates in O (log 2 n) worst-case time. <ref> [146] </ref> gives an algorithm for any fixed dimension that uses only algebraic functions and thus is optimal. The data structure uses linear space and maintains the closest pair in O (log n) amortaized time per insertion.
Reference: [147] <author> R. Seidel, </author> <title> "Linear Programming and Convex Hulls Made Easy," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1990), </booktitle> <pages> 211-215. </pages>
Reference-contexts: The technique of van Kreveld and Overmars [93] to make data structures concatenable provides a data structure for reporting the convex hull within a query rectangle in time O ( p insertions and deletions take O (log 2 n) time and the space complexity is O (n). Seidel <ref> [147] </ref> gives a randomized incremental semi-dynamic algorithm for constructing convex hulls, which takes expected O (n log n) time for d = 2; 3, and O (n bd=2c ) time for d &gt; 3, to execute a random sequence of insertions.
Reference: [148] <institution> M.I. Shamos, "Computational Geometry," Doctoral Disertation, Yale Univ. </institution> <year> (1978). </year>
Reference-contexts: If we represent the Voronoi diagram with a point-location data structure, closest point queries take O (log n) time (see [133]). Also, given the Voronoi diagram of S, the all-nearest-neighbors problem can be solved in O (n) time <ref> [148] </ref>. Aggarwal et al. [5] show that in a planar Voronoi diagram, points can be inserted and deleted in O (n) time; this also leads to an update time of O (n) for maintaining the minimal distance of a point set, using O (n) space.
Reference: [149] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: Queries are performed by using a centroid decomposition of the dual tree to drive searches in the primal tree. The link-cut tree data structure of Sleator and Tarjan <ref> [149] </ref> is used to dynamize the method, which is relatively easy to implement. This approach also allows one to implement the dual operations of expand and contract, with applications to three-dimensional point location. A variation of this method supports updates in a semi-dynamic environment in which only insertions are performed. <p> A variation of the dynamic tree of Sleator and Tarjan <ref> [149] </ref> is used to maintain the normalization structure, where each solid path is represented by double threads. <p> Point location queries are 23 supported by a separate location structure, which is a dynamic version of the trapezoid tree [131]: it is not explicitly balanced but instead represented by a dynamic tree <ref> [149] </ref>. The method achieves optimal query time O (log n), with space O (n log n) and update time O (log 3 n), where the time bounds are amortized for the vertex update and worst-case for the other update operations.
Reference: [150] <author> M. Smid, </author> <title> private communication. </title>
Reference-contexts: Closest point searching with updates restricted to insertions only is a decomposable searching problem. Hence, the logarithmic method presented in Section 3 can be applied to yield O (n) space and O (log 2 n) query and update times. Earlier results in this direction are presented in [20,72,99]. By <ref> [150] </ref>, based on the method of Overmars' thesis [121], the time for insertions and queries can be improved to O (log 2 n= log log n) as follows. Two Voronoi diagrams can be merged in linear time. Therefore, we can apply the logarithmic method with P (n) = O (n).
Reference: [151] <author> M. Smid, </author> <title> "Dynamic Data Structures on Multiple Storage Media," </title> <institution> University of Amsterdam, </institution> <type> Ph.D. Thesis, </type> <year> 1989. </year> <month> 45 </month>
Reference-contexts: Icking, Klein and Ottman [81] have studied the problem of realizing priority search trees in external memory, where data are transferred in blocks of size B. They present two techniques derived from B-trees and a generalized version of red-black trees. Smid <ref> [151] </ref>, Overmars, Smid, de Berg and van Kreveld [128] and Smid and Overmars [157] consider the problem of maintaining range trees in secondary memory. <p> It is shown that t convex hull membership queries can be performed in optimal time O ((n + t) log min (n; t)), using as a subroutine the Kirkpatrick-Seidel top-down convex hull algorithm [90]. Several dynamic deferred data structuring methods for some membership problems are given by Smid <ref> [151] </ref> and Ching, Mehlhorn and Smid [43]. An off-line dynamic convex hull problem is studied by Hershberger and Suri [78].
Reference: [152] <author> M. Smid, </author> <title> "A Worst-case Algorithm for Semi-online Updates on Decomposable Problems," </title> <institution> Fachbereich Informatik, Universitat des Saarlandes, </institution> <note> Report A 03/90, </note> <year> 1990. </year> <title> See also: "Algorithms for Semi-online Updates on Decomposable Problems", </title> <booktitle> Proc. Canadian Conf. on Computational Geometry (1990), </booktitle> <pages> 347-350. </pages>
Reference-contexts: Thus, at the cost of log n factor, the data structure allows semi-on-line update capability. As an immediate application, the diameter, or the closest pair, of a planar point set can be maintained in time O (log 2 n) per semi-on-line update. Smid <ref> [152] </ref> gives an alternative description of the algorithm, and shows how the amortized update time can be made worst-case. Moreover, it is shown that the method is a generalization of the logarithmic method: if the semi-on-line sequence consists of only insertions, we get the logarithmic method. <p> Maintaining the minimum and maximum distance between points under a semi-on-line sequence of updates can be handled using the general technique of Dobkin and Suri [51] (see Section 3). They show that in the plane, such updates can be performed in O (log 2 n) amortized time. Using <ref> [152] </ref>, this update time can be made worst-case. Smid [155], Schwarz and Smid [145], and Schwarz, Smid and Snoeyink [146] give several techniques for maintaining the closest pair of a point set under insertions only or under a semi-on-line sequence of updates.
Reference: [153] <author> M. Smid, </author> <title> "Maintaining the Minimal Distance of a Point Set in Less Than Linear Time," </title> <booktitle> Algorithms Review 2 (1) (1991), </booktitle> <pages> 33-44. </pages>
Reference-contexts: Smid [153,156] gives two fully dynamic techniques for maintaining the minimal L r distance of a point set in d-dimensional space. The data structure of <ref> [153] </ref> uses O (n) space and supports updates in O (n 2=3 log n) time, by giving a method to compute the O (n 2=3 ) smallest distances defined by a set of n points in O (n log n) time.
Reference: [154] <author> M. Smid, </author> <title> "Range Trees with Slack Parameter," </title> <booktitle> Algorithms Review 2 (2) (1991), </booktitle> <pages> 77-87. </pages>
Reference-contexts: Mehlhorn [109] intorduces a variation of the above data structure, the range tree with slack parameter m: instead of augmenting each node with a secondary structure, only the nodes with depth divisible by m have secondary structures. Smid <ref> [154] </ref> gives a complete analysis of the data structure, and shows that the space used is O (n (log n=f (n)) d1 ), the query time is O ((2 f (2n) =f (n)) d1 log d n+ k) and the update time is O (log d n=f (n) d1 +log d1
Reference: [155] <author> M. Smid, </author> <title> "Dynamic Rectangular Point Location, with an Application to the Closest Pair Problem," </title> <institution> Max-Planck-Institut fur Informatik, Saarbrucken, </institution> <note> Report MPI-I-91-101, 1991. See also: Proc. 2nd International Symp. on Algorithms, 1991.. </note>
Reference-contexts: It achieves optimal query time O (log n), update time O (log 2 n) and space O (n log n), where the time bounds are amortized for insertion and deletion of vertices, and worst-case for the others. Smid <ref> [155] </ref> considers the d-dimensional rectangular point location problem, where a set of n nonoverlapping d-dimensional axes-parallel hyperrectangles, or d-boxes, are stored in a data structure to support point location queries. <p> They show that in the plane, such updates can be performed in O (log 2 n) amortized time. Using [152], this update time can be made worst-case. Smid <ref> [155] </ref>, Schwarz and Smid [145], and Schwarz, Smid and Snoeyink [146] give several techniques for maintaining the closest pair of a point set under insertions only or under a semi-on-line sequence of updates. In [155], an algorithm is given that uses linear space and supports insertions only, in O (log d1 <p> Using [152], this update time can be made worst-case. Smid <ref> [155] </ref>, Schwarz and Smid [145], and Schwarz, Smid and Snoeyink [146] give several techniques for maintaining the closest pair of a point set under insertions only or under a semi-on-line sequence of updates. In [155], an algorithm is given that uses linear space and supports insertions only, in O (log d1 n) amortized time. It only uses algebraic functions and thus is optimal for the planar case. Another method of [155] is a variation of Dobkin and Suri [51], and gives a linear size data <p> In <ref> [155] </ref>, an algorithm is given that uses linear space and supports insertions only, in O (log d1 n) amortized time. It only uses algebraic functions and thus is optimal for the planar case. Another method of [155] is a variation of Dobkin and Suri [51], and gives a linear size data structure that supports each semi-on-line update in O (log 2 n) time for arbitrary fixed dimension. If only insertions take place, the update time can be improved to O (log 2 n= log log n).
Reference: [156] <author> M. Smid, </author> <title> "Maintaining the Minimal Distance of a Point Set in Polylogarithmic Time (revised version)," </title> <institution> Max-Planck-Institut fur Informatik, Saarbrucken, </institution> <note> Report MPI-I-91-103, 1991. See also: Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), 1-6. </note>
Reference-contexts: By [49,141], which show how to compute the n smallest distances in O (n log n) time, the update time is improved to O (n 1=2 log n), for arbitrary dimension. In <ref> [156] </ref>, the update time is reduced to O (log d n log log n) amortized, while the space is slightly increased to (n log d n). We briefly describe the main idea of [156] for two dimensions. <p> In <ref> [156] </ref>, the update time is reduced to O (log d n log log n) amortized, while the space is slightly increased to (n log d n). We briefly describe the main idea of [156] for two dimensions. Let d (A; B) be the minimal 30 distance between a point in set A and a point in set B. Hence d (S; S) denotes the minimal distance between distinct points in S.
Reference: [157] <author> M. Smid and M.H. Overmars, </author> <title> "Maintaining Range Trees in Secondary Memory, Part II: Lower Bounds," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 453-480. </pages>
Reference-contexts: They present two techniques derived from B-trees and a generalized version of red-black trees. Smid [151], Overmars, Smid, de Berg and van Kreveld [128] and Smid and Overmars <ref> [157] </ref> consider the problem of maintaining range trees in secondary memory.
Reference: [158] <author> K. Supowit, </author> <title> "New Techniques for some Dynamic Closest-Point and Farthest-Point Problems," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 84-90. </pages>
Reference-contexts: If we replace the logarithmic method by a method that writes the size of S in the number system with base log n, then both the query time and the insertion time are O (log 2 n= log log n). Supowit <ref> [158] </ref> shows how to dynamize heuristic algorithms for closest-point and farthest-point problems in the presence of deletions. Maintaining the minimum and maximum distance between points under a semi-on-line sequence of updates can be handled using the general technique of Dobkin and Suri [51] (see Section 3).
Reference: [159] <author> R. Tamassia, </author> <title> "An Incremental Reconstruction Method for Dynamic Planar Point Location," </title> <booktitle> Information Processing Letters 37 (1991), </booktitle> <pages> 79-83. </pages>
Reference-contexts: Tamassia presents a technique for point location in triangulations that allows a tradeoff between query and update time, and can be used in conjunction with any of the known static point location data structures <ref> [159] </ref>. It is based on the dynamization methods for decomposable search problems [20,121]. The update operations are inserting a "star" (vertex and three edges) inside a region (which partitions it into three new regions), and swapping the diagonal of a convex quadrilateral formed by adjacent regions.
Reference: [160] <author> R.E. Tarjan, </author> <title> "Data Structures and Network Algorithms," </title> <booktitle> CBMS-NSF Regional Conference Series in Applied Mathematics 44 (1983). </booktitle>
Reference: [161] <author> R.E. Tarjan, </author> <title> "Updating a Balanced Search Tree in O(1) Rotations," </title> <note> Information Processing Letters 16 (1983). </note>
Reference: [162] <author> R.E. Tarjan, </author> <title> "Amortized Computational Complexity," </title> <booktitle> SIAM J. Algebraic Discrete Methods 6 (1985), </booktitle> <pages> 306-318. </pages>
Reference-contexts: The concept of amortized time complexity <ref> [162] </ref> will be used in the analysis of data structure for which the worst-case time complexity of an operation is larger than the average time complexity over a sequence of operations. <p> That is, if a sequence of m operations takes total time t, then we say that the amortized time complexity of an operation is t=m. A detailed discussion on amortized complexity and techniques for analyzing it can be found in <ref> [162] </ref>. 2.2 Balanced Trees Consider a set P of n points in one-dimensional space (i.e., a set of real numbers).
Reference: [163] <author> V.K. Vaishnavi, </author> <title> "Computing Point Enclosures," </title> <journal> IEEE Transactions on Computers C-31 (1) (1982), </journal> <pages> 22-29. </pages>
Reference: [164] <author> V.K. Vaishnavi, </author> <title> "Multidimensional Balanced Binary Trees," </title> <booktitle> IEEE Transactions on Computers 38 (7) (1989), </booktitle> <pages> 968-985. </pages>
Reference-contexts: Moreover, it is shown that the method is a generalization of the logarithmic method: if the semi-on-line sequence consists of only insertions, we get the logarithmic method. Vaishnavi [164,165,166] proposes several multidimensional tree structures. A multidimensional generalization of balanced binary trees, called d-dimensional balanced binary tree, is given in <ref> [164] </ref>. It stores a set of n d-dimensional points in O (d n) space and supports access, insertion and deletion operations in O (log n + d) time, where only O (d) rotations are needed to rebalance the tree after an insertion or deletion. <p> planar st-graphs and general planar graphs use O (n) space, and support updates in O (log n) time and drawing queries in O (k log n) time. 9.8 Lower Bounds General lower bound techniques for dynamic algorithms are discussed in [23,64]; some relevant lower bounds are also given in [32,62,63,173]. <ref> [164] </ref> gives an upper bound that precisely matches the lower bounds of [63] and [173]; the difference between these two is that they obtain the same quantitative lower bounds under different models of computation. [88] gives an upper bound that nearly matches the lower bound of [62].
Reference: [165] <author> V.K. Vaishnavi, </author> <title> "On k-dimensional Balanced Binary Trees," </title> <institution> Dept. of Computer Information Systems, Georgia State Univ., </institution> <type> Technical Report CIS-90-001, </type> <year> 1990. </year>
Reference-contexts: An amortized analysis of the insertions and deletions of this data structure is given in <ref> [165] </ref>, which shows that a mixed sequence of m insertions and deletions in the structure storing n d-dimensional points takes O (d (n + m)) total rebalancing time. Based on the two-dimensional version of the data structure, [165] also gives another data structure called 6 self-organizing balanced binary tree, which is <p> analysis of the insertions and deletions of this data structure is given in <ref> [165] </ref>, which shows that a mixed sequence of m insertions and deletions in the structure storing n d-dimensional points takes O (d (n + m)) total rebalancing time. Based on the two-dimensional version of the data structure, [165] also gives another data structure called 6 self-organizing balanced binary tree, which is nearly-optimal, meaning that the access probabilities of the items are not known a priori, and the tree is updated after each access so that the access time of the i-th item with searching frequency w i is
Reference: [166] <author> V.K. Vaishnavi, </author> <title> "Multidimensional (a, b)-Trees: An Efficient Dynamic Multidimensional File Structure," </title> <institution> Dept. of Computer Information Systems, Georgia State Univ., </institution> <type> Technical Report CIS-90-003, </type> <year> 1990. </year>
Reference-contexts: A dynamic multidimensional file structure, called multidimensional (a, b)-tree, which is a multidimensional generalization of (a, b)-trees of [110] is presented in <ref> [166] </ref>. It is shown that a weak d-dimensional (a, b)-tree (with b 2a) of size n requires O (d (m + n)) time for a mixed sequence of m insertions and deletions.
Reference: [167] <author> V.K. Vaishnavi and D. Wood, </author> <title> "Rectilinear Line Segment Intersection, Layered Segment Trees, </title> <editor> and Dynamization," J. </editor> <booktitle> Algorithms 3 (1982), </booktitle> <pages> 160-176. 46 </pages>
Reference-contexts: This data structure uses O (n log n) space and supports queries in time O (log 2 n + k). The update time is O (log 2 n). Static fractional cascading can be used to improve the query time to O (log n + k) <ref> [167] </ref>. Lipski [100,101] shows how to achieve O (log n log log n+k) query time, O (log n log log n) update time and O (n log n) space by applying the techniques of van Emde Boas [26,27] to the secondary structures of the segment tree.
Reference: [168] <author> D. Willard, </author> <title> "New Data Structures for Orthogonal Range Queries," </title> <journal> SIAM J. Computing (1985), </journal> <pages> 232-253. </pages>
Reference: [169] <author> D. Willard and G. Lueker, </author> <title> "Adding Range Restriction Capability to Dynamic Data Structures," </title> <editor> J. </editor> <booktitle> ACM 32 (1985), </booktitle> <pages> 597-617. </pages>
Reference-contexts: Lueker and Willard [102] illustrate an ad hoc construction using the Nievergelt-Reingold [119] notion of bounded balance, which gives a data structure with O (log d n) query time and amortized update time, using space O (n log d1 n). Willard and Lueker <ref> [169] </ref> give a general transformation method that adds range searching capability to any dynamic data structure for a decomposable searching problem with a factor of O (log n) increase in time and space usage; their method improves the update time of [102] from amortized to worst-case, while all the other bounds <p> They dynamize this approach with the BB [ff] tree data structure [110], using the approach of Willard and Lueker <ref> [169] </ref> to spread local updates over future operations, and the method of Overmars [121] to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced. <p> The m-contour of S is the "staircase" chain delimiting the points of the plane that are dominated by at least one maximal point of S. One can test if a point is maximal by performing a range query, using, e.g., the data structure of Willard and Lueker <ref> [169] </ref> or the priority search tree [108]. Frederickson and Rodger [61] consider the problem of maintaining the m-contour of S. Their data structure consists of a balanced tree that stores the points sorted by x-coordinate, plus several additional pointers.
Reference: [170] <author> D.E. Willard, </author> <title> "The Super-B-Tree Algorithm," </title> <type> Tech. Report TR-03-79, </type> <institution> Aiken Computer Lab., Harvard University (1979). </institution>
Reference: [171] <author> D.E. Willard, </author> <title> "On the Application of Sheared Retrieval to Orthogonal Range Queries," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1986), </booktitle> <pages> 80-89. </pages>
Reference-contexts: This decomposition process is represented by a binary tree. Detailed discussion on kd-trees can be found in [13,84,96,133]. Dynamic k-d trees are discussed in Overmars' thesis [121] (section 5.3.2). A local reorganization technique improving the performance of kd-trees is presented in [47]. Bentlely and Mauer [19] and Willard <ref> [171] </ref> describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19]. <p> Bentlely and Mauer [19] and Willard <ref> [171] </ref> describe linear space data structures of pragmatic interest. [19] gives the historically first data structure to obtain O (n * ) query time for range searching in O (n) space, and the shearing method of [171] is an interesting alternative to [19].
Reference: [172] <author> D.E. Willard, </author> <title> "Multidimensional Search Trees That Provide New Types of Memeory Reductions," </title> <editor> J. </editor> <booktitle> ACM 34 (4) (1987), </booktitle> <pages> 846-858. </pages>
Reference-contexts: The query and update time can be further improved by using fractional cascading, as described in Section 4.2. Willard <ref> [172] </ref> studies the following variation of range search: let P be a set of n points in d-dimensional space, each with a value from a semigroup. An aggregate query consists of computing the semigroup sum of the values of the points in the query range. The technique of [172] modifies the <p> Willard <ref> [172] </ref> studies the following variation of range search: let P be a set of n points in d-dimensional space, each with a value from a semigroup. An aggregate query consists of computing the semigroup sum of the values of the points in the query range. The technique of [172] modifies the first-generation k-fold tree of Bentley and Shamos [21] and achieves O (log d n) query and update time, with space O (n (log n= log log n) d1 ). The idea of k-dimensional binary trees, or kd-trees, was first presented in [13].
Reference: [173] <author> D.E. Willard, </author> <title> "Lower Bounds for the Addition-Subtraction Operations in Orthogonal Range Queries," </title> <booktitle> Information and Computation 82 (1989), </booktitle> <pages> 45-64. </pages>
Reference-contexts: O (log n) time and drawing queries in O (k log n) time. 9.8 Lower Bounds General lower bound techniques for dynamic algorithms are discussed in [23,64]; some relevant lower bounds are also given in [32,62,63,173]. [164] gives an upper bound that precisely matches the lower bounds of [63] and <ref> [173] </ref>; the difference between these two is that they obtain the same quantitative lower bounds under different models of computation. [88] gives an upper bound that nearly matches the lower bound of [62]. Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds.
Reference: [174] <author> D.E. Willard, </author> <title> "Applications of the Fusion Tree Method to Computational Geometry and Searching," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1992), </booktitle> <pages> 286-295. </pages>
Reference-contexts: Fredman and Willard [65,174] explain how fusion trees refute many conjectures about lower bounds. For instance, <ref> [174] </ref> shows that one can speed up the priority trees of [108] by a factor of log log n. 10 Open Problems Despite the increasing interest in the area of incremental computation, efficient dynamic algorithms are not known for many geometric problems.
Reference: [175] <author> F.F. Yao, </author> <title> "Computational Geometry," </title> <booktitle> in Handbook of Theoretical Computer Science, Volume A, Algorithms and Complexity, </booktitle> <publisher> Elsevier/MIT Press, </publisher> <year> 1990, </year> <pages> 343-390. 47 </pages>
Reference-contexts: Problems that do not fall in these categories are discussed in Section 9. Section 10 concludes the paper with open problems. Previous tutorial and survey work in the area is as follows. A recent overview of major topics in computational geometry is given by F. Yao <ref> [175] </ref>. Fundamental dynamic geometric techniques are described in the books by Edelsbrunner [56], Mehlhorn [109] and by Preparata and Shamos [133]. Iyengar et al. [84] survey dynamic data structures for multidimensional searching. Overmars' thesis [121] is an excellent reference for dynamic computational geometry results up to 1983.
References-found: 175

