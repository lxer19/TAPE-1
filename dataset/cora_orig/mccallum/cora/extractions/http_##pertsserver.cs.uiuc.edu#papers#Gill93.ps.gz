URL: http://pertsserver.cs.uiuc.edu/papers/Gill93.ps.gz
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: ALGORITHMS TO SCHEDULE TASKS WITH AND/OR PRECEDENCE CONSTRAINTS  
Author: BY DONALD WILLIAM GILLIES 
Degree: THESIS Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science in the Graduate College of the  
Date: 1990  
Address: 1984 M.S., University of Illinois,  1993 Urbana, Illinois  
Affiliation: B.S., Massachusetts Institute of Technology,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [Aho74] <author> Aho, A.V., Hopcroft, J. E. and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms . Addison-Wesley, </title> <address> Reading Massachusetts, </address> <year> 1974. </year>
Reference-contexts: Warren's algorithm scans by rows and uses boolean OR operations on the rows. Whereas Warshall's algorithm has one main scan, Warren's algorithm has two. If each row of the matrix requires a separate page, then Warren's algorithm reduces the number of page faults from O (n 2 In <ref> [Aho74] </ref> the algorithm of Warshall is unified to solve a large class of path problems over a closed semiring. In [Lehmann77] Warshall's algorithm is generalized over closed semi-rings, with slightly weaker assumptions and simpler proofs than [Aho74]. Many interesting operations-research applications are contained therein. <p> then Warren's algorithm reduces the number of page faults from O (n 2 In <ref> [Aho74] </ref> the algorithm of Warshall is unified to solve a large class of path problems over a closed semiring. In [Lehmann77] Warshall's algorithm is generalized over closed semi-rings, with slightly weaker assumptions and simpler proofs than [Aho74]. Many interesting operations-research applications are contained therein. Tarjan [Tarjan81] presents a different 95 approach where Warshall's algorithm is generalized to solve path problems over an algebra of regular expressions. This work contains many interesting applications in the area of dataflow analysis of computer programs.
Reference: [Balas80a] <author> Balas, Egon. </author> <title> Cutting Planes from Conditional Bounds: A New Approach to Set Covering. </title> <booktitle> Mathematical Programming (1980) vol. </booktitle> <volume> 12, </volume> <pages> pp. 19-36. </pages>
Reference-contexts: A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed <ref> [Balas80a] </ref> [Balas80b], and one heuristic with bounded worst-case performance has been developed [Chvatal79] [Lovasz75] [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [Balas80b] <author> Balas, Egon and A. Ho. </author> <title> Set Covering Algorithms Using Cutting Planes, Heuristics and Subgradient Optimization: A Computational Study. </title> <booktitle> Mathematical Programming (1980) Vol 12, </booktitle> <pages> pp. 37-60. </pages>
Reference-contexts: A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] <ref> [Balas80b] </ref>, and one heuristic with bounded worst-case performance has been developed [Chvatal79] [Lovasz75] [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic . <p> In fact, this worst-case performance occurs even if w j = 1 for all j. Hence, the worst-case performance of the algorithm is likely to arise from the lack of consideration given to the hypergraph structure. In <ref> [Balas80b] </ref> several closely-related cost functions (such as log| e j | / w j ) were proposed and simulated, and it was suggested that these cost functions might yield better performance than the cost function used by the Clj heuristic.
Reference: [Belkhale90] <author> Belkhale, K. P. and P. Banerjee. </author> <title> An Approximate Algorithm for the Partitionable Independent Task Scheduling Problem. </title> <booktitle> Proceedings of the International Conference on Parallel Processing (1990) vol. </booktitle> <volume> I, </volume> <pages> pp. </pages> <address> 72- 75. </address>
Reference-contexts: If a job 91 takes p i units of time to finish on one processor then it would take s i (p i /k) time units to finish when executed in parallel on k processors. In <ref> [Belkhale90] </ref> the problem of minimizing completion time is considered and an algorithm with a worst-case performance of 2 1/(m+1) is presented.
Reference: [Biyabani88] <author> Biyabani, Sara R., John A. Stankovic and Krithi Ramamritham. </author> <title> The Integration of Deadline and Criticalness in Hard Real-Time Scheduling. </title> <booktitle> Proceedings of the IEEE Real Time System Symposium (1988) vol. </booktitle> <volume> 9, </volume> <pages> pp. 152-160. </pages>
Reference-contexts: In several simulation studies greedy scheduling has been found to be effective in scheduling a random task system <ref> [Biyabani88] </ref> [Ramamritham84]. We believe that this conclusion may have been reached because the aspect ratio was not a controlled variable in the simulation. As the theorem above shows, a simulation should generate task systems with a = 1 to ensure that the worst-case workloads are tested.
Reference: [Chakrabarti92] <author> Chakrabarti, P. P. and S. Ghose. </author> <title> A General Best First Search Algorithm in AND/OR Graphs. </title> <journal> Journal of Algorithms (1992) vol. </journal> <volume> 13, </volume> <pages> pp. 177-187. </pages>
Reference-contexts: Algorithms have been proposed to dynamically schedule an AND/OR/skipped task system with tree precedence constraints to minimize the execution time on a single processor [Mahanti85] <ref> [Chakrabarti92] </ref>. This previous work assumes that the task system is too large to be fully explored; the scheduling algorithm makes decisions based on a usersupplied function that predicts the future execution costs of different task subgraphs.
Reference: [Chang90] <author> Chang, Ming-Feng, Weiping Shi and W. Kent Fuchs. </author> <title> Optimal Diagnosis Procedures for k-out-of-n Structures. </title> <journal> IEEE Transactions on Computers (April 1990) vol. </journal> <volume> 39, no. 4, </volume> <pages> pp. 559-564. </pages>
Reference-contexts: This problem is known as sequencing to minimize the mean time to the first failure. There is an optimal algorithm to minimize the expected time to get k failures in a schedule <ref> [Chang90] </ref> when all the tasks are independent. The algorithm identifies a set of k tasks which ranges from those with short execution time and high probability of success to those with longer execution time and lower probability of success.
Reference: [Chang88] <author> Chang, Po-Rong. </author> <title> Parallel Algorithms and VLSI Architectures for Robotics and Assembly Scheduling. </title> <type> Ph.D. Thesis, </type> <institution> Purdue University, West Lafayette, </institution> <note> Indiana (December 1988). </note>
Reference-contexts: In some applications all the predecessors of an OR task must eventually be completed, that is, they cannot be skipped. This type of application model is called the AND/OR/unskipped model. This model was proposed by Chang in his Ph.D. thesis <ref> [Chang88] </ref>.
Reference: [Chen75] <author> Chen, Nai-Fung. </author> <title> An Analysis of Scheduling Algorithms in Multiprocessor Computing Systems, </title> <institution> University of Illinois Department of Computer Science Report No. UIUCDCS-R-75-724, Urbana, Illinois, </institution> <year> 1975. </year>
Reference-contexts: Chen and Liu <ref> [Chen75] </ref> showed that for UET tasks and the longest-processing-time (LPT) algorithm, W'/W 2 1/(m 1) for m 3, and W'/W 4/3 for m = 2. Coffman and Graham 90 examined an algorithm that is a refinement of LPT, and showed that it was optimal for 2-processor scheduling [Coffman72].
Reference: [Chung89] <author> Chung, J. Y., Wei-Kuan Shih, Jane W.-S. Liu, and Donald W. Gillies. </author> <title> Scheduling Imprecise Computations to Minimize Total Error. </title> <journal> Microprocessing and Microprogramming (1989) vol. </journal> <volume> 27, </volume> <pages> pp. 767-774. </pages>
Reference-contexts: The AND/OR/skipped task model can represent the portions of tasks or portions of the task system that may be skipped. In the early models of imprecise computation <ref> [Chung89] </ref> [Chung90] [Shih91], it was assumed that the precision of an imprecise task was linearly increasing and continuous. The AND/OR/skipped task model can represent applications where the precision increases in discrete steps, and this is presumably more common in real-world applications.
Reference: [Chung90] <author> Chung, J. Y., Liu, J. W.-S. and K. J. Lin. </author> <title> Scheduling Periodic Jobs That Allow Imprecise Results. </title> <journal> IEEE Transactions on Computers (September 1990) vol. </journal> <volume> 39, no. 9, </volume> <pages> pp. 1156-1174. </pages>
Reference-contexts: The AND/OR/skipped task model can represent the portions of tasks or portions of the task system that may be skipped. In the early models of imprecise computation [Chung89] <ref> [Chung90] </ref> [Shih91], it was assumed that the precision of an imprecise task was linearly increasing and continuous. The AND/OR/skipped task model can represent applications where the precision increases in discrete steps, and this is presumably more common in real-world applications. Fault-tolerant applications may also benefit from AND/OR scheduling [Thumbidurai89] [McElvany88].
Reference: [Chvatal79] <author> Chvatal, V. </author> <title> A Greedy Heuristic for the Set-Covering Problem. </title> <journal> Mathematics of Operations Research (August 1979) vol. </journal> <volume> 4, no. 3, </volume> <pages> pp. 233-235. </pages>
Reference-contexts: A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] [Balas80b], and one heuristic with bounded worst-case performance has been developed <ref> [Chvatal79] </ref> [Lovasz75] [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [Coffman76] <author> Coffman, E. G. (ed), </author> <title> Computer and Job Shop Scheduling Theor y, </title> <address> New York: </address> <publisher> Wiley (1976). </publisher> <pages> 102 </pages>
Reference-contexts: Examples of AND-only task systems that achieve the bound of Corollary 4.5. under any set of task priorities may be found in <ref> [Coffman76] </ref> and [Gillies91b]. All priority-driven algorithms must schedule these AND-only task systems as a special case. <p> As the theorem above shows, a simulation should generate task systems with a = 1 to ensure that the worst-case workloads are tested. When a = 1 then Theorem 4.7 reduces to W'/ W 2 1/ m. The worst-case task systems from <ref> [Coffman76] </ref> and [Gillies91b] both have a = 1. The aspect ratio theorem suggests a method to choose between two different graphs with identical values L 1 (B (G)). Presumably, the graphs have different aspect ratios, so one may compute the two worst-case performance levels W'/W from these aspect ratios.
Reference: [Coffman78] <author> Coffman, E. G., J. Y. Leung and D. W. Ting. </author> <title> Bin Packing: Maximizing the Number of Pieces Packed. </title> <journal> Acta Informatica (1978) vol. </journal> <volume> 9, </volume> <pages> pp. </pages> <note> 263-271. </note> <author> [deMello86] de Mello, Luiz S. Homem and Arthur C. Sanderson. </author> <title> AND/OR Graph Representation of Assembly Plans. </title> <booktitle> Proceedings of AAAI (1986) pp. </booktitle> <pages> 1113-1119. </pages>
Reference-contexts: There are similar heuristics such as the fewest-predecessors-first, least-slack-first, and least - slack-times-predecessors-first heuristic. All these heuristics neglect to compare the deadlines among different in-trees. Other examples of such heuristics are multidimensional versions of some previous heuristics that maximize the number of pieces packed into bins <ref> [Coffman78] </ref>.
Reference: [Dertouzos74] <author> M. Dertouzos. </author> <title> Control Robotics: the Procedural Control of Physical Processes. </title> <booktitle> Proceedings of the IFIP Congress (1974), </booktitle> <pages> pp. 807-813. </pages>
Reference-contexts: In other words, if there is a schedule that meets all the deadlines then the earliest deadline first rule finds such a schedule. The least-laxity-first algorithm is also optimal, but it can lead to an inordinate number of preemptions <ref> [Dertouzos74] </ref>. When there are several processors McNaughton's algorithm can be used to meet multiple deadlines.
Reference: [Du89] <author> Du, Jianzhong and Joseph Y-T. Leung. </author> <title> Complexity of Scheduling Parallel Task Systems, </title> <journal> SIAM Journal on Discrete Math (1989) vol. </journal> <volume> 2, </volume> <pages> pp. 473-487. </pages>
Reference-contexts: In [Leung90], several complexity results are presented, and not surprisingly, most variants of the problem are strongly NP-complete. However, several types of problems can be solved in pseudo-polynomial time. Full details are contained in <ref> [Du89] </ref>. The problem of minimizing the completion time of independent tasks with arbitrary (unconstrained) parallel speedups is considered in [Gillies91c]. Using the techniques developed for AND/OR scheduling, an algorithm is proposed with 2 1/ m performance.
Reference: [Fisher90] <author> Fisher, Marshall L. and Pradeep Kedia. </author> <title> Optimal Solution of Set Covering/Partitioning Problems Using Dual Heuristics. </title> <booktitle> Management Science (June 1990) vol. </booktitle> <volume> 36, no. 6., </volume> <pages> pp. 674-688. </pages>
Reference-contexts: A good AND/OR/skipped scheduling algorithm should produce good set cover solutions when a bipartite set-cover graph is input to the algorithm. A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem <ref> [Fisher90] </ref> [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] [Balas80b], and one heuristic with bounded worst-case performance has been developed [Chvatal79] [Lovasz75] [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [Fuji69] <author> Fuji, M, T. Kasami and K. Ninomiya. </author> <title> Optimal Sequencing of Two Equivalent Processors. </title> <journal> SIAM Journal of Applied Mathematics (1969) vol. </journal> <volume> 17, </volume> <pages> pp. 784-789. </pages>
Reference-contexts: Scheduling to Minimize Completion Time A widely studied problem is that of scheduling unitexecution-time tasks with precedence constraints to minimize completion time on two processors. Many algorithms have been proposed to solve this problem <ref> [Fuji69] </ref> [Muraoka71] [Coffman72] [Garey77]. When a third processor is present, the complexity of the problem is unknown and has remained one of the most famous open problems in complexity theory [Garey79]. For an arbitrary number of processors, three heuristics have been analyzed.
Reference: [Gallo86] <author> Gallo, Giorgio and Stefano Pallottino. </author> <title> Shortest Path Methods: A Unifying Approach. </title> <booktitle> Mathematical Programming Study (1986) vol. </booktitle> <volume> 26, </volume> <pages> pp. 38-64. </pages>
Reference-contexts: Many interesting operations-research applications are contained therein. Tarjan [Tarjan81] presents a different 95 approach where Warshall's algorithm is generalized to solve path problems over an algebra of regular expressions. This work contains many interesting applications in the area of dataflow analysis of computer programs. The work <ref> [Gallo86] </ref> surveys many previous algorithms to solve minimum path problems on digraphs. It uses an ad-hoc algorithm blueprint and is not an axiomatic treatment. By changing certain parameters of the blueprint some classical and some recent algorithms are derived.
Reference: [Garey73] <author> Garey, M. R. </author> <title> Optimal task sequencing with precedence constraints. </title> <journal> Discrete Mathematics (1973) vol. </journal> <volume> 4, </volume> <pages> pp. 37-56. </pages>
Reference-contexts: This algorithm has been around for a long time; Chang's work contains the first proof of its optimality for general values of n and k. When precedence constraints are present then the problem becomes considerably harder. Garey considers the problem of sequencing with precedence constraints <ref> [Garey73] </ref>. He shows that a series of interchange rules may be applied that allow task pairs to be merged or the precedence constraints to be relaxed. His rules are sufficient to provide optimal schedules for opposing forests.
Reference: [Garey76] <author> Garey, M. R. and D. S. Johnson. </author> <title> Scheduling Tasks with Nonuniform Deadlines on Two Processors. </title> <journal> Journal of the ACM (July 1976) vol. </journal> <volume> 23, no. 3, </volume> <pages> pp. 461-467. </pages>
Reference-contexts: When the release times and deadlines are arbitrary rational numbers, then it is possible to meet deadlines for UET tasks on a single processor [Garey81]. 89 When precedence constraints are present in a uniprocessor task system then a deadline modification algorithm can be used to remove these constraints <ref> [Garey76] </ref> (see Section 2.3). Therefore, precedence constraints are usually not a problem in scheduling a uniprocessor. When precedence constraints are present in a multiprocessor system and the tasks are UET, then the algorithms [Garey76] [Garey77] can be used to meet deadlines or to meet release times and deadlines on two processors. <p> in a uniprocessor task system then a deadline modification algorithm can be used to remove these constraints <ref> [Garey76] </ref> (see Section 2.3). Therefore, precedence constraints are usually not a problem in scheduling a uniprocessor. When precedence constraints are present in a multiprocessor system and the tasks are UET, then the algorithms [Garey76] [Garey77] can be used to meet deadlines or to meet release times and deadlines on two processors. When the precedence constraints form an in-tree and the tasks are UET, then there is an optimal algorithm to meet deadlines on a multiprocessors [Hu61]. <p> Lam and Sethi extended this proof to show that the algorithm obeys the bound W'/W 2 2/m for an arbitrary number of processors [Lam77]. Gillies [Gillies93a] has analyzed the algorithm of <ref> [Garey76] </ref> in the context of m processor scheduling. He showed that W'/W 2 2/m for m 3, and W'/W = 3/2 for m = 3. When preemption is allowed and the task lengths are arbitrary, Muntz and Coffman proposed an algorithm that is optimal for two processors [Muntz72].
Reference: [Garey77] <author> Garey, M. R. and D. S. Johnson. </author> <title> Two-Processor Scheduling With Start Times and Deadlines. </title> <journal> SIAM Journal on Computing (1977) vol. </journal> <volume> 6, </volume> <pages> pp. 416-428. </pages>
Reference-contexts: Unfortunately, it seems difficult to apply these techniques to schedule AND/OR task systems. Deadline Modification. The technique of deadline modification is used in some optimal algorithms for scheduling AND-only task systems to meet deadlines on one or two processors <ref> [Garey77] </ref> [Garey81]. <p> In fact, the next chapter shows that the one-processor scheduling problem is NP-hard. Precedence Constraint Modification. The technique of precedence constraint modification, taken from <ref> [Garey77] </ref>, is used to convert an algorithm to minimize completion time into an algorithm to meet deadlines. <p> Later, multiprocessor scheduling is considered and it is shown that for general graphs and for in-trees, the problem of minimizing completion time is also NP-complete. 3.1.1. Scheduling to Meet Deadlines on a Single Processor There are well-known polynomial-time algorithms <ref> [Garey77] </ref> [Garey81] for scheduling tasks with AND-only precedence constraints, identical processing times, and arbitrary deadlines on one or two processors. It is natural to ask whether the corresponding AND/OR scheduling problems may be solved in polynomial time. <p> Therefore, when there are O (log n ) OR tasks in the AND/OR task system, it is possible to enumerate in polynomial time the set of all possible AND-only task graphs and apply an optimal AND-only scheduling algorithm such as the one described in <ref> [Garey77] </ref> to find an optimal schedule of the AND/OR task system. On the other hand, Theorems 3.1 through 3.4 show that several natural scheduling problems with O (n) OR tasks are NP-complete. <p> Therefore, precedence constraints are usually not a problem in scheduling a uniprocessor. When precedence constraints are present in a multiprocessor system and the tasks are UET, then the algorithms [Garey76] <ref> [Garey77] </ref> can be used to meet deadlines or to meet release times and deadlines on two processors. When the precedence constraints form an in-tree and the tasks are UET, then there is an optimal algorithm to meet deadlines on a multiprocessors [Hu61]. <p> Scheduling to Minimize Completion Time A widely studied problem is that of scheduling unitexecution-time tasks with precedence constraints to minimize completion time on two processors. Many algorithms have been proposed to solve this problem [Fuji69] [Muraoka71] [Coffman72] <ref> [Garey77] </ref>. When a third processor is present, the complexity of the problem is unknown and has remained one of the most famous open problems in complexity theory [Garey79]. For an arbitrary number of processors, three heuristics have been analyzed.
Reference: [Garey79] <author> Garey, M. R. and D. S. Johnson. </author> <title> Computers and Intractibility: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <address> San Francisco (1979). </address>
Reference-contexts: This problem is known to be NP - complete <ref> [Garey79] </ref>. v 1 v 3 e 1 e 2 T T T T 1,2,3 T 4,5,6 2 4 6 (a) Exact 3-cover problem (b) AND/OR task system The exact 3-cover problem can be transformed into an AND/OR scheduling problem as follows. <p> Proof. It suffices to show that the problem is NP-complete on a single processor. The proof is based on a reduction from the partition with integer weights problem <ref> [Garey79] </ref>. <p> This problem is NP-complete <ref> [Garey79] </ref>. The partition problem is transformed into a one-processor scheduling problem as follows. <p> Many algorithms have been proposed to solve this problem [Fuji69] [Muraoka71] [Coffman72] [Garey77]. When a third processor is present, the complexity of the problem is unknown and has remained one of the most famous open problems in complexity theory <ref> [Garey79] </ref>. For an arbitrary number of processors, three heuristics have been analyzed.
Reference: [Garey81] <author> Garey, M. R., D. S. Johnson, B. B. Simons and R. E. Tarjan. </author> <title> Scheduling Unit-Time Tasks with Arbitrary Release Times and Deadlines. </title> <journal> SIAM J. Computing (May 1981) vol. </journal> <volume> 10, no. 2, </volume> <pages> pp. 256-269. </pages>
Reference-contexts: Unfortunately, it seems difficult to apply these techniques to schedule AND/OR task systems. Deadline Modification. The technique of deadline modification is used in some optimal algorithms for scheduling AND-only task systems to meet deadlines on one or two processors [Garey77] <ref> [Garey81] </ref>. <p> Later, multiprocessor scheduling is considered and it is shown that for general graphs and for in-trees, the problem of minimizing completion time is also NP-complete. 3.1.1. Scheduling to Meet Deadlines on a Single Processor There are well-known polynomial-time algorithms [Garey77] <ref> [Garey81] </ref> for scheduling tasks with AND-only precedence constraints, identical processing times, and arbitrary deadlines on one or two processors. It is natural to ask whether the corresponding AND/OR scheduling problems may be solved in polynomial time. <p> To make this decision the arc (T i , T j ) is discarded if (Step 2a) the task graph already has some other arc ( T k , T j ), or if (Step 2b) the algorithm of <ref> [Garey81] </ref> indicates that the task system would become infeasible if ( T i , T j ) were added to the AND-only task graph. If the arc passes both tests, it is added to the AND-only task graph, otherwise it is discarded. <p> The heuristic then tests the next arc in the priority list, and so on, until the list is exhausted and a 23 feasible AND-only task graph has been produced. (Step 3) The AND-only task graph is scheduled according to the optimal algorithm of <ref> [Garey81] </ref>. An arbitrary AND/OR scheduling heuristic is greedy if its chosen AND-only graph is locally optimal, i.e. no additional OR in-arcs may be added to the graph without making the graph infeasible. An optimal algorithm is in the class of greedy heuristics. <p> When the release times and deadlines are arbitrary rational numbers, then it is possible to meet deadlines for UET tasks on a single processor <ref> [Garey81] </ref>. 89 When precedence constraints are present in a uniprocessor task system then a deadline modification algorithm can be used to remove these constraints [Garey76] (see Section 2.3). Therefore, precedence constraints are usually not a problem in scheduling a uniprocessor.
Reference: [Gillies90] <author> Gillies, Donald W. and Jane W.S. Liu. </author> <title> Scheduling tasks with AND/OR precedence constraints. </title> <booktitle> Second Annual IEEE Symposium on Parallel Distributed Processing (December 1990), </booktitle> <pages> pp. 379-387. </pages>
Reference-contexts: To carry out this approximation, negative task lengths may be input to the scheduling algorithms. This may be of use to developers of real-time language timing tools. 1.2. Summary of Results Some of the work in this thesis has already appeared. In particular, <ref> [Gillies90] </ref> [Gillies91a] and [Gillies93b] contain some of the results in this thesis. We first show that our AND/OR scheduling model subsumes some other models. Then it is shown that if the precedence constraints are arbitrary, the skipped problem subsumes the unskipped problem.
Reference: [Gillies91a] <author> Gillies, D. W. and J. W. S. Liu. </author> <title> Scheduling Tasks with AND/OR Precedence Constraints. </title> <type> Report No. </type> <institution> UIUCDCS-R-90-1627 (UIUC-ENG-1766), Department of Computer Science, University of Illinois at Urbana-Champaign (1991). </institution>
Reference-contexts: To carry out this approximation, negative task lengths may be input to the scheduling algorithms. This may be of use to developers of real-time language timing tools. 1.2. Summary of Results Some of the work in this thesis has already appeared. In particular, [Gillies90] <ref> [Gillies91a] </ref> and [Gillies93b] contain some of the results in this thesis. We first show that our AND/OR scheduling model subsumes some other models. Then it is shown that if the precedence constraints are arbitrary, the skipped problem subsumes the unskipped problem.
Reference: [Gillies91b] <author> Gillies, Donald W. and Jane W.S. Liu. </author> <title> Greed in Resource Scheduling. </title> <journal> Acta Informatica (1991) vol. </journal> <volume> 28, </volume> <pages> pp. 755-775. </pages>
Reference-contexts: If L*(B (G)) = min alli -L*(B i (G))-, then W ( B (G))/ W opt 21/m in any priority - driven schedule of the AND/OR/unskipped task system B (G). n It is known <ref> [Gillies91b] </ref> that no AND-only priority-driven algorithm can avoid 2 1/ m worst-case performance (because priority-driven algorithms never intentionally idle the processor, and sometimes intentional idling is needed). <p> Examples of AND-only task systems that achieve the bound of Corollary 4.5. under any set of task priorities may be found in [Coffman76] and <ref> [Gillies91b] </ref>. All priority-driven algorithms must schedule these AND-only task systems as a special case. <p> As the theorem above shows, a simulation should generate task systems with a = 1 to ensure that the worst-case workloads are tested. When a = 1 then Theorem 4.7 reduces to W'/ W 2 1/ m. The worst-case task systems from [Coffman76] and <ref> [Gillies91b] </ref> both have a = 1. The aspect ratio theorem suggests a method to choose between two different graphs with identical values L 1 (B (G)). Presumably, the graphs have different aspect ratios, so one may compute the two worst-case performance levels W'/W from these aspect ratios. <p> Many researchers have considered the problem of scheduling with additional constraints such as resources or processors of different speeds. The most relevant work along these lines is our own; it introduce a method of finding the worst-case heuristic performance using symbolic linear programming [Gillies89] <ref> [Gillies91b] </ref>. The work in this thesis builds mainly on the work of Graham. As was shown in Chapter 4, the distance measures used in this thesis are NP-complete to compute, even for generalized series-parallel graphs and arbitrary execution times. <p> It provides a performance guarantee of 3 2/ m. This is surprising because if the tasks are parallel but the parallelism cannot be changed, then the worst case performance is known to be m times optimal <ref> [Gillies91b] </ref>. There has also been some work on the problem of scheduling with precedence constraints to meet deadlines. This problem is considered in [Yu91] and a heuristic approach based on linear programming is proposed.
Reference: [Gillies91c] <author> Gillies, Donald W. </author> <title> Scheduling Parallelizable Jobs. </title> <type> Manuscript (1991). </type>
Reference-contexts: However, several types of problems can be solved in pseudo-polynomial time. Full details are contained in [Du89]. The problem of minimizing the completion time of independent tasks with arbitrary (unconstrained) parallel speedups is considered in <ref> [Gillies91c] </ref>. Using the techniques developed for AND/OR scheduling, an algorithm is proposed with 2 1/ m performance. Thus, the techniques developed for this thesis can be applied to other settings when the scheduler must choose from many different kinds of task systems.
Reference: [Gillies93a] <author> Gillies, Donald W. </author> <title> A New Heuristic for UET and Pipeline Scheduling, </title> <booktitle> Sixth SIAM Conference on Parallel Processing for Scientific Computing, </booktitle> <month> (March </month> <year> 1993). </year>
Reference-contexts: Coffman and Graham 90 examined an algorithm that is a refinement of LPT, and showed that it was optimal for 2-processor scheduling [Coffman72]. Lam and Sethi extended this proof to show that the algorithm obeys the bound W'/W 2 2/m for an arbitrary number of processors [Lam77]. Gillies <ref> [Gillies93a] </ref> has analyzed the algorithm of [Garey76] in the context of m processor scheduling. He showed that W'/W 2 2/m for m 3, and W'/W = 3/2 for m = 3.
Reference: [Gillies93b] <author> Gillies, Donald W. and Jane W.-S. Liu. </author> <title> Scheduling Tasks With AND/OR Precedence Constraints. </title> <note> To appear, SIAM Journal on Computing (1993). 103 </note>
Reference-contexts: To carry out this approximation, negative task lengths may be input to the scheduling algorithms. This may be of use to developers of real-time language timing tools. 1.2. Summary of Results Some of the work in this thesis has already appeared. In particular, [Gillies90] [Gillies91a] and <ref> [Gillies93b] </ref> contain some of the results in this thesis. We first show that our AND/OR scheduling model subsumes some other models. Then it is shown that if the precedence constraints are arbitrary, the skipped problem subsumes the unskipped problem.
Reference: [Graham69] <author> Graham, Ronald L. </author> <title> Bounds on Multiprocessing Timing Anomalies. </title> <journal> SIAM Journal of Applied Mathematics (March 1969) vol. </journal> <volume> 17, no. 2, </volume> <pages> pp. 416-429. </pages>
Reference-contexts: Let L r (G)= ```````````` r r r denote the well-known L r distance measure of a point in two-dimensional space. In particular, L 1 (G) = L*(G) + E*( G)/m, and L ( G)=max (L*(G),E*(G)/m). The following fact is proved in a well - known work <ref> [Graham69] </ref>. Lemma 4.1. <p> The proof opens by observing a consequence of Graham's famous theorem <ref> [Graham69] </ref>, namely W (B (G)) P*(B (G) )/m + L*( B (G) ). From the assumption that B (G) is a minimal graph, we have P*(B (G) )/m + L*(B (G) ) P*(G o )/m + L*(G o ). <p> Let W denote the length of an optimal schedule and let W' denote the length of a worst-case list schedule. The following theorem relates worst-case scheduling performance to the quantity a. It is a generalization of the theorem of <ref> [Graham69] </ref>. Theorem 4.7. The worst-case performance of listscheduling on m processors is W' 1 1 ifa1andam1 1+a m ifa1andam1 undefined ifam&lt;1. Proof. The time in any list schedule can be divided into two types, known as the idle time and the busy time. <p> Proof. The time in any list schedule can be divided into two types, known as the idle time and the busy time. Let W b denote the total length of the busy time and let W p denote the total length of the idle time. A theorem of <ref> [Graham69] </ref> states that there is a chain of tasks that executes during the idle time, and that the time is limited by W p L*(G) = P*(G ) / ma. <p> Graham showed that for tasks of arbitrary length and with arbitrary execution time, all schedules obey the bound W'/W 2 1/ m, where m is the number of processors, W' is the length of a worst - case schedule, and W is the length of an optimal schedule <ref> [Graham69] </ref>. Chen and Liu [Chen75] showed that for UET tasks and the longest-processing-time (LPT) algorithm, W'/W 2 1/(m 1) for m 3, and W'/W 4/3 for m = 2.
Reference: [Hu61] <author> Hu, T. C. </author> <title> Parallel Sequencing and Assembly Line Problems. </title> <journal> Operations Research (1961) vol. </journal> <volume> 9, </volume> <pages> pp. 841-848. </pages>
Reference-contexts: About thirty years ago, T. C. Hu gave a polynomial-time algorithm to schedule an AND-only task system with in-tree precedence constraints on m processors <ref> [Hu61] </ref>. Thus, there is some hope that if the AND/OR/unskipped task system is restricted to only in-tree precedence constraints, a polynomial-time algorithm may be feasible. Unfortunately, the following theorem shows that this AND/OR scheduling problem is NP-complete. Theorem 3.2. <p> This problem is equivalent to that of scheduling to minimize the overall completion time. Ullman has shown this problem to 26 be NP-complete [Lawler89] for AND-only task systems where all the tasks have identical processing times; however, Hu <ref> [Hu61] </ref> has shown that if the graph is an in-tree, then it is possible to minimize the overall completion time in a multiprocessor. Unfortunately, unless P=NP the completion time of an AND/OR task system cannot be minimized in a multiprocessor. Theorem 3.5. <p> When the precedence constraints form an in-tree and the tasks are UET, then there is an optimal algorithm to meet deadlines on a multiprocessors <ref> [Hu61] </ref>. The earlier work in scheduling to meet deadlines provides a multitude of tractable AND-only scheduling problems. These problems were investigated in Chapter three to see if the corresponding AND/OR scheduling problems could be solved in polynomial time. 6.2.
Reference: [Johnson74] <author> Johnson, D. S. </author> <title> Approximation Algorithms for Combinatorial Problems. </title> <journal> Journal of Computer and System Sciences (1974) vol. </journal> <volume> 9, </volume> <pages> pp. 256-278. </pages>
Reference-contexts: A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] [Balas80b], and one heuristic with bounded worst-case performance has been developed [Chvatal79] [Lovasz75] <ref> [Johnson74] </ref>. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [Kim91] <author> Kim, Taewhan, Jane W.-S. Liu, and C. L. Liu. </author> <title> A Scheduling Algorithm for Conditional Resource Sharing. </title> <booktitle> Proceedings of International Conference on Computer-Aided Design (1991) pp. </booktitle> <pages> 84-87. </pages>
Reference-contexts: Therefore, most of the algorithms in this thesis will be designed to solve AND/OR/skipped scheduling problems. Tasks with OR-fork semantics. A different type of AND/OR task system has been considered in <ref> [Kim91] </ref>. In this type of task system, only one of the direct successors of each OR task is executed. Such an OR task and its successors model conditional branches in the course of a computation. <p> In other words, an OR-fork task is similar to an IF statement in a dataflow graph; just one branch of the graph is taken in a given execution of a program. The scheduler does not know which branch will be taken and must plan for each branch separately <ref> [Kim91] </ref>. The goal of the planning is to produce partial schedules of the conditional branches that make efficient use of the processor's resources.
Reference: [Lam77] <author> Lam, Shui and Ravi Sethi. </author> <title> Worst Case Analysis of Two Scheduling Algorithms. </title> <journal> SIAM Journal on Computing (September 1977) vol. </journal> <volume> 6, no. 3, </volume> <pages> pp. 518-536. </pages>
Reference-contexts: Coffman and Graham 90 examined an algorithm that is a refinement of LPT, and showed that it was optimal for 2-processor scheduling [Coffman72]. Lam and Sethi extended this proof to show that the algorithm obeys the bound W'/W 2 2/m for an arbitrary number of processors <ref> [Lam77] </ref>. Gillies [Gillies93a] has analyzed the algorithm of [Garey76] in the context of m processor scheduling. He showed that W'/W 2 2/m for m 3, and W'/W = 3/2 for m = 3. <p> When preemption is allowed and the task lengths are arbitrary, Muntz and Coffman proposed an algorithm that is optimal for two processors [Muntz72]. Lam and Sethi extended this algorithm to show W'/W 2 2/m when an arbitrary number of processors are present <ref> [Lam77] </ref>. Many researchers have considered the problem of scheduling with additional constraints such as resources or processors of different speeds. The most relevant work along these lines is our own; it introduce a method of finding the worst-case heuristic performance using symbolic linear programming [Gillies89] [Gillies91b].
Reference: [Lawler89] <author> Lawler, E. L., J. K. Lenstra, A. H. G. Rinnooy Kan and D. B. Shmoys. </author> <title> Sequencing and Scheduling: Algorithms and Complexity, </title> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: Task Processing Time General Graph In-Tree Identical NP-C <ref> [Lawler89] </ref> for AND-only NP-C (Theorem 3.5) Arbitrary Minimum-Path Algorithm Minimum-Path Algorithm Without loss of generality, assume that a priority-driven heuristic is used to schedule the AND/OR task system, and assume that the heuristic consists of three conceptual steps. <p> Scheduling to Minimize Completion Time Consider the problem of scheduling AND/OR/unskipped task systems with arbitrary processing times on m processors to meet a common deadline. This problem is equivalent to that of scheduling to minimize the overall completion time. Ullman has shown this problem to 26 be NP-complete <ref> [Lawler89] </ref> for AND-only task systems where all the tasks have identical processing times; however, Hu [Hu61] has shown that if the graph is an in-tree, then it is possible to minimize the overall completion time in a multiprocessor. <p> Task Processing Time General Graph In-Tree Identical NP-C <ref> [Lawler89] </ref> NP-C (Theorem 3.8) Arbitrary No Algorithm Path-Balancing Algorithm 3.2.2. Scheduling to Minimize Completion Time Table 3.2 also gives the complexity of scheduling m processors to minimize completion time. Theorem 3.8. <p> It follows that unless P = NP no polynomial-time AND/OR/skipped scheduling algorithm can guarantee a worst-case completion time of less than 3/2 times the length of an optimal schedule. In contrast to this, if the task system is AND-only, it is known <ref> [Lawler89] </ref> that no polynomial-time algorithm can guarantee a worst-case completion time of less than of 4/3 times the length of an optimal schedule. 30 CHAPTER 4. APPROXIMATION ALGORITHMS Many optimal scheduling algorithms work in two phases. <p> In fact, it has been a longstanding open problem to find a non-priority-driven AND-only scheduling algorithm that avoids 2 1/m worst-case performance <ref> [Lawler89] </ref>. Our last approximation theorem substitutes P*(G) for E*(G) in the distance metric. 36 Theorem 4.6. Define a metric space with axes L*( G) and P*( G)/m.
Reference: [Lehmann77] <author> Lehmann, Daniel J. </author> <title> Algebraic Structures for Transitive Closure. </title> <booktitle> Theoretical Computer Science (1977) vol. </booktitle> <volume> 4, </volume> <pages> pp. 59-76. </pages>
Reference-contexts: If each row of the matrix requires a separate page, then Warren's algorithm reduces the number of page faults from O (n 2 In [Aho74] the algorithm of Warshall is unified to solve a large class of path problems over a closed semiring. In <ref> [Lehmann77] </ref> Warshall's algorithm is generalized over closed semi-rings, with slightly weaker assumptions and simpler proofs than [Aho74]. Many interesting operations-research applications are contained therein. Tarjan [Tarjan81] presents a different 95 approach where Warshall's algorithm is generalized to solve path problems over an algebra of regular expressions.
Reference: [Leung90] <author> Leung, Joseph Y-T. </author> <title> Research in Real-Time Scheduling. </title> <booktitle> Third Annual Office of Naval Research Workshop (October 1990) vol. </booktitle> <volume> 3, </volume> <pages> pp. 11-17. </pages>
Reference-contexts: This algorithm assumes a more general task model where the task speedup function is a concave function of the number of processors allotted to the task, and there is no supralinear speedup. In <ref> [Leung90] </ref>, several complexity results are presented, and not surprisingly, most variants of the problem are strongly NP-complete. However, several types of problems can be solved in pseudo-polynomial time. Full details are contained in [Du89].
Reference: [Liu73] <author> Liu, C. L. and James W. Layland. </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment. </title> <journal> Journal of the ACM (January 1973) vol. </journal> <volume> 20, no. 1, </volume> <pages> pp. 46-61. </pages>
Reference-contexts: Scheduling to Meet Deadlines The problem of scheduling tasks with release times and deadlines has been extensively studied. In the case where there are no precedence constraints, arbitrary execution times, and preemption is allowed, the earliest deadline first method has been shown to be optimal for a single processor <ref> [Liu73] </ref>. In other words, if there is a schedule that meets all the deadlines then the earliest deadline first rule finds such a schedule. The least-laxity-first algorithm is also optimal, but it can lead to an inordinate number of preemptions [Dertouzos74].
Reference: [Lovasz75] <author> Lovasz, L. </author> <title> On the Ratio of Optimal Integral and Fractional Covers. </title> <journal> Discrete Mathematics (1975) vol. </journal> <volume> 13, </volume> <pages> pp. 383-390. </pages>
Reference-contexts: A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] [Mahanti90]. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] [Balas80b], and one heuristic with bounded worst-case performance has been developed [Chvatal79] <ref> [Lovasz75] </ref> [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [Mahanti85] <author> Mahanti, </author> <title> A and A Bagchi. AND/OR Graph Heuristic Search Methods. </title> <journal> Journal of the ACM (January 1985) vol. </journal> <volume> 32, no. 1, </volume> <pages> pp. 28-51. </pages>
Reference-contexts: Algorithms have been proposed to dynamically schedule an AND/OR/skipped task system with tree precedence constraints to minimize the execution time on a single processor <ref> [Mahanti85] </ref> [Chakrabarti92]. This previous work assumes that the task system is too large to be fully explored; the scheduling algorithm makes decisions based on a usersupplied function that predicts the future execution costs of different task subgraphs.
Reference: [Mahanti90] <author> Mahanti, Ambuj, Karinthi, Raghu, Ghosh, Subrata and Asim Pal. </author> <title> AI Search for Minimum-Cost Set Cover and Multiple-Goal Plan Optimization Problems: Applications to Process Planning. </title> <type> Report No. </type> <institution> UMIACS-TR-90-125, Institute for Advanced Computer Studies, University of Maryland at College Park (1990). </institution>
Reference-contexts: A good AND/OR/skipped scheduling algorithm should produce good set cover solutions when a bipartite set-cover graph is input to the algorithm. A great deal is known about efficient algorithms for the set cover problem. Ad-hoc branch-and-bound algorithms have been developed to solve this problem [Fisher90] <ref> [Mahanti90] </ref>. Cutting-plane branch-and-bound algorithms have also been developed [Balas80a] [Balas80b], and one heuristic with bounded worst-case performance has been developed [Chvatal79] [Lovasz75] [Johnson74]. The algorithms in this thesis are based on a generalization of this last heuristic, which works as follows. Chvatal-Lovasz-Johnson (Clj) Heuristic .
Reference: [McElvany88] <author> McElvany, Michelle C. </author> <title> Guaranteeing Deadlines in MAFT. </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium (December 1988) vol. </booktitle> <volume> 9, </volume> <pages> pp. 130-139. </pages>
Reference-contexts: For instance, a recent real-time system called MAFT 4 incorporated AND/OR precedence constraints into its implementation <ref> [McElvany88] </ref>. This system provides support for task graphs with OR-fork/AND-join semantics (analogous to an if statement in a programming language), as well as AND-fork/OR-join semantics. The latter semantics are equivalent to the type of precedence constraints discussed in this thesis. <p> The AND/OR/skipped task model can represent applications where the precision increases in discrete steps, and this is presumably more common in real-world applications. Fault-tolerant applications may also benefit from AND/OR scheduling [Thumbidurai89] <ref> [McElvany88] </ref>. In this type of scheduling OR tasks known as a threshold task s are ready to execute when k out of m direct predecessor tasks have completed their execution.
Reference: [Monma79] <author> Monma, Clyde L. and Jeffrey B. Sidney. </author> <title> Sequencing with Series-Parallel Precedence Constraints. </title> <journal> Mathematics of Operations Research (August 1979) vol. </journal> <volume> 4, no. 3, </volume> <pages> pp. 215-224. </pages>
Reference-contexts: Garey considers the problem of sequencing with precedence constraints [Garey73]. He shows that a series of interchange rules may be applied that allow task pairs to be merged or the precedence constraints to be relaxed. His rules are sufficient to provide optimal schedules for opposing forests. In <ref> [Monma79] </ref> two interchange rules are proposed that allow global improvement in the cost function. These rules are known as the adjacent sequence interchange rule (ASI) and the series 93 network decomposition (SND) rule. They make it possible to find optimal schedules for parallel-chains and for generalized series-parallel precedence constraints. <p> He also provided four rules for sequencing tasks with general precedence constraints: ASI, SND, consistency and monotonicity. These rules generalize the work of <ref> [Monma79] </ref> and also provide an optimal solution to the 2-machine flow shop problem where the objective is to minimize maximum flow time. Several other applications are mentioned in [Sidney81]. The work in [Monma87] recasts the algorithms of [Monma79] to handle job modules. <p> These rules generalize the work of <ref> [Monma79] </ref> and also provide an optimal solution to the 2-machine flow shop problem where the objective is to minimize maximum flow time. Several other applications are mentioned in [Sidney81]. The work in [Monma87] recasts the algorithms of [Monma79] to handle job modules. Any directed graph that is not generalized series-parallel is a job module; job modules can be composed using the rules for generalized series-parallel graphs. The job modules of a graph can be found in O (n 2 ) time.
Reference: [Monma87] <author> Monma, Clyde L. and Jeffrey B. Sidney. </author> <title> Optimal sequencing Via Modular Decomposition: Characterization of Sequencing Functions. </title> <journal> Mathematics of Operations Research (February 1987) vol. </journal> <volume> 12, no. 1, </volume> <pages> pp. 22-31. </pages>
Reference-contexts: These rules generalize the work of [Monma79] and also provide an optimal solution to the 2-machine flow shop problem where the objective is to minimize maximum flow time. Several other applications are mentioned in [Sidney81]. The work in <ref> [Monma87] </ref> recasts the algorithms of [Monma79] to handle job modules. Any directed graph that is not generalized series-parallel is a job module; job modules can be composed using the rules for generalized series-parallel graphs. The job modules of a graph can be found in O (n 2 ) time.
Reference: [Moore68] <author> Moore, J. M. </author> <title> An n Job, One Machine Sequencing Algorithm for Minimizing the Number of Late Jobs. </title> <booktitle> Management Science (1968) vol. </booktitle> <volume> 15, </volume> <pages> pp. 102-109. 104 </pages>
Reference-contexts: To produce such a schedule, note that an OR task together with one predecessor subtree consisting of k i AND tasks may be thought of as one large task with processing time k i + 1. Then the algorithm of <ref> [Moore68] </ref>, which minimizes unit penalty on a single processor, may be used to schedule tasks with processing time (k i + 1), to maximize the number of OR tasks that meet their deadline. <p> Deadline Location General Graph In-Tree Simple Inforest 1 deadline O (n) deadlines On all tasks NP-C (Theorem 3.1) NP-C (Theorem 3.6) NP-C (Theorem 3.7) On OR tasks only NP-C (Theorem 3.1) NP-C (Theorem 3.6) <ref> [Moore68] </ref> Algorithm (b) Scheduling to minimize completion time on m processors. Task Processing Time General Graph In-Tree Identical NP-C [Lawler89] NP-C (Theorem 3.8) Arbitrary No Algorithm Path-Balancing Algorithm 3.2.2. Scheduling to Minimize Completion Time Table 3.2 also gives the complexity of scheduling m processors to minimize completion time. Theorem 3.8.
Reference: [Muntz89] <author> Muntz, Alice H. and Ellis Horowitz. </author> <title> A Framework for Specification and Design of Software for Advanced Sensor Systems. </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium (December 1989) vol. </booktitle> <volume> 10, </volume> <pages> pp. 204-213. </pages>
Reference-contexts: Another system being designed at Hughes Aircraft uses OR tasks to represent mutually exclusive functions both in the control flow of an individual task and also at a higher level, among disparate tasks in the computer system <ref> [Muntz89] </ref>. It will become evident later that the algorithms developed in this thesis can be used in a CAD system for real-time system design.
Reference: [Muraoka71] <author> Muraoka, Y. </author> <title> Parallelism Exposure and Exploitation in Programs. </title> <institution> University of Illinois Department of Computer Science Report No. </institution> <month> UIUCDCS-R-71-424 </month> <year> (1971). </year>
Reference-contexts: Scheduling to Minimize Completion Time A widely studied problem is that of scheduling unitexecution-time tasks with precedence constraints to minimize completion time on two processors. Many algorithms have been proposed to solve this problem [Fuji69] <ref> [Muraoka71] </ref> [Coffman72] [Garey77]. When a third processor is present, the complexity of the problem is unknown and has remained one of the most famous open problems in complexity theory [Garey79]. For an arbitrary number of processors, three heuristics have been analyzed.
Reference: [Nilsson80] <author> Nilsson, Nils J. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <address> Palo Alto, California: </address> <publisher> Tioga Publishing Company (1980). </publisher>
Reference-contexts: Many artificial intelligence problems can be formulated as heirarchies of subproblems where some problems may be solved in one of many ways <ref> [Nilsson80] </ref>. A computation to solve such a problem can often be modeled as an AND/OR/skipped tree. In the tree, an AND task would represent a problem comprising many subproblems, and an OR task would represent a problem that reduces to one of many subproblems.
Reference: [Ramamritham84] <author> Ramamritham, K. and J. Stankovic. </author> <title> Dynamic Task Scheduling in Distributed Hard Real-Time Systems. </title> <journal> IEEE Software (July 1984) vol. </journal> <volume> 1, no. </volume> <pages> 3. </pages>
Reference-contexts: In several simulation studies greedy scheduling has been found to be effective in scheduling a random task system [Biyabani88] <ref> [Ramamritham84] </ref>. We believe that this conclusion may have been reached because the aspect ratio was not a controlled variable in the simulation. As the theorem above shows, a simulation should generate task systems with a = 1 to ensure that the worst-case workloads are tested.
Reference: [Reingold77] <author> Reingold, E. M., Nievergelt, J. and N. Deo. </author> <title> Combinatorial Algorithms. </title> <address> Englewood Cliffs, New Jersey: </address> <publisher> Prentice-Hall (1977). </publisher>
Reference: [Roy59] <editor> Roy, B. Transitivite et Connexite. Compt. Rend. </editor> <volume> (1959) vol. 249, </volume> <pages> pp. 216-218. </pages>
Reference-contexts: Path Problems on Directed Graphs One of the critical algorithms used in this thesis is the algorithm to compute the transitive closure of an AND/OR graph. This algorithm is based on the algorithm of Roy and Warshall <ref> [Roy59] </ref> [Warshall62] to compute transitive closure; hereafter it will be referred to as Warshall's algorithm. Since the publication of that algorithm, many subsequent algorithms have been 94 proposed and the dynamic programming approach in the algorithm has been greatly extended.
Reference: [Sefika91] <author> Sefika, Mohlalefi. </author> <title> Path-Balancing Algorithm for In-Trees: Implementation Document. </title> <note> manuscript (December 1991). </note>
Reference-contexts: Most of the work is done when returning from procedure calls. Hence, the overall complexity of this algorithm is O (n 2 ). This algorithm has been implemented; a description of the implementation appears in <ref> [Sefika91] </ref>. 43 Input: Threshold graph G = (T, A, P, P) that is an in-tree. Output: A schedule of an AND-only graph G' = (T' , A', P' ). 1.
Reference: [Sidney81] <author> Sidney, Jeffrey B. </author> <title> A Decomposition Algorithm for Sequencing with General Precedence Constraints. </title> <journal> Mathematics of Operations Research (1981) vol. </journal> <volume> 6, no. 2, </volume> <pages> pp. 190-205. </pages>
Reference-contexts: They make it possible to find optimal schedules for parallel-chains and for generalized series-parallel precedence constraints. Two years later Sidney extended some classical work by Smith that characterizes the set of sequencing problems that can be solved optimally by repeated pairwise interchange of the tasks in a schedule <ref> [Sidney81] </ref>. He also provided four rules for sequencing tasks with general precedence constraints: ASI, SND, consistency and monotonicity. These rules generalize the work of [Monma79] and also provide an optimal solution to the 2-machine flow shop problem where the objective is to minimize maximum flow time. <p> These rules generalize the work of [Monma79] and also provide an optimal solution to the 2-machine flow shop problem where the objective is to minimize maximum flow time. Several other applications are mentioned in <ref> [Sidney81] </ref>. The work in [Monma87] recasts the algorithms of [Monma79] to handle job modules. Any directed graph that is not generalized series-parallel is a job module; job modules can be composed using the rules for generalized series-parallel graphs.
Reference: [Simons83] <author> Simons, Barbara. </author> <title> Multiprocessor Scheduling of Unit-Time Jobs with Arbitrary Release Times and Deadlines. </title> <journal> SIAM Journal on Computing (May 1983) vol. </journal> <volume> 12, no. 2, </volume> <pages> pp. 294-299. </pages>
Reference-contexts: When there are several processors McNaughton's algorithm can be used to meet multiple deadlines. If preemption is not allowed then the problem is NP-complete, even for a single deadline, but if all the tasks have identical execution times (UET tasks) then the algorithm of <ref> [Simons83] </ref> can be used to meet integer release times and deadlines.
Reference: [Shih91] <author> Shih, W.K., Liu, J. W.-S. and J.-Y. Chung. </author> <title> Algorithms for Scheduling Imprecise Computations with timing constraints. </title> <journal> SIAM Journal on Computing (1991) vol. </journal> <volume> 20, no. 3, </volume> <pages> pp. 537-552. </pages>
Reference-contexts: The AND/OR/skipped task model can represent the portions of tasks or portions of the task system that may be skipped. In the early models of imprecise computation [Chung89] [Chung90] <ref> [Shih91] </ref>, it was assumed that the precision of an imprecise task was linearly increasing and continuous. The AND/OR/skipped task model can represent applications where the precision increases in discrete steps, and this is presumably more common in real-world applications. Fault-tolerant applications may also benefit from AND/OR scheduling [Thumbidurai89] [McElvany88].
Reference: [Syslo75] <author> Syslo, M. M. and J. Dzikiewicz. </author> <title> Computational Experiences with Some Transitive Closure Algorithms. </title> <booktitle> Computing (1975) vol. </booktitle> <volume> 15, </volume> <pages> pp. 33-39. </pages>
Reference-contexts: There have been at least 65 papers that build on this work of Warshall; here we only highlight a few of the most relevant papers found. Syslo and Dzikiewicz <ref> [Syslo75] </ref> studied the execution time of 5 transitive closure algorithms, including Floyd's algorithm, Purdom's algorithm, Syslow's algorithm, Dzikiewicz's algorithm, and Warshall's algorithm. Warshall's algorithm was broken into two steps: (Step 1) pack the adjacency matrix, and (Step 2) compute a bit-mapped transitive closure.
Reference: [Tarjan81] <author> Tarjan, Robert Endre. </author> <title> A Unified Approach to Path Problems. </title> <journal> Journal of the ACM (July 1981) vol. </journal> <volume> 28, no. 3, </volume> <pages> pp. 577-593. </pages>
Reference-contexts: In [Lehmann77] Warshall's algorithm is generalized over closed semi-rings, with slightly weaker assumptions and simpler proofs than [Aho74]. Many interesting operations-research applications are contained therein. Tarjan <ref> [Tarjan81] </ref> presents a different 95 approach where Warshall's algorithm is generalized to solve path problems over an algebra of regular expressions. This work contains many interesting applications in the area of dataflow analysis of computer programs. The work [Gallo86] surveys many previous algorithms to solve minimum path problems on digraphs.
Reference: [Thambidurai89] <author> Thambidurai, Phillip and Kishor S. Trevidi. </author> <title> Transient Overloads in Fault-Tolerant Real-Time Systems. </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium (December 1989) vol. </booktitle> <volume> 10, </volume> <pages> pp. 126-133. </pages>
Reference: [Valdes78] <author> Valdes, Jacobo. </author> <title> Parsing Flowcharts and Series-Parallel Graphs. </title> <institution> Computer Science Department Technical Report #STAN-CS-78-682, Stanford University, Stanford California (December 1978). </institution>
Reference-contexts: The generalized series-parallel graph decomposition can be computed in linear time <ref> [Valdes78] </ref> [Valdes79]. Lemma 4.13 is applied at most n times and it takes O (1) time to compute the costs for this lemma. Lemmas 4.14 and 4.15 are together applied exactly n 1 times and they each require O (n) time to update the cost vectors.
Reference: [Valdes79] <author> Valdes, Jacobo, Robert E. Tarjan and Eugene L. Lawler. </author> <title> The Recognition of Series Parallel Digraphs. </title> <booktitle> Proceedings of the 11th Annual ACM Symposium on Theory of Computing (1979) pp. </booktitle> <pages> 1-12. </pages>
Reference-contexts: The generalized series-parallel graph decomposition can be computed in linear time [Valdes78] <ref> [Valdes79] </ref>. Lemma 4.13 is applied at most n times and it takes O (1) time to compute the costs for this lemma. Lemmas 4.14 and 4.15 are together applied exactly n 1 times and they each require O (n) time to update the cost vectors.
Reference: [Wang92] <author> Wang, Qingzhou and Kam Hoi Cheng. </author> <title> A Heuristic of Scheduling Parallel Tasks and its Analysis. </title> <journal> SIAM Journal on Computing (1992) vol. </journal> <volume> 21, no. 2, </volume> <pages> pp. 281-294. 105 </pages>
Reference-contexts: Thus, the techniques developed for this thesis can be applied to other settings when the scheduler must choose from many different kinds of task systems. When the task system contains precedence constraints and parallelizable jobs there is a surprisingly good algorithm to minimize completion time <ref> [Wang92] </ref>. The algorithm assumes linear speedup and it dynamically chooses the task parallelism as it executes tasks. It provides a performance guarantee of 3 2/ m.
Reference: [Warren75] <author> Warren, Henry S. </author> <title> A Modification of Warshall's Algorithm for the Transitive Closure of Binary Relations. </title> <journal> Communications of the ACM (1975) vol. </journal> <volume> 18, no. 4, </volume> <pages> pp. 218-220. </pages>
Reference-contexts: The advantage of Warshall's algorithm became very pronounced as the number of vertices increased beyond 50. Furthermore, Warshall's algorithm is very memory-efficient, especially if the matrix does not need to be unpacked. Warren described a modification of Warshall's algorithm to optimize it for a paging environment <ref> [Warren75] </ref>. Warshall's algorithm scans a boolean matrix by columns in order to use boolean OR operations on the rows of the matrix. Warren's algorithm scans by rows and uses boolean OR operations on the rows. Whereas Warshall's algorithm has one main scan, Warren's algorithm has two.
Reference: [Warshall62] <author> Warshall, Stephen. </author> <title> A Theorem on Boolean Matrics. </title> <journal> Journal of the ACM (1962) vol. </journal> <volume> 9, </volume> <pages> pp. 11-12. </pages>
Reference-contexts: The work in this thesis also has some application to compiler design. One of the early motivations for the study of graph algorithms was to find ways to perform dataflow transformations on program dependency graphs <ref> [Warshall62] </ref>. Dataflow transformations include loop transformations, constant propagation, strength reduction, cache prefetching, strip mining, et cetera. In a program dependency graph there is a vertex for every statement or action in a computer program and the vertex has a weight representing the statement execution time. <p> Path Problems on Directed Graphs One of the critical algorithms used in this thesis is the algorithm to compute the transitive closure of an AND/OR graph. This algorithm is based on the algorithm of Roy and Warshall [Roy59] <ref> [Warshall62] </ref> to compute transitive closure; hereafter it will be referred to as Warshall's algorithm. Since the publication of that algorithm, many subsequent algorithms have been 94 proposed and the dynamic programming approach in the algorithm has been greatly extended.

References-found: 64

