URL: ftp://ftp.cs.washington.edu/homes/chambers/mmtc-body.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/mmtc.html
Root-URL: 
Email: chambers@cs.washington.edu  
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: Typechecking and Modules for Multi-Methods  
Author: Craig Chambers 
Address: 309 Sieg Hall, FR-35  Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering  University of Washington  
Abstract: Two major obstacles hindering the wider acceptance of multi-methods are concerns over the lack of encapsulation and modularity and the absence of static typechecking in existing multi-method-based languages. This paper * addresses both of these problems. We present a polynomial-time static typechecking algorithm that checks the conformance, completeness, and consistency of a group of method implementations with respect to declared message signatures. This algorithm improves on previous algorithms by handling separate type and inheritance hierarchies, abstract classes, and graph-based method lookup semantics. We also present a module system that enables independently-developed code to be fully encapsulated and statically typechecked on a per-module basis. To guarantee that potential conicts between independently-developed modules have been resolved, a simple well-formedness condition on the modules comprising a program is checked at link-time. The typechecking algorithm and module system are applicable to a range of multi-method-based languages, but the paper uses the Cecil language as a concrete example of how they can be applied. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada 83] <institution> Reference Manual for the Ada Programming Language, ANSI/MIL-STD 1815A, </institution> <year> 1983. </year>
Reference-contexts: 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada <ref> [Ada 83, Barnes 91] </ref>, and Haskell [Hudak et al. 92].
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: Section 5 introduces our module mechanism and discusses its impact on the typechecking algorithm. Section 6 offers our conclusions. 2 Related Work 2.1 Type Checking Agrawal, DeMichiel, and Lindsay present a polynomial-time algorithm for typechecking Polyglot, a CLOS-like database type system <ref> [Agrawal et al. 91] </ref>. Their algorithm divides the typechecking problem into two components: checking that the collection of multi-methods comprising a generic function is consistent, and checking that calls of generic functions are type-correct. <p> Various sources have described efficient data structures and c t c c c 18 Typechecking and Modules for Multi-Methods Chambers & Leavens algorithms for testing subtyping in a lattice and for testing whether there exists a common descendant of two members of a partial order <ref> [e.g. Caseau 93, Agrawal et al. 91] </ref>.) Prior to typechecking, we precompute for each class the partial order of its concrete subclasses. With this set-up, the worst-case time complexity of computing top-concrete-conforming-subclasses (c, t) is O (C concrete ).
Reference: [America 87] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <booktitle> In ECOOP 87 Conference Proceedings, </booktitle> <pages> pp. 234-242, </pages> <address> Paris, France, </address> <month> June, </month> <year> 1987. </year> <note> Published as Lecture Notes in Computer Science 276, Springer-Verlag, Berlin, </note> <year> 1987. </year>
Reference-contexts: Keeping inheritance and subtyping separate allows for more exible and extensible organizations of code, and some more recent languages including Cecil, POOL <ref> [America 87, America & van der Linden 90] </ref>, and Strongtalk [Bracha & Griswold 93] do in fact separate the two relations.
Reference: [America & van der Linden 90] <author> Pierre America and Frank van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 161-168, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Keeping inheritance and subtyping separate allows for more exible and extensible organizations of code, and some more recent languages including Cecil, POOL <ref> [America 87, America & van der Linden 90] </ref>, and Strongtalk [Bracha & Griswold 93] do in fact separate the two relations.
Reference: [Amiel et al. 94] <author> Eric Amiel, Olivier Gruber, and Eric Simon. </author> <title> Optimizing Multi-Method Dispatch Using Compressed Dispatch Tables. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <address> Portland, OR, </address> <month> October, </month> <year> 1994. </year>
Reference-contexts: This semantics considers ambiguously-defined multi-methods to be a programming error, unlike the CLOS semantics which attempts to resolve such ambiguities automatically. Multi-methods might be slower to select and invoke than singly-dispatched methods. Work is progressing on this front, however <ref> [Chen & Turau 94, Amiel et al. 94] </ref>, and we expect that the run-time 3 Typechecking and Modules for Multi-Methods Chambers & Leavens performance difference between singly and multiply-dispatched systems to become negligible in the near future. Multi-methods are seen to prevent object encapsulation.
Reference: [Barnes 91] <author> J. G. P. Barnes. </author> <title> Programming in Ada (third edition). </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1991. </year>
Reference-contexts: 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada <ref> [Ada 83, Barnes 91] </ref>, and Haskell [Hudak et al. 92].
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 215-230, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference-contexts: Keeping inheritance and subtyping separate allows for more exible and extensible organizations of code, and some more recent languages including Cecil, POOL [America 87, America & van der Linden 90], and Strongtalk <ref> [Bracha & Griswold 93] </ref> do in fact separate the two relations. Our algorithm allows the type partial order to be specified independently of the code inheritance graph, and the set of legal messages (described by signatures) can be defined independently of the set of multi-method implementations.
Reference: [Bruce et al. 93] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and Decidable Type Checking in an Object-Oriented Language. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 29-46, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference-contexts: It seems that the combination of allowing inheritance without subtyping and avoiding retypechecking of inherited methods in subclasses leads to a type system with these properties, whether or not multi-methods are present. For example, the TOOPLE singly-dispatched language places restrictions on inheritance to avoid conformance errors <ref> [Bruce et al. 93] </ref>. TOOPLE includes a ClassType that represents the interface to self within a method; subclasses are required to preserve this interface.
Reference: [Bruce et al. 95] <author> Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On Binary Methods. </title> <type> Technical report #95-08, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> May, </month> <year> 1995. </year>
Reference: [Canning et al. 89] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for Strongly-Typed Object-Oriented Programming. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 457-467, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: Our module design also supports these degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86], and Eiffel supports public and protected levels of visibility [Meyer 88, Meyer 92]. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk <ref> [Canning et al. 89] </ref>. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues.
Reference: [Cardelli 88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <booktitle> Information and Computation 76(2/3), </booktitle> <pages> pp. 138-164, </pages> <address> February/March, </address> <year> 1988. </year>
Reference-contexts: This pair of checks is the standard contravariant rule for subtyping of functions <ref> [Cardelli 88, Cardelli & Wegner 85] </ref>, restricted to unspecialized formals. c 15 Typechecking and Modules for Multi-Methods Chambers & Leavens The final conformance check tests constrained formals.
Reference: [Cardelli & Wegner 85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys 17(4), </journal> <pages> pp. 471-522, </pages> <month> December, </month> <year> 1985. </year> <title> 30 Typechecking and Modules for Multi-Methods Chambers & Leavens </title>
Reference-contexts: This pair of checks is the standard contravariant rule for subtyping of functions <ref> [Cardelli 88, Cardelli & Wegner 85] </ref>, restricted to unspecialized formals. c 15 Typechecking and Modules for Multi-Methods Chambers & Leavens The final conformance check tests constrained formals.
Reference: [Cardelli & Mitchell 89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on Records. </title> <booktitle> In Proceedings of the International Conference on the Mathematical Foundation of Programming Semantics, </booktitle> <address> New Orleans, LA, </address> <year> 1989. </year>
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 182-192, </pages> <address> San Francisco, </address> <month> June, </month> <year> 1992. </year> <note> Published as Lisp Pointers 5(1), January-March, </note> <year> 1992. </year>
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil <ref> [Chambers 92, Chambers 93] </ref> is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et <p> This problem was addressed in an earlier paper that described a programming methodology, language design, and programming environment for multi-methods that attempts to preserve much of the avor of object-centered programming <ref> [Chambers 92] </ref>. The semantics of multi-method lookup is considered to be very complicated. This problem also was addressed in the earlier paper, where a simple lookup semantics was presented which was based on deriving the partial ordering over methods from the partial ordering over their specializers. <p> In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program. An earlier approach to encapsulation in Cecil suffered from the problem that privileged access could always be gained by writing methods that specialized on the desired data structures <ref> [Chambers 92] </ref>. We have developed a module system for Cecil that addresses these shortcomings of existing multi-method languages. This system can restrict access to parts of an implementation to a statically-determined region of program text while preserving the exibility of multi-methods.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil <ref> [Chambers 92, Chambers 93] </ref> is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Portland, OR, </address> <month> October, </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), </note> <month> October, </month> <year> 1994. </year>
Reference-contexts: This simpler version of ComputeIsConforming would require only O (M (S+|T|)) time overall <ref> [Chambers & Leavens 94] </ref>. 4.5 Checking Completeness To check the completeness of a set of method implementations with respect to a signature, we first compute the set of concrete class vectors that are the tops of those cones that conform to the argument types of the signature, i.e., the set of <p> In fact, earlier versions of this work did exactly that <ref> [Chambers & Leavens 94] </ref>. 23 Typechecking and Modules for Multi-Methods Chambers & Leavens Our programming language model also distinguishes abstract and concrete classes.
Reference: [Chambers & Leavens 95] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <type> Technical report #95-08-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> August, </month> <year> 1995, </year> <type> and technical report #95-19, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> June, </month> <year> 1995. </year>
Reference-contexts: Hence the original assumption must be false and the theorem must hold. (A formal, symbolic proof for this and all other theorems is contained in a separate technical report <ref> [Chambers & Leavens 95] </ref>.) The next three subsections present algorithms that implement each part of the problem breakdown efficiently. 4.4 Checking Conformance To check conformance, our algorithm considers each method in the program in turn.
Reference: [Chen & Turau 94] <author> Weimin Chen and Volker Turau. </author> <title> Efficient Dynamic Look-Up Strategy for Multi-Methods. </title> <booktitle> In ECOOP 94 Conference Proceedings, </booktitle> <address> Bologna, Italy, </address> <month> July, </month> <year> 1994. </year>
Reference-contexts: This semantics considers ambiguously-defined multi-methods to be a programming error, unlike the CLOS semantics which attempts to resolve such ambiguities automatically. Multi-methods might be slower to select and invoke than singly-dispatched methods. Work is progressing on this front, however <ref> [Chen & Turau 94, Amiel et al. 94] </ref>, and we expect that the run-time 3 Typechecking and Modules for Multi-Methods Chambers & Leavens performance difference between singly and multiply-dispatched systems to become negligible in the near future. Multi-methods are seen to prevent object encapsulation.
Reference: [Cook et al. 90] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Inheritance and subtyping are synonymous in Polyglot. While many common object-oriented languages link code inheritance with subtyping, many researchers have noted that conceptually the two relations are different (e.g., <ref> [Snyder 86, Cook et al. 90, Leavens & Weihl 90] </ref>). Subclassing refers to an implementation strategy, where a subclass inherits some of its implementation from its superclasses. Subtyping, on the other hand, refers to a relationship between the interfaces of two types.
Reference: [Cook 90] <author> William Cook. </author> <title> Object-Oriented Programming versus Abstract Data Types. </title> <booktitle> In Proceedings of the Workshop on the Foundations of Object-Oriented Languages, </booktitle> <pages> pp. 151-178, </pages> <address> Noordwijkerhout, the Netherlands, May/June, </address> <year> 1990. </year> <note> Published as Lecture Notes in Computer Science 489, </note> <editor> Springer-Verlag, </editor> <address> New York, </address> <year> 1991. </year>
Reference-contexts: We believe that these two contributions are important steps towards modular development of robust software in multi-method-based languages. In particular, the combination of typechecking, modules, and multi-methods allows programmers to integrate the advantages of both abstract data types and object-oriented programming <ref> [Cook 90] </ref>. One can simulate the ADT mechanisms of languages like CLU and Ada by hiding the data representation in a module.
Reference: [Cook 92] <author> William R. Cook. </author> <title> Interfaces and Specifications for the Smalltalk-80 Collection Classes. </title> <booktitle> In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October </month> <year> 1992. </year>
Reference: [Ghelli 91] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 129-145, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk <ref> [Goldberg & Robson 83] </ref> and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et al. 92].
Reference: [Goguen 84] <author> Joseph A. Goguen. </author> <title> Parameterized Programming. </title> <journal> IEEE Transactions on Software Engineering 10(5), </journal> <pages> pp. 528-543, </pages> <month> September, </month> <year> 1984. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML [Milner et al. 90, Paulson 91] and in the equational specification language OBJ2 <ref> [Goguen 84] </ref>. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information. Both SML and OBJ2 have ways of importing modules that allow for sophisticated kinds of renaming.
Reference: [Harrison & Ossher 93] <author> William Harrison and Harold Ossher. </author> <title> Subject-Oriented Programming (A Critique of Pure Objects). </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 411-428, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference-contexts: Using the sending scope to determine the set of potentially callable methods allows a module to extend and customize imported types and representations without affecting unrelated modules or requiring changes to the source code of imported modules <ref> [Hlzle 93, Harrison & Ossher 93] </ref>. For example, a text-processing module can add tab-expansion behavior to string data structures without polluting the general interface to strings as seen by unrelated modules.
Reference: [Hlzle 93] <author> Urs Hlzle. </author> <title> Integrating Independently-Developed Components in Object-Oriented Languages. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <pages> pp. 36-56, </pages> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science 707, Springer-Verlag, Berlin, </note> <year> 1993. </year>
Reference-contexts: Using the sending scope to determine the set of potentially callable methods allows a module to extend and customize imported types and representations without affecting unrelated modules or requiring changes to the source code of imported modules <ref> [Hlzle 93, Harrison & Ossher 93] </ref>. For example, a text-processing module can add tab-expansion behavior to string data structures without polluting the general interface to strings as seen by unrelated modules.
Reference: [Hudak et al. 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzmn, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the Programming Language Haskell: A Non-strict, Purely Functional Language, Version 1.2. </title> <booktitle> In SIGPLAN Notices 27(5), </booktitle> <month> May, </month> <year> 1992. </year>
Reference-contexts: Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell <ref> [Hudak et al. 92] </ref>.
Reference: [Leavens 91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <booktitle> IEEE Software 8(4), </booktitle> <pages> pp. 72-80, </pages> <month> July, </month> <year> 1991. </year>
Reference-contexts: This split between checking clients against explicitly imported interfaces and checking extensions of the interface resembles the modularity obtained by the use of legal subtyping in the verification of object-oriented languages with subtyping <ref> [Leavens & Weihl 90, Leavens 91] </ref>. To provide more control over the interface seen by extension modules, declarations in a module may be tagged protected.
Reference: [Leavens & Weihl 90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 212-223, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Inheritance and subtyping are synonymous in Polyglot. While many common object-oriented languages link code inheritance with subtyping, many researchers have noted that conceptually the two relations are different (e.g., <ref> [Snyder 86, Cook et al. 90, Leavens & Weihl 90] </ref>). Subclassing refers to an implementation strategy, where a subclass inherits some of its implementation from its superclasses. Subtyping, on the other hand, refers to a relationship between the interfaces of two types. <p> This split between checking clients against explicitly imported interfaces and checking extensions of the interface resembles the modularity obtained by the use of legal subtyping in the verification of object-oriented languages with subtyping <ref> [Leavens & Weihl 90, Leavens 91] </ref>. To provide more control over the interface seen by extension modules, declarations in a module may be tagged protected.
Reference: [Liskov et al. 77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and J. Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <journal> Communications of the ACM 20(8), </journal> <pages> pp. 564-576, </pages> <month> August, </month> <year> 1977. </year>
Reference-contexts: To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated [Parnas71, Parnas72, Liskov & Zilles 74]. But previous multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> or singly-dispatched object-oriented languages such as C++ and even Smalltalk. In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program.
Reference: [Liskov et al. 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 114, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1981. </year>
Reference-contexts: To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated [Parnas71, Parnas72, Liskov & Zilles 74]. But previous multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> or singly-dispatched object-oriented languages such as C++ and even Smalltalk. In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program.
Reference: [Liskov & Zilles 74] <author> Barbara H. Liskov and Stephen N. Zilles. </author> <title> Programming with Abstract Data Types. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Very High Level Languages, </booktitle> <pages> pp. 50-59, </pages> <month> April, </month> <year> 1974. </year> <note> Published as SIGPLAN Notices 9(4), </note> <year> 1974. </year> <title> 31 Typechecking and Modules for Multi-Methods Chambers & Leavens </title>
Reference-contexts: Encapsulation and modularity of multi-methods is a related problem. To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated <ref> [Parnas71, Parnas72, Liskov & Zilles 74] </ref>. But previous multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU [Liskov et al. 77, Liskov et al. 81] or singly-dispatched object-oriented languages such as C++ and even Smalltalk.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1998. </year>
Reference-contexts: Our module design also supports these degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86], and Eiffel supports public and protected levels of visibility <ref> [Meyer 88, Meyer 92] </ref>. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89]. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Our module design also supports these degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86], and Eiffel supports public and protected levels of visibility <ref> [Meyer 88, Meyer 92] </ref>. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89]. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML <ref> [Milner et al. 90, Paulson 91] </ref> and in the equational specification language OBJ2 [Goguen 84]. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information.
Reference: [Mssenbck & Wirth 91] <author> H. Mssenbck and Niklaus Wirth. </author> <booktitle> The Programming Language Oberon-2. Structured Programming 12(4), </booktitle> <year> 1991. </year>
Reference-contexts: A few other object-oriented languages include some form of separate module system, including Modular Smalltalk [Wirfs-Brock & Wilkerson 88], Modula-3 [Nelson 91], and Oberon-2 <ref> [Mssenbck & Wirth 91] </ref>. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <note> Also appears in ECOOP 91 Conference Proceedings, </note> <institution> Geneva, Switzerland, </institution> <month> July, </month> <year> 1991. </year>
Reference-contexts: As a result, our algorithm includes the standard contravariant method typechecking rules of singly-dispatched languages as a special case. Kea is a higher-order polymorphic functional language supporting multi-methods <ref> [Mugridge et al. 91] </ref>. Like Polyglot, code inheritance and subtyping in Kea are unified. Keas type checking includes the notion that a collection of multi-methods must be exhaustive and unambiguous, and these notions appear in our type system as well.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: In contrast, encapsulation 5 Typechecking and Modules for Multi-Methods Chambers & Leavens can be enforced in our module system and our module system cooperates with our static typechecking algorithm. A few other object-oriented languages include some form of separate module system, including Modular Smalltalk [Wirfs-Brock & Wilkerson 88], Modula-3 <ref> [Nelson 91] </ref>, and Oberon-2 [Mssenbck & Wirth 91]. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Paepcke 93] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in
Reference: [Palsberg & Schwartzbach 94] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference: [Parnas 71] <author> D. L. Parnas. </author> <title> Information Distribution Aspects of Design Methodology. </title> <booktitle> Proceedings of IFIP Congress 71. IFIP, </booktitle> <year> 1971. </year>
Reference: [Parnas 72] <author> D. L. Parnas. </author> <title> On the Criteria to be Used in Decomposing Systems into Modules. </title> <journal> Communications of the ACM 15(5), </journal> <pages> pp. 330-336, </pages> <month> May, </month> <year> 1972. </year>
Reference: [Paulson 91] <author> Laurence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML <ref> [Milner et al. 90, Paulson 91] </ref> and in the equational specification language OBJ2 [Goguen 84]. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information.
Reference: [Pierce & Turner 92] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically Typed Multi-Methods via Partially Abstract Types. </title> <type> Unpublished manuscript, </type> <month> October, </month> <year> 1992. </year>
Reference: [Reynolds 80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones (ed.), </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, </booktitle> <pages> pp. 211-258, </pages> <address> Aarhus, Denmark, </address> <month> January, </month> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 94, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1980. </year>
Reference-contexts: Because of this constraint on implementations, clients can safely assume that the result of a message will be a subtype of the declared result types of all matching signatures. One might expect more specific signatures to narrow result types in a covariant fashion <ref> [Reynolds 80] </ref>, but by using the g.l.b. operation our model does not need to impose any such restrictions. Other client-side checks are straightforward and language-dependent, and we do not discuss them further here.
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Because of C++s friend mechanism, one can write software that has privileged access to more than one type of data while still textually limiting private access. Our module design also supports these degrees of visibility. Trellis supports these notions except for friends <ref> [Schaffert et al. 86] </ref>, and Eiffel supports public and protected levels of visibility [Meyer 88, Meyer 92]. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89].
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 38-45, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: However, their algorithm depends on a number of restrictive assumptions about the language they typecheck: The multi-methods within a generic function must be totally ordered in terms of specificity. Graph-based method lookup semantics found in most object-oriented languages with multiple inheritance <ref> [Snyder 86] </ref>, where the method overriding relationship only forms a partial order, cannot be handled. Our algorithm supports such partially ordered method hierarchies while still detecting whether any ambiguously-defined messages are sent. <p> Inheritance and subtyping are synonymous in Polyglot. While many common object-oriented languages link code inheritance with subtyping, many researchers have noted that conceptually the two relations are different (e.g., <ref> [Snyder 86, Cook et al. 90, Leavens & Weihl 90] </ref>). Subclassing refers to an implementation strategy, where a subclass inherits some of its implementation from its superclasses. Subtyping, on the other hand, refers to a relationship between the interfaces of two types.
Reference: [Steele 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language (second edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in <p> on type systems for object-oriented programming (e.g., [Cardelli & Wegner 85, Cardelli & Mitchell 89, Bruce et al. 93, Palsberg & Schwartzbach 94]) only deals with singly-dispatched languages. 2.2 Module Systems The only module system for a multi-method-based language of which we are aware is the Common Lisp package system <ref> [Steele 90] </ref>. This system provides name space management, allowing symbols to be clustered into packages and allowing some symbols to be private to a package. In Common Lisp, encapsulation is only advisory, and users may always circumvent the encapsulation of a symbol s in a package p by writing p::s.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ <ref> [Stroustrup 91] </ref> or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et al. 92].
Reference: [Szyperski 92] <author> Clemens A. Szyperski. </author> <title> Import is Not Inheritance - Why We Need Both: Modules and Classes. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 19-32, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: Like Common Lisp and Oberon-2, we do not tie the module notion to the notion of classes or types <ref> [Szyperski 92] </ref>. A program is a sequence of one or more modules, one of which is called Main. Each module contains a group of declarations; there is no code that appears outside of a module, and for simplicity modules do not nest.
Reference: [Touretzky 86] <author> D. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: We say that a vector of classes inherits a method m when inh specializers (m). Because vectors of classes are ordered pointwise, with no priority assigned to the position of the vector element, the specializers of a method are equally important in determining the methods overriding relationships <ref> [Touretzky 86] </ref>. This matches Cecils semantics, but may not match other languages. For example, CLOS prioritizes argument positions with earlier argument orderings completely dominating later argument orderings.
Reference: [Wirfs-Brock & Wilkerson 88] <author> Allen Wirfs-Brock and Brian Wilkerson. </author> <title> An Overview of Modular Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 123-134, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: In contrast, encapsulation 5 Typechecking and Modules for Multi-Methods Chambers & Leavens can be enforced in our module system and our module system cooperates with our static typechecking algorithm. A few other object-oriented languages include some form of separate module system, including Modular Smalltalk <ref> [Wirfs-Brock & Wilkerson 88] </ref>, Modula-3 [Nelson 91], and Oberon-2 [Mssenbck & Wirth 91]. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Wirth 88] <author> Niklaus Wirth. </author> <title> Programming in Modula-2 (fourth edition). </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: In this paper we present our module system informally. We defer a more formal treatment of modules and multi-methods to a future paper. 5.1 Module Basics The core of our module system provides standard name space management, as in Modula-2 <ref> [Wirth 88] </ref>. Like Common Lisp and Oberon-2, we do not tie the module notion to the notion of classes or types [Szyperski 92]. A program is a sequence of one or more modules, one of which is called Main.
References-found: 56

