URL: http://www.cs.indiana.edu/l/www/pub/liu/TimeAnal-TR98.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/liu/
Root-URL: http://www.cs.indiana.edu
Title: Automatic Accurate Time-Bound Analysis for High-Level Languages  
Author: Yanhong A. Liu and Gustavo Gomez 
Date: April 1998  
Abstract: This paper describes a general approach for automatic and accurate time-bound analysis. The approach consists of transformations for building time-bound functions in the presence of partially known input structures, symbolic evaluation of the time-bound function based on input parameters, optimizations to make the overall analysis efficient as well as accurate, and measurements of primitive parameters, all at the source-language level. We have implemented this approach and performed a number of experiments for analyzing Scheme programs. The measured worst-case times are closely bounded by the calculated bounds.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Abelson, G. J. Sussman, and J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1985. </year>
Reference-contexts: Each particular component is not meant to be a new analysis or transformation, but the combination of them for the application of automatic and accurate time-bound analysis for high-level languages is new. We used a functional subset of Scheme <ref> [1, 8] </ref> for three reasons. 1) Functional programming languages, together with features like automatic garbage collection, have become increasingly widely used, yet work for calculating actual running time of functional programs has been lacking. 2) Much work has been done on analyzing and transforming functional programs, including complexity analysis, and it
Reference: [2] <author> P. Altenbernd. </author> <title> On the false path problem in hard real-time programs. </title> <booktitle> In Proceedings of the 8th EuroMicro Workshop on Real-Time Systems, </booktitle> <pages> pages 102-107, </pages> <address> L'Aquila, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis <ref> [27, 2] </ref>. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [28], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [27]. <p> Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [2, 10, 15, 17] </ref>. <p> In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user [35, 28, 27, 22], even though program analyses can help in some cases <ref> [2, 10, 15, 17] </ref>. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. This isolates the third problem, which is most interesting to systems research: obtaining values of primitive parameters for various compilers, run-time systems, operating systems, and machine hardwares. <p> However, if we consider only the two realizable execution paths, we know that the worst case is tF ibonacci (2000) plus some small constants. This is known as the false-path elimination problem <ref> [2] </ref>. Two transformations, lifting conditions and simplifying conditionals, allow us to achieve the accurate analysis results above. In each function definition, the former lifts conditions to the outmost scope that the test does not depend on, and the latter simplifies conditionals according to the lifted condition. <p> A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [27, 2, 10, 15, 17] </ref>. Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> A number of techniques have been studied for obtaining loop bounds or execution paths [27, 2, 10, 15, 17]. Manual annotations [27, 22] are inconvenient and error-prone <ref> [2] </ref>. Automatic analysis of such information has two main problems. First, even when a precise loop bound can be obtained by symbolic evaluation of the program [10], separating the loop and path information from the rest of the analysis is in general less accurate than an integrated analysis [25].
Reference: [3] <author> R. Arnold, F. Mueller, D. B. Whalley, and M. G. Harmon. </author> <title> Bounding worst-case instruction cache performance. </title> <booktitle> In Proceedings of the 13th IEEE Real-Time Systems Symposium. </booktitle> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <year> 1994. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory <ref> [3, 22, 11] </ref>, etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2]. <p> In recent year, much progress has been made in analyzing low-level dynamic factors, such as clock interrupt, memory refresh, cache usage, instruction scheduling, and parallel architectures <ref> [28, 3, 22, 11] </ref>. Nevertheless, inability to compute loop bounds or execution paths automatically and accurately has led calculated bounds to be much higher than measured worst-case time. Additionally, primitive parameters are difficult and expensive to obtain and can not be reused for different systems and machines.
Reference: [4] <editor> B. Bjtrner, A. P. Ershov, and N. D. Jones, editors. </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1988. </year>
Reference-contexts: We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation, incremental computation, and transformations of conditionals to make the analysis more efficient and more accurate. Partial evaluation <ref> [4, 19] </ref>, incremental computation [24, 23], and other transformations have been studied intensively in programming languages. Their applications in our time-bound analysis are particularly simple and clean; the resulting transformations are fully automatic and efficient.
Reference: [5] <author> Cadence Research Systems. </author> <title> Chez Scheme System Manual. </title> <institution> Cadence Research Systems, Bloomington, Indiana, </institution> <address> revision 2.4 edition, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: The symbolic evaluation and optimizations, as well as measurements of primitive parameters, are written in Scheme. The measurements 11 and analyses are performed for source programs compiled with Chez Scheme compiler <ref> [5] </ref>. The particular numbers below are taken on a Sun Ultra 1 with 167MHz UltraSPARC CPU and 64MB main memory, but we have also performed the analysis for several other kinds of SPARC stations, and the results are similar.
Reference: [6] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, accessing an array element a [i] takes the time of accessing i, offsetting the element address from that of a, and finally getting the value from that address. Note that side effects caused by these features often cause other analysis to be difficult <ref> [6, 18] </ref>. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied [37, 33]. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions.
Reference: [7] <author> J. Cohen. </author> <title> Computer-assisted microanalysis of programs. </title> <journal> Commun. ACM, </journal> <volume> 25(10) </volume> <pages> 724-733, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: This is done easily by associating a parameter with each program construct representing its running time and by summing these parameters based on the semantics of the constructs <ref> [38, 7, 35] </ref>. We call parameters that describe the running times of program constructs primitive parameters. To calculate actual time bounds based on the timing function, three difficult problems must be solved. <p> Whatever values of the primitive parameters are assumed, a second problem arises, and it is theoretically challenging: optimizing the time-bound function to a closed form in terms of the input size <ref> [38, 7, 21, 30, 13] </ref>. Although much progress has been made in this area, closed forms are known only for subclasses of functions. Thus, such optimization can not be automatically done for analyzing general programs.
Reference: [8] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: Each particular component is not meant to be a new analysis or transformation, but the combination of them for the application of automatic and accurate time-bound analysis for high-level languages is new. We used a functional subset of Scheme <ref> [1, 8] </ref> for three reasons. 1) Functional programming languages, together with features like automatic garbage collection, have become increasingly widely used, yet work for calculating actual running time of functional programs has been lacking. 2) Much work has been done on analyzing and transforming functional programs, including complexity analysis, and it
Reference: [9] <author> J. Engblom, P. Altenbernd, and A. Ermedahl. </author> <title> Facilitating worst-case execution time analysis for optimized code. </title> <booktitle> In Proceedings of the 10th EuroMicro Workshop on Real-Time Systems, </booktitle> <address> Berlin, Germany, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations <ref> [28, 9] </ref>, pipelining [16, 22], cache memory [3, 22, 11], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications.
Reference: [10] <author> A. Ermedahl and J. Gustafsson. </author> <title> Deriving annotations for tight calculation of execution time. </title> <booktitle> In In Proceedings of Euro-Par'97, volume 1300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1298-1307. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [2, 10, 15, 17] </ref>. <p> In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user [35, 28, 27, 22], even though program analyses can help in some cases <ref> [2, 10, 15, 17] </ref>. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. This isolates the third problem, which is most interesting to systems research: obtaining values of primitive parameters for various compilers, run-time systems, operating systems, and machine hardwares. <p> A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [27, 2, 10, 15, 17] </ref>. Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. First, even when a precise loop bound can be obtained by symbolic evaluation of the program <ref> [10] </ref>, separating the loop and path information from the rest of the analysis is in general less accurate than an integrated analysis [25]. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [10, 15, 25]. <p> Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds <ref> [10, 15, 25] </ref>. Some new methods, while powerful, apply only to certain classes of programs [17]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures.
Reference: [11] <author> C. Ferdinand, F. Martin, and R. Wilhelm. </author> <title> Applying compiler techniques to cache behavior prediction. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1997 Workshop on Languages, Compilers, and Tools for Real-Time Systems, </booktitle> <pages> pages 37-46, </pages> <year> 1997. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory <ref> [3, 22, 11] </ref>, etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2]. <p> In recent year, much progress has been made in analyzing low-level dynamic factors, such as clock interrupt, memory refresh, cache usage, instruction scheduling, and parallel architectures <ref> [28, 3, 22, 11] </ref>. Nevertheless, inability to compute loop bounds or execution paths automatically and accurately has led calculated bounds to be much higher than measured worst-case time. Additionally, primitive parameters are difficult and expensive to obtain and can not be reused for different systems and machines. <p> We have also studied simple but powerful optimizations to speed up the analysis. In a new analysis for cache behavior <ref> [11] </ref>, loops are transformed into recursive calls, and a predefined callstring level determines how many times the fixed point analysis iterates and thus how the analysis results are approximated. Our method allows the analysis to perform the exact number of recursions, or iterations, for the given partial input data structures. <p> We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level <ref> [22, 11] </ref>. In particular, we plan to apply our general approach to analyze space consumption and hence to help predict garbage-collection and caching behavior. In conclusion, the approach we propose is based entirely on high-level programming languages.
Reference: [12] <author> P. Flajolet, B. Salvy, and P. Zimmermann. Lambda-Upsilon-Omega: </author> <title> An assistant algorithms analyzer. </title> <editor> In T. Mora, editor, </editor> <title> Applied Algebra, Algebraic Algorithms and Error-Correcting Codes, </title> <booktitle> volume 357 of Lecture Notes in Computer Science, </booktitle> <pages> pages 201-212, </pages> <address> Rome, Italy, July 1989. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [20, 12, 13, 41] </ref>, programming languages [38, 21, 30, 33], and systems [35, 28, 32, 31].
Reference: [13] <author> P. Flajolet, B. Salvy, and P. Zimmermann. </author> <title> Automatic average-case analysis of algorithms. </title> <journal> Theoretical Computer Science, Series A, </journal> <volume> 79(1) </volume> <pages> 37-109, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [20, 12, 13, 41] </ref>, programming languages [38, 21, 30, 33], and systems [35, 28, 32, 31]. <p> Whatever values of the primitive parameters are assumed, a second problem arises, and it is theoretically challenging: optimizing the time-bound function to a closed form in terms of the input size <ref> [38, 7, 21, 30, 13] </ref>. Although much progress has been made in this area, closed forms are known only for subclasses of functions. Thus, such optimization can not be automatically done for analyzing general programs. <p> Compared to work in algorithm analysis and program complexity analysis [21, 33, 41], this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements. There is also work on analyzing average-case complexity <ref> [13] </ref>, which has a different goal than worst-case bounds.
Reference: [14] <author> Y. Futamura and K. Nogi. </author> <title> Generalized partial evaluation. </title> <editor> In Bjtrner et al. </editor> <volume> [4], </volume> <pages> pages 133-151. </pages>
Reference-contexts: The power of these transformations depends on reasonings used in simplifying the conditionals, as have been studied in many program transformation methods <ref> [39, 34, 36, 14, 24] </ref>. At least syntactic equality can be used, which identifies the most obvious source of inaccuracy. These optimizations also speed up the symbolic evaluation, since now obviously infeasible execution paths are not searched. These transformations have been implemented and applied on many test programs.
Reference: [15] <author> J. Gustafsson and A. Ermedahl. </author> <title> Automatic derivation of path and loop annotations in object-oriented real-time programs. </title> <journal> Journal of Parallel and Distributed Computing Practices, </journal> <volume> 1(2), </volume> <month> June </month> <year> 1998. </year>
Reference-contexts: Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [2, 10, 15, 17] </ref>. <p> In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user [35, 28, 27, 22], even though program analyses can help in some cases <ref> [2, 10, 15, 17] </ref>. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. This isolates the third problem, which is most interesting to systems research: obtaining values of primitive parameters for various compilers, run-time systems, operating systems, and machine hardwares. <p> A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [27, 2, 10, 15, 17] </ref>. Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds <ref> [10, 15, 25] </ref>. Some new methods, while powerful, apply only to certain classes of programs [17]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures.
Reference: [16] <author> M. G. Harmon, T. P. Baker, and D. B. Whalley. </author> <title> A retargetable technique for predicting execution time. </title> <booktitle> In Proceedings of the 11th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 68-77. </pages> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining <ref> [16, 22] </ref>, cache memory [3, 22, 11], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2].
Reference: [17] <author> C. Healy, M. Sjodin, V. Rustagi, and D. Whalley. </author> <title> Bounding loop iterations for timing analysis. </title> <booktitle> In Proceedings of the IEEE Real-Time Applications Symposium. </booktitle> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [2, 10, 15, 17] </ref>. <p> In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user [35, 28, 27, 22], even though program analyses can help in some cases <ref> [2, 10, 15, 17] </ref>. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. This isolates the third problem, which is most interesting to systems research: obtaining values of primitive parameters for various compilers, run-time systems, operating systems, and machine hardwares. <p> A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [27, 2, 10, 15, 17] </ref>. Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [10, 15, 25]. Some new methods, while powerful, apply only to certain classes of programs <ref> [17] </ref>. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures.
Reference: [18] <author> L. J. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> June </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: For example, accessing an array element a [i] takes the time of accessing i, offsetting the element address from that of a, and finally getting the value from that address. Note that side effects caused by these features often cause other analysis to be difficult <ref> [6, 18] </ref>. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied [37, 33]. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions.
Reference: [19] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1993. </year>
Reference-contexts: We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation, incremental computation, and transformations of conditionals to make the analysis more efficient and more accurate. Partial evaluation <ref> [4, 19] </ref>, incremental computation [24, 23], and other transformations have been studied intensively in programming languages. Their applications in our time-bound analysis are particularly simple and clean; the resulting transformations are fully automatic and efficient.
Reference: [20] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1968. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [20, 12, 13, 41] </ref>, programming languages [38, 21, 30, 33], and systems [35, 28, 32, 31].
Reference: [21] <author> D. Le Metayer. </author> <title> Ace: An automatic complexity evaluator. </title> <journal> ACM Trans. Program. Lang. and Syst., </journal> <volume> 10(2) </volume> <pages> 248-266, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages <ref> [38, 21, 30, 33] </ref>, and systems [35, 28, 32, 31]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> In general, due to imperfect knowledge about the input, the timing function is transformed into a time-bound function. In algorithm analysis, inputs are characterized by their size; accommodating this requires manual or semi-automatic transformation of the timing function <ref> [38, 21, 41] </ref>. The analysis is mainly asymptotic, and primitive parameters are considered independent of input size, i.e., are constants while the computation iterates or recurses. <p> Whatever values of the primitive parameters are assumed, a second problem arises, and it is theoretically challenging: optimizing the time-bound function to a closed form in terms of the input size <ref> [38, 7, 21, 30, 13] </ref>. Although much progress has been made in this area, closed forms are known only for subclasses of functions. Thus, such optimization can not be automatically done for analyzing general programs. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [38, 21, 35] </ref>. However, partially known input structures provide a natural means [30]. A special value unknown represents unknown values. <p> Certain detailed comparisons have also been discussed while presenting our method. This section summarizes them, compares with analyses for loop bounds and execution paths in more detail, and concludes. Compared to work in algorithm analysis and program complexity analysis <ref> [21, 33, 41] </ref>, this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements. There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds.
Reference: [22] <author> S.-S. Lim, Y. H. Bae, G. T. Jang, B.-D. Rhee, S. L. Min, C. Y. Park, H. Shin, K. Park, S.-M. Moon, and C.-S. Kim. </author> <title> An accurate worst case timing analysis for risc processors. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 21(7) </volume> <pages> 593-604, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining <ref> [16, 22] </ref>, cache memory [3, 22, 11], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2]. <p> Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory <ref> [3, 22, 11] </ref>, etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2]. <p> Thus, such optimization can not be automatically done for analyzing general programs. In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user <ref> [35, 28, 27, 22] </ref>, even though program analyses can help in some cases [2, 10, 15, 17]. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. <p> In recent year, much progress has been made in analyzing low-level dynamic factors, such as clock interrupt, memory refresh, cache usage, instruction scheduling, and parallel architectures <ref> [28, 3, 22, 11] </ref>. Nevertheless, inability to compute loop bounds or execution paths automatically and accurately has led calculated bounds to be much higher than measured worst-case time. Additionally, primitive parameters are difficult and expensive to obtain and can not be reused for different systems and machines. <p> Figure 5 depicts the numbers in Figure 3. Examples such as sorting are classified as complex examples in previous study <ref> [28, 22] </ref>, where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [28] or 20 [22]) is reported in each experiment. <p> Examples such as sorting are classified as complex examples in previous study [28, 22], where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [28] or 20 <ref> [22] </ref>) is reported in each experiment. We found that when inputs are extremely small (10 or 20), the measured time is occasionally above the calculated time for some examples. <p> There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds. Compared to work in systems <ref> [35, 28, 27, 22] </ref>, this work explores program analysis and transformation techniques to make the analysis automatic, efficient, and accurate, overcoming the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> A number of techniques have been studied for obtaining loop bounds or execution paths [27, 2, 10, 15, 17]. Manual annotations <ref> [27, 22] </ref> are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level <ref> [22, 11] </ref>. In particular, we plan to apply our general approach to analyze space consumption and hence to help predict garbage-collection and caching behavior. In conclusion, the approach we propose is based entirely on high-level programming languages.
Reference: [23] <author> Y. A. Liu, S. D. Stoller, and T. Teitelbaum. </author> <title> Static caching for incremental computation. </title> <journal> ACM Trans. Program. Lang. and Syst., </journal> <volume> 20(2), </volume> <month> March </month> <year> 1998. </year>
Reference-contexts: We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation, incremental computation, and transformations of conditionals to make the analysis more efficient and more accurate. Partial evaluation [4, 19], incremental computation <ref> [24, 23] </ref>, and other transformations have been studied intensively in programming languages. Their applications in our time-bound analysis are particularly simple and clean; the resulting transformations are fully automatic and efficient.
Reference: [24] <author> Y. A. Liu and T. Teitelbaum. </author> <title> Systematic derivation of incremental programs. </title> <journal> Sci. Comput. Program., </journal> <volume> 24(1) </volume> <pages> 1-39, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: The power of these transformations depends on reasonings used in simplifying the conditionals, as have been studied in many program transformation methods <ref> [39, 34, 36, 14, 24] </ref>. At least syntactic equality can be used, which identifies the most obvious source of inaccuracy. These optimizations also speed up the symbolic evaluation, since now obviously infeasible execution paths are not searched. These transformations have been implemented and applied on many test programs. <p> We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation, incremental computation, and transformations of conditionals to make the analysis more efficient and more accurate. Partial evaluation [4, 19], incremental computation <ref> [24, 23] </ref>, and other transformations have been studied intensively in programming languages. Their applications in our time-bound analysis are particularly simple and clean; the resulting transformations are fully automatic and efficient.
Reference: [25] <author> T. Lundqvist and P. Stenstrom. </author> <title> Integrating path and timing analysis using instruction-level simulation techniques. </title> <type> Technical Report No. 98-3, </type> <institution> Department of Computer Engineering, Chalmers University of Technology, Goteborg, Sweden, </institution> <year> 1998. </year>
Reference-contexts: the problem but can not completely solve it, because they apply only to some classes of programs or use approximations that are too crude for the analysis, and because separating the loop and path information from the rest of the analysis is in general less accurate than an integrated analysis <ref> [25] </ref>. This paper describes a general approach for automatic and accurate time-bound analysis. The approach combines methods and techniques studied in theory, languages, and systems. We call it a language-based approach, because it primarily exploits methods and techniques for static program analysis and transformation. <p> Automatic analysis of such information has two main problems. First, even when a precise loop bound can be obtained by symbolic evaluation of the program [10], separating the loop and path information from the rest of the analysis is in general less accurate than an integrated analysis <ref> [25] </ref>. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [10, 15, 25]. Some new methods, while powerful, apply only to certain classes of programs [17]. <p> Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds <ref> [10, 15, 25] </ref>. Some new methods, while powerful, apply only to certain classes of programs [17]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures. <p> Our method allows the analysis to perform the exact number of recursions, or iterations, for the given partial input data structures. The most recent work by Lundqvist and Stenstrom <ref> [25] </ref> is based on essentially the same ideas as ours.
Reference: [26] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: running time of a variable reference; a conditional statement is transformed into the time of the test plus, if the condition is true, the time of the true branch, otherwise, the time of the false branch, and plus the time for the transfers 1 The keywords are taken from ML <ref> [26] </ref>.
Reference: [27] <author> C. Y. Park. </author> <title> Predicting program execution times by analyzing static and dynamic program paths. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 5 </volume> <pages> 31-62, </pages> <year> 1993. </year>
Reference-contexts: However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis <ref> [27, 2] </ref>. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [28], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [27]. <p> For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [28], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience <ref> [27] </ref>. Various program analysis methods have been proposed to provide loop bounds or execution paths [2, 10, 15, 17]. <p> Thus, such optimization can not be automatically done for analyzing general programs. In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user <ref> [35, 28, 27, 22] </ref>, even though program analyses can help in some cases [2, 10, 15, 17]. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. <p> There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds. Compared to work in systems <ref> [35, 28, 27, 22] </ref>, this work explores program analysis and transformation techniques to make the analysis automatic, efficient, and accurate, overcoming the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [27, 2, 10, 15, 17] </ref>. Manual annotations [27, 22] are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems. <p> A number of techniques have been studied for obtaining loop bounds or execution paths [27, 2, 10, 15, 17]. Manual annotations <ref> [27, 22] </ref> are inconvenient and error-prone [2]. Automatic analysis of such information has two main problems.
Reference: [28] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <journal> IEEE Computer, </journal> <volume> 24(5) </volume> <pages> 48-57, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages [38, 21, 30, 33], and systems <ref> [35, 28, 32, 31] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages <ref> [35, 28] </ref>. Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory [3, 22, 11], etc. <p> Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations <ref> [28, 9] </ref>, pipelining [16, 22], cache memory [3, 22, 11], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. <p> This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [27, 2]. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in <ref> [28] </ref>, while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [27]. Various program analysis methods have been proposed to provide loop bounds or execution paths [2, 10, 15, 17]. <p> Thus, such optimization can not be automatically done for analyzing general programs. In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user <ref> [35, 28, 27, 22] </ref>, even though program analyses can help in some cases [2, 10, 15, 17]. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. <p> In recent year, much progress has been made in analyzing low-level dynamic factors, such as clock interrupt, memory refresh, cache usage, instruction scheduling, and parallel architectures <ref> [28, 3, 22, 11] </ref>. Nevertheless, inability to compute loop bounds or execution paths automatically and accurately has led calculated bounds to be much higher than measured worst-case time. Additionally, primitive parameters are difficult and expensive to obtain and can not be reused for different systems and machines. <p> Structured data is essentially records in Pascal, structs in C, and constructor applications in ML. Conditionals and bindings easily simulate conditional statements and assignments, and recursions can simulate loops. We can also see that time analysis in the presence of arrays and pointers is not fundamentally harder <ref> [28] </ref>, because the running times of the program constructs for them can be measured in the same way as times of other constructs. <p> Figure 5 depicts the numbers in Figure 3. Examples such as sorting are classified as complex examples in previous study <ref> [28, 22] </ref>, where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [28] or 20 [22]) is reported in each experiment. <p> Examples such as sorting are classified as complex examples in previous study [28, 22], where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 <ref> [28] </ref> or 20 [22]) is reported in each experiment. We found that when inputs are extremely small (10 or 20), the measured time is occasionally above the calculated time for some examples. <p> There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds. Compared to work in systems <ref> [35, 28, 27, 22] </ref>, this work explores program analysis and transformation techniques to make the analysis automatic, efficient, and accurate, overcoming the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> To make the analysis even more accurate and efficient, we can automatically generate measurement programs for all maximum subexpressions that do not include transfers of control; this corresponds to the large atomic-blocks method <ref> [28] </ref>. We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level [22, 11].
Reference: [29] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: We also used the system to obtain the exact symbolic counts and the performance measurements shown in Section 4. The implementation is for a subset of Scheme. An editor for the source programs is implemented using the Synthesizer Generator <ref> [29] </ref>, and thus we can easily change the syntax for the source programs. For example, the current implementation supports both the syntax used in this paper and Scheme syntax. Time-bound functions are constructed using SSL, a simple functional language used in the Synthesizer Generator.
Reference: [30] <author> M. Rosendahl. </author> <title> Automatic complexity analysis. </title> <booktitle> In Proceedings of the 4th International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 144-156. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages <ref> [38, 21, 30, 33] </ref>, and systems [35, 28, 32, 31]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> Whatever values of the primitive parameters are assumed, a second problem arises, and it is theoretically challenging: optimizing the time-bound function to a closed form in terms of the input size <ref> [38, 7, 21, 30, 13] </ref>. Although much progress has been made in this area, closed forms are known only for subclasses of functions. Thus, such optimization can not be automatically done for analyzing general programs. <p> Additionally, primitive parameters are difficult and expensive to obtain and can not be reused for different systems and machines. In programming-language area, Rosendahl proposed using partially known input structures <ref> [30] </ref>. For example, instead of replacing an input list l with its length n, as done in algorithm analysis, or annotating loops with numbers related to n, as done in systems, we simply use as input a list of n unknown elements. <p> (x)) +( let s = least (cdr (x)) in T if + T + T car + T varref + T varref +( if car (x) s then T car + T varref else T varref ) end)) This transformation is similar to the local cost assignment [38], step-counting function <ref> [30] </ref>, cost function [33], etc. in other work. Our transformation extends those methods with bindings, and makes all primitive parameters explicit at the source-language level. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate [38, 21, 35]. However, partially known input structures provide a natural means <ref> [30] </ref>. A special value unknown represents unknown values. <p> We apply the ideas at source-level, and our experiments show that we can calculate more accurate time bound and for many more programs than merging paths, and the calculation is still efficient. The idea of using partially known input structures originates from Rosendahl <ref> [30] </ref>. We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation.
Reference: [31] <author> R. H. Saavedra and A. J. Smith. </author> <title> Analysis of benchmark characterization and benchmark performance prediction. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 14(4) </volume> <pages> 344-384, </pages> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages [38, 21, 30, 33], and systems <ref> [35, 28, 32, 31] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction <ref> [32, 31] </ref>. In that work, information about execution paths was obtained by running the programs on a number of inputs; for programs such as insertion sort whose best-case and worst-case execution times differ greatly, the predicted time using this method could be very inaccurate.
Reference: [32] <author> R. H. Saavedra-Barrera, A. J. Smith, and E. Miya. </author> <title> Machine characterization based on an abstract high-level language machine. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(12) </volume> <pages> 1659-1679, </pages> <month> Dec. </month> <year> 1989. </year> <title> Special issue on Performance Evaluation. </title>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages [38, 21, 30, 33], and systems <ref> [35, 28, 32, 31] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction <ref> [32, 31] </ref>. In that work, information about execution paths was obtained by running the programs on a number of inputs; for programs such as insertion sort whose best-case and worst-case execution times differ greatly, the predicted time using this method could be very inaccurate.
Reference: [33] <author> D. Sands. </author> <title> Complexity analysis for a lazy higher-order language. </title> <booktitle> In Proceedings of the 3rd European Symposium on Programming, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 361-376. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages <ref> [38, 21, 30, 33] </ref>, and systems [35, 28, 32, 31]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> Note that side effects caused by these features often cause other analysis to be difficult [6, 18]. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied <ref> [37, 33] </ref>. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions. We first transform the original program to construct a timing function, which takes the original input and primitive parameters as arguments and returns the running time. <p> s = least (cdr (x)) in T if + T + T car + T varref + T varref +( if car (x) s then T car + T varref else T varref ) end)) This transformation is similar to the local cost assignment [38], step-counting function [30], cost function <ref> [33] </ref>, etc. in other work. Our transformation extends those methods with bindings, and makes all primitive parameters explicit at the source-language level. For example, each primitive operation p is given a different symbol T p , and each constructor c is given a different symbol T c . <p> Certain detailed comparisons have also been discussed while presenting our method. This section summarizes them, compares with analyses for loop bounds and execution paths in more detail, and concludes. Compared to work in algorithm analysis and program complexity analysis <ref> [21, 33, 41] </ref>, this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements. There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds.
Reference: [34] <author> W. L. Scherlis. </author> <title> Program improvement by internal specialization. </title> <booktitle> In Conference Record of the 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 41-49. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1981. </year>
Reference-contexts: The power of these transformations depends on reasonings used in simplifying the conditionals, as have been studied in many program transformation methods <ref> [39, 34, 36, 14, 24] </ref>. At least syntactic equality can be used, which identifies the most obvious source of inaccuracy. These optimizations also speed up the symbolic evaluation, since now obviously infeasible execution paths are not searched. These transformations have been implemented and applied on many test programs.
Reference: [35] <author> A. Shaw. </author> <title> Reasoning about time in higher level language software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages [38, 21, 30, 33], and systems <ref> [35, 28, 32, 31] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages <ref> [35, 28] </ref>. Since Shaw proposed timing schema for analyzing system running time based on high-level languages [35], a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory [3, 22, 11], etc. <p> Since Shaw proposed timing schema for analyzing system running time based on high-level languages <ref> [35] </ref>, a number of people have extended it for analysis in the presence of compiler optimizations [28, 9], pipelining [16, 22], cache memory [3, 22, 11], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. <p> This is done easily by associating a parameter with each program construct representing its running time and by summing these parameters based on the semantics of the constructs <ref> [38, 7, 35] </ref>. We call parameters that describe the running times of program constructs primitive parameters. To calculate actual time bounds based on the timing function, three difficult problems must be solved. <p> Thus, such optimization can not be automatically done for analyzing general programs. In systems, inputs are characterized indirectly using loop bounds or execution paths in programs, and such information must in general be provided by the user <ref> [35, 28, 27, 22] </ref>, even though program analyses can help in some cases [2, 10, 15, 17]. Closed forms in terms of parameters for these bounds can be obtained easily from the timing function. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [38, 21, 35] </ref>. However, partially known input structures provide a natural means [30]. A special value unknown represents unknown values. <p> There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds. Compared to work in systems <ref> [35, 28, 27, 22] </ref>, this work explores program analysis and transformation techniques to make the analysis automatic, efficient, and accurate, overcoming the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely.
Reference: [36] <author> V. F. Turchin. </author> <title> The concept of a supercompiler. </title> <journal> ACM Trans. Program. Lang. and Syst., </journal> <volume> 8(3) </volume> <pages> 292-325, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: The power of these transformations depends on reasonings used in simplifying the conditionals, as have been studied in many program transformation methods <ref> [39, 34, 36, 14, 24] </ref>. At least syntactic equality can be used, which identifies the most obvious source of inaccuracy. These optimizations also speed up the symbolic evaluation, since now obviously infeasible execution paths are not searched. These transformations have been implemented and applied on many test programs.
Reference: [37] <author> P. Wadler. </author> <title> Strictness analysis aids time analysis. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Note that side effects caused by these features often cause other analysis to be difficult [6, 18]. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied <ref> [37, 33] </ref>. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions. We first transform the original program to construct a timing function, which takes the original input and primitive parameters as arguments and returns the running time.
Reference: [38] <author> B. Wegbreit. </author> <title> Mechanical program analysis. </title> <journal> Commun. ACM, </journal> <volume> 18(9) </volume> <pages> 528-538, </pages> <month> Sept. </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [20, 12, 13, 41], programming languages <ref> [38, 21, 30, 33] </ref>, and systems [35, 28, 32, 31]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [35, 28]. <p> This is done easily by associating a parameter with each program construct representing its running time and by summing these parameters based on the semantics of the constructs <ref> [38, 7, 35] </ref>. We call parameters that describe the running times of program constructs primitive parameters. To calculate actual time bounds based on the timing function, three difficult problems must be solved. <p> In general, due to imperfect knowledge about the input, the timing function is transformed into a time-bound function. In algorithm analysis, inputs are characterized by their size; accommodating this requires manual or semi-automatic transformation of the timing function <ref> [38, 21, 41] </ref>. The analysis is mainly asymptotic, and primitive parameters are considered independent of input size, i.e., are constants while the computation iterates or recurses. <p> Whatever values of the primitive parameters are assumed, a second problem arises, and it is theoretically challenging: optimizing the time-bound function to a closed form in terms of the input size <ref> [38, 7, 21, 30, 13] </ref>. Although much progress has been made in this area, closed forms are known only for subclasses of functions. Thus, such optimization can not be automatically done for analyzing general programs. <p> + tleast (cdr (x)) +( let s = least (cdr (x)) in T if + T + T car + T varref + T varref +( if car (x) s then T car + T varref else T varref ) end)) This transformation is similar to the local cost assignment <ref> [38] </ref>, step-counting function [30], cost function [33], etc. in other work. Our transformation extends those methods with bindings, and makes all primitive parameters explicit at the source-language level. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [38, 21, 35] </ref>. However, partially known input structures provide a natural means [30]. A special value unknown represents unknown values.
Reference: [39] <author> B. Wegbreit. </author> <title> Goal-directed program transformation. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> SE-2(2):69-80, </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: The power of these transformations depends on reasonings used in simplifying the conditionals, as have been studied in many program transformation methods <ref> [39, 34, 36, 14, 24] </ref>. At least syntactic equality can be used, which identifies the most obvious source of inaccuracy. These optimizations also speed up the symbolic evaluation, since now obviously infeasible execution paths are not searched. These transformations have been implemented and applied on many test programs.
Reference: [40] <author> D. Weise, R. F. Crew, M. Ernst, and B. Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Conference Record of the 21st Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: lacking. 2) Much work has been done on analyzing and transforming functional programs, including complexity analysis, and it can be used for analyzing actual running times efficiently and accurately as well. 3) Analyses and transformations developed for functional language can be applied to improve analyses of imperative languages as well <ref> [40] </ref>. All our analyses and transformations are performed at source level. This allows implementations to be independent of compilers and underlying systems and allows analysis results to be understood at source level. Language.
Reference: [41] <author> P. Zimmermann and W. Zimmermann. </author> <title> The automatic complexity analysis of divide-and-conquer algorithms. </title> <booktitle> In Computer and Information Sciences VI. </booktitle> <publisher> Elsevier, </publisher> <year> 1991. </year> <month> 17 </month>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [20, 12, 13, 41] </ref>, programming languages [38, 21, 30, 33], and systems [35, 28, 32, 31]. <p> In general, due to imperfect knowledge about the input, the timing function is transformed into a time-bound function. In algorithm analysis, inputs are characterized by their size; accommodating this requires manual or semi-automatic transformation of the timing function <ref> [38, 21, 41] </ref>. The analysis is mainly asymptotic, and primitive parameters are considered independent of input size, i.e., are constants while the computation iterates or recurses. <p> Certain detailed comparisons have also been discussed while presenting our method. This section summarizes them, compares with analyses for loop bounds and execution paths in more detail, and concludes. Compared to work in algorithm analysis and program complexity analysis <ref> [21, 33, 41] </ref>, this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements. There is also work on analyzing average-case complexity [13], which has a different goal than worst-case bounds.
References-found: 41

