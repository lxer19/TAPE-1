URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR90-09/TR.ps.Z
Refering-URL: http://www.cs.iastate.edu/~leavens/main.html
Root-URL: http://www.cs.iastate.edu
Title: Modular Verification of Object-Oriented Programs with Subtypes  
Author: Gary T. Leavens 
Degree: cfl Gary T. Leavens, 1990. All rights reserved.  
Address: Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science Iowa State University  
Date: July 5, 1990  
Pubnum: TR #90-09  
Abstract-found: 0
Intro-found: 1
Reference: [Ada83] <author> American National Standards Institute. </author> <title> Reference Manual for the Ada Programming Language, </title> <month> February </month> <year> 1983. </year> <note> ANSI/MIL-STD 1815A. Also published by Springer-Verlag as LNCS 155. </note>
Reference-contexts: In some languages the method dictionary is implicit in a type parameter, such as Int in the instantiation sort [Int] as one might write in CLU [LAB + 81] or Ada <ref> [Ada83] </ref>. In ML [GMW79], type parameters are implicit, but one must pass the operations that would go in the method dictionary explicitly. The polymorphism that results from forms of overloading can also be explained by method dictionaries [WB89]. <p> A mechanism to mediate between independently designed abstractions with fixed interfaces is a feature of several languages without message passing mecha nisms (e.g., OBJ2 [FGJM85], Argus [LDH + 87], and Ada <ref> [Ada83] </ref>), where one can change the interface of a type parameter. In a language with a message passing mechanism, one wants to be able to change the interfaces of objects.
Reference: [AK84] <author> Hassan Ait-Kaci. </author> <title> A Lattice Theoretic Approach to Computation Based on a Calculus of Partially Ordered Type Structures. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1984. </year>
Reference-contexts: Formal work on the question of when one type is a subtype of another can be roughly divided into two camps: algebraic model theory and type theory. The work of Ait-Kaci <ref> [AK84] </ref> falls outside this classification.
Reference: [Ame89] <author> Pierre America. </author> <title> A Behavioural Approach to Subtyping in Object-Oriented Programming Languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: America has independently developed a definition of subtype relationships <ref> [Ame89] </ref>. Like Meyer, America's definition is based on implications between pre-and post-conditions of operations. However, unlike Meyer, America does not use program operations in assertions. <p> One approach to such a result is to work with implications between the pre- and post-conditions of operation specifications (and invariants), following the lead of Meyer [Mey88] or America <ref> [Ame89] </ref>. It might also be useful to have a proof-theoretic definition of subtype relations.
Reference: [BDMN73] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> SIMULA Begin. </title> <publisher> Auerbach Publishers, </publisher> <address> Philadelphia, Penn., </address> <year> 1973. </year>
Reference-contexts: An important way that one can enhance the functionality of a system is by adding new types of objects. The message passing mechanism of an object-oriented programming language such as Smalltalk-80 [GR83], C++ [Str86], the Common LISP Object System (CLOS) [Kee89], or Simula 67 <ref> [BDMN73] </ref>, can eliminate the need to up date code to work with objects of new types [Cox86], because it separates the manipulation of an object from knowledge of the object's type. <p> Since these types do not have class operations they cannot be instantiated. A type that cannot be instantiated is called a virtual type, since its implementations often use virtual operations. A virtual operation has an implementation that uses some primitive (called virtual in Simula 67 <ref> [BDMN73] </ref>) to invoke an operation of a subclass 2 ; hence a virtual operation cannot be executed unless the subclass has defined the required operation. Consider the specification Vehicles, given in Figure 4.7. In this specification, Vehicle is a virtual type and has no class operations.
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: informal definitions * are behavioral, since they are based on the specifications of abstract types, as opposed to structural rules for subtyping among certain built-in 37 types (such as those proposed by Cardelli and oth- ers) or structural comparisons between the signa tures of abstract types (as in Emerald [BHJL86] <ref> [BHJ + 87] </ref>), and * generalize closely related work (by Reynolds and by Bruce and Wegner) in that they are defined using simulation relations instead of coercion functions among families of algebraic models of specifications, and can thus handle nondeterministic and incompletely specified types.
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: various informal definitions * are behavioral, since they are based on the specifications of abstract types, as opposed to structural rules for subtyping among certain built-in 37 types (such as those proposed by Cardelli and oth- ers) or structural comparisons between the signa tures of abstract types (as in Emerald <ref> [BHJL86] </ref> [BHJ + 87]), and * generalize closely related work (by Reynolds and by Bruce and Wegner) in that they are defined using simulation relations instead of coercion functions among families of algebraic models of specifications, and can thus handle nondeterministic and incompletely specified types. <p> If the declared subtype relation satisfies the semantic constraints described in Chapter 4, then the style of reasoning described above should be useful for program verification in Trellis/Owl. 6.5.3 Verification in Emerald Unlike Trellis/Owl the designers of Emerald <ref> [BHJL86] </ref> have made the mistake of inferring subtype relationships for abstract types from syntactic interfaces. Unfortunately, it is easy to specify types so that the binary relation that Emerald infers is not a subtype relation (i.e., the inferred relation does not satisfy the semantic constraints on subtype relations).
Reference: [BL88] <author> Kim B. Bruce and Giuseppe Longo. </author> <title> A Modest Model of Records, Inheritance, and Bounded Quantification. </title> <editor> In Y. Gurevich, editor, </editor> <booktitle> Logic in Computer Science, </booktitle> <pages> pages 38-50. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: For such a specification, ResSort (add; hInt; Inti) = Rat: 22 which is less specific than might be desired. Various re-searchers have used "bounded quantification" to state type restrictions so that the nominal type of adding two integers is an integer [CW85] [Car88], but bounded quantification has its problems <ref> [BL88] </ref>. On the other hand, the designer must be careful to specify types in such a way that a legal signature results. <p> For example, consider a subtype of IntSet whose objects cannot contain 3. The problem is that the returned object cannot be an element of such a type. The problem is similar to the semantic problems with bounded quantification pointed out by <ref> [BL88] </ref>. A better solution to this problem would be to allow multiple specifications for functions, as described above. <p> For certain languages the ideal model [MS82] cited by Cardelli and Wegner, has a rich enough structure to accommodate this explanation. But for Cardelli and Wegner's language, the ideal model is not sound <ref> [BL88] </ref>. One can also construct special-purpose models with the property that the set of values of a subtype is a subset of the set of values of its supertypes [Car84]. However, building specialized models is not a practical approach to settling subtyping questions.
Reference: [Bro86] <author> Manfred Broy. </author> <title> A Theory for Nondeterminism, Parallelism, </title> <journal> Communication, and Concurrency. Theoretical Computer Science, </journal> <volume> 45(1) </volume> <pages> 1-61, </pages> <year> 1986. </year>
Reference-contexts: It is object-oriented because it has a message passing mechanism. The language NOAL is a hybrid of Trellis/Owl [SCB + 86] and Broy's AMPL <ref> [Bro86] </ref>. NOAL resembles AMPL in that it is a lambda calculus with explicit facilities for nondeterminism. Like AMPL, NOAL is a first-order language; that is, functions are not objects in NOAL programs. NOAL resembles Trellis/Owl in its type system and message passing mechanism. <p> Figure B.3 is an algebraic model IntStream. The model of BoolStream is similar and can be obtained by replacing Bool for Int throughout. The carrier set of IntStream is defined using the operator Stream <ref> [Bro86] </ref>, defined as Stream (I) def where * I fl denotes the set of finite streams, which are finite sequences of elements of I, such as the empty stream hi and hi 1 ; i 2 ; i 3 i, * I fl fi f?g denotes the set of partial streams, <p> This appendix also contains the proof of the substitution property for NOAL functions. C.1 Semantics of NOAL Functions The semantics of NOAL functions are discussed informally in Chapter 5. Thus only the formal details are presented here. The semantics follows Broy's discussion of the semantics of AMPL <ref> [Bro86, Page 20] </ref>. As a preliminary to the semantics, the first subsection below describes how the carrier sets of an algebra are viewed as a domain, which requires an assumption about the domain ordering on the carrier sets of algebras that can be observed by NOAL programs. <p> From now on pointed complete partial orders will be called domains. Of primary interest are flat domains, since the semantics for recursive functions assumes that each carrier set, except for the carrier sets of the stream types, is a flat domain <ref> [Bro86, Page 7] </ref>. Definition C.1.1 (flat domain). A domain is flat if and only if for all elements q and r, q v r if and only if q = r or q = ?. As usual, the notation q &lt; r means q v r and q 6= r. <p> Let A be an algebra and q; r 2 BoolStream A . Then q v r if and only if either q = r or q is a partial stream whose proper elements are a prefix of r; similarly for IntStream <ref> [Bro86, Section 2.1] </ref>. The carrier set of A itself is a domain formed by the union of all its carrier sets. <p> For sets of possible results, the ordering v E is defined so that Q v E R if for each q 2 Q there is some r 2 R such that q v r <ref> [Bro86, Page 13] </ref>. For the domain ordering on an algebra to be useful, it must say something about the operations of the algebra. In particular, the operations (both the pro gram operations and the specification functions) of the algebra must be monotonic and continuous. Definition C.1.2 (monotonic). <p> This assumption is necessary for the assignment of denotations to mutually recursive NOAL functions. This assumption also ensures that the set of possible results of each NOAL expression is closed and thus accords with the principle of finite observability <ref> [Bro86] </ref>. C.1.2 Semantics of Recursive Functions in NOAL The semantics of systems of mutually recursive NOAL functions is given by several stages of approximation. First the semantics of systems that do not use angelic choice are defined. <p> Better approximations are obtained by using earlier approximations to evaluate recursive calls. The net effect is that each approximation uses angelic choice for deeper recursions than the previous approximation <ref> [Bro86, Page 19] </ref>. Let . . . be a system of mutually recursive NOAL function definitions. Let E (j;0) be derived from E j by replacing all occurrences of the angelic choice operator (5) with the erratic choice operator ( ). <p> The possible results of F [[g (1;i) ]](A)(0) for all i &gt; 1 are also f0; 1; 2; 3; . . .g. Following <ref> [Bro86, Page 19] </ref>, for each j the meaning of f j is def " F [[g (j;i) ]](A)(~q): (C.9) For the pick2 example: F [[pick2]](A)(0) def " F [[g (1;i) ]](A)(0) (C.10) C.2 The Substitution Property for Functions The postponed proof of the substitution property for NOAL functions, Lemma 7.2.2, is <p> For the inductive step, suppose that the result holds for each subexpression. As Broy points out <ref> [Bro86, Theorem 3.2] </ref>, the meaning of each expression except angelic choice that has subexpressions fl 1 ; . . . ; fl n has the form M [[expr (~fl)]](A; ) = [ h (~q) for some monotonic set-valued function h.
Reference: [BW86] <author> Kim B. Bruce and Peter Wegner. </author> <title> An Algebraic Model of Subtypes in Object-Oriented Languages (Draft). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(10), </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: Requiring that the coercion and the types operations satisfy the substitution property ensures that one can reason about overloading and coercion without an exhaustive case analysis. A similar idea is found in the work of Bruce and Wegner <ref> [BW86] </ref> [BW87b]. The work of Reynolds and that of Bruce and Wegner does not allow one to directly compare type specifications: one can only compare particular algebraic models.
Reference: [BW87a] <author> Kim B. Bruce and Peter Wegner. </author> <title> Algebraic and Lambda Calculus Models of Subtype and Inheritance (Extended Abstract). </title> <note> Working paper?, </note> <year> 1987. </year>
Reference-contexts: The difference is that we provide for message passing (through program operations) and allow objects of one type to be related to objects of another type. Simulation relations are also similar to, but more general than, the coercer functions of Reynolds [Rey80] [Rey85] and Bruce and Wegner <ref> [BW87a] </ref>. These au thors also require a substitution property. 18 Chapter 3 Polymorphic Type and Function Specifications In this chapter a new method for the modular specification of abstract types and polymorphic functions that use message passing is described. <p> Most other work on subtyping only describes subtype relationships for a fixed set of built-in types (e.g., [Car84]). The definition of subtype relations also allows incompletely specified and nondeterministic types to be compared, so it is more widely applicable than Bruce and Wegner's definition <ref> [BW87a] </ref>. Simulation as defined in this report handles non-determinism as follows. A nondeterministic object q simulates an object r if q has only the behaviors that r has; however, q may be more deterministic. The definition of subtype relations takes the potential incompleteness of specifications into account as follows.
Reference: [BW87b] <author> Kim B. Bruce and Peter Wegner. </author> <title> An Algebraic Model of Subtype and Inheritance. </title> <note> To appear in Database Programming Languages, </note> <editor> Francois Bancilhon and Peter Buneman (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Requiring that the coercion and the types operations satisfy the substitution property ensures that one can reason about overloading and coercion without an exhaustive case analysis. A similar idea is found in the work of Bruce and Wegner [BW86] <ref> [BW87b] </ref>. The work of Reynolds and that of Bruce and Wegner does not allow one to directly compare type specifications: one can only compare particular algebraic models.
Reference: [Car84] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, </note> <institution> volume 76, </institution> <type> numbers 2/3, </type> <pages> pages 138-164, </pages> <month> February/March </month> <year> 1988. </year>
Reference-contexts: Finally, America has not investigated modular specification and verification as discussed above. The main line of type theoretic research on subtyp-ing has been carried on by Luca Cardelli. His landmark paper "A Semantics of Multiple Inheritance" <ref> [Car84] </ref> showed the soundness of subtyping rules for function types, immutable records, and immutable variants. Cardelli and Mitchell give subtyping rules for immutable records that allow extension and restriction operations [CM89]. <p> are of interest for comparison with related work, making generalizations about semantic relationships between subtypes and supertypes, and studying the interaction between subtyping and exceptions. 4.2.1 OneOf Types Oneof types are useful in modeling exceptions (see Chapter 3), and are also one of the earliest studied ex amples of subtyping <ref> [Car84] </ref>. Cardelli's rule for OneOf types is that a OneOf with fewer tags is a subtype of a OneOf type with more tags, provided the corresponding fields were in the subtype relation. <p> (toNE (o 1 ) == o 3 ) toNE (make normal (i)) = make normal (i) exempts for all [i: Int] val empty (make normal (i)) 34 operations that observe instances, one could have a programming language with built-in expressions for observing OneOf instances [LAB + 81, Section 11.6] [CW85] <ref> [Car84] </ref>; however, it seems best to keep the type specification independent of the programming language by making the programming language's expressions syntactic sugar for operation invocations. One could also could specify value ni operations for each tag ni; the pre-condition would then state when these operations were defined. <p> For example, he says that "behavioral subtyping cannot be deduced without formal semantic specification of behavior." However, he goes on to say that "lacking such specifications, one can deduce subtyping based solely on syntactic external interfaces (i.e., the names of the operations) <ref> [Car84] </ref>." This latter statement is wrong, since for valid reasoning based on subtype relationships among abstract types, the semantics of a type must be taken into account. For example, the types IntSet and Interval have the same set of instance operations, but IntSet is not a subtype of Interval. <p> For example, the types IntSet and Interval have the same set of instance operations, but IntSet is not a subtype of Interval. Although Snyder cites Cardelli's paper <ref> [Car84] </ref> to support his statement, Cardelli's syntactic deductions do not apply to abstract types in general, but only to a limited set of types. 4.3.2 Algebraic Approaches The definition of subtype relations given in this report follow the algebraic tradition of Goguen, Reynolds, and others. Subtypes as Subsets. <p> But for Cardelli and Wegner's language, the ideal model is not sound [BL88]. One can also construct special-purpose models with the property that the set of values of a subtype is a subset of the set of values of its supertypes <ref> [Car84] </ref>. However, building specialized models is not a practical approach to settling subtyping questions. The constraint that a subtype's carrier set must be a subset of each of its supertype's makes such models counterintuitive and unnecessarily difficult to construct. <p> But to show that twoBool is a subtype of oneBool Cardelli constructs a model where the set of values of type twoBool is a subset of oneBool's <ref> [Car84] </ref>. Cardelli's "A Semantics of Multiple Inheritance". A good example of such a construction is found in Cardelli's landmark 1984 paper [Car84]. This paper describes subtype relationships among the built-in types of a small programming language, as well as its type checking and semantics. <p> But to show that twoBool is a subtype of oneBool Cardelli constructs a model where the set of values of type twoBool is a subset of oneBool's <ref> [Car84] </ref>. Cardelli's "A Semantics of Multiple Inheritance". A good example of such a construction is found in Cardelli's landmark 1984 paper [Car84]. This paper describes subtype relationships among the built-in types of a small programming language, as well as its type checking and semantics. <p> Cardelli writes S T when S is syntactically a subtype of T. The semantics of Cardelli's language are described using a domain V. This domain is constructed so that, whenever S T, then the carrier set of S is a subset of the carrier set of T <ref> [Car84, Page 62] </ref>. <p> The treatment of type checking is thus similar to Reynolds's [Rey80]. Like Reynolds, the type inference rules below assign a single nominal type, to each type-safe expression. This is in contrast type systems with a rule of subsumption, such as Cardelli's <ref> [Car84] </ref>, where expressions have multiple types. As with Reynolds's system, the nominal type of an if expression is the least upper bound of the nominal types of the arms, if the least upper bound exists. <p> Technically, this is because the definition of subtype relations is based on the semantics of specifications. Most other work on subtyping only describes subtype relationships for a fixed set of built-in types (e.g., <ref> [Car84] </ref>). The definition of subtype relations also allows incompletely specified and nondeterministic types to be compared, so it is more widely applicable than Bruce and Wegner's definition [BW87a]. Simulation as defined in this report handles non-determinism as follows.
Reference: [Car88] <author> Luca Cardelli. </author> <title> Structural Subtyping and the Notion of Power Type. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 70-79. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: Cardelli and Mitchell give subtyping rules for immutable records that allow extension and restriction operations [CM89]. But neither of these papers nor more sophisticated types systems with the same structural ideas for subtyping (such as <ref> [Car88] </ref> and [Car89]) give subtype rules for abstract data types in general. That is, such type systems do not give general rules that can say whether Interval is a subtype of IntSet based on their specifications. types are common in object-oriented programming. <p> For such a specification, ResSort (add; hInt; Inti) = Rat: 22 which is less specific than might be desired. Various re-searchers have used "bounded quantification" to state type restrictions so that the nominal type of adding two integers is an integer [CW85] <ref> [Car88] </ref>, but bounded quantification has its problems [BL88]. On the other hand, the designer must be careful to specify types in such a way that a legal signature results.
Reference: [Car89] <author> Luca Cardelli. </author> <title> Typeful Programming. </title> <type> Research Report 45, </type> <institution> Digital Equipement Corporation, Systems Research Center, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Cardelli and Mitchell give subtyping rules for immutable records that allow extension and restriction operations [CM89]. But neither of these papers nor more sophisticated types systems with the same structural ideas for subtyping (such as [Car88] and <ref> [Car89] </ref>) give subtype rules for abstract data types in general. That is, such type systems do not give general rules that can say whether Interval is a subtype of IntSet based on their specifications. types are common in object-oriented programming.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Fourth International Conference on Functional Programming and Computer Architecture. ACM, </booktitle> <month> September </month> <year> 1989. </year> <note> Also technical report STL-89-5, </note> <institution> from Software Technology Laboratory, Hewlett-Packard Laboratories. </institution>
Reference-contexts: The problem is similar to the semantic problems with bounded quantification pointed out by [BL88]. A better solution to this problem would be to allow multiple specifications for functions, as described above. A different approach would be to use the notion of "F-bounded quantification" <ref> [CCH + 89] </ref>. 3.5.3 The Need for Subtype-Constraining As sertions In the specification of IntSet given in Figure 1.1, the pre-condition of the choose operation is written as ": isEmpty (s)" instead of ":(s = fg)." However, for the soundness of program verification (see Chapter 6) the assertions used in specifications
Reference: [Che89] <author> Jolly Chen. </author> <title> The Larch/Generic Interface Language. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1989. </year> <note> The author's Bachelor's thesis. 88 </note>
Reference-contexts: The specification language is adapted from Wing's interface specification language for CLU [Win83] [LG86, Chapter 10] [GHW85] [Win87] and Chen's Larch/Generic interface specification language <ref> [Che89] </ref>. However, unlike Wing, the specifications only deal with immutable types. The specification of a function or a program operation is written as if each argument and result has the specified type. However, actual arguments and results are allowed to have types that are subtypes of the specified types.
Reference: [CM89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on Records. </title> <booktitle> In Fifth International Conference on Mathematical Foundations of Programming Semantics, </booktitle> <month> March </month> <year> 1989. </year>
Reference-contexts: His landmark paper "A Semantics of Multiple Inheritance" [Car84] showed the soundness of subtyping rules for function types, immutable records, and immutable variants. Cardelli and Mitchell give subtyping rules for immutable records that allow extension and restriction operations <ref> [CM89] </ref>. But neither of these papers nor more sophisticated types systems with the same structural ideas for subtyping (such as [Car88] and [Car89]) give subtype rules for abstract data types in general. <p> This would probably pose no great problems for reasoning. However, such an extension is left for future work. A different approach to these problems in the context of record types is illustrated in the work of Jate gaonkar and Mitchell on ML [JM88] and Cardelli and Mitchell <ref> [CM89] </ref>. 3.5.2 Loss of Type Information for Subtype Results The specification language cannot express certain constraints on the type of the value returned by a func tion.
Reference: [Cox86] <author> Brad J. Cox. </author> <title> Object Oriented Programming: an Evolutionary Approach. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1986. </year>
Reference-contexts: The message passing mechanism of an object-oriented programming language such as Smalltalk-80 [GR83], C++ [Str86], the Common LISP Object System (CLOS) [Kee89], or Simula 67 [BDMN73], can eliminate the need to up date code to work with objects of new types <ref> [Cox86] </ref>, because it separates the manipulation of an object from knowledge of the object's type. To reason about the behavior of a program to which new types of objects have been added, programmers often classify types by how instances of that type behave. <p> The remainder of this chapter contains a discussion of the purpose and background of the research, an overview of the solution, a survey of related work, and a guide to the technical details. 1.1 Purpose and Background Object-oriented design techniques arise out of concerns for modularity in software systems <ref> [Cox86] </ref>. Modularity means the separation of code into modules that have few and well-defined interactions with each other. Modules can be used to hide design decisions that may have to be changed at a later time [Par72], allowing one to view a system's design at many different levels of detail. <p> Message Passing and Method Dictionaries. The message passing (or late binding) mechanism of an object-oriented programming language can eliminate the need to update code to work with objects of new types <ref> [Cox86] </ref>. Each object in such a lan guage contains 1 both data and a table of operations called a method dictionary. An object's method dictionary maps message names to the operations (code) that implements the named operations for a given type [WB89].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: For example, a function inBoth can find a key number that is common to two IntSet objects, or two Interval objects (or an IntSet and an Interval) using the same sequence of message sends. This kind of polymorphism is called subtype polymorphism (or inclusion polymor phism <ref> [CW85] </ref>). To understand why subtype polymor-phism makes reasoning about programs difficult, it is necessary to understand how subtype polymorphism differs from other kinds of polymorphism. A polymorphic procedure must generally be supplied with a method dictionary for each type of parameter. <p> Cardelli and Wegner call this idea "bounded quantification" <ref> [CW85] </ref>. <p> For such a specification, ResSort (add; hInt; Inti) = Rat: 22 which is less specific than might be desired. Various re-searchers have used "bounded quantification" to state type restrictions so that the nominal type of adding two integers is an integer <ref> [CW85] </ref> [Car88], but bounded quantification has its problems [BL88]. On the other hand, the designer must be careful to specify types in such a way that a legal signature results. <p> However, the type system of the specification language cannot express this. One way to do so would be to use a kind of bounded quantification <ref> [CW85] </ref>. <p> = (toNE (o 1 ) == o 3 ) toNE (make normal (i)) = make normal (i) exempts for all [i: Int] val empty (make normal (i)) 34 operations that observe instances, one could have a programming language with built-in expressions for observing OneOf instances [LAB + 81, Section 11.6] <ref> [CW85] </ref> [Car84]; however, it seems best to keep the type specification independent of the programming language by making the programming language's expressions syntactic sugar for operation invocations. One could also could specify value ni operations for each tag ni; the pre-condition would then state when these operations were defined. <p> The idea that a subtype is semantically a subset has been used in an attempt to explain subtyping in programming languages with higher order types by Cardelli and Wegner <ref> [CW85, Page 490] </ref>. For certain languages the ideal model [MS82] cited by Cardelli and Wegner, has a rich enough structure to accommodate this explanation. But for Cardelli and Wegner's language, the ideal model is not sound [BL88].
Reference: [EM85] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: Algebras are presented first, followed by simulation relations. 2.1 Algebraic Models The algebras defined below are an extension of the usual algebraic structures found in the study of equational logic or algebraic specifications <ref> [EM85] </ref>. As such an algebra includes a carrier set and a set of specification functions; to these are added a set of program operations. <p> Let A be a -algebra. Then the 0 -reduct of A is the algebra A ( 0 ) = @ fT A j T 2 SORTS 0 g; ff A j f 2 SFUNS 0 g; fg A j g 2 POPS 0 g 1 <ref> [EM85, Section 6.8] </ref>. That is, A ( 0 ) has as its carrier sets the carrier sets of the sorts in A that appear in 0 , and as its specification functions and program operations those named in 0 . <p> The substitution property for specification functions is the key to the proof that simulation is preserved by all assertions and the soundness of the modular program verification techniques described in Chapter 6. A substitution property is also used to define homo-morphisms between multisorted algebras <ref> [EM85] </ref>. The substitution property defined above differs from the usual substitution property for multisorted algebras in two ways: it is a substitution property for relations instead of functions, and it allows relations among objects of different types. <p> This extension uses the specification functions of the algebra in the environment's range to evaluate specification function symbols and uses the environment itself to evaluate free identifiers <ref> [EM85, Section 1.10] </ref>. Let be a signature and A a -algebra. The notation means the extension of the -environment : X ! jAj to a mapping from terms that sort-check to elements of the carrier set of A.
Reference: [End72] <author> Herbert B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, Inc., </publisher> <address> Orlando, Florida, </address> <year> 1972. </year>
Reference-contexts: The specification functions are defined on carrier sets without ? because they are strict and their inverses are strict. A trait structure is thus a multi-sorted algebra, as used in the semantics of first-order logic <ref> [End72] </ref>. An algebra A satisfies the traits of a specification if and only if the trait structure of A is a model of those traits in the usual sense of models of first-order formulas in formal logic. <p> Since C [[1 2 s]] = true by the above definition, (C; ) j= 1 2 s. Since C [[4 2 s]] = false, (C; C ) does not model "4 2 s." The above definition of "models" specializes to the standard definition <ref> [End72] </ref> when the presumed sub type relation is equality (=). This follows trivially, since the only difference between the above definition and the standard definition is the notion of extended application.
Reference: [FGJM85] <author> Kokichi Futatsugi, Joseph A. Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <booktitle> Principles of OBJ2. In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1985. </year>
Reference-contexts: A mechanism to mediate between independently designed abstractions with fixed interfaces is a feature of several languages without message passing mecha nisms (e.g., OBJ2 <ref> [FGJM85] </ref>, Argus [LDH + 87], and Ada [Ada83]), where one can change the interface of a type parameter. In a language with a message passing mechanism, one wants to be able to change the interfaces of objects.
Reference: [GH78] <author> J. Guttag and J. J. Horning. </author> <title> The Algebraic Specification of Abstract Data Types. </title> <journal> Acta Informatica, </journal> <volume> 10(1) </volume> <pages> 27-52, </pages> <year> 1978. </year>
Reference-contexts: This is a practical benefit in specifications, since one does not have to specify carrier sets so carefully that there are no observably equivalent elements. Technically this means that one's specification of a carrier set does not have to be sufficiently complete <ref> [GH78] </ref>. The following example shows how subtyping based on homomorphic functions (Bruce and Wegner's def inition) fails to show a subtype relationship between two types that are observably equivalent. The example is adapted from a paper by Mitchell [Mit86, Page 266].
Reference: [GH86a] <author> J. V. Guttag and J. J. Horning. </author> <title> A Larch Shared Language Handbook. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 135-157, </pages> <year> 1986. </year>
Reference-contexts: Each trait describes the abstract values of a type; formally it specifies the carrier set and specification functions of a model. (Unless these traits are unconventional, they will be found in the Larch Shared Language Handbook <ref> [GH86a] </ref>.) The bulk of the specifications is taken up by program operation specifications. In what follows sets of type specifications will often be named. For example, the set of type specifications named II consists of the specifications IntSet found in Figure 1.1 and Interval found in Figure 1.2. <p> These traits introduce various sorts and operations, which become the sorts and specification function symbols, as renamed by the hrenamingi clause. The imported traits are from <ref> [GH86a] </ref>. However, the sort name following the keyword sort in the specification of a type named T is renamed to T. In the II example, there is an auxiliary sort Card that has no corresponding type. It is used in the specification of the program operation size.
Reference: [GH86b] <author> J. V. Guttag and J. J. Horning. </author> <title> Report on the Larch Shared Language. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 103-134, </pages> <year> 1986. </year>
Reference-contexts: Rather the specification functions are models of the functions used to precisely specify the abstract values of a type. Such specification in a trait. Algebraic equational specifications, called traits, are used to specify abstract values; these are written in the Larch Shared Language <ref> [GH86b] </ref>. To ensure that the assertions used in specifications have meaning when subtyping is used, specification functions are also polymorphic. In an algebra there is no separate representation for abstract values and objects. <p> The nonterminal symbols hspecification functioni, htypei, and hidentifieri represent specification function symbols, type symbols, and program operation symbols and other identifiers (re spectively). The nonterminal htermi is as in <ref> [GH86b] </ref>; in addition, terms of the form e 1 = e 2 are allowed. However, in specifications, equality (=) may only be used between terms of visible sort; such terms are called subtype-constraining. <p> Since the type PSchd is generated by the specification function h#; #i, we can write these empty PSchd objects in C as htrue; fgi, and hfalse; fgi. Since the type Crowd is generated by the specification functions fg and "insert" and is partitioned by 2 <ref> [GH86b] </ref>, there can only be one empty Crowd object in A, which can be denoted by fg.
Reference: [GHW85] <author> J. V. Guttag, J. J. Horning, and J. M. Wing. </author> <title> Larch in Five Easy Pieces. </title> <type> Technical Report 5, </type> <institution> Digital Systems Research Center, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: The specification language is adapted from Wing's interface specification language for CLU [Win83] [LG86, Chapter 10] <ref> [GHW85] </ref> [Win87] and Chen's Larch/Generic interface specification language [Che89]. However, unlike Wing, the specifications only deal with immutable types. The specification of a function or a program operation is written as if each argument and result has the specified type.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <type> Technical Report CSLI-87-92, </type> <institution> Center for the Study of Language and Information, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: Subtypes as Subsets. In Goguen's work, the signature of an order-sorted algebra has a partial order on sorts, called the subsort relation <ref> [GM87] </ref>. In an order-sorted algebra, if S is a subsort of T, then the carrier set of S must be a subset of the carrier set of T.
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1979. </year> <note> The second author is listed on the cover as Arthur J. Milner, which is clearly a mistake. </note>
Reference-contexts: In some languages the method dictionary is implicit in a type parameter, such as Int in the instantiation sort [Int] as one might write in CLU [LAB + 81] or Ada [Ada83]. In ML <ref> [GMW79] </ref>, type parameters are implicit, but one must pass the operations that would go in the method dictionary explicitly. The polymorphism that results from forms of overloading can also be explained by method dictionaries [WB89]. <p> inBoth (create (Interval,1,4), create (Interval,2,5)) fi letrec testForML (i,s1,s2, choose,remove,elem) = if elem (s2, i) then i else testForML (choose (remove (s1,i)), remove (s1,i), s2, choose, remove, elem) ;; let inBothML (s1,s2,choose,remove,elem) = testForML (choose (s1), s1, s2, choose, remove, elem) ;; in ML. with static polymorphism, such as ML <ref> [GMW79] </ref>.
Reference: [Gog84] <author> Joseph A. Goguen. </author> <title> Parameterized Programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: The standard technique is to specify a polymorphic module by specifying the behavior of the method dictionary that the polymorphic module needs to do its work [Gut80, Page 21] [Win83, Section 4.2.3] <ref> [Gog84, Page 537] </ref>. For example, roughly following Goguen, one might specify the function inBoth as in Figure 1.7.
Reference: [Gol84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1984. </year>
Reference-contexts: A related problem is how to aid the reuse of designs. In an object-oriented programming environment there tend to be many, many abstract data types (for exam ple, [GR83] describe at least 78 types that are built-in to Smalltalk-80). Sophisticated object-oriented pro gramming environments (e.g., <ref> [Gol84] </ref>) often provide ways to navigate or browse the code for classes that implement abstract data types. However, a designer is not primarily interested in code or subclass relationships | designers are interested in type specifications.
Reference: [Goo75] <author> J. B. Goodenough. </author> <title> Exception Handling: Issues and a Proposed Notation. </title> <journal> Communications of the ACM, </journal> <volume> 18(12) </volume> <pages> 683-696, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: A (fg) def Or the normal case may be made more deterministic, for example returning only the least element of the argument set. 3.3 Specifying Types with Exceptions Instead of specifying operations with non-trivial preconditions or arbitrarily defining a result, one often wishes a program operation to signal an exception <ref> [Goo75] </ref>. A programming language can define a mechanism to handle exceptions that arise while executing an invocation, as is done in CLU [LS79] and Trellis/Owl. For simplicity, whenever exceptions are discussed, all operations of an algebra are thought of as returning OneOf objects.
Reference: [Gr79] <author> George Gratzer. </author> <title> Universal Algebra. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1979. </year>
Reference-contexts: A well-ordered set is a totally-ordered set such that every non-empty subset has a least element <ref> [Gr79, Page12] </ref>. The elements of a 81 sequence form a chain and conversely the elements of a chain can be placed in a sequence. Definition C.1.3 (continuous).
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: An important way that one can enhance the functionality of a system is by adding new types of objects. The message passing mechanism of an object-oriented programming language such as Smalltalk-80 <ref> [GR83] </ref>, C++ [Str86], the Common LISP Object System (CLOS) [Kee89], or Simula 67 [BDMN73], can eliminate the need to up date code to work with objects of new types [Cox86], because it separates the manipulation of an object from knowledge of the object's type. <p> The main problem then, is to design modular methods for specifying and verifying programs that use message passing and subtype polymorphism. A related problem is how to aid the reuse of designs. In an object-oriented programming environment there tend to be many, many abstract data types (for exam ple, <ref> [GR83] </ref> describe at least 78 types that are built-in to Smalltalk-80). Sophisticated object-oriented pro gramming environments (e.g., [Gol84]) often provide ways to navigate or browse the code for classes that implement abstract data types. <p> A type system that ensures obedience to a subtype relation can thus aid verification by automating the verification of obedience. 1.3 Related Work Informal treatments of object-oriented programming discuss the notion of a "protocol", which can be thought of as a specification of how an object responds to messages <ref> [GR83] </ref>. More refined treatments of this idea cast the notion of a protocol as an abstract data type specification and the notion that the protocol of one type "fits" the protocol of another type as a subtype relationship. <p> To supply Smalltalk-80 programs with a notion of nominal type, one can annotate one's programs with this information. The Smalltalk-80 programs in Goldberg and Robson's book <ref> [GR83] </ref> already follow a convention of putting type information into variable names to aid understanding. There are two ways to force expressions to obey a subtype relation: dynamic or static checking.
Reference: [Gut80] <author> John Guttag. </author> <title> Notes on Type Abstractions (Version 2). </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):13-23, </volume> <month> January </month> <year> 1980. </year> <title> Version 1 in Proceedings Specifications of Reliable Software, </title> <address> Cambridge, Mass., </address> <publisher> IEEE, </publisher> <month> April, </month> <year> 1979. </year>
Reference-contexts: An obvious approach to the modular reasoning problem is to adapt standard techniques for reasoning about polymorphic program modules. The standard technique is to specify a polymorphic module by specifying the behavior of the method dictionary that the polymorphic module needs to do its work <ref> [Gut80, Page 21] </ref> [Win83, Section 4.2.3] [Gog84, Page 537]. For example, roughly following Goguen, one might specify the function inBoth as in Figure 1.7.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: A verification technique is sound if whenever one concludes by using that technique that a program satisfies its specification then that program does indeed satisfy its specification. The soundness proof follows the presentation of the logic below. 6.1 A Hoare Logic for NOAL The Hoare logic <ref> [Hoa69] </ref> of NOAL programs is a total correctness logic. That is, specifications require termination whenever their pre-condition is met. <p> rule [isDef ] says that to prove that an isDef? expression halts (with value true), one must prove that all the possible results of the ar gument expression are proper. * The general inference rule [conseq] is standard for Hoare logics, where it is often called the "rule of consequence" <ref> [Hoa69] </ref>. It allows one to use a stronger pre-condition and a weaker post-condition. The implications that appear in the hypothesis must be provable from the traits of the referenced specification, using the proof rules and axioms of those traits.
Reference: [Hud89] <author> Paul Hudak. </author> <title> Conception, Evolution, and Application of Functional Programming Languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: For example, in a language where arithmetic operators like + can mean either integer or floating-point operations, one can write expressions such as a+b, and the compiler determines which method dictionary (integer or float) to consult for the meaning of +. The functional language Haskell <ref> [Hud89] </ref> allows a function with body a+b to be applied to arguments of different types; such a procedure is passed a method dictionary that gives meaning to the overloaded operations.
Reference: [JL76] <author> Anita K. Jones and Barbara H. Liskov. </author> <title> A Language Extension for Controlling Access to Shared Data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(4):277-285, </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: In a language with a message passing mechanism, one wants to be able to change the interfaces of objects. The ability to change object interfaces could also be exploited to provide access control for objects <ref> [JL76] </ref> [JL78]. 72 Chapter 9 Summary and Conclusions A high-level summary of results and their significance is offered in this chapter, as well as some conclusions about programming and programming language design. 9.1 Summary of Results The two main results in this report are a new definition of subtype relations and
Reference: [JL78] <author> Anita K. Jones and Barbara H. Liskov. </author> <title> A Language Extension for Expressing Constraints on Data Access. </title> <journal> Communications of the ACM, </journal> <volume> 21(5) </volume> <pages> 358-367, </pages> <month> May </month> <year> 1978. </year>
Reference-contexts: In a language with a message passing mechanism, one wants to be able to change the interfaces of objects. The ability to change object interfaces could also be exploited to provide access control for objects [JL76] <ref> [JL78] </ref>. 72 Chapter 9 Summary and Conclusions A high-level summary of results and their significance is offered in this chapter, as well as some conclusions about programming and programming language design. 9.1 Summary of Results The two main results in this report are a new definition of subtype relations and new
Reference: [JM88] <author> Lalita A. Jategaonkar and John C. Mitchell. </author> <title> ML with Extended Patterm Matching and Subtypes (preliminary version). </title> <booktitle> In ACM Conference on LISP and Functional Programming, Snowbird, Utah, </booktitle> <pages> pages 198-211, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: This would probably pose no great problems for reasoning. However, such an extension is left for future work. A different approach to these problems in the context of record types is illustrated in the work of Jate gaonkar and Mitchell on ML <ref> [JM88] </ref> and Cardelli and Mitchell [CM89]. 3.5.2 Loss of Type Information for Subtype Results The specification language cannot express certain constraints on the type of the value returned by a func tion.
Reference: [Jon86] <author> Cliff B. Jones. </author> <title> Program Specification and Verification in VDM. </title> <type> Technical Report 89 UMCS-86-10-5, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> November </month> <year> 1986. </year>
Reference-contexts: There are also some syntactic constraints on subtype relationships. Abstract types are described by specifications that describe a set of abstract values and how the operations behave on objects with different abstract values. Such two-tiered [Win87] or abstract-model style <ref> [Jon86] </ref> specifications allow one to specify types incompletely, including types that are not intended to be implemented directly (e.g., deferred types in Eiffel [Mey88]). Such specifications also allow one to specify operations that may fail to terminate or that are nondeterministic.
Reference: [Kee89] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference-contexts: An important way that one can enhance the functionality of a system is by adding new types of objects. The message passing mechanism of an object-oriented programming language such as Smalltalk-80 [GR83], C++ [Str86], the Common LISP Object System (CLOS) <ref> [Kee89] </ref>, or Simula 67 [BDMN73], can eliminate the need to up date code to work with objects of new types [Cox86], because it separates the manipulation of an object from knowledge of the object's type. <p> In what follows, a slightly more general notation will be used for message passing. That is, ins (s,e) will mean sending the message ins to s and e. The exact procedure that is invoked will depend on the types of both objects, s and e, as in CLOS <ref> [Kee89] </ref>. Often it will be appropriate to think of ins (s,e) as sending the message ins with argument e to the object denoted by s.
Reference: [LAB + 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheifler, and Alan Snyder. </author> <title> CLU Reference Manual, </title> <booktitle> volume 114 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: ensures i = leastElement (s) op size (s:Interval) returns (i:Int) ensures i = toInt (size (s)) op remove (s:Interval, i:Int) returns (r:IntSet) ensures r == delete (s,i) 1.1.1 The Code Update Problem The code update problem is demonstrated by the function inBothCLU of Figure 1.3, which is written in CLU <ref> [LAB + 81] </ref>. If the IntSet arguments of inBothCLU have an element in common, then the function returns an integer in their intersection (see Figure 1.6 for a specification). The notation IntSet$choose in a CLU program means the choose operation of the module that implements IntSet. <p> In some languages the method dictionary is implicit in a type parameter, such as Int in the instantiation sort [Int] as one might write in CLU <ref> [LAB + 81] </ref> or Ada [Ada83]. In ML [GMW79], type parameters are implicit, but one must pass the operations that would go in the method dictionary explicitly. The polymorphism that results from forms of overloading can also be explained by method dictionaries [WB89]. <p> For simplicity, whenever exceptions are discussed, all operations of an algebra are thought of as returning OneOf objects. A OneOf type is like the variant or discriminated union types that appear in some programming lan guages, such as CLU <ref> [LAB + 81] </ref>. <p> 3 == o 1 ) = (toNE (o 1 ) == o 3 ) toNE (make normal (i)) = make normal (i) exempts for all [i: Int] val empty (make normal (i)) 34 operations that observe instances, one could have a programming language with built-in expressions for observing OneOf instances <ref> [LAB + 81, Section 11.6] </ref> [CW85] [Car84]; however, it seems best to keep the type specification independent of the programming language by making the programming language's expressions syntactic sugar for operation invocations.
Reference: [LaL89] <author> Wilf R. LaLonde. </author> <title> Designing Families of Data Types Using Exemplars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 212-248, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: If E is defined by inheritance from a class D, then E is called a subclass of D. Subclasses should not be confused with subtypes [Sny86b] [LTP86] [Lis88] <ref> [LaL89] </ref>, as a subclass relationship is a purely implementation relationship, while a subtype relationship is a relationship among abstract data types (i.e., among specifications). In general, a subclass does not implement a subtype and a subtype need not be implemented by a subclass. <p> Liskov has described how subtype relationships can be used during design to record decisions that refine type specifications, to localize the effects of changes to type specifications, and to group and classify types [Lis88]. LaLonde also uses subtype relationships as a means of classifying types by behavior [LTP86] <ref> [LaL89] </ref>. However, neither Liskov nor LaLonde give a formal definition of subtype relationships. Some semi-formal specification and verification techniques appear in Meyer's book on Eiffel [Mey88, Chapter 7]. Assertions in Eiffel are written using program operations. Meyer gives specifications for operations using assertions for pre- and post-conditions.
Reference: [LDH + 87] <author> Barbara Liskov, Mark Day, Maurice Herlihy, Paul Johnson, Gary Leavens, Robert Scheifler, and William Weihl. </author> <title> Argus Reference Manual. </title> <type> Technical Report 400, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> October </month> <year> 1987. </year> <note> An earlier version appeared as Programming Methodology Group Memo 54 in March 1987. </note>
Reference-contexts: A mechanism to mediate between independently designed abstractions with fixed interfaces is a feature of several languages without message passing mecha nisms (e.g., OBJ2 [FGJM85], Argus <ref> [LDH + 87] </ref>, and Ada [Ada83]), where one can change the interface of a type parameter. In a language with a message passing mechanism, one wants to be able to change the interfaces of objects.
Reference: [Lea88] <author> Gary T. Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> December </month> <year> 1988. </year> <note> Published as MIT/LCS/TR-439 in February 1989. </note>
Reference: [Lea89] <author> Gary T. Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <title> The author's Ph.D. </title> <type> thesis. </type>
Reference-contexts: Hence Interval is a subtype of IntSet. A modular specification and verification technique for reasoning about message passing programs can be based on the concepts of subtype relationships and nominal type, as pioneered in my dissertation <ref> [Lea89] </ref> 5 and further developed in [LW90]. <p> So at run-time the operation invoked is not the choose operation from the method dictionary associated with instances of IntSet, written IntSet.choose in the figure, but 4 Coercing the abstract values of arguments, as in <ref> [Lea89] </ref>, seems to be inferior to this approach. 6 instead the operation Interval.choose. The prob-lem is that Interval.choose might not satisfy the specification used during program verification, since the Interval.choose operation has different pre- and post-conditions than IntSet.choose. <p> the verifier must also ensure that the specified subtype relation satisfies the semantic constraints described above. (Verification of the implementation of classes is outside the scope of this report.) Besides the semantic constraints on the specified subtype relation, type checking is necessary to ensure soundness of this 8 verification technique <ref> [Lea89] </ref>, because it is assumed during verification that identifiers denote objects of their (statically) declared types. <p> Incomplete specifications are important in practical designs, since they leave implementation decisions open. Furthermore, the models must have carrier sets that are reduced (in the sense that distinct abstract values do not behave similarly), since otherwise there might not be a coercion function with the substitution property <ref> [Lea89, Section 5.4.3] </ref>. <p> As may be seen from the above, several simplifying assumptions are made in this report. Only designs with immutable types are considered, and verification is only considered for an applicative object-oriented language. Thus the report represents a second step (after <ref> [Lea89] </ref>) towards general reasoning techniques for programs that use message passing and subtype polymorphism. 10 Chapter 2 Algebraic Models and Simulation Relations In this chapter the semantics of sets of type specifications, sets of algebraic models, and simulation relations between these models are discussed. <p> More restrictive is the requirement that the specification functions also apply to presumed sub-types. Thus if one wishes to specify a subtype, one must define all the trait functions of the presumed su-pertype on the abstract values. In <ref> [Lea89] </ref>, there was no such restriction, but its lack lead to strong restrictions on the kinds of assertions that one could write in a specification. <p> Hence, even though these two terms are logically equivalent for sets, they are not equivalent when used in a specification. This problem is much like those that arise when reasoning about nonstandard models of sets. The problem is avoided by requiring that assertions in specifications be subtype constraining. In <ref> [Lea89] </ref>, the requirements on assertions were even stronger, as one had to use "program observable" assertions in specifications. The requirement of program observability is more severe, since it may restrict how specifications can be written. These problems are illustrated by the following example, suggested by W. Weihl (personal communication, 1989). <p> Cardelli's rule for OneOf types is that a OneOf with fewer tags is a subtype of a OneOf type with more tags, provided the corresponding fields were in the subtype relation. The example below thus shows that each instance of Cardelli's rule is a subtype relation. (See <ref> [Lea89] </ref> for an a similar comparison with immutable record types.) A specification of the type OneOf [normal:Int, empty:Null] is given in Figure 4.2, where the type name is abbreviated to NE. This abbreviation will also be used in the rest of this chapter. <p> The great advantage of nondeterminism and incomplete specifications is that they allow the specifier more freedom. In contrast to my dissertation <ref> [Lea89] </ref>, observations are not used to define subtype relations. Some of the reasons for this change have already been mentioned. A detailed discussion of the relation of the definition of subtype relations given above to the one in [Lea89] is found in Chapter 7. <p> In contrast to my dissertation <ref> [Lea89] </ref>, observations are not used to define subtype relations. Some of the reasons for this change have already been mentioned. A detailed discussion of the relation of the definition of subtype relations given above to the one in [Lea89] is found in Chapter 7. For now, it is enough to know that the definition of subtype relations found in [Lea89] is weaker than that given here. <p> A detailed discussion of the relation of the definition of subtype relations given above to the one in <ref> [Lea89] </ref> is found in Chapter 7. For now, it is enough to know that the definition of subtype relations found in [Lea89] is weaker than that given here. Formal work on the question of when one type is a subtype of another can be roughly divided into two camps: algebraic model theory and type theory. The work of Ait-Kaci [AK84] falls outside this classification. <p> Formally, NOAL programs manipulate the algebras described in Chapter 2. The identifiers in a NOAL program denote objects in the carrier set of an algebra. The message passing (or dynamic binding) mechanism is modeled by the algebra itself (in con trast to <ref> [Lea89] </ref>). The set of possible results of a message send is determined by consulting the appropriate operation of an algebra. The semantics of NOAL programs makes certain mild assumptions about algebras. <p> For example, q might imitate r with respect to programs that only observe them by using the message size, yet q might not imitate r with respect to all NOAL programs. This context dependence allows one to investigate notions of subtyping appropriate for particular languages or language subsets <ref> [Lea89] </ref>. <p> M [[P ]](A; 1 ), there is some r 2 M [[P ]](B; 2 ) such that q = r; that is, Therefore (A; 1 ) imitates (B; 2 ) with respect to the set of type-safe NOAL programs. 7.3 A Weaker Definition of Subtyping based on Imitation As in <ref> [Lea89] </ref>, it is possible to give a weaker definition of subtype relations based on imitation. The advantage of the following notion of "weak subtyping" is that it is dependent on a set of observations, and can 68 thus be tailored more exactly to a given programming language. <p> Therefore, such an algebra-environment pair does not imitate a nominal algebra-environment pair, and hence this is not a weak subtype relation. As with the standard definition of subtype relations, weak subtypes can be more deterministic and incompletely specified supertypes can be handled <ref> [Lea89, Section 5.1] </ref>. Like the imitates relation, whether a binary relation on types is a weak subtype relation varies with the observations one makes. As a trivial example, every binary relation on types is a weak subtype relation with respect to the empty set of observations. <p> So if an error can be revealed by testing, then there is some implementation of the types explicitly used in the program that can reveal it. 7.5.2 Comparing the two Notions of Subtyp ing The notions of imitation and weak subtyping play a crucial role in my dissertation <ref> [Lea89] </ref>, where weak subtype relations are called subtype relations.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: An object-oriented design (as opposed to a program) consists of procedure and abstract data type specifications that, when implemented and put together, will satisfy the system's requirements <ref> [LG86, Page 265] </ref>. The implementation of a procedure or abstract data type specification may itself be guided by a lower-level design. An abstract data type is specified by describing a set of objects (the instances of that type) and how those objects behave when manipulated by the type's operations. <p> The specification language is adapted from Wing's interface specification language for CLU [Win83] <ref> [LG86, Chapter 10] </ref> [GHW85] [Win87] and Chen's Larch/Generic interface specification language [Che89]. However, unlike Wing, the specifications only deal with immutable types. The specification of a function or a program operation is written as if each argument and result has the specified type.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 214-223, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: A class operation is typically used to create instances of a type and is not one of the operations 5 Some object-oriented programming languages do not have classes, but are based on a notion of delegation <ref> [Lie86] </ref> [SLU89]. In such systems one can still speak of an object's instance operations (the set of messages to which it responds), even though there are no classes and class operations.
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Data Abstraction and Hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year> <note> Revised version of the keynote address given at OOPSLA '87. </note>
Reference-contexts: If E is defined by inheritance from a class D, then E is called a subclass of D. Subclasses should not be confused with subtypes [Sny86b] [LTP86] <ref> [Lis88] </ref> [LaL89], as a subclass relationship is a purely implementation relationship, while a subtype relationship is a relationship among abstract data types (i.e., among specifications). In general, a subclass does not implement a subtype and a subtype need not be implemented by a subclass. <p> Subtype relationships are also useful for organizing the specifications of abstract data types. Liskov has described how subtype relationships can be used during design to record decisions that refine type specifications, to localize the effects of changes to type specifications, and to group and classify types <ref> [Lis88] </ref>. LaLonde also uses subtype relationships as a means of classifying types by behavior [LTP86] [LaL89]. However, neither Liskov nor LaLonde give a formal definition of subtype relationships. Some semi-formal specification and verification techniques appear in Meyer's book on Eiffel [Mey88, Chapter 7]. <p> Subtype relations are useful during program design, where they can help track the evolution of abstractions, limit the effects of specification changes, and group and classify related types <ref> [Lis88] </ref>. In a system like Smalltalk-80 where classes are also objects, subtype relationships among the types of classes (metatypes) can also be used in similar ways. Subtype relations can be used to write polymorphic specifications and to support careful reasoning.
Reference: [LL85] <author> Gary T. Leavens and Barbara Liskov. </author> <title> The Name Clash Problem and a Proposed Solution. DSG Note 130, </title> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> October </month> <year> 1985. </year>
Reference-contexts: For example, it is not yet known what features of an inheritance mechanism help or hinder verification. A more modest language design project would be to solve the name-clash (or interface control) problem for languages with message passing mechanisms <ref> [LL85] </ref>. In a language with message passing, each object's instance operations form a behavioral interface that is analogous to the behavioral interface of an abstract type. However, in all languages with message passing mechanisms, there is no way to change an object's interface.
Reference: [LS79] <author> Barbara H. Liskov and Alan Snyder. </author> <title> Exception Handling in CLU. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(6):546-558, </volume> <month> November </month> <year> 1979. </year>
Reference-contexts: A programming language can define a mechanism to handle exceptions that arise while executing an invocation, as is done in CLU <ref> [LS79] </ref> and Trellis/Owl. For simplicity, whenever exceptions are discussed, all operations of an algebra are thought of as returning OneOf objects. A OneOf type is like the variant or discriminated union types that appear in some programming lan guages, such as CLU [LAB + 81].
Reference: [LTP86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An Exemplar Based Smalltalk. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 322-330, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: If E is defined by inheritance from a class D, then E is called a subclass of D. Subclasses should not be confused with subtypes [Sny86b] <ref> [LTP86] </ref> [Lis88] [LaL89], as a subclass relationship is a purely implementation relationship, while a subtype relationship is a relationship among abstract data types (i.e., among specifications). In general, a subclass does not implement a subtype and a subtype need not be implemented by a subclass. <p> Liskov has described how subtype relationships can be used during design to record decisions that refine type specifications, to localize the effects of changes to type specifications, and to group and classify types [Lis88]. LaLonde also uses subtype relationships as a means of classifying types by behavior <ref> [LTP86] </ref> [LaL89]. However, neither Liskov nor LaLonde give a formal definition of subtype relationships. Some semi-formal specification and verification techniques appear in Meyer's book on Eiffel [Mey88, Chapter 7]. Assertions in Eiffel are written using program operations. Meyer gives specifications for operations using assertions for pre- and post-conditions.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-oriented Programs that use Subtypes (extended abstract). </title> <type> Technical Report 90-03, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> March </month> <year> 1990. </year> <note> To appear in ECOOP/OOPSLA '90. </note>
Reference-contexts: Hence Interval is a subtype of IntSet. A modular specification and verification technique for reasoning about message passing programs can be based on the concepts of subtype relationships and nominal type, as pioneered in my dissertation [Lea89] 5 and further developed in <ref> [LW90] </ref>.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Such two-tiered [Win87] or abstract-model style [Jon86] specifications allow one to specify types incompletely, including types that are not intended to be implemented directly (e.g., deferred types in Eiffel <ref> [Mey88] </ref>). Such specifications also allow one to specify operations that may fail to terminate or that are nondeterministic. Because type specifications may be incomplete, they may have many different implementations with differing behavior. <p> LaLonde also uses subtype relationships as a means of classifying types by behavior [LTP86] [LaL89]. However, neither Liskov nor LaLonde give a formal definition of subtype relationships. Some semi-formal specification and verification techniques appear in Meyer's book on Eiffel <ref> [Mey88, Chapter 7] </ref>. Assertions in Eiffel are written using program operations. Meyer gives specifications for operations using assertions for pre- and post-conditions. There is some discussion of loop invariants and variants, but Meyer does not give a formal logic for program verification. <p> A and B is a subclass of A, then the pre-condition of r in the specification of B may be no stronger than the pre-condition of r in A, and the post-condition of r in the specification of B must be no weaker than the post-condition of r in A <ref> [Mey88, Page 256] </ref>. This condition is intended to ensure that the implementation of an operation in a subclass (B), satisfies the specification of that operation in the su-perclass (A). <p> to itself constructed from the specification as 2 Some researchers (e.g., [SCW85, Page 42] [Sym84, Page 450]) call a type or class that cannot be instantiated "abstract," but this leads to confusion with the term "abstract data type." In Eiffel, operations that are not implemented are said to be "deferred" <ref> [Mey88] </ref>. 36 Vehicle virtual type instance ops [wheels, passengers] based on sort C from VehicleTrait op wheels (v:Vehicle) returns (i:Int) ensures i = wheels (v) op passengers (v:Vehicle) returns (i:Int) ensures i = passengers (v) Bicycle immutable type subtype of Vehicle by s R makeVehicle (2,1) class ops [new] instance ops <p> One approach to such a result is to work with implications between the pre- and post-conditions of operation specifications (and invariants), following the lead of Meyer <ref> [Mey88] </ref> or America [Ame89]. It might also be useful to have a proof-theoretic definition of subtype relations.
Reference: [Mit86] <author> John C. Mitchell. </author> <title> Representation Independence and Data Abstraction (preliminary version). </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 263-276. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Simulation relations resemble the "logical relations" used in the study of the lambda calculus [Sta85] <ref> [Mit86] </ref>. An important property of logical relations is captured by the so-called fundamental theorem of logical relations [Sta85], which states that simulation is preserved by expressions. The substitution property is similar to the defining property of Nipkow's simulation relations [Nip86]. <p> The following example shows how subtyping based on homomorphic functions (Bruce and Wegner's def inition) fails to show a subtype relationship between two types that are observably equivalent. The example is adapted from a paper by Mitchell <ref> [Mit86, Page 266] </ref>. Let the types S1 and S2 represent multi-sets of integers (i.e., bags of integers). Since neither Reynolds nor Bruce and Wegner deal with specifications, one may choose a particular model. <p> For a given algebra, the denotation of a NOAL function is a mapping from tuples of arguments to sets of possible results. Such mappings are related by analogy to the definition of logical relations [Sta85] <ref> [Mit86] </ref>.
Reference: [MS82] <author> D. B. MacQueen and Ravi Sethi. </author> <title> A Semantic Model of Types for Applicative Languages. </title> <booktitle> In ACM Symp. on LISP and Functional Programming, </booktitle> <pages> pages 243-252. </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: The idea that a subtype is semantically a subset has been used in an attempt to explain subtyping in programming languages with higher order types by Cardelli and Wegner [CW85, Page 490]. For certain languages the ideal model <ref> [MS82] </ref> cited by Cardelli and Wegner, has a rich enough structure to accommodate this explanation. But for Cardelli and Wegner's language, the ideal model is not sound [BL88].
Reference: [Nip86] <author> Tobias Nipkow. </author> <title> Non-deterministic Data Types: Models and Implementations. </title> <journal> Acta Informatica, </journal> <volume> 22(16) </volume> <pages> 629-661, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: To model nondeterministic procedures, the program operations of an algebra are set-valued functions; that is, a program operation returns the set of the possible results of the corresponding procedure <ref> [Nip86] </ref> [Nip87]. The special value ? is used to model procedure calls that do not halt or that encounter run-time errors. <p> An important property of logical relations is captured by the so-called fundamental theorem of logical relations [Sta85], which states that simulation is preserved by expressions. The substitution property is similar to the defining property of Nipkow's simulation relations <ref> [Nip86] </ref>. The difference is that we provide for message passing (through program operations) and allow objects of one type to be related to objects of another type. Simulation relations are also similar to, but more general than, the coercer functions of Reynolds [Rey80] [Rey85] and Bruce and Wegner [BW87a]. <p> It is an applicative language since it has no notion of assignment or mutation. It is nondeterministic so that the claims that subtyping does not allow surprising behavior to be observed will be strong, as only a language with nondeterminism can make certain observations <ref> [Nip86] </ref>. It is object-oriented because it has a message passing mechanism. The language NOAL is a hybrid of Trellis/Owl [SCB + 86] and Broy's AMPL [Bro86]. NOAL resembles AMPL in that it is a lambda calculus with explicit facilities for nondeterminism.
Reference: [Nip87] <author> Tobias Nipkow. </author> <title> Behavioural Implementation Concepts for Nondeterministic Data Types. </title> <type> PhD thesis, </type> <institution> University of Manchester, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: To model nondeterministic procedures, the program operations of an algebra are set-valued functions; that is, a program operation returns the set of the possible results of the corresponding procedure [Nip86] <ref> [Nip87] </ref>. The special value ? is used to model procedure calls that do not halt or that encounter run-time errors. <p> An operation is strict if whenever one of its arguments is ?, then the only possible result is ?. Specification functions are strict. However, non-strict program operations are useful for modeling types with lazy evaluation, such as streams. Operations and algebras can be classified as follows <ref> [Nip87, Page 9] </ref>. An operation is total if whenever all its arguments are proper (i.e., not ?), then no possible result is ?. Thus each specification function is total. An operation that is not total is partial.
Reference: [Par72] <author> D. L. Parnas. </author> <title> On the Criteria to be Used in Decomposing Systems into Modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: Modularity means the separation of code into modules that have few and well-defined interactions with each other. Modules can be used to hide design decisions that may have to be changed at a later time <ref> [Par72] </ref>, allowing one to view a system's design at many different levels of detail. This aids the construction of software systems as well as their maintenance, since when a design decision is changed, only one module should need to be changed. <p> If the design has made careful use of abstract data types, then it will be relatively easy to change design decisions, especially decisions about the data structures used to represent objects <ref> [Par72] </ref>.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year> <month> 90 </month>
Reference-contexts: Such syntactic restrictions have been formalized, for example, in Reynolds's category sorted algebras <ref> [Rey80] </ref> [Rey85]. What is novel is that modularity of specifications results from the requirement that the specification functions applicable to a supertype be applicable to sub-types. <p> But the operations of D are not implemented, so the assertions that are used to define these operations are meaningless. Reynolds has studied partial orders on types in the setting of his category sorted algebras <ref> [Rey80] </ref> (see also [Rey85]). The semantic requirement that Reynolds imposes on the subtype relation are illustrated by the following example. Suppose Integer is a subtype of Float, a and b are objects of type Integer, and to Float is the coercion function from Integer to Float. <p> To more closely model the procedures of a class, the program operations of an algebra may be polymorphic. The treatment of polymorphism is based on techniques from Reynolds's category sorted algebras <ref> [Rey80] </ref>. Message passing is thus modeled by simply invoking a program operation. The specification functions have no counterpart in the classes that implement abstract types. Rather the specification functions are models of the functions used to precisely specify the abstract values of a type. Such specification in a trait. <p> Type specifications also determine the nominal signatures for each of the program operations of each type. From the nominal signature information is derived a function that predicts an upper bound (using ) of the result type of a program operation or specification function <ref> [Rey80] </ref>. Definition 2.1.1 (signature). <p> It is not necessarily antisymmetric. 11 * A partial function ResSort: OPS ; SORTS fl ! SORTS, which returns an upper bound on the result sort of a specification function or program operation symbol applied to a tuple of arguments with the given sorts. Following Reynolds <ref> [Rey80, Page 217] </ref>, ResSort must be monotone in the following sense: for all g 2 OPS , and for all tuples of sorts ~ S ~ T , if ResSort (g; ~ T ) is defined, then so is ResSort (g; ~ S ), and furthermore ResSort (g; ~ S ) <p> The same notation is also used for sorts. Notice that the definition of the program operations of an algebra is more general than the usual definition of an operation, since the program operations are polymorphic and possibly nondeterministic. The operations even generalize Reynolds' generic operators <ref> [Rey80] </ref>, in that the result returned may have some type other than the result type given by ResSort. <p> The difference is that we provide for message passing (through program operations) and allow objects of one type to be related to objects of another type. Simulation relations are also similar to, but more general than, the coercer functions of Reynolds <ref> [Rey80] </ref> [Rey85] and Bruce and Wegner [BW87a]. These au thors also require a substitution property. 18 Chapter 3 Polymorphic Type and Function Specifications In this chapter a new method for the modular specification of abstract types and polymorphic functions that use message passing is described. <p> That is, an expression with nominal type T can only denote an object whose type is a subtype of T. The notion of an expression's nominal type is similar to Reynolds's notion of the minimal type of an expression <ref> [Rey80] </ref> [Rey85]. The guarantee implicit in the nominal type of an expression can only be realized if the expression has a certain form. Hence not all expressions have a nominal type, only those that type-check. An expression (or program) that has a nominal type is called type-safe. <p> The nominal type of a message send is determined by the ResSort function, applied to the nominal types determined (recursively) for the arguments. The treatment of type checking is thus similar to Reynolds's <ref> [Rey80] </ref>. Like Reynolds, the type inference rules below assign a single nominal type, to each type-safe expression. This is in contrast type systems with a rule of subsumption, such as Cardelli's [Car84], where expressions have multiple types. <p> The proof of the obedience of expressions without function calls can be regarded as the source of some of the restrictions on signatures (compare with <ref> [Rey80] </ref>). The condition that be transitive comes from function calls, where the nominal type of a formal may be S, the nominal type of the actual may be S, and the type of the actual argument may be 0 .
Reference: [Rey85] <author> John C. Reynolds. </author> <title> Three Approaches to Type Structure. </title> <editor> In Hartmut Ehrig, Christiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: Such syntactic restrictions have been formalized, for example, in Reynolds's category sorted algebras [Rey80] <ref> [Rey85] </ref>. What is novel is that modularity of specifications results from the requirement that the specification functions applicable to a supertype be applicable to sub-types. Function and operation specifications are modular, because they are written as if the actual arguments had the specified types and do not explicitly mention subtypes. <p> But the operations of D are not implemented, so the assertions that are used to define these operations are meaningless. Reynolds has studied partial orders on types in the setting of his category sorted algebras [Rey80] (see also <ref> [Rey85] </ref>). The semantic requirement that Reynolds imposes on the subtype relation are illustrated by the following example. Suppose Integer is a subtype of Float, a and b are objects of type Integer, and to Float is the coercion function from Integer to Float. <p> The difference is that we provide for message passing (through program operations) and allow objects of one type to be related to objects of another type. Simulation relations are also similar to, but more general than, the coercer functions of Reynolds [Rey80] <ref> [Rey85] </ref> and Bruce and Wegner [BW87a]. These au thors also require a substitution property. 18 Chapter 3 Polymorphic Type and Function Specifications In this chapter a new method for the modular specification of abstract types and polymorphic functions that use message passing is described. <p> That is, an expression with nominal type T can only denote an object whose type is a subtype of T. The notion of an expression's nominal type is similar to Reynolds's notion of the minimal type of an expression [Rey80] <ref> [Rey85] </ref>. The guarantee implicit in the nominal type of an expression can only be realized if the expression has a certain form. Hence not all expressions have a nominal type, only those that type-check. An expression (or program) that has a nominal type is called type-safe. <p> So when observed by a type-safe program, instances of PSchd that are bound to identifiers of nominal type IntSet behave like instances of IntSet. Following Reynolds <ref> [Rey85] </ref>, type checking for NOAL programs is described by using a signature's result sort mapping, its presumed subtype relation, and the nominal signatures determined by the declarations of recursively defined functions. The nominal type of an expression is defined recursively.
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: This property will be useful in solving some of the specification and verification problems discussed below. Furthermore, a programming language's type system can statically enforce such limits on the use of polymorphic functions. For example, in Trellis/Owl <ref> [SCB + 86] </ref> and C++ type checking is based on a declared subtype relationship. <p> For example, in ML or Ada the types of arguments must be statically known. With subtype polymorphism, exact knowledge of method dictionaries can be postponed until run-time, but one may still do static type checking <ref> [SCB + 86] </ref>. * Programs may be more terse with subtype poly-morphism, since instance operations are implicitly associated with objects, and thus extra arguments can be suppressed. <p> The standard informal definition is that each object of the subtype must "behave like" some object of the supertype [Sny86b] <ref> [SCB + 86] </ref>. Informal definitions of subtype relationships, like the one given above are helpful but lack the precision needed to guide designers in determining when one type is a subtype of another. <p> The specification of a function or a program operation is written as if each argument and result has the specified type. However, actual arguments and results are allowed to have types that are subtypes of the specified types. This follows the practice of Trel lis/Owl <ref> [SCB + 86] </ref> and other typed object-oriented programming languages. An example is the specification of inBoth, found in Figure 1.6. <p> of Subtype Rela tionships Schaffert et al. offer the following informal definition of a subtype relationship: "Given a type S which is a subtype of a type T, then any object of type S behaves like a T object and may be used wherever a T object may be used" <ref> [SCB + 86, Section 5] </ref>. For types that are not incompletely specified, this definition seems to agree with the above definition of subtyping. <p> It is nondeterministic so that the claims that subtyping does not allow surprising behavior to be observed will be strong, as only a language with nondeterminism can make certain observations [Nip86]. It is object-oriented because it has a message passing mechanism. The language NOAL is a hybrid of Trellis/Owl <ref> [SCB + 86] </ref> and Broy's AMPL [Bro86]. NOAL resembles AMPL in that it is a lambda calculus with explicit facilities for nondeterminism. Like AMPL, NOAL is a first-order language; that is, functions are not objects in NOAL programs. NOAL resembles Trellis/Owl in its type system and message passing mechanism. <p> Instead of checking obedience with the Hoare logic, it is convenient to separate type checking from the rest of the verification problem. Separating type checking from verification allows the logic to be simpler than it would be otherwise. Furthermore, type checking can be mechanical, as in Trellis-Owl <ref> [SCB + 86] </ref>. The NOAL type system can ensure obedience of type-safe expressions over a specification SPEC if the conditions on signatures are met. <p> The NOAL type system can ensure obedience of type-safe expressions over a specification SPEC if the conditions on signatures are met. See Section 5.3. 6.5.2 Verification in Trellis/Owl It is easiest to use the Hoare-style verification techniques described above in a statically typed object-oriented programming language, such as Trellis/Owl <ref> [SCB + 86] </ref>. The Trellis/Owl type system was the inspiration for the NOAL type system, since it is static and based on nominal signatures and a declared subtype relation. Trellis/Owl limits presumed subtype relations to be partial orders, that is reflexive, transitive, and antisymmetric relations on types.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: </title>
Reference-contexts: It is a difficult problem to construct the least fixed points of systems of mutually recursive function definitions in NOAL. The construction of least fixed points is described in Appendix C. What follows are merely some informal explanations and examples. NOAL uses lazy evaluation for evaluating function arguments <ref> [Sch86, Page 181] </ref>; Broy calls the rule call-time-choice. Like call-by-name, call-time-choice uses delayed evaluation, hence functions written in NOAL need not be strict. However, each actual parameter is only evaluated once; hence formal parameters are not themselves sources of nondeterminism. <p> The following definition of a pointed complete partial order is taken from <ref> [Sch86, Page 111] </ref>. For a partially ordered set D, a subset Q of D is a chain if it is nonempty and for all q 1 ; q 2 2 Q, either q 1 v q 2 or q 2 v q 1 .
References-found: 63

