URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR55.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-misc.html
Root-URL: 
Email: weide,heym-@cis.ohio-state.edu  jholly@ius.indiana.edu  
Title: Reverse Engineering of Legacy Code is Intractable  
Author: Bruce W. Weide Wayne D. Heym Joseph E. Hollingsworth 
Note: Copyright 1994 by the authors. All rights reserved.  
Date: (October 1994)  
Address: Columbus, OH 43210  New Albany, IN 47150  
Affiliation: Department of Computer and Information Science The Ohio State University  Department of Computer Science Indiana University Southeast  
Pubnum: Technical Report OSU-CISRC-10/94-TR55  
Abstract: Reverse engineering of large legacy software systems is widely recognized to be a difficult problem. How bad is it? By an argument that identifies key underlying sources of the difficulty, reverse engineering of legacy code is shown to be intractable in the usual computational complexity sense. This conclusion implies that we should not be too enthusiastic about the ultimate value of reverse engineering as the centerpiece of a cost-effective approach to constructing new generations of systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Biggerstaff 94] <author> Biggerstaff, T.J., Mitbander, B.G., and Webster, D.E. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Comm. ACM 37, </journal> <month> 5 (May </month> <year> 1994), </year> <pages> 72-83. </pages>
Reference-contexts: seem to summarize nicely: A person understands a program when able to explain the program, its structure, its behavior, its effects on its operational context, and its relationships to its application domain in terms that are qualitatively different from the tokens used to construct the source code for the program. <ref> [Biggerstaff 94, p. 72] </ref> We insist that at least one hypothesis involved in successful reverse engineering should be useful in this sense. <p> This approach in which the hypotheses are generated by methods known variously <ref> [Ning 94, Biggerstaff 94] </ref> as concept recognition, plan identification, concept assignment, etc. seems to characterize most recent work on reverse engineering of legacy code.
Reference: [Cook 78] <author> Cook, S.A. </author> <title> Soundness and completeness of an axiom system for program verification. </title> <journal> SIAM J. Comp. </journal> <volume> 7, </volume> <month> 1 (Feb. </month> <year> 1978), </year> <pages> 70-90. 17 </pages>
Reference-contexts: However, engineering and implementing code that supports effective reasoning about behavior is more subtle than it appears at first [Neumann 93, Wilde 93]. Problems arise from coupling through side-effects and aliased variables <ref> [Cook 78, Harms 91, Weide 91] </ref>, arrays, pointers, and dynamic storage management [Hollingsworth 92, Ernst 94], generics [Ernst 91], inheritance [Leavens 90, Weber 92], and from many other sources.
Reference: [Chandrasekaran 93] <author> Chandrasekaran, B., Goel, A.K., and Iwasaki, Y. </author> <title> Functional representation as design rationale. </title> <booktitle> Computer 26, </booktitle> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 48-56. </pages>
Reference-contexts: The challenges in achieving understanding of a poorly understood system are to generate such hypotheses, which are in fact correct, and to establish why they are correct. Rephrasing slightly to reflect the connection with related work on program understanding <ref> [Littman 86, Chandrasekaran 93] </ref>, a reverse engineering project can be considered to include many instances of two subtasks: Making a hypothesis about the existence of particular functional components and their roles, especially causal relationships, in producing particular higher-level runtime behavior of the system.
Reference: [CSTB 90] <institution> Computer Science and Technology Board. Scaling up: a research agenda for software engineering. </institution> <note> Comm. ACM 33, </note> <month> 3 (Mar. </month> <year> 1990), </year> <pages> 281-293. </pages>
Reference-contexts: Specifically, we are disturbed that the emphasis has been on building tools to solve problems whose inherent complexity suggests that those tools cannot be expected to scale up to realistically large systems <ref> [CSTB 90] </ref>.
Reference: [Ernst 91] <author> Ernst, G.W., Hookway, R.J., Menegay, J.A., and Ogden, W.F. </author> <title> Modular verification of Ada generics. </title> <journal> Comp. Lang. </journal> <volume> 16, 3/4 (1991), </volume> <pages> 259-280. </pages>
Reference-contexts: However, engineering and implementing code that supports effective reasoning about behavior is more subtle than it appears at first [Neumann 93, Wilde 93]. Problems arise from coupling through side-effects and aliased variables [Cook 78, Harms 91, Weide 91], arrays, pointers, and dynamic storage management [Hollingsworth 92, Ernst 94], generics <ref> [Ernst 91] </ref>, inheritance [Leavens 90, Weber 92], and from many other sources. Potentially troublesome techniques are permitted by the programming languages used for real legacy systems because, in the interest of performance and other essential considerations, these techniques can be useful when applied carefully.
Reference: [Ernst 94] <author> Ernst, G.W., Hookway, R.J., and Ogden, W.F. </author> <title> Modular verification of data abstractions with shared realizations. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 20, </volume> <month> 4 (Apr. </month> <year> 1991), </year> <pages> 288-307. </pages>
Reference-contexts: However, engineering and implementing code that supports effective reasoning about behavior is more subtle than it appears at first [Neumann 93, Wilde 93]. Problems arise from coupling through side-effects and aliased variables [Cook 78, Harms 91, Weide 91], arrays, pointers, and dynamic storage management <ref> [Hollingsworth 92, Ernst 94] </ref>, generics [Ernst 91], inheritance [Leavens 90, Weber 92], and from many other sources. Potentially troublesome techniques are permitted by the programming languages used for real legacy systems because, in the interest of performance and other essential considerations, these techniques can be useful when applied carefully.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W. </author> <title> Copying and swapping: influences on the design of reusable software components. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <pages> 424-435. </pages>
Reference-contexts: However, engineering and implementing code that supports effective reasoning about behavior is more subtle than it appears at first [Neumann 93, Wilde 93]. Problems arise from coupling through side-effects and aliased variables <ref> [Cook 78, Harms 91, Weide 91] </ref>, arrays, pointers, and dynamic storage management [Hollingsworth 92, Ernst 94], generics [Ernst 91], inheritance [Leavens 90, Weber 92], and from many other sources.
Reference: [Hollingsworth 92] <author> Hollingsworth, </author> <title> J.E. Software Component Design-for-Reuse: </title>
Reference-contexts: clearly understood new systems, the central business is really upgrading poorly understood old systems. [Waters 94, p. 23] On the contrary, we hold that most software hasnt been written yet, 2 and that widely practiced modern approaches to the nuts-and-bolts of software engineering do not lead to well-designed new systems <ref> [Hollingsworth 92] </ref>. <p> However, engineering and implementing code that supports effective reasoning about behavior is more subtle than it appears at first [Neumann 93, Wilde 93]. Problems arise from coupling through side-effects and aliased variables [Cook 78, Harms 91, Weide 91], arrays, pointers, and dynamic storage management <ref> [Hollingsworth 92, Ernst 94] </ref>, generics [Ernst 91], inheritance [Leavens 90, Weber 92], and from many other sources. Potentially troublesome techniques are permitted by the programming languages used for real legacy systems because, in the interest of performance and other essential considerations, these techniques can be useful when applied carefully.
References-found: 8

