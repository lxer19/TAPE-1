URL: http://www.cs.bc.edu/~muller/postscript/tic97.ps
Refering-URL: http://www.cs.bc.edu/~muller/papers.html
Root-URL: http://www.cs.bc.edu
Email: fturbak@wellesley.edu  dimock@das.harvard.edu  muller@cs.bc.edu  jbw@dcs.gla.ac.uk  
Title: Compiling with Polymorphic and Polyvariant Flow Types  
Author: Franklyn Turbak Allyn Dimock Robert Muller J. B. Wells 
Date: June 3, 1997  
Address: College  College  Glasgow  
Affiliation: Wellesley  Harvard University  Boston  University of  
Abstract: Optimizing compilers for function-oriented and object-oriented languages exploit type and flow information for efficient implementation. Although type and flow information (both control and data flow) are inseparably intertwined, compilers usually compute and represent them separately. Partially, this has been a result of the usual polymorphic type systems using 8 and 9 quantifiers, which are difficult to use in combination with flow annotations. In the Church Project, we are experimenting with intermediate languages that integrate type and flow information into a single flow type framework. This integration facilitates the preservation of flow and type information through program transformations. In this paper we describe CIL , an intermediate language supporting polymorphic types and polyvariant flow information and describe its application in program optimiziation. We are experimenting with this intermediate language in a flow and type-directed compiler for a functional language. The types of CIL encode flow information (1) via labels that approximate sources and sinks of values and (2) via intersection and union types, finitary versions of universal and existential types that support type polymorphism and (in combination with the labels) polyvariant flow analysis. Accurate flow types expose opportunities for a wide range of optimizing program transformations. This paper is organized as follows. In section 1, we explain the background of the use of types and flow information in compilation and the motivation for our approach to combining types and flow information. In section 2, we present the language CIL as an example of a language with polymorphic and polyvariant flow types and give simple examples of how it can be used. Section 3 concludes with a discussion of research directions. 
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This sort of in-lining can be performed without any fancy flow analysis <ref> [TMC + 95, Tar96, App92] </ref>. However, in the presence of non-trivial flow patterns, such as the conditional argument to pfoldr in the definition of the function sums that chooses between two predicates, in-lining can require more sophisticated flow analyses and transformations.
Reference: [Ash96] <author> J. Michael Ashley. </author> <title> A practical and flexible flow analysis for higher-order languages. </title> <booktitle> In POPL '96 [POPL96], </booktitle> <pages> pages 195-207. </pages>
Reference-contexts: In languages making heavy used of higher-order functions or object methods, flow information can show global patterns that are not apparent from local structure. For example, flow analysis is used to guide function and method inlining [JW96, PC95], efficient function representations <ref> [WS94, Ash96] </ref>, the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages [Shi91, JW95]. <p> For example, flow analysis is used to guide function and method inlining [JW96, PC95], efficient function representations [WS94, Ash96], the detection of loops hidden in function calls <ref> [Ash96] </ref>, and type recovery and type check elimination in dynamically typed languages [Shi91, JW95]. <p> We are interested in analyses that use additional elements in virtual tuples to circumvent the limitations of shallow subtyping, and in implementing (and extending) polymorphic splitting [JW95]. There is also evidence that even crude flow analysis can be useful for program optimization <ref> [Ash96] </ref>.
Reference: [AW93] <author> Alexander S. Aiken and Edward L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In FPCA '93, Conf. Funct. Program. </booktitle> <publisher> Lang. Comput. Arch., </publisher> <pages> pages 31-41. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. It is not clear whether any work with constrained types has used a typed intermediate language. <p> However, link time optimizations remain a rich area for exploration. * Imperative Features: It is important to show that our techniques are still applicable in the context of features like references and exceptions. * Connections with Constrained Types We are currently exploring connections between flow types and constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. Our goal is to incorporate the polyvariant power of intersections and unions into the constrained type framework.
Reference: [AWL94] <author> Alexander S. Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In POPL '94 [POPL94], </booktitle> <pages> pages 163-173. </pages>
Reference-contexts: While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. It is not clear whether any work with constrained types has used a typed intermediate language. <p> However, link time optimizations remain a rich area for exploration. * Imperative Features: It is important to show that our techniques are still applicable in the context of features like references and exceptions. * Connections with Constrained Types We are currently exploring connections between flow types and constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. Our goal is to incorporate the polyvariant power of intersections and unions into the constrained type framework.
Reference: [Ban97] <author> Anindya Banerjee. </author> <title> A modular, polyvariant, and type-based closure analysis. </title> <booktitle> In ICFP '97 [ICFP97]. </booktitle> <pages> 9 </pages>
Reference-contexts: Moreover, recent work on flow analysis in higher-order typed languages suggests that there are some important synergies between flows and types in typed languages. For example, types can provide a basis for polyvariant flow analysis <ref> [Ban97, JWW97] </ref> that is more natural than the call string contours of the n-CFA approach [JWW97] (see for n-CFA). <p> Tang and Jouvelot track function flows via control flow effects annotating arrow types [Tan94, TJ94] Heintze use labelled types to show the equivalences between type systems and flow systems [Hei95]. Banerjee uses flow types in his combined approach to type inference and flow analysis <ref> [Ban97] </ref>. What is new about the flow type system of CIL is that the fine-grained flow distinctions afforded by intersection and union types makes it possible to express a wide range of polyvariant flow analyses. <p> The type inference system attaches only trivial flow labels to terms and types. These are replaced by more precise labels in a subsequent flow analysis pass. Our current flow analysis algorithm is patterned after the flow analysis component of Banerjee's combined type and flow inference system <ref> [Ban97] </ref>. The analysis in the current prototype is polyvariant, in that it analyzes each element of a virtual tuple separately. The analysis in the prototype is constrained by a naive implementation of the shallow subtyping rule in CIL . <p> A more aggressive approach is to perform additional analysis and transformations when modules are linked together. Recent techniques for performing flow analysis across module boundaries <ref> [TJ94, Ban97, FF97] </ref> indicate that flow types are not inherently incompatible with modular program organization.
Reference: [Ble93] <author> Guy E. Blelloch. Nesl: </author> <title> A nested data-parallel language. </title> <type> Technical Report CMU-CS-93-129, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Types can be used by compilers to guide data-representation decisions and program transformations for improved program performance. For example, in type-directed specialization, different copies of a polymorphic function or method are compiled for each type at which the polymorphic routine is used <ref> [Jon94, Ble93, CU89, PC95] </ref>. The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types [PJL91, Ler92, HJ94].
Reference: [CU89] <author> Craig Chambers and David Ungar. </author> <title> Iterative type analysis and extended message splitting. optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proc. ACM SIGPLAN '90 Conf. Prog. Language Design & Implementation, </booktitle> <year> 1989. </year>
Reference-contexts: Types can be used by compilers to guide data-representation decisions and program transformations for improved program performance. For example, in type-directed specialization, different copies of a polymorphic function or method are compiled for each type at which the polymorphic routine is used <ref> [Jon94, Ble93, CU89, PC95] </ref>. The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types [PJL91, Ler92, HJ94].
Reference: [Cur90] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> XEROX PARC, CSLPubs.parc@xerox.com, </note> <year> 1990. </year>
Reference-contexts: While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. It is not clear whether any work with constrained types has used a typed intermediate language. <p> However, link time optimizations remain a rich area for exploration. * Imperative Features: It is important to show that our techniques are still applicable in the context of features like references and exceptions. * Connections with Constrained Types We are currently exploring connections between flow types and constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. Our goal is to incorporate the polyvariant power of intersections and unions into the constrained type framework.
Reference: [DMTW97] <author> Allyn Dimock, Robert Muller, Franklyn Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed representation transformations. </title> <booktitle> In ICFP '97 [ICFP97]. </booktitle>
Reference-contexts: Intersection and union types are capable of expressing polymorphism and abstract data types. In conjunction with flow labels, they can express forms of polyvariant flow analyses. We have used CIL as the intermediate language for a framework that supports multiple closure representations for functions <ref> [DMTW97] </ref>. Some practical difficulties with CIL include controlling the size of representations in CIL and the dependence of CIL on the closed program assumption (which is at odds with modular programming and separate compilation). Nevertheless, we feel that CIL serves as a proof-of-concept for the notion of flow types. <p> We discuss the syntax and semantics of the language in the context of some simple examples. Along the way, we also explain some of the design decisions underlying the language. For a more formal presentation, see [WDMT97]; a summary of the formal presentation appears in the appendix of <ref> [DMTW97] </ref>. <p> Each of these terms pairs an abstraction with an argument value to which it will be applied (in h). Thus, the tuples have the form of thunks (nullary functions) that have been closure-converted <ref> [DMTW97] </ref>. ^ M b reduces to the normal form fi (4; 12; 1). 2.2 The Unlabelled Language CIL ul The typed but unlabelled language CIL ul is an extension to CIL ut in which all variables (except those introduced by case expressions) and injections are annotated with a type. <p> This specialization is expressed by converting the ^ in the type and corresponding term to a associated occurrences of (Finding the corresponding occurrences is facilitated by the flow labels in the typed and labelled language.) Splitting is an important technique in the representation transformation framework based on CIL <ref> [DMTW97] </ref>. A positional intersection type encodes flow information in the sense that it approximates how a value at one point of a program (the intersection term) fans out to other parts of the program (the projection terms). <p> By combining the fan-out flow of intersection types with the fan-in flow of union types, it is possible to construct networks flow paths connecting the sources of values with the sinks of values. For instance, <ref> [DMTW97] </ref> uses a simple network connecting two functions with two application sites to illustrate various approaches to closure conversion. 2.3 The Typed Language CIL The type language CIL extends CIL ul with flow label annotations on terms and types. <p> The trivial flow annotation, in which every term and type is labelled with the same "don't care" label is isomorphic to the unlabelled calculus. Often it is helpful to assume a type/label consistency (TLC) property in which the flow annotations are at least as refined as the types <ref> [DMTW97] </ref>; this corresponds to the notion of type respecting flow analysis in [JWW97]. The flow information in CIL flow types can guide the sorts of flow-directed optimizations mentioned in Section 1. <p> Flow information may also be helpful for detecting values that are used in a linear fashion. We have used flow information in conjunction with the splitting and tagging transformations discussed above to manage the plumbing details associated with transformations that introduce multiple representations for a type <ref> [DMTW97] </ref>. An important stage of this framework is flow separation, which refines flow types to express finer-grained flow distinctions. The notion of integrating flow and type information into a single flow type system is not new.
Reference: [EST95] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proc. 1995 Mathematical Foundations of Programming Semantics Conf. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year>
Reference-contexts: While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. It is not clear whether any work with constrained types has used a typed intermediate language. <p> However, link time optimizations remain a rich area for exploration. * Imperative Features: It is important to show that our techniques are still applicable in the context of features like references and exceptions. * Connections with Constrained Types We are currently exploring connections between flow types and constrained types <ref> [Cur90, EST95, AW93, AWL94] </ref>. Our goal is to incorporate the polyvariant power of intersections and unions into the constrained type framework.
Reference: [FF97] <author> Cormac Flanagan and Matthias Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In Proc. ACM SIGPLAN '97 Conf. Prog. Language Design & Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: A more aggressive approach is to perform additional analysis and transformations when modules are linked together. Recent techniques for performing flow analysis across module boundaries <ref> [TJ94, Ban97, FF97] </ref> indicate that flow types are not inherently incompatible with modular program organization.
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: For example, the identity function x:x that appears in the untyped term ^ M a can be assigned the type ^ [int ! int; bool ! bool] because it is applied only to integers and booleans. In type systems based on System F <ref> [Gir72, Rey74] </ref>, the identity function is normally assigned the universal type 8o:o ! o . Universal types do not provide any information about the types at which polymorphic functions are instantiated. In effect, they strongly suggest a uniform representation, which often implies overheads like boxing.
Reference: [Hei95] <author> Nevin Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In SAS '95 [SAS95], </booktitle> <pages> pages 189-206. </pages>
Reference-contexts: Also, support in constrained type systems for type polymorphism has been via let-polymorphism, which is difficult to use in a typed intermediate language without losing the ability to express a polyvariant flow analysis. Formal connections have been established between monovariant flow analyses and monomorphic type system <ref> [PO95, Hei95] </ref>, but typed intermediate languages need type polymorphism. In those languages which have used flow analysis with a typed intermediate language, the results of flow analysis have been maintained separately from the typed intermediate representation [JWW97]. <p> The notion of integrating flow and type information into a single flow type system is not new. Tang and Jouvelot track function flows via control flow effects annotating arrow types [Tan94, TJ94] Heintze use labelled types to show the equivalences between type systems and flow systems <ref> [Hei95] </ref>. Banerjee uses flow types in his combined approach to type inference and flow analysis [Ban97]. What is new about the flow type system of CIL is that the fine-grained flow distinctions afforded by intersection and union types makes it possible to express a wide range of polyvariant flow analyses.
Reference: [HJ94] <author> Fritz Henglein and Jesper Jorgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In POPL '94 [POPL94], </booktitle> <pages> pages 213-226. </pages>
Reference-contexts: The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types <ref> [PJL91, Ler92, HJ94] </ref>. Alternatively, dynamic type dispatch can be used to coerce a function to a specialized version based on an explicit type argument [Mor95]. Compilers have also used flow information to improve program performance.
Reference: [ICFP97] <editor> Proc. </editor> <booktitle> 1997 ACM SIGPLAN Int'l Conf. Functional Programming, </booktitle> <year> 1997. </year>
Reference: [Jim96] <author> Trevor Jim. </author> <title> What are principal typings and what are they good for? In POPL '96 [POPL96]. </title>
Reference-contexts: In our current implementation, type inference is performed on ML-like terms using the type inference system for rank-2 intersection types developed by Jim <ref> [Jim96] </ref>. Although the result of type inference satisfies the rank-2 restriction, there is no restriction on the types of terms that are produced by subsequent program transformations. The type inference system attaches only trivial flow labels to terms and types.
Reference: [Jon94] <author> Mark P. Jones. </author> <title> Dictionary-free overloading by partial evaluation. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Eval. & Semantics-Based Prog. Manipulation, </booktitle> <year> 1994. </year>
Reference-contexts: Types can be used by compilers to guide data-representation decisions and program transformations for improved program performance. For example, in type-directed specialization, different copies of a polymorphic function or method are compiled for each type at which the polymorphic routine is used <ref> [Jon94, Ble93, CU89, PC95] </ref>. The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types [PJL91, Ler92, HJ94].
Reference: [JW95] <author> Suresh Jagannathan and Andrew K. Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In SAS '95 [SAS95], </booktitle> <pages> pages 207-224. </pages>
Reference-contexts: For example, flow analysis is used to guide function and method inlining [JW96, PC95], efficient function representations [WS94, Ash96], the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages <ref> [Shi91, JW95] </ref>. <p> The analysis in the prototype is constrained by a naive implementation of the shallow subtyping rule in CIL . We are interested in analyses that use additional elements in virtual tuples to circumvent the limitations of shallow subtyping, and in implementing (and extending) polymorphic splitting <ref> [JW95] </ref>. There is also evidence that even crude flow analysis can be useful for program optimization [Ash96].
Reference: [JW96] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Flow-directed inlining. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. Prog. Language Design & Implementation, </booktitle> <pages> pages 193-205, </pages> <year> 1996. </year>
Reference-contexts: In languages making heavy used of higher-order functions or object methods, flow information can show global patterns that are not apparent from local structure. For example, flow analysis is used to guide function and method inlining <ref> [JW96, PC95] </ref>, efficient function representations [WS94, Ash96], the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages [Shi91, JW95]. <p> For example, if the flow annotations indicate that only one function flows to a call site, the function may be in-lined at that site (though special care needs to be taken to handle open functions, i.e, functions with free variables) <ref> [JW96] </ref>. When several functions flow to a call site, it is possible to dispatch to one of several in-lined functions. Flow information may also be helpful for detecting values that are used in a linear fashion.
Reference: [JWW97] <author> Suresh Jagannathan, Stephen Weeks, and Andrew Wright. </author> <title> Type-directed flow analysis for typed intermediate languages. </title> <note> To appear in SAS97, </note> <month> April 7, </month> <year> 1997. </year>
Reference-contexts: Formal connections have been established between monovariant flow analyses and monomorphic type system [PO95, Hei95], but typed intermediate languages need type polymorphism. In those languages which have used flow analysis with a typed intermediate language, the results of flow analysis have been maintained separately from the typed intermediate representation <ref> [JWW97] </ref>. Any formalism connecting the flow information to the typed program is outside the type system. Because the flow analysis is separate from the type system, the type system itself does not help in proving that program transformations preserve the correctness of the flow analysis. <p> Moreover, recent work on flow analysis in higher-order typed languages suggests that there are some important synergies between flows and types in typed languages. For example, types can provide a basis for polyvariant flow analysis <ref> [Ban97, JWW97] </ref> that is more natural than the call string contours of the n-CFA approach [JWW97] (see for n-CFA). <p> For example, types can provide a basis for polyvariant flow analysis [Ban97, JWW97] that is more natural than the call string contours of the n-CFA approach <ref> [JWW97] </ref> (see for n-CFA). To address these issues, we propose that the type and flow information in a compiler should be integrated into a single flow type system, and that flow types should be the basis for compiler intermediate languages. <p> Often it is helpful to assume a type/label consistency (TLC) property in which the flow annotations are at least as refined as the types [DMTW97]; this corresponds to the notion of type respecting flow analysis in <ref> [JWW97] </ref>. The flow information in CIL flow types can guide the sorts of flow-directed optimizations mentioned in Section 1. <p> In our flow type framework, intersections and unions can encode the results of a wide range of polyvariant flow analyses. Intersection components model distinct value contexts and union components model distinct continuation contexts. Our framework naturally encodes the type-based polyvariance of <ref> [JWW97] </ref>, but can also encode other polyvariant contexts, such as the call-string contours of [Shi91].
Reference: [Ler92] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conf. Rec. 19th Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <year> 1992. </year>
Reference-contexts: The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types <ref> [PJL91, Ler92, HJ94] </ref>. Alternatively, dynamic type dispatch can be used to coerce a function to a specialized version based on an explicit type argument [Mor95]. Compilers have also used flow information to improve program performance.
Reference: [Mit96] <author> John C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Even though these types are distinct, the values with these types are used only in a way that does not expose the differences (i.e., applying the function in the first tuple component to the second component to yield an integer). Traditionally, this situation is modelled with existential types <ref> [Mit96] </ref>, which hide the unobservable types. For example, both of the above types are instances of the existential type 9o: fi [o ! int; o ]. As with universal types, existential types hide usage information and imply unnecessary overheads.
Reference: [Mor95] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types [PJL91, Ler92, HJ94]. Alternatively, dynamic type dispatch can be used to coerce a function to a specialized version based on an explicit type argument <ref> [Mor95] </ref>. Compilers have also used flow information to improve program performance. A flow analysis provides a conservative approximation of which program points (sources) can produce the values that are consumed at other program points (sinks).
Reference: [PC95] <author> John Plevyak and Andrew A. Chien. </author> <title> Iterative flow analysis. </title> <note> Submitted, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: Types can be used by compilers to guide data-representation decisions and program transformations for improved program performance. For example, in type-directed specialization, different copies of a polymorphic function or method are compiled for each type at which the polymorphic routine is used <ref> [Jon94, Ble93, CU89, PC95] </ref>. The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types [PJL91, Ler92, HJ94]. <p> In languages making heavy used of higher-order functions or object methods, flow information can show global patterns that are not apparent from local structure. For example, flow analysis is used to guide function and method inlining <ref> [JW96, PC95] </ref>, efficient function representations [WS94, Ash96], the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages [Shi91, JW95].
Reference: [Pie91] <author> Benjamin C. Pierce. </author> <title> Programming with intersection types, union types, and polymorphism. </title> <type> Technical Report CMU-CS-91-106, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Although the virtual tuple and projection notations are somewhat cumbersome, they have two key benefits: * They solve an important technical problem: how to annotate the bound variables of terms of intersection type in an explicitly typed language. Previous approaches that allow bound variables to range over instantiation types <ref> [Rey96, Pie91] </ref> cannot express some of the typings expressible in our system.
Reference: [PJHH + 93] <author> Simon L. Peyton Jones, Cordy Hall, Kevin Hammond, Will Partain, and Phil Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conf., </booktitle> <year> 1993. </year> <month> 10 </month>
Reference-contexts: Because of the benefits of type and flow information, increasingly sophisticated type and flow analyses are being employed in compilers. Much recent work has focused on transmitting type information through the stages of a compiler via typed intermediate languages and well-typedness-preserving transformations <ref> [TMC + 95, PJHH + 93] </ref>. Not only is the preserved type information important for guiding representation decisions and enabling optimizations, but it also serves as a helpful tool for proving the correctness of transformations and debugging compiler implementations [TMC + 95, PJM97].
Reference: [PJL91] <author> Simon L. Peyton Jones and John Launchbury. </author> <title> Unboxed values as first class citizens in a non--strict functional language. </title> <booktitle> In FPCA '91, Conf. Funct. Program. Lang. Comput. Arch., volume 523 of LNCS, </booktitle> <address> Cambridge, MA. U.S.A., 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The cost of polymorphism can be isolated to uses of polymorphic functions by wrapping them in boxing coercions that are determined by the instantiated types <ref> [PJL91, Ler92, HJ94] </ref>. Alternatively, dynamic type dispatch can be used to coerce a function to a specialized version based on an explicit type argument [Mor95]. Compilers have also used flow information to improve program performance.
Reference: [PJM97] <author> Simon L. Peyton Jones and Erik Meijer. Henk: </author> <title> A typed intermediate language. </title> <note> Submitted, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: Not only is the preserved type information important for guiding representation decisions and enabling optimizations, but it also serves as a helpful tool for proving the correctness of transformations and debugging compiler implementations <ref> [TMC + 95, PJM97] </ref>. While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types [Cur90, EST95, AW93, AWL94].
Reference: [PO95] <author> Jens Palsberg and Patrick O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <year> 1995. </year>
Reference-contexts: Also, support in constrained type systems for type polymorphism has been via let-polymorphism, which is difficult to use in a typed intermediate language without losing the ability to express a polyvariant flow analysis. Formal connections have been established between monovariant flow analyses and monomorphic type system <ref> [PO95, Hei95] </ref>, but typed intermediate languages need type polymorphism. In those languages which have used flow analysis with a typed intermediate language, the results of flow analysis have been maintained separately from the typed intermediate representation [JWW97].
Reference: [POPL94] <editor> Conf. </editor> <booktitle> Rec. 21st Ann. ACM Symp. Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference: [POPL96] <editor> Conf. </editor> <booktitle> Rec. POPL '96: 23rd ACM Symp. Principles of Prog. Languages, </booktitle> <year> 1996. </year>
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloque sur la Programmation, volume 19 of LNCS, </booktitle> <pages> pages 408-425, </pages> <address> Paris, France, 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For example, the identity function x:x that appears in the untyped term ^ M a can be assigned the type ^ [int ! int; bool ! bool] because it is applied only to integers and booleans. In type systems based on System F <ref> [Gir72, Rey74] </ref>, the identity function is normally assigned the universal type 8o:o ! o . Universal types do not provide any information about the types at which polymorphic functions are instantiated. In effect, they strongly suggest a uniform representation, which often implies overheads like boxing.
Reference: [Rey96] <author> John C. Reynolds. </author> <title> Design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-96-146, </type> <institution> Carnegie Mellon Univ., </institution> <address> Pittsburgh, PA 15213, USA, </address> <month> June 28 </month> <year> 1996. </year>
Reference-contexts: Although the virtual tuple and projection notations are somewhat cumbersome, they have two key benefits: * They solve an important technical problem: how to annotate the bound variables of terms of intersection type in an explicitly typed language. Previous approaches that allow bound variables to range over instantiation types <ref> [Rey96, Pie91] </ref> cannot express some of the typings expressible in our system.
Reference: [SAS95] <editor> Proc. </editor> <booktitle> 2nd Int'l Static Analysis Symp., </booktitle> <year> 1995. </year>
Reference: [Shi91] <author> Olin Shivers. </author> <title> Control Flow Analysis of Higher Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: For example, flow analysis is used to guide function and method inlining [JW96, PC95], efficient function representations [WS94, Ash96], the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages <ref> [Shi91, JW95] </ref>. <p> Intersection components model distinct value contexts and union components model distinct continuation contexts. Our framework naturally encodes the type-based polyvariance of [JWW97], but can also encode other polyvariant contexts, such as the call-string contours of <ref> [Shi91] </ref>. We are investigating a formal characterization of the flow analyses that can be expressed in CIL . . 3 Research Directions Our investigation of compiling with flow types is still in a preliminary stage and many important steps remain to be taken.
Reference: [Tan94] <institution> Yan-Mei Tang. Systemes d'effet et interpretation abstraite pour l'analyse de flot de controle. </institution> <type> PhD thesis, </type> <institution> Ecole Nationale Superieure des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: An important stage of this framework is flow separation, which refines flow types to express finer-grained flow distinctions. The notion of integrating flow and type information into a single flow type system is not new. Tang and Jouvelot track function flows via control flow effects annotating arrow types <ref> [Tan94, TJ94] </ref> Heintze use labelled types to show the equivalences between type systems and flow systems [Hei95]. Banerjee uses flow types in his combined approach to type inference and flow analysis [Ban97].
Reference: [Tar96] <author> David Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Typed-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year> <month> December. </month>
Reference-contexts: This sort of in-lining can be performed without any fancy flow analysis <ref> [TMC + 95, Tar96, App92] </ref>. However, in the presence of non-trivial flow patterns, such as the conditional argument to pfoldr in the definition of the function sums that chooses between two predicates, in-lining can require more sophisticated flow analyses and transformations.
Reference: [TJ94] <author> Mei Yan Tang and Pierre Jouvelot. </author> <title> Separate abstract interpretation for control-flow analysis. </title> <publisher> LNCS, </publisher> <address> 789:224-??, </address> <year> 1994. </year>
Reference-contexts: An important stage of this framework is flow separation, which refines flow types to express finer-grained flow distinctions. The notion of integrating flow and type information into a single flow type system is not new. Tang and Jouvelot track function flows via control flow effects annotating arrow types <ref> [Tan94, TJ94] </ref> Heintze use labelled types to show the equivalences between type systems and flow systems [Hei95]. Banerjee uses flow types in his combined approach to type inference and flow analysis [Ban97]. <p> A more aggressive approach is to perform additional analysis and transformations when modules are linked together. Recent techniques for performing flow analysis across module boundaries <ref> [TJ94, Ban97, FF97] </ref> indicate that flow types are not inherently incompatible with modular program organization.
Reference: [TMC + 95] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. Prog. Language Design & Implementation, </booktitle> <year> 1995. </year>
Reference-contexts: This sort of in-lining can be performed without any fancy flow analysis <ref> [TMC + 95, Tar96, App92] </ref>. However, in the presence of non-trivial flow patterns, such as the conditional argument to pfoldr in the definition of the function sums that chooses between two predicates, in-lining can require more sophisticated flow analyses and transformations. <p> Because of the benefits of type and flow information, increasingly sophisticated type and flow analyses are being employed in compilers. Much recent work has focused on transmitting type information through the stages of a compiler via typed intermediate languages and well-typedness-preserving transformations <ref> [TMC + 95, PJHH + 93] </ref>. Not only is the preserved type information important for guiding representation decisions and enabling optimizations, but it also serves as a helpful tool for proving the correctness of transformations and debugging compiler implementations [TMC + 95, PJM97]. <p> Not only is the preserved type information important for guiding representation decisions and enabling optimizations, but it also serves as a helpful tool for proving the correctness of transformations and debugging compiler implementations <ref> [TMC + 95, PJM97] </ref>. While type information has been tightly integrated into modern intermediate languages, flow information has not. The only implemented or partially implemented languages of which we are aware which merge type and flow information are those based on constrained types [Cur90, EST95, AW93, AWL94].
Reference: [WDMT97] <author> J. B. Wells, Allyn Dimock, Robert Muller, and Franklyn Turbak. </author> <title> A typed intermediate language for flow-directed compilation. </title> <booktitle> In Proc. 7th Int'l Joint Conf. Theory & Practice of Software Development, </booktitle> <address> Lille, France, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our presentation of CIL is informal. We discuss the syntax and semantics of the language in the context of some simple examples. Along the way, we also explain some of the design decisions underlying the language. For a more formal presentation, see <ref> [WDMT97] </ref>; a summary of the formal presentation appears in the appendix of [DMTW97]. <p> The flow labels are sound with respect to the reduction rules of the calculus in the sense that in reductions that annihilate a source/sink pair, the source and sink labels on these terms must match exactly. (Soundess follows from a subject reduction property on the calculus <ref> [WDMT97] </ref>.) Of course, flow annotations are necessarily only conservative compile-time approximations of actual run-time flow. For example, it may be the case that no value produced by a particular source term can flow to particular sink term whose label is in the sink set of the source.
Reference: [WS94] <author> Mitchell Wand and Paul Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In POPL '94 [POPL94], </booktitle> <pages> pages 435-445. 11 </pages>
Reference-contexts: In languages making heavy used of higher-order functions or object methods, flow information can show global patterns that are not apparent from local structure. For example, flow analysis is used to guide function and method inlining [JW96, PC95], efficient function representations <ref> [WS94, Ash96] </ref>, the detection of loops hidden in function calls [Ash96], and type recovery and type check elimination in dynamically typed languages [Shi91, JW95].
References-found: 41

