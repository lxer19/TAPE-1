URL: http://www.cs.washington.edu/homes/matthai/publications/pepm97.ps
Refering-URL: http://www.cs.washington.edu/homes/matthai/
Root-URL: 
Title: Annotation-Directed Run-Time Specialization in C  
Author: Brian Grant, Markus Mock, Matthai Philipose, Craig Chambers, and Susan J. Eggers 
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We present the design of a dynamic compilation system for C. Directed by a few declarative user annotations specifying where and on what dynamic compilation is to take place, a binding time analysis computes the set of run-time constants at each program point in each annotated procedures control ow graph; the analysis supports program-point-specific polyvariant division and specialization. The analysis results guide the construction of a specialized run-time specializer for each dynamically compiled region; the specializer supports various caching strategies for managing dynamically generated code and supports mixes of speculative and demand-driven specialization of dynamic branch successors. Most of the key cost/benefit trade-offs in the binding time analysis and the run-time specializer are open to user control through declarative policy annotations. Our design is being implemented in the context of an existing optimizing compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [Andersen 92] <author> L.O. Andersen. </author> <title> Self-Applicable C Program Specialization. </title> <booktitle> pages 5461, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Outside the realm of dynamic compilation, other partial evaluation systems share characteristics with our system. In particular, C-mix is a partial-evaluation system for C that provides program-point polyvariant specialization <ref> [Andersen 92] </ref>, but not polyvariant division. C-mix copes directly with unstructured code, but it appears to lack reachability analysis to identify static merges [Andersen 94]. C-mix also includes support for automatic interprocedural call graph, alias, and side-effect analysis, although partially static data structures are not supported.
Reference: [Andersen 94] <author> L.O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <year> 1994. </year> <note> DIKU Research Report 94/19. </note>
Reference-contexts: In particular, C-mix is a partial-evaluation system for C that provides program-point polyvariant specialization [Andersen 92], but not polyvariant division. C-mix copes directly with unstructured code, but it appears to lack reachability analysis to identify static merges <ref> [Andersen 94] </ref>. C-mix also includes support for automatic interprocedural call graph, alias, and side-effect analysis, although partially static data structures are not supported. Schisms filters permit choices about whether to unfold or residualize a function and which arguments to generalize, given binding times for the functions parameters [Consel 93].
Reference: [Auslander et al. 96] <author> J. Auslander, M. Philipose, C. Chambers, S. Eggers, and B. Bershad. </author> <title> Fast, Effective Dynamic Compilation. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 149159, </pages> <month> May </month> <year> 1996. </year> <booktitle> In Proceedings of the ACM SIG-PLAN 96 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: This kind of system offers great exibility and control to the programmer, at the cost of significant programmer effort and debugging difficulty. Alternatively, several dynamic compilation systems, including Fabius [Leone & Lee 96], Tempo [Consel & Nol 96], and our own previous system <ref> [Auslander et al. 96] </ref>, take a declarative approach, with user annotations guiding the dynamic compilation process. <p> Reachability conditions are computed at the same time as the BTA information, since it depends on the BTAs division and static variable analysis and inuences the BTA analysiss treatment of merge nodes. Further details on reachability analysis can be found in an earlier paper <ref> [Auslander et al. 96] </ref>. 6 Generating the Run-Time Specializer Given the output of the BTA analysis, our compiler statically constructs the code and static data structures that, when executed at run time, will call the run-time specializer with the appropriate run-time constant arguments to produce and cache the run-time specialized code <p> The compiler separates the static operations (OpNodes whose right-hand-side expressions were computed to be static by the BTA analysis) and the dynamic operations into two separate, parallel control ow subgraphs; in earlier work we called these subgraphs set-up code and template code, respectively <ref> [Auslander et al. 96] </ref>. Subsection 6.4 discusses some issues with this separation in more detail. <p> We apply standard compiler optimizations, including instruction scheduling and register allocation, to each subgraph separately. (We perform higher-level target-independent optimizations such as common-subexpression elimination and loop optimizations before our BTA analysis.) Performing these regular compiler optimizations over both statically compiled and dynamically compiled code is crucial for generating high-quality code <ref> [Auslander et al. 96] </ref>. Finally, each units ReduceAndResidualize function is produced. First, the control-ow and the reduce operations of the ReduceAndResidualize function are derived from the static control-ow subgraph, after removing all dynamic branches from the static subgraph; this process is described in more detail in subsection 6.5. <p> Fabius does little cross-dynamic-statement optimization other than register allocation, since, unlike our system, it does not explicitly construct an explicit dynamic subgraph that can then be optimized. Compared to our previous system <ref> [Auslander et al. 96] </ref>, our current system has a more exible and expressive annotation language, support for polyvariant division and better support for polyvariant specialization, support for nested and overlapping dynamic regions, support for demand-driven (lazy) specialization, support for interprocedural specialization, a much more efficient strategy for and optimizations of run-time
Reference: [Consel & Nol 96] <author> C. Consel and F. Nol. </author> <title> A General Approach for Run-Time Specialization and its Application to C. </title> <booktitle> In Conference Record of POPL 96: 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 145156, </pages> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This kind of system offers great exibility and control to the programmer, at the cost of significant programmer effort and debugging difficulty. Alternatively, several dynamic compilation systems, including Fabius [Leone & Lee 96], Tempo <ref> [Consel & Nol 96] </ref>, and our own previous system [Auslander et al. 96], take a declarative approach, with user annotations guiding the dynamic compilation process. <p> Demotions corresponding to the ends of dynamic regions are compiled into direct jumps to statically compiled code. 7 Comparison To Related Work Tempo <ref> [Consel & Nol 96] </ref>, a compile-time and run-time specialization system for C, is most similar to our system. The two differ chiey in the following ways: Our system may produce multiple divisions and specializations of program points, with the degree of division and specialization varying from point to point.
Reference: [Consel 93] <author> C. Consel. </author> <title> A Tour of Schism: A Partial Evaluation System for Higher-Order Applicative Languages. </title> <booktitle> pages 145154, </booktitle> <year> 1993. </year>
Reference-contexts: C-mix also includes support for automatic interprocedural call graph, alias, and side-effect analysis, although partially static data structures are not supported. Schisms filters permit choices about whether to unfold or residualize a function and which arguments to generalize, given binding times for the functions parameters <ref> [Consel 93] </ref>. Because filters are executed by the binding-time analysis, only binding-time information can be used to make decisions. Our systems conditional specialization can use the results of arbitrary static or dynamic expressions to control all aspects of run-time specialization.
Reference: [Consel et al. 96] <author> C. Consel, L. Hornof, F. Nol, J. Noy, and N. </author> <note> Volanschi. </note>
Reference-contexts: Tempo supports only function-level polyvariant division and specialization, with no additional division or specialization possible within the function, except for some limited support for loop unrolling. Our system performs analysis over arbitrary, potentially unstructured control-ow graphs. Tempo converts all instances of unstructured code to structured form <ref> [Erosa & Hendren 94, Consel et al. 96] </ref>, which introduces a number of additional tests and may also introduce loops. Our system allows dynamic-to-static promotions to occur within dynamically compiled code. Tempo requires such promotions to occur only at the entry point.
References-found: 6

