URL: http://www.cs.wisc.edu/~cs536-1/submissions/114.ps.gz
Refering-URL: 
Root-URL: 
Title: Word count (detex paper.tex j wc -w) excluding text. Design and Implementation of Elimination-Based Data
Author: Vugranam Sreedhar Guang Gao Yong-fong Lee Correspondence: Vugranam C. Sreedhar 
Keyword: Subject: Data flow analysis, iterated dominance frontiers.  
Address: 11000 Wolfe Road, MS 42U5 Cupertino, California 95014-0678  CA 95014.  Santa Clara, CA 95052-8119  
Affiliation: California Language Lab  School of Computer Science, McGill University, Montreal, Canada. Currently at HP Company, Cupertino,  School of Computer Science, McGill University, Montreal, Canada Intel Corporation,  
Note: appendices 4747. This extended abstract contains 13 pages of main text, including figures. Figures occupy approximately 4.5 pages. The rest are bibliography and appendices, which are included as supplementary materials. The major points of the paper can be understood from the 13 pages of the main  
Email: email: sreedhar@cup.hp.com  
Phone: tel: (408) 447-5475  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Aho, A. V., Sethi, R., and Ullman, J. D. Compilers-Principles, </author> <title> Techniques, and Tools. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1986. </year>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Therefore, the time complexity of our elimination methods is expected to be linear in practice. 6 Handling Irreducibility In this section we describe how to handle irreducibility in flowgraphs using delayed elimination. 6 One classical definition for irreducibility is as follows <ref> [1, 7] </ref>: A flowgraph is irreducible if we cannot partition the edges into forward edges and back edges such that the destination node of every back edge dominates the source node. Figure 7 (a) gives an example irreducible flowgraph, and its DJ graph is given in Figure 7 (b).
Reference: [2] <author> Allen, F. E., and Cocke, J. </author> <title> A program data flow analysis procedure. </title> <journal> Communications of the ACM 19, </journal> <month> 3 (March </month> <year> 1976), </year> <pages> 137-147. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner.
Reference: [3] <author> Briggs, P., and Torczon, L. </author> <title> An efficient representation for sparse sets. </title> <journal> ACM Letters on Programming Languages and Systems 2, </journal> <month> 1-4 </month> <year> (1993), </year> <pages> 59-63. </pages>
Reference-contexts: The simplicity of our methods contributed to their ease of implementation. We compared the performance of our methods with the well-known iterative scheme that uses a reverse postorder for iteration [9]. We implemented the Briggs-Torczon sparse sets for manipulating sets <ref> [3] </ref>. We used as test data a set of 40 FORTRAN procedures taken from SPEC92, RiCEPS, LAPACK, and GATOR. We carried out our experiments on a SPARC-20 workstation. Tables 1 and 2, given in Appendix B, give our empirical results.
Reference: [4] <author> Burke, M. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data-flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems 12, </journal> <month> 3 (July </month> <year> 1990), </year> <pages> 341-395. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner. <p> We perform fixed-point iteration, for an irreducible region, only over the nodes at the same level in the dominator tree during the reduction process (see Section 6). Thus, the number of nodes participating in fixed-point iteration is usually smaller than previous approaches <ref> [17, 4] </ref>. <p> This suggests that our approach is indeed very efficient in practice for handling irreducible loops. Previous approaches perform iteration over a normally much larger region when an irreducible region is encountered <ref> [4, 17] </ref>. One classical approach for handling irreducible regions consists of identifying the smallest single-entry strongly connected region that encloses the irreducible region [17]. <p> Using this approach we found the size of the single-entry regions enclosing irreducible regions to be 25 for coef, 33 for colmr, 78 for card, and 28 for dcdcmp. 7 In <ref> [4] </ref> Burke proposes a method that is similar to Schwartz and Sharir's method, except that the single-entry region need not be strongly connected. Burke's approach, although improving over Schwartz and Sharir's method, still identifies a much larger region than our approach. <p> They mainly use two approaches to handle irreducible flow graphs. One is node splitting, which generates an "equivalent," reducible flowgraph by splitting nodes [7]. The other approach is to form improper regions to accommodate irreducibility and use fixed-point iteration in those regions <ref> [17, 4, 26] </ref>. We take the second approach, but perform fixed-point iteration only overs nodes that are in the irreducible region and are at the same level. Through experimentation we demonstrated, the number of nodes involved in fixed-point iteration is much smaller than previous methods. <p> In our case, the D2b rule eliminates such edges so we never need to "inspect" any J edges during path compression. Elimination methods are general-purpose data flow solution procedures <ref> [12, 4, 14, 24] </ref>. In [4] Burke reformulates Tarjan's interval analysis so that it can be applied to any monotone data flow problem. Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems. <p> In our case, the D2b rule eliminates such edges so we never need to "inspect" any J edges during path compression. Elimination methods are general-purpose data flow solution procedures [12, 4, 14, 24]. In <ref> [4] </ref> Burke reformulates Tarjan's interval analysis so that it can be applied to any monotone data flow problem. Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems.
Reference: [5] <author> Cytron, R., Ferrante, J., Rosen, B. K., Wegman, M. N., and Zadeck, F. K. </author> <title> Efficiently computing static single assignment form and control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems 13, </journal> <month> 4 (October </month> <year> 1991), </year> <pages> 452-490. </pages>
Reference-contexts: Claim 5.2 In delayed elimination, the total length of the paths compressed during the D1 and D2a rules is bounded by the total size of the dominance frontier relation. In <ref> [5] </ref> Cytron et al. have shown that, in practice, the size of the dominance frontier relation is linear in the size of its flowgraph.
Reference: [6] <author> Graham, S. L., and Wegman, M. </author> <title> A fast and usually linear algorithm for global flow analysis. </title> <journal> Journal of the ACM 23, </journal> <month> 1 (January </month> <year> 1976), </year> <pages> 172-202. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner. <p> The main contributions of the papers include: * Compared with existing elimination-based methods, our framework has the following features: Simplicity: Our framework is simple in the sense that it does not require a `parse' [8, 27, 23, 24] or `S-set finding' <ref> [6] </ref> to guide the graph reduction and variable elimination. We simply perform the elimination phase on the DJ graph itself, removing J edges and variables, in a bottom-up manner.
Reference: [7] <author> Hecht, M. S. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, Inc., </publisher> <year> 1977. </year>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Therefore, the time complexity of our elimination methods is expected to be linear in practice. 6 Handling Irreducibility In this section we describe how to handle irreducibility in flowgraphs using delayed elimination. 6 One classical definition for irreducibility is as follows <ref> [1, 7] </ref>: A flowgraph is irreducible if we cannot partition the edges into forward edges and back edges such that the destination node of every back edge dominates the source node. Figure 7 (a) gives an example irreducible flowgraph, and its DJ graph is given in Figure 7 (b). <p> But our approach has several significant differences. Except for the Graham-Wegman method, these elimination methods are applicable only to reducible flow graphs. They mainly use two approaches to handle irreducible flow graphs. One is node splitting, which generates an "equivalent," reducible flowgraph by splitting nodes <ref> [7] </ref>. The other approach is to form improper regions to accommodate irreducibility and use fixed-point iteration in those regions [17, 4, 26]. We take the second approach, but perform fixed-point iteration only overs nodes that are in the irreducible region and are at the same level.
Reference: [8] <author> Hecht, M. S., and Ullman, J. D. </author> <title> Flow graph reducibility. </title> <journal> SIAM Journal of Computing 1, </journal> <month> 2 (June </month> <year> 1972), </year> <pages> 188-202. </pages>
Reference-contexts: The main contributions of the papers include: * Compared with existing elimination-based methods, our framework has the following features: Simplicity: Our framework is simple in the sense that it does not require a `parse' <ref> [8, 27, 23, 24] </ref> or `S-set finding' [6] to guide the graph reduction and variable elimination. We simply perform the elimination phase on the DJ graph itself, removing J edges and variables, in a bottom-up manner.
Reference: [9] <author> Hecht, M. S., and Ullman, J. D. </author> <title> A simple algorithm for global data flow analysis problems. </title> <journal> SIAM Journal of Computing 4, </journal> <month> 4 (December </month> <year> 1977), </year> <pages> 519-532. </pages>
Reference-contexts: The simplicity of our methods contributed to their ease of implementation. We compared the performance of our methods with the well-known iterative scheme that uses a reverse postorder for iteration <ref> [9] </ref>. We implemented the Briggs-Torczon sparse sets for manipulating sets [3]. We used as test data a set of 40 FORTRAN procedures taken from SPEC92, RiCEPS, LAPACK, and GATOR. We carried out our experiments on a SPARC-20 workstation. Tables 1 and 2, given in Appendix B, give our empirical results.
Reference: [10] <author> Kam, J. B., and Ullman, J. D. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM 23, </journal> <month> 1 (January </month> <year> 1976), </year> <pages> 158-171. </pages>
Reference: [11] <author> Kildall, G. A. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the First ACM Symposium on Principles of Programming Languages (Boston, </booktitle> <address> Massachusetts, </address> <year> 1973), </year> <journal> ACM SIGACT and SIGPLAN, </journal> <pages> pp. 194-206. </pages>
Reference: [12] <author> Marlowe, T. J. </author> <title> Data Flow Analysis and Incremental Iteration. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <address> New Brunswick, New Jersey, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: In our case, the D2b rule eliminates such edges so we never need to "inspect" any J edges during path compression. Elimination methods are general-purpose data flow solution procedures <ref> [12, 4, 14, 24] </ref>. In [4] Burke reformulates Tarjan's interval analysis so that it can be applied to any monotone data flow problem. Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems.
Reference: [13] <author> Rosen, B. K. </author> <title> Monoids for rapid data flow analysis. </title> <journal> SIAM Journal of Computing 9, </journal> <month> 1 (February </month> <year> 1980), </year> <pages> 159-196. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis.
Reference: [14] <author> Rosen, B. K. </author> <title> Linear cost is sometimes quadratic. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages (January 1981), ACM SIGACT and SIGPLAN, </booktitle> <pages> pp. 117-124. </pages>
Reference-contexts: In our case, the D2b rule eliminates such edges so we never need to "inspect" any J edges during path compression. Elimination methods are general-purpose data flow solution procedures <ref> [12, 4, 14, 24] </ref>. In [4] Burke reformulates Tarjan's interval analysis so that it can be applied to any monotone data flow problem. Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems.
Reference: [15] <author> Rosen, B. K. </author> <title> A lubricant for data flow analysis. </title> <journal> SIAM Journal of Computing 11, </journal> <month> 3 (August </month> <year> 1982), </year> <pages> 493-511. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner.
Reference: [16] <author> Ryder, B. G., and Paull, M. C. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys 18, </journal> <month> 3 (September </month> <year> 1986), </year> <pages> 277-316. </pages>
Reference-contexts: Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors [1, 2, 27, 7, 6, 24, 4, 13, 15, 17]. An excellent survey can be found in <ref> [16] </ref>. In this paper we present a new framework for elimination-based data flow analysis. We will demonstrate that our approach is simple, easy to implement, practically efficient, and can handle irreducible flowgraphs very efficiently. <p> A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. A dominator tree edge is called a D edge. Traditional elimination-based data flow analysis techniques consist of three steps <ref> [16] </ref>: (1) reducing the flowgraph to a single node, (2) eliminating variables in the data flow equations by substitution, and (3) once the solution to the single node is determined, propagating the solution to other nodes to determine their respective solutions.
Reference: [17] <author> Schwartz, J. T., and Sharir, M. </author> <title> A design for optimizations of the bitvectoring class. </title> <type> Tech. rep., </type> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> September </month> <year> 1979. </year> <note> Courant Computer Science Report No. 17. </note>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> We perform fixed-point iteration, for an irreducible region, only over the nodes at the same level in the dominator tree during the reduction process (see Section 6). Thus, the number of nodes participating in fixed-point iteration is usually smaller than previous approaches <ref> [17, 4] </ref>. <p> This suggests that our approach is indeed very efficient in practice for handling irreducible loops. Previous approaches perform iteration over a normally much larger region when an irreducible region is encountered <ref> [4, 17] </ref>. One classical approach for handling irreducible regions consists of identifying the smallest single-entry strongly connected region that encloses the irreducible region [17]. <p> Previous approaches perform iteration over a normally much larger region when an irreducible region is encountered [4, 17]. One classical approach for handling irreducible regions consists of identifying the smallest single-entry strongly connected region that encloses the irreducible region <ref> [17] </ref>. <p> They mainly use two approaches to handle irreducible flow graphs. One is node splitting, which generates an "equivalent," reducible flowgraph by splitting nodes [7]. The other approach is to form improper regions to accommodate irreducibility and use fixed-point iteration in those regions <ref> [17, 4, 26] </ref>. We take the second approach, but perform fixed-point iteration only overs nodes that are in the irreducible region and are at the same level. Through experimentation we demonstrated, the number of nodes involved in fixed-point iteration is much smaller than previous methods.
Reference: [18] <author> Sreedhar, V. C. </author> <title> Efficient Program Analyses Using DJ Graphs. </title> <type> PhD thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: An interesting aspect of our approach is that it is amenable to incremental analysis, which is a subject of another paper [19]. At the heart of our approach is a simple program representation called the DJ graph which has been successfully applied to other problems <ref> [20, 22, 18] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. <p> In delayed elimination, if we do not perform path compression, the cost of delayed elimination would still be quadratic (as in eager elimination). But with path compression the complexity becomes O (jEjfilog jN j) <ref> [21, 18] </ref>. the flow equation at each node depends only on the flow variable of its parent in the compressed dominator tree, and all the J edges are eliminated.
Reference: [19] <author> Sreedhar, V. C., and Gao, G. R. </author> <title> An elimination-based approach to incremental data flow analysis. </title> <type> Tech. Rep. ACAPS Memo 94, </type> <institution> McGill University, </institution> <month> June </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: We will demonstrate that our approach is simple, easy to implement, practically efficient, and can handle irreducible flowgraphs very efficiently. An interesting aspect of our approach is that it is amenable to incremental analysis, which is a subject of another paper <ref> [19] </ref>. At the heart of our approach is a simple program representation called the DJ graph which has been successfully applied to other problems [20, 22, 18]. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1).
Reference: [20] <author> Sreedhar, V. C., and Gao, G. R. </author> <title> A linear time algorithm for placing -nodes. </title> <note> In ACM SIGPLAN--SIGACT Symposium on Principles of Programming Languages (January 1995). A longer version to appear in Journal of Programming Languages. </note>
Reference-contexts: An interesting aspect of our approach is that it is amenable to incremental analysis, which is a subject of another paper [19]. At the heart of our approach is a simple program representation called the DJ graph which has been successfully applied to other problems <ref> [20, 22, 18] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree.
Reference: [21] <author> Sreedhar, V. C., Gao, G. R., and Lee, Y. </author> <title> Efficient data flow analysis using DJ graphs: Elimination methods revisited. </title> <type> Tech. Rep. ACAPS Memo 93, </type> <institution> McGill University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: A note to the committee members: In this paper we have avoided correctness proofs and complexity analysis. These can be found in our TR <ref> [21] </ref>, which we have made available on the web site: http:""www-acaps.cs.mcgill.ca/~sreedhar/pubs.html. 2 Background and Notation Please consult Appendix A for background and notation on flowgraphs and data flow analysis. 3 Eager Elimination Method Both our elimination methods consist of two phases: (1) bottom-up DJ graph reduction and variable elimination, called the <p> G 4 + P 6 G 5 + G 6 P 9 P 7 P 6 G 5 + P 9 P 7 G 6 + P 9 G 7 + G 9 y Corresponding DJ graphs in Figure 4 The correctness proofs for eager elimination can be found in <ref> [21] </ref>. <p> Figure 5 gives a DJ graph, in which every J edge is annotated with its top node &lt; x &gt;. In a pre-processing step we can easily compute the top nodes of all J edges in linear time <ref> [21] </ref>. An interesting point to note is that the destination node 9 of edges 7 ! 9, 6 ! 9, and 3 ! 9 is in the dominance frontiers of the source nodes 7, 6, and 3. <p> In delayed elimination, if we do not perform path compression, the cost of delayed elimination would still be quadratic (as in eager elimination). But with path compression the complexity becomes O (jEjfilog jN j) <ref> [21, 18] </ref>. the flow equation at each node depends only on the flow variable of its parent in the compressed dominator tree, and all the J edges are eliminated. <p> The final data flow solution at each node can be obtained by top-down propagation of data flow information starting at the root node. The correctness proofs for delayed elimination can be found in <ref> [21] </ref>. 7 7 ! 9; and path compressions are performed from f to g, from j to k, from k to l, and from l to m). 8 5 The Complexity of Our Elimination Methods Although both eager and delayed elimination are theoretically worse than linear, they can behave as if
Reference: [22] <author> Sreedhar, V. C., Gao, G. R., and Lee, Y. </author> <title> Incremental computation of dominator trees. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representation (in conjunction with the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages) (January 1995). Also appears in SIGPLAN Notices Volume 30, </booktitle> <volume> Number 4, </volume> <year> 1995. </year>
Reference-contexts: An interesting aspect of our approach is that it is amenable to incremental analysis, which is a subject of another paper [19]. At the heart of our approach is a simple program representation called the DJ graph which has been successfully applied to other problems <ref> [20, 22, 18] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree.
Reference: [23] <author> Tarjan, R. E. </author> <title> Testing flow graph reducibility. </title> <journal> Journal of Computer and System Sciences 9 (1974), </journal> <pages> 355-365. </pages>
Reference-contexts: The main contributions of the papers include: * Compared with existing elimination-based methods, our framework has the following features: Simplicity: Our framework is simple in the sense that it does not require a `parse' <ref> [8, 27, 23, 24] </ref> or `S-set finding' [6] to guide the graph reduction and variable elimination. We simply perform the elimination phase on the DJ graph itself, removing J edges and variables, in a bottom-up manner.
Reference: [24] <author> Tarjan, R. E. </author> <title> Fast algorithms for solving path problems. </title> <journal> Journal of the ACM 28, </journal> <month> 3 (July </month> <year> 1981), </year> <pages> 594-614. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner. <p> The main contributions of the papers include: * Compared with existing elimination-based methods, our framework has the following features: Simplicity: Our framework is simple in the sense that it does not require a `parse' <ref> [8, 27, 23, 24] </ref> or `S-set finding' [6] to guide the graph reduction and variable elimination. We simply perform the elimination phase on the DJ graph itself, removing J edges and variables, in a bottom-up manner. <p> In our case, the D2b rule eliminates such edges so we never need to "inspect" any J edges during path compression. Elimination methods are general-purpose data flow solution procedures <ref> [12, 4, 14, 24] </ref>. In [4] Burke reformulates Tarjan's interval analysis so that it can be applied to any monotone data flow problem. Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems. <p> Burke proposes to use the closure of an interval in order to summarize local data flow information for monotone problems. In our approach, we similarly define a closure operation for recursive data flow equations. In Section 5 of <ref> [24] </ref>, Tarjan defines a derived graph G 0 of a flow graph G in order to solve path problems on both reducible and irreducible graphs. Using our terms, we observe that all the D edges in G also appear in G 0 .
Reference: [25] <author> Tarjan, R. E., and van Leeuwen, J. </author> <title> Worst-case analysis of set union algorithms. </title> <journal> Journal of the ACM 31, </journal> <volume> 2 (1984), </volume> <pages> 245-281. </pages>
Reference-contexts: Delayed Substitution: For each node w on the (compressed) dominator tree path x + ! y, excluding x, express variable O w as a linear function of O x . 5 By "static" we mean that UNION operations are not used to dynamically construct the tree <ref> [25] </ref>. 6 2. Path Compression: Make children of x all the nodes on the path x + ! y, excluding x. These two operations are performed in the top-down traversal of x + ! y.
Reference: [26] <author> Tjiang, S. W. K., and Hennessy, J. L. </author> <title> Sharlit|a tool for building optimizers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation (San Francisco, </booktitle> <address> California, </address> <month> June 17-19, </month> <year> 1992), </year> <pages> pp. </pages> <month> 82-93. </month> <journal> SIGPLAN Notices, </journal> <volume> 27(7), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: They mainly use two approaches to handle irreducible flow graphs. One is node splitting, which generates an "equivalent," reducible flowgraph by splitting nodes [7]. The other approach is to form improper regions to accommodate irreducibility and use fixed-point iteration in those regions <ref> [17, 4, 26] </ref>. We take the second approach, but perform fixed-point iteration only overs nodes that are in the irreducible region and are at the same level. Through experimentation we demonstrated, the number of nodes involved in fixed-point iteration is much smaller than previous methods.
Reference: [27] <author> Ullman, J. D. </author> <title> Fast algorithms for the elimination of common subexpressions. </title> <journal> Acta Informatica 2, </journal> <volume> 3 (1973), </volume> <pages> 191-213. </pages>
Reference-contexts: Also, some elimination methods cannot handle irreducible flowgraphs, and even if they do, they are not very efficient. Elimination-based data flow analysis are general data flow analysis techniques that have been studied by many authors <ref> [1, 2, 27, 7, 6, 24, 4, 13, 15, 17] </ref>. An excellent survey can be found in [16]. In this paper we present a new framework for elimination-based data flow analysis. <p> Unlike the previous elimination methods, that typically reduces a flowgraph to a single node <ref> [2, 27, 6, 24, 4, 15] </ref>, our approach only eliminates J edges from a DJ graph. The reduction is performed in a bottom-up fashion, reducing the DJ graph to its dominator tree. It also performs variable elimination either eagerly or in a delayed manner. <p> The main contributions of the papers include: * Compared with existing elimination-based methods, our framework has the following features: Simplicity: Our framework is simple in the sense that it does not require a `parse' <ref> [8, 27, 23, 24] </ref> or `S-set finding' [6] to guide the graph reduction and variable elimination. We simply perform the elimination phase on the DJ graph itself, removing J edges and variables, in a bottom-up manner.
References-found: 27

