URL: ftp://ftp.cs.ucsd.edu/pub/team/failAwareness.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Email: e-mail: fcfetzer,flaviug@cs.ucsd.edu  
Title: Fail-Awareness in Timed Asynchronous Systems  
Author: Christof Fetzer and Flaviu Cristian 
Note: This research was partially supported by a grant from the Air Force Office of Scientific Research. An earlier version of this technical report was published in the Proceedings of the 15th ACM Symposium on Principles of Distributed Computing, May 1996, Philadelphia.  
Web: http://www-cse.ucsd.edu/users/fcfetzer,flaviug CS95-453  
Address: La Jolla, CA 920930114  
Affiliation: Department of Computer Science Engineering University of California, San Diego  
Abstract: We address the problem of the impossibility of implementing synchronous fault-tolerant service specifications in asynchronous distributed systems. We introduce a method for weakening a synchronous service specification so that it becomes implementable in "timed" asynchronous systems, that is, asynchronous systems in which processes have access to local hardware clocks. The method (1) adds to a service interface an exception indicator so that a client knows at any time if a server is currently providing its standard "synchronous" semantics or some other specified exceptional semantics, (2) the standard behavior provided when the exception indicator does not signal an exception is "similar" to the original synchronous service behavior, and (3) a server has to provide its standard semantics whenever the underlying communication and process services exhibit "synchronous behavior". To illustrate our method, we show how the specification of a synchronous datagram service and an internal clock synchronization service can be transformed into a fail-aware service specification. Further illustrations of the usefulness of fail-aware services are provided by describing a railway crossing service and a fail-aware weak group membership service. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Peleg, and R. R. </author> <title> Renaming in an asynchronous environment. </title> <journal> Journal of the ACM, </journal> <volume> 37(3) </volume> <pages> 524-548, </pages> <year> 1990. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models [12, 14], failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems <ref> [13, 1] </ref>. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [2] <author> C. B. and C. Dwork. </author> <title> Randomization in byzantine agreement. </title> <booktitle> Advances in Computer Research, </booktitle> <volume> 5 </volume> <pages> 443-497, </pages> <year> 1989. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization <ref> [2] </ref>, (b) the introduction of partially synchronous models [12, 14], failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems [13, 1]. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [3] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> Impossibility of group membership in asynchronous systems. </title> <type> Technical Report 95-1533, </type> <institution> Computer Science Department, Cornell University, Ithaca, </institution> <year> 1995. </year>
Reference-contexts: Using a simple railway crossing example, we show how fail-aware services can be used to enforce the safety properties of an application. 2 Related Work Many problems such as consensus [17] and weak membership <ref> [3] </ref> cannot be solved in asynchronous systems. Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models [12, 14], failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems [13, 1]. <p> of time after sending an "election" message to all processes, it becomes the leader for a bounded amount of time. 7 Example: Fail-Aware Weak Group Membership Most previous attempts to specify a primary partition asynchronous group membership service have failed to achieve their goal in being implementable in asynchronous systems <ref> [3] </ref>. The reason for this impossibility is that a service weaker than the services specified in those attempts is not implementable in asynchronous systems. This service is called the weak group membership (WGM) service. <p> Consider a team G of at least 4 processes p 1 ; p 2 ; p 3 ; p 4 , and assume that all these processes are in the first group g to be created by the service. The WGM service is required to satisfy the following properties <ref> [3] </ref>: (1) If p 1 or p 2 (or both) wish to leave g, then at least one process eventually joins a newly created group g', and no process joins a different group, and (2) for every i 2 f1,2g there is at least one execution in which p i is
Reference: [4] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models [12, 14], failure detectors <ref> [4] </ref>, and progress assumptions [15], and (c) the investigation of weaker problems [13, 1]. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [5] <author> F. Cristian. </author> <title> Correct and robust programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(2):163-174, </volume> <month> Mar </month> <year> 1984. </year>
Reference-contexts: When this delivery happens at time t, it is denoted by Deliver p (m; s; e) at t. The event of process p sending a message m to a process q at time t is denoted by Send p (m; q) at t. By analogy with exception handling terminology <ref> [5] </ref>, we call the delivery of a message with a false exception indicator a standard delivery, and the message is then called standard. The delivery of a message with a true exception indicator is called an exceptional delivery, and the message is accordingly called exceptional.
Reference: [6] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: Every system which can be described in the time-free model and which has local hardware clocks can therefore be modeled as a timed system by defining "appropriate" time-out delays. The protocol for a fail-aware datagram service is based on an idea which underlies probabilistic remote clock reading <ref> [6] </ref>, namely that the measurement of round trip message delays allows the calculation of an upper bound of the transmission delay of messages. <p> In probabilistic clock reading, knowledge of the round trip delay allows a slave clock to calculate an upper bound for the deviation between its clock and the clock of the master, and hence, allows the slave clock to know if it is synchronized or not <ref> [6] </ref>. Probabilistic clock synchronization can therefore be viewed as an early example of a fail-aware distributed service. <p> We therefore restrict ourselves to describe the implementation of the fail-awareness and the timeliness requirement. All fa-messages are sent as a-messages. The fail-awareness requirement is implemented using an approach similar to that of the probabilistic remote clock reading <ref> [6, 10] </ref>: a process p computes for each a-message m an upper bound on the transmission time by measuring the duration of an asynchronous datagram round-trip which includes m.
Reference: [7] <author> F. Cristian. </author> <title> Synchronous atomic broadcast for redundant broadcast channels. </title> <journal> The Journal of Real Time Systems, </journal> <volume> 2 </volume> <pages> 195-212, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Synchronous fault-tolerant services are services defined for synchronous systems: they are always required to meet their deadlines, provided no more than a bounded number of failures occur [9]. Examples are internal clock synchronization [18] and synchronous atomic broadcast <ref> [7] </ref>, and membership services [8]. The implementation of such services depends critically on the existence of an upper bound for message transmission and process scheduling delays. Synchronous fault-tolerant services cannot be implemented in asynchronous systems which are characterized by unbounded communication and scheduling delays.
Reference: [8] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Synchronous fault-tolerant services are services defined for synchronous systems: they are always required to meet their deadlines, provided no more than a bounded number of failures occur [9]. Examples are internal clock synchronization [18] and synchronous atomic broadcast [7], and membership services <ref> [8] </ref>. The implementation of such services depends critically on the existence of an upper bound for message transmission and process scheduling delays. Synchronous fault-tolerant services cannot be implemented in asynchronous systems which are characterized by unbounded communication and scheduling delays. <p> Probabilistic clock synchronization can therefore be viewed as an early example of a fail-aware distributed service. An example of the usage of an indicator in distributed services are the membership services of <ref> [8, 11] </ref> each of which has a "joined" indicator telling the service clients whether they are joined to a group or not. <p> By "similar" we mean that the standard semantics implies the synchronous semantics under the condition that all processes and messages would always be timely. We shall explain this weak kind of similarity using the following example. In a synchronous membership service <ref> [8] </ref> the current group membership v can satisfy the properties: (1) v does not contain any process which crashed or left the group more than t time units ago, and (2) v contains all processes which have not been crashed for at least t time units.
Reference: [9] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Synchronous fault-tolerant services are services defined for synchronous systems: they are always required to meet their deadlines, provided no more than a bounded number of failures occur <ref> [9] </ref>. Examples are internal clock synchronization [18] and synchronous atomic broadcast [7], and membership services [8]. The implementation of such services depends critically on the existence of an upper bound for message transmission and process scheduling delays. <p> In this way, the clients can take appropriate recovery actions at their level of abstraction, e.g. in a manner similar to the technique of hierarchical exception masking described in <ref> [9] </ref>. Using a simple railway crossing example, we show how fail-aware services can be used to enforce the safety properties of an application. 2 Related Work Many problems such as consensus [17] and weak membership [3] cannot be solved in asynchronous systems. <p> When the transmission delay of m is greater than ffi, we say that m has suffered a performance failure. The asynchronous datagram service has omission/performance failure semantics <ref> [9] </ref>: it can lose a message or it can fail to deliver a message in a timely manner. <p> This service allows a receiver to detect when the transmission time of a message was greater than an a priori given constant . It is then up to the receiver to handle such an "exceptional" message in a manner that makes sense at its level of abstraction <ref> [9] </ref>. For example, the receiver can reject all exceptional messages to get omission failure semantics. To simplify the description of the requirements for the fail-aware datagram service, we assume that each fail-aware datagram message (or fa-message) is unique.
Reference: [10] <author> F. Cristian and C. </author> <title> Fetzer. Fault-tolerant internal clock synchronization. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Reliable Distributed Systems, Dana Point, </booktitle> <address> Ca., </address> <month> Oct </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: Our proposed fail-aware clock synchronization service handles performance, omission, and crash failures but does not tolerate arbitrary failures. An extension to mask a bounded number of arbitrary failures could be done in a way similar to the protocols described in <ref> [10] </ref>. Performance failures are in a certain sense "more difficult" than arbitrary failures because they are not restricted to some subset of processes, i.e. two processes can fail to read different sets of clocks within some a priori given reading error. <p> However, performance failures can be detected and can therefore be "more easily" masked than arbitrary failures. The fail-aware clock synchronization protocol is based on the protocols introduced in <ref> [10] </ref>. 3 Example: Railway Crossing One possible application domain of fail-aware services is the implementation of timed, fault-tolerant applications. Obviously, not all timed, fault-tolerant applications can be implemented in timed asynchronous systems. <p> We therefore restrict ourselves to describe the implementation of the fail-awareness and the timeliness requirement. All fa-messages are sent as a-messages. The fail-awareness requirement is implemented using an approach similar to that of the probabilistic remote clock reading <ref> [6, 10] </ref>: a process p computes for each a-message m an upper bound on the transmission time by measuring the duration of an asynchronous datagram round-trip which includes m.
Reference: [11] <author> F. Cristian and F. Schmuck. </author> <title> Agree--ing on processor-group membership in ayn-chronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> Dept of Computer Science and Engineering, University of California, </institution> <address> San Diego, La Jolla, CA, </address> <year> 1995. </year>
Reference-contexts: Hardware clocks and the notion of "performance failures" are essential for our approach. This work is therefore based on the timed asynchronous system model <ref> [11] </ref> instead of the time-free model [17]. The timed asynchronous system model (see section 4) is asynchronous in the sense that it does not require the existence of upper bounds for message transmission and scheduling delays. <p> However, fail-awareness can be combined with progress assumptions to strengthen the properties of fail-aware services without changing their protocols (see sec tion 8). 2 In this work we use the timed asynchronous sys-tem model <ref> [11] </ref> instead of the time-free asynchronous system model [17]. The timed model assumes that each process has access to a local hardware clock and defines time-outs for message transmission and process scheduling delays. The time-outs are the foundation for specifying what it means for a system to exhibit "synchronous behavior". <p> Probabilistic clock synchronization can therefore be viewed as an early example of a fail-aware distributed service. An example of the usage of an indicator in distributed services are the membership services of <ref> [8, 11] </ref> each of which has a "joined" indicator telling the service clients whether they are joined to a group or not. <p> following way: each controller is assigned a sequence of unique time slots and a controller p can send commands to the gate units whenever its clock says that it is synchronized and its value is within one of p's time slots. 4 Timed Asynchronous Sys tems A timed asynchronous system <ref> [11] </ref> is a distributed system consisting of a finite set of processes linked by an asynchronous datagram service. A one-way time-out delay ffi is defined for the datagram service. <p> Two processes are connected in [s; t] if they are timely during [s; t] and each message sent by one process to the other in [s; t ffi] is received in a timely manner <ref> [11] </ref>. 5 Fail-Aware Datagram A datagram service provides operations to send and to deliver messages. A synchronous data-gram service has, by definition, omission failure semantics: the communication system may lose messages but all delivered messages are timely. <p> The exact meaning of a system "exhibiting synchronous behavior" is defined by a stability predicate <ref> [11, 15] </ref>. For fail-aware clock synchronization we define a predicate -stable and we will require that whenever a process has been -stable for a sufficiently long time its clock has to be synchronized. <p> The exact meaning of "the system exhibits synchronous behavior" is determined by a stability predicate such as stable <ref> [11] </ref>, -stable, or majority-stable [15]. The weaker the stability predicate is, the more often the system exhibits synchronous behavior and the more often a fail-aware service has to provide its standard semantics.
Reference: [12] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models <ref> [12, 14] </ref>, failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems [13, 1]. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [13] <author> D. Dolev, N. Lynch, S. Pinter, E. Stark, and W. Weihl. </author> <title> Reaching approximate agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 33(3) </volume> <pages> 499-516, </pages> <year> 1986. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models [12, 14], failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems <ref> [13, 1] </ref>. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [14] <author> C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 288-323, </pages> <month> Feb </month> <year> 1988. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models <ref> [12, 14] </ref>, failure detectors [4], and progress assumptions [15], and (c) the investigation of weaker problems [13, 1]. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems.
Reference: [15] <author> C. Fetzer and F. Cristian. </author> <title> On the possibility of consensus in asynchronous systems. </title> <booktitle> In Proceedings of the 1995 Pacific Rim Int'l Symp. on Fault-Tolerant Systems, </booktitle> <address> Newport Beach, CA, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Several approaches to overcome this problem have been proposed: (a) the usage of randomization [2], (b) the introduction of partially synchronous models [12, 14], failure detectors [4], and progress assumptions <ref> [15] </ref>, and (c) the investigation of weaker problems [13, 1]. Fail-awareness is a method for transforming problems into weaker problems such that they become implementable in timed asynchronous systems. <p> The exact meaning of a system "exhibiting synchronous behavior" is defined by a stability predicate <ref> [11, 15] </ref>. For fail-aware clock synchronization we define a predicate -stable and we will require that whenever a process has been -stable for a sufficiently long time its clock has to be synchronized. <p> This idea is generalized to allow a system to be continuously -stable even when a bounded number of processes in P U recover or crash during I. There exists weaker and perhaps "more intuitive" predicates like the majority-stable predicate of <ref> [15] </ref> which could be used for fail-aware clock synchronization. Even though we have designed a protocol for majority-stability, we will describe 7 a protocol for -stability to simplify the protocol description. <p> The intuition why this problem becomes solvable is that all -stable processes can agree on the processes to be removed. This can be done in a manner similar to the consensus protocol given in <ref> [15] </ref> which achieves such an agreement under the weaker assumption that processes are majority-stable (instead of -stable). 8 Fail-Awareness Fail-awareness is a design concept which allows to transform a synchronous service specification into a fail-aware service specification implementable in timed asynchronous systems. <p> The exact meaning of "the system exhibits synchronous behavior" is determined by a stability predicate such as stable [11], -stable, or majority-stable <ref> [15] </ref>. The weaker the stability predicate is, the more often the system exhibits synchronous behavior and the more often a fail-aware service has to provide its standard semantics. However, any fail-aware services requires that the system exhibits some "minimal synchronism" before it can provide its standard semantics. <p> For example, the properties of the fail-aware WGM imply the properties of the WGM under the following assumption (PA): the system always eventually becomes -stable for a "sufficiently long time". We call condition (PA) a progress assumption <ref> [15] </ref>. A progress assumption is introduced to guarantee that a system will exhibit synchronous behavior, that is, they are a way to introduce additional synchronism into the timed asynchronous system model.
Reference: [16] <author> C. Fetzer and F. Cristian. </author> <title> Fail-aware failure detectors. </title> <type> Technical Report CSE96-475, UCSD, </type> <year> 1996. </year> <note> Available via anonymous ftp at cs.ucsd.edu as /pub/team/failAwareFD.ps.Z. </note>
Reference-contexts: Fail-awareness is not restricted to the transformation of synchronous services into fail-aware services, e.g. we applied it to define fail-aware failure detectors <ref> [16] </ref>. Most fault-tolerant applications are timed in the sense that they are required to react to inputs by certain deadlines. We are interested in supporting the implementation of timed, fault-tolerant applications in asynchronous systems by providing fail-aware services. <p> Fail-awareness is applicable to various other synchronous services such as a group membership service and an atomic broadcast service. Moreover, fail-awareness can be applied to time-free problems like the weak group membership problem (see section 7) and failure detectors <ref> [16] </ref>. The combination of fail-awareness and progress assumptions allows the solution of time-free problems which are otherwise not solvable in asynchronous systems. The usage of fail-aware services to ensure safety properties of timed applications is illustrated by a railway crossing ex ample.
Reference: [17] <author> M. J. Fischer, N. A. Lynch, and M. S. Pa-terson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: Hardware clocks and the notion of "performance failures" are essential for our approach. This work is therefore based on the timed asynchronous system model [11] instead of the time-free model <ref> [17] </ref>. The timed asynchronous system model (see section 4) is asynchronous in the sense that it does not require the existence of upper bounds for message transmission and scheduling delays. <p> Using a simple railway crossing example, we show how fail-aware services can be used to enforce the safety properties of an application. 2 Related Work Many problems such as consensus <ref> [17] </ref> and weak membership [3] cannot be solved in asynchronous systems. <p> However, fail-awareness can be combined with progress assumptions to strengthen the properties of fail-aware services without changing their protocols (see sec tion 8). 2 In this work we use the timed asynchronous sys-tem model [11] instead of the time-free asynchronous system model <ref> [17] </ref>. The timed model assumes that each process has access to a local hardware clock and defines time-outs for message transmission and process scheduling delays. The time-outs are the foundation for specifying what it means for a system to exhibit "synchronous behavior".
Reference: [18] <author> L. Lamport and P. M. Melliar-Smith. </author> <title> Synchronizing clocks in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 52-78, </pages> <month> Jan </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Synchronous fault-tolerant services are services defined for synchronous systems: they are always required to meet their deadlines, provided no more than a bounded number of failures occur [9]. Examples are internal clock synchronization <ref> [18] </ref> and synchronous atomic broadcast [7], and membership services [8]. The implementation of such services depends critically on the existence of an upper bound for message transmission and process scheduling delays. Synchronous fault-tolerant services cannot be implemented in asynchronous systems which are characterized by unbounded communication and scheduling delays. <p> An example of the usage of an indicator in distributed services are the membership services of [8, 11] each of which has a "joined" indicator telling the service clients whether they are joined to a group or not. Most internal clock synchronization protocols, e.g. <ref> [18, 19] </ref>, mask arbitrary failures, in the sense that correct clocks are synchronized when less than a third of the clocks suffer failures. Our proposed fail-aware clock synchronization service handles performance, omission, and crash failures but does not tolerate arbitrary failures. <p> Let us assume that a process p ensures that any connected pro cess receives at least every d = :5s a message from p. By defining ffi = 10 5 , evaluates to 1:4ms. 6 Fail-Aware Clock Synchro nization Deterministic internal clock synchronization for synchronous systems <ref> [18] </ref> requires that * at any point in time t and for any two correct processes p and q, the deviation between the clocks of p and q be bounded by a constant maximum deviation , and * the drift rate of a clock of a correct process be bounded by
Reference: [19] <author> J. Lundelius-Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> 77(1) </volume> <pages> 1-36, </pages> <year> 1988. </year>
Reference-contexts: An example of the usage of an indicator in distributed services are the membership services of [8, 11] each of which has a "joined" indicator telling the service clients whether they are joined to a group or not. Most internal clock synchronization protocols, e.g. <ref> [18, 19] </ref>, mask arbitrary failures, in the sense that correct clocks are synchronized when less than a third of the clocks suffer failures. Our proposed fail-aware clock synchronization service handles performance, omission, and crash failures but does not tolerate arbitrary failures.
References-found: 19

