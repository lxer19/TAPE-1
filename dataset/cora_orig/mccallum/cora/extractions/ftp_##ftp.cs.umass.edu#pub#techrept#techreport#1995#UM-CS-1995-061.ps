URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-061.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-061.html
Root-URL: 
Title: A Compact Petri Net Representation for Concurrent Programs  
Author: Matthew B. Dwyer Lori A. Clarke 
Address: Amherst  
Affiliation: Department of Computer Science University of Massachusetts,  
Abstract: This paper presents a compact Petri net representation for concurrent programs. These Petri nets are based on task interaction graphs and, thus, are called TIG-based Petri nets (TPN)s. They form a compact representation by summarizing the effects of large sequential regions of a program and making useful information about those regions available for program analysis. TPNs and their associated analyses represent a tradeoff between encoding information about program behavior in the program representation or in the analysis algorithms. To evaluate the cost-effectiveness of this tradeoff, we have developed a flexible framework for checking a variety of properties of concurrent programs using the reachability graph generated from a TPN. We present empirical results that demonstrate the benefit of TPNs over alternate Petri net representations and discuss techniques to further reduce the cost of TPN-based analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 91] <author> G.S. Avrunin, U.A. Buy, J.C. Corbett, L.K. Dillon, and J.C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Integer linear programming techniques avoid consideration of the state space entirely. They formulate a set of necessary conditions related to the property of interest and analyze the satisfiability of those conditions by the program <ref> [ABC + 91] </ref>. Unfortunately, in the worst-case, the integer programming algorithm for performing this analysis requires exponential time. 2 Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost [CK93, DS91, DC94, MR91]. <p> BDS is a simulation of a border defense system [DBDS94]. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures. Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [ABC + 91] </ref>. Phils are versions of the basic dining philosophers example with deadlock [ABC + 91]. RW are versions of the readers/writers example presented in [ABC + 91]. <p> Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [ABC + 91] </ref>. Phils are versions of the basic dining philosophers example with deadlock [ABC + 91]. RW are versions of the readers/writers example presented in [ABC + 91]. <p> Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [ABC + 91] </ref>. Phils are versions of the basic dining philosophers example with deadlock [ABC + 91]. RW are versions of the readers/writers example presented in [ABC + 91].
Reference: [And91] <author> G.R. Andrews. </author> <title> Paradigms for process interaction in distributed programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(1) </volume> <pages> 49-90, </pages> <month> mar </month> <year> 1991. </year>
Reference-contexts: Such results are useful as an initial indication of the feasibility of an analysis technique. The cost of an analysis technique can vary greatly from program to program. The control and communication structures that are used in real concurrent programs <ref> [And91] </ref> can also vary greatly. Therefore, a thorough understanding of the practical benefits of an analysis technique requires evaluation of that technique over a wide range of real concurrent programs. To date, there has been little empirical work in evaluating concurrency analysis techniques.
Reference: [ASU85] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Early compilers used control flow graphs (CFG)s whose nodes represented program statements annotated with simple forms of analysis-specific information. The cost of data flow analysis grows rapidly with the number of CFG nodes and analyses over these statement CFGs was expensive. Basic block CFGs <ref> [ASU85] </ref> were introduced to coarsen the statement-level CFG by collapsing multiple nodes into a single node. This essentially shifted information from the CFG to the analysis algorithms. The algorithms now had to compute and manipulate more complicated analysis-specific node information.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking : 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: Symbolic model-checking techniques use a fix-point computation over an encoding of the state transition relation to determine reachability of a given state <ref> [BCM + 90] </ref>. For some systems this encoding is very compact, allowing time-efficient analysis. Finding a compact encoding can be difficult, however, and for some systems no compact encoding exists, resulting in a worst case state transition relation that is exponential in size.
Reference: [CK93] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the European Software Engineering Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Unfortunately, in the worst-case, the integer programming algorithm for performing this analysis requires exponential time. 2 Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [CK93, DS91, DC94, MR91] </ref>. These techniques formulate a set of conditions, related to the property to be analyzed, as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [Cor94] <author> J.C. Corbett. </author> <title> An empirical evaluation of three methods for deadlock analysis of Ada tasking programs. </title> <booktitle> Software Engineering Notes, </booktitle> <pages> pages 204-215, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the International Symposium on Software Testing and Analysis. </booktitle>
Reference-contexts: A recent study <ref> [Cor94] </ref> has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> A fair comparison requires that both techniques be equivalent in the kinds of information they model and the kinds of analyses they support. There are a great variety of program models and analysis algorithms. As Corbett discusses <ref> [Cor94] </ref>, different models and algorithms can be sensitive to subtle variations in the input program. Thus, a comparative evaluation can easily lead to unintended biasing of the results. Moreover, program analyses are not useful in the abstract; their worth derives from application to "real" programs.
Reference: [DBDS94] <author> S. Duri, U. Buy, R. Devarapalli, </author> <title> and S.M. Shatz. Application and experimental evaluation of state space reduction methods for deadlock analysis in ada. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(4) </volume> <pages> 340-380, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The state space considered by these methods can be reduced by maintaining only the parts of the state space that are relevant to the analysis of a particular property, such as deadlock freedom <ref> [GW91, DBDS94] </ref>. For some programs, state space reduction is able to decrease analysis cost considerably but, in general, the cost of these techniques grows exponentially with the size of the program. <p> despite the rapid growth of the state space, enumeration methods that consider the entire concurrent program can be practical for small to medium size programs of moderate complexity [YTL + 95] and that state space reduction techniques can increase the size of the programs that can be considered still further <ref> [DBDS94] </ref>. A recent study [Cor94] has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> We use Ada-nets, their associated reachability graphs, and the appropriate analysis algorithms for comparison. Analysis data based on Ada-nets is available for four example Ada tasking programs <ref> [DBDS94, Sha93] </ref>, BDS, versions of Gas-1, Phils and the RW examples. BDS is a simulation of a border defense system [DBDS94]. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures. <p> We use Ada-nets, their associated reachability graphs, and the appropriate analysis algorithms for comparison. Analysis data based on Ada-nets is available for four example Ada tasking programs [DBDS94, Sha93], BDS, versions of Gas-1, Phils and the RW examples. BDS is a simulation of a border defense system <ref> [DBDS94] </ref>. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures. Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries [ABC + 91]. <p> Although the maximum capacity of the TOTAL 9 toolset is not stated, programs whose reachability graphs are as large as 200000 states and 750000 arcs have been analyzed <ref> [DBDS94] </ref>. If we assume that reachability graphs are at least that large for the examples where reachability graphs for Ada-nets could not be generated, then our results for the Gas-1 5, Phils 5, and Phils 7 examples also show a compaction on the order of two orders of magnitude. <p> Recent experimental data has demonstrated that net reduction techniques are an effective approach to extending the size of programs for which deadlock checking is practical <ref> [DBDS94] </ref>. Here we discuss two TPN reductions: parallel transitions and forced communication pairs. Parallel transition reductions preserve all information in the reduced TPN and thus can be applied to improve the effectiveness of analysis for any property.
Reference: [DC94] <author> M.B. Dwyer and L.A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 62-75, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: Unfortunately, in the worst-case, the integer programming algorithm for performing this analysis requires exponential time. 2 Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [CK93, DS91, DC94, MR91] </ref>. These techniques formulate a set of conditions, related to the property to be analyzed, as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [DS91] <author> E. Duesterwald and M.L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification, </booktitle> <address> Victoria, Canada, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Unfortunately, in the worst-case, the integer programming algorithm for performing this analysis requires exponential time. 2 Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [CK93, DS91, DC94, MR91] </ref>. These techniques formulate a set of conditions, related to the property to be analyzed, as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [For91] <author> K. Forester. </author> <title> TIG-based Petri nets for modeling Ada tasking. </title> <type> Master's thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The example CFGPN in section 4 has 16 places and 13 transitions. An Ada-net [SMBT90] is a CFGPN designed to model Ada programs. An Ada-net for this example has 21 places and 16 transitions <ref> [For91] </ref>.
Reference: [GW91] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <pages> pages 417-428, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The state space considered by these methods can be reduced by maintaining only the parts of the state space that are relevant to the analysis of a particular property, such as deadlock freedom <ref> [GW91, DBDS94] </ref>. For some programs, state space reduction is able to decrease analysis cost considerably but, in general, the cost of these techniques grows exponentially with the size of the program.
Reference: [LC89] <author> D.L. Long and L.A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 44-52, </pages> <address> Pittsburgh, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: One of the goals of our work is to understand the practical limitations of a variety of static program analysis techniques as applied to "real" programs. We have developed a framework for experimenting with a variety of state space enumeration analyses based on task interaction graphs (TIG)s <ref> [LC89] </ref> and Petri nets. Petri nets are a well-studied model for concurrent systems [Mur89]. This paper presents a coarsened Petri net model, called TIG-based Petri nets (TPN)s, that is efficient to construct. <p> Reachability graphs for this type of Petri net have been used to perform analysis of Ada tasking programs [MR87, SMBT90]. 4 Task Interaction Graphs TIGs have been proposed by Long and Clarke <ref> [LC89] </ref> as a compact flow graph representation for concurrent programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. TIGs are a coarsened flow graph representation analogous to basic block control flow graphs, where regions are blocks.
Reference: [MR87] <author> E.T. Morgan and R.R. Razouk. </author> <title> Interactive state-space analysis of concurrent systems. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1080-1091, </pages> <year> 1987. </year>
Reference-contexts: In fact, in many cases this tradeoff enables analysis of programs for which analysis of a statement-level Petri net representation is infeasible. 3 Related Work State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [MR87, SMBT90, Tay83, YTL + 95] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [MZGT85, MR87, PTY92, SMBT90] </ref>. We call a Petri net that explicitly represents the possible control flow branch and merge points in each program task a control flow graph Petri net (CFGPN). <p> Because the net represents control flow choices explicitly, the set of reachable markings that have no successor marking is a conservative approximation of the set of program deadlock states. Reachability graphs for this type of Petri net have been used to perform analysis of Ada tasking programs <ref> [MR87, SMBT90] </ref>. 4 Task Interaction Graphs TIGs have been proposed by Long and Clarke [LC89] as a compact flow graph representation for concurrent programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. <p> The CFGs are then converted to TIGs from which the TPN is constructed. Transformations can be applied to reduce the size of the TPNs. A reachability graph is generated from a TPN using standard Petri net techniques <ref> [MR87] </ref>. A variety of analysis algorithms can then be applied to the TPN-based reachability graph including checking for deadlock freedom, checking for freedom from critical races, and performing data flow analyses to check for event or state sequencing properties.
Reference: [MR91] <author> S.P. Masticola and B.G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of Workshop on Parallel and Distributed Debugging. ACM, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Unfortunately, in the worst-case, the integer programming algorithm for performing this analysis requires exponential time. 2 Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [CK93, DS91, DC94, MR91] </ref>. These techniques formulate a set of conditions, related to the property to be analyzed, as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [Mur89] <author> T. Murata. </author> <title> Petri nets: Properties, analysis and applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(44) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: We have developed a framework for experimenting with a variety of state space enumeration analyses based on task interaction graphs (TIG)s [LC89] and Petri nets. Petri nets are a well-studied model for concurrent systems <ref> [Mur89] </ref>. This paper presents a coarsened Petri net model, called TIG-based Petri nets (TPN)s, that is efficient to construct. This model summarizes the effects of large regions of a program and makes useful information about those regions available for program analysis. <p> In this section, we consider techniques for reducing a TPN prior to reachability analysis. The theory of Petri net reductions <ref> [Mur89] </ref> allows a given net to be replaced by a reduced net that maintains certain properties of the original net and has a smaller reachability graph. Most Petri net representations of concurrent programs, including TPNs, explicitly represent all potential inter-task communications.
Reference: [MZGT85] <author> D. Mandrioli, R. Zicari, C. Ghezzi, and F. Tisato. </author> <title> Modeling the Ada task system by Petri nets. </title> <journal> Computer Languages, </journal> <volume> 10(1) </volume> <pages> 43-61, </pages> <year> 1985. </year>
Reference-contexts: Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [MZGT85, MR87, PTY92, SMBT90] </ref>. We call a Petri net that explicitly represents the possible control flow branch and merge points in each program task a control flow graph Petri net (CFGPN).
Reference: [PTY92] <author> M. Pezze, R.N. Taylor, and M. Young. </author> <title> Graph models for reachability analysis of concurrent programs. </title> <type> Technical Report TR-92-27, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [MZGT85, MR87, PTY92, SMBT90] </ref>. We call a Petri net that explicitly represents the possible control flow branch and merge points in each program task a control flow graph Petri net (CFGPN).
Reference: [Sha93] <author> S.M. </author> <title> Shatz. </title> <type> Personal Communication, </type> <month> February </month> <year> 1993. </year>
Reference-contexts: We use Ada-nets, their associated reachability graphs, and the appropriate analysis algorithms for comparison. Analysis data based on Ada-nets is available for four example Ada tasking programs <ref> [DBDS94, Sha93] </ref>, BDS, versions of Gas-1, Phils and the RW examples. BDS is a simulation of a border defense system [DBDS94]. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures.
Reference: [SMBT90] <author> S.M. Shatz, K. Mai, C. Black, and S. Tu. </author> <title> Design and implementation of a Petri net based toolkit for Ada tasking analysis. </title> <journal> IEEE Transactions on Parallel and Distributed System, </journal> <volume> 1(4) </volume> <pages> 424-441, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In fact, in many cases this tradeoff enables analysis of programs for which analysis of a statement-level Petri net representation is infeasible. 3 Related Work State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [MR87, SMBT90, Tay83, YTL + 95] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [MZGT85, MR87, PTY92, SMBT90] </ref>. We call a Petri net that explicitly represents the possible control flow branch and merge points in each program task a control flow graph Petri net (CFGPN). <p> Because the net represents control flow choices explicitly, the set of reachable markings that have no successor marking is a conservative approximation of the set of program deadlock states. Reachability graphs for this type of Petri net have been used to perform analysis of Ada tasking programs <ref> [MR87, SMBT90] </ref>. 4 Task Interaction Graphs TIGs have been proposed by Long and Clarke [LC89] as a compact flow graph representation for concurrent programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. <p> TPNs typically contain fewer places and transitions than CFGPNs. For comparison, the TPN for the example in figure 1 has 6 places and 9 transitions. The example CFGPN in section 4 has 16 places and 13 transitions. An Ada-net <ref> [SMBT90] </ref> is a CFGPN designed to model Ada programs. An Ada-net for this example has 21 places and 16 transitions [For91]. <p> Unfortunately, for very different models and reasoning algorithms there is no alternative. We cannot compare the models directly or analytically derive the amount of work required to reason about the model. We are fortunate to have access to analysis results from the TOTAL toolset <ref> [SMBT90] </ref>. TOTAL performs state space analysis by constructing the reachability graph from a statement level Petri net model of Ada tasking programs, called Ada-nets. Ada-nets are a kind of CFGPN since they explicitly represent control flow decisions in the structure of the Petri net.
Reference: [Tay83] <author> R.N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year> <month> 16 </month>
Reference-contexts: In fact, in many cases this tradeoff enables analysis of programs for which analysis of a statement-level Petri net representation is infeasible. 3 Related Work State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [MR87, SMBT90, Tay83, YTL + 95] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical.
Reference: [TBC + 88] <author> Richard N. Taylor, Frank C. Belz, Lori A. Clarke, Leon J. Osterweil, Richard W. Selby, Jack C. Wile--den, Alexander L. Wolf, and Michal Young. </author> <title> Foundations for the Arcadia Environment Architecture. </title> <booktitle> In Proceedings of SIGSOFT88: Third Symposium on Software Development Environment, </booktitle> <pages> pages 1-13, </pages> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGPLAN Notices 24(2) and as SIGSOFT Software Engineering Notes, </note> <month> 13(5) November </month> <year> 1988. </year>
Reference-contexts: This data was collected using the TPN toolset. With this toolset, constructing a TPN from Ada source code involves executing the Arcadia <ref> [TBC + 88] </ref> language processing tools to generate a collection of CFGs. The CFGs are then converted to TIGs from which the TPN is constructed. Transformations can be applied to reduce the size of the TPNs. A reachability graph is generated from a TPN using standard Petri net techniques [MR87].
Reference: [YTL + 95] <author> M. Young, R.N. Taylor, D.L. Levine, K.A. Nies, and D. Brodbeck. </author> <title> A concurrency analysis tool suite: Rationale, design, and preliminary experience. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(1) </volume> <pages> 64-106, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: In fact, in many cases this tradeoff enables analysis of programs for which analysis of a statement-level Petri net representation is infeasible. 3 Related Work State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [MR87, SMBT90, Tay83, YTL + 95] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> To date, there has been little empirical work in evaluating concurrency analysis techniques. Experimental results suggest that despite the rapid growth of the state space, enumeration methods that consider the entire concurrent program can be practical for small to medium size programs of moderate complexity <ref> [YTL + 95] </ref> and that state space reduction techniques can increase the size of the programs that can be considered still further [DBDS94]. A recent study [Cor94] has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> Thus, the total cost of Algorithm 3 is O (c k ). We note that Young et. al. <ref> [YTL + 95] </ref> showed this problem to be NP-hard, but they have found empirically that for a number of programs, checking this condition is practical. Checking for freedom from deadlock is supported by the TOTAL toolset. For most statement-level Petri net representations, including Ada-nets, the deadlock predicate is very simple.
Reference: [YY91] <author> W.J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification, </booktitle> <pages> pages 49-59, </pages> <address> Victoria, Canada, </address> <month> October </month> <year> 1991. </year> <month> 17 </month>
Reference-contexts: Finding conditions that are strong enough for the analysis problem at hand yet amenable to a polynomial-time data flow formulation can be difficult. Compositional approaches decompose the original analysis problem into smaller problems on which the above techniques can be applied <ref> [YY91] </ref>. This approach relies on finding a decomposition of the original problem that significantly reduces the cost of analysis for the subproblems. For many programs, such a suitable decomposition may be difficult to find, if one exists at all.
References-found: 23

