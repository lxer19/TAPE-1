URL: http://www.cs.brown.edu/courses/cs227/papers/b5/unstructured.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: peter@central.cis.upenn.edu  susan@central.cis.upenn.edu  gerdh@saul.cis.upenn.edu  suciu@research.att.com  
Title: A Query Language and Optimization Techniques for Unstructured Data  
Author: Peter Buneman Susan Davidson Gerd Hillebrand Dan Suciu 
Address: Pennsylvania  Pennsylvania  Pennsylvania  
Affiliation: University of  University of  University of  AT&T Research  
Abstract: For certain database tasks that require great flexibility, some people are turning to a new kind of data representation in which the database is not constrained by a schema. Instead, each component of the database carries its own description, which is independent of other components. Systems like ACeDB, which has become very popular with biologists, and the recent Tsimmis proposal for data integration organize data in tree-like structures whose components can be used equally well to represent sets and tuples. What query language is appropriate for such structures? Here we propose a simple language UnQL for querying data organized as a rooted, edge-labeled graph. In this model, relational data may be represented as fixed-depth trees, and on such trees UnQL is equivalent to the relational algebra. The novelty of UnQL consists in its programming constructs for arbitrarily deep data and for cyclic structures. While strictly more powerful than query languages with path expressions like XSQL, UnQL can still be efficiently evaluated. We describe new optimization techniques for the deep, or "vertical" dimension of UnQL queries. Furthermore, we show that known optimization techniques for operators on flat relations apply to the "horizontal" dimension of UnQL.
Abstract-found: 1
Intro-found: 1
Reference: [BBW92] <author> Val Breazu-Tannen, Peter Buneman, and Limsoon Wong. </author> <title> Naturally embedded query languages. </title> <editor> In J. Biskup and R. Hull, editors, </editor> <booktitle> LNCS 646: Proceedings of 4th International Conference on Database Theory, </booktitle> <address> Berlin, Germany, </address> <month> October, </month> <year> 1992, </year> <pages> pages 140-154. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1992. </year> <note> Available as UPenn Technical Report MS-CIS-92-47. </note>
Reference-contexts: Following <ref> [BBW92] </ref>, we use the term calculus in the sense of lambda calculus (a formalism with variables and functions), rather than in the sense of relational calculus (a logic, with variables and quantifiers). We give a simple, effective procedure for translating UnQL queries into UnCAL expressions.
Reference: [BDS94] <author> Peter Buneman, Susan Davidson, and Dan Suciu. </author> <title> Programming constructs for unstructured data. </title> <type> Technical Report MS-CIS-95-14, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA 19104, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Bisimulation extends naturally to graphs with * edges <ref> [BDS94] </ref>: the graphs in Translated into OODB terminology, this means that our notion of equality is value-based: we consider two databases as equal if the two (possibly infinite) databases obtained by replacing all oid's with the value of their corresponding object are the same. <p> Informally, this equation says that a tree is a set of pairs of labels and trees. Following [BTS91], we can obtain a natural form of computation for this type based on structural recursion. However, we know <ref> [BDS94] </ref> that general structural recursion is too powerful: on cyclic structures, some queries may lead to "infinite recursion" and give undefined results. The languages we describe below are restrictions of general structural recursion that are well-defined on cyclic structures.
Reference: [BLS + 94] <author> P. Buneman, L. Libkin, D. Suciu, V. Tannen, and L. Wong. </author> <title> Comprehension syntax. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 23(1) </volume> <pages> 87-96, </pages> <month> March </month> <year> 1994. </year> <month> 18 </month>
Reference-contexts: The returned expression is: fT up ) fA ) "a"; B ) 2; C ) 3g; T up ) fA ) "b"; B ) 4; C ) 5gg: There are some important differences between our comprehension syntax <ref> [BLS + 94] </ref> and that of relational calculus or languages derived from SQL.
Reference: [BTS91] <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and computational aspects of programming with Sets/Bags/Lists. </title> <booktitle> In LNCS 510: Proceedings of 18th International Colloquium on Automata, Languages, and Programming, </booktitle> <address> Madrid, Spain, </address> <month> July </month> <year> 1991, </year> <pages> pages 60-75. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The type for labeled trees Tree satisfies the equation Tree = P fin (Label fi Tree). Informally, this equation says that a tree is a set of pairs of labels and trees. Following <ref> [BTS91] </ref>, we can obtain a natural form of computation for this type based on structural recursion. However, we know [BDS94] that general structural recursion is too powerful: on cyclic structures, some queries may lead to "infinite recursion" and give undefined results.
Reference: [CM90] <author> M. Consens and A. Mendelzon. </author> <title> Graphlog: a visual formalism for real life recursion. </title> <booktitle> In Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: Connections with "graph logic". Another approach to querying labeled trees is to use some variety of "graph logic" <ref> [CM90] </ref>. It is possible to express at least the vext fragment of UnCAL in Datalog, given a graph representation of the input tree.
Reference: [GP84] <author> A. Goldberg and R. Paige. </author> <title> Stream processing. </title> <booktitle> In Proceedings of ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 53-62, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: The rule for if described earlier and the simple rule vext (f )(fg) = fg allows us to transform the first query into the second one. The second optimization rule corresponds to the vertical loop fusion in <ref> [GP84] </ref>. Consider the expression vext (g)(vext (f)(t)). One can visualize it as a pipeline process in which the edges of t are fed one by one into the function f, which transforms every label into a "small" tree f (a).
Reference: [GRS93] <author> N. Goodman, S. Rozen, and L. Stein. </author> <title> Requirements for a deductive query language in the MapBase genome-mapping database. </title> <booktitle> In Proceedings of Workshop on Programming with Logic Databases, </booktitle> <address> Vancouver, BC, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Unstructured data models. Biological data storage poses a problem for "fixed schema" systems. The problem is that the rapid evolution of experimental techniques requires constant adjustment of the schema <ref> [GRS93] </ref>. Moreover missing data is so common that it is desirable to have a system that only presents the data that is actually there (i.e., fields with null values should not even be mentioned). One database fl Corresponding author.
Reference: [KKS92] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented databases. </title> <editor> In M. Stonebraker, editor, </editor> <booktitle> Proceedings ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 393-402, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For example, one might want to search all the character strings in the database to determine which tables contain a particular term. One cannot write a generic relational algebra expression to express such a query. Languages such as XSQL <ref> [KKS92] </ref> provide a solution to this, and these can be extended, with some limitations, to object-oriented databases. However the problem of "deep" queries and query optimization remains.
Reference: [KL89] <author> M. Kifer and G. Laussen. F-logic: </author> <title> A higher order language for reasoning about objects, inheritance, and scheme. </title> <booktitle> In Proceedings of ACM-SIGMOD 1989, </booktitle> <pages> pages 46-57, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: the tree by a set of (oid; label; oid) triples and construct a program that expresses an output graph as a predicate on (oid 0 ; label; oid 0 ) triples where oid 0 values are constructed by a Skolem function on the input oids, similar to id-terms in F-logic <ref> [KL89] </ref>. Whether Datalog optimizations have anything to do with the optimizations we have presented here is an open question. Other optimizations.
Reference: [Kos91] <author> Anthony S. Kosky. </author> <title> Modeling and merging database schemas. </title> <type> Technical Report MS-CIS-91-65/L&C 39, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1991. </year>
Reference-contexts: Even though our tree data model is not intended to be an object-oriented model, it is worthwhile to discuss briefly the advantages of adopting this complex notion of equality rather than using object identifiers. First, bisimulation is, in some sense, the same as "observational equality": in <ref> [Kos91] </ref>, it is shown that for any reasonably expressive object-oriented query language that cannot directly observe (or test equality of) object identifiers, two databases are bisimilar iff they are indistinguishable by any query in that language. This result legitimizes bisimulation as a notion relevant to database query languages.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 = fA ) X 1 g X 1 where X 1 = fA ) fA ) X 1 gg X 1 where X 1 = fA ) X 2 g; X 2 = fA ) X 1 g The notion of equality which we adopt is that of bisimulation <ref> [Mil89] </ref>.
Reference: [PGMW95] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: A limited query language has been developed for ACeDB. It allows selections of objects and pointer traversals; but no restructuring of the data in the form of projections or joins can be performed. 1 Another system that uses a tree-like model is the Tsimmis project <ref> [PGMW95] </ref>, which has recently been proposed for heterogeneous data integration. The idea is to let the data describe itself, rather than trying to force a common global schema over databases that have arisen independently and therefore may have very little structure in common. <p> The deliberately irregular example we have used here in no way reflects the details of that well-structured and very useful database. 2 database (cf. the examples given in <ref> [PGMW95] </ref>), where information about heterogeneous documents and their referencing relationship is represented in a graph-like structure. Note that information only resides at labels. <p> For example to find the set of all strings in the database: select flg where fl ) nl ) DB; isstring (l) Here the fl is a "repeated wildcard" that matches any path, i.e., sequence of edges, in the tree. Such a construct is proposed in <ref> [PGMW95] </ref>. However, we shall find some useful queries where we need more than this. We shall want to specify regular expressions on paths, and for this we shall adopt a grep-like syntax.
Reference: [PT87] <author> Robert Paige and Robert E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16 </volume> <pages> 973-989, </pages> <year> 1987. </year>
Reference-contexts: Under an oid-based notion of equality, this is an instance of the graph isomorphism problem, which is not known to be tractable. By contrast, bisimulation of graphs can be tested quite efficiently: Paige and Tarjan <ref> [PT87] </ref> show that for a graph with n vertices and m edges, bisimilarity can be tested in O (m log n) time. Types. The type of labeled trees has a simple description.
Reference: [TMD92] <author> J. Thierry-Mieg and R. </author> <title> Durbin. Syntactic Definitions for the ACEDB Data Base Manager. </title> <type> Technical Report MRC-LMB xx.92, </type> <institution> MRC Laboratory for Molecular Biology, Cambridge,CB2 2QH, UK, </institution> <year> 1992. </year>
Reference-contexts: Address: Department of Computer and Information Science, University of Pennsylvania, 200 South 33 rd Street, Philadelphia, PA 19104-6389. Phone: (215) 898-3490. Fax: (215) 898-0587. 1 system that is extremely popular within the molecular biology community for storing experimental data is ACeDB (A C. elegans Database) <ref> [TMD92] </ref>. Although ACeDB has a schema, the schema imposes only weak constraints on the database. A class in an ACeDB schema can be thought of as a labeled tree with non-terminal edges labeled by attribute names or base types and leaves labeled by base types or class names.
Reference: [Won94] <author> Limsoon Wong. </author> <title> Querying Nested Collections. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA 19104, </address> <month> August </month> <year> 1994. </year> <note> Available as University of Pennsylvania IRCS Report 94-09. 19 </note>
Reference-contexts: We will do this next. Optimization rules for set-based query languages centered around ext and set union [ have been considered previously <ref> [Won94] </ref>. Surprisingly, they hold in identical form for the vertical dimension, with the slight twist that sometimes we have to restrict ourselves to vext instead of gext. <p> Example 5.3 We start with the following simple optimization rule for ext, adapted from <ref> [Won94] </ref>: ext ((l; t):if p then e else e 0 ) (T ) = if p then ext ((l; t):e) (T ) else ext ((l; t):e 0 ) (T ) when l and t do not occur free in p This extends naturally to vext and gext as: gext ((l; t):if <p> In other instances we may discover that some markers are not accessible from the root: these markers can be eliminated, further simplifying the query. We give next the optimization rules in their general form. As mentioned earlier, all 9 rules in <ref> [Won94] </ref> apply to the vertical operators in UnCAL. Instead of listing all of them, we show only the most powerful ones, together with their corresponding horizontal versions. <p> We intend to incorporate at least the comprehension based fragment of UnQL into our existing implementation of CPL (Collection Programming Language <ref> [Won94] </ref>). However there are some important open questions. Syntax. The syntax for making deep queries can probably be improved. There are deep restructuring operations, expressible in UnCAL whose translation into traverse : : : giving : : : is rather cumbersome. Expressive power.
References-found: 15

