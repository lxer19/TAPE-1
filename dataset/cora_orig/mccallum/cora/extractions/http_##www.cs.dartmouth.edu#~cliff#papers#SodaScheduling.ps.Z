URL: http://www.cs.dartmouth.edu/~cliff/papers/SodaScheduling.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Email: E-mail: chekuri@cs.stanford.edu.  E-mail: rajeev@cs.stanford.edu.  E-mail: natarajan@hpl.hp.com.  E-mail: cliff@cs.dartmouth.edu.  
Title: Approximation Techniques for Average Completion Time Scheduling  
Author: C. Chekuri R. Motwani B. Natarajan C. Stein 
Note: Supported by NSF Award CCR-9357849, with matching funds from IBM, Mitsubishi, Schlumberger Foundation, Shell Foundation, and Xerox Corporation.  Supported by an Alfred P. Sloan Research Fellowship, an IBM Faculty Partnership Award, an ARO MURI Grant DAAH04-96-1-0007, and NSF Young Investigator Award CCR-9357849, with matching funds from IBM, Mitsubishi, Schlumberger Foundation, Shell Foundation, and Xerox Corporation.  Research partly supported by NSF Award CCR-9308701. Most of this work was done while the author was visiting  
Address: College  Stan-ford, CA 94305-9045.  Stan-ford, CA 94305-9045.  1501 Page Mill Road, Palo Alto, CA 94304.  Science,Dartmouth College, Hanover, NH.  
Affiliation: Stanford University  Stanford University  Hewlett Packard Laboratories  Dartmouth  Department of Computer Science, Stanford University,  Department of Computer Science, Stanford University,  Hewlett Packard Laboratories,  Department of Computer  Stanford University  
Abstract: We consider the problem of nonpreemptive scheduling to minimize average (weighted) completion time, allowing for release dates, parallel machines, and precedence constraints. Recent work has led to constant-factor approximations for this problem, based on solving a preemptive or linear programming relaxation and then using the solution to get an ordering on the jobs. We introduce several new techniques which generalize this basic paradigm. We use these ideas to obtain improved approximation algorithms for one-machine scheduling to minimize average completion time with release dates. In the process, we obtain an optimal randomized on-line algorithm for the same problem that beats a lower bound for deterministic on-line algorithms. We consider extensions to the case of parallel machine scheduling, and for this we introduce two new ideas: first, we show that a preemptive one-machine relaxation is a powerful tool for designing parallel machine scheduling algorithms that simultaneously produce better approximations and have smaller running times; second, we show that a non-greedy "rounding" of the relaxation yields better approximations than a greedy one. We also prove a general theorem relating the value of one-machine relaxations to that of the schedules obtained for the original m-machine problems. This theorem applies even when there are precedence constraints on the jobs. We apply this result to precedence graphs such as in-trees, out-trees, and series-parallel graphs; these are of particular interest in compiler applications that partly motivated our work. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Adolphson. </author> <title> Single machine job sequencing with precedence constraints. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <month> 40-54 </month> <year> (1977). </year>
Reference-contexts: Our approach is based on what we call ff-schedules (this notion was also used by [21] and [11] in a somewhat different manner). Given a preemptive schedule P and ff 2 <ref> [0; 1] </ref>, we define C P j (ff) to be the time at which an ff-fraction of J j is completed. An ff-schedule is a nonpreemptive schedule obtained by list scheduling jobs in order of increasing C P j (ff), possibly introducing idle time to account for release dates. <p> We show that for arbitrary ff, an ff-scheduler has a tight approximation ratio of 1 + 1=ff. Given that 1 + 1=ff 2 for ff 2 <ref> [0; 1] </ref>, it may appear that this notion of ff-schedulers is useless for obtaining ratios better than 2. A key insight is that a worst-case instance with performance ratio 1 + 1=ff for one value of ff is not a worst-case instance for many other values of ff. <p> For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints [7, 19], although a 2-approximation is possible [12]. A polynomial-time solution is known when the precedence graph is a forest [14], or a series-parallel graph <ref> [19, 1] </ref>. For arbitrary m, the problem is N P-hard even without precedence constraints, unless the weights are all equal (without release dates); on the other hand, the problem is strongly N P-hard even when all weights are identical and the precedence graph is a union of chains [5]. <p> We begin by analyzing simple ff-schedules. Techniques from [21, 12] are easily generalized to yield the following: Theorem 2.1. For ff 2 <ref> [0; 1] </ref>, an ff-schedule has P j C ff P j , and this is tight. This theorem, in and of itself, always yields approximation bounds that are worse than 2. We thus introduce a new fact that ultimately yields better algorithms. <p> To avoid the worst case ff, we choose ff randomly, according to some probability distribution. We now give a very general bound on this algorithm. Lemma 2.3. Suppose ff is chosen from a probability distribution over <ref> [0; 1] </ref> with a density function f . Then, the E [ i C ff P i , where ffi = max Z fi 1 + ff fi f (ff)dff: Proof.
Reference: [2] <author> S. Chakrabarti, C. Phillips, A. Schulz, D.B. Shmoys, C. Stein, and J. Wein. </author> <title> Improved Scheduling Algorithms for Minsum Criteria. </title> <booktitle> In Proceedings of the 23rd International Colloquium on Automata, Languages and Programming, </booktitle> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: Recent work has led to constant-factor approximations for weighted completion time for a variety of these N P-hard scheduling problems <ref> [21, 12, 2] </ref>. <p> The m-machine problem gives rises to two complications: the problem of computing an optimal m-machine preemptive schedule is N P-hard [4], and the best known approximation ratio is 2 [21]; further, the conversion bounds from preemptive to nonpreemptive schedules are not as good. Chakrabarti et al <ref> [2] </ref> obtain a bound of 7=3 on the conversion from preemptive to nonpreemptive case, yielding a 14=3-approximation for scheduling on m machines with release dates. Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. <p> Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. Phillips et al [21] gave the first such algorithm, a 24-approximation algorithm. This has been greatly improved to 4 + * [11], 4 1 m [12], and 3:5 <ref> [2] </ref>. Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *. Unfortunately, the algorithm with the best approximation is inefficient, as it uses the polynomial approximation scheme for makespan due to Hochbaum and Shmoys [15]. <p> Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. Phillips et al [21] gave the first such algorithm, a 24-approximation algorithm. This has been greatly improved to 4 + * [11], 4 1 m [12], and 3:5 <ref> [2] </ref>. Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *. Unfortunately, the algorithm with the best approximation is inefficient, as it uses the polynomial approximation scheme for makespan due to Hochbaum and Shmoys [15]. We give a new algorithm for this problem. <p> An expected approximation ratio of 5:33 + * is achievable with release dates and precedence constraints <ref> [2] </ref>. We extend our techniques to obtain a fairly general algorithm for m-machine problems with precedence constraints, in addition to release dates and job weights. <p> Note that in applications such as compilers [3], speed and simplicity are sometimes more important than getting the best possible ratio. Finally, our algorithm has a surprising property: it gives schedules that are good for both makespan and average completion time (Chakrabarti et al <ref> [2] </ref> also have shown the existence of such schedules). We also show that a similar but simpler technique gives a 2-approximation if the precedence graph is an in-tree; note that the optimal one-processor schedule for in-trees is polynomial-time computable. <p> This algorithm can be made online by simulating the preemptive schedule and adding a job to the list when it completes in the preemptive schedule. 7 3.2 Improvement to a 2:85-approximation. We now improve the approximation bound to 2:85, which improves the the earlier ratio of 2:89 + * <ref> [2] </ref>. We observe that it is possible that, when we order the jobs by C P 1 j , there are pairs of jobs j and k with C P 1 j &gt; C P 1 r j &lt; r k .
Reference: [3] <author> C. Chekuri, R. Johnson, R. Motwani, B.K. Natarajan, B.R. Rau, and M. Schlansker. </author> <title> Profile-Driven Instruction Level Parallel Scheduling with Applications to Super Blocks. </title> <booktitle> To appear in Proceeding of the 29th Annual International Symposium on Microarchitechture (MICRO-29), </booktitle> <address> Paris, France, </address> <month> December 2-4, </month> <year> 1996. </year>
Reference-contexts: Compile-time instruction scheduling is essential for effectively exploiting the fine-grained parallelism offered in pipelined, superscalar, and VLIW architectures (for example, see [13, 26]). Current research is addressing the issue of profile-based compiler optimization. In a recent paper, Chekuri, Johnson, Motwani, Natarajan, Rau, and Schlansker <ref> [3] </ref> show that weighted completion time is the measure of interest in profile-driven code optimization; some of our results are related to the heuristics described and empirically tested therein. <p> Further, our conversion algorithm has the advantage of being extremely simple and combinatorial. Note that in applications such as compilers <ref> [3] </ref>, speed and simplicity are sometimes more important than getting the best possible ratio. Finally, our algorithm has a surprising property: it gives schedules that are good for both makespan and average completion time (Chakrabarti et al [2] also have shown the existence of such schedules).
Reference: [4] <author> J. Du, J.Y.T. Leung, and G.H. Young. </author> <title> Minimizing mean flow time with release time constraint. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 75 </month> <year> (1990). </year>
Reference-contexts: His algorithm is also a Best-ff algorithm, but it works off of a linear programming relaxation rather than a preemptive schedule. Scheduling Parallel Machines with Release Dates. The m-machine problem gives rises to two complications: the problem of computing an optimal m-machine preemptive schedule is N P-hard <ref> [4] </ref>, and the best known approximation ratio is 2 [21]; further, the conversion bounds from preemptive to nonpreemptive schedules are not as good.
Reference: [5] <author> J. Du, J.Y.T. Leung, and G.H. Young. </author> <title> Scheduling chain structured tasks to minimize makespan and mean flow time. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <month> 219-236 </month> <year> (1991). </year>
Reference-contexts: For arbitrary m, the problem is N P-hard even without precedence constraints, unless the weights are all equal (without release dates); on the other hand, the problem is strongly N P-hard even when all weights are identical and the precedence graph is a union of chains <ref> [5] </ref>. An expected approximation ratio of 5:33 + * is achievable with release dates and precedence constraints [2]. We extend our techniques to obtain a fairly general algorithm for m-machine problems with precedence constraints, in addition to release dates and job weights.
Reference: [6] <author> M.R. Garey. </author> <title> Optimal task sequencing with precedence constraints. </title> <journal> Discrete Mathematics, </journal> <volume> 4 </volume> <month> 37-56 </month> <year> (1973). </year>
Reference: [7] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco (1979). </address>
Reference-contexts: We now consider the weighted completion time problem with precedence constraints; for the time being, assume that all release dates are 0, but note that our results apply unchanged for arbitrary release dates. For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints <ref> [7, 19] </ref>, although a 2-approximation is possible [12]. A polynomial-time solution is known when the precedence graph is a forest [14], or a series-parallel graph [19, 1].
Reference: [8] <author> M.X. Goemans. </author> <title> A Supermodular Relaxation for Scheduling with Release Dates. </title> <booktitle> In Proceedings of the Fifth Conference On Integer Programming and Combinatorial Optimization, </booktitle> <pages> 288-301, </pages> <year> 1996. </year>
Reference: [9] <author> M.X. Goemans. </author> <title> Improved approximation algorithms for scheduling with release dates. </title> <booktitle> In Proceedings of the 8th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1997. </year>
Reference-contexts: If this is true, or if there is a better preemptive approximation algorithm, our results will have bearing on the weighted case. Independently, Goemans <ref> [9] </ref> has used some related ideas to design a 2-approximation algorithm for the problem of nonpreemptive scheduling on one machine so as to minimize the average weighted completion time. His algorithm is also a Best-ff algorithm, but it works off of a linear programming relaxation rather than a preemptive schedule.
Reference: [10] <author> R.L. </author> <title> Graham Bounds on multiprocessor timing anomalies. </title> <journal> SIAM Journal on Applied Mathematics, </journal> <volume> 17 </volume> <month> 416-429 </month> <year> (1969). </year>
Reference-contexts: The idea is to use list scheduling with a one-processor schedule as the "list," which is a natural heuristic for makespan <ref> [10] </ref>. 2 One-Machine Scheduling with Release Dates In this section, we present our results for one-machine scheduling with release dates to minimize average completion time.
Reference: [11] <author> L.A. Hall, D.B. Shmoys, and J. Wein. </author> <title> Scheduling to minimize average completion time: O*ine and online algorithms. </title> <booktitle> In Proceedings of the 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1996, </year> <pages> pp. 142-151. </pages>
Reference-contexts: We also obtain an optimal randomized on-line algorithm (in the oblivious adversary model) with expected competitive ratio e e1 , which beats the deterministic on-line lower bound. Our approach is based on what we call ff-schedules (this notion was also used by [21] and <ref> [11] </ref> in a somewhat different manner). Given a preemptive schedule P and ff 2 [0; 1], we define C P j (ff) to be the time at which an ff-fraction of J j is completed. <p> Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. Phillips et al [21] gave the first such algorithm, a 24-approximation algorithm. This has been greatly improved to 4 + * <ref> [11] </ref>, 4 1 m [12], and 3:5 [2]. Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *.
Reference: [12] <author> L.A. Hall, A.S. Schulz, D.B. Shmoys, J. Wein. </author> <title> Scheduling to Minimize Average Completion time: Off-line and On-line Approximation Algorithms. </title> <type> Preprint, </type> <year> 1996. </year>
Reference-contexts: Recent work has led to constant-factor approximations for weighted completion time for a variety of these N P-hard scheduling problems <ref> [21, 12, 2] </ref>. <p> Thus, our conversion results generalize to weighted completion time. However, since for the weighted case even the preemptive scheduling problem is N P-hard (given release dates), we must use an approximation for the relaxation. There is a 2-approximation for the preemptive case <ref> [12] </ref>, which yields a 3:16-approximation for the nonpreemptive case. While this does not immediately improve earlier results, we believe that, as an off-line algorithm, Best-ff actually has a performance ratio better than 1:58 when applied to structured preemptive schedules as opposed to arbitrary preemptive schedules. <p> Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. Phillips et al [21] gave the first such algorithm, a 24-approximation algorithm. This has been greatly improved to 4 + * [11], 4 1 m <ref> [12] </ref>, and 3:5 [2]. Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *. Unfortunately, the algorithm with the best approximation is inefficient, as it uses the polynomial approximation scheme for makespan due to Hochbaum and Shmoys [15]. <p> For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints [7, 19], although a 2-approximation is possible <ref> [12] </ref>. A polynomial-time solution is known when the precedence graph is a forest [14], or a series-parallel graph [19, 1]. <p> Let P be a preemptive schedule, and let C P i denote the completion time of J i in P and in the nonpreemptive ff-schedule derived from P , respectively. We begin by analyzing simple ff-schedules. Techniques from <ref> [21, 12] </ref> are easily generalized to yield the following: Theorem 2.1. For ff 2 [0; 1], an ff-schedule has P j C ff P j , and this is tight. This theorem, in and of itself, always yields approximation bounds that are worse than 2.
Reference: [13] <author> J.L. Hennessy and T. Gross. </author> <title> Postpass code optimization of pipeline constraints. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5 </volume> <month> 422-448 </month> <year> (1983). </year>
Reference-contexts: An important motivation for studying weighted completion time, aside from its intrinsic theoretical interest, comes from application to compiler optimizations. Compile-time instruction scheduling is essential for effectively exploiting the fine-grained parallelism offered in pipelined, superscalar, and VLIW architectures (for example, see <ref> [13, 26] </ref>). Current research is addressing the issue of profile-based compiler optimization.
Reference: [14] <author> W.A. Horn. </author> <title> Single-machine job sequencing with treelike precedence ordering and linear delay penalties. </title> <journal> SIAM Journal of Applied Mathematics, </journal> <volume> 23 </volume> <month> 189-202 </month> <year> (1972). </year>
Reference-contexts: For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints [7, 19], although a 2-approximation is possible [12]. A polynomial-time solution is known when the precedence graph is a forest <ref> [14] </ref>, or a series-parallel graph [19, 1].
Reference: [15] <author> D.S. Hochbaum, </author> <title> and D.B. Shmoys. A polynomial approximation scheme for scheduling on uniform processors: using the dual approximation approach. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 </volume> <month> 539-551 </month> <year> (1988). </year>
Reference-contexts: Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *. Unfortunately, the algorithm with the best approximation is inefficient, as it uses the polynomial approximation scheme for makespan due to Hochbaum and Shmoys <ref> [15] </ref>. We give a new algorithm for this problem. First we introduce a different relaxation a preemptive one-machine relaxation. More precisely, we maintain the original release dates and allow preemptions, but divide all the processing times by m. We then compute a one-machine schedule.
Reference: [16] <author> J.A. Hoogeveen, and A.P.A. Vestjens. </author> <title> Optimal On-Line Algorithms for Single-Machine Scheduling. </title> <booktitle> In Proceedings of the Fifth Conference On Integer Programming and Combinatorial Optimization, </booktitle> <year> 1996, </year> <pages> pp. 404-414. </pages>
Reference-contexts: This randomized on-line algorithm is particularly interesting as it beats a lower bound for deterministic on-line algorithms <ref> [16] </ref>, and matches a recent lower bound for randomized on-line algorithms [25]. <p> A simple proof shows that each job J j completes at time no later than 2C P j , implying a 2-approximation. Two other 2-approximation algorithms have been discovered subsequently <ref> [16, 24] </ref>, and it is also known that no deterministic on-line algorithm has approximation ratio better than 2 [16, 24]. <p> A simple proof shows that each job J j completes at time no later than 2C P j , implying a 2-approximation. Two other 2-approximation algorithms have been discovered subsequently <ref> [16, 24] </ref>, and it is also known that no deterministic on-line algorithm has approximation ratio better than 2 [16, 24]. This approximation technique has been generalized to many other scheduling problems, and hence finding better approximations for this basic problem is believed to be an important step towards improved approximations for more general problems.
Reference: [17] <author> W.A. Horn. </author> <title> Some simple scheduling algorithms. </title> <journal> Naval Research Logistics Quarterly, </journal> <volume> 21 </volume> <month> 177-185 </month> <year> (1974). </year>
Reference-contexts: For the single machine case, if the release dates are 0 for all jobs, then the weighted completion time problem can be solved optimally in polynomial time <ref> [17] </ref>. We are interested in a more general setting with release dates and precedence constraints and multiple machines, any of which makes the problem N P -hard [20]. Thus, we will consider approximation algorithms, or, in an on-line setting, competitive ratios.
Reference: [18] <author> T.C. Hu. </author> <title> Parallel sequencing and assembly line problems. </title> <journal> Operations Research, </journal> <volume> 9 </volume> <month> 841-848 </month> <year> (1961). </year>
Reference: [19] <author> E.L. Lawler. </author> <title> Sequencing jobs to minimize total weighted completion time. </title> <journal> Annals of Discrete Mathematics, </journal> <volume> 2 </volume> <month> 75-90 </month> <year> (1978). </year>
Reference-contexts: We now consider the weighted completion time problem with precedence constraints; for the time being, assume that all release dates are 0, but note that our results apply unchanged for arbitrary release dates. For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints <ref> [7, 19] </ref>, although a 2-approximation is possible [12]. A polynomial-time solution is known when the precedence graph is a forest [14], or a series-parallel graph [19, 1]. <p> For one-processor scheduling, minimizing the weighted completion time is N P-hard for arbitrary precedence constraints [7, 19], although a 2-approximation is possible [12]. A polynomial-time solution is known when the precedence graph is a forest [14], or a series-parallel graph <ref> [19, 1] </ref>. For arbitrary m, the problem is N P-hard even without precedence constraints, unless the weights are all equal (without release dates); on the other hand, the problem is strongly N P-hard even when all weights are identical and the precedence graph is a union of chains [5].
Reference: [20] <author> E.L. Lawler, J.K. Lenstra, A.H.G. Rinnooy Kan and D.B. Shmoys, </author> <title> Sequencing and Scheduling: Algorithms and Complexity, </title> <booktitle> In Handbooks in Operations Research and Management Science, </booktitle> <volume> Vol. 4: </volume> <booktitle> Logistics of Production and Inventory (1990). </booktitle>
Reference-contexts: We are interested in a more general setting with release dates and precedence constraints and multiple machines, any of which makes the problem N P -hard <ref> [20] </ref>. Thus, we will consider approximation algorithms, or, in an on-line setting, competitive ratios. An important motivation for studying weighted completion time, aside from its intrinsic theoretical interest, comes from application to compiler optimizations. <p> First, an optimal preemptive schedule P is found using the shortest remaining processing time (SRPT) algorithm <ref> [20] </ref> which at any time runs an available job that has the least processing time left; note that this is an on-line algorithm.
Reference: [21] <author> C. Phillips, C. Stein, and J. Wein. </author> <title> Scheduling jobs that arrive over time. </title> <booktitle> In Proceedings of the Fourth International Workshop on Algorithms and Data Structures, </booktitle> <year> 1995, </year> <pages> pp. 86-97. </pages>
Reference-contexts: Recent work has led to constant-factor approximations for weighted completion time for a variety of these N P-hard scheduling problems <ref> [21, 12, 2] </ref>. <p> We begin with a more detailed discussion of our results and their relation to earlier work. One-Machine Scheduling with Release Dates. The first constant-factor approximation algorithm for a weighted completion time problem was the following 2-approximation algorithm of Phillips, Stein and Wein <ref> [21] </ref> for minimizing the average completion time on one machine with release dates. <p> We also obtain an optimal randomized on-line algorithm (in the oblivious adversary model) with expected competitive ratio e e1 , which beats the deterministic on-line lower bound. Our approach is based on what we call ff-schedules (this notion was also used by <ref> [21] </ref> and [11] in a somewhat different manner). Given a preemptive schedule P and ff 2 [0; 1], we define C P j (ff) to be the time at which an ff-fraction of J j is completed. <p> Clearly, an ff-scheduler is an on-line algorithm; moreover, for ff = 1, the ff-scheduler is exactly the algorithm of Phillips et al <ref> [21] </ref> and hence a 2-approximation. We show that for arbitrary ff, an ff-scheduler has a tight approximation ratio of 1 + 1=ff. Given that 1 + 1=ff 2 for ff 2 [0; 1], it may appear that this notion of ff-schedulers is useless for obtaining ratios better than 2. <p> Scheduling Parallel Machines with Release Dates. The m-machine problem gives rises to two complications: the problem of computing an optimal m-machine preemptive schedule is N P-hard [4], and the best known approximation ratio is 2 <ref> [21] </ref>; further, the conversion bounds from preemptive to nonpreemptive schedules are not as good. Chakrabarti et al [2] obtain a bound of 7=3 on the conversion from preemptive to nonpreemptive case, yielding a 14=3-approximation for scheduling on m machines with release dates. <p> Chakrabarti et al [2] obtain a bound of 7=3 on the conversion from preemptive to nonpreemptive case, yielding a 14=3-approximation for scheduling on m machines with release dates. Several other algorithms don't use the preemptive schedule but use a linear programming relaxation. Phillips et al <ref> [21] </ref> gave the first such algorithm, a 24-approximation algorithm. This has been greatly improved to 4 + * [11], 4 1 m [12], and 3:5 [2]. Using a general on-line framework [2], one can obtain an algorithm with an approximation ratio of 2:89 + *. <p> Let P be a preemptive schedule, and let C P i denote the completion time of J i in P and in the nonpreemptive ff-schedule derived from P , respectively. We begin by analyzing simple ff-schedules. Techniques from <ref> [21, 12] </ref> are easily generalized to yield the following: Theorem 2.1. For ff 2 [0; 1], an ff-schedule has P j C ff P j , and this is tight. This theorem, in and of itself, always yields approximation bounds that are worse than 2.
Reference: [22] <author> R. Ravi, A. Agrawal, and P. Klein. </author> <title> Ordering problems approximated: single-processor scheduling and interval graph completion. </title> <booktitle> In Proceedings of the 18th International Colloquium on Automata, Languages and Programming, </booktitle> <year> 1991, </year> <pages> pp. 751-762. </pages>
Reference: [23] <author> A.S. Schulz. </author> <title> Scheduling to minimize total weighted completion time: performance guarantees of lp based heuristics and lower bounds. </title> <booktitle> In Proceedings of the Fifth Conference On Integer Programming and Combinatorial Optimization, </booktitle> <year> 1996, </year> <pages> pp. 301-315. </pages>
Reference: [24] <author> L. Stougie, </author> <year> 1995. </year> <type> Personal communication cited in [16]. </type>
Reference-contexts: A simple proof shows that each job J j completes at time no later than 2C P j , implying a 2-approximation. Two other 2-approximation algorithms have been discovered subsequently <ref> [16, 24] </ref>, and it is also known that no deterministic on-line algorithm has approximation ratio better than 2 [16, 24]. <p> A simple proof shows that each job J j completes at time no later than 2C P j , implying a 2-approximation. Two other 2-approximation algorithms have been discovered subsequently <ref> [16, 24] </ref>, and it is also known that no deterministic on-line algorithm has approximation ratio better than 2 [16, 24]. This approximation technique has been generalized to many other scheduling problems, and hence finding better approximations for this basic problem is believed to be an important step towards improved approximations for more general problems.
Reference: [25] <author> L. Stougie and A. Vestjens, </author> <year> 1996. </year> <type> Personal communication. </type>
Reference-contexts: This randomized on-line algorithm is particularly interesting as it beats a lower bound for deterministic on-line algorithms [16], and matches a recent lower bound for randomized on-line algorithms <ref> [25] </ref>. <p> Further, there is a deterministic off-line algorithm, Best-ff, which is a 1:58-approximation algorithm for the same problem and runs in O (n 2 log n) time. We omit the proof of the following negative results for the various algorithms. Note that, after learning of our results, Stougie and Vestjens <ref> [25] </ref> improved the lower bound for randomized on-line algorithms to e=(e 1). This implies that our randomized on-line algorithm is optimal. Theorem 2.3. 1. For ff chosen uniformly, the ex pected approximation ratio is at least 2. 2.
Reference: [26] <author> S. Weiss and J.E. Smith. </author> <title> A study of scalar compilation techniques for pipelined supercomputers. </title> <booktitle> In Proceedings of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS). </booktitle> <year> 1987. </year>
Reference-contexts: An important motivation for studying weighted completion time, aside from its intrinsic theoretical interest, comes from application to compiler optimizations. Compile-time instruction scheduling is essential for effectively exploiting the fine-grained parallelism offered in pipelined, superscalar, and VLIW architectures (for example, see <ref> [13, 26] </ref>). Current research is addressing the issue of profile-based compiler optimization.
Reference: [27] <author> A.C. Yao. </author> <title> Probabilistic computations: Towards a unified measure of complexity. </title> <booktitle> In Proceedings of the 17th Annual Symposium on Foundations of Computer 11 Science, </booktitle> <year> 1977, </year> <pages> pp. 222-227. </pages>
References-found: 27

