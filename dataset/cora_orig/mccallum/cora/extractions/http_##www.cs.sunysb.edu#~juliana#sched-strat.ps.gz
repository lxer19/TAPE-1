URL: http://www.cs.sunysb.edu/~juliana/sched-strat.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,tswift,warreng@cs.sunysb.edu  
Title: Beyond Depth-First: Improving Tabled Logic Programs through Alternative Scheduling Strategies  
Author: Juliana Freire Terrance Swift David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: Tabled evaluations ensure termination of logic programs with finite models by keeping track of which subgoals have been called. Given several variant subgoals in an evaluation, only the first one encountered will use program clause resolution; the rest uses answer resolution. This use of answer resolution prevents infinite looping which happens in SLD. Given the asynchronicity of answer generation and answer return, tabling systems face an important scheduling choice not present in traditional top-down evaluation: How does the order of returning answers to consuming subgoals affect program efficiency. This paper investigates alternate scheduling strategies for tabling in a WAM implementation, the SLG-WAM. The original SLG-WAM had a simple mechanism of scheduling answers to be returned to callers which was expensive in terms of trailing and choice point creation. We propose here a more sophisticated scheduling strategy, Batched Scheduling, which reduces the overheads of these operations and provides dramatic space reduction as well as speedups for many programs. We also propose a second strategy, Local Scheduling, which has applications to non-monotonic reasoning and when combined with answer subsumption can improve the performance of some programs by arbitrary amounts.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. At-Kaci. </author> <title> WAM: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We thus refer to the unlabeled SDG as a pre-stratification of a system. Single Stack Scheduling The scheduling of resolution in Prolog <ref> [1] </ref> is conceptually simple. The engine performs forward execution for as long as it possibly can.
Reference: 2. <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, these different strategies can benefit the serious research and industrial applications which are beginning to emerge. To take a well-known instance, in order to efficiently evaluate queries to disk-resident data, a tabling system should provide set-at-a-time processing analogous to the semi-naive evaluation of a magic-transformed <ref> [2] </ref> program, so that communication and I/O costs are minimized. To address this, a separate paper defined a breadth-first set-at-a-time strategy for the SLG-WAM [15] of XSB 2 and proved it iteration equivalent to the semi-naive evaluation of a magic transformed program [8]. <p> This latter step gives good performance for in memory queries, but makes the Batched Scheduling algorithm differ from traditional goal-oriented formulations of semi-naive fixpoint 5 such as Magic evaluation <ref> [2] </ref>. Batched Scheduling bears some resemblance to other two independently developed approaches: the ET fl algorithm from [5] and the AMAI from [10]. However, in [5], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers, what might cause inefficiencies.
Reference: 3. <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year> <month> 13 </month>
Reference-contexts: in time. * Local Scheduling can provide large speedups for programs that require answer subsumption, while incurring a relatively small constant cost for programs that do not. 2 Scheduling SLG Evaluations Review of SLG Terminology Full details of the concepts and terminology presented in this section can be found in <ref> [3] </ref>. In an SLG evaluation predicates can be either tabled or non-tabled, in which case SLD resolution is used. Evaluations in tabling systems are usually modeled by a forest of resolution trees containing a tree for every tabled subgoal present in an evaluation.
Reference: 4. <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical Program Analysis Using General Purpose Logic Programming Systems | A Case Study. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 117-125. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. <ref> [4, 10] </ref>), for deductive database queries that use aggregates [17], and for answers involving constraints [9]. This paper motivates and describes two new types of scheduling for tabled logic programs: We describe Batched Scheduling which is highly efficient for in-memory programs that do not require answer subsumption.
Reference: 5. <author> C. Fan and S. Dietrich. </author> <title> Extension Table Built-ins for Prolo. </title> <journal> Software-Practice and Experience, </journal> <volume> 22(7) </volume> <pages> 573-597, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: This latter step gives good performance for in memory queries, but makes the Batched Scheduling algorithm differ from traditional goal-oriented formulations of semi-naive fixpoint 5 such as Magic evaluation [2]. Batched Scheduling bears some resemblance to other two independently developed approaches: the ET fl algorithm from <ref> [5] </ref> and the AMAI from [10]. However, in [5], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers, what might cause inefficiencies. <p> Batched Scheduling bears some resemblance to other two independently developed approaches: the ET fl algorithm from <ref> [5] </ref> and the AMAI from [10]. However, in [5], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers, what might cause inefficiencies. In [10], Janssens et al. describe an abstract machine specialized for abstract interpretation and use a similar scheduling strategy for their fixpoint iterations.
Reference: 6. <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting Parallelism in Tabled Evaluations. </title> <booktitle> In 7th International Symposium, </booktitle> <volume> PLILP 95 - LNCS Vol. 982. </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: While single-stack scheduling is simple to conceptualize, it contains several drawbacks. First, the integration of the action of returning answers into the mechanism of the choice point stack makes Single Stack Scheduling not easily adaptable to a parallel engine <ref> [6] </ref>. Another problem is memory usage: In order to perform answer clause resolution at different points in the SLG forest, the stacks have to be frozen so that the environment can be correctly reconstructed at the different points.
Reference: 7. <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Batched answers: An alternative strategy for tabled evaluations. </title> <type> Technical Report 96/2, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1996. </year>
Reference-contexts: In other words, answers are returned outside of an SCC (that is, to consuming nodes in trees whose root subgoal is not in the SCC) only 5 Details of these differences can be found in <ref> [7] </ref>. 7 after that SCC is completely evaluated. The action of Local Scheduling can easily be seen through the following example of stratified evaluation. (a) Negative dependencies (b) No negative dependencies Fig. 5. Subgoal dependency graphs for program P of Example 3 under different search strategies Example 3.
Reference: 8. <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <type> Technical Report 96/4, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1996. </year>
Reference-contexts: To address this, a separate paper defined a breadth-first set-at-a-time strategy for the SLG-WAM [15] of XSB 2 and proved it iteration equivalent to the semi-naive evaluation of a magic transformed program <ref> [8] </ref>. Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed very good performance for disk accesses. ? To appear in PLILP 96. 2 XSB is freely available at http://www.cs.sunysb.edu/~sbprolog.
Reference: 9. <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. [4, 10]), for deductive database queries that use aggregates [17], and for answers involving constraints <ref> [9] </ref>. This paper motivates and describes two new types of scheduling for tabled logic programs: We describe Batched Scheduling which is highly efficient for in-memory programs that do not require answer subsumption.
Reference: 10. <author> G. Janssens, M. Bruynooghe, and V. Dumortier. </author> <title> A Blueprint for an Abstract Machine for Abstract Interpretation of (Constraint) Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <year> 1995. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. <ref> [4, 10] </ref>), for deductive database queries that use aggregates [17], and for answers involving constraints [9]. This paper motivates and describes two new types of scheduling for tabled logic programs: We describe Batched Scheduling which is highly efficient for in-memory programs that do not require answer subsumption. <p> Batched Scheduling bears some resemblance to other two independently developed approaches: the ET fl algorithm from [5] and the AMAI from <ref> [10] </ref>. However, in [5], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers, what might cause inefficiencies. In [10], Janssens et al. describe an abstract machine specialized for abstract interpretation and use a similar scheduling strategy for their fixpoint iterations. <p> Batched Scheduling bears some resemblance to other two independently developed approaches: the ET fl algorithm from [5] and the AMAI from <ref> [10] </ref>. However, in [5], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers, what might cause inefficiencies. In [10], Janssens et al. describe an abstract machine specialized for abstract interpretation and use a similar scheduling strategy for their fixpoint iterations.
Reference: 11. <author> D. E. Knuth. </author> <title> The Stanford GraphBase: A Platform for Combinatorial Computing. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: graphs, based on Knuth's Words 7 . 6 Implementation details are given in the expanded version of this paper available at http://www.cs.sunysb.edu/~sbprolog. 7 The nodes of this graph are the 5757 more common 5-letter English words; there is an arc between two words if they differ in a single character <ref> [11] </ref>. 9 Transitive Closure reach (X,Y) :- arc (X,Y). reach (X,Y) :- reach (X,Z), arc (Z,Y). Shortest-Path sp (X,Y)(D) :- arc (X,Y,D). sp (X,Y)(D) :- subsumes (min)(sp (X,Z),D1), arc (Z,Y,D2), D is D1+D2.
Reference: 12. <author> G. Kostler, W. Kiessling, H. Thone, and U. Guntzer. </author> <title> Fixpoint iteration with subsumption in deductive databases. </title> <journal> Journal of Intelligent Information Systems (JIIS), </journal> <volume> 4(2) </volume> <pages> 123-148, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Resolving a call to a negative literal requires completely evaluating the subgoal contained in the literal, along with all other dependent subgoals. In a similar manner, waiting until part of an evaluation has been completely evaluated can also benefit programs that use answer subsumption (e.g. <ref> [12] </ref>), in which only the most general answers need to be maintained and returned to consuming subgoals.
Reference: 13. <author> T.C. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated least fixed point model. </title> <booktitle> In Proceedings of the ACM Symposium on Principle of Database Systems (PODS), </booktitle> <pages> pages 11-21, </pages> <year> 1989. </year>
Reference-contexts: Note that the dependency graph may be labeled with different types of dependencies: positive or negative dependencies in normal programs, or aggregate dependencies in deductive database programs. Given the usual dependency labelings for normal programs, these SDGs can be related to the dynamic stratification of <ref> [13] </ref> in the sense that a program is dynamically stratified if there is a dynamic computation rule which avoids labeled SDGs that have cycles through negation. We thus refer to the unlabeled SDG as a pre-stratification of a system.
Reference: 14. <author> T. Swift. </author> <title> Efficient Evaluation of Normal Logic Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: The choice point stack thus serves as a scheduling stack for both returning answers and resolving program clauses. Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in <ref> [14] </ref> and forms the basis of XSB's SLG-WAM as described in [15]. The following example demonstrates how this strategy works. Example 1. Consider the following double-recursive transitive closure :- table p/2. a (1,2). a (1,3). a (2,3). p (X,Y) :- a (X,Y). and the query ?- p (1,Y).
Reference: 15. <author> T. Swift and D. S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: To address this, a separate paper defined a breadth-first set-at-a-time strategy for the SLG-WAM <ref> [15] </ref> of XSB 2 and proved it iteration equivalent to the semi-naive evaluation of a magic transformed program [8]. <p> Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in [14] and forms the basis of XSB's SLG-WAM as described in <ref> [15] </ref>. The following example demonstrates how this strategy works. Example 1. Consider the following double-recursive transitive closure :- table p/2. a (1,2). a (1,3). a (2,3). p (X,Y) :- a (X,Y). and the query ?- p (1,Y).
Reference: 16. <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 219-238, </pages> <year> 1994. </year>
Reference-contexts: Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed very good performance for disk accesses. ? To appear in PLILP 96. 2 XSB is freely available at http://www.cs.sunysb.edu/~sbprolog. Of course tabled evaluations must also be efficient in terms of time and space for in-memory queries. <ref> [16] </ref> showed that, compared to Prolog, tabled evaluation incurred a minimal execution time overhead under several different criteria of measurement. <p> We describe Local Scheduling, which provides an elegant strategy to evaluate both fixed-order stratified programs, and programs which use answer subsumption. We provide detailed results of experiments comparing these two strategies with XSB's original Single Stack Scheduling (described in <ref> [16] </ref>).
Reference: 17. <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 13-34, </pages> <year> 1993. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. [4, 10]), for deductive database queries that use aggregates <ref> [17] </ref>, and for answers involving constraints [9]. This paper motivates and describes two new types of scheduling for tabled logic programs: We describe Batched Scheduling which is highly efficient for in-memory programs that do not require answer subsumption.
Reference: 18. <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year> <month> 14 </month>
Reference-contexts: Local Scheduling can perform asymptotically better than Batched Scheduling when combined with answer subsumption. This can be of use in many different areas such as aggregate selection and program analysis. In addition, Local Scheduling may have an important role to play in evaluating programs under the well-founded semantics <ref> [18] </ref>. Currently in XSB the engine may have to construct part of the SDG to check for loops through negation. Since Local Scheduling maintains exact SCCs, it does not require this step as was demonstrated by Example 3.
References-found: 18

