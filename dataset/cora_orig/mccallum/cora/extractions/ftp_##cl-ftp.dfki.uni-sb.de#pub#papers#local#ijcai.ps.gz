URL: ftp://cl-ftp.dfki.uni-sb.de/pub/papers/local/ijcai.ps.gz
Refering-URL: http://cl-www.dfki.uni-sb.de/cl/papers/cl-abstracts.html
Root-URL: 
Email: fkrieger,schaeferg@dfki.uni-sb.de  
Phone: phone: (+49 681) 302-5299 fax: (+49 681) 302-5341  
Title: Efficient Parameterizable Type Expansion for Typed Feature Formalisms  
Author: Hans-Ulrich Krieger, Ulrich Schafer 
Keyword: Natural language, typed feature formalisms, recursive feature types. Knowledge representation, languages and systems for  
Note: representing knowledge.  
Address: Stuhlsatzenhausweg 3, 66123 Saarbrucken, Germany  
Affiliation: German Research Center for Artificial Intelligence (DFKI)  
Abstract: Over the last few years, constraint-based grammar formalisms have become the predominant paradigm in natural language processing and computational linguistics. From the viewpoint of computer science, typed feature structures can be seen as data structures that allow to represent linguistic knowledge in a uniform fashion. Type expansion is an operation that makes constraints of a typed feature structure explicit and determines its satisfiability. We describe an efficient expansion algorithm that takes care of recursive type definitions and allows to explore different expansion strategies through the use of control knowledge. This knowledge is specified on a separate layer, independent of grammatical information. The algorithm, as presented in the paper, has been fully implemented in Common Lisp and is an integrated part of a large NL system. This paper has not already been accepted by and is not currently under review for a journal or another conference. Nor will it be sub mitted for such during IJCAI's review period. 
Abstract-found: 1
Intro-found: 1
Reference: [ At-Kaci and Nasr, 1986 ] <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: The language he described was called KBL and shared great similarities with LOGIN; see <ref> [ At-Kaci and Nasr, 1986 ] </ref> . However, the expansion mechanism he outlined was order dependent in that it substituted types by their definition instead of unifying the information.
Reference: [ At-Kaci et al., 1993 ] <author> Hassan At-Kaci, Andreas Podelski, and Seth Copen Gold-stein. </author> <title> Order-sorted feature theory unification. </title> <type> Technical Report 32, </type> <institution> Digital Equipment Corporation, DEC Paris Research Laboratory, France, </institution> <month> May </month> <year> 1993. </year> <booktitle> Also in Proceedings of the International Symposium on Logic Programming, </booktitle> <address> Oct. 1993, </address> <publisher> MIT Press. </publisher>
Reference-contexts: Note that recursive types can be substituted by definite relations (equivalences), as is the case for CUF, such that parsing/generation roughly corresponds to SLD resolution. 2 It is worth noting that our notion of TE shares similarities with At-Kaci's sort unfolding <ref> [ At-Kaci et al., 1993 ] </ref> and Carpenter's total well-typedness [ Carpenter, 1992, Ch. 6 ] . <p> algorithm is independent of the underlying deduction system|we are not interested in the normalization of feature constraints (i.e., how unification 3 It should be noted that we define TFS to have a nested structure and not to be flat (in contrast to feature clauses in a more logic-oriented approach, e.g., <ref> [ At-Kaci et al., 1993 ] </ref> ) in order to make the connection to the implementation clear and to come close to the structured attribute-value matrix notation. 4 of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower <p> In every other case, the unfolding process goes on by substituting types through their definitions. Recently, <ref> [ At-Kaci et al., 1993 ] </ref> have formally shown a similar result by using the compactness theorem of first-order logic. However, their proof assumes the existence of an infinite OSF clause (generated by unfolding a -term). Thus our algorithm might not terminate if we choose the complete expansion strategy.
Reference: [ At-Kaci, 1986 ] <author> Hassan At-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 293-351, </pages> <year> 1986. </year>
Reference-contexts: In the following, we refer to a type hierarchy I by a pair hT ; i, such that T fi T is a decidable partial order, i.e., is reflexive, antisymmetric, and transitive. A typed feature structure (TFS) is essentially either a -term or an *-term <ref> [ At-Kaci, 1986 ] </ref> , i.e., ::= hx; t; i j hx; t; fii such that x 2 V, t 2 T , = ff 1 : : where each f i 2 F and i is again a TFS. <p> on the construction of a fixpoint over a certain continuous function. 4 The first approach is in general closer to an implementation (and thus to our algorithm) in that the function which is involved in the fixpoint construction corresponds more or less to the unification/substitution of TFS (see for instance <ref> [ At-Kaci, 1986 ] </ref> or [ Pollard and Moshier, 1990 ] ). <p> that cyc-list is a subtype of list ): 8x:cyc-list (x) $ 9y; z:list (x) ^ first (x; y) ^ rest (x; z) ^ y : : 5 Comparison to other Approaches To our knowledge, the problem of type expansion within a typed feature-based environment was first addressed by Hassan At-Kaci <ref> [ At-Kaci, 1986 ] </ref> . The language he described was called KBL and shared great similarities with LOGIN; see [ At-Kaci and Nasr, 1986 ] . However, the expansion mechanism he outlined was order dependent in that it substituted types by their definition instead of unifying the information.
Reference: [ At-Kaci, 1993 ] <author> Hassan At-Kaci. </author> <title> An introduction to LIFE|programming with logic, inheritance, functions, and equations. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 52-68, </pages> <year> 1993. </year>
Reference-contexts: Another possibility one might follow is to integrate TE into the typed unification process so that TE can take place at run time. Systems that explore this strategy are TFS [ Zajac, 1992 ] and LIFE <ref> [ At-Kaci, 1993 ] </ref> . However, both implementations are not lazy, thus hard to control and moreover, might not terminate. In addition, if prototype memoization is not available, TE at run time is inefficient; cf. the results of our grammar example on page 8).
Reference: [ Carpenter and Penn, 1994 ] <author> Bob Carpenter and Gerald Penn. </author> <title> ALE|the attribute logic engine user's guide. version 2.0. </title> <type> Technical report, </type> <institution> Laboratory for Computational Linguistics. Philosophy Department, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: the connection to the implementation clear and to come close to the structured attribute-value matrix notation. 4 of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower bound is obligatory (TFS [ Zajac, 1992 ] ; ALE <ref> [ Carpenter and Penn, 1994 ] </ref> ) or optional as in T DL [ Krieger and Schafer, 1994 ] . We assume here that typed unification is simply a black box and can be accessed through an interface function (say unify-tfs). <p> However, the expansion mechanism he outlined was order dependent in that it substituted types by their definition instead of unifying the information. Moreover, it was non-lazy, thus it will fail to terminate for recursive types and performs TE only at definition time as is the case for ALE <ref> [ Carpenter and Penn, 1994 ] </ref> . However, ALE provides recursion through a built-in bottom-up chart parser and through definite clauses. Allowing TE only at definition time is in general space consuming, thus unification and copying is expensive at run time.
Reference: [ Carpenter, 1992 ] <author> Bob Carpenter. </author> <title> The Logic of Typed Feature Structures. </title> <booktitle> Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: that recursive types can be substituted by definite relations (equivalences), as is the case for CUF, such that parsing/generation roughly corresponds to SLD resolution. 2 It is worth noting that our notion of TE shares similarities with At-Kaci's sort unfolding [ At-Kaci et al., 1993 ] and Carpenter's total well-typedness <ref> [ Carpenter, 1992, Ch. 6 ] </ref> .
Reference: [ Dorre and Dorna, 1993 ] <author> Jochen Dorre and Michael Dorna. </author> <title> CUF|a formalism for linguistic knowledge representation. </title> <editor> In Jochen Dorre, editor, </editor> <title> Computational Aspects of Constraint-Based Linguistic Description I. </title> <address> DYANA, </address> <year> 1993. </year>
Reference-contexts: Later, other operations came into play, e.g., (classical) negation. However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS [ Zajac, 1992 ] , CUF <ref> [ Dorre and Dorna, 1993 ] </ref> , or TDL [ Krieger and Schafer, 1994 ] . Types are ordered hierarchically as it is known from object-oriented programming languages, a feature heavily employed in lexicalized grammar theories like Head-Driven Phrase Structure Grammar (HPSG) [ Pollard and Sag, 1987 ] . <p> In addition, if prototype memoization is not available, TE at run time is inefficient; cf. the results of our grammar example on page 8). A system that employs a lazy strategy on demand at run time is CUF <ref> [ Dorre and Dorna, 1993 ] </ref> . Laziness can be achieved here by specifying delay patterns as is familiar from Prolog.
Reference: [ Eisele and Dorre, 1990 ] <author> Andreas Eisele and Jochen Dorre. </author> <title> Disjunctive unification. </title> <type> IWBS Report 124, </type> <institution> IWBS, IBM Germany, Stuttgart, </institution> <year> 1990. </year>
Reference-contexts: The input is specified through a list under path input ; cf. the definition of type ab below. The distributed (or named) disjunction <ref> [ Eisele and Dorre, 1990 ] </ref> headed by $1 in type state1 is used to map input symbols to state types (and vice versa). 8 list ) fcons; h ig cons ) " first &gt; rest list # we abbreviate cons via h: : :i non-final-config ) 2 4 input h
Reference: [ Jaffar and Lassez, 1987 ] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: We only have to say a few words on the semantic foundations of our approach at the end of this paper. This is because we could either choose extensions of feature logic [ Smolka, 1989 ] or directly interpret our structures within the paradigm of (constraint) logic programming <ref> [ Lloyd, 1987; Jaffar and Lassez, 1987 ] </ref> . 3 Algorithm The overall design of our TE algorithm was inspired by the following requirements: * support a complete expansion strategy * allow lazy expansion of recursive types * minimize the number of unifications * make expansion parameterizable for delay and preference
Reference: [ Krieger and Schafer, 1994 ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|a type description language for constraint-based grammars. </title> <booktitle> In Proceedings of the 15th International Conference on Computational Linguistics, COLING-94, </booktitle> <address> Kyoto, Japan, </address> <pages> pages 893-899, </pages> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Later, other operations came into play, e.g., (classical) negation. However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS [ Zajac, 1992 ] , CUF [ Dorre and Dorna, 1993 ] , or TDL <ref> [ Krieger and Schafer, 1994 ] </ref> . Types are ordered hierarchically as it is known from object-oriented programming languages, a feature heavily employed in lexicalized grammar theories like Head-Driven Phrase Structure Grammar (HPSG) [ Pollard and Sag, 1987 ] . <p> attribute-value matrix notation. 4 of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower bound is obligatory (TFS [ Zajac, 1992 ] ; ALE [ Carpenter and Penn, 1994 ] ) or optional as in T DL <ref> [ Krieger and Schafer, 1994 ] </ref> . We assume here that typed unification is simply a black box and can be accessed through an interface function (say unify-tfs). <p> Because our notion of type expansion is conceived as a 13 stand-alone module here, one can freely choose the time of its invocation, e.g., during unification, parsing, etc. The algorithm, as presented in the paper, has been fully implemented within TDL <ref> [ Krieger and Schafer, 1994 ] </ref> and is an integrated part of the Disco system [ Uszkoreit et al., 1994 ] .
Reference: [ Krieger et al., 1993 ] <author> Hans-Ulrich Krieger, John Nerbonne, and Hannes Pirker. </author> <title> Feature-based allomorphy. </title> <booktitle> In Proceedings of the 31st Annual Meeting of the Association for Computational Linguistics, </booktitle> <year> 1993. </year> <note> A version of this paper is available as DFKI Research Report RR-93-28. </note>
Reference-contexts: An instance of such a recursive type that stops is the recursive version of list , as defined below. 3.4 Example In the following, we define a finite state machine <ref> [ Krieger et al., 1993 ] </ref> with two states that accepts the language a fl (a+b). The input is specified through a list under path input ; cf. the definition of type ab below.
Reference: [ Lloyd, 1987 ] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: We only have to say a few words on the semantic foundations of our approach at the end of this paper. This is because we could either choose extensions of feature logic [ Smolka, 1989 ] or directly interpret our structures within the paradigm of (constraint) logic programming <ref> [ Lloyd, 1987; Jaffar and Lassez, 1987 ] </ref> . 3 Algorithm The overall design of our TE algorithm was inspired by the following requirements: * support a complete expansion strategy * allow lazy expansion of recursive types * minimize the number of unifications * make expansion parameterizable for delay and preference
Reference: [ Pollard and Moshier, 1990 ] <author> Carl J. Pollard and M. Drew Moshier. </author> <title> Unifying partial descriptions of sets. </title> <editor> In P. Hanson, editor, </editor> <title> Information, Language, </title> <journal> and Cognition. </journal> <volume> Vol. </volume> <booktitle> 1 of Vancouver Studies in Cognitive Science, </booktitle> <pages> pages 285-322. </pages> <institution> University of British Columbia Press, </institution> <year> 1990. </year>
Reference-contexts: fixpoint over a certain continuous function. 4 The first approach is in general closer to an implementation (and thus to our algorithm) in that the function which is involved in the fixpoint construction corresponds more or less to the unification/substitution of TFS (see for instance [ At-Kaci, 1986 ] or <ref> [ Pollard and Moshier, 1990 ] </ref> ). The latter approach is based on the assumption that TFS 4 In both cases, there is, in general, more than one fixpoint, but it seems desirable to choose the greatest one. 12 are only syntactic sugar for first-order formulae.
Reference: [ Pollard and Sag, 1987 ] <author> Carl Pollard and Ivan A. Sag. </author> <title> Information-Based Syntax and Semantics. Vol. I: Fundamentals. CSLI Lecture Notes, Number 13. Center for the Study of Language and Information, </title> <publisher> Stanford, </publisher> <year> 1987. </year>
Reference-contexts: Types are ordered hierarchically as it is known from object-oriented programming languages, a feature heavily employed in lexicalized grammar theories like Head-Driven Phrase Structure Grammar (HPSG) <ref> [ Pollard and Sag, 1987 ] </ref> . This leads to multiple inheritance in the description of linguistic entities. In general, not only is a type related to other types through the inheritance hierarchy, but is also provided with feature constraints that are idiosyncratic to this type.
Reference: [ Rounds and Manaster-Ramer, 1987 ] <author> William C. Rounds and Alexis Manaster-Ramer. </author> <title> A logical version of functional grammar. </title> <booktitle> In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 89-96, </pages> <year> 1987. </year>
Reference-contexts: the :attribute-preference list to define the "right" order for expansion. * Finally, one can define an appropriate :resolved-predicate that is suitable for a class of recursive types. 4 Theoretical Results It is worth noting that testing for the satisfiability of feature descriptions admitting recursive type equations/definitions is in general undecidable. <ref> [ Rounds and Manaster-Ramer, 1987 ] </ref> were the first having shown that a Kasper-Rounds logic enriched with recursive types allows one to encode a Turing machine. Later, [ Smolka, 1989 ] argued that the undecidability result is due to the use of coreference constraints.
Reference: [ Shieber et al., 1983 ] <author> Stuart Shieber, Hans Uszkoreit, Fernando Pereira, Jane Robinson, and Mabry Tyson. </author> <title> The formalism and implementation of PATR-II. </title> <editor> In Barbara J. Grosz and Mark E. Stickel, editors, </editor> <booktitle> Research on Interactive Acquisition and Use of Knowledge, </booktitle> <pages> pages 39-79. </pages> <institution> AI Center, SRI International, Menlo Park, Cal., </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction Over the last few years, constraint-based grammar formalisms [ Shieber, 1986 ] have become the predominant paradigm in natural language processing and computational linguistics. While the first approaches relied on annotated phrase structure rules (e.g., PATR-II <ref> [ Shieber et al., 1983 ] </ref> ), modern formalisms try to specify grammatical knowledge as well as lexicon entries entirely through feature structures. In order to achieve this goal, one must enrich the expressive power of the first unification-based formalisms with different forms of disjunctive descriptions.
Reference: [ Shieber, 1986 ] <author> Stuart M. Shieber. </author> <title> An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes, Number 4. Center for the Study of Language and Information, </title> <publisher> Stanford, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Over the last few years, constraint-based grammar formalisms <ref> [ Shieber, 1986 ] </ref> have become the predominant paradigm in natural language processing and computational linguistics.
Reference: [ Smolka, 1989 ] <author> Gert Smolka. </author> <title> Feature constraint logic for unification grammars. </title> <type> IWBS Report 93, </type> <institution> IWBS, IBM Germany, Stuttgart, </institution> <month> November </month> <year> 1989. </year> <note> Also in Journal of Logic Programming, </note> <month> 12 </month> <pages> 51-87, </pages> <year> 1992. </year>
Reference-contexts: We only have to say a few words on the semantic foundations of our approach at the end of this paper. This is because we could either choose extensions of feature logic <ref> [ Smolka, 1989 ] </ref> or directly interpret our structures within the paradigm of (constraint) logic programming [ Lloyd, 1987; Jaffar and Lassez, 1987 ] . 3 Algorithm The overall design of our TE algorithm was inspired by the following requirements: * support a complete expansion strategy * allow lazy expansion of <p> We adapt Smolka's treatment of negation for our TFS <ref> [ Smolka, 1989 ] </ref> . <p> Later, <ref> [ Smolka, 1989 ] </ref> argued that the undecidability result is due to the use of coreference constraints. He demonstrated his claim by encoding the word problem of Thue systems. Hence, our expansion mechanism is faced with the same result in that expansion might not terminate.
Reference: [ Uszkoreit et al., 1994 ] <author> Hans Uszkoreit, Rolf Backofen, Stephan Busemann, Ab-del Kader Diagne, Elizabeth A. Hinkelman, Walter Kasper, Bernd Kiefer, Hans-Ulrich Krieger, Klaus Netter, Gunter Neumann, Stephan Oepen, and Stephen P. Spackman. </author> <title> DISCO|an HPSG-based NLP system and its application for appointment scheduling. </title> <booktitle> In Proceedings of COLING-94, </booktitle> <address> Kyoto, Japan, </address> <pages> pages 436-440, </pages> <year> 1994. </year> <note> A version of this paper is available as DFKI Research Report RR-94-38. </note>
Reference-contexts: The algorithm, as presented in the paper, has been fully implemented within TDL [ Krieger and Schafer, 1994 ] and is an integrated part of the Disco system <ref> [ Uszkoreit et al., 1994 ] </ref> .
Reference: [ Uszkoreit, 1991 ] <author> Hans Uszkoreit. </author> <title> Strategies for adding control information to declarative grammars. </title> <booktitle> In Proceedings of the 29th Meeting of the Association for Computational Linguistics (ACL), </booktitle> <pages> pages 237-245, </pages> <year> 1991. </year>
Reference-contexts: Working in the type deduction paradigm enforces a grammar writer to replace the context-free backbone through recursive types. Here, parameterized delayed type expansion is the key to controlled linguistic deduction <ref> [ Uszkoreit, 1991 ] </ref> . In the next section, we introduce the basic inventory to describe our own novel approach to TE. We then describe the basic structure of the algorithm, present several improvements, and show how it can be parameterized w.r.t. different dimension. <p> The substructures at the attributes leftmost in the list 10 will be expanded first. This non-numerical preference may speed up expansion if no numerical heuristics are known. * :use-fconjjdisjg-heuristics ftjnilg <ref> [ Uszkoreit, 1991 ] </ref> suggested to exploit numerical preferences to speed up unification.
Reference: [ Zajac, 1992 ] <author> Remi Zajac. </author> <title> Inheritance and constraint-based grammar formalisms. </title> <journal> Computational Linguistics, </journal> <volume> 18(2) </volume> <pages> 159-182, </pages> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Later, other operations came into play, e.g., (classical) negation. However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS <ref> [ Zajac, 1992 ] </ref> , CUF [ Dorre and Dorna, 1993 ] , or TDL [ Krieger and Schafer, 1994 ] . <p> ] ) in order to make the connection to the implementation clear and to come close to the structured attribute-value matrix notation. 4 of feature structures is actually done) nor are we interested in the logic of types, e.g., whether the existence of a greatest lower bound is obligatory (TFS <ref> [ Zajac, 1992 ] </ref> ; ALE [ Carpenter and Penn, 1994 ] ) or optional as in T DL [ Krieger and Schafer, 1994 ] . We assume here that typed unification is simply a black box and can be accessed through an interface function (say unify-tfs). <p> Another possibility one might follow is to integrate TE into the typed unification process so that TE can take place at run time. Systems that explore this strategy are TFS <ref> [ Zajac, 1992 ] </ref> and LIFE [ At-Kaci, 1993 ] . However, both implementations are not lazy, thus hard to control and moreover, might not terminate. In addition, if prototype memoization is not available, TE at run time is inefficient; cf. the results of our grammar example on page 8).
References-found: 21

