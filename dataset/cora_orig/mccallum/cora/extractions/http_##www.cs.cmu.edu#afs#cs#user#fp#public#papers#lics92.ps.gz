URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/lics92.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: Email: hannan@diku.dk  Email: fp@cs.cmu.edu  
Title: Compiler Verification in LF  
Author: John Hannan Frank Pfenning 
Address: Universitetsparken 1 DK-2100 Copenhagen Denmark  5000 Forbes Avenue Pittsburgh, PA 15213-3890, U.S.A.  
Affiliation: Department of Computer Science University of Copenhagen  School of Computer Science Carnegie Mellon University  
Abstract: We sketch a methodology for the verification of compiler correctness based on the LF Logical Framework as realized within the Elf programming language. We have applied this technique to specify, implement, and verify a compiler from a simple functional programming language to a variant of the Categorical Abstract Machine (CAM). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: We start by informally presenting a first-order abstract syntax for -terms: Expressions F ::= 1 j F " j flF j F 1 F 2 This notation uses a slight generalization of de Bruijn notation. Here, the constructor " (reminiscent of the shift operator in the -calculus <ref> [1] </ref>) is used to generate indices greater than 1. For example, the term x: y: xy is represented by flfl ((1")1). The representation in LF is straightforward. fexp : type. 1 : fexp. ^ : fexp -&gt; fexp. $ : fexp -&gt; fexp. @ : fexp -&gt; fexp -&gt; fexp.
Reference: [2] <author> R. Burstall and F. Honsell. </author> <title> Operational semantics in a natural deduction setting. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 185-214. </pages> <publisher> Cam-bridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Here we consider this paradigm using the example of an operational semantics, presented as a deductive system. Various axiomatizations of operational semantics in LF are investigated in <ref> [2, 15] </ref>. The primary judgment is e ,! v (e evaluates to v).
Reference: [3] <author> B. Ciesielski and M. Wand. </author> <title> Using the theorem prover Isabelle-91 to verify a simple proof of compiler correctness. </title> <type> Unpublished Draft, </type> <year> 1991. </year>
Reference-contexts: The idea of using deductive systems to prove properties of compilers is also found in [23] where judgments are used to verify that a compiler correctly uses the static properties of its symbol tables. Using the theorem prover Isabelle-91 [18], <ref> [3] </ref> gives a mechanized proof of compiler correctness. This work is based on using denotational semantics 2 for the source language of the compiler, rather than operational semantics.
Reference: [4] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-27. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: This method stops short of generating machine code for actual hardware, but some ideas towards this goal are presented in [9]. We have used this three stage strategy to construct and verify a compiler from the language Mini-ML (a core subset of Standard ML introduced in <ref> [4] </ref>) to a variant of the Categorical Abstract Machine [6]. Proofs of this translation exist [7, 6], but to our knowledge they have not previously been mechanically verified. Many other approaches to compiling languages can be considered in the LF setting.
Reference: [5] <author> T. Coquand. </author> <title> An algorithm for testing conversion in type theory. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 255-279. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Similarly, A ! K can stand for x:A: K when x does not appear free in K. A signature declares the kinds of family-level constants a and types of object-level constants c. The notion of definitional equality we consider here is based on fi-conversion. Type-checking remains decidable (see <ref> [5] </ref>) and it has the advantage over the original formulation with only fi-conversion that every term has an equivalent canonical form. 2.1 Realization in Elf We present the concrete syntax for Elf in the form of a grammar, where optional constituents are enclosed within h i.
Reference: [6] <editor> G. Cousineau, P.-L. Curien, and M. Mauny. </editor> <booktitle> The cat egorical abstract machine. The Science of Programming, </booktitle> <volume> 8(2) </volume> <pages> 173-202, </pages> <year> 1987. </year>
Reference-contexts: Operational Semantics as Deductive Systems. We can specify operational semantics as deductive systems. In such semantics deductions represent computations. Compiler correctness then reduces to verifying a correspondence between deductions (i.e., computations) in the two semantics. The correctness proof found in <ref> [6] </ref> for a simple compiler from -terms to CAM (Cat-egorical Abstract Machine) code uses this idea. <p> Program Translations as Deductive Systems. We can describe translations (compilations) between programs as deductive systems, axiomatizing relations between programs in source and target languages. This idea appears in [7], where the compiler from <ref> [6] </ref> is given as a deductive system; and the semantics for both source and target languages are given as deductive systems. These are all specified in Typol, a programming language supporting the definition of natural semantics [14]. <p> We have used this three stage strategy to construct and verify a compiler from the language Mini-ML (a core subset of Standard ML introduced in [4]) to a variant of the Categorical Abstract Machine <ref> [6] </ref>. Proofs of this translation exist [7, 6], but to our knowledge they have not previously been mechanically verified. Many other approaches to compiling languages can be considered in the LF setting. <p> We have used this three stage strategy to construct and verify a compiler from the language Mini-ML (a core subset of Standard ML introduced in [4]) to a variant of the Categorical Abstract Machine [6]. Proofs of this translation exist <ref> [7, 6] </ref>, but to our knowledge they have not previously been mechanically verified. Many other approaches to compiling languages can be considered in the LF setting. An initial phase of many compilers consists of performing source-to-source program transformations to produce programs from which better code can be generated.

Reference: [8] <author> J. Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Lan guage for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> January </month> <year> 1991. </year> <note> Available as MS-CIS-91-09. </note>
Reference-contexts: Traditional approaches to this task are based on denotational semantics and use abstract interpretation to provide information about the flow of data through programs. Some initial work in using deductive systems to perform such analyses can be found in <ref> [8] </ref> in which the problem of strictness analysis is addressed. 7 Conclusion and Future Work We have demonstrated how the LF Logical Framework provides a natural setting for verifying the correctness of compilers.
Reference: [9] <author> J. Hannan. </author> <title> Making abstract machines less abstract. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 618-635, </pages> <address> Cambridge, Massachussetts, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag LNCS 523. </note>
Reference-contexts: The compilation rules translate the source expressions into an intermediate-level abstract machine code, while the execution rules pro vide the definition for this abstract machine language. This method stops short of generating machine code for actual hardware, but some ideas towards this goal are presented in <ref> [9] </ref>. We have used this three stage strategy to construct and verify a compiler from the language Mini-ML (a core subset of Standard ML introduced in [4]) to a variant of the Categorical Abstract Machine [6].
Reference: [10] <author> J. Hannan. </author> <title> Staging transformations for abstract ma chines. </title> <booktitle> In ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 130-141, </pages> <address> New Haven, Connecticut, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: We have, however, examined some particular methods and shown correctness results for various stages of compilers. A particular method of compiler construction that we have examined is the one based on a series of papers describing the translation of operational semantics to 8 intermediate level abstract machines <ref> [12, 10] </ref>. In this work compilers are constructed from operational semantics via a three stage process. We assume that the source language is defined via an operational semantics that axiomatizes a relation between programs and values. <p> This step is based on the idea of staging transformations in which the original rewrite rules are decomposed into compilation and execution stages <ref> [10] </ref>. The compilation rules translate the source expressions into an intermediate-level abstract machine code, while the execution rules pro vide the definition for this abstract machine language. This method stops short of generating machine code for actual hardware, but some ideas towards this goal are presented in [9].
Reference: [11] <author> J. Hannan and D. Miller. </author> <title> A meta-logic for functional programming. </title> <editor> In H. Abramson and M. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, chapter 24, </booktitle> <pages> pages 453-476. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: At the highest level, the abstract syntax is higher-order, that is, contains meta-level abstractions. The idea is to use meta-level variables to represent object-level variables. This leads to a very intuitive and succinct, yet executable specification of the operational semantics of a language <ref> [11] </ref>. At lower levels we can define abstract syntaxes for languages resembling machine code. <p> We assume that the source language is defined via an operational semantics that axiomatizes a relation between programs and values. Furthermore, we assume that this definition uses a higher-order abstract syntax to represent programs (and possibly other structures). (See <ref> [11] </ref> for a discussion of semantics specified in this style.) The first stage is the translation from a semantics using this higher-order syntax to one using a first-order syntax, similar to the example of the previous section.
Reference: [12] <author> J. Hannan and D. Miller. </author> <title> From operational seman tics to abstract machines: Preliminary results. </title> <editor> In M. Wand, editor, </editor> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 323-332, </pages> <address> Nice, France, </address> <year> 1990. </year>
Reference-contexts: We have, however, examined some particular methods and shown correctness results for various stages of compilers. A particular method of compiler construction that we have examined is the one based on a series of papers describing the translation of operational semantics to 8 intermediate level abstract machines <ref> [12, 10] </ref>. In this work compilers are constructed from operational semantics via a three stage process. We assume that the source language is defined via an operational semantics that axiomatizes a relation between programs and values.
Reference: [13] <author> R. Harper, F. Honsell, and G. Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <note> To appear. A preliminary version appeared in Symposium on Logic in Computer Science, pages 194-204, </note> <month> June </month> <year> 1987. </year>
Reference-contexts: Unfortunately, even for small languages and simple compilers, proving their correctness can be an enormous task, and verifying these proofs becomes an equally difficult task. Our goal is to develop techniques for mechanizing proofs of compiler correctness. To this end we employ 1. the LF Logical Framework <ref> [13] </ref> to specify rela tionships between source and target languages; 2. the Elf programming language [21] to provide an operational semantics for these relationships; and 3. a related meta-theory [22] to reason about the LF specifications. <p> In Section 6 we give an overview of some general verification techniques that we have used to verify simple compilers. Finally in Section 7 we conclude and briefly describe some future work. 2 Deductive Systems in LF We briefly review the LF logical framework <ref> [13] </ref> as realized in Elf [19, 21, 20]. A tutorial introduction to the Elf core language can be found in [15]. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type.
Reference: [14] <author> G. Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag LNCS 247, </publisher> <year> 1987. </year>
Reference-contexts: We use operational semantics to provide meanings for source and target programs. An appealing feature of using operational semantics is the ability to specify the meanings of high-level and low-level languages in a common framework. More importantly, in natural semantics <ref> [14] </ref> (a form of operational semantics) deductions provide explicit evidence for the relation between a program and its meaning. Given representations for the judgments found in the above diagram, we can reason about the correctness of translations as follows. <p> This idea appears in [7], where the compiler from [6] is given as a deductive system; and the semantics for both source and target languages are given as deductive systems. These are all specified in Typol, a programming language supporting the definition of natural semantics <ref> [14] </ref>. The informal verification of compiler correctness proceeds by induction on the structure of the deductions.
Reference: [15] <author> S. Michaylov and F. Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In Lars Hallnas, editor, </editor> <booktitle> Extensions of Logic Programming. </booktitle> <publisher> Springer-Verlag LNCS, </publisher> <year> 1992. </year> <note> To appear. A preliminary version is available as Technical Report MPI-I-91-211, </note> <institution> Max-Planck-Institute for Computer Science, Saarbrucken, Germany, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: A mechanical verification of a code generator for an imperative language using the Boyer-Moore theorem prover is described in [24]. This verification is also based on an operational semantics, but both source and target languages are very different from what we consider here. In <ref> [15, 22] </ref> some other examples of properties of programming languages that can be verified using LF are given. <p> Finally in Section 7 we conclude and briefly describe some future work. 2 Deductive Systems in LF We briefly review the LF logical framework [13] as realized in Elf [19, 21, 20]. A tutorial introduction to the Elf core language can be found in <ref> [15] </ref>. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type. <p> Instead of Prolog's first-order unification, Elf solves constraints given as dependently typed functional equations. A constant declaration (represent-ing an inference rule) plays the role of a clause, and a signature plays the role of a program. Due to space limitations, we must refer the reader to <ref> [19, 15, 21] </ref> for further material on the operational semantics of Elf. 2.2 Abstract Syntax in Elf For the example used throughout this paper, the source language of the compiler is an untyped calculus with only abstraction and application. <p> The operational semantics of a richer language and some of its meta-theory has been investigated in <ref> [15] </ref>, and the basic ideas here extend to this richer language. Expressions e ::= x j e 1 e 2 j x: e The first step in the axiomatization of a language in Elf is the description of the abstract syntax of the language. <p> Here we consider this paradigm using the example of an operational semantics, presented as a deductive system. Various axiomatizations of operational semantics in LF are investigated in <ref> [2, 15] </ref>. The primary judgment is e ,! v (e evaluates to v).
Reference: [16] <author> G. Nadathur and D. Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Thus deductions representing computations in an operational semantics become objects whose types identify the judgments in the semantics. We can then specify "higher-level" judgments that take as arguments objects representing deductions. We can manipulate objects representing deductions in languages with weaker type systems, such as Typol or Prolog <ref> [16] </ref>, but such specifications require explicit reasoning about the validity of such objects. For example, in these languages we could introduce new term constructors corresponding to the inference rules of an operational semantics, but this approach has two immediate shortcomings.
Reference: [17] <author> F. Nielson and H. Nielson. </author> <title> Two-level semantics and code generation. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 59-133, </pages> <year> 1988. </year>
Reference-contexts: Using the theorem prover Isabelle-91 [18], [3] gives a mechanized proof of compiler correctness. This work is based on using denotational semantics 2 for the source language of the compiler, rather than operational semantics. The relationship between code generation and denotational semantics is covered in <ref> [17] </ref>, although this work does not address mechanical verification of this relationship. A mechanical verification of a code generator for an imperative language using the Boyer-Moore theorem prover is described in [24].
Reference: [18] <author> L. Paulson and T. Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The idea of using deductive systems to prove properties of compilers is also found in [23] where judgments are used to verify that a compiler correctly uses the static properties of its symbol tables. Using the theorem prover Isabelle-91 <ref> [18] </ref>, [3] gives a mechanized proof of compiler correctness. This work is based on using denotational semantics 2 for the source language of the compiler, rather than operational semantics.
Reference: [19] <author> F. Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: In Section 6 we give an overview of some general verification techniques that we have used to verify simple compilers. Finally in Section 7 we conclude and briefly describe some future work. 2 Deductive Systems in LF We briefly review the LF logical framework [13] as realized in Elf <ref> [19, 21, 20] </ref>. A tutorial introduction to the Elf core language can be found in [15]. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type. <p> Instead of Prolog's first-order unification, Elf solves constraints given as dependently typed functional equations. A constant declaration (represent-ing an inference rule) plays the role of a clause, and a signature plays the role of a program. Due to space limitations, we must refer the reader to <ref> [19, 15, 21] </ref> for further material on the operational semantics of Elf. 2.2 Abstract Syntax in Elf For the example used throughout this paper, the source language of the compiler is an untyped calculus with only abstraction and application.
Reference: [20] <author> F. Pfenning. </author> <title> An implementation of the Elf core language in Standard ML. </title> <note> Available via ftp over the Internet, September 1991. Send mail to elf-request@cs.cmu.edu for further information. </note>
Reference-contexts: In Section 6 we give an overview of some general verification techniques that we have used to verify simple compilers. Finally in Section 7 we conclude and briefly describe some future work. 2 Deductive Systems in LF We briefly review the LF logical framework [13] as realized in Elf <ref> [19, 21, 20] </ref>. A tutorial introduction to the Elf core language can be found in [15]. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type.
Reference: [21] <author> F. Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Our goal is to develop techniques for mechanizing proofs of compiler correctness. To this end we employ 1. the LF Logical Framework [13] to specify rela tionships between source and target languages; 2. the Elf programming language <ref> [21] </ref> to provide an operational semantics for these relationships; and 3. a related meta-theory [22] to reason about the LF specifications. <p> In Section 6 we give an overview of some general verification techniques that we have used to verify simple compilers. Finally in Section 7 we conclude and briefly describe some future work. 2 Deductive Systems in LF We briefly review the LF logical framework [13] as realized in Elf <ref> [19, 21, 20] </ref>. A tutorial introduction to the Elf core language can be found in [15]. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type. <p> Term reconstruction fills in the omitted types in quantifications -xand abstractions [x] and omitted types or objects indicated by an underscore _. In case of ambiguity a warning or error message results. For a description of Elf's term reconstruction phase see <ref> [21] </ref>. 3 The operational semantics of Elf arises from a computational interpretation of types. This is similar in spirit to the way a computational interpretation of formulas in Horn logic gives rise to Pure Prolog. A goal is given by a type instead of a formula. <p> Instead of Prolog's first-order unification, Elf solves constraints given as dependently typed functional equations. A constant declaration (represent-ing an inference rule) plays the role of a clause, and a signature plays the role of a program. Due to space limitations, we must refer the reader to <ref> [19, 15, 21] </ref> for further material on the operational semantics of Elf. 2.2 Abstract Syntax in Elf For the example used throughout this paper, the source language of the compiler is an untyped calculus with only abstraction and application.
Reference: [22] <author> F. Pfenning and E. Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <address> Saratoga Springs, New York, </address> <month> June </month> <year> 1992. </year> <note> Springer-Verlag LNCS. To appear. </note>
Reference-contexts: To this end we employ 1. the LF Logical Framework [13] to specify rela tionships between source and target languages; 2. the Elf programming language [21] to provide an operational semantics for these relationships; and 3. a related meta-theory <ref> [22] </ref> to reason about the LF specifications. <p> A mechanical verification of a code generator for an imperative language using the Boyer-Moore theorem prover is described in [24]. This verification is also based on an operational semantics, but both source and target languages are very different from what we consider here. In <ref> [15, 22] </ref> some other examples of properties of programming languages that can be verified using LF are given. <p> The checking of Stage 4 must currently be done by hand. However, for certain classes of relations (anal-ogous to the class of primitive recursive functions) this checking can be automated. This process, called schema-checking, is discussed in more detail in <ref> [22] </ref>. It relies on induction over the structure of closed, valid LF terms over a given signature. All the examples in this paper and their extension to Mini-ML can be verified mechanically by schema-checking.
Reference: [23] <author> M. Wand and Z.-Y. Wang. </author> <title> Conditional lambda theories and the verification of static properties of programs. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 321-332, </pages> <address> Philadelphia, Pennsylvania, </address> <year> 1990. </year>
Reference-contexts: We do, however, mechanize the process of proof construction, exploiting the facilities of the Elf language to ensure partial correctness (through type constraints) and to manage the many necessary mathematical details (through term reconstruction). The idea of using deductive systems to prove properties of compilers is also found in <ref> [23] </ref> where judgments are used to verify that a compiler correctly uses the static properties of its symbol tables. Using the theorem prover Isabelle-91 [18], [3] gives a mechanized proof of compiler correctness.

References-found: 22

