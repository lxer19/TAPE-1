URL: http://www.cs.colorado.edu/~zorn/derby-thesis.ps
Refering-URL: http://www.cs.colorado.edu/~zorn/Home.html
Root-URL: http://www.cs.colorado.edu
Title: A Study of Language Ideas for Prototyping Numerical Computations  
Author: by Thomas M. Derby 
Note: University of Colorado,  
Address: 1991  
Affiliation: B.S., University of Colorado,  University of Colorado  Department of Computer Science  
Email: B.M.,  
Degree: A thesis submitted to the Faculty of the Graduate School of the  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: 1991  1999  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> ANSI. </author> <title> American National Standard Programming Language Fortran ANSI X3.9-1978. </title>
Reference-contexts: Indeed, its wide base of use suggests that it must have something going for it. FORTRAN <ref> [1] </ref> has been a very popular, almost standard, choice for numerical computation for a long time. While its popularity is often simply attributed to the "dusty deck" phenomenon, we feel that the imperative languages do have many very desirable features. <p> These "positioning" operators are a very typical feature (and problem) with array-based computation languages. Backus' FP system [3] is perhaps even more cryptic: Def IP j (n+) ffi (fffi) ffi trans Def MM j (ffffIP) ffi (ffdistl) ffi distr ffi <ref> [1; trans ffi 2] </ref> The details of exactly how this program works are immaterial here; the point is that languages that try to avoid explicit looping structures by using array operators tend to end up introducing a large number of operators that seem to have little to do with the actual <p> Because these languages are relatively familiar, we only discuss a small sampling of them. FORTRAN77 Although often maligned by those advocating more modern languages such as C, FOR-TRAN77 <ref> [1] </ref> actually has much to recommend it for numerical programming. In addition to the benefits of a standard scalar imperative language, FORTRAN77 also offers the following additional features: 34 * FORTRAN77 subprograms can support arguments that have varying, instead of fixed, size. <p> Multiple definitions of a variable are also illegal, as one might expect. Programs such as a = 3; are obvious nonsense in an unordered single assignment execution model. But the rule also prevents constructions such as a <ref> [1] </ref> = 3; because both assignments define the variable a. At first glance, this program seems perfectly sensible, even in a single assignment system, because the two assignments cannot ever assign the same element of a twice. <p> Thus, EQ bans all kinds of multiple assignments to the same variable name. This rule becomes more intuitive when one remembers that a partial assignment such as a <ref> [1] </ref> = 3 defines all of a, setting those elements not specifically assigned in the statement to the corresponding elements of prev a. Thus, our examples actually provide two values for each and every element of a, and therefore the code is illegal. <p> However, if we were to fuse these two loops together, the program would no longer work correctly; the assignments to B <ref> [1] </ref> and B [2] would be made before the value of A [3] had actually been defined, assuming the loops run in the incrementing (rather than decrementing) direction. These problems only occur when fusing loops with a dependency between them.
Reference: [2] <author> B. A. Ashcroft and W. W. Wadge. </author> <title> Lucid, a nonprocedural language with iteration. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 519-526, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Windowing is related to our work in Chapter 8 on rank reduction. In more recent research EPL has viewed itself as a useful intermediate form rather than a direct source language, and had considered the process of translating FORTRAN programs automatically into EPL for optimization [19]. Lucid Lucid <ref> [2, 76] </ref> is a data flow language in the most direct sense possible, because each variable v represents not a single value, but an entire stream of values at once. It too uses a single assignment rule, which means that the entire stream must be defined at once. <p> The technique is a little hard to demonstrate at this point, however, because we have not yet discussed EQ's array features. But if we suppose that zero_vec already contains a vector of five zeros, then the code prev x = zero_vec; x <ref> [2] </ref> = 1; next x [4] = 1; would produce a value in x which is the vector (0; 1; 0; 0; 0), and next x will be (0; 1; 0; 1; 0). <p> For each (base type, dimension) pair with non-zero dimension, a header file eqlib.h 185 (which is included by the generated C code) defines a type to represent the corresponding memvars. The declaration for two dimensional real variables is: typedef struct - double *data; int offset; axis_desc axis <ref> [2] </ref>; - double_array2; The data pointer points to the actual data, which is allocated using the C malloc function, but this pointer is offset so that no constant term will need to be added when indexing the array. <p> However, if we were to fuse these two loops together, the program would no longer work correctly; the assignments to B [1] and B <ref> [2] </ref> would be made before the value of A [3] had actually been defined, assuming the loops run in the incrementing (rather than decrementing) direction. These problems only occur when fusing loops with a dependency between them.
Reference: [3] <author> John Backus. </author> <title> Can programming be liberated from the von Neumann Style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: These concepts are not a direct part of typical numerical algorithms; in a sense they represent an artificial concept imposed upon the problem. Indeed, languages such as FP <ref> [3] </ref> go so far as to ban referencing actual numerical values with names at all. This approach does remove certain formal complexities from the semantics of the language. However, on the whole it seems clear that value names are a definite part of most user's mental vocabulary. <p> We refer to the idea of changing only a portion of a data structure as a partial update. The notation for performing a partial update in typical imperative languages is very straightforward; x <ref> [3] </ref> = 5; is written in the C syntax, but the methods used in other imperative languages are very similar. We argue the following points: * The partial update operation is a critical part of many numerical algorithms. <p> This issue is sometimes referred to as the "von Neumann bottleneck" <ref> [3] </ref>, although this term often implies more of a concern for efficiency and processor design. 27 * Loop-free structures can expose the inherent parallelism of the computations. <p> These operations (namely, the " fl n " and associated vector) have to do with positioning the computed products in an appropriate way. These "positioning" operators are a very typical feature (and problem) with array-based computation languages. Backus' FP system <ref> [3] </ref> is perhaps even more cryptic: Def IP j (n+) ffi (fffi) ffi trans Def MM j (ffffIP) ffi (ffdistl) ffi distr ffi [1; trans ffi 2] The details of exactly how this program works are immaterial here; the point is that languages that try to avoid explicit looping structures by <p> While formalisms can be developed that can handle this concept (Backus <ref> [3] </ref> discusses it for FP, for example), in practice an informal, intuitive understanding is what is needed. The positioning structures in array operator languages often make understanding these relationships "at a glance" very difficult. * The operations of the array system often do not correspond with those of standard mathematics. <p> Combinator systems are of interest because they do not have variables. As a result, all of the difficult semantic issues that arise regarding variable bindings are eliminated. These systems are thus extremely simple and pure from a mathematical point of view. 42 Backus' FP <ref> [3] </ref> was the first combinator system actually intended for user-level programming. The basic language (as opposed to its high-level imperative extension designed for handling I/O, AST [3]) has the following properties: * No variables. FP only names functions, which are combined using composition, rather than values. <p> These systems are thus extremely simple and pure from a mathematical point of view. 42 Backus' FP <ref> [3] </ref> was the first combinator system actually intended for user-level programming. The basic language (as opposed to its high-level imperative extension designed for handling I/O, AST [3]) has the following properties: * No variables. FP only names functions, which are combined using composition, rather than values. We have argued earlier that this approach is exactly the opposite of natural intuition. * No Explicit Loops. <p> Like Haskell, SISAL does support an "incremental update" operator for arrays, in which a new array is created that differs from the original array in some subset of elements. Thus, instead of writing A <ref> [3] </ref> = 0; one instead says A = A [3:0]; The required change is not a big difference in this example, but the problems with the update operation discussed in Section 2.2.3 all apply. <p> back and forth between expression- and statement-oriented programming. * Although the conditional construct in most functional languages is represented as an expression, this form does not permit the representation of conditional updates. * The partial update construct is most naturally expressed just as it is in an imperative language: a <ref> [3] </ref> = 0 sets the third element of a to zero. This construction is obviously statement-oriented. EQ therefore takes the statement-oriented approach. <p> imperative languages. * A conditional update is performed by assigning to a variable in only one branch of an if statement: if (...) forms a conditional update of x. 66 * A partial update is performed by using subscripting on the left hand side of an assign ment statement: x <ref> [3] </ref> = 0; performs a partial update of x. As we have already seen, only one explicit definition of a particular variable can be provided within a statement group. Therefore, additional statements cannot be explicitly provided to fill in the elements not assigned by the above constructions. <p> The only important detail to note here is that when a pure variable is assigned to, such as the construction A = B, the entire variable A is redefined, including its size. Assignments to pure variables contrast with statements such as A <ref> [3] </ref> = B, which only update a portion of A (defaulting the rest from prev A, as previously mentioned), and set the size of A to be the same as the size of prev A. 93 5.3.2 Transposition The matrix transposition operation is written in EQ using a suffix "~" character. <p> In this case, only those elements of the base array with this particular index value at the given position are selected. The resulting array will have one fewer dimensions for each integer subscript. A simple example: A <ref> [3] </ref> selects the element of A with index 3. * A scalar expression of type range. In this case, only those elements of the base array with index values within the range at the given position are selected. <p> This rule catches statements such as A <ref> [3] </ref> = 0, which do not really define a matrix at all. This statement is legal, however, as an update to an existing array. Note that this process should not be confused with the sizing analysis routines discussed in the context of the rank reduction analysis (see Section 9.1). <p> However, this idea introduces a difficulty, because it may now no longer be possible to reference the previous value of the variable|which the EQ semantics permits. Consider, for example, the code i in R; prev a [i] = 0; a <ref> [3] </ref> = 1; next a [5] = a [3] - prev a [3]; In order to perform the final assignment, the values of a and prev a must both be available at the same time. <p> However, this idea introduces a difficulty, because it may now no longer be possible to reference the previous value of the variable|which the EQ semantics permits. Consider, for example, the code i in R; prev a [i] = 0; a <ref> [3] </ref> = 1; next a [5] = a [3] - prev a [3]; In order to perform the final assignment, the values of a and prev a must both be available at the same time. <p> Consider, for example, the code i in R; prev a [i] = 0; a <ref> [3] </ref> = 1; next a [5] = a [3] - prev a [3]; In order to perform the final assignment, the values of a and prev a must both be available at the same time. The solution which the implementation of EQ adopts is to make a copy of the value representing prev a before it is updated to become a. <p> code similar to the following: []: alloc v1-&gt;a_family [R]; [L0 in R]: copy (v1-&gt;a_family [L0], 0); []: alloc prev_a_setaside [R]; [L1 in R]: copy (prev_a_setaside [L1], v1-&gt;a_family [L1]); []: size v2-&gt;a_family &lt;- v1-&gt;a_family; [L2 in R]: noalloc v2-&gt;a_family [L2] after v1-&gt;a_family [L2]; []: unsize v2-&gt;a_family -&gt; v1-&gt;a_family; []: copy (v2-&gt;a_family <ref> [3] </ref>, 1); []: alloc a_setaside [R]; [L3 in R]: copy (a_setaside [L3], v2-&gt;a_family [L3]); []: size a_family &lt;- v2-&gt;a_family; [L4 in R]: noalloc a_family [L4] after v2-&gt;a_family [L4]; []: unsize a_family -&gt; v2-&gt;a_family; []: sub (a_family [5], a_setaside [3], prev_a_setaside [3]); 177 The required free instructions have been omitted for brevity. <p> [L2] after v1-&gt;a_family [L2]; []: unsize v2-&gt;a_family -&gt; v1-&gt;a_family; []: copy (v2-&gt;a_family <ref> [3] </ref>, 1); []: alloc a_setaside [R]; [L3 in R]: copy (a_setaside [L3], v2-&gt;a_family [L3]); []: size a_family &lt;- v2-&gt;a_family; [L4 in R]: noalloc a_family [L4] after v2-&gt;a_family [L4]; []: unsize a_family -&gt; v2-&gt;a_family; []: sub (a_family [5], a_setaside [3], prev_a_setaside [3]); 177 The required free instructions have been omitted for brevity. Diagrammatically, the situation is depicted in Figure 7.1. <p> v1-&gt;a_family [L2]; []: unsize v2-&gt;a_family -&gt; v1-&gt;a_family; []: copy (v2-&gt;a_family <ref> [3] </ref>, 1); []: alloc a_setaside [R]; [L3 in R]: copy (a_setaside [L3], v2-&gt;a_family [L3]); []: size a_family &lt;- v2-&gt;a_family; [L4 in R]: noalloc a_family [L4] after v2-&gt;a_family [L4]; []: unsize a_family -&gt; v2-&gt;a_family; []: sub (a_family [5], a_setaside [3], prev_a_setaside [3]); 177 The required free instructions have been omitted for brevity. Diagrammatically, the situation is depicted in Figure 7.1. <p> For 197 example, consider the short intermediate code example []: form_range (R, 1, 10); [i in R]: copy (A [i], i); [j in R]: copy (B [j], A <ref> [3] </ref>); Clearly, loops i and j have exactly the same length. However, if we were to fuse these two loops together, the program would no longer work correctly; the assignments to B [1] and B [2] would be made before the value of A [3] had actually been defined, assuming the <p> in R]: copy (B [j], A <ref> [3] </ref>); Clearly, loops i and j have exactly the same length. However, if we were to fuse these two loops together, the program would no longer work correctly; the assignments to B [1] and B [2] would be made before the value of A [3] had actually been defined, assuming the loops run in the incrementing (rather than decrementing) direction. These problems only occur when fusing loops with a dependency between them. If the loops are unrelated, then obviously fusion between loops with equal extents will be successful in all cases.
Reference: [4] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The technique is a little hard to demonstrate at this point, however, because we have not yet discussed EQ's array features. But if we suppose that zero_vec already contains a vector of five zeros, then the code prev x = zero_vec; x [2] = 1; next x <ref> [4] </ref> = 1; would produce a value in x which is the vector (0; 1; 0; 0; 0), and next x will be (0; 1; 0; 1; 0). <p> A good general survey of general optimization techniques can be found in <ref> [4] </ref>. 304 12.4 Assessment of the Language Design Itself Obviously, the small collection of example programs in this dissertation is only the start of a comprehensive evaluation of the EQ language's ability to express algorithms more effectively than existing languages.
Reference: [5] <author> Robert A. Ballance, Anthony J. Giancola, George F. Luger, and Timothy J. Ross. </author> <title> A framework-based environment for object-oriented scientific codes. </title> <booktitle> In Proceedings of the First Annual Object-Oriented Numerics Conference, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: the code that performs this function does so. 57 Existing applications of object-oriented approaches to scientific computing problems include the areas of class library definition (matrix and array classes, as well as libraries to support specific scientific fields, such as magnetic resonance [67]) and support for general frameworks, such as <ref> [5] </ref>. Object-oriented ideas relate more to high-level structuring mechanisms, such as class hierarchies; our goals are more relevant to "programming in the small". Although object-orientation is usually considered in terms of imperative languages such as C++ [70] or Java [30], the concept is more generally applicable. <p> However, this idea introduces a difficulty, because it may now no longer be possible to reference the previous value of the variable|which the EQ semantics permits. Consider, for example, the code i in R; prev a [i] = 0; a [3] = 1; next a <ref> [5] </ref> = a [3] - prev a [3]; In order to perform the final assignment, the values of a and prev a must both be available at the same time. <p> noalloc v2-&gt;a_family [L2] after v1-&gt;a_family [L2]; []: unsize v2-&gt;a_family -&gt; v1-&gt;a_family; []: copy (v2-&gt;a_family [3], 1); []: alloc a_setaside [R]; [L3 in R]: copy (a_setaside [L3], v2-&gt;a_family [L3]); []: size a_family &lt;- v2-&gt;a_family; [L4 in R]: noalloc a_family [L4] after v2-&gt;a_family [L4]; []: unsize a_family -&gt; v2-&gt;a_family; []: sub (a_family <ref> [5] </ref>, a_setaside [3], prev_a_setaside [3]); 177 The required free instructions have been omitted for brevity. Diagrammatically, the situation is depicted in Figure 7.1.
Reference: [6] <author> Brignam Bell, Wayne Citrin, Clayton Lewis, John Rieman, Robert Weaver, Nick Wilde, and Benjamin Zorn. </author> <title> Using the programming walkthrough to aid in programming language design. </title> <journal> Software: Practice and Experience, </journal> <volume> 24(1) </volume> <pages> 1-25, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Future steps that would be of assistance in this area might include: * The examination of additional algorithms within the field, including some more extended examples. It is difficult to come to definite conclusions with our small sample space. * Utilization of a process such as the walkthrough <ref> [6] </ref>, to understand better the value of properties like those presented in Chapter 2. * Actual use of EQ in the development of new algorithms within a research team.
Reference: [7] <author> Radtislav Bodik, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Complete removal of redundant computations. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 1-14, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: There is good reason, however, to believe that solutions to these issues can be found: * Much successful research in these areas has gone on with regard to scalars in the standard language community for some time. Recent results in partial redundancy elimination <ref> [7, 51] </ref> are particularly promising in this area, showing that under limited circumstances 235 it is possible to perform an optimal job of redundancy elimination.
Reference: [8] <author> A. P. W. Bohm, R. R. Oldehoeft, D. C. Cann, and J. T. Feo. </author> <title> SISAL reference manual, language version 2.0. </title> <type> Technical Report CS-91-118, </type> <institution> Colorado State University, Fort Collins, Colorado, </institution> <year> 1991. </year>
Reference-contexts: Otherwise, minor algorithmic changes&lt;replace text&gt; that seem trivial at the functional level can have disastrous consequences at the efficiency level. Many functional languages (such as Haskell [39] and SISAL <ref> [8] </ref>) introduce an "update operator" of some kind, which produces a new object representing an old array with a part of the array changed to a new value. This mechanism, because it implicitly copies the array, does not destroy the original, and thus is still side-effect free. <p> The sizes of the arrays themselves are not part of the type system. SISAL SISAL <ref> [8] </ref> is an attempt to produce a functional language for performing scientific computations without introducing side effects. Thus, it has some of the same goals as the EQ language design, and is therefore a particularly important language to consider.
Reference: [9] <author> A. I. Borisenko and I. E. Tarapov. </author> <title> Vector and Tensor Analysis with Applications. </title> <publisher> Dover Publications, Inc., </publisher> <address> New York, </address> <note> revised english edition, </note> <year> 1968. </year> <title> Translated from the Russian by Richard A. </title> <type> Silverman. </type>
Reference-contexts: Using associativity, we can see that this is equal to s*(s*y~)*y~, 240 which in turn equals (s*y~)*(s*y~). This approach is a superset of the previous one. We believe that a design for such a system could be constructed from the fundamental ideas behind tensor analysis <ref> [9] </ref>. Any of these three solutions is a possible extension to EQ; see Section 12.2.4 for further discussion. 10.4.2 Assessment of Statement-Level of BFGS Code This example effectively demonstrates the use of nested control structures and multiple exit conditions. <p> There may be interesting correlations between these issues and the notation and semantics of tensor analysis <ref> [9] </ref>. Matrix Inversion The operation of matrix inversion (such as A 1 ) is the only significant operation missing from EQ's assortment of linear algebra matrix operations.
Reference: [10] <author> Preston Briggs and Keith D. Cooper. </author> <title> Effective partial redundancy elimination. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 159-170, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This optimization is a generalization of common subex-pressions and loop invariant code lifting, which involves handling cases where the same value may be computed twice. Examples requiring this optimization are plentiful in the Nelder-Meade code. There is much research on this topic <ref> [10, 49, 51] </ref> that could be applied to an EQ implementation of this idea. The side-effect free nature of EQ should make it easier to implement on arrays, which has been less studied in the literature. * Partially dead code removal.
Reference: [11] <author> David Callahan, Steve Carr, and Ken Kennedy. </author> <title> Improving register allocation for subscripted variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 53-65, </pages> <year> 1990. </year>
Reference-contexts: In this section we mention some of these projects, and their relationship to the approach outlined here. 195 There are numerous papers on performing array contraction (such as <ref> [11, 29, 65] </ref>) within standard imperative languages. Such work often becomes entangled with issues of complex dependency analysis and aliasing, and usually tries to handle recurrence structures. Due to its design, EQ does not have to handle these issues, and therefore makes a more suitable vehicle for exploring rank reduction. <p> Support for Compiler-Checking of Subscripting Bounds The current EQ compiler does not verify that indices in subscripts such as a [x] are in bounds. Thus, code such as i in 1..10; print a <ref> [11] </ref>; will not produce a sensible runtime error, but will instead print the value in memory just past the end of the array a.
Reference: [12] <author> David E. Cann. </author> <title> Compilation techniques for high performance applicative computation. </title> <type> Technical Report CS-89-108, </type> <institution> Colorado State University, Dept. of Computer Science, </institution> <month> May </month> <year> 1989. </year> <month> 309 </month>
Reference-contexts: That this optimization can be performed in our example is obvious, but when A is passed to a general user function to compute the new value, the situation is far more complex. The SISAL developers have spent significant effort on this problem, with generally very good results <ref> [12, 13] </ref>. * The for loop expression is "statement" oriented, which makes it difficult to combine with other parts of SISAL that are expression-oriented. Consider, for example, the if construction.
Reference: [13] <author> David E. Cann. </author> <title> RETIRE FORTRAN? A debate rekindled. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 81-89, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Mathematical notations that are ambiguous must be clarified to a particular meaning. 2.2 The "Side-Effect Free" Property vs. Expressing Change and Par tial Update A raging debate has been going on for some time about the effectiveness of functional languages in comparison to their more standard imperative counterparts <ref> [13] </ref>, and is likely to continue. Certainly the imperative side has been winning the practical side of the "war", but functional languages, though less familiar, also have properties to recommend them. Each of these language paradigms, however, also have significant weaknesses regarding the expression of numerical computations. <p> Advocates of the functional system have often attributed its lack of success to errant public perceptions, poor early implementations, and the wealth of historical imperative code and familiarity <ref> [13] </ref>. All of these reasons surely play some role. <p> That this optimization can be performed in our example is obvious, but when A is passed to a general user function to compute the new value, the situation is far more complex. The SISAL developers have spent significant effort on this problem, with generally very good results <ref> [12, 13] </ref>. * The for loop expression is "statement" oriented, which makes it difficult to combine with other parts of SISAL that are expression-oriented. Consider, for example, the if construction.
Reference: [14] <author> A. Church. </author> <title> The Calculi of Lambda Conversion. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1941. </year>
Reference-contexts: One can, of course, declare lambda calculus to be the answer to our problem. Invented by Alonzo Church, the lambda calculus <ref> [14, 37] </ref> is a way of embedding all possible computations (as far as is known) into a very simple and mathematical system, focusing on the manipulation of functions.
Reference: [15] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1984. </year>
Reference-contexts: The imprecisions of finite computer arithmetic imply that these three equations may produce inconsistent results. Nonetheless, it should be noted that true mathematics has more of a relationship with relational programming languages, such as Prolog <ref> [15] </ref> and constraint logic programming systems [45], in this regard. <p> We include in this category all language that include backtracking/search mechanisms as a basic part of the language semantics, including "logic" languages such as Prolog <ref> [15] </ref> and constraint logic programming [16, 45], as well as languages that only use local searching semantics, such as Snobol4 [31] and its successor, Icon [32]. These languages are intended for a variety of different problem domains. What unifies them is their backtracking execution mechanism.
Reference: [16] <author> J. Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: We include in this category all language that include backtracking/search mechanisms as a basic part of the language semantics, including "logic" languages such as Prolog [15] and constraint logic programming <ref> [16, 45] </ref>, as well as languages that only use local searching semantics, such as Snobol4 [31] and its successor, Icon [32]. These languages are intended for a variety of different problem domains. What unifies them is their backtracking execution mechanism.
Reference: [17] <author> B. A. Davey and H. A. Priestly. </author> <title> Introduction to Lattices and Order, </title> <booktitle> chapter 1, </booktitle> <pages> pages 7-9. </pages> <publisher> Cambridge Mathematical Textbooks. Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1990. </year>
Reference-contexts: This figure contains an "inverted" Hasse diagram <ref> [17] </ref>, in which a &lt; b if and only if there exists a downward path from a to b. Thus, we can determine the proper ordering of instructions within an instruction set simply from this instruction-variable dependency information.
Reference: [18] <author> Antony J. T. Davie. </author> <title> An Introduction to Functional Programming Systems Using Haskell. Number 27 in Cambridge Compute Science Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The above extensions make the system more powerful than FP, but do nothing to correct its fundamental limitations. 3.3 Functional Languages These languages eschew the complexities and subtleties of imperative side effects, in favor of the the referential transparency of expression-based languages <ref> [34, 18, 47] </ref>. Some of these languages maintain the "purity" of formal reasoning by eliminating all side effects whatsoever. Others take a more "middle of the road" approach, with update operations possible but discouraged. And still others fully embrace the imperative operations along with the functional ones.
Reference: [19] <author> E. Deelman, W. K. Kaplow, B. K. Szymanski, P. Tannenbaum, and L. Ziantz. </author> <title> Intergrat-ing data and task parallelism in scientific programs. </title> <booktitle> In Third Workshop on Languages, Compilers, and Run-Time Systems for Scalable Computers, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: Windowing is related to our work in Chapter 8 on rank reduction. In more recent research EPL has viewed itself as a useful intermediate form rather than a direct source language, and had considered the process of translating FORTRAN programs automatically into EPL for optimization <ref> [19] </ref>. Lucid Lucid [2, 76] is a data flow language in the most direct sense possible, because each variable v represents not a single value, but an entire stream of values at once.
Reference: [20] <author> Dept. </author> <title> of Defense. Military Standard: </title> <booktitle> Ada Programming Language, </booktitle> <year> 1981. </year> <month> MIL-STD-1815. </month>
Reference-contexts: This approach was felt to be less cumbersome than the fully bracketing syntax of languages such as ADA <ref> [20] </ref>. In EQ, there are many different types of control structure, many of which are expected to be commonly used with only a single statement as the body (over, at, and 168 "=&gt;" statements in particular).
Reference: [21] <author> Howard Derby. </author> <title> BQ|Compiler for the Blue Programming Language. Neonatura, 1997. </title> <type> Internal Report. </type>
Reference-contexts: It also discusses the efficiency of the required computations. 7.1 Language Used for the Implementation EQ has been implemented using the BLUE Compiler Development System <ref> [21, 59] </ref>, a proprietary programming language of Neonatura. The primary component of this system is the BLUE language, which uses a generalization of graphs as its primary data structure.
Reference: [22] <author> Thomas Derby, Robert Schnabel, and Benjamin Zorn. EQ: </author> <title> Overview of a new language approach for prototyping scientific computation. </title> <editor> In Pingali et al., editor, </editor> <booktitle> Seventh Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 391-405. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We have for some time been studying language design ideas for prototyping scientific computations <ref> [22, 23, 24, 25] </ref> that try to provide solutions to some of these issues.
Reference: [23] <author> Thomas Derby, Robert Schnabel, and Benjamin Zorn. </author> <title> The relationship between language paradigm and parallelism: the EQ prototyping langauge. </title> <editor> In B. Szymanski and B. Sinharoy, editors, </editor> <booktitle> Languages, Compilers, and Run-Time Systems for Scalable Computers, </booktitle> <pages> pages 329-332, </pages> <year> 1995. </year>
Reference-contexts: We have for some time been studying language design ideas for prototyping scientific computations <ref> [22, 23, 24, 25] </ref> that try to provide solutions to some of these issues.
Reference: [24] <author> Thomas Derby, Robert Schnabel, and Benjamin Zorn. </author> <title> A new language design for proto-typing numerical computation. </title> <journal> Journal of Scientific Programming, </journal> <volume> 5 </volume> <pages> 279-300, </pages> <year> 1996. </year>
Reference-contexts: We have for some time been studying language design ideas for prototyping scientific computations <ref> [22, 23, 24, 25] </ref> that try to provide solutions to some of these issues. <p> The reader is encouraged to examine each example in that appendix before reading the corresponding section of this chapter. Each of these programs can be compiled without modification by the EQ compiler discussed in Chapter 7, unlike in our earlier work <ref> [24] </ref> where the examples were "beautified" versions, including features not implemented by the early EQ compilers. 222 10.1 PLU Decomposition PLU decomposition is the typical general-purpose matrix decomposition used to solve the equation A ~ x = ~ b for the vector ~ x, given an n fi n matrix A <p> although it does require some extra provisions to handle separate compilation and external procedures. 12.3.6 Standard Optimizations There are a number of standard optimizations that we have previously mentioned would be very helpful in our example programs, and have in our previous work been related to the concept of dependability <ref> [24] </ref>. Those that seem of particular interest, as motivated by our example programs, would include: * Common subexpressions. The side-effect free nature of EQ makes such an optimization relatively easy to perform. However, there are differences from standard treatments. The capabilities of partial assignment must be taken into account.
Reference: [25] <author> Thomas M. Derby and Benjamin Zorn. </author> <title> A type system for languages with dynamic arrays. </title> <type> Technical Report CU-CS-874-98, </type> <institution> University of Colorado, </institution> <year> 1998. </year>
Reference-contexts: We have for some time been studying language design ideas for prototyping scientific computations <ref> [22, 23, 24, 25] </ref> that try to provide solutions to some of these issues. <p> It should be noted that the current EQ compiler does not actually check the correctness of the program with regards to these sizing requirements, either at compile time or runtime. A compile-time "sizing system" that could check these requirements has been discussed in the past for EQ <ref> [25] </ref>, but the current implementation does not include such a system. If a parameter is declared A [R,R], then all arguments passed for this value are assumed to be square. <p> to all sizes created from the .. operator (only M1 in our example), we obtain the graph in Figure 9.1 This kind of graph is referred to in this thesis as an abstract extent graph, and is a simplified version of the construct developed in some of our previous work <ref> [25] </ref>. In our particular example, all of the ordinary nodes (vertices) are connected together. Thus, it is easy to see that all must have the same size (extent). Had we obtained the graph in Figure 9.2, there would be exactly two different sizes being manipulated. <p> This issue could be addressed statically at compile time in a similar fashion to static type systems. This feature was originally planned to be included in the EQ language, but was removed from this research due to breadth concerns. Our paper on sizing systems <ref> [25] </ref> discusses how to provide such a system in the context of a simple imperative array language, though we currently have no practical experiences with an implementation of it.
Reference: [26] <author> J. J. Dongarra, C. B. Moler, J. R. Bunch, and G. W. Steward. </author> <title> LINPACK Users' Guide, </title> <year> 1979. </year>
Reference-contexts: MATLAB MATLAB [56] was originally viewed as a system to provide access to LINPACK, significant mathematical libraries written in FORTRAN for performing linear algebra computations <ref> [26] </ref>. As a result, its operator set more closely resembles linear algebra constructions than the element-by-element approach of other array languages, which makes the representation of linear algebra expressions quite natural. Unfortunately, arrays are primarily restricted to only two dimensions.
Reference: [27] <author> I. S. Duff, A. M. Erisman, and J .K. Reid. </author> <title> Direct Methods for Sparse Matrices. Monographs on Numerical Analysis. </title> <publisher> Oxford Science Publications, Clarendon Press, Oxford, </publisher> <year> 1986. </year>
Reference-contexts: This often involves some kind of "restructuring" pass, to try and arrange the elements of the array in a more conducive order for the operation (such as in the minimum degree algorithm), or entirely new algorithms for the problem (such as the multifront method) <ref> [27] </ref>.
Reference: [28] <author> R. Fletcher. </author> <title> Practical Methods of Optimization. </title> <publisher> Wiley-Interscience, </publisher> <address> Chichester, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: For example, a mathematical discussion of numerical optimization might let x be the current approximation, x fl be the correct answer, and x ( k) be the approximation to the minimizer on iteration k <ref> [28] </ref>. Another notation we have seen uses x c for the current value of x, x p for the previous value (the previous approximation), and x + to represent the new approximation [66].
Reference: [29] <author> G. R. Gao, R. Olsen, V. Sarkar, and R. Thekkath. </author> <title> Collective loop fusion for array contraction. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Proceedings of the Fifth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <institution> Yale University, </institution> <month> August </month> <year> 1992, </year> <booktitle> Springer-Verlag Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this section we mention some of these projects, and their relationship to the approach outlined here. 195 There are numerous papers on performing array contraction (such as <ref> [11, 29, 65] </ref>) within standard imperative languages. Such work often becomes entangled with issues of complex dependency analysis and aliasing, and usually tries to handle recurrence structures. Due to its design, EQ does not have to handle these issues, and therefore makes a more suitable vehicle for exploring rank reduction.
Reference: [30] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java TM Language Specification. The Java TM Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year> <month> 310 </month>
Reference-contexts: Object-oriented ideas relate more to high-level structuring mechanisms, such as class hierarchies; our goals are more relevant to "programming in the small". Although object-orientation is usually considered in terms of imperative languages such as C++ [70] or Java <ref> [30] </ref>, the concept is more generally applicable. Haskell, for example, provides object orientation through its type class system [33]. Thus, object-oriented concepts can be applied to side-effect free languages as well as the standard imperative ones. <p> Pointers The other important data structure from imperative languages that is not currently available in EQ are pointers. Pointers types are distinguished from standard variable names by the ability to change what value they refer to (though these concepts are somewhat blurred in 282 languages like Java <ref> [30] </ref>, where all variables are pointer references). This means that a pointer data types necessarily engage in a sort of aliasing, although this can be greatly reduced from the completely general aliasing that occurs in languages such as C.
Reference: [31] <author> R. E. Griswold, J. F. Poage, and I. P. Polonsky. </author> <title> The Snobol4 Programming Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1971, 1968. </year>
Reference-contexts: We include in this category all language that include backtracking/search mechanisms as a basic part of the language semantics, including "logic" languages such as Prolog [15] and constraint logic programming [16, 45], as well as languages that only use local searching semantics, such as Snobol4 <ref> [31] </ref> and its successor, Icon [32]. These languages are intended for a variety of different problem domains. What unifies them is their backtracking execution mechanism. Backtracking is the idea of undoing decisions that have already been made because they resulted in eventual failure.
Reference: [32] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: We include in this category all language that include backtracking/search mechanisms as a basic part of the language semantics, including "logic" languages such as Prolog [15] and constraint logic programming [16, 45], as well as languages that only use local searching semantics, such as Snobol4 [31] and its successor, Icon <ref> [32] </ref>. These languages are intended for a variety of different problem domains. What unifies them is their backtracking execution mechanism. Backtracking is the idea of undoing decisions that have already been made because they resulted in eventual failure.
Reference: [33] <author> Cordeilia V. Hall, Kevin Hammond, Simon L. Peyton Jones, and Philip L. Wadler. </author> <title> Type classes in Haskell. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(2) </volume> <pages> 109-138, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Although object-orientation is usually considered in terms of imperative languages such as C++ [70] or Java [30], the concept is more generally applicable. Haskell, for example, provides object orientation through its type class system <ref> [33] </ref>. Thus, object-oriented concepts can be applied to side-effect free languages as well as the standard imperative ones. The above discussion demonstrates that the ideas of object orientation are, for the most part, independent of the underlying language paradigm. <p> It should be noted that we believe the type system implemented here is not a subset of the Hindley-Milner type system, though it might be integrable as a part of the more general "type class" based system used by Haskell <ref> [33] </ref>. The EQ type computation is done on a procedure by procedure basis. This analysis is made possible by the explicit type signatures for the arguments to procedures. The computation is performed in several steps. (1) A type change propagation graph is constructed.
Reference: [34] <author> Peter Henderson. </author> <title> Functional Progarmming: Application and Implementation. </title> <booktitle> Prentice-Hall International Series in Compute Science. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1980. </year>
Reference-contexts: The above extensions make the system more powerful than FP, but do nothing to correct its fundamental limitations. 3.3 Functional Languages These languages eschew the complexities and subtleties of imperative side effects, in favor of the the referential transparency of expression-based languages <ref> [34, 18, 47] </ref>. Some of these languages maintain the "purity" of formal reasoning by eliminating all side effects whatsoever. Others take a more "middle of the road" approach, with update operations possible but discouraged. And still others fully embrace the imperative operations along with the functional ones.
Reference: [35] <author> Paul N. Hilfinger and Phillip Collela. FIDIL: </author> <title> A language for scientific programming. </title> <type> Technical Report UCRL-PREPRINT 98057, </type> <institution> Lawrence Livermore National Laboratory, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: However, it is not always the case that a fully parallel algorithm is needed, even on a parallel machine. FIDIL FIDIL <ref> [35, 36] </ref>, in contrast, is a much richer programming environment. Like ZPL, FIDIL encourages programmers to treat arrays all together at once, in an element-by-element fashion. Its semantics are slightly different than those of ZPL.
Reference: [36] <author> Paul N. Hilfinger and Phillip Collela. FIDIL: </author> <title> A language for scientific programming. </title> <editor> In Robert Grossman, editor, </editor> <booktitle> Symbolic Computation: Applications to Scientific Computing, chapter 5, </booktitle> <pages> pages 97-138. </pages> <publisher> SIAM, </publisher> <year> 1989. </year>
Reference-contexts: However, it is not always the case that a fully parallel algorithm is needed, even on a parallel machine. FIDIL FIDIL <ref> [35, 36] </ref>, in contrast, is a much richer programming environment. Like ZPL, FIDIL encourages programmers to treat arrays all together at once, in an element-by-element fashion. Its semantics are slightly different than those of ZPL.
Reference: [37] <author> Paul Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: One can, of course, declare lambda calculus to be the answer to our problem. Invented by Alonzo Church, the lambda calculus <ref> [14, 37] </ref> is a way of embedding all possible computations (as far as is known) into a very simple and mathematical system, focusing on the manipulation of functions. <p> The secret to getting actual value out of the properties listed above is that the "scopes" involved are large; that is, cover as much of the program as possible. 2.2.2 Benefits of Pure Functional Languages Advocates of functional languages have cited a number of advantages to these properties <ref> [37] </ref>. Those that we feel are of the most importance for numerical computing are listed below. * Expressions behave more like their mathematical counterparts when the properties of Section 2.2.1 hold. Each occurrence of an expression E within a single scope means the same thing.
Reference: [38] <author> Paul Hudak. </author> <title> Tutorial on the functional programming language Haskell. </title> <note> Postscript available via FTP from Yale University, </note> <month> June </month> <year> 1991. </year>
Reference-contexts: As a result, some languages (such as ML and Scheme, which have side effects) do not include it, and others (such as SISAL) will provide it only in a limited fashion, or in limited circumstances. 47 Haskell Haskell <ref> [38, 40, 39] </ref> really serves as a generalization of much of the work done in "pure" functional languages. Many features of earlier functional languages such as ML and Miranda [75] have been made more elegant and general in Haskell, eliminating many of the pitfalls found in its predecessors.
Reference: [39] <editor> Paul Hudak et al. </editor> <title> Report on the programming language Haskell: A non-strict, purely functional language version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5):R-1-R-164, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Otherwise, minor algorithmic changes&lt;replace text&gt; that seem trivial at the functional level can have disastrous consequences at the efficiency level. Many functional languages (such as Haskell <ref> [39] </ref> and SISAL [8]) introduce an "update operator" of some kind, which produces a new object representing an old array with a part of the array changed to a new value. This mechanism, because it implicitly copies the array, does not destroy the original, and thus is still side-effect free. <p> As a result, some languages (such as ML and Scheme, which have side effects) do not include it, and others (such as SISAL) will provide it only in a limited fashion, or in limited circumstances. 47 Haskell Haskell <ref> [38, 40, 39] </ref> really serves as a generalization of much of the work done in "pure" functional languages. Many features of earlier functional languages such as ML and Miranda [75] have been made more elegant and general in Haskell, eliminating many of the pitfalls found in its predecessors. <p> As a result, functional languages have to either simply "give up" on side-effect free I/O, or else use highly abstract and convoluted structures to handle it (the Haskell approach of using "monadic" I/O <ref> [39, 63] </ref> is an example of the latter). Either way, some of the advantages of being side-effect free are lost. However, the "print" operation is clearly very similar in many respects to a partial update.
Reference: [40] <author> Paul Hudak and Joseph Fasel. </author> <title> A gentle introduction to Haskell. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5):T-1-T-53, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: As a result, some languages (such as ML and Scheme, which have side effects) do not include it, and others (such as SISAL) will provide it only in a limited fashion, or in limited circumstances. 47 Haskell Haskell <ref> [38, 40, 39] </ref> really serves as a generalization of much of the work done in "pure" functional languages. Many features of earlier functional languages such as ML and Miranda [75] have been made more elegant and general in Haskell, eliminating many of the pitfalls found in its predecessors.
Reference: [41] <author> John Hughes. </author> <title> Why functional programming matters. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, chapter 2, </booktitle> <pages> pages 17-41. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Lazy evaluation can be a very powerful abstraction technique <ref> [41] </ref>. For example, consider a program that computes a sequence of approximations until a sufficiently accurate approximation is reached. Lazy evaluation of this sequence permits the termination of the algorithm to be coded separately from the computation of the approximations.
Reference: [42] <author> IBM. </author> <title> APL2 Language Manual. </title> <type> Technical Report SB21-3039. </type>
Reference-contexts: The requirement to distinguish between four different types of multiplication ("*", OUTER_PRODUCT, DOT_PRODUCT, and MATMUL) makes the FORTRAN90 code more difficult to understand. APL APL [44] and its derivatives (such as APL2 <ref> [42] </ref>) are perhaps the most general of the imperative array languages, and their array operators have the most power. <p> The operation transposes all of the dimensions of the object it is applied to (the last dimension becomes the first, and vice versa). It also converts between row and column vectors. The interesting construction here is that, similar to APL2 <ref> [42] </ref>, the transpose can be used on LValues as well as on expressions.
Reference: [43] <author> ISO. </author> <title> Fortran 90 Standard ISO/IEC 1539:1991(E). </title>
Reference-contexts: With whole arrays, we have the ability to change only a part of the array. Indeed, in FORTRAN, we can only change a single element of it at a time; there is no way to perform whole array operations (as can be done in FORTRAN90 <ref> [43] </ref>). We refer to the idea of changing only a portion of a data structure as a partial update. <p> These programs can be shorter, easier to understand, and avoid the difficult reasoning processes required to understand control flow around looping constructions. The convenience of expression-based array computation is now well recognized (consider, for example, the addition of array operation facilities to FORTRAN90 <ref> [43] </ref>). However, many of the proposed solutions to this issue (such as APL, FP, and others) rely on performing computations on whole arrays via some set of array operators. <p> Recent work on the language, however, has considered the compilation process to try and address these issues [46]. The compilation of MATLAB encounters some of the same difficulties (but also many additional ones) as EQ compilation. FORTRAN90 FORTRAN90 <ref> [43] </ref> is the successor to FORTRAN77, and brings the language up to date with modern programming language constructs while still remaining largely compatible with the older FORTRAN77. <p> This style of selection operation can be contrasted with a "maxloc" approach, such as that provided by FORTRAN90 <ref> [43] </ref>, in which a function is provided that returns a vector containing the position within an array that has the largest value.
Reference: [44] <author> Kenneth E. Iverson. </author> <title> A Programming Language. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: Such calculations are an obviously important part of a language for prototyping numerical computations. We only consider dense array structures in this section, and indeed in EQ; issues of sparsity will be briefly discussed in Section 12.2.3. Many languages, such as APL <ref> [44] </ref> and MATLAB [56], provide various features for operating on arrays "en masse"; that is, to perform computations on arrays without working on an element-by-element basis. <p> The requirement to distinguish between four different types of multiplication ("*", OUTER_PRODUCT, DOT_PRODUCT, and MATMUL) makes the FORTRAN90 code more difficult to understand. APL APL <ref> [44] </ref> and its derivatives (such as APL2 [42]) are perhaps the most general of the imperative array languages, and their array operators have the most power.
Reference: [45] <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey, and Roland H. C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The imprecisions of finite computer arithmetic imply that these three equations may produce inconsistent results. Nonetheless, it should be noted that true mathematics has more of a relationship with relational programming languages, such as Prolog [15] and constraint logic programming systems <ref> [45] </ref>, in this regard. <p> We include in this category all language that include backtracking/search mechanisms as a basic part of the language semantics, including "logic" languages such as Prolog [15] and constraint logic programming <ref> [16, 45] </ref>, as well as languages that only use local searching semantics, such as Snobol4 [31] and its successor, Icon [32]. These languages are intended for a variety of different problem domains. What unifies them is their backtracking execution mechanism.
Reference: [46] <author> Stephen C. Johnson and Cleve Moler. </author> <title> Compiling MATLAB. </title> <booktitle> In Proceedings of the Very High Level Languages Symposium, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Because of the interpretive implementation of MATLAB, performance suffers greatly when this sort of "scalarization" occurs. Recent work on the language, however, has considered the compilation process to try and address these issues <ref> [46] </ref>. The compilation of MATLAB encounters some of the same difficulties (but also many additional ones) as EQ compilation. FORTRAN90 FORTRAN90 [43] is the successor to FORTRAN77, and brings the language up to date with modern programming language constructs while still remaining largely compatible with the older FORTRAN77.
Reference: [47] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1987. </year> <title> With chapters by Philip Wadler, Peter Hancock, and David Turner. </title>
Reference-contexts: The above extensions make the system more powerful than FP, but do nothing to correct its fundamental limitations. 3.3 Functional Languages These languages eschew the complexities and subtleties of imperative side effects, in favor of the the referential transparency of expression-based languages <ref> [34, 18, 47] </ref>. Some of these languages maintain the "purity" of formal reasoning by eliminating all side effects whatsoever. Others take a more "middle of the road" approach, with update operations possible but discouraged. And still others fully embrace the imperative operations along with the functional ones. <p> The EQ typing problem is of intermediate difficulty, lying between languages where all variables have declared types (such as C and Pascal), and languages which infer everything in a higher-order context, usually utilizing some variant of the Hindley-Milner type system, such as that used by Haskell <ref> [47, Chapters 8 and 9] </ref>. The EQ system strikes a balance, forcing full declarations for each procedure, but deducing types of variables otherwise. <p> Pointers are usually perceived as requiring side effects in order to have any meaning at all. Indeed, this perception is one reason why the purely functional languages do not support user-level pointers at all, to our knowledge, although pointers are heavily used within the implementation of such languages <ref> [47] </ref>. EQ's model of time, however, may offer a potential way to implement pointer-based graph structures within the language in a direct and elegant fashion.
Reference: [48] <author> Brain W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: Its avoidance of pointer structures and the resulting aliasing issues can make the dependencies of the program easier to understand than in other imperative languages. C The C programming language <ref> [48] </ref> was originally developed for the implementation of UNIX, but has since then grown far beyond its original application. Indeed, C has become a popular alternative choice to FORTRAN for the implementation of numerical codes.
Reference: [49] <author> Jens Knoop, Oliver Ruthing, and Bernhard Steffen. </author> <title> Optimal code motion: </title> <journal> Theory and practice. ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 16 </volume> <pages> 1117-1155, </pages> <year> 1994. </year> <month> 311 </month>
Reference-contexts: This optimization is a generalization of common subex-pressions and loop invariant code lifting, which involves handling cases where the same value may be computed twice. Examples requiring this optimization are plentiful in the Nelder-Meade code. There is much research on this topic <ref> [10, 49, 51] </ref> that could be applied to an EQ implementation of this idea. The side-effect free nature of EQ should make it easier to implement on arrays, which has been less studied in the literature. * Partially dead code removal.
Reference: [50] <author> Jens Knoop, Oliver Ruthing, and Bernhard Steffen. </author> <title> Partial dead code elimination. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 147-158, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Often, as in that code, rearranging an algorithm to only compute those values that are actually needed depends on complex conditionals. This rearrangement can even force users to write multiple copies of some portions of their code. There is significant research into optimizations to eliminate dead code <ref> [50] </ref> for sequential execution, and much of this can probably be extended to handle EQ. Indeed, in many cases these optimizations are more important than they would be in a standard imperative system.
Reference: [51] <author> Jens Knoop, Oliver Ruthing, and Bernhard Steffen. </author> <title> The power of assignment motion. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30 </volume> <pages> 233-245, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: There is good reason, however, to believe that solutions to these issues can be found: * Much successful research in these areas has gone on with regard to scalars in the standard language community for some time. Recent results in partial redundancy elimination <ref> [7, 51] </ref> are particularly promising in this area, showing that under limited circumstances 235 it is possible to perform an optimal job of redundancy elimination. <p> This optimization is a generalization of common subex-pressions and loop invariant code lifting, which involves handling cases where the same value may be computed twice. Examples requiring this optimization are plentiful in the Nelder-Meade code. There is much research on this topic <ref> [10, 49, 51] </ref> that could be applied to an EQ implementation of this idea. The side-effect free nature of EQ should make it easier to implement on arrays, which has been less studied in the literature. * Partially dead code removal.
Reference: [52] <author> Donald E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1973. </year>
Reference-contexts: The algorithms of the previous section are used to properly order instructions within an instruction set, based on the standard O (n) topological sorting algorithm <ref> [52] </ref>, and a piece of C code is output for each instruction. Memvars and loopvars are translated into C names. The memvars are declared at the head of the function.
Reference: [53] <author> Priyadarshan Kolte and Michael Wolfe. </author> <title> Elimination of redundant array subscript range checks. </title> <booktitle> In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 270-278, </pages> <year> 1995. </year>
Reference-contexts: Performing subscripting bounds checks can take a significant amount of execution time if done in a naive fashion, but much of the work can be eliminated by determining that the evaluation will always be in bounds a priori <ref> [53] </ref>. It should be noted that the existing sizing analysis would allow many of the subscripting checks involving iterators to be removed.
Reference: [54] <author> Thomas Lengauer and Robert E. Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> I(1):121-141, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: The construction of the graph takes O (nd) time, where n is the size of the program, and d the maximum dimension. The computation of the dominator tree can then be performed very quickly, using a sophisticated algorithm given by Lengauer and Tarjan <ref> [54] </ref>. This algorithm takes O (ndff (nd; nd)) time, where ff is the inverse Ackerman's function.
Reference: [55] <author> E. Christopher Lewis, Calvin Lin, and Lawrence Snyder. </author> <title> The implementation and evaluation of fusion and contraction in array langauges. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 50-59, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Thus, in some respects the EPL goals are more ambitious than those for EQ. However, to our knowledge, no published results of an actual algorithm for performing windowing exist. Perhaps the most compelling related work has been done in work on the implementation of the ZPL parallel programming language <ref> [55] </ref>. ZPL is an imperative SIMD language, emphasizing element-by-element computation over multidimensional arrays. Work has been done on performing contraction of user temporary variables to a scalar (equivalent to rank reducing all dimensions of a variable).
Reference: [56] <author> Math Works Inc. </author> <title> MATLAB User's Guide, </title> <year> 1992. </year>
Reference-contexts: Such calculations are an obviously important part of a language for prototyping numerical computations. We only consider dense array structures in this section, and indeed in EQ; issues of sparsity will be briefly discussed in Section 12.2.3. Many languages, such as APL [44] and MATLAB <ref> [56] </ref>, provide various features for operating on arrays "en masse"; that is, to perform computations on arrays without working on an element-by-element basis. Such mechanisms, however, often either are very incomplete, or require that the programmer carefully "position" his operands or generate simple constant structures before performing computations. <p> The imperative features of these languages often become correspondingly less important. This progression comes to its "logical" conclusion in Section 3.2, where the FP and FAC systems abandon imperative features all together, relying exclusively on the array operators. MATLAB MATLAB <ref> [56] </ref> was originally viewed as a system to provide access to LINPACK, significant mathematical libraries written in FORTRAN for performing linear algebra computations [26]. <p> The only language we know of that provides any facilities to address this issue is MATLAB <ref> [56] </ref>, which has built-in support for handling sparse arrays in the same way as it treats ordinary arrays. Unfortunately, their approach has some weaknesses, because the user is restricted to a particular implementation of sparsity.
Reference: [57] <author> MathSoft. </author> <note> MathCad. URL: http://www.mathsoft.com. </note>
Reference-contexts: We refer here to the structure of the notations involved, 7 not their particular graphical appearance (the graphical approach is taken, for example, in tools such as MathCAD <ref> [57] </ref>). Attempting to mimic the actual appearance of constructs such as p may have merit, but is impractical in an ASCII source file. We therefore treat p n and sqrt (n) as being basically the same.
Reference: [58] <author> Dror E. Maydan, Saman P. Amarasinghe, and Monica S. Lam. </author> <title> Array data-flow analysis and its use in array privatization. </title> <booktitle> In Proceedings of the 20th ACM Conference on Principles of Programming Langauges, </booktitle> <pages> pages 2-15, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Due to its design, EQ does not have to handle these issues, and therefore makes a more suitable vehicle for exploring rank reduction. There is also work on the inverse of array contraction, known as privatization <ref> [58] </ref>, which adds dimensions to variables inside loops such that each location is used only once. This process removes false dependencies between iterations of the loop, and has been designed for use as a part of parallelizing compilers.
Reference: [59] <author> Neonatura. </author> <title> BLUE compiler development system. </title> <publisher> Propritary. </publisher>
Reference-contexts: It also discusses the efficiency of the required computations. 7.1 Language Used for the Implementation EQ has been implemented using the BLUE Compiler Development System <ref> [21, 59] </ref>, a proprietary programming language of Neonatura. The primary component of this system is the BLUE language, which uses a generalization of graphs as its primary data structure.
Reference: [60] <author> Rishiyur S. Nikhil. </author> <title> Id language reference manual, </title> <note> version 90.1. Postscript available via FTP from Massachusetts Institute of Technology, </note> <month> July </month> <year> 1991. </year>
Reference-contexts: Id Id <ref> [60] </ref> is another functional language that is mostly side-effect free. Its features for supporting side effects, however, are very novel. It introduces constructions called I-structures and M-structures. These represent variables with a very limited semantic: * I-structures are variables that can be assigned once and only once. <p> What is of more importance to us are the Id features for representing loops. Like SISAL, Id provides structures that produce loops. The syntax and semantics are much simpler than the corresponding SISAL constructs. As an example of the notation, the following Id expression (taken from <ref> [60] </ref>) computes the nth Fibonacci number: -x, y = 1, 1 -for j &lt;- 1 to n do next x, next y = y, x+y finally x-- 55 For each iteration of the loop, values for next x and next y are determined from the existing x and y.
Reference: [61] <author> Can Ozturan, Balaram Sinharoy, and Boleslaw K. Szymanski. </author> <title> Compiler technology for parallel scientific computation. </title> <journal> Scientific Programming, </journal> <volume> 3(3) </volume> <pages> 201-225, </pages> <year> 1994. </year>
Reference-contexts: But in order to convert this idea into a general Turing complete programming language, they offer a variety of semantics. These usually involve some method for describing a related sequence of values. The technique by which sequences are expressed varies greatly in the various data flow languages. EPL EPL <ref> [72, 61] </ref> is one of the few statement-oriented side-effect free languages. The basic data structures within EPL are multi-dimensional arrays. Computations are expressed using the concept of subscripts, variables that implicitly vary over some set of integer values. <p> The EPL papers introduce the concept of windowing <ref> [61] </ref>. The idea behind windowing is that only a small finite portion of a variable along a particular dimension may need to be stored at any one time, with this "window" sweeping through the array as the computation proceeds. <p> This process removes false dependencies between iterations of the loop, and has been designed for use as a part of parallelizing compilers. The EPL project has also discussed the basic concepts behind rank reduction <ref> [61] </ref>. The EPL programming language has a form of EQ's iterators, but permits recurrences such as x [i+1] = x [i] + x [i-1] to be written.
Reference: [62] <author> L. C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: The execution of such code will be very poor, taking O (n 2 ) time. The above examples demonstrate the weaknesses of trying to use lists to represent arrays. ML ML <ref> [62] </ref> was the first language to offer a more sophisticated typing system than the earlier LISP and Scheme. ML offers a variety of data types, including user-declared data types corresponding to records and unions, and provides for pattern matching over these types.
Reference: [63] <author> S. L. Peyton Jones and P. L. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: As a result, functional languages have to either simply "give up" on side-effect free I/O, or else use highly abstract and convoluted structures to handle it (the Haskell approach of using "monadic" I/O <ref> [39, 63] </ref> is an example of the latter). Either way, some of the advantages of being side-effect free are lost. However, the "print" operation is clearly very similar in many respects to a partial update.
Reference: [64] <author> Jonathan Rees and William Clinger. </author> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Scheme LISP was really the first functional language to appear on the scene, and Scheme <ref> [64] </ref> is one of the most important dialects of that language. Scheme does not use a polymorphic typing system; instead, all data structures are constructed from lists of arbitrary elements (all elements need not be the same type, as in most of the other functional languages discussed in this section).
Reference: [65] <author> Vivek Sarkar and Guang R. Gao. </author> <title> Optimization of array accesses by collective loop transformations. </title> <booktitle> In Proceedings of the ACM 1991 International Conference on Supercomputing, </booktitle> <pages> pages 194-205, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: In this section we mention some of these projects, and their relationship to the approach outlined here. 195 There are numerous papers on performing array contraction (such as <ref> [11, 29, 65] </ref>) within standard imperative languages. Such work often becomes entangled with issues of complex dependency analysis and aliasing, and usually tries to handle recurrence structures. Due to its design, EQ does not have to handle these issues, and therefore makes a more suitable vehicle for exploring rank reduction.
Reference: [66] <author> R.B. Schnabel and J.E. Dennis Jr. </author> <title> Numerical Methods for Unconstrained Optimization and Nonlinear Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year> <note> Reprinted in the SIAM Classics In Applied Mathematics series, No. 16, </note> <year> 1996. </year>
Reference-contexts: Another notation we have seen uses x c for the current value of x, x p for the previous value (the previous approximation), and x + to represent the new approximation <ref> [66] </ref>. Regardless of the particulars of the notation, the important observation is that all of these were modifications of the symbol used for the variable x. <p> Obviously, any corresponding programming language notation cannot represent both of these as distinct concepts at the same time. Indeed, in their unconstrained optimization textbook <ref> [66] </ref>, Dennis and Schnabel avoid using numerical subscripts at all in algorithmic pseudo-code, for fear of the resulting confusion. <p> The similarities between notations such as x + = f (x c ; x p ) (the notation used in <ref> [66] </ref>) and next x = f (x, prev x); are, we feel, significant. * The concept of iterators developed in Section 4.2.2 allows array computations to be written in a style very similar to their mathematical "element-by-element" counterparts. <p> An excellent presentation of the BFGS method and related minimization algorithms can be found in Dennis and Schnabel <ref> [66] </ref>. The variant of this algorithm presented here works as follows. At each major step, an approximate local quadratic model is constructed of the function f , and a step towards the minimizer of that model is proposed. <p> Instead, it would be preferable to somehow specify these in the main program. But passing a large set of parameters to each call to BFGS is also inelegant. Indeed, Dennis and Schnabel <ref> [66] </ref> describe unconstrained optimization algorithms in their Appendix A as if all of the variables being manipulated are global. * A user-level sizing system (see Section 12.2.3) will make it desirable to declare global ranges representing sizes of particular interest.
Reference: [67] <author> S. A. Smith, T.O. Levante, B.H. Meier, and R.R. Erns. </author> <title> Computer simulations in magnetic resonance: An object-oriented programming approach. Journal of Magnetic Resonance, A, </title> <month> November </month> <year> 1993. </year> <month> 312 </month>
Reference-contexts: to draw itself with no knowledge of how the code that performs this function does so. 57 Existing applications of object-oriented approaches to scientific computing problems include the areas of class library definition (matrix and array classes, as well as libraries to support specific scientific fields, such as magnetic resonance <ref> [67] </ref>) and support for general frameworks, such as [5]. Object-oriented ideas relate more to high-level structuring mechanisms, such as class hierarchies; our goals are more relevant to "programming in the small".
Reference: [68] <author> Lawrence Snyder. </author> <title> ZPL program walk-through. </title> <note> Available from the University of Washing-ton. </note>
Reference-contexts: The above analysis suggests that fields might potentially be better represented in a different fashion than that used for matrices, an idea discussed further in Section 12.2.3. ZPL ZPL <ref> [68, 69] </ref> is a "language within a language"; it forms a small part of the more general Orca model for parallel programming. The "Z" level is the most restricted, but also the easiest to use. <p> ZPL offers arrays that are really fields, in the sense described earlier. All operators are extended to operate in an element-by-element fashion, and the set of elements that are operated on in a given statement is specified by giving a region. For example (abstracted from <ref> [68] </ref>), region R = [1..n, 1..n]; direction north = [-1,0]; south = [1,0]; east = [0,1]; west = [0,1]; [R] A = (A@north + A@east + A@west + A@south) / 4.0; performs a standard Jacobi smoothing step. The "[R]" specifies the region over which the computation is to be performed.
Reference: [69] <author> Lawrence Snyder. </author> <title> A ZPL programming guide. </title> <institution> Available from the University of Washington, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The above analysis suggests that fields might potentially be better represented in a different fashion than that used for matrices, an idea discussed further in Section 12.2.3. ZPL ZPL <ref> [68, 69] </ref> is a "language within a language"; it forms a small part of the more general Orca model for parallel programming. The "Z" level is the most restricted, but also the easiest to use. <p> We should note that the designers of ZPL would argue, perhaps correctly, that this is as it should be, since the standard matrix-matrix multiplication does not parallelize fully. They do present a very complicated matrix-matrix multiplication routine which is fully parallel <ref> [69] </ref>, involving explicitly shifting the elements of the source arrays around the processors of the parallel machine. However, it is not always the case that a fully parallel algorithm is needed, even on a parallel machine. FIDIL FIDIL [35, 36], in contrast, is a much richer programming environment.
Reference: [70] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1986. </year>
Reference-contexts: Object-oriented ideas relate more to high-level structuring mechanisms, such as class hierarchies; our goals are more relevant to "programming in the small". Although object-orientation is usually considered in terms of imperative languages such as C++ <ref> [70] </ref> or Java [30], the concept is more generally applicable. Haskell, for example, provides object orientation through its type class system [33]. Thus, object-oriented concepts can be applied to side-effect free languages as well as the standard imperative ones.
Reference: [71] <author> Steven J. Sullivan and Benjamin G. Zorn. </author> <title> Numerical analysis using nonprocedural paradigms. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 21(3) </volume> <pages> 267-298, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Its typing system makes it very clear when referential transparency reasoning is appropriate, and when it is not. However, by embracing the side-effect system of the imperative languages, it also acquires all of its weaknesses <ref> [71] </ref>. ML's handling of arrays, however, is somewhat weak notationally. It does support the major operations, including partial update, but only on an element-by-element basis. 3.3.2 Side-Effect Free Functional Languages Another group of functional languages embraces strict enforcement of the side-effect free rules.
Reference: [72] <author> Boleslaw K. Szymanski. </author> <title> EPL|parallel programming with recurrent equations. </title> <editor> In Boleslaw K. Szymanski, editor, </editor> <booktitle> Parallel Functional Languages and Compilers, chapter 3, </booktitle> <pages> pages 51-104. </pages> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <year> 1991. </year>
Reference-contexts: But in order to convert this idea into a general Turing complete programming language, they offer a variety of semantics. These usually involve some method for describing a related sequence of values. The technique by which sequences are expressed varies greatly in the various data flow languages. EPL EPL <ref> [72, 61] </ref> is one of the few statement-oriented side-effect free languages. The basic data structures within EPL are multi-dimensional arrays. Computations are expressed using the concept of subscripts, variables that implicitly vary over some set of integer values.
Reference: [73] <author> Hai-Chen Tu and Alan J. Perlis. </author> <title> FAC: A functional APL language. </title> <journal> IEEE Software, </journal> <volume> 3(1) </volume> <pages> 36-45, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: This restriction results in even more positioning operators than other languages that manipulate arrays (such as APL), because now even multiple arguments to a function have to be positioned using operators. FAC FAC <ref> [73] </ref> is a somewhat similar idea, except that the underlying operators are more powerful. While not technically a strict combinator-based language, FAC's powerful array features still encourage this sort of programming. Unlike FP, FAC (which stands for Functional Array Calculator) is based on the syntax and operators of APL2 directly.
Reference: [74] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software: Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: Combinators are nothing more than a particular set of functions, which are then used to build other computations through composition, instead of using the variable binding mechanisms of standard functional languages. For example, the SK combinator system <ref> [74] </ref> consists of only two combinators: S = x:y:z:( x y)( x z) Surprisingly, just using these two functions forms a fully Turing complete computation system; any computation that can be done in the Lambda calculus can be performed using just S and K.
Reference: [75] <author> David Turner. </author> <title> An overview of Miranda. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, chapter 1, </booktitle> <pages> pages 1-14. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Many features of earlier functional languages such as ML and Miranda <ref> [75] </ref> have been made more elegant and general in Haskell, eliminating many of the pitfalls found in its predecessors. Haskell does support multi-dimensional array constructions, through its "Array" type (part of the Ix library). Like Id, the basic facilities are oriented toward the construction of "monolithic" arrays.
Reference: [76] <author> William W. Wadge. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Windowing is related to our work in Chapter 8 on rank reduction. In more recent research EPL has viewed itself as a useful intermediate form rather than a direct source language, and had considered the process of translating FORTRAN programs automatically into EPL for optimization [19]. Lucid Lucid <ref> [2, 76] </ref> is a data flow language in the most direct sense possible, because each variable v represents not a single value, but an entire stream of values at once. It too uses a single assignment rule, which means that the entire stream must be defined at once.
References-found: 76

