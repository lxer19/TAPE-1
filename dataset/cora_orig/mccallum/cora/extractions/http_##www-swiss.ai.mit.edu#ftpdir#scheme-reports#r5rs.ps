URL: http://www-swiss.ai.mit.edu/ftpdir/scheme-reports/r5rs.ps
Refering-URL: http://www.norvig.com/SILK.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: 5 Report on the Algorithmic Language Scheme convenient expression in Scheme. The introduction offers a
Author: G. BROOKS C. HANSON K. M. PITMAN M. WAND Robert Hieb 
Keyword: language.  3.1 Variables, syntactic keywords, and regions 6  keywords, and procedures 48  
Note: Dedicated to the Memory of  find  Chapters 4 and 5 describe the  1.2 Syntax 3 1.3 Notation and terminology 3 2 Lexical conventions 5 2.1 Identifiers 5 2.2 Whitespace and comments 5 2.3 Other notations 5 3 Basic concepts 6  3.2 Disjointness of types 6 3.3 External representations 6  5 Program structure 16 5.1 Programs 16 5.2 Definitions 16 5.3 Syntax definitions 17 6 Standard procedures 17 6.1 Equivalence predicates 17 6.2 Numbers 19 6.3 Other data types 25 6.4 Control features 31 6.5 Eval 35 6.6 Input and output 35 7 Formal syntax and semantics 38 7.1 Formal syntax 38 7.2 Formal semantics  
Date: Revised  20 February 1998  1.1 Semantics 3  4.3 Macros 13  40  
Pubnum: 10  
Abstract: RICHARD KELSEY, WILLIAM CLINGER, AND JONATHAN REES (Editors) H. ABELSON R. K. DYBVIG C. T. HAYNES G. J. ROZAS N. I. ADAMS IV D. P. FRIEDMAN E. KOHLBECKER G. L. STEELE JR. D. H. BARTLEY R. HALSTEAD D. OXLEY G. J. SUSSMAN SUMMARY The report gives a defining description of the programming language Scheme. Scheme is a statically scoped and properly tail-recursive dialect of the Lisp programming language invented by Guy Lewis Steele Jr. and Gerald Jay Sussman. It was designed to have an exceptionally clear and simple semantics and few different ways to form expressions. A wide variety of programming paradigms, including imperative, functional, and message passing styles, of the report. The first three chapters present the fundamental ideas of the language and describe the notational conventions used for describing the language and for writing programs in the 7.3 Derived expression types . . . . . . . . . . . . . . . . . 43 Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 Additional material . . . . . . . . . . . . . . . . . . . . . . . . 45 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 Alphabetic index of definitions of concepts, 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson and Gerald Jay Sussman with Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs, second edition. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1996. </year>
Reference-contexts: Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University [21, 17, 10]. An introductory computer science textbook using Scheme was published in 1984 <ref> [1] </ref>. As Scheme became more widespread, local dialects began to diverge until students and researchers occasionally found it difficult to understand code written at other sites.
Reference: [2] <author> Alan Bawden and Jonathan Rees. </author> <title> Syntactic closures. </title> <booktitle> In Proceedings of the 1988 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 86-95. </pages>
Reference-contexts: The syntactic keyword of a macro may shadow variable bindings, and local variable bindings may shadow keyword bindings. All macros defined using the pattern language are "hygienic" and "referentially transparent" and thus preserve Scheme's lexical scoping <ref> [14, 15, 2, 7, 9] </ref>: 14 Revised 5 Scheme * If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers.
Reference: [3] <author> Robert G. Burger and R. Kent Dybvig. </author> <title> Printing floating-point numbers quickly and accurately. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 108-116. </pages>
Reference-contexts: is inexact, the radix is 10, and the above expression can be satisfied by a result that contains a decimal point, then the result contains a decimal point and is expressed using the minimum number of digits (exclusive of exponent and trailing zeroes) needed to make the above expression true <ref> [3, 5] </ref>; otherwise the format of the result is unspecified. The result returned by number-&gt;string never contains an explicit radix prefix. Note: The error case can occur only when z is not a complex number or is a complex number with a non-rational real or imaginary part.
Reference: [4] <editor> William Clinger, editor. </editor> <title> The revised revised report on Scheme, or an uncommon Lisp. </title> <booktitle> MIT Artificial Intelligence Memo 848, </booktitle> <month> August </month> <year> 1985. </year> <note> Also published as Computer Science Department Technical Report 174, </note> <institution> Indiana University, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Fifteen representatives of the major implementations of Scheme therefore met in October 1984 to work toward a better and more widely accepted standard for Scheme. Their report <ref> [4] </ref> was published at MIT and Indiana University in the summer of 1985. Further revision took place in the spring of 1986 [23], and in the spring of 1988 [6]. The present report reflects further revisions agreed upon in a meeting at Xerox PARC in June 1992.
Reference: [5] <author> William Clinger. </author> <title> How to read floating point numbers accurately. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 92-101. </pages> <note> Proceedings published as SIGPLAN Notices 25(6), </note> <month> June </month> <year> 1990. </year>
Reference-contexts: is inexact, the radix is 10, and the above expression can be satisfied by a result that contains a decimal point, then the result contains a decimal point and is expressed using the minimum number of digits (exclusive of exponent and trailing zeroes) needed to make the above expression true <ref> [3, 5] </ref>; otherwise the format of the result is unspecified. The result returned by number-&gt;string never contains an explicit radix prefix. Note: The error case can occur only when z is not a complex number or is a complex number with a non-rational real or imaginary part.
Reference: [6] <editor> William Clinger and Jonathan Rees, editors. </editor> <title> The revised 4 report on the algorithmic language Scheme. </title> <booktitle> In ACM Lisp Pointers 4(3), </booktitle> <pages> pages 1-55, </pages> <year> 1991. </year>
Reference-contexts: Their report [4] was published at MIT and Indiana University in the summer of 1985. Further revision took place in the spring of 1986 [23], and in the spring of 1988 <ref> [6] </ref>. The present report reflects further revisions agreed upon in a meeting at Xerox PARC in June 1992. We intend this report to belong to the entire Scheme com munity, and so we grant permission to copy it in whole or in part without fee. <p> test (begin (if #f #f) expr ...) (begin command ... (loop (do "step" var step ...) ...)))))) (loop init ...))) ((do "step" x) x) ((do "step" x y) y))) Example 45 NOTES Language changes This section enumerates the changes that have been made to Scheme since the "Revised 4 report" <ref> [6] </ref> was published. * The report is now a superset of the IEEE standard for Scheme [13]: implementations that conform to the report will also conform to the standard. This required the following changes: The empty list is now required to count as true.
Reference: [7] <author> William Clinger and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 155-162. </pages>
Reference-contexts: The syntactic keyword of a macro may shadow variable bindings, and local variable bindings may shadow keyword bindings. All macros defined using the pattern language are "hygienic" and "referentially transparent" and thus preserve Scheme's lexical scoping <ref> [14, 15, 2, 7, 9] </ref>: 14 Revised 5 Scheme * If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers.
Reference: [8] <author> William Clinger. </author> <title> Proper Tail Recursion and Space Efficiency. </title> <booktitle> To appear in Proceedings of the 1998 ACM Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: In the absence of captured continuations, calls could return at most once and the active calls would be those that had not yet returned. A formal definition of proper tail recursion can be found in <ref> [8] </ref>. Rationale: Intuitively, no space is needed for an active tail call because the continuation that is used in the tail call has the same semantics as the continuation passed to the procedure containing the call.
Reference: [9] <author> R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. </author> <title> Syntactic abstraction in Scheme. </title> <booktitle> Lisp and Symbolic Computation 5(4) </booktitle> <pages> 295-326, </pages> <year> 1993. </year>
Reference-contexts: The syntactic keyword of a macro may shadow variable bindings, and local variable bindings may shadow keyword bindings. All macros defined using the pattern language are "hygienic" and "referentially transparent" and thus preserve Scheme's lexical scoping <ref> [14, 15, 2, 7, 9] </ref>: 14 Revised 5 Scheme * If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers.
Reference: [10] <author> Carol Fessenden, William Clinger, Daniel P. Fried-man, and Christopher Haynes. </author> <note> Scheme 311 version 4 reference manual. Indiana University Computer Science Technical Report 137, February 1983. Superseded by [11]. </note>
Reference-contexts: A revised report [25] appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler [26]. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University <ref> [21, 17, 10] </ref>. An introductory computer science textbook using Scheme was published in 1984 [1]. As Scheme became more widespread, local dialects began to diverge until students and researchers occasionally found it difficult to understand code written at other sites.
Reference: [11] <author> D. Friedman, C. Haynes, E. Kohlbecker, and M. Wand. </author> <title> Scheme 84 interim reference manual. </title> <note> Indi-ana University Computer Science Technical Report 153, January 1985. References 47 </note>
Reference: [12] <editor> IEEE Standard 754-1985. </editor> <title> IEEE Standard for Binary Floating-Point Arithmetic. </title> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: This report recommends, but does not require, that the IEEE 32-bit and 64-bit floating point standards be followed by implementations that use flonum representations, and that implementations using other representations should match or exceed the precision achievable using these floating point standards <ref> [12] </ref>. In particular, implementations that use flonum representations must follow these rules: A flonum result must be represented with at least as much precision as is used to express any of the inexact arguments to that operation.
Reference: [13] <editor> IEEE Standard 1178-1990. </editor> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: ...)))))) (loop init ...))) ((do "step" x) x) ((do "step" x y) y))) Example 45 NOTES Language changes This section enumerates the changes that have been made to Scheme since the "Revised 4 report" [6] was published. * The report is now a superset of the IEEE standard for Scheme <ref> [13] </ref>: implementations that conform to the report will also conform to the standard. This required the following changes: The empty list is now required to count as true. The classification of features as essential or inessential has been removed.
Reference: [14] <author> Eugene E. Kohlbecker Jr. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indi-ana University, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: The syntactic keyword of a macro may shadow variable bindings, and local variable bindings may shadow keyword bindings. All macros defined using the pattern language are "hygienic" and "referentially transparent" and thus preserve Scheme's lexical scoping <ref> [14, 15, 2, 7, 9] </ref>: 14 Revised 5 Scheme * If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers.
Reference: [15] <author> Eugene E. Kohlbecker Jr., Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-161. </pages>
Reference-contexts: The syntactic keyword of a macro may shadow variable bindings, and local variable bindings may shadow keyword bindings. All macros defined using the pattern language are "hygienic" and "referentially transparent" and thus preserve Scheme's lexical scoping <ref> [14, 15, 2, 7, 9] </ref>: 14 Revised 5 Scheme * If a macro transformer inserts a binding for an identifier (variable or keyword), the identifier will in effect be renamed throughout its scope to avoid conflicts with other identifiers.
Reference: [16] <author> Peter Landin. </author> <title> A correspondence between Algol 60 and Church's lambda notation: Part I. </title> <journal> Communications of the ACM 8(2) </journal> <pages> 89-101, </pages> <month> February </month> <year> 1965. </year>
Reference-contexts: Call-with-current-continuation allows Scheme pro 34 Revised 5 Scheme grammers to do that by creating a procedure that acts just like the current continuation. Most programming languages incorporate one or more special-purpose escape constructs with names like exit, return, or even goto. In 1965, however, Peter Landin <ref> [16] </ref> invented a general purpose escape operator called the J-operator. John Reynolds [24] described a simpler but equally powerful construct in 1972.
Reference: [17] <institution> MIT Department of Electrical Engineering and Computer Science. </institution> <note> Scheme manual, seventh edition. </note> <month> September </month> <year> 1984. </year>
Reference-contexts: A revised report [25] appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler [26]. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University <ref> [21, 17, 10] </ref>. An introductory computer science textbook using Scheme was published in 1984 [1]. As Scheme became more widespread, local dialects began to diverge until students and researchers occasionally found it difficult to understand code written at other sites. <p> We thank Texas Instruments, Inc. for permission to use text from the TI Scheme Language Reference Manual [30]. We gladly acknowledge the influence of manuals for MIT Scheme <ref> [17] </ref>, T [22], Scheme 84 [11],Common Lisp [27], and Algol 60 [18]. We also thank Betty Dexter for the extreme effort she put into setting this report in T E X, and Donald Knuth for designing the program that caused her troubles.
Reference: [18] <author> Peter Naur et al. </author> <title> Revised report on the algorithmic language Algol 60. </title> <journal> Communications of the ACM 6(1) </journal> <pages> 1-17, </pages> <month> January </month> <year> 1963. </year>
Reference-contexts: We thank Texas Instruments, Inc. for permission to use text from the TI Scheme Language Reference Manual [30]. We gladly acknowledge the influence of manuals for MIT Scheme [17], T [22], Scheme 84 [11],Common Lisp [27], and Algol 60 <ref> [18] </ref>. We also thank Betty Dexter for the extreme effort she put into setting this report in T E X, and Donald Knuth for designing the program that caused her troubles.
Reference: [19] <author> Paul Penfield, Jr. </author> <title> Principal values and branch cuts in complex APL. </title> <booktitle> In APL '81 Conference Proceedings, </booktitle> <pages> pages 248-256. </pages> <publisher> ACM SIGAPL, </publisher> <address> San Fran-cisco, </address> <month> September </month> <year> 1981. </year> <note> Proceedings published as APL Quote Quad 12(1), ACM, </note> <month> September </month> <year> 1981. </year>
Reference-contexts: With log defined this way, the values of sin 1 z, cos 1 z, and tan 1 z are according to the following for-mul: p cos 1 z = =2 sin 1 z The above specification follows [27], which in turn cites <ref> [19] </ref>; refer to these sources for more detailed discussion of branch cuts, boundary conditions, and implementation of these functions. When it is possible these procedures produce a real result from a real argument. 24 Revised 5 Scheme (sqrt z) procedure Returns the principal square root of z.
Reference: [20] <author> Kent M. </author> <note> Pitman. The revised MacLisp manual (Sat-urday evening edition). </note> <institution> MIT Laboratory for Computer Science Technical Report 295, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: Numbers Numerical computation has traditionally been neglected by the Lisp community. Until Common Lisp there was no carefully thought out strategy for organizing numerical computation, and with the exception of the MacLisp system <ref> [20] </ref> little effort was made to execute numerical code efficiently. This report recognizes the excellent work of the Common Lisp committee and accepts many of their recommendations. In some ways this report simplifies and generalizes their proposals in a manner consistent with the purposes of Scheme.
Reference: [21] <author> Jonathan A. Rees and Norman I. Adams IV. </author> <title> T: A dialect of Lisp or, lambda: The ultimate software tool. </title> <booktitle> In Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 114-122. </pages>
Reference-contexts: A revised report [25] appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler [26]. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University <ref> [21, 17, 10] </ref>. An introductory computer science textbook using Scheme was published in 1984 [1]. As Scheme became more widespread, local dialects began to diverge until students and researchers occasionally found it difficult to understand code written at other sites.
Reference: [22] <author> Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan. </author> <title> The T manual, fourth edition. </title> <institution> Yale University Computer Science Department, </institution> <month> January </month> <year> 1984. </year>
Reference-contexts: We thank Texas Instruments, Inc. for permission to use text from the TI Scheme Language Reference Manual [30]. We gladly acknowledge the influence of manuals for MIT Scheme [17], T <ref> [22] </ref>, Scheme 84 [11],Common Lisp [27], and Algol 60 [18]. We also thank Betty Dexter for the extreme effort she put into setting this report in T E X, and Donald Knuth for designing the program that caused her troubles.
Reference: [23] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <booktitle> In ACM SIGPLAN Notices 21(12), </booktitle> <pages> pages 37-79, </pages> <month> De-cember </month> <year> 1986. </year>
Reference-contexts: Fifteen representatives of the major implementations of Scheme therefore met in October 1984 to work toward a better and more widely accepted standard for Scheme. Their report [4] was published at MIT and Indiana University in the summer of 1985. Further revision took place in the spring of 1986 <ref> [23] </ref>, and in the spring of 1988 [6]. The present report reflects further revisions agreed upon in a meeting at Xerox PARC in June 1992.
Reference: [24] <author> John Reynolds. </author> <title> Definitional interpreters for higher order programming languages. </title> <booktitle> In ACM Conference Proceedings, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: Most programming languages incorporate one or more special-purpose escape constructs with names like exit, return, or even goto. In 1965, however, Peter Landin [16] invented a general purpose escape operator called the J-operator. John Reynolds <ref> [24] </ref> described a simpler but equally powerful construct in 1972. The catch special form described by Sussman and Steele in the 1975 report on Scheme is exactly the same as Reynolds's construct, though its name came from a less general construct in MacLisp.
Reference: [25] <author> Guy Lewis Steele Jr. and Gerald Jay Sussman. </author> <title> The revised report on Scheme, a dialect of Lisp. </title> <booktitle> MIT Artificial Intelligence Memo 452, </booktitle> <month> January </month> <year> 1978. </year>
Reference-contexts: More recently, Scheme became the first programming language to support hygienic macros, which permit the syntax of a block-structured language to be extended in a consistent and reliable manner. Background The first description of Scheme was written in 1975 [28]. A revised report <ref> [25] </ref> appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler [26]. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University [21, 17, 10].
Reference: [26] <author> Guy Lewis Steele Jr. Rabbit: </author> <title> a compiler for Scheme. </title> <institution> MIT Artificial Intelligence Laboratory Technical Report 474, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: Background The first description of Scheme was written in 1975 [28]. A revised report [25] appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler <ref> [26] </ref>. Three distinct projects began in 1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and Indiana University [21, 17, 10]. An introductory computer science textbook using Scheme was published in 1984 [1].
Reference: [27] <author> Guy Lewis Steele Jr. </author> <title> Common Lisp: The Language, second edition. </title> <publisher> Digital Press, </publisher> <address> Burlington MA, </address> <year> 1990. </year>
Reference-contexts: We thank Texas Instruments, Inc. for permission to use text from the TI Scheme Language Reference Manual [30]. We gladly acknowledge the influence of manuals for MIT Scheme [17], T [22], Scheme 84 [11],Common Lisp <ref> [27] </ref>, and Algol 60 [18]. We also thank Betty Dexter for the extreme effort she put into setting this report in T E X, and Donald Knuth for designing the program that caused her troubles. <p> With log defined this way, the values of sin 1 z, cos 1 z, and tan 1 z are according to the following for-mul: p cos 1 z = =2 sin 1 z The above specification follows <ref> [27] </ref>, which in turn cites [19]; refer to these sources for more detailed discussion of branch cuts, boundary conditions, and implementation of these functions.
Reference: [28] <author> Gerald Jay Sussman and Guy Lewis Steele Jr. </author> <title> Scheme: an interpreter for extended lambda calculus. </title> <booktitle> MIT Artificial Intelligence Memo 349, </booktitle> <month> December </month> <year> 1975. </year>
Reference-contexts: More recently, Scheme became the first programming language to support hygienic macros, which permit the syntax of a block-structured language to be extended in a consistent and reliable manner. Background The first description of Scheme was written in 1975 <ref> [28] </ref>. A revised report [25] appeared in 1978, which described the evolution of the language as its MIT implementation was upgraded to support an innovative compiler [26].
Reference: [29] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1977. </year>
Reference-contexts: Formal semantics This section provides a formal denotational semantics for the primitive expressions of Scheme and selected built-in procedures. The concepts and notation used here are described in <ref> [29] </ref>; the notation is summarized below: h : : : i sequence formation s # k kth member of the sequence s (1-based) #s length of sequence s s x t concatenation of sequences s and t s y k drop the first k members of sequence s t ! a;

References-found: 29

