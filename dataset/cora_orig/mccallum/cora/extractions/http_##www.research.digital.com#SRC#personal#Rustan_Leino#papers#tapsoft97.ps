URL: http://www.research.digital.com/SRC/personal/Rustan_Leino/papers/tapsoft97.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Rustan_Leino/home.html
Root-URL: http://www.research.digital.com
Email: fma,rustang@pa.dec.com  
Title: A logic of object-oriented programs  
Author: Martin Abadi and K. Rustan M. Leino 
Affiliation: Systems Research Center Digital Equipment Corporation  
Abstract: We develop a logic for reasoning about object-oriented programs. The logic is for a language with an imperative semantics and aliasing, and accounts for self-reference in objects. It is much like a type system for objects with subtyping, but our specifications go further than types in detailing pre- and postconditions. We intend the logic as an analogue of Hoare logic for object-oriented programs. Our main technical result is a soundness theorem that relates the logic to a standard operational semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [AC96] <author> M. Abadi and L. Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: Roughly imitating Hoare, we develop a logic for the specification and verification of object-oriented programs. We focus on elementary goals: we are interested in logical reasoning about pre- and postconditions of programs written in a basic object-oriented programming language (a variant of the calculi of Abadi and Cardelli <ref> [AC96] </ref>). Like Hoare, we deal with partial correctness, not with termination. The programming language presents many interesting and challenging features of common object-oriented languages. In particular, the operational semantics of the language is imperative and allows aliasing. Objects have fields and methods, and the self variable permits self-reference. <p> Thus, object types are invariant in the types of fields; this invariance is essential for soundness <ref> [AC96] </ref>. Formally, we write ` A to express that A is a well-formed type, and ` A &lt;: A 0 to express that A is a subtype of A 0 .
Reference: [Apt81] <author> K.R. Apt. </author> <title> Ten years of Hoare's logic: A survey|Part I. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 431-483, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: We aim to develop a logic with some of those same advantages. Our rules are not quite as simple as Hoare's, in part because of aliasing, and in part because objects are more expressive than first-order procedures and give some facilities for higher-order programming (cf. <ref> [Cla79, Apt81] </ref>). However, our rules are precise; in particular, we are able to state and to prove a soundness theorem. We do not know of any equivalent soundness theorem in the object-oriented literature. In the next section we describe the programming language.
Reference: [Cla79] <author> E.M. Clarke. </author> <title> Programming language constructs for which it is impossible to obtain good Hoare axiom systems. </title> <journal> Journal of the ACM, </journal> <volume> 26(1) </volume> <pages> 129-147, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: We aim to develop a logic with some of those same advantages. Our rules are not quite as simple as Hoare's, in part because of aliasing, and in part because objects are more expressive than first-order procedures and give some facilities for higher-order programming (cf. <ref> [Cla79, Apt81] </ref>). However, our rules are precise; in particular, we are able to state and to prove a soundness theorem. We do not know of any equivalent soundness theorem in the object-oriented literature. In the next section we describe the programming language.
Reference: [Flo67] <author> R.W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Proceedings of the Symposium on Applied Math., </booktitle> <volume> Vol. 19, </volume> <pages> pages 19-32. </pages> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: 1 Introduction In the realm of procedural programming, Floyd and Hoare defined two of the first logics of programs <ref> [Flo67, Hoa69] </ref>; many later formalisms and systems built on their ideas, and addressed difficult questions of concurrency and data abstraction, for example. An analogous development has not taken place in object-oriented programming.
Reference: [Har94] <author> R. Harper. </author> <title> A simplified account of polymorphic references. </title> <journal> Information Processing Letters, </journal> <volume> 51 </volume> <pages> 201-206, </pages> <year> 1994. </year>
Reference-contexts: As another corollary, we obtain a soundness theorem for the type system of section 2.2. Therefore, as might be expected, our proofs are no less intricate than typical soundness proofs for type systems of imperative languages. In fact, they generalize techniques developed for proofs of type soundness <ref> [Har94, Ler92, Tof90, WF94] </ref>. New ingredients are required because specifications, unlike ordinary (non-dependent) types, may contain occurrences of program variables. 5.3 Completeness issues While we have soundness, we do not have its converse, completeness. Unfortunately, our rules do not seem to be complete even for well-typed programs.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: 1 Introduction In the realm of procedural programming, Floyd and Hoare defined two of the first logics of programs <ref> [Flo67, Hoa69] </ref>; many later formalisms and systems built on their ideas, and addressed difficult questions of concurrency and data abstraction, for example. An analogous development has not taken place in object-oriented programming.
Reference: [Jon92] <author> C.B. Jones. </author> <title> An object-based design method for concurrent programs. </title> <type> Technical Report UMCS-92-12-1, </type> <institution> University of Manchester, </institution> <year> 1992. </year>
Reference-contexts: At the type level, the type of an object lists the types of its fields and the result types of its methods; a subtyping relation supports subsumption and inheritance. We mostly ignore "advanced" issues, like concurrency, but some of them have been considered in the literature (e.g., see <ref> [Jon92, YT87] </ref>). Much like Hoare logic, our logic includes one rule for reasoning about pre-and postconditions for each of the constructs of the programming language. In order to formulate these rules, we introduce object specifications.
Reference: [Lea89] <author> G.T. Leavens. </author> <title> Verifying Object-Oriented Programs that Use Subtypes. </title> <type> PhD thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <note> Available as Technical Report MIT/LCS/TR-439. </note>
Reference-contexts: The words "object" and "logic" are frequently used together in the literature, but with many different meanings (e.g., [SSC95]). Our work is most similar to that of Leavens <ref> [Lea89] </ref>, who gave verification rules for a small language with objects; however, those rules are limited in that they apply only to programs without side-effects and aliasing. We do not know of any previous Hoare logic for a language like ours. <p> We do not know of any previous Hoare logic for a language like ours. Much of the emphasis of the previous research has been on issues of refinement and inheritance. Lano and Haughton [LH92], Leavens <ref> [Lea89, Lea91] </ref>, and Liskov and Wing [LW94] all studied notions of subtyping and of refinement of specifications (similar to our subspecification relation, though in some respects more sophisticated). Stata and Guttag [SG95] studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance.
Reference: [Lea91] <author> G.T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <pages> pages 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: We do not know of any previous Hoare logic for a language like ours. Much of the emphasis of the previous research has been on issues of refinement and inheritance. Lano and Haughton [LH92], Leavens <ref> [Lea89, Lea91] </ref>, and Liskov and Wing [LW94] all studied notions of subtyping and of refinement of specifications (similar to our subspecification relation, though in some respects more sophisticated). Stata and Guttag [SG95] studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance.
Reference: [Lei95] <author> K.R.M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: Specifications at different levels of abstraction can be related by simulation relations or abstraction functions. Undoubtedly the use of abstraction is important for specification and verification. We leave a full treatment of abstraction for future work; some results on abstraction appear in Leino's dissertation <ref> [Lei95] </ref>, which also includes a guarded-command semantics for objects. Several other extensions to our logic might be interesting. For example, it would be trivial to account for a construct that compares the addresses of two objects, or for a cloning construct.
Reference: [Ler92] <author> X. Leroy. </author> <title> Polymorphic typing of an algorithmic language. </title> <type> Technical report, </type> <institution> Institut National de Recherche en Informatique et en Automatique, </institution> <month> October </month> <year> 1992. </year> <note> English version of the author's PhD thesis. </note>
Reference-contexts: As another corollary, we obtain a soundness theorem for the type system of section 2.2. Therefore, as might be expected, our proofs are no less intricate than typical soundness proofs for type systems of imperative languages. In fact, they generalize techniques developed for proofs of type soundness <ref> [Har94, Ler92, Tof90, WF94] </ref>. New ingredients are required because specifications, unlike ordinary (non-dependent) types, may contain occurrences of program variables. 5.3 Completeness issues While we have soundness, we do not have its converse, completeness. Unfortunately, our rules do not seem to be complete even for well-typed programs.
Reference: [LH92] <author> K. Lano and H. Haughton. </author> <title> Reasoning and refinement in object-oriented specification languages. </title> <editor> In Ole Lehrmann Madsen, editor, </editor> <booktitle> Proceedings of the 6th European Conference on Object-Oriented Programming (ECOOP), </booktitle> <pages> pages 78-97. </pages> <publisher> Springer-Verlag LNCS 615, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: We do not know of any previous Hoare logic for a language like ours. Much of the emphasis of the previous research has been on issues of refinement and inheritance. Lano and Haughton <ref> [LH92] </ref>, Leavens [Lea89, Lea91], and Liskov and Wing [LW94] all studied notions of subtyping and of refinement of specifications (similar to our subspecification relation, though in some respects more sophisticated). Stata and Guttag [SG95] studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance.
Reference: [LH94] <author> K. Lano and H. Haughton. </author> <title> Object-Oriented Specification Case Studies. </title> <publisher> Pren-tice Hall, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: Stata and Guttag [SG95] studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance. Lano and Haughton <ref> [LH94] </ref> have collected other research on object-oriented specification. In some existing formalisms (e.g., Leavens'), specifications can be written in terms of abstract variables. Specifications at different levels of abstraction can be related by simulation relations or abstraction functions. Undoubtedly the use of abstraction is important for specification and verification.
Reference: [LW94] <author> B.H. Liskov and J.M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Trans--actions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In particular, types are not automatically associated with specifications, and subtyping does not impose any "behavioral" constraints (cf. <ref> [LW94] </ref>). However, as section 3 explains, specifications generalize types. 3 Verification In this section, which is the core of the paper, we give rules for verifying object-oriented programs written in the language of section 2. <p> We do not know of any previous Hoare logic for a language like ours. Much of the emphasis of the previous research has been on issues of refinement and inheritance. Lano and Haughton [LH92], Leavens [Lea89, Lea91], and Liskov and Wing <ref> [LW94] </ref> all studied notions of subtyping and of refinement of specifications (similar to our subspecification relation, though in some respects more sophisticated). Stata and Guttag [SG95] studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance.
Reference: [MS88] <author> A.R. Meyer and K. Sieber. </author> <title> Towards fully abstract semantics for local variables: Preliminary report. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 191-203, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: We have considered other remedies, but do not yet know which is the "right" one. A deeper difficulty arises because the verification rules rely on a "global store" model. As Meyer and Sieber have explained <ref> [MS88] </ref>, the use of this model is a source of incompleteness for procedural languages with local variables. Some of their remarks apply to our language as well. For example, the following program is reminiscent of their Example 2: let x = [f = true] in (y:m ; x:f).
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The addition of concurrency primitives would be more difficult; it would call for a change of formalism, similar to the move from Hoare logic to Owicki-Gries logic <ref> [OG76] </ref>. 7 Conclusions In summary, the main outcome of our work is a logic that enables us (at least in principle) to specify and to verify object-oriented programs. To our knowledge, our notations and rules are novel.
Reference: [OT95] <author> P.W. O'Hearn and R.D. Tennent. </author> <title> Parametricity and local variables. </title> <journal> Journal of the ACM, </journal> <volume> 42(3) </volume> <pages> 658-709, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: We can prove this, but only by adopting a strong specification for y, for example requiring that y:m not modify the field f of any object. Recently, there has been progress in the semantics of procedural languages with local variables (e.g., see <ref> [OT95, PS93] </ref>). Some of the insights gained in that area should be applicable to reasoning about objects. 6 Past and future work As we mentioned in the introduction, there has been much research on specification and verification for object-oriented languages.
Reference: [PPS96] <author> S. Peyton Jones, W. Partain, and A. Santos. Let-floating: </author> <title> moving bindings to give faster programs. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming (ICFP '96), </booktitle> <pages> pages 1-12, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: A reasonable diagnosis is that the judgment E `` a : A :: T does not allow sufficient interaction between A and T (particularly in the rule for let). One remedy is transforming b 1 into b 2 (by let-floating <ref> [PPS96] </ref>) or into b 3 (by adding an auxiliary field). We have considered other remedies, but do not yet know which is the "right" one. A deeper difficulty arises because the verification rules rely on a "global store" model.
Reference: [PS93] <author> A.M. Pitts and I.D.B. Stark. </author> <title> Observable properties of higher order functions that dynamically create local names, or: </title> <booktitle> What's new? In Mathematical Foundations of Computer Science, Proc. 18th Int. Symp., Gdansk, 1993, volume 711 of Lecture Notes in Computer Science, </booktitle> <pages> pages 122-141. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: We can prove this, but only by adopting a strong specification for y, for example requiring that y:m not modify the field f of any object. Recently, there has been progress in the semantics of procedural languages with local variables (e.g., see <ref> [OT95, PS93] </ref>). Some of the insights gained in that area should be applicable to reasoning about objects. 6 Past and future work As we mentioned in the introduction, there has been much research on specification and verification for object-oriented languages.
Reference: [SG95] <author> R. Stata and J.V. Guttag. </author> <title> Modular reasoning in the presence of subclass-ing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(10) </volume> <pages> 200-214, </pages> <month> October </month> <year> 1995. </year> <booktitle> OOPSLA '95 conference proceedings. </booktitle>
Reference-contexts: Lano and Haughton [LH92], Leavens [Lea89, Lea91], and Liskov and Wing [LW94] all studied notions of subtyping and of refinement of specifications (similar to our subspecification relation, though in some respects more sophisticated). Stata and Guttag <ref> [SG95] </ref> studied the notion of subclassing, and presented a pre-formal approach for reasoning about inheritance. Lano and Haughton [LH94] have collected other research on object-oriented specification. In some existing formalisms (e.g., Leavens'), specifications can be written in terms of abstract variables.
Reference: [SSC95] <author> A. Sernadas, C. Sernadas, and J.F. Costa. </author> <title> Object specification logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 5(5) </volume> <pages> 603-630, </pages> <year> 1995. </year>
Reference-contexts: The words "object" and "logic" are frequently used together in the literature, but with many different meanings (e.g., <ref> [SSC95] </ref>). Our work is most similar to that of Leavens [Lea89], who gave verification rules for a small language with objects; however, those rules are limited in that they apply only to programs without side-effects and aliasing.
Reference: [Tof90] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89(1) </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: As another corollary, we obtain a soundness theorem for the type system of section 2.2. Therefore, as might be expected, our proofs are no less intricate than typical soundness proofs for type systems of imperative languages. In fact, they generalize techniques developed for proofs of type soundness <ref> [Har94, Ler92, Tof90, WF94] </ref>. New ingredients are required because specifications, unlike ordinary (non-dependent) types, may contain occurrences of program variables. 5.3 Completeness issues While we have soundness, we do not have its converse, completeness. Unfortunately, our rules do not seem to be complete even for well-typed programs.
Reference: [WF94] <author> A.K. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: As another corollary, we obtain a soundness theorem for the type system of section 2.2. Therefore, as might be expected, our proofs are no less intricate than typical soundness proofs for type systems of imperative languages. In fact, they generalize techniques developed for proofs of type soundness <ref> [Har94, Ler92, Tof90, WF94] </ref>. New ingredients are required because specifications, unlike ordinary (non-dependent) types, may contain occurrences of program variables. 5.3 Completeness issues While we have soundness, we do not have its converse, completeness. Unfortunately, our rules do not seem to be complete even for well-typed programs.
Reference: [YT87] <editor> A. Yonezawa and M. Tokoro, editors. </editor> <booktitle> Object-oriented Concurrent Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: At the type level, the type of an object lists the types of its fields and the result types of its methods; a subtyping relation supports subsumption and inheritance. We mostly ignore "advanced" issues, like concurrency, but some of them have been considered in the literature (e.g., see <ref> [Jon92, YT87] </ref>). Much like Hoare logic, our logic includes one rule for reasoning about pre-and postconditions for each of the constructs of the programming language. In order to formulate these rules, we introduce object specifications.
References-found: 24

