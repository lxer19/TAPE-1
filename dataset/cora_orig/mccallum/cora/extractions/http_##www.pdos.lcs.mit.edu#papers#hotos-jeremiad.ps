URL: http://www.pdos.lcs.mit.edu/papers/hotos-jeremiad.ps
Refering-URL: http://www.pdos.lcs.mit.edu/PDOS-papers.html
Root-URL: 
Email: fengler, kaashoekg@lcs.mit.edu  
Title: Exterminate All Operating System Abstractions  
Author: Dawson R. Engler M. Frans Kaashoek 
Address: 545 Technology Square Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science  
Abstract: The defining tragedy of the operating systems community has been the definition of an operating system as software that both multiplexes and abstracts physical resources. The view that the OS should abstract the hardware is based on the assumption that it is possible both to define abstractions that are appropriate for all areas and to implement them to perform efficiently in all situations. We believe that the fallacy of this quixotic goal is self-evident, and that the operating system problems of the last two decades (poor performance, poor reliability, poor adaptability, and inflexibility) can be traced back to it. The solution we propose is simple: complete elimination of operating system abstractions by lowering the operating system interface to the hardware level. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proc. Thirteenth Symposium on Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Applications that do not need this feature pay unnecessary overhead <ref> [1, 18] </ref>. In the case of garbage collectors or database systems this cost can amount to an order of magnitude. Additionally, simply using a given feature is costly, since time must be spent selecting from a myriad of options [18].
Reference: [2] <author> A.W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on ASPLOS, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine.
Reference: [3] <author> K. Bala, M.F. Kaashoek, and W.E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 243-253, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Of course, all of these operations can be sped up by downloading application code into the kernel [4, 9] or using a "software TLB" <ref> [14, 3] </ref> to cache translations. These implementation techniques aside, the full functionality provided by the underlying hardware should be exposed (e.g., reference bits, the ability to disable caching on a page-basis, the ability to use different pagesizes, etc.).
Reference: [4] <author> B.N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. Sirer. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> TR 94-03-03, </type> <institution> Univ. of Washington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24]. <p> 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine. <p> Exception propagation is done in a direct manner by (perhaps) saving a few scratch registers in some agreed-upon location in application-space and then jumping to an application-specified PC-address [24]. Of course, all of these operations can be sped up by downloading application code into the kernel <ref> [4, 9] </ref> or using a "software TLB" [14, 3] to cache translations. These implementation techniques aside, the full functionality provided by the underlying hardware should be exposed (e.g., reference bits, the ability to disable caching on a page-basis, the ability to use different pagesizes, etc.). <p> In contrast, our approach exports hardware resources rather than emulates them, allowing an efficient and fast implementation. OS extensibility has a long history [15, 20]. Current attempts include SPIN <ref> [4] </ref>, Bridge [17], and Vino [22]. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation [25], are also applicable to exokernels.
Reference: [5] <author> B.N. Bershad, D. Lee, T.H. Romer, and J.B. Chen. </author> <title> Avoiding conflict misses dynamically in large direct-mapped caches. </title> <booktitle> In ASPLOS-VI, </booktitle> <year> 1994. </year>
Reference-contexts: The simplest bootstrapping mechanism is to provide a small number of "guaranteed mappings" that can be used to map the page-table and exception handling code. Physical memory allocation should support requests for a given page number (enabling such techniques as "page-coloring" for improved caching <ref> [5] </ref>). Privileged instructions (e.g., flush, probe, and modify instructions) can be wrapped in systems calls, and those that write to privileged state (e.g., TLB write instructions) are associated with access checks.
Reference: [6] <author> B.N. Bershad, D.D. Redell, and J.R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Proc. of the Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-237, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Placing context-switching under application control (through the application-defined prologue and epilogue code) enables techniques such as moving the program counter out of critical sections at context-switch time <ref> [6] </ref>. IPC The basic functionality required by IPC is simply the transfer of a PC from one protection domain to an agreed-upon value in another, with the donation of the current time-slice, installation of the called domain's exception context, and an indication of which process initiated the call.
Reference: [7] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the Sixth SIGOPS European Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24]. <p> With micro-kernels, applications can have even fewer options than with monolithic ones. Two current OS research efforts, the Cache Kernel <ref> [7] </ref> and Aegis [9, 10], adhere closely to our precepts for a model operating system. Further experience is needed to see if a low-level kernel interface is indeed the panacea that can cure current operating system troubles.
Reference: [8] <author> R. J. Creasy. </author> <title> The origin of the VM/370 timesharing system. </title> <journal> IBM J. Research and Development, </journal> <volume> 25(5) </volume> <pages> 483-490, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: In addition, the exokernel attempts to define no OS abstractions, while in the open operating systems the file system and communications are standardized. Despite these differences, one can view the exokernel architecture as an instance of an open operating system. The interface provided by the VM/370 OS <ref> [8] </ref> is very similar to what would be provided by our ideal OS: namely, the raw hardware. However, the important difference is that VM/370 provides this interface by virtualizing the entire base-machine.
Reference: [9] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole. </author> <title> The operating system kernel as a secure programmable machine. </title> <booktitle> In Proceedings of the Sixth SIGOPS Euro-pean Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24]. <p> Exception propagation is done in a direct manner by (perhaps) saving a few scratch registers in some agreed-upon location in application-space and then jumping to an application-specified PC-address [24]. Of course, all of these operations can be sped up by downloading application code into the kernel <ref> [4, 9] </ref> or using a "software TLB" [14, 3] to cache translations. These implementation techniques aside, the full functionality provided by the underlying hardware should be exposed (e.g., reference bits, the ability to disable caching on a page-basis, the ability to use different pagesizes, etc.). <p> With micro-kernels, applications can have even fewer options than with monolithic ones. Two current OS research efforts, the Cache Kernel [7] and Aegis <ref> [9, 10] </ref>, adhere closely to our precepts for a model operating system. Further experience is needed to see if a low-level kernel interface is indeed the panacea that can cure current operating system troubles.
Reference: [10] <author> Dawson R. Engler. </author> <title> The design and implementation of a prototype exokernel operating system. </title> <type> Master's thesis, </type> <institution> MIT, 545 Technology Square, </institution> <address> Boston MA 02139, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: The bare minimum is much removed from the policy-laden, overly general, and restrictive implementations surrounding us today. (A more complete discussion and evaluation of the ex-okernel methodology and a prototype exokernel can be found in Engler <ref> [10] </ref>; our prototype exokernel performs 10-100 times faster than a mature monolithic system in operations such as as IPC, exception forwarding, and virtual memory manipulations.) 4 Discussion We discuss how our proposed structure solves the traditional problems of reliability, efficiency, and extensibility; these points have at their core the simple principle <p> With micro-kernels, applications can have even fewer options than with monolithic ones. Two current OS research efforts, the Cache Kernel [7] and Aegis <ref> [9, 10] </ref>, adhere closely to our precepts for a model operating system. Further experience is needed to see if a low-level kernel interface is indeed the panacea that can cure current operating system troubles.
Reference: [11] <author> Per Brinch Hansen. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-241, </pages> <month> April </month> <year> 1970. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24].
Reference: [12] <author> J.H. Hartman, A.B. Montz, David Mosberger, S.W. O'Malley, L.L. Peterson, and T.A. Proebsting. </author> <title> Scout: A communication-oriented operating system. </title> <type> Technical Report TR 94-20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements).
Reference: [13] <author> K. Harty and D.R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the Fifth International Conference on ASPLOS, </booktitle> <pages> pages 187-199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine.
Reference: [14] <author> J. Huck and J. Hays. </author> <title> Architectural support for translation table management in large address space machines. </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <year> 1992. </year>
Reference-contexts: Of course, all of these operations can be sped up by downloading application code into the kernel [4, 9] or using a "software TLB" <ref> [14, 3] </ref> to cache translations. These implementation techniques aside, the full functionality provided by the underlying hardware should be exposed (e.g., reference bits, the ability to disable caching on a page-basis, the ability to use different pagesizes, etc.).
Reference: [15] <author> B.W. Lampson. </author> <title> On reliable and extendable operating systems. State of the Art Report, </title> <type> 1, </type> <year> 1971. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24]. <p> Since this machine can be quite complicated and expensive to emulate faithfully, virtualization can result in a complex and inefficient OS. In contrast, our approach exports hardware resources rather than emulates them, allowing an efficient and fast implementation. OS extensibility has a long history <ref> [15, 20] </ref>. Current attempts include SPIN [4], Bridge [17], and Vino [22]. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation [25], are also applicable to exokernels. <p> As a result, many people have been led to the conclusion that some radical changes must be made, both in the way we think about the functions of operating systems and in the way they are implemented <ref> [15] </ref>. We believe that these problems can be solved by lowering the interface to the hardware that is enforced by the kernel: namely, by exporting physical resources to applications directly. Management and abstraction of these resources can then be specialized for simplicity, efficiency, and appropriateness.
Reference: [16] <author> B.W. Lampson and R.F. Sproull. </author> <title> An open operating system for a single-user machine. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 98-105, </pages> <year> 1979. </year>
Reference-contexts: Further experience is needed to see if a low-level kernel interface is indeed the panacea that can cure current operating system troubles. The open operating system for a single-user machine is motived by similar observations as the ones that motivate the exokernel <ref> [16] </ref>. However, the approach taken to extensibility taken is different. The exokernel's main task is secure multiplexing, while in the open operating system protection is not an issue at all, since it relies on the fact it is designed for a single-user machine.
Reference: [17] <author> Steven Lucco. </author> <title> High-performance microkernel systems (abstract). </title> <booktitle> In Proc. of the first Symp. on OSDI, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: In contrast, our approach exports hardware resources rather than emulates them, allowing an efficient and fast implementation. OS extensibility has a long history [15, 20]. Current attempts include SPIN [4], Bridge <ref> [17] </ref>, and Vino [22]. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation [25], are also applicable to exokernels.
Reference: [18] <author> H. Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate <ref> [4, 7, 9, 11, 15, 18] </ref>. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems [2, 4, 12, 13, 18, 23, 24]. <p> 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> Applications that do not need this feature pay unnecessary overhead <ref> [1, 18] </ref>. In the case of garbage collectors or database systems this cost can amount to an order of magnitude. Additionally, simply using a given feature is costly, since time must be spent selecting from a myriad of options [18]. <p> Applications that do not need this feature pay unnecessary overhead [1, 18]. In the case of garbage collectors or database systems this cost can amount to an order of magnitude. Additionally, simply using a given feature is costly, since time must be spent selecting from a myriad of options <ref> [18] </ref>. Furthermore, the mere existence of OS abstractions consumes significant amounts of main memory, cache space, TLB space, and cycles, which could be used by applications to perform useful work. <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine.
Reference: [19] <author> J. K. Ousterhout. </author> <title> Why aren't operating systems getting faster as fast as hardware? In Proc. </title> <booktitle> Summer Usenix, </booktitle> <pages> pages 247-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, a client that trusts a server may allow the server to save and restore the registers it needs, instead of saving the entire register file on every IPC. Since the machine state of current RISC machines is growing larger <ref> [19] </ref>, this can be crucial for good performance. This is far from a complete enumeration of all system objects (for example, we neglect disks and devices), but should give a feel for what level of functionality the OS is required to provide.
Reference: [20] <author> D.D. Redell, Y.K. Dalal, T.R. Horsley, H.C. Lauer, W.C. Lynch, P.R. McJones, H.G. Murray, </author> <title> and S.C. Purcell. Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Since this machine can be quite complicated and expensive to emulate faithfully, virtualization can result in a complex and inefficient OS. In contrast, our approach exports hardware resources rather than emulates them, allowing an efficient and fast implementation. OS extensibility has a long history <ref> [15, 20] </ref>. Current attempts include SPIN [4], Bridge [17], and Vino [22]. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation [25], are also applicable to exokernels.
Reference: [21] <author> J.H. Saltzer, D.P. Reed, and D.D. Clark. </author> <title> End-to-end arguments in system design. </title> <booktitle> Proc. of the Fifth SOSP, </booktitle> <pages> pages 509-512, </pages> <year> 1981. </year>
Reference-contexts: The thesis of this position paper is that the operating system should not abstract physical resources. What the OS should do is what no other piece of software can do: safely multiplex physical resources. The motivation for this decision can be placed in the context of the "end-to-end" argument <ref> [21] </ref>: OS abstractions are reduntant or of little value when compared to the cost of providing them. We explore these issues more thoroughly below: Poor reliability Abstracting resources (e.g., providing a full-featured virtual memory system with copy-on-write, memory-mapped I/O and other treats) requires a large amount of complex, multi-threaded code.
Reference: [22] <editor> Margo Seltzer et al. </editor> <title> An introduction to the architecture of the VINO kernel, </title> <month> November </month> <year> 1994. </year>
Reference-contexts: In contrast, our approach exports hardware resources rather than emulates them, allowing an efficient and fast implementation. OS extensibility has a long history [15, 20]. Current attempts include SPIN [4], Bridge [17], and Vino <ref> [22] </ref>. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation [25], are also applicable to exokernels.
Reference: [23] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> CACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine.
Reference: [24] <author> C. A. Thekkath and Henry M. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In Sixth Conf. on ASPLOS, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Throughout the history of computer science there has been a fairly constant opinion that "current" operating systems are inadequate [4, 7, 9, 11, 15, 18]. The literature is rife with specific examples that describe the cost of the inappropriate, inefficient abstractions peddled by operating systems <ref> [2, 4, 12, 13, 18, 23, 24] </ref>. This situation has persisted for the last three decades, and has survived numerous assaults (object-oriented operating systems and micro-kernels are two of the more popular movements). <p> For example, once the application has no access to the raw disk interface, database records must be emulated on top of files. The list of such examples is painfully long and continues to grow <ref> [2, 4, 13, 18, 23, 24] </ref>. In short, operating systems are complex, fragile, inflexible, and slow, because they have dabbled in the practice of providing a general purpose virtual machine. <p> Exception propagation is done in a direct manner by (perhaps) saving a few scratch registers in some agreed-upon location in application-space and then jumping to an application-specified PC-address <ref> [24] </ref>. Of course, all of these operations can be sped up by downloading application code into the kernel [4, 9] or using a "software TLB" [14, 3] to cache translations.
Reference: [25] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proc. of Fourteenth SOSP, </booktitle> <pages> pages 203-216, </pages> <year> 1993. </year>
Reference-contexts: OS extensibility has a long history [15, 20]. Current attempts include SPIN [4], Bridge [17], and Vino [22]. Some of the techniques used in these systems, such as type-safe languages and software fault-isolation <ref> [25] </ref>, are also applicable to exokernels.
References-found: 25

