URL: http://www-ccs.cs.umass.edu/db/publications/ICDE97.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/publications/
Root-URL: 
Email: cris, krithi@cs.umass.edu  
Title: Delegation: Efficiently Rewriting History  
Author: Cris Pedregal Martin and Krithi Ramamritham 
Address: Amherst, Mass. 01003-4610  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: Transaction delegation, as introduced in ACTA, allows a transaction to transfer responsibility for the operations that it has performed on an object to another transaction. Delegation can be used to broaden the visibility of the delegatee, and to tailor the recovery properties of a transaction model. Delegation has been shown to be useful in synthesizing Advanced Transaction Models. With an efficient implementation of delegation it becomes practicable to realize various Advanced Transaction Models whose requirements are specified at a high level language instead of the current expensive practice of building them from scratch. In this paper we identify the issues in efficiently supporting delegation and hence advanced transaction models, and illustrate this with our solution in ARIES, an industrial-quality system that uses UNDO/REDO recovery. Since delegation is tantamount to rewriting history, a nave implementation can entail frequent, costly log accesses, and can result in complicated recovery protocols. Our algorithm achieves the effect of rewriting history without rewriting the log, resulting in an implementation that realizes the semantics of delegation at minimal additional overhead and incurs no overhead when delegation is not used. Our work indicates that it is feasible to build efficient and robust, general-purpose machinery for Advanced Transaction Models. It also leads toward making recovery a first-class concept within Advanced Transaction Models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Barga and C. Pu. </author> <title> A practical and modular implementation of extended transaction models. </title> <booktitle> In Proc. of the 21st Int'l Conf. on Very Large Data Bases, </booktitle> <address> Zurich, </address> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: This may allow for initial gains in performance, but we believe that the use of language primitives is a richer and more flexible approach. Barga and Pu <ref> [1] </ref> explore another modular approach, based on metaobject protocols [11], and incorporate some elements of the TSME approach and some of our language-based approach. Also related is the ConTract model [20], where a set of steps define individual transactions; a script is provided to control the execution of these transactions.
Reference: [2] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concur-rency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1987. </year>
Reference-contexts: For that we use the Transaction List and expand each transaction's Object List found in conventional Database Systems; we also add a delegate type log record. Tr List. The Transaction List <ref> [2, 10, 13] </ref> contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser. 6 Ob List.
Reference: [3] <author> A. Biliris, S. Dar, N. Gehani, H. V. Jagadish, and K. Ra-mamritham. </author> <title> ASSET: A system for supporting extended transactions. </title> <booktitle> In Proc. of the ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Minneapolis, Minn., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: A first step was ACTA [6], that identified, in a formal framework, the essential components of ATMs. In more operational terms, ASSET <ref> [3] </ref> provided a set of new language primitives that enable the realization of various ATMs in an object-oriented database setting. <p> Examples of ATMs that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions [6, 8]. Biliris et al. <ref> [3] </ref> gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a powerful primitive for synthesizing ATMs. Our work builds on the formal foundation provided by ACTA [6, 5], and the primitives introduced in ASSET <ref> [3] </ref>. With delegation (and the other two ASSET primitives, permit and form-dependency [3]) we believe we can offer the flexibility to synthesize a wide range of ATMs. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a powerful primitive for synthesizing ATMs. Our work builds on the formal foundation provided by ACTA [6, 5], and the primitives introduced in ASSET <ref> [3] </ref>. With delegation (and the other two ASSET primitives, permit and form-dependency [3]) we believe we can offer the flexibility to synthesize a wide range of ATMs. Given the efficient implementation of delegation presented in this paper, we believe we can achieve this flexibility at a performance comparable to that of tailor-made implementations.
Reference: [4] <author> A. Biliris and E. Panagos. </author> <title> EOS User's Guide. </title> <institution> AT&T Bell Labs, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: For lack of space we present here only our ARIES [13] -based solution. In a longer version of this paper [15] we demonstrate the correctness of the implementation and also discuss how to implement delegation on EOS <ref> [4] </ref>. Our additions allow the efficient Rewriting of History, so we call our protocol ARIES/RH. By providing delegation, we add substantial semantic power to a conventional Transaction Management System (TMS), allowing it to capture various ATMs.
Reference: [5] <author> P. K. Chrysanthis and K. Ramamritham. </author> <title> Delegation in ACTA as a means to control sharing in extended transactions. </title> <journal> IEEE Data Eng. Bull., </journal> <volume> 16(2) </volume> <pages> 16-19, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Other examples can be found in <ref> [6, 5] </ref>. Inheritance in Nested Transactions [14] is an instance of delegation. It is achieved through the delegation of all the changes the child transaction t c is responsible for to its parent t p when t c commits. <p> Thus, although efficient, these systems are limited in the models they can synthesize. Delegation, by allowing changes in the visibility and recovery properties of transactions, is a powerful primitive for synthesizing ATMs. Our work builds on the formal foundation provided by ACTA <ref> [6, 5] </ref>, and the primitives introduced in ASSET [3]. With delegation (and the other two ASSET primitives, permit and form-dependency [3]) we believe we can offer the flexibility to synthesize a wide range of ATMs.
Reference: [6] <author> P. K. Chrysantis and K. Ramamritham. </author> <title> Synthesis of extended transaction models using ACTA. </title> <journal> ACM Trans. on Database Systems, </journal> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Our strategy has been to work from first principles, first identifying the basic elements that give rise to different models and showing how to realize various ATMs using these elements, and then proposing mechanisms for implementing these elements. A first step was ACTA <ref> [6] </ref>, that identified, in a formal framework, the essential components of ATMs. In more operational terms, ASSET [3] provided a set of new language primitives that enable the realization of various ATMs in an object-oriented database setting. <p> Examples of ATMs that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions <ref> [6, 8] </ref>. Biliris et al. [3] gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> Other examples can be found in <ref> [6, 5] </ref>. Inheritance in Nested Transactions [14] is an instance of delegation. It is achieved through the delegation of all the changes the child transaction t c is responsible for to its parent t p when t c commits. <p> Thus, although efficient, these systems are limited in the models they can synthesize. Delegation, by allowing changes in the visibility and recovery properties of transactions, is a powerful primitive for synthesizing ATMs. Our work builds on the formal foundation provided by ACTA <ref> [6, 5] </ref>, and the primitives introduced in ASSET [3]. With delegation (and the other two ASSET primitives, permit and form-dependency [3]) we believe we can offer the flexibility to synthesize a wide range of ATMs.
Reference: [7] <editor> A. K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, Calif., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction The transaction model adopted in traditional database systems has proven inadequate for novel applications of growing importance, such as those that involve reactive (endless), open-ended (long-lived), and collaborative (interactive) activities. Various Advanced Transaction Models (ATMs) have been proposed <ref> [7, 17] </ref>, each custom built for the application it addresses; alas, no one extension is of universal applicability. To address this problem, we have been investigating how to create general-purpose and robust support for the specification and implementation of diverse ATMs.
Reference: [8] <author> N. Gehani, K. Ramamritham, and O. Shmueli. </author> <title> Accessing extra database information: Concurrency control and correctness. </title> <type> Technical Report 93-081, </type> <institution> University of Massachusetts, </institution> <address> Amherst, Mass., </address> <year> 1993. </year>
Reference-contexts: Examples of ATMs that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions <ref> [6, 8] </ref>. Biliris et al. [3] gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> The 2 Extra data: information accessed by transactions that is not part of the database schema; for example, the log, the system clock, wait-for graph. Gehani et al. <ref> [8] </ref> discuss the issues of correctness with extra data. 3 It is easier to tolerate unusual log manipulations during recovery than during normal processing. 4 Some variants of ARIES merge the two forward passes into one, thus we also use only one forward pass. (backward) Undo pass rolls back all the
Reference: [9] <author> D. Georgakopoulos, M. Hornick, P. Krychniak, and F. Manola. </author> <title> Specification and management of extended transactions in a programmable transaction environment. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Eng., </booktitle> <pages> page 462, </pages> <address> Houston, Tex., </address> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Thus our extension of ARIES, while including it, goes beyond the functionality provided in ARIES/NT, and allows the efficient synthesis of arbitrary ATMs, not just nested transactions. Work related to ours includes the Transaction Specification and Management Environment (TSME, <ref> [9] </ref>), in which specifications are mapped to certain configurations of pre-built components, so it approaches the problem at a coarser grain. This may allow for initial gains in performance, but we believe that the use of language primitives is a richer and more flexible approach.
Reference: [10] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, Calif., </address> <year> 1993. </year>
Reference-contexts: For that we use the Transaction List and expand each transaction's Object List found in conventional Database Systems; we also add a delegate type log record. Tr List. The Transaction List <ref> [2, 10, 13] </ref> contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser. 6 Ob List. <p> WRITE ABORT RECORD. Write abort log record to log. 3. FLUSH LOG. Flush log up to abort record. We process other transactional events as usual <ref> [10, 13] </ref>. Note: The preceding algorithm assumes that delegation is used often, but the overhead for transactions that do not use delegation can be reduced to a minimum with the following optimization.
Reference: [11] <author> G. Kiczales, J. des Rivieres, and D. G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: This may allow for initial gains in performance, but we believe that the use of language primitives is a richer and more flexible approach. Barga and Pu [1] explore another modular approach, based on metaobject protocols <ref> [11] </ref>, and incorporate some elements of the TSME approach and some of our language-based approach. Also related is the ConTract model [20], where a set of steps define individual transactions; a script is provided to control the execution of these transactions.
Reference: [12] <author> B. Liskov and R. W. Scheifler. </author> <title> The Argus Language and System. </title> <booktitle> In Lecture Notes on Computer Science Springer Verlag, volume 190, </booktitle> <address> Berlin, </address> <year> 1982. </year>
Reference-contexts: Otherwise, we just add or remove scopes from the Cluster and the LsrScopes sets. In summary, ARIES/RH adds only minimal overhead to ARIES to support delegation. 5 Related Work Previous work has produced many Advanced Transaction Models (ATMs), but each has its own tailor-made implementation. For instance, both Argus <ref> [12] </ref> and Camelot [19] each supports its ATM (variants of nested transactions). Split-Transactions [16] allows the commitment of partial results but in a way that is less general than delegation (see section 2.2). Thus, although efficient, these systems are limited in the models they can synthesize.
Reference: [13] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 17(1) </volume> <pages> 94-162, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: To further the goal of providing general purpose machinery to support the specification and implementation of arbitrary ATMs, we have developed efficient implementations of delegation on two log-based recovery systems. For lack of space we present here only our ARIES <ref> [13] </ref> -based solution. In a longer version of this paper [15] we demonstrate the correctness of the implementation and also discuss how to implement delegation on EOS [4]. Our additions allow the efficient Rewriting of History, so we call our protocol ARIES/RH. <p> For that we use the Transaction List and expand each transaction's Object List found in conventional Database Systems; we also add a delegate type log record. Tr List. The Transaction List <ref> [2, 10, 13] </ref> contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser. 6 Ob List. <p> WRITE ABORT RECORD. Write abort log record to log. 3. FLUSH LOG. Flush log up to abort record. We process other transactional events as usual <ref> [10, 13] </ref>. Note: The preceding algorithm assumes that delegation is used often, but the overhead for transactions that do not use delegation can be reduced to a minimum with the following optimization. <p> Given the efficient implementation of delegation presented in this paper, we believe we can achieve this flexibility at a performance comparable to that of tailor-made implementations. Our research also builds on the substantial work in ARIES <ref> [13] </ref>, in particular ARIES/NT [18], an extension of ARIES that supports nested transactions [14]. Rewriting history is a natural extension of the repeating history paradigm of ARIES, and it has served as a powerful abstraction to guide our efforts.
Reference: [14] <author> J. E. B. Moss. </author> <title> Nested Transactions: An approach to reliable distributed computing. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, Mass., </address> <month> Apr. </month> <year> 1981. </year>
Reference-contexts: Other examples can be found in [6, 5]. Inheritance in Nested Transactions <ref> [14] </ref> is an instance of delegation. It is achieved through the delegation of all the changes the child transaction t c is responsible for to its parent t p when t c commits. A transaction can delegate at any point during its execution, not just when it aborts or commits. <p> Given the efficient implementation of delegation presented in this paper, we believe we can achieve this flexibility at a performance comparable to that of tailor-made implementations. Our research also builds on the substantial work in ARIES [13], in particular ARIES/NT [18], an extension of ARIES that supports nested transactions <ref> [14] </ref>. Rewriting history is a natural extension of the repeating history paradigm of ARIES, and it has served as a powerful abstraction to guide our efforts.
Reference: [15] <author> C. Pedregal Martin and K. Ramamritham. </author> <title> Delegation: Efficiently rewriting history. </title> <type> Technical Report 95-090, </type> <institution> University of Massachusetts, </institution> <address> Amherst, Mass., </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: For lack of space we present here only our ARIES [13] -based solution. In a longer version of this paper <ref> [15] </ref> we demonstrate the correctness of the implementation and also discuss how to implement delegation on EOS [4]. Our additions allow the efficient Rewriting of History, so we call our protocol ARIES/RH. <p> For details see <ref> [15] </ref>. 3.6 Crash Recovery After a crash, the transaction system must recover to a consistent state, restoring the state from a checkpoint (retrieved from stable storage), and using the log (also from stable storage) to reproduce the events after the checkpoint was taken. <p> With delegation, we must also ensure that operations ultimately delegated to loser transactions will be aborted, and operations ultimately delegated to winner transactions will be committed. For lack of space we omit the proof here, which can be found in our technical report <ref> [15] </ref>. The rest of this section argues that ARIES/RH is efficient. * No delegation: negligible overhead. <p> ATMs: * By casting delegation in terms of rewriting history, we were able to express the issues of delegation in terms amenable to the specification of a recovery algorithm. * We showed how to achieve RH in the context of a practical system (ARIES) and we have also discussed elsewhere <ref> [15] </ref> how to apply it to another (EOS), suggesting the practical implementability of delegation. As indicated in section 4, the cost of delegation in ARIES/RH is very low, and its support incurs no cost at all when delegation is not used. We have also demonstrated (elsewhere, [15]) the correctness of our <p> have also discussed elsewhere <ref> [15] </ref> how to apply it to another (EOS), suggesting the practical implementability of delegation. As indicated in section 4, the cost of delegation in ARIES/RH is very low, and its support incurs no cost at all when delegation is not used. We have also demonstrated (elsewhere, [15]) the correctness of our implementation, showing that it satisfies the desired transaction properties in the presence of delegation. We are exploring the issues of delegating components of complex objects. We will continue investigating the broader issues of providing robust, efficient, and flexible transaction processing.
Reference: [16] <author> C. Pu, G. Kaiser, and N. Hutchinson. </author> <title> Split-transactions for open-ended activities. </title> <booktitle> In Proc. of the 14th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 26-37, </pages> <address> Los Angeles, Calif., </address> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: It is achieved through the delegation of all the changes the child transaction t c is responsible for to its parent t p when t c commits. A transaction can delegate at any point during its execution, not just when it aborts or commits. For instance, in Split Transactions <ref> [16] </ref>, a transaction t 1 may split into two transactions, t 1 and t 2 , at any point during its execution. <p> In summary, ARIES/RH adds only minimal overhead to ARIES to support delegation. 5 Related Work Previous work has produced many Advanced Transaction Models (ATMs), but each has its own tailor-made implementation. For instance, both Argus [12] and Camelot [19] each supports its ATM (variants of nested transactions). Split-Transactions <ref> [16] </ref> allows the commitment of partial results but in a way that is less general than delegation (see section 2.2). Thus, although efficient, these systems are limited in the models they can synthesize.
Reference: [17] <author> Krithi Ramamritham and Panos K. </author> <title> Chrysanthis Advances in Concurrency Control and Transaction Processing. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> Calif., </address> <year> 1996. </year>
Reference-contexts: 1 Introduction The transaction model adopted in traditional database systems has proven inadequate for novel applications of growing importance, such as those that involve reactive (endless), open-ended (long-lived), and collaborative (interactive) activities. Various Advanced Transaction Models (ATMs) have been proposed <ref> [7, 17] </ref>, each custom built for the application it addresses; alas, no one extension is of universal applicability. To address this problem, we have been investigating how to create general-purpose and robust support for the specification and implementation of diverse ATMs.
Reference: [18] <author> K. Rothermel and C. Mohan. ARIES/NT: </author> <title> A recovery method based on write-ahead logging for nested transactions. </title> <booktitle> In Proc. of the 15th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Amsterdam, </address> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Cluster -( , , left, )- (4) processed record LOG [K], next (left) K K 1 (end ff) until K &lt; begCluster finished this cluster (sweep backwards) (fi) find next cluster of scopes K max -right j ( , , , right) 2 LsrScopes RecoveryComplete similar to that of ARIES/NT <ref> [18] </ref>, writing CLRs as we undo the updates. 4 ARIES/RH is efficient ARIES/RH, presented in sections 3.5 and 3.6, is correct and efficient. <p> Given the efficient implementation of delegation presented in this paper, we believe we can achieve this flexibility at a performance comparable to that of tailor-made implementations. Our research also builds on the substantial work in ARIES [13], in particular ARIES/NT <ref> [18] </ref>, an extension of ARIES that supports nested transactions [14]. Rewriting history is a natural extension of the repeating history paradigm of ARIES, and it has served as a powerful abstraction to guide our efforts.
Reference: [19] <author> A. Z. Spector, R. Pausch, and G. Bruell. Camelot: </author> <title> A flexible, distributed transaction processing system. </title> <booktitle> In Proc. of Compcon, </booktitle> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: In summary, ARIES/RH adds only minimal overhead to ARIES to support delegation. 5 Related Work Previous work has produced many Advanced Transaction Models (ATMs), but each has its own tailor-made implementation. For instance, both Argus [12] and Camelot <ref> [19] </ref> each supports its ATM (variants of nested transactions). Split-Transactions [16] allows the commitment of partial results but in a way that is less general than delegation (see section 2.2). Thus, although efficient, these systems are limited in the models they can synthesize.
Reference: [20] <author> H. Wachter and A. Reuter. </author> <title> The ConTract Model. </title> <booktitle> In Elma-garmid [7], </booktitle> <year> 1991. </year>
Reference-contexts: Barga and Pu [1] explore another modular approach, based on metaobject protocols [11], and incorporate some elements of the TSME approach and some of our language-based approach. Also related is the ConTract model <ref> [20] </ref>, where a set of steps define individual transactions; a script is provided to control the execution of these transactions.
References-found: 20

