URL: ftp://ftp.research.microsoft.com/users/palarson/cascon95_asl.ps
Refering-URL: http://www.research.microsoft.com/~palarson/publications.htm
Root-URL: http://www.research.microsoft.com
Email: E-mail: fgkattalu,jslonim,palarsong@bluebox.uwaterloo.ca  
Title: Concurrency Control with Lock Preemption and Restoration  
Author: Gopi K. Attaluri Jacob Slonim Per -Ake Larson 
Keyword: Transaction management, Concurrency control, Locking, Non-traditional database applications.  
Note: Head  
Address: Waterloo, Ontario, Canada N2L 3V5  
Affiliation: Department of Computer Science University of Waterloo  of Research, Centre for Advanced Studies, IBM Toronto Lab, Toronto.  
Abstract: Lock preemption is a common problem with two-phase locking. While a transaction is still active, its locks may be preempted to avoid a deadlock or to satisfy the lock request of a higher-priority transaction. In general, the victim of preemption is aborted. This paper suggests that the victim could be continued and its work up to preemption could be saved if the preempted lock is restored on its availability. Object-oriented database management systems based on client-server architecture, multidatabase systems, and relational database management systems using page-locks are a few cases where lock restoration can be beneficial. Lock restoration works well when the granularity of locking is larger than the granularity of database operations, namely, reads and writes. This paper proposes a correctness criteria called value-serializability for isolation in histories generated by a lock restoring concurrency control scheme. A value-serializable history is shown to have the same behavior (in terms of values read and written) as a conflict-serializable history. The paper describes concurrency control scheme based on lock restoration, and proves that the scheme generates value-serializable histories in general and conflict-serializable histories for a certain class of preempted locks. Some important advantages and disadvantages of lock restoration are listed at the end. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ahmed, A. Wong, D. Sriram, and R. Logcher. </author> <title> Object-oriented database management systems for engineering: A comparison. </title> <journal> Journal of Object-oriented programming, </journal> <volume> 5(3) </volume> <pages> 27-44, </pages> <year> 1992. </year>
Reference-contexts: There are several reasons for preemption. Locks of one or more transactions may be preempted to break a deadlock of blocked lock requests. When a transaction crosses a timeout period designed to detect deadlocks or communication failures, its locks may be preempted. In a prioritized system (for example, VERSANT <ref> [1] </ref>), a low-priority lock may be preempted to satisfy a conflicting high-priority lock request. Finally, locks of unprepared, non-terminated transactions are preempted at site and system failures.
Reference: [2] <author> G. K. Attaluri, D. P. Bradshaw, N. Coburn, P. A. Larson, P. Martin, A. Silberschatz, J. Slonim, and Q. Zhu. </author> <title> The CORDS Mul-tidatabase Project. </title> <journal> IBM Systems Journal, </journal> <volume> 34(1), </volume> <year> 1995. </year>
Reference-contexts: In the above two cases, lock preemption is necessary. However, in a prioritized DBMS such as VERSANT lock preemption is desirable to avoid blocking a high priority transaction. Lock preemption in a multidatabase system <ref> [2] </ref> is particularly interesting regardless of the cause for preemption (site failure, communication failure, deadlock or timeout), restoration can always be attempted. A multidatabase system is a collection of autonomous, heterogeneous, preexisting local DBMSs. It supports global transactions to access data located in multiple local DBMSs.
Reference: [3] <author> P. Bernstein, V. Hadzilacos, and N. Good-man. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: It is a well-known result that a history is conflict-serializable if and only if a directed graph representing the conflicts of committed transactions, known as serialization graph, is acyclic. The above definitions of transactions and histories are a simplified adaptation from <ref> [3] </ref>. 2.4 Issues in Lock Restoration The following examples assume that the transaction manager uses two-phase locking with pages as data items and tuples as data objects. The focus is on managing the victim; we are not concerned with the reasons for preemption. <p> We are concerned with the lock preemption and restoration aspects of transaction management and just recall the relevant principles of recovery below. Details such as lock implementation and recovery are beyond the scope of our discussion and can be found in <ref> [3] </ref>. * If the recovery scheme employs undo, the committed value of a data item (which is read and/or modified by current lock owner) is in the log and the uncommitted value (due to the uncommitted writes of current lock owner) is either in the buffer or the database. * If <p> uncommitted writes of current lock owner) is either in the buffer or the database. * If recovery scheme employs redo, the committed value is in the log or the database and the uncommitted value is in the buffer. 3.2 Lock Processing The transaction manager employs the strict two-phase locking scheme <ref> [3] </ref> and any of the well-known logging and recovery schemes [3]. Let T be a transaction whose mode m lock for data item d is to be preempted. Based on the read and/or write operations performed by T , d is designated into three parts as shown in Figure 1. <p> buffer or the database. * If recovery scheme employs redo, the committed value is in the log or the database and the uncommitted value is in the buffer. 3.2 Lock Processing The transaction manager employs the strict two-phase locking scheme <ref> [3] </ref> and any of the well-known logging and recovery schemes [3]. Let T be a transaction whose mode m lock for data item d is to be preempted. Based on the read and/or write operations performed by T , d is designated into three parts as shown in Figure 1.
Reference: [4] <author> K. E. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> On the notions of consistency and predicate locks in a relational database system. </title> <journal> CACM, </journal> 19(11) 624-34, 1976. 
Reference-contexts: In general (when restored locks are not limited in the above sense), the history is shown to be value-serializable. If no locks are preempted, H is just a history generated by a two-phase locking scheme and hence conflict-serializable <ref> [4] </ref>.
Reference: [5] <author> D. Gawlick and D. Kinkade. </author> <title> Varieties of Con-currency Control in IMW/VS FastPath. Q. </title> <journal> Bull. IEEE TC on Data Engineering, </journal> <volume> 8(2) </volume> <pages> 3-10, </pages> <year> 1985. </year>
Reference-contexts: Value-serializability is particularly suitable here because read validation can be done at user application level. 4.3 Related Work and Extensions We are not aware of any reported work on restoration. The closest related work is from IMS Fast-path <ref> [5] </ref>. Here, lock preemption is avoided to some extent by allocating write locks after a transaction has finished all its operations. Write operations of transaction can be buffered until data items are write locked for. This approach minimizes lock contention by reducing the duration of write locks.
References-found: 5

