URL: http://http.cs.berkeley.edu/~fateman/papers/ding.ps
Refering-URL: http://http.cs.berkeley.edu/~fateman/algebra.html
Root-URL: 
Title: Branch Cuts in Computer Algebra  
Author: Adam Dingle Richard Fateman 
Address: Berkeley  
Affiliation: Computer Science Division, EECS Dep't University of California at  
Abstract: Many standard functions, such as the logarithm and square root functions, cannot be defined continuously on the complex plane. Mistaken assumptions about the properties of these functions lead computer algebra systems into various conundrums. We discuss how they can manipulate such functions in a useful fashion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. F. Carrier, M. Krook, and C. E. Pearson. </author> <title> Functions of a Complex Variable: Theory and Techniques, </title> <publisher> McGraw-Hill, </publisher> <year> 1966. </year>
Reference-contexts: For example, consider the cuts (0; 1; x:x 3 ) and (0; 1; x:x); in the previous section we claimed that these two cuts are equivalent. Since the minimum and maximum values of z:z 3 in the real interval <ref> [0; 1] </ref> are 0 and 1, respectively, the real function rule maps (0; 1; z:z 3 ) to (0; 1; z:z). 3.1.1 Lines and segments We define the canonical form for a line segment, ray, or line to be a cut of the form (r 0 ; r 1 ; z:uz <p> A complication that arises in practice is that f may have an inverse function which is defined only on a portion of the complex plane. For example, in the computation of the branch cuts of p p z 2, we must find the inverse image of the ray <ref> [1; 2] </ref> under the mapping f (z) = p As it turns out, f 1 (z) = z 2 is an inverse for f when =2 &lt; arg (z) &lt;= =2, but when z is in the left half-plane, f (w) = z has no solution. <p> In the above example, for instance, we find that the the inequality =2 &lt; arg (z) &lt;= =2 holds only on the subinterval [0; 2] of <ref> [1; 2] </ref>, so the inverse image of [1; 2] under p z is the branch cut (0; 2; z 2 ) = (0; 4; z). 3.3 Checking for overlap Once we have placed branch cuts into canonical form, we can often tell if two branch cuts overlap: (r 0 ; r <p> In the above example, for instance, we find that the the inequality =2 &lt; arg (z) &lt;= =2 holds only on the subinterval [0; 2] of <ref> [1; 2] </ref>, so the inverse image of [1; 2] under p z is the branch cut (0; 2; z 2 ) = (0; 4; z). 3.3 Checking for overlap Once we have placed branch cuts into canonical form, we can often tell if two branch cuts overlap: (r 0 ; r 1 ; f ) overlaps with (r <p> For example, consider the function f (z) = log (z + 1) log (z 1). The above procedure will compute that the branch cut of log (z + 1) is the interval <ref> [1; 1] </ref> and that the branch cut of log (z 1) is the interval [1; 1], and conclude that the branch cut of f (z) is [1; 1]. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is <p> For example, consider the function f (z) = log (z + 1) log (z 1). The above procedure will compute that the branch cut of log (z + 1) is the interval <ref> [1; 1] </ref> and that the branch cut of log (z 1) is the interval [1; 1], and conclude that the branch cut of f (z) is [1; 1]. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is a removable branch cut. <p> The above procedure will compute that the branch cut of log (z + 1) is the interval <ref> [1; 1] </ref> and that the branch cut of log (z 1) is the interval [1; 1], and conclude that the branch cut of f (z) is [1; 1]. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is a removable branch cut. We will modify our procedure so that it will eliminate many removable branch cuts; our modified procedure will return [1; 1] as <p> branch cut of log (z + 1) is the interval <ref> [1; 1] </ref> and that the branch cut of log (z 1) is the interval [1; 1], and conclude that the branch cut of f (z) is [1; 1]. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is a removable branch cut. We will modify our procedure so that it will eliminate many removable branch cuts; our modified procedure will return [1; 1] as the branch cut of f (z). 4.2.1 Terminology First we introduce some informal terminology. <p> is the interval <ref> [1; 1] </ref> and that the branch cut of log (z 1) is the interval [1; 1], and conclude that the branch cut of f (z) is [1; 1]. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is a removable branch cut. We will modify our procedure so that it will eliminate many removable branch cuts; our modified procedure will return [1; 1] as the branch cut of f (z). 4.2.1 Terminology First we introduce some informal terminology. <p> (z) is <ref> [1; 1] </ref>. As it turns out, f (z) is only discontinous across the interval [1; 1]; f (z) is continuous across [1; 1], which is a removable branch cut. We will modify our procedure so that it will eliminate many removable branch cuts; our modified procedure will return [1; 1] as the branch cut of f (z). 4.2.1 Terminology First we introduce some informal terminology. <p> The procedure is recursively invoked on the function g 1 , which is of the form f (g (z)) where f = log is primitive. g = z:z + 1 has no branch cuts; f has the single branch cut B = <ref> [1; 0] </ref> with corresponding alternate branch function b (z) = log (z) 2i. Mapping the cut B under the g 1 , we obtain the cut B 0 = [1; 1] with corresponding alternate branch function b ffi g = log (z + 1) 2i. <p> Mapping the cut B under the g 1 , we obtain the cut B 0 = <ref> [1; 1] </ref> with corresponding alternate branch function b ffi g = log (z + 1) 2i. Similarly, the algorithm is invoked on log (z1), returning the cut [1; 1] with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them <p> Mapping the cut B under the g 1 , we obtain the cut B 0 = <ref> [1; 1] </ref> with corresponding alternate branch function b ffi g = log (z + 1) 2i. Similarly, the algorithm is invoked on log (z1), returning the cut [1; 1] with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f <p> , we obtain the cut B 0 = <ref> [1; 1] </ref> with corresponding alternate branch function b ffi g = log (z + 1) 2i. Similarly, the algorithm is invoked on log (z1), returning the cut [1; 1] with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z <p> the cut B 0 = <ref> [1; 1] </ref> with corresponding alternate branch function b ffi g = log (z + 1) 2i. Similarly, the algorithm is invoked on log (z1), returning the cut [1; 1] with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z +1)2i)(log (z 1)2i) <p> Similarly, the algorithm is invoked on log (z1), returning the cut <ref> [1; 1] </ref> with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z +1)2i)(log (z 1)2i) = log (z +1)log (z 1). Since [1; 1] derives <p> Similarly, the algorithm is invoked on log (z1), returning the cut <ref> [1; 1] </ref> with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z +1)2i)(log (z 1)2i) = log (z +1)log (z 1). Since [1; 1] derives only from g <p> Similarly, the algorithm is invoked on log (z1), returning the cut <ref> [1; 1] </ref> with alternate branch function log (z 1) 2i. We determine that the intervals [1; 1] and [1; 1] overlap, and break them into the two intervals [1; 1] and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z +1)2i)(log (z 1)2i) = log (z +1)log (z 1). Since [1; 1] derives only from g 2 , its <p> two intervals <ref> [1; 1] </ref> and [1; 1]. Since [1; 1] derives from both g 1 and g 2 , its alternate branch function is f ffi (z: log (z + 1) 2i; z: log (z 1) 2i) = (log (z +1)2i)(log (z 1)2i) = log (z +1)log (z 1). Since [1; 1] derives only from g 2 , its alternate branch function is f ffi (z: log (z + 1); z: log (z 1) 2i) = log (z + 1) log (z 1) + 2i. When we trim the set of branch cuts, [1; 1] vanishes because its alternate branch cut <p> Since <ref> [1; 1] </ref> derives only from g 2 , its alternate branch function is f ffi (z: log (z + 1); z: log (z 1) 2i) = log (z + 1) log (z 1) + 2i. When we trim the set of branch cuts, [1; 1] vanishes because its alternate branch cut is identical to the function E itself; we are left with the single branch cut [1; 1]. 5 Implementation in Mathematica We have implemented the branch cut computation algorithm in Mathematica; the code is available from the authors. <p> When we trim the set of branch cuts, <ref> [1; 1] </ref> vanishes because its alternate branch cut is identical to the function E itself; we are left with the single branch cut [1; 1]. 5 Implementation in Mathematica We have implemented the branch cut computation algorithm in Mathematica; the code is available from the authors. The Mathematica function BranchCuts is used to find the branch cuts of a function of a single complex variable. <p> The implementation can find the branch cuts of many simple functions. For example, exercise 13a on page 24 of Carrier, Krook, and Pearson's complex analysis text <ref> [1] </ref> asks the reader to find the branch cuts of the complex function p 1 + z. <p> corresponding exercise 13b asks for the branch cuts of the function log 1 + p z 2 + 1; our implementation can solve this problem as well: In [7]:= BranchCuts [Fn [z, Log [1 + Sqrt [z^2 + 1]]]] Out [7]= -Cut [-Infinity, -1, I #1 & ], &gt; Cut <ref> [1, Infinity, I #1 & ] </ref>- The branch cuts reported are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for z:iz.) Our implementation will eliminate many removable branch cuts, such as in this example: In [8]:= BranchCuts [Fn [z, Log [z + <p> are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for z:iz.) Our implementation will eliminate many removable branch cuts, such as in this example: In [8]:= BranchCuts [Fn [z, Log [z + 1] - Log [z - 1]]] Out [8]= -Cut <ref> [-1, 1, Identity] </ref>- 4 5.1 Difficulties in implementation Several aspects of Mathematica posed difficulties for our implementation. <p> Our branch cut procedure tells us that the branch cuts of f (z) are the lines <ref> [1; i] </ref> (using interval notation a bit loosely this indicates a line from 1 to i or, more precisely, the set fx + ij 1 &lt; x 0g), [1; i], [i; i1] and [i; i1]. <p> Our branch cut procedure tells us that the branch cuts of f (z) are the lines <ref> [1; i] </ref> (using interval notation a bit loosely this indicates a line from 1 to i or, more precisely, the set fx + ij 1 &lt; x 0g), [1; i], [i; i1] and [i; i1]. The first two branch cuts are the branch cuts of log (z i) and log (z + i), respectively; the last two are obtained by mapping the negative real axis under the inverses of (z + i)(z i). <p> None of the branch cuts intersect at points other than their endpoints; the set of branch cut endpoints is fi; i; 1g. The branch cuts around 1 are sorted in the order [i; i1], <ref> [1; i] </ref>, [1; i], [i; i1] (we must use the second derivative to properly order [1; i] and [1; i]). We now traverse the branch cuts in S. <p> None of the branch cuts intersect at points other than their endpoints; the set of branch cut endpoints is fi; i; 1g. The branch cuts around 1 are sorted in the order [i; i1], <ref> [1; i] </ref>, [1; i], [i; i1] (we must use the second derivative to properly order [1; i] and [1; i]). We now traverse the branch cuts in S. <p> None of the branch cuts intersect at points other than their endpoints; the set of branch cut endpoints is fi; i; 1g. The branch cuts around 1 are sorted in the order [i; i1], <ref> [1; i] </ref>, [1; i], [i; i1] (we must use the second derivative to properly order [1; i] and [1; i]). We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and [i; 1]; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , <p> The branch cuts around 1 are sorted in the order [i; i1], <ref> [1; i] </ref>, [1; i], [i; i1] (we must use the second derivative to properly order [1; i] and [1; i]). We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and [i; 1]; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , bordered by [1; <p> We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and <ref> [i; 1] </ref>; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , bordered by [1; i] and [i; i1]. 6.5 Implementation We have implemented the region-finding procedure in Math-ematica. <p> i], [i; i1] (we must use the second derivative to properly order <ref> [1; i] </ref> and [1; i]). We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and [i; 1]; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , bordered by [1; i] and [i; i1]. 6.5 Implementation We have implemented the region-finding procedure in Math-ematica. <p> We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and <ref> [i; 1] </ref>; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , bordered by [1; i] and [i; i1]. 6.5 Implementation We have implemented the region-finding procedure in Math-ematica. The Mathematica function Regions maps a function to a list of its branch regions; each region is represented by a list of its boundaries. <p> <ref> [1; i] </ref>). We now traverse the branch cuts in S. Starting with the point at infinity, we traverse the regions R 1 , bordered by [i1; i] and [i; 1]; R 2 , bordered by [1; i], [i; i1], [i1; i], and [i; 1]; and R 3 , bordered by [1; i] and [i; i1]. 6.5 Implementation We have implemented the region-finding procedure in Math-ematica. The Mathematica function Regions maps a function to a list of its branch regions; each region is represented by a list of its boundaries. <p> Our implementation can find the branch regions of the example given in the previous section: In [6]:= Regions [Fn [z, Log [(z + I)(z I)]- Log [z + I] - Log [z I]]] Out [6]= --Cut [-Infinity, 0, I + #1 & ], &gt; Cut <ref> [1, Infinity, I #1 & ] </ref>, &gt; Cut [-Infinity, -1, I #1 & ], &gt; Cut [0, -Infinity, -I + #1 & ]-, &gt; -Cut [-1, -Infinity, I #1 & ], &gt; Cut [-Infinity, 0, -I + #1 & ]-, &gt; -Cut [0, -Infinity, I + #1 & ], &gt; Cut <p> Infinity, I #1 & ], &gt; Cut [-Infinity, -1, I #1 & ], &gt; Cut [0, -Infinity, -I + #1 & ]-, &gt; -Cut [-1, -Infinity, I #1 & ], &gt; Cut [-Infinity, 0, -I + #1 & ]-, &gt; -Cut [0, -Infinity, I + #1 & ], &gt; Cut <ref> [Infinity, 1, I #1 & ] </ref>-- Again, I + #1 & is a Mathematica shorthand for z:z+i. The regions reported by Mathematica are, in order, R 2 , R 3 , and R 1 .
Reference: [2] <author> B. W. Char, K. 0&gt; Geddes, et al. </author> <title> Maple V Library Reference Manual, </title> <publisher> (and other volumes) Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A complication that arises in practice is that f may have an inverse function which is defined only on a portion of the complex plane. For example, in the computation of the branch cuts of p p z 2, we must find the inverse image of the ray <ref> [1; 2] </ref> under the mapping f (z) = p As it turns out, f 1 (z) = z 2 is an inverse for f when =2 &lt; arg (z) &lt;= =2, but when z is in the left half-plane, f (w) = z has no solution. <p> In the above example, for instance, we find that the the inequality =2 &lt; arg (z) &lt;= =2 holds only on the subinterval <ref> [0; 2] </ref> of [1; 2], so the inverse image of [1; 2] under p z is the branch cut (0; 2; z 2 ) = (0; 4; z). 3.3 Checking for overlap Once we have placed branch cuts into canonical form, we can often tell if two branch cuts overlap: (r <p> In the above example, for instance, we find that the the inequality =2 &lt; arg (z) &lt;= =2 holds only on the subinterval [0; 2] of <ref> [1; 2] </ref>, so the inverse image of [1; 2] under p z is the branch cut (0; 2; z 2 ) = (0; 4; z). 3.3 Checking for overlap Once we have placed branch cuts into canonical form, we can often tell if two branch cuts overlap: (r 0 ; r <p> In the above example, for instance, we find that the the inequality =2 &lt; arg (z) &lt;= =2 holds only on the subinterval [0; 2] of <ref> [1; 2] </ref>, so the inverse image of [1; 2] under p z is the branch cut (0; 2; z 2 ) = (0; 4; z). 3.3 Checking for overlap Once we have placed branch cuts into canonical form, we can often tell if two branch cuts overlap: (r 0 ; r 1 ; f ) overlaps with (r <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut <ref> [2; 6] </ref>, then S will contain the branch cuts [4; 2], [2; 4] and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts <ref> [4; 2] </ref>, [2; 4] and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts [4; 2], <ref> [2; 4] </ref> and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> Note that solution of algebraic systems is used internally in AXIOM for other purposes, and therefore results from (in particular) the integration program may include rootOf expressions. The Maple system <ref> [2] </ref> uses the operator RootOf to express the solution of algebraic equations in a similar manner to that of AXIOM. Maple allows the notation to be used for transcendental equations as in RootOf (cos (x)=x,x), but 6 appears to have no routines to manipulate such transcenden-tal forms. <p> We have implemented the above substitution in Mathe-matica. The example above can be simplified automatically: In <ref> [2] </ref>:= ExpTrans [Log [w^2] - 2 Log [w]] Arg [w] Out [2]= -2 I Pi Round [-----] Pi 7.3 Multiple Values The expressions derived using the simplification of the previous section will often contain complicated instances of the nearest-integer function, which are difficult to analyze algebraically. <p> We have implemented the above substitution in Mathe-matica. The example above can be simplified automatically: In <ref> [2] </ref>:= ExpTrans [Log [w^2] - 2 Log [w]] Arg [w] Out [2]= -2 I Pi Round [-----] Pi 7.3 Multiple Values The expressions derived using the simplification of the previous section will often contain complicated instances of the nearest-integer function, which are difficult to analyze algebraically.
Reference: [3] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM the Scientific Computation System. </title> <publisher> NAG and Springer Verlag, </publisher> <address> NY, </address> <year> 1992. </year>
Reference-contexts: If the solution of an algebraic equation cannot be expressed in terms of radicals, the solve program declines to solve it. (Adopting a variation of the solutions of Mathematica or Maple, described below, would probably be a quick but partial fix.) The AXIOM system <ref> [3] </ref> provides zeroOf and rootOf to specify algebraic numbers within some arbitrary choice. AXIOM allows a command of the form a := rootOf (a**4+1,a). The operation zeroOf is similar to rootOf, but will use radicals when possible.
Reference: [4] <author> A. Dingle. </author> <title> "Branch Cuts in Computer Algebra," </title> <type> Master's Thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of California at Berkeley, </institution> <year> 1991. </year>
Reference-contexts: For example, if G 1 contains the branch cut <ref> [4; 4] </ref>, an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts [4; 2], [2; 4] and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts <ref> [4; 2] </ref>, [2; 4] and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts [4; 2], <ref> [2; 4] </ref> and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts [4; 2], [2; 4] and <ref> [4; 6] </ref>. Now we construct an alternate branch function for each branch cut B in S. Each branch cut B has an alternate branch function f 0 ffi (h 1 ; : : : ; h n ), where f 0 and the h i are defined as follows. <p> More careful attention to the endpoints of intervals would allow us to represent and ma nipulate singularities, which we can consider to be degener ate branch cuts. A Acknowledgments Large portions of this paper are based on Adam Dingle's Master's project <ref> [4] </ref> written under the direction of Richard Fateman, University of California at Berkeley. Prof. W. Ka-han, the second reader for this report, also contributed helpful suggestions. Adam Dingle was supported in part by a National Science Foundation Graduate Fellowship.
Reference: [5] <author> W. Kahan. </author> <note> "Instead of UNLN", unpublished paper, </note> <month> April </month> <year> 1991. </year>
Reference-contexts: G In unpublished work (but described in sci.math.symbolic Internet netnews (April 19, 1991), Charles Patton, Sam Dooley, and others have attempted to derive minimum "add-on" concepts that would permit computer algebra systems to deal with multiple values. 7.2 Simplification using Integer Rounding Kahan has noted <ref> [5] </ref> that expressions involving functions with branch cuts can sometimes be written in a simpler form by using the nearest-integer function. For example, ln (e ) = z 2i [=(z)=2] where [a] denotes the integer nearest to a, rounding half-integers down, and where =(z) denotes the imaginary part of z. <p> Similarly, we find that f (z) = 0 when z is in R 2 , and that f (z) = 2i when z is in R 3 . 7 7.5 A challenge problem Consider a problem posed by W. Kahan in <ref> [5] </ref> as a challenge for computer algebra systems: if R (z) = (z + 1=z)=2 and S (w) = w + w + 1 w 1, simplify S (R (z)). (Notice that S is a "weak inverse function" for R as R (S (z)) = z for all z.) Expansion of
Reference: [6] <author> H. Kober. </author> <title> Dictionary of Conformal Representations, </title> <publisher> Dover, </publisher> <year> 1957. </year>
Reference-contexts: Kober's dictionary of conformal mappings <ref> [6] </ref> describes the effect that common mappings have on common shapes. We can add algebraic information from the dictionary to our system in the form of rules that ensure that when shapes are mapped, they will simplify to canonical form. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut <ref> [2; 6] </ref>, then S will contain the branch cuts [4; 2], [2; 4] and [4; 6]. Now we construct an alternate branch function for each branch cut B in S. <p> For example, if G 1 contains the branch cut [4; 4], an interval on the real axis, and G 2 contains the branch cut [2; 6], then S will contain the branch cuts [4; 2], [2; 4] and <ref> [4; 6] </ref>. Now we construct an alternate branch function for each branch cut B in S. Each branch cut B has an alternate branch function f 0 ffi (h 1 ; : : : ; h n ), where f 0 and the h i are defined as follows. <p> That function is represented in Mathematica as Fn [z, Sqrt [1 + Sqrt [z]]], so we can pose the branch cut problem to the BranchCuts function as follows: In <ref> [6] </ref>:= BranchCuts [Fn [z, Sqrt [1 + Sqrt [z]]]] Out [6]= -Cut [-Infinity, 0, Identity]- Mathematica reports that the function has the single branch cut (1; 0; z:z), which is the negative real axis. <p> That function is represented in Mathematica as Fn [z, Sqrt [1 + Sqrt [z]]], so we can pose the branch cut problem to the BranchCuts function as follows: In <ref> [6] </ref>:= BranchCuts [Fn [z, Sqrt [1 + Sqrt [z]]]] Out [6]= -Cut [-Infinity, 0, Identity]- Mathematica reports that the function has the single branch cut (1; 0; z:z), which is the negative real axis. <p> Our implementation can find the branch regions of the example given in the previous section: In <ref> [6] </ref>:= Regions [Fn [z, Log [(z + I)(z I)]- Log [z + I] - Log [z I]]] Out [6]= --Cut [-Infinity, 0, I + #1 & ], &gt; Cut [1, Infinity, I #1 & ], &gt; Cut [-Infinity, -1, I #1 & ], &gt; Cut [0, -Infinity, -I + #1 & <p> Our implementation can find the branch regions of the example given in the previous section: In <ref> [6] </ref>:= Regions [Fn [z, Log [(z + I)(z I)]- Log [z + I] - Log [z I]]] Out [6]= --Cut [-Infinity, 0, I + #1 & ], &gt; Cut [1, Infinity, I #1 & ], &gt; Cut [-Infinity, -1, I #1 & ], &gt; Cut [0, -Infinity, -I + #1 & ]-, &gt; -Cut [-1, -Infinity, I #1 & ], &gt; Cut [-Infinity, 0, -I + #1 & ]-,
Reference: [7] <author> Macsyma Inc. </author> <title> Macsyma Reference Manual, </title> <type> Version 14, </type> <year> 1991. </year>
Reference-contexts: branch cut, since the function 1 + p z does not map any values z to the branch cut of p The corresponding exercise 13b asks for the branch cuts of the function log 1 + p z 2 + 1; our implementation can solve this problem as well: In <ref> [7] </ref>:= BranchCuts [Fn [z, Log [1 + Sqrt [z^2 + 1]]]] Out [7]= -Cut [-Infinity, -1, I #1 & ], &gt; Cut [1, Infinity, I #1 & ]- The branch cuts reported are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for <p> any values z to the branch cut of p The corresponding exercise 13b asks for the branch cuts of the function log 1 + p z 2 + 1; our implementation can solve this problem as well: In <ref> [7] </ref>:= BranchCuts [Fn [z, Log [1 + Sqrt [z^2 + 1]]]] Out [7]= -Cut [-Infinity, -1, I #1 & ], &gt; Cut [1, Infinity, I #1 & ]- The branch cuts reported are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for z:iz.) Our implementation will eliminate many removable branch cuts, such as in <p> Macsyma <ref> [7] </ref> allows certain computations to be done over algebraic number and algebraic function fields via the command tellrat. For example tellrat (a^2=3) specifies that a 2 = 3 without expressing an opinion as to whether a is positive or negative, or in general, real or complex.
Reference: [8] <author> Z. Nehari. </author> <title> Conformal Mapping, </title> <publisher> McGraw-Hill, </publisher> <year> 1952. </year>
Reference-contexts: I #1 & ], &gt; Cut [1, Infinity, I #1 & ]- The branch cuts reported are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for z:iz.) Our implementation will eliminate many removable branch cuts, such as in this example: In <ref> [8] </ref>:= BranchCuts [Fn [z, Log [z + 1] - Log [z - 1]]] Out [8]= -Cut [-1, 1, Identity]- 4 5.1 Difficulties in implementation Several aspects of Mathematica posed difficulties for our implementation. <p> cuts reported are the imaginary intervals [i; i1] and [i; i1]. (The notation I #1 & is a Mathe-matica shorthand for z:iz.) Our implementation will eliminate many removable branch cuts, such as in this example: In <ref> [8] </ref>:= BranchCuts [Fn [z, Log [z + 1] - Log [z - 1]]] Out [8]= -Cut [-1, 1, Identity]- 4 5.1 Difficulties in implementation Several aspects of Mathematica posed difficulties for our implementation.
Reference: [9] <author> H. Seymour. "Conform: </author> <title> A Conformal Mapping System", </title> <type> Master's Thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of California at Berkeley, </institution> <year> 1985. </year>
Reference-contexts: For example, a circle might be represented by the symbol "circle" along with its center and radius. Harlan Seymour describes such a representation in his master's thesis <ref> [9] </ref>. Sey-mour's library is able to derive conformal mappings that transform one given shape into another given shape. Our problem is more difficult: given a shape S and a mapping M , we need to be able to recognize the shape to which S is mapped under M .
Reference: [10] <author> S. Wolfram. </author> <title> Mathematica, A System for Doing Mathematics by Computer, Second edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: The procedures discussed below are suitable for implementation in a computer algebra system. Typically, a computer algebra system will have a set of primitive functions from which complex expressions may be built; these primitive functions will form the set P fl . In our Mathematica <ref> [10] </ref> implementation, P contains the Power and Log functions, which have branch cuts, as well as all Mathematica functions which do not have branch cuts, including the addition and multiplication functions and trigonometric functions. <p> Maple does use RootOf for its own purposes, in a manner similar to that of AXIOM, and so new expressions may be generated. A finite sum over different roots is supported. The Mathematica system <ref> [10] </ref> uses a convention where Solve can provide a set of algebraic rules for simplification (through rule application) or the user can define, with the assistance of AlgebraicRules a sequence of substitutions intended to simplify expressions. The rules must be explicitly applied to expressions for them to take effect.
References-found: 10

