URL: http://www.cs.wisc.edu/~fischer/cs701/pldi92.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/cs701/readings.html
Root-URL: 
Email: jk@informatik.uni-kiel.dbp.de  or@informatik.uni-kiel.dbp.de  bus@zeus.informatik.rwth-aachen.de  
Title: Lazy Code Motion  
Author: Jens Knoop Oliver Ruthing Bernhard Steffen 
Keyword: Topics: data flow analysis, program optimization, partial redundancy elimination, code motion, bit-vector data flow analyses.  
Date: 27, 7 (1992), 224 234.  
Note: In Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation (PLDI'92), San Francisco, California, SIGPLAN Notices  Part of the work was done, while the author was supported by the Deutsche Forschungsgemeinschaft grant La 426/9-2.  The author is supported by the Deutsche Forschungsge-meinschaft grant La 426/11-1.  
Address: Kiel  Kiel  Aachen  Christian-Albrechts-Universitat, Preuerstrae 1-9, D-2300 Kiel 1.  Aachen, Ahornstrae 55, D-5100 Aachen.  
Affiliation: CAU  CAU  RWTH  Institut fur Informatik und Praktische Mathematik,  Lehrstuhl fur Informatik II, Rheinisch-Westfalische Tech nische Hochschule  
Abstract: We present a bit-vector algorithm for the optimal and economical placement of computations within flow graphs, which is as efficient as standard unidirectional analyses. The point of our algorithm is the decomposition of the bi-directional structure of the known placement algorithms into a sequence of a backward and a forward analysis, which directly implies the efficiency result. Moreover, the new compositional structure opens the algorithm for modification: two further uni-directional analysis components exclude any unnecessary code motion. This laziness of our algorithm minimizes the register pressure, which has drastic effects on the run-time be-haviour of the optimized programs in practice, where an economical use of registers is essential. 
Abstract-found: 1
Intro-found: 1
Reference: [AU] <author> Aho, A. V., and Ullman, J. D. </author> <title> Node listings for reducible flow graphs. </title> <booktitle> In Proceedings 7 th STOC, </booktitle> <address> Albuquerque, New Mexico, </address> <year> 1975, </year> <pages> 177 - 185. </pages>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [Ch] <author> Chow, F. </author> <title> A portable machine independent optimizer Design and measurements. </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Electrical Engineering, Stanford University, Stanford, Calif., and Tech. </institution> <type> Rep. 83-254, </type> <institution> Computer Systems Lab., Stanford University, </institution> <year> 1983. </year>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> The problem of unnecessary code motion is only addressed in <ref> [Ch, Dh2, Dh3] </ref>, and these proposals are of heuristic nature: code is unnecessarily moved or redundancies remain in the program. In contrast, our algorithm is composed of unidirectional analyses 2 .
Reference: [Dh1] <author> Dhamdhere, D. M. </author> <title> Characterization of program loops in code optimization. </title> <journal> Comp. Lang. </journal> <volume> 8, 2 (1983), 69 - 76. </volume>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>).
Reference: [Dh2] <author> Dhamdhere, D. M. </author> <title> A fast algorithm for code movement optimization. </title> <journal> SIGPLAN Not. </journal> <volume> 23, 10 (1988), 172 - 180. </volume>
Reference-contexts: Theorem 3.9). Central idea to obtain this optimality result is to place computations as early as possible in a program, while maintaining safety (cf. <ref> [Dh2, Dh3, KS2, MR1, St] </ref>). However, this strategy moves computations even if it is unnecessary, i.e. there is no run-time gain 1 . This causes superfluous register pressure, which is in fact a major problem in practice. <p> This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> The problem of unnecessary code motion is only addressed in <ref> [Ch, Dh2, Dh3] </ref>, and these proposals are of heuristic nature: code is unnecessarily moved or redundancies remain in the program. In contrast, our algorithm is composed of unidirectional analyses 2 . <p> to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1.
Reference: [Dh3] <author> Dhamdhere, D. M. </author> <title> Practical adaptation of the global optimization algorithm of Morel and Renvoise. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 13, 2 (1991), 291 - 294. </volume>
Reference-contexts: Theorem 3.9). Central idea to obtain this optimality result is to place computations as early as possible in a program, while maintaining safety (cf. <ref> [Dh2, Dh3, KS2, MR1, St] </ref>). However, this strategy moves computations even if it is unnecessary, i.e. there is no run-time gain 1 . This causes superfluous register pressure, which is in fact a major problem in practice. <p> Moreover, the new compositional structure allows to avoid any unnecessary code motion by modifying the standard computationally optimal computation points according to the following idea: 1 In <ref> [Dh3] </ref> unnecessary code motions are called redundant. * Initialize "as late as possible" while maintaining computational optimality. Together with the suppression of initializations, which are only going to be used at the insertion point itself, this characterizes our approach of lazy code motion. <p> This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> complex than uni-directional ones: e.g. in contrast to the uni-directional case, where reducible programs can be dealt with in O (n log (n)) time, where n characterizes the size of the argument program (e.g. number of statements), the best known estimation for bi-directional analyses is O (n 2 ) (cf. <ref> [Dh3] </ref>). The problem of unnecessary code motion is only addressed in [Ch, Dh2, Dh3], and these proposals are of heuristic nature: code is unnecessarily moved or redundancies remain in the program. In contrast, our algorithm is composed of unidirectional analyses 2 . <p> The problem of unnecessary code motion is only addressed in <ref> [Ch, Dh2, Dh3] </ref>, and these proposals are of heuristic nature: code is unnecessarily moved or redundancies remain in the program. In contrast, our algorithm is composed of unidirectional analyses 2 . <p> to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1.
Reference: [DS] <author> Drechsler, K. H., and Stadel, M. P. </author> <title> A solution to a problem with Morel and Ren-voise's "Global optimization by suppression of partial redundancies". </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 10, 4 (1988), 635 - 640. </volume>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1.
Reference: [GW] <author> Graham, S. L., and Wegman, M. </author> <title> A fast and usually linear algorithm for global flow analysis. </title> <journal> Journal of the ACM 23, </journal> <volume> 1 (1976), 172 - 202. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [He] <author> Hecht, M. S. </author> <title> Flow analysis of computer programs. </title> <publisher> Elsevier, North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: This leads to the usual bit-vector algorithms that realize such a combination efficiently (cf. <ref> [He] </ref>). In the following, we fix the flow graph G and the term t 2 T n V, in order to allow a simple, unparam-eterized notation, and we denote the computations of t occurring in G as original computations. 3 We do not assume any structural restrictions on G. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. <ref> [He] </ref>).
Reference: [HU1] <author> Hecht, M. S., and Ullman, J. D. </author> <title> Analysis of a simple algorithm for global flow problems. </title> <booktitle> In Proceedings 1 st POPL, </booktitle> <address> Boston, Mas-sachusetts, </address> <year> 1973, </year> <pages> 207 - 217. </pages>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [HU2] <author> Hecht, M. S., and Ullman, J. D. </author> <title> A simple algorithm for global data flow analysis problems. </title> <journal> In SIAM J. Comput. </journal> <volume> 4, 4 (1977), 519 - 532. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [JD1] <author> Joshi, S. M., and Dhamdhere, D. M. </author> <title> A composite hoisting-strength reduction transformation for global program optimization part I. </title> <journal> Internat. J. Computer Math. </journal> <volume> 11, </volume> <year> (1982), </year> <pages> 21 - 41. </pages>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> Moreover, it makes the algorithm modular, which supports future extensions: in [KRS] we present an extension of our lazy code motion algorithm which, in a similar fashion as in <ref> [JD1, JD2] </ref>, uniformly combines code motion and strength reduction, and following the lines of [KS1, KS2] a generalization to programs with procedures, local variables and formal parameters is straightforward.
Reference: [JD2] <author> Joshi, S. M., and Dhamdhere, D. M. </author> <title> A composite hoisting-strength reduction transformation for global program optimization part II. </title> <journal> Internat. J. Computer Math. </journal> <volume> 11, </volume> <year> (1982), </year> <pages> 111 - 126. </pages>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>). <p> Moreover, it makes the algorithm modular, which supports future extensions: in [KRS] we present an extension of our lazy code motion algorithm which, in a similar fashion as in <ref> [JD1, JD2] </ref>, uniformly combines code motion and strength reduction, and following the lines of [KS1, KS2] a generalization to programs with procedures, local variables and formal parameters is straightforward.
Reference: [Ke] <author> Kennedy, K. </author> <title> Node listings applied to data flow analysis. </title> <booktitle> In Proceedings 2 nd POPL, </booktitle> <address> Palo Alto, California, </address> <year> 1975, </year> <pages> 10 - 21. </pages>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [KRS] <author> Knoop, J., Ruthing, O., and Steffen, B. </author> <title> Lazy strength reduction. </title> <note> To appear. </note>
Reference-contexts: Fundamental was the decomposition of the typically bi-directionally specified code motion procedures into uni-directional components. Besides yielding clarity and reducing the number of predicates drastically, this allows us to utilize the efficient algorithms for uni-directional bit-vector analyses. Moreover, it makes the algorithm modular, which supports future extensions: in <ref> [KRS] </ref> we present an extension of our lazy code motion algorithm which, in a similar fashion as in [JD1, JD2], uniformly combines code motion and strength reduction, and following the lines of [KS1, KS2] a generalization to programs with procedures, local variables and formal parameters is straightforward.
Reference: [KS1] <author> Knoop, J., and Steffen, B. </author> <title> The inter-procedural coincidence theorem. Aachener Informatik-Berichte Nr. </title> <type> 9127, </type> <institution> Rheinisch-Westfalische Technische Hochschule Aachen, Aachen, </institution> <year> 1991. </year>
Reference-contexts: Moreover, it makes the algorithm modular, which supports future extensions: in [KRS] we present an extension of our lazy code motion algorithm which, in a similar fashion as in [JD1, JD2], uniformly combines code motion and strength reduction, and following the lines of <ref> [KS1, KS2] </ref> a generalization to programs with procedures, local variables and formal parameters is straightforward. We are also investigating an adaption of the as early as necessary but as late as possible placing strategy to the semantically based code motion algorithms of [SKR1, SKR2].
Reference: [KS2] <author> Knoop, J., and Steffen, B. </author> <title> Efficient and optimal interprocedural bit-vector data flow analyses: A uniform interprocedural framework. </title> <note> To appear. </note>
Reference-contexts: Theorem 3.9). Central idea to obtain this optimality result is to place computations as early as possible in a program, while maintaining safety (cf. <ref> [Dh2, Dh3, KS2, MR1, St] </ref>). However, this strategy moves computations even if it is unnecessary, i.e. there is no run-time gain 1 . This causes superfluous register pressure, which is in fact a major problem in practice. <p> The two new predicates Latest and Isolated prevent any 2 Such an algorithm was first proposed in [St], which later on was interprocedurally generalized to programs with procedures, local variables and formal parameters in <ref> [KS2] </ref>. Both algorithms realize an "as early as possible" placement. unnecessary code motion. 2 Preliminaries We consider variables v 2 V, terms t 2 T, and directed flow graphs G = (N; E; s; e) with node set N and edge set E. <p> Moreover, it makes the algorithm modular, which supports future extensions: in [KRS] we present an extension of our lazy code motion algorithm which, in a similar fashion as in [JD1, JD2], uniformly combines code motion and strength reduction, and following the lines of <ref> [KS1, KS2] </ref> a generalization to programs with procedures, local variables and formal parameters is straightforward. We are also investigating an adaption of the as early as necessary but as late as possible placing strategy to the semantically based code motion algorithms of [SKR1, SKR2].
Reference: [KU1] <author> Kam, J. B., and Ullman, J. D. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM 23, </journal> <volume> 1 (1976), 158 - 171. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [KU2] <author> Kam, J. B., and Ullman, J. D. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Infor-matica 7, (1977), </journal> <volume> 309 - 317. </volume>
Reference: [Mo] <author> Morel, E. </author> <title> Data flow analysis and global optimization. </title> <editor> In: Lorho, B. (Ed.). </editor> <title> Methods and tools for compiler construction, </title> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>).
Reference: [MR1] <author> Morel, E., and Renvoise, C. </author> <title> Global optimization by suppression of partial redundancies. </title> <journal> Commun. of the ACM 22, </journal> <volume> 2 (1979), 96 - 103. </volume>
Reference-contexts: Theorem 3.9). Central idea to obtain this optimality result is to place computations as early as possible in a program, while maintaining safety (cf. <ref> [Dh2, Dh3, KS2, MR1, St] </ref>). However, this strategy moves computations even if it is unnecessary, i.e. there is no run-time gain 1 . This causes superfluous register pressure, which is in fact a major problem in practice. <p> This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies <ref> [MR1] </ref>. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So]). <p> Conventions: Following <ref> [MR1] </ref>, we assume that all right-hand-side terms of assignment statements contain at most one operation symbol. This does not impose any restrictions, because every assignment statement can be decomposed into sequences of assignments of this form. <p> of the efficient techniques of [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. <ref> [MR1] </ref>), indicating whether the computation of t is locally anticipatable at node n. 3 Computationally Optimal Computation Points In this section we develop an algorithm for the "as early as possible" placement, which in contrast to previous approaches is composed of uni-directional analyses. <p> 1 ; : : : ; n j ) which satisfies: a) Used (n j ) b) :Used (n i ) for all i 2 f1; : : : ; j 1g c) Transp (n i ) for all i 2 f1; : : : ; j 1g 8 In <ref> [MR1] </ref> down-safety is called anticipability, and the dual notion to down-safety, up-safety, is called availability. 9 n-up-safety of a node is defined in analogy to n-down safety. 10 Note that a node is n-safe if and only if it is n-down-safe or n-up-safe. <p> Moreover, according to Lemma 3.1, Lemma 3.6 and Lemma 3.8 the Safe-Earliest Transformation is down-safe and earliest. Together with Theorem 3.4 this yields: Theorem 3.9 (Computational Optimality) The Safe-Earliest Transformation is computationally optimal. which is essentially the same as the one delivered by the algorithm of Morel and Renvoise <ref> [MR1] </ref> 11 . In general, however, there may be more deviations, since their algorithm inserts computations at the end of nodes, and it moves computations only, if they are partially available. Introducing this condition can be considered as a first step in order to avoid unnecessary code motion. <p> node, i.e.: - n is a computation point of some compu tationally optimal placement and on every terminating path p starting in n any following computation point of a com-putationally optimal placement occurs af ter an original computation on p. 11 In the example of Figure 1 the algorithm of <ref> [MR1] </ref> would not insert a computation at node 3.
Reference: [MR2] <author> Morel, E., and Renvoise, C. </author> <title> Interprocedu-ral elimination of partial redundancies. </title> <editor> In: Muchnick, St. S., and Jones, N. D. (Eds.). </editor> <title> Program flow analysis: Theory and applications. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>).
Reference: [RWZ] <author> Rosen, B. K., Wegman, M. N., and Zadeck,F. K. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In Proceedings 15 th POPL, </booktitle> <address> San Diego, California, </address> <year> 1988, </year> <pages> 12 - 27. </pages>
Reference-contexts: to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1.
Reference: [So] <author> Sorkin, A. </author> <title> Some comments on A solution to a problem with Morel and Renvoise's "Global optimization by suppression of partial redundancies". </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 11, 4 (1989), 666 - 668. </volume>
Reference-contexts: This confirms that computations are only moved when it is profitable. Related Work In 1979 Morel and Renvoise proposed a bit-vector algorithm for the suppression of partial redundancies [MR1]. The bi-directionality of their algorithm became model in the field of bit-vector based code motion (cf. <ref> [Ch, Dh1, Dh2, Dh3, DS, JD1, JD2, Mo, MR2, So] </ref>).
Reference: [St] <author> Steffen, B. </author> <title> Data flow analysis as model checking. </title> <booktitle> In Proceedings TACS'91, Sendai, </booktitle> <address> Japan, </address> <note> Springer-Verlag, LNCS 526 (1991), 346 - 364. </note>
Reference-contexts: Theorem 3.9). Central idea to obtain this optimality result is to place computations as early as possible in a program, while maintaining safety (cf. <ref> [Dh2, Dh3, KS2, MR1, St] </ref>). However, this strategy moves computations even if it is unnecessary, i.e. there is no run-time gain 1 . This causes superfluous register pressure, which is in fact a major problem in practice. <p> Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of <ref> [St] </ref>, which simply computes the predicates D-Safe and Earliest. The two new predicates Latest and Isolated prevent any 2 Such an algorithm was first proposed in [St], which later on was interprocedurally generalized to programs with procedures, local variables and formal parameters in [KS2]. <p> Thus our algorithm is an extension of the algorithm of <ref> [St] </ref>, which simply computes the predicates D-Safe and Earliest. The two new predicates Latest and Isolated prevent any 2 Such an algorithm was first proposed in [St], which later on was interprocedurally generalized to programs with procedures, local variables and formal parameters in [KS2].
Reference: [SKR1] <author> Steffen, B., Knoop, J., and Ruthing, O. </author> <title> The value flow graph: A program representation for optimal program transformations. </title> <booktitle> In Proceedings 3 rd ESOP, </booktitle> <address> Copenhagen, Denmark, </address> <note> Springer-Verlag, LNCS 432 (1990), 389 - 405. </note>
Reference-contexts: to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1. <p> This simple transformation certainly implies that all critical edges are eliminated. Moreover, it simplifies the subsequent analysis, since it allows to obtain programs that are computationally and lifetime optimal (Optimality Theorem 4.9) by inserting all computations uniformly at node entries (cf. <ref> [SKR1, SKR2] </ref>) 6 . 3.2 Guaranteeing Computational Op timality A placement is * safe, iff every computation point n is an n-safe node, i.e.: a computation of t at n does not introduce a new value on a path through n. <p> We are also investigating an adaption of the as early as necessary but as late as possible placing strategy to the semantically based code motion algorithms of <ref> [SKR1, SKR2] </ref>.
Reference: [SKR2] <author> Steffen, B., Knoop, J., and Ruthing, O. </author> <title> Efficient code motion and an adaption to strength reduction. </title> <booktitle> In Proceedings 4 th TAP-SOFT, </booktitle> <address> Brighton, United Kingdom, </address> <note> Springer-Verlag, LNCS 494 (1991), 394 - 415. </note>
Reference-contexts: to placements that only insert computations at node entries. 3.1 Critical Edges It is well-known that in completely arbitrary graph structures the code motion process may be blocked by "critical" edges, i.e. by edges leading from nodes with more than one successor to nodes with more than one predecessor (cf. <ref> [Dh2, Dh3, DS, RWZ, SKR1, SKR2] </ref>). In Figure 3 (a) the computation of "a + b" at node 3 is partially redundant with respect to the computation of "a + b" at node 1. <p> This simple transformation certainly implies that all critical edges are eliminated. Moreover, it simplifies the subsequent analysis, since it allows to obtain programs that are computationally and lifetime optimal (Optimality Theorem 4.9) by inserting all computations uniformly at node entries (cf. <ref> [SKR1, SKR2] </ref>) 6 . 3.2 Guaranteeing Computational Op timality A placement is * safe, iff every computation point n is an n-safe node, i.e.: a computation of t at n does not introduce a new value on a path through n. <p> We are also investigating an adaption of the as early as necessary but as late as possible placing strategy to the semantically based code motion algorithms of <ref> [SKR1, SKR2] </ref>.
Reference: [Ta1] <author> Tarjan, R. E. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the ACM 26, </journal> <volume> 4 (1979), 690 - 715. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [Ta2] <author> Tarjan, R. E. </author> <title> A unified approach to path problems. </title> <journal> Journal of the ACM 28, </journal> <volume> 3 (1981), 577 - 593. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [Ta3] <author> Tarjan, R. E. </author> <title> Fast algorithms for solving path problems. </title> <journal> Journal of the ACM 28, </journal> <volume> 3 (1981), 594 - 614. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
Reference: [Ull] <author> Ullman, J. D. </author> <title> Fast algorithms for the elimination of common subexpressions. </title> <journal> Acta In-formatica 2, </journal> <volume> 3 (1973), 191 - 213. </volume>
Reference-contexts: In contrast, our algorithm is composed of unidirectional analyses 2 . Thus the same estimations for the worst case time complexity apply as for uni-directional analyses (cf. <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref>). Moreover, our algorithm is conceptually simple. It only requires the sequential computation of the four predicates D-Safe, Earliest, Latest, and Isolated. Thus our algorithm is an extension of the algorithm of [St], which simply computes the predicates D-Safe and Earliest. <p> In fact, every algorithm computing the fixed point solution of a unidirectional bit-vector data flow analysis problem may be used to compute the predicates D-Safe, Earliest, Latest, and Isolated (cf. [He]). However, application of the efficient techniques of <ref> [AU, GW, HU1, HU2, Ke, KU1, Ta1, Ta2, Ta3, Ull] </ref> requires that G satisfies the structural restrictions imposed by these algorithms. 4 Flow graphs composed of basic blocks can be treated entirely in the same fashion replacing the predicate Used by the predicate Antloc (cf. [MR1]), indicating whether the computation of
References-found: 30

