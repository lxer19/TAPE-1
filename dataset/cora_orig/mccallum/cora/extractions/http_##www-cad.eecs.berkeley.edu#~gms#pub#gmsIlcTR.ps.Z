URL: http://www-cad.eecs.berkeley.edu/~gms/pub/gmsIlcTR.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~gms/projects/research.html
Root-URL: 
Title: Incremental Formal Design Verification  
Author: Gitanjali M. Swamy Robert K. Brayton 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Science. University of California at Berkeley  
Abstract: Language containment is a method for design verification that involves checking if the behavior of the system to be verified is a subset of the behavior of its specifications (properties or requirements). If this check fails, language containment returns a subset of `fair' states involved in behavior that the system exhibits but the specification does not. Current techniques for language containment do not take advantage of the fact that the process of design is incremental; namely that the designer repeatedly modifies and re-verifies his/her design. This results in unnecessary computation. We present a method that successively modifies the latest result of verification each time the design is modified. Our incremental algorithm translates changes made by the designer into an addition or subtraction of edges, states or constraints (on acceptable behavior) from the transition behavior or specification of the problem. Next, these changes are used to update the set of `fair' states previously computed. This incremental algorithm takes much less time than the current techniques for language containment; a conclusion supported by experimental results presented in this paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Touati, R. K. Brayton, and R. P. Kurshan, </author> <title> Checking Language Containment using BDDs, </title> <booktitle> in Proc. of Intl. Workshop on Formal Methods in VLSI Design, </booktitle> <address> (Miami, FL), </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: The problem of language containment has to be solved in this environment of interacting finite state machines. i 1 i 2 y 2 x 2 o 3 T 1 i 3 Current techniques <ref> [1, 2] </ref> perform language containment as a single pass. If the designer modifies the design after a solution has been obtained, then the entire language containment algorithm is repeated on the new design. In practice, the process of design is incremental; the designer modifies and re-verifies the design many times. <p> When P is expressed as an L-automaton, the problem of complementing P is solved by expressing it as an L-process <ref> [1] </ref>. The acceptance conditions for L-processes and L-automata are complementary and representing P by a L-process is easily done (if P is deterministic) by just keeping the same transition structure and complementing the acceptance conditions (the complementation is implicit by the choice of representation). <p> A language emptiness check remains to be done, and it is performed by checking the product automata D = M fi P for acceptable infinite behavior <ref> [1] </ref> (or fair paths), which indicate that the language for the system-property product machine is not empty. A cycle is associated with any infinitary behavior in a finite graph, and in order for this infinite behavior to be acceptable, this cycle must also satisfy the fairness constraints.
Reference: [2] <author> R. Hojati, T. R. Shiple, R. K. Brayton, and R. P. Kurshan, </author> <title> A Unified Environment for Language Containment and Fair CTL Model Checking, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <address> (Dallas, Texas), </address> <pages> pp. 475-481, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The problem of language containment has to be solved in this environment of interacting finite state machines. i 1 i 2 y 2 x 2 o 3 T 1 i 3 Current techniques <ref> [1, 2] </ref> perform language containment as a single pass. If the designer modifies the design after a solution has been obtained, then the entire language containment algorithm is repeated on the new design. In practice, the process of design is incremental; the designer modifies and re-verifies the design many times. <p> We introduce the concept of incremental verification, which allows multiple changes to the system but runs the entire language containment algorithm only once, and propagates successive changes or increments from the latest solution. The language containment algorithms of Touati et. al.[1] and Hojati et. al. <ref> [2] </ref> start with all reachable states, and successively reduce this until only the fair states remain. These algorithms are monotonic in nature, i.e., once a state is removed from the set of potential fair states, it is never added back. <p> Our algorithm uses information about the change in the system and the original set of fair states to derive a smaller superset of new fair states (smaller than the set of all reachable states). Then, it reduces this superset with an algorithm similar to <ref> [2] </ref>. Since this superset is much smaller than the set of all reachable states, the incremental algorithm converges faster. <p> The Reach Reachable States operator or RRS (T; S) is computed as follows: RRS (T; S) return (BR (T; S) [ F R (T; S)) 6. Forward Stable Set Operator <ref> [2] </ref>: Given a transition relation T (x; y) and a set of vertices A (x), the forward stable set operator or F SS (T; A) returns a set of states in A, which are on a cycle or can reach a cycle in A. <p> The following algorithm is used to compute the Forward Stable Set operator F SS : FSS (T; A) return (GF P (y; T (x; y); A (x))) 7. Forward Fair Path Operator <ref> [2] </ref>: Given T (x; y), the transition relation, A (x), a set of states and C, a set of fairness constraints, the forward fair path operator or F F P (T; C; A), returns a subset of states in A (x) which are on a fair path. <p> This set is also called the set of Fair states. In general, we compute a superset of this set called F air + , which consists of all states which are on a path to a fair cycle. Hojati et. al. <ref> [2] </ref> have presented an algorithm for computation of F air + , within a Streett environment. The algorithm computes F air + by starting with the set of reachable states, and alternately applying the FSS and FFP operators. <p> + Restrict the Transition Relation T (x; y) to reachable states Remove negative fair edges Set S 0 = Reachable states While S n+1 6= S n S 0 = F SS (T; S n ) return S n The proof of correctness of this algorithm can be found in <ref> [2] </ref>. This algorithm has a complexity of O (N 2 ), where N is the number of reachable states in the state space. <p> SS (T sub ; F air n ) return F air n Theorem 4.2 If the only changes induced in the system consist of subtraction of edges from the state transition graph then Algorithm 4.3 is correct and returns F air +new Proof From Lemma 4.1 and Hojati et. al. <ref> [2] </ref> Computing the conjunction of R sub , and F air + in step 4. of the Algorithm 4.3 is not necessary to the computation, but increases the efficiency, if the computation of R sub is not expensive. <p> Proof From Lemma 4.3 and Hojati et. al. <ref> [2] </ref>. As noted in Section 3, the set of reachable states can be used to simplify the BDD for the transition relation. In algorithm 4.3 the set of reachable states is not explicitly involved but may be used to simplify the transition relation BDD. <p> Proof From Lemma 4.5 and <ref> [2] </ref>. Using the same reasoning as Section 4.3, this algorithm has a time complexity of O (N D), where N is the number of reachable states. The addition of constraints can very easily be used in conjunction with the addition and subtraction of edges.
Reference: [3] <author> G. M. Swamy and R. K. Brayton, </author> <title> Incremental Formal Design Verification, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Section 5 describes the entire incremental language containment algorithm. Finally, we conclude by presenting experimental results, which demonstrate the efficacy of this method, in Section 6, and give future direction for this research in section 7. A shorter description of this work has been published in <ref> [3] </ref>. It is important to keep in mind that all operations are to be carried out in the context of the Binary Decision Diagram (BDD) data structure [4].
Reference: [4] <author> R. Bryant, </author> <title> Graph-based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. </pages> <address> 677--691, </address> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: A shorter description of this work has been published in [3]. It is important to keep in mind that all operations are to be carried out in the context of the Binary Decision Diagram (BDD) data structure <ref> [4] </ref>.
Reference: [5] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Implicit State Enumeration of Finite State Machines using BDD's, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: It is important to keep in mind that all operations are to be carried out in the context of the Binary Decision Diagram (BDD) data structure [4]. Even though not explicitly stated, all sets and relations are represented as their BDD's <ref> [5] </ref>. 2 Definitions Definition 1 Finite State Machine: A finite state machine or finite automaton M is a 5-tuple (Q; S; G; T; I) where * Q is a finite set of states * S is a finite set of input values * G is a finite set of output values
Reference: [6] <author> R. S. Streett, </author> <title> Propositional Dynamic Logic of Looping and Converse is Elementary Decidable, </title> <journal> Information and Control, </journal> <volume> vol. 54, </volume> <pages> pp. 121-141, </pages> <year> 1982. </year>
Reference-contexts: This path corresponds to behavior that is generated by the system but rejected by the task or property automaton and it is a witness to the failure of the property. The set of states which are involved in fair behavior are called Fair states. Definition 5 Streett Automata <ref> [6] </ref>: An FSM that accepts infinite behavior, which satisfies the Streett acceptance conditions is called a Streett automaton.
Reference: [7] <author> M. O. Rabin, </author> <title> Automata on Infinite Objects and Church's Problem, </title> <booktitle> vol. 13 of Regional Conf. Series in Mathematics. </booktitle> <address> Providence, Rhode Island: </address> <publisher> American Mathematical Society, </publisher> <year> 1972. </year>
Reference-contexts: In addition, fairness constraints may also be given in the form of Positive Fair Edge E i which must be traversed infinitely often and Negative Fair Edge N i which must not be traversed infinitely often in any accepting run r. Rabin Automata <ref> [7] </ref>: The fairness conditions for a Rabin Automaton are the complements of the fairness conditions for a Streett automaton, i.e., 8 i ((inf (r) " U i = ;) " (inf (r) 6 V i )). In addition, positive and negative fair edges constraints also exist.
Reference: [8] <author> R. P. Kurshan, </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: In addition, positive and negative fair edges constraints also exist. Definition 6 L-Automata: The L automaton <ref> [8] </ref> acceptance condition consists of a pair hR; Zi. R Q fi Q, is termed the recur edges, and Z 2 Q is the set of cycle sets.
Reference: [9] <author> E. A. Emerson, </author> <title> Temporal and Modal Logic, in Formal Models and Semantics (J. </title> <editor> van Leeuwen, ed.), </editor> <volume> vol. </volume> <booktitle> B of Handbook of Theoretical Computer Science, </booktitle> <pages> pp. 996-1072, </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: In general, r (x; y), where r is a relation, is the same as r (y; x) with x and y variables interchanged. 1. Least Fixed Point Computation <ref> [9] </ref>: Given an initial set of states S 0 (x), a transition relation T (x; y), and a variable set x, the least fixed point returns a function LF P (x; T; S 0 ) where LF P is computed as follows. <p> LFP (x; T (x; y); S n (x)) if (S n+1 = S n ) return S n else return LF P (x; T; S n+1 ) 2. Greatest Fixed Point Computation <ref> [9] </ref>: Given an initial set of states S 0 (x), a transition relation T (x; y), and a variable set x, the greatest fixed point returns a function GF P (x; T; S 0 ) where GF P is computed as follows.
Reference: [10] <author> M. Y. Vardi and P. L. Wolper, </author> <title> An Automata-Theoretic Approach to Program Verification, </title> <booktitle> in Proc. IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 332-334, </pages> <year> 1986. </year>
Reference-contexts: Note that this operator returns just a path and not necessarily an infinite path. The FFP operator can be computed by using the following algorithm: FFP (T; C; A) return (( Q Q 3 Previous Work Vardi and Wolper <ref> [10] </ref> observe that the problem of verifying whether a machine (M ) satisfies a given property (P ) reduces to the problem of checking whether the language of the machine automaton is contained in the language of the property automaton.
Reference: [11] <author> G. Ramalingam and T. Reps, </author> <title> On the Computational Complexity of Incremental Algorithms, </title> <type> Tech. Rep. TR 1033, </type> <institution> University of Wisconsion, Madison, University of Wisconsion, Madison, </institution> <year> 1991. </year>
Reference: [12] <author> R. Hojati, V. Singhal, and R. K. Brayton, </author> <title> Edge-Streett/Edge-Rabin Automata Environment for Formal Verification Using Language Containment, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M94/12, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1994. </year>
Reference-contexts: In our implementation, the designer is allowed to directly change the individual transition relations, or input process constraints and new processes via the intermediate `Pif' <ref> [12] </ref> format. 5.2 Incremental Language Containment The general algorithm for computation of F air +new is based on Algorithm 4.3 and Algorithm 4.4, with the additional caveat that the F F P is modified to account for the changes in the set of constraints.
Reference: [13] <author> R. Milner, </author> <title> Communication and Concurrency. </title> <address> New York: </address> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The first example, Gigamax, was a description of the gigamax distributed multiprocessor, using a shared memory architecture. The second example, Scheduler, describes a version of the scheduler example by Milner <ref> [13] </ref>, and the system consists of a token ring, where element of the ring, called a cell, communicates with its "job", and its two nearest neighbor cells. The third example, Tcp, describes a simplified version of the TCP/IP communication protocol.
Reference: [14] <author> R. Brayton et al., HSIS: </author> <title> A BDD-Based Environment for Formal Verification, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 454-459, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The third example, Tcp, describes a simplified version of the TCP/IP communication protocol. The final example, Idlc, describes an industrial data link controller example. All the examples were written in Verilog, and translated into the blif-mv format using the vl2mv translator <ref> [14] </ref>. All successive incremental changes were made directly to the system within the HSIS environment.
References-found: 14

