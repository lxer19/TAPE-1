URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/cikm94.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fhan, lingliu, zhaohuig@cs.sfu.ca  
Title: LogicBase: A Deductive Database System Prototype  
Author: Jiawei Han, Ling Liu and Zhaohui Xie 
Address: Burnaby, B.C., Canada V5A 1S6  
Affiliation: School of Computing Science Simon Fraser University  
Abstract: A deductive database system prototype, LogicBase, has been developed, with an emphasis on efficient compilation and query evaluation of application-oriented recursions in deductive databases. The system identifies different classes of recursions and compiles recursions into chain or pseudo-chain forms when appropriate. Queries posed to the compiled recursions are analyzed systematically with efficient evaluation plans generated and executed, mainly based on a chain-based query evaluation method. The system has been tested using sophisticated recursions and queries with satisfactory performance. This paper introduces the general design principles and implementation techniques of the system and discusses its strength and limitations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: Queries in different input/output mode combinations can be processed properly. For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", can be answered correctly and efficiently [10, 9]. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. <p> By such compilation, the selection-pushing technique can capture more bindings in complex recursions than those using traditional rule rewriting techniques, such as the magic rule rewriting <ref> [1, 26, 2] </ref>. This is illustrated by the following example [12]. Example 2.1 Traditional rule rewriting techniques may encounter some difficulties in the propagation of bindings in some recursive rules [12], which is demonstrated in the analysis of the following recursion. <p> It simulates partial transitive closure processing in the case of single chain recursion [14, 13] and the counting method <ref> [1, 6] </ref> in the case of multiple chain recursion. For example, the recursion length defined by f (2.9), (2.10)g can be compiled into a double-chain recursion. <p> Queries with other adornments can be analyzed and evaluated similarly. For query "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", the predicate queens should be evaluated first. Otherwise, it is unsafe to evaluate range bff . <p> It evaluates correctly not only the binding nqueens bf , such as "? nqueens (5; Qs)", but also other bindings, such as "? nqueens (N; <ref> [1; 3; 5; 2; 4] </ref>)", "? nqueens (N; [1; 3; 2; 5; 4; 11; 17; : : : ; 45]):" (a list containing more than 50 elments), "? nqueens (N; Qs)", etc. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. 1986 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation <ref> [2, 5, 17, 19, 27] </ref>, and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Queries in different input/output mode combinations can be processed properly. For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", can be answered correctly and efficiently [10, 9]. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. <p> By such compilation, the selection-pushing technique can capture more bindings in complex recursions than those using traditional rule rewriting techniques, such as the magic rule rewriting <ref> [1, 26, 2] </ref>. This is illustrated by the following example [12]. Example 2.1 Traditional rule rewriting techniques may encounter some difficulties in the propagation of bindings in some recursive rules [12], which is demonstrated in the analysis of the following recursion. <p> defined by EDB predicates a, b and e. r (X 1 ; X; Y ) e (X 1 ; X; Y ): (2.1) a (X; Y ); r (X 2 ; X 1 ; Y 1 ); b (X 2 ; Y 1 ): (2.2) Following the binding propagation rules <ref> [2, 26] </ref>, the bind ings in the adorned goal, r bbf , are propagated to the subgoal r in the body of the recursive rule, resulting in an adorned subgoal, r fbf , as shown in (2.3), which are in turn propa gated to the next expansion, resulting in r fff <p> Queries with other adornments can be analyzed and evaluated similarly. For query "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", the predicate queens should be evaluated first. Otherwise, it is unsafe to evaluate range bff . <p> It evaluates correctly not only the binding nqueens bf , such as "? nqueens (5; Qs)", but also other bindings, such as "? nqueens (N; <ref> [1; 3; 5; 2; 4] </ref>)", "? nqueens (N; [1; 3; 2; 5; 4; 11; 17; : : : ; 45]):" (a list containing more than 50 elments), "? nqueens (N; Qs)", etc. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [3] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Queries in different input/output mode combinations can be processed properly. For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", can be answered correctly and efficiently [10, 9]. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. <p> Queries with other adornments can be analyzed and evaluated similarly. For query "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", the predicate queens should be evaluated first. Otherwise, it is unsafe to evaluate range bff . <p> It evaluates correctly not only the binding nqueens bf , such as "? nqueens (5; Qs)", but also other bindings, such as "? nqueens (N; <ref> [1; 3; 5; 2; 4] </ref>)", "? nqueens (N; [1; 3; 2; 5; 4; 11; 17; : : : ; 45]):" (a list containing more than 50 elments), "? nqueens (N; Qs)", etc. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in <p> Queries posed to the compiled recursions are analyzed systematically with efficient query evaluation plan generated. Queries are executed mainly by chain-based evaluation, together with several other query evaluation methods, such as the generalized magic-sets method <ref> [3] </ref>, etc. The system has been tested and demonstrated on some interesting deductive database and logic programming programs, with satisfactory results and good performance [9]. The current implementation of LogicBase is a prototype for evaluation of deductive queries.
Reference: [4] <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15 </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: Queries in different input/output mode combinations can be processed properly. For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", can be answered correctly and efficiently [10, 9]. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. <p> By transforming functions into functional predicates, the compilation and evaluation techniques developed for function-free recursions can be extended to functional ones [7]. Furthermore, the method can be generalized to logical programs containing modularly stratified negation [19] and those with higher-order syntax and first-order semantics <ref> [4] </ref>. Therefore, compilation of recursions into chain and pseudo-chain forms represents a powerful program transformation technique which transforms recursion into simple, easily-analyzable forms and facilitates the application of efficient evaluation methods. In general, the chain-based query evaluation method consists of chain-following, chain-split, existence checking, and constraint-based evaluation techniques. <p> Queries with other adornments can be analyzed and evaluated similarly. For query "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", the predicate queens should be evaluated first. Otherwise, it is unsafe to evaluate range bff . <p> It evaluates correctly not only the binding nqueens bf , such as "? nqueens (5; Qs)", but also other bindings, such as "? nqueens (N; <ref> [1; 3; 5; 2; 4] </ref>)", "? nqueens (N; [1; 3; 2; 5; 4; 11; 17; : : : ; 45]):" (a list containing more than 50 elments), "? nqueens (N; Qs)", etc. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [5] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction As an important extension to relational approach, research into deductive database systems represents a direction towards declarative query processing, high-level database programming, and integration of logic programming and relational database technology [22]. Many deductive database systems or prototypes, such as LDL <ref> [5] </ref>, Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation <ref> [2, 5, 17, 19, 27] </ref>, and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> It evaluates correctly not only the binding nqueens bf , such as "? nqueens (5; Qs)", but also other bindings, such as "? nqueens (N; <ref> [1; 3; 5; 2; 4] </ref>)", "? nqueens (N; [1; 3; 2; 5; 4; 11; 17; : : : ; 45]):" (a list containing more than 50 elments), "? nqueens (N; Qs)", etc. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [26, 5, 27, 19] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL <ref> [5] </ref>, ADITI [27], NAIL! [26], CORAL [19], etc. are constructed based on this approach.
Reference: [6] <author> J. Han. </author> <title> Multi-way counting method. </title> <journal> Information Systems, </journal> <volume> 14 </volume> <pages> 219-229, </pages> <year> 1989. </year>
Reference-contexts: It simulates partial transitive closure processing in the case of single chain recursion [14, 13] and the counting method <ref> [1, 6] </ref> in the case of multiple chain recursion. For example, the recursion length defined by f (2.9), (2.10)g can be compiled into a double-chain recursion. <p> Similarly, chain-following evaluation [7] should be performed on queens bbf (U; S; Qs), chain-split evaluation should be on select fbf (X; Y Y s; Y Zs), and existence-checking evaluation <ref> [6] </ref> on attk bbb (X; N; Y Y s). Queries with other adornments can be analyzed and evaluated similarly. For query "? nqueens (N; [2; 4; 1; 3])", the predicate queens should be evaluated first. Otherwise, it is unsafe to evaluate range bff . <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [7] <author> J. Han. </author> <title> Constraint-based query evaluation in deductive databases. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 6 </volume> <pages> 96-107, </pages> <year> 1994. </year>
Reference-contexts: Such a quantitative analysis, similar to the access path selection and query plan generation for relational queries, can be performed based on the characteristics of the compiled chains, query instantiations, inquiries, integrity constraints, and database statistics of extensional relations <ref> [7] </ref>. Notice that quantitative analysis has been incorporated in many other recursion handling methods to generate different query evaluation plans as well. <p> By transforming functions into functional predicates, the compilation and evaluation techniques developed for function-free recursions can be extended to functional ones <ref> [7] </ref>. Furthermore, the method can be generalized to logical programs containing modularly stratified negation [19] and those with higher-order syntax and first-order semantics [4]. <p> Then the evaluation proceeds in a way similar to the evaluation of a multi-chain recursion, except that the corresponding buffered values should be patched in the latter evaluation. Such an evaluation technique is called chain-split evaluation <ref> [7] </ref>. Example 2.2 f (2.11), (2.12)g defines a recursion append, which can be compiled into a single-chain recursion. <p> W 1 ; W )" further, which derives the third set of the answer: fU = [a; b], V = []g. 2 2.3 Constraint-based query evaluation Besides the distinction of chain-following vs. chain-split eval uation, another important strength of the method is the systematic analysis and exploration of available constraints <ref> [7] </ref>. Taking the evaluation of a single-chain recursion as an example, we examine how to push query constraints (or in-stantiations) at both ends of a compiled chain. The processing should start at a more restrictive end (the start end) and proceeds to a less restrictive end (the finish end). <p> A systematic way to push query constraints at the finish end can be derived by examining the interactions between query constraints and monotonicity constraints <ref> [7] </ref>. If the value (or the mapped value) of an argument in the recursive predicate monotonically increases but does not converge to a limit during the evaluation, a query constraint which blocks such an increase is useful at reducing the search space in iterative evaluation. <p> Similarly, chain-following evaluation <ref> [7] </ref> should be performed on queens bbf (U; S; Qs), chain-split evaluation should be on select fbf (X; Y Y s; Y Zs), and existence-checking evaluation [6] on attk bbb (X; N; Y Y s). Queries with other adornments can be analyzed and evaluated similarly. <p> Based on the studies in <ref> [7, 12] </ref>, linear and nested linear recursions can be compiled into highly regular chain forms. Many complex recursions, though cannot be compiled into highly regular chains, may still have interesting regularities among the variable connections in the recursive rules. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [8] <author> J. Han and L. V. S. Lakshmanan. </author> <title> Evaluation of regular nonlinear recursions by deductive database techniques. </title> <note> In SFU CSS/LCCR Technical Report TR93-09, </note> <institution> Simon Fraser University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: such recursions, and queries such as "? hanoi (3; a; b; c; M oves)" or "?hanoi (N; a; b; c; [a to b; a to c; b to c; a to b; c to a; c to b; a to b]):" can still be analyzed systematically and be evaluated efficiently <ref> [8] </ref>. However, this does not imply that chain-based evaluation can be applied effectively to all kinds of recursions. This is because some recursions may not have regular variable passing patterns and cannot be compiled into chain or even pseudo-chain forms. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 3.2 For the nqeens recursion in Example 2.4, "? nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" is expected to generate only one answer "N = 8". <p> be fed into range bfb (1; N; N s) in equation (2.29), will consist of a number of 8! = 40,320 (intermediate) answers for N s, ranging from "<ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "[8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since N s must be a list whose sequence of elements have monotonically increasing values (called mono <p> This property confines the possible generation of the lists by select bfb to be mono inc list only, which substantially reduces the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 The analysis of Example 3.2 shows that some logic programs, originally coded by programmers with the program execution in one direction in mind, such as select fbf in
Reference: [9] <author> J. Han, L. Liu, and Z. Xie. LogicBase: </author> <title> A system prototype for deductive query evaluation. </title> <booktitle> In Proc. 1993 ILPS Workshop on Programming with Logic Databases, </booktitle> <pages> pages 146-160, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: The LogicBase system (demonstrated in the workshop on "Programming with Logic Databases", associated with "1993 International Logic Programming Symposium" <ref> [9] </ref>) has the following major features. * Query-independent compilation captures the bindings that could be difficult to be captured otherwise and derives highly-regular and precise compiled chain pro grams for query analysis and evaluation. * Chain-based evaluation, including a set of interesting techniques, such as chain-following, chain-split, constraint pushing, partial evaluation, <p> For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; [2; 4; 1; 3])", can be answered correctly and efficiently <ref> [10, 9] </ref>. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. A discussion of the applicability of the methodology and a method for further reduction of search space are presented in Section 3. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> Queries are executed mainly by chain-based evaluation, together with several other query evaluation methods, such as the generalized magic-sets method [3], etc. The system has been tested and demonstrated on some interesting deductive database and logic programming programs, with satisfactory results and good performance <ref> [9] </ref>. The current implementation of LogicBase is a prototype for evaluation of deductive queries.
Reference: [10] <author> J. Han and T. Lu. </author> <title> N-queens problem revisited: A deductive database approach. </title> <booktitle> In Proc. 1992 IJCSLP Workshop on Deductive Databases, </booktitle> <pages> pages 48-55, </pages> <address> Wash-inton D.C., </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: For example, in the nqueens (N; Qs) recursion of Ex. 2.4, the predicates or rules in the program can be swapped randomly, and the queries, such as "? nqueens (5; Qs)", and "? nqueens (N; [2; 4; 1; 3])", can be answered correctly and efficiently <ref> [10, 9] </ref>. To illustrate the interestingness of the LogicBase, the ma-jor features of the system are analyzed in Section 2 based on a set of examples. A discussion of the applicability of the methodology and a method for further reduction of search space are presented in Section 3. <p> Example 3.1 The adorned predicate sort fb for a recursion sort (Original List; Sorted List), implies to find all of the original lists which can be sorted into a given Sorted List. A query, "?sort (Original; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers.
Reference: [11] <author> J. Han and W. Lu. </author> <title> Asynchronous chain recursions. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 1 </volume> <pages> 185-195, </pages> <year> 1989. </year>
Reference-contexts: Finally, Section 4 summarizes our discussion and outlines the future development plan. 2 Major Features of LogicBase Although recursions can be in complex forms, most recursions in practical applications can be compiled into chain or chain-like forms to which efficient query analysis and evaluation techniques can be explored <ref> [12, 11] </ref>. The design of LogicBase is based on this regularity of recursion and the strength of chain-based compilation and evaluation. 2.1 Capture of more bindings in query binding propaga tion First, LogicBase compiles complex recursions into highly regular chain forms. <p> The classification unit takes a complex recursive program as input, rectifies it, eliminates mutual recursions when pos sible, simplifies the recursion when appropriate, and identifies the class of recursions to which the program belongs <ref> [11] </ref>. By this processing, a recursion is classified into one of the following classes: (1) (single) linear recursion, (2) nested linear recursion, (3) multiple linear recursion, (4) regular nonlinear recursion, and (5) irregular recursion [11]. <p> simplifies the recursion when appropriate, and identifies the class of recursions to which the program belongs <ref> [11] </ref>. By this processing, a recursion is classified into one of the following classes: (1) (single) linear recursion, (2) nested linear recursion, (3) multiple linear recursion, (4) regular nonlinear recursion, and (5) irregular recursion [11]. The compilation unit (based on [12, 11]) takes the pre processed recursion and compiles (normalizes) it into a chain program, when possible, based on a compilation (normalization) algorithm described in [12]. Furthermore, algebraic simplification is performed on the compiled expressions. <p> By this processing, a recursion is classified into one of the following classes: (1) (single) linear recursion, (2) nested linear recursion, (3) multiple linear recursion, (4) regular nonlinear recursion, and (5) irregular recursion [11]. The compilation unit (based on <ref> [12, 11] </ref>) takes the pre processed recursion and compiles (normalizes) it into a chain program, when possible, based on a compilation (normalization) algorithm described in [12]. Furthermore, algebraic simplification is performed on the compiled expressions.
Reference: [12] <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <pages> 299-322, </pages> <year> 1992. </year>
Reference-contexts: The LogicBase project adopts a different approach. It adopts query-independent compilation and chain-based query evaluation, where the former <ref> [12] </ref> transforms a set of deduction rules into highly regular compiled forms, which facilitates quantitative analysis of queries and efficient query evaluation; whereas the latter explores set-oriented evaluation of each compiled chain with appropriate constraint transformation and push, which reduces unnecessary or redundant computation and facilitates the judgement of termination. <p> Finally, Section 4 summarizes our discussion and outlines the future development plan. 2 Major Features of LogicBase Although recursions can be in complex forms, most recursions in practical applications can be compiled into chain or chain-like forms to which efficient query analysis and evaluation techniques can be explored <ref> [12, 11] </ref>. The design of LogicBase is based on this regularity of recursion and the strength of chain-based compilation and evaluation. 2.1 Capture of more bindings in query binding propaga tion First, LogicBase compiles complex recursions into highly regular chain forms. <p> By such compilation, the selection-pushing technique can capture more bindings in complex recursions than those using traditional rule rewriting techniques, such as the magic rule rewriting [1, 26, 2]. This is illustrated by the following example <ref> [12] </ref>. Example 2.1 Traditional rule rewriting techniques may encounter some difficulties in the propagation of bindings in some recursive rules [12], which is demonstrated in the analysis of the following recursion. <p> This is illustrated by the following example <ref> [12] </ref>. Example 2.1 Traditional rule rewriting techniques may encounter some difficulties in the propagation of bindings in some recursive rules [12], which is demonstrated in the analysis of the following recursion. <p> Such a propagation cannot be caught by the traditional approaches but can be captured by the compilation (or normalization) of linear recursions <ref> [12] </ref>. <p> By this processing, a recursion is classified into one of the following classes: (1) (single) linear recursion, (2) nested linear recursion, (3) multiple linear recursion, (4) regular nonlinear recursion, and (5) irregular recursion [11]. The compilation unit (based on <ref> [12, 11] </ref>) takes the pre processed recursion and compiles (normalizes) it into a chain program, when possible, based on a compilation (normalization) algorithm described in [12]. Furthermore, algebraic simplification is performed on the compiled expressions. <p> The compilation unit (based on [12, 11]) takes the pre processed recursion and compiles (normalizes) it into a chain program, when possible, based on a compilation (normalization) algorithm described in <ref> [12] </ref>. Furthermore, algebraic simplification is performed on the compiled expressions. <p> Dynamic transformation and push of query constraints have been implemented in LogicBase and demonstrated using many examples, including the air-flight reservation. 2.4 Chain-based evaluation of complex classes of recur sions Since a (single) linear recursion can be compiled into a chain form or a bounded recursion <ref> [12] </ref>, chain-based evaluation can be applied to this class of recursion. Similarly, a nested linear recursion (a linear recursion in which some subgoal (s) in the rule are defined in turn by linear recursion (s)) can also be so compiled and evaluated. <p> Based on the studies in <ref> [7, 12] </ref>, linear and nested linear recursions can be compiled into highly regular chain forms. Many complex recursions, though cannot be compiled into highly regular chains, may still have interesting regularities among the variable connections in the recursive rules. <p> Second, it evaluates a program declaratively (i.e., in order-independent and query-mode independent fashion), and thus requires sophisticated query analysis and query optimization techniques. The limitation of the chain-based query evaluation technique is that the compilation method is confined to the recursions that can be compiled into highly regular forms <ref> [12] </ref>. In contrast, the Magic Sets method is applicable to general function-free recursions. However, this method facilitates quantitative analysis of compiled recursions and, therefore, can reduce search space more accurately than the Magic Sets method.
Reference: [13] <author> Y. E. Ioannidis and R. Ramakrishnan. </author> <title> Efficient transitive closure algorithms. </title> <booktitle> In Proc. 14th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 382-394, </pages> <address> Long Beach, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> It simulates partial transitive closure processing in the case of single chain recursion <ref> [14, 13] </ref> and the counting method [1, 6] in the case of multiple chain recursion. For example, the recursion length defined by f (2.9), (2.10)g can be compiled into a double-chain recursion.
Reference: [14] <author> B. Jiang. </author> <title> A suitable algorithm for computing partial transitive closures. </title> <booktitle> In Proc. 6th Int. Conf. Data Engineering, </booktitle> <pages> pages 264-271, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> It simulates partial transitive closure processing in the case of single chain recursion <ref> [14, 13] </ref> and the counting method [1, 6] in the case of multiple chain recursion. For example, the recursion length defined by f (2.9), (2.10)g can be compiled into a double-chain recursion.
Reference: [15] <author> R. E. Korf. </author> <title> Linear-space best-first search: Summary of results. </title> <booktitle> In Proc. 10th National Conf. on AI, AAAI-92, </booktitle> <pages> pages 533-538, </pages> <address> San Jose, CA, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [29] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [28, 15, 30, 25] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [28, 30, 25].
Reference: [16] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding query power in constraint logic programming languages. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pages 20-36, </pages> <address> Cleveland, OH, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Obviously, this is quite different from the implementations of Prolog [24] which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive effi cient query evaluation plans. Recent studies on constraint logic programming, such as <ref> [28, 16] </ref>, enforce more constraints than Prolog but still mainly confine the program evaluation ordering to those given by programmers.
Reference: [17] <author> S. Morishita, M. Derr, and G. Phipps. </author> <title> Design and implementation of the Glue-Nail database system. </title> <booktitle> In Proc. 1993 ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 147-156, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction As an important extension to relational approach, research into deductive database systems represents a direction towards declarative query processing, high-level database programming, and integration of logic programming and relational database technology [22]. Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! <ref> [17] </ref>, CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation <ref> [2, 5, 17, 19, 27] </ref>, and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21].
Reference: [18] <author> I.S. Mumick, H. Pirahesh, and R. Ramakrishnan. </author> <title> The magic of duplicates and aggregates. </title> <booktitle> In Proc. 16th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 264-277, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The current implementation of LogicBase is a prototype for evaluation of deductive queries. The following two major features are being incorporated in the future development, with the incorporation of the recent research results in deductive databases <ref> [18, 20, 23] </ref>. * Aggregation and modularly stratified negation. * Towards a deductive and object-oriented database sys tem.
Reference: [19] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Coral control, relations and logic. </title> <booktitle> In Proc. 18th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 547-559., </pages> <address> Vancou-ver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation <ref> [2, 5, 17, 19, 27] </ref>, and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> By transforming functions into functional predicates, the compilation and evaluation techniques developed for function-free recursions can be extended to functional ones [7]. Furthermore, the method can be generalized to logical programs containing modularly stratified negation <ref> [19] </ref> and those with higher-order syntax and first-order semantics [4]. Therefore, compilation of recursions into chain and pseudo-chain forms represents a powerful program transformation technique which transforms recursion into simple, easily-analyzable forms and facilitates the application of efficient evaluation methods. <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [26, 5, 27, 19] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [5], ADITI [27], NAIL! [26], CORAL <ref> [19] </ref>, etc. are constructed based on this approach. <p> For example, the Magic Sets method cannot evaluate the nqueens recursion in predicate order-independent and query-mode independent fashion <ref> [19] </ref>. Similar comments can be applied to the EKS-V1 system [29] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [28, 15, 30, 25].
Reference: [20] <author> K. Ross and Y. Sagiv. </author> <title> Monotonic aggregation in deductive databases. </title> <booktitle> In Proc. 11th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 114-126, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The current implementation of LogicBase is a prototype for evaluation of deductive queries. The following two major features are being incorporated in the future development, with the incorporation of the recent research results in deductive databases <ref> [18, 20, 23] </ref>. * Aggregation and modularly stratified negation. * Towards a deductive and object-oriented database sys tem.
Reference: [21] <author> K. Sagonas, T. Swift, and D. S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proc. 1994 ACM SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 442-453, </pages> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB <ref> [21] </ref>, etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method <ref> [21] </ref>.
Reference: [22] <author> A. Silberschatz, M. Stonebraker, and J. D. Ullman. </author> <title> Database systems: Achievements and opportunities. </title> <journal> Comm. ACM, </journal> <volume> 34 </volume> <pages> 94-109, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction As an important extension to relational approach, research into deductive database systems represents a direction towards declarative query processing, high-level database programming, and integration of logic programming and relational database technology <ref> [22] </ref>. Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems.
Reference: [23] <author> D. Srivastava, R. Ramakrishnan, P. Seshadri, and S. Sudarshan. </author> <title> Coral++: Adding object-orientation to a logic database language. </title> <booktitle> In Proc. 19th Int. Conf. Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction As an important extension to relational approach, research into deductive database systems represents a direction towards declarative query processing, high-level database programming, and integration of logic programming and relational database technology [22]. Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ <ref> [23] </ref>, EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> The current implementation of LogicBase is a prototype for evaluation of deductive queries. The following two major features are being incorporated in the future development, with the incorporation of the recent research results in deductive databases <ref> [18, 20, 23] </ref>. * Aggregation and modularly stratified negation. * Towards a deductive and object-oriented database sys tem.
Reference: [24] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Similarly, a nested linear recursion (a linear recursion in which some subgoal (s) in the rule are defined in turn by linear recursion (s)) can also be so compiled and evaluated. Example 2.4 A typical n-queens recursion defined in <ref> [24] </ref> is a nested linear recursion whose query analysis can be performed as follows. For a query, "?nqueens (4; Qs)", the binding pattern for nqueens is nqueens bf (N; Qs). The bf binding of nqueens leads to range bbf and queens bbf if range is evaluated first. <p> Fur thermore, it executes successfully many other interesting, and/or sophisticated logic programs, such as sublist, mirror, insertion sort, wolf goat cabbage, etc. in rule/subgoal order-independent, and query input/output mode-independent fashion. Most of these programs are from a typical logic programming textbook <ref> [24] </ref>. 3 Discussions The above analysis of the evaluation of different query in-stantiations for the nqueens-recursion discloses an interesting fact: A logic program can be executed declaratively, independent of query modes and rule/predicate ordering. Moreover, it derives the complete set of answers and terminates properly. <p> Moreover, it derives the complete set of answers and terminates properly. Obviously, this is quite different from the implementations of Prolog <ref> [24] </ref> which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive effi cient query evaluation plans. <p> Many complex recursions, though cannot be compiled into highly regular chains, may still have interesting regularities among the variable connections in the recursive rules. For example, the recursion tower of hanoi with the head predicate "hanoi (N; A; B; C; M oves)" <ref> [24] </ref> is a typical nonlinear recursion which cannot be compiled into highly regular chain forms.
Reference: [25] <author> L. A. Taylor and R. E. Korf. </author> <title> Pruning duplicate nodes in depth-first search. </title> <booktitle> In Proc. 11th National Conf. on AI, AAAI-93, </booktitle> <pages> pages 756-761, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [29] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [28, 15, 30, 25] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [28, 30, 25]. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [28, 30, 25] </ref>. The LogicBase approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
Reference: [26] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Vol. 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> By such compilation, the selection-pushing technique can capture more bindings in complex recursions than those using traditional rule rewriting techniques, such as the magic rule rewriting <ref> [1, 26, 2] </ref>. This is illustrated by the following example [12]. Example 2.1 Traditional rule rewriting techniques may encounter some difficulties in the propagation of bindings in some recursive rules [12], which is demonstrated in the analysis of the following recursion. <p> defined by EDB predicates a, b and e. r (X 1 ; X; Y ) e (X 1 ; X; Y ): (2.1) a (X; Y ); r (X 2 ; X 1 ; Y 1 ); b (X 2 ; Y 1 ): (2.2) Following the binding propagation rules <ref> [2, 26] </ref>, the bind ings in the adorned goal, r bbf , are propagated to the subgoal r in the body of the recursive rule, resulting in an adorned subgoal, r fbf , as shown in (2.3), which are in turn propa gated to the next expansion, resulting in r fff <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [26, 5, 27, 19] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [5], ADITI [27], NAIL! <ref> [26] </ref>, CORAL [19], etc. are constructed based on this approach.
Reference: [27] <author> J. Vaghani, K. Ramamohanarao, D. Kemp, Z. Somogyi, and P. Stuckey. </author> <title> An introduction to the ADITI deductive database system. </title> <journal> Australian Computer Journal, </journal> <volume> 23 </volume> <pages> 37-52, </pages> <year> 1991. </year>
Reference-contexts: Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI <ref> [27] </ref>, XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 [29], ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches <ref> [2, 26, 5, 17, 19, 27, 14, 13] </ref> lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation <ref> [2, 5, 17, 19, 27] </ref>, and (2) top-down evaluation, represented by the query/subquery approach [29] and the tuple-at-a-time with memoing method [21]. <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [26, 5, 27, 19] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [5], ADITI <ref> [27] </ref>, NAIL! [26], CORAL [19], etc. are constructed based on this approach.
Reference: [28] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Obviously, this is quite different from the implementations of Prolog [24] which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive effi cient query evaluation plans. Recent studies on constraint logic programming, such as <ref> [28, 16] </ref>, enforce more constraints than Prolog but still mainly confine the program evaluation ordering to those given by programmers. <p> Similar comments can be applied to the EKS-V1 system [29] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [28, 15, 30, 25] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [28, 30, 25]. <p> The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [28, 15, 30, 25]. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction <ref> [28] </ref>. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [28, 30, 25]. The LogicBase approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [28, 30, 25] </ref>. The LogicBase approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
Reference: [29] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <address> Boston, MA, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction As an important extension to relational approach, research into deductive database systems represents a direction towards declarative query processing, high-level database programming, and integration of logic programming and relational database technology [22]. Many deductive database systems or prototypes, such as LDL [5], Glue-NAIL! [17], CORAL++ [23], EKS-V1 <ref> [29] </ref>, ADITI [27], XSB [21], etc. have been developed and reported in recent years. Efficient query evaluation in deductive databases is an essential issue in the realization of deductive database systems. <p> Previous researches [2, 26, 5, 17, 19, 27, 14, 13] lead to two influential classes of deductive query evaluation methods: (1) bottom-up evaluation, represented by magic sets computation and semi-naive evaluation [2, 5, 17, 19, 27], and (2) top-down evaluation, represented by the query/subquery approach <ref> [29] </ref> and the tuple-at-a-time with memoing method [21]. <p> For example, the Magic Sets method cannot evaluate the nqueens recursion in predicate order-independent and query-mode independent fashion [19]. Similar comments can be applied to the EKS-V1 system <ref> [29] </ref> which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [28, 15, 30, 25].
Reference: [30] <author> W. Zhang and R. E. Korf. </author> <title> Depth-first vs. best-first search: New results. </title> <booktitle> In Proc. 11th National Conf. on AI, AAAI-93, </booktitle> <pages> pages 769-775, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [29] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [28, 15, 30, 25] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [28, 30, 25]. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [28]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [28, 30, 25] </ref>. The LogicBase approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
References-found: 30

