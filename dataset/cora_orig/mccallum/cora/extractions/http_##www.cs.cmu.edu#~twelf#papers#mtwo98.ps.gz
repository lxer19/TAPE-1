URL: http://www.cs.cmu.edu/~twelf/papers/mtwo98.ps.gz
Refering-URL: http://www.cs.cmu.edu/~twelf/
Root-URL: 
Email: carsten@cs.cmu.edu fp@cs.cmu.edu  
Title: Automated Theorem Proving in a Simple Meta Logic for LF  
Author: Carsten Schurmann and Frank Pfenning 
Affiliation: Carnegie Mellon University School of Computer Science  
Abstract: Higher-order representation techniques allow elegant encodings of logics and programming languages in the logical framework LF, but unfortunately they are fundamentally incompatible with induction principles needed to reason about them. In this paper we develop a meta-logic M 2 which allows inductive reasoning over such LF encodings, and describe its implementation in Twelf, a special-purpose automated theorem prover for properties of logics and programming languages. We have used Twelf to automatically prove a number of non-trivial theorems, including type preservation for Mini-ML and the deduction theorem for intuitionistic propositional logic.
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> Henk Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of logic in Computer Science, </booktitle> <volume> volume II, </volume> <pages> pages 118-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Section 5 compares the most closely related work before we assess the results and discuss future work. 2 The Logical Framework The type theory underlying the logical framework LF is an extension of the simply-typed -calculus by dependent types. It also appears under the name P in Baren-dregt's -cube <ref> [Bar92] </ref>.
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: On the other hand, McDowell has demonstrated the flexibility of his approach in his thesis [McD97] where he also treats a logical framework which incorporates linearity. Since the overall architecture is quite similar, this gives us confidence that our approach may be extended to a linear logical framework <ref> [CP96] </ref>, which is planned in future work. We believe that the separation between logical framework and meta-logic, and the separation between definition by cases and well-founded recursion are all critical ingredients in making this idea successful for even richer logical frameworks than LF.
Reference: [DPS97] <author> Joelle Despeyroux, Frank Pfenning, and Carsten Schurmann. </author> <title> Primitive recursion for higher-order abstract syntax. </title> <editor> In R. Hindley, editor, </editor> <booktitle> Proceedings fo the Third International Conference on Typed Lambda Calculus and Applications (TLCA'97), </booktitle> <address> Nancy, France, April 1997. </address> <publisher> Springer-Verlag LNCS. </publisher>
Reference-contexts: The first called schema-checking [Roh94,RP96] implements meta-theoretic proofs as relations whose ? This work was sponsored by NSF Grant CCR-9619584 1 See <ref> [DPS97] </ref> for a detailed analysis. operational reading as logic programs realizes the informal proofs. This has been applied successfully in many case studies (see [Pfe96]), but lacks automation. The second is based on reflection via a modal provability operator. <p> This has been applied successfully in many case studies (see [Pfe96]), but lacks automation. The second is based on reflection via a modal provability operator. At present it is unclear how this idea, developed for simple types in <ref> [DPS97] </ref>, interacts with dependent types, and if it is flexible enough for many of the theorems that can be treated with schema-checking. The third is to devise an explicit (meta-)meta-logic for reasoning about logical framework encodings. <p> Unfortunately, such a function does not exist in LF, since it would have to be defined by primitive recursion over its first argument, and primitive recursion is not available in LF. Moreover, straightforward attempts to add primitive recursion render the higher-order representations inadequate. This is discussed in detail in <ref> [DPS97] </ref>. <p> We are currently investigating how to incorporate ideas from schema-checking [Roh94] and primitive recursion over higher-order abstract syntax <ref> [DPS97] </ref> into our meta-logical framework in order to make progress on item (3), that is, allow reasoning over terms which may have free variables from certain "regular" contexts which arises in many practical examples.
Reference: [Eri94] <author> Lars-Henrik Eriksson. </author> <title> Pi: An interactive derivation editor for the calculus of partial inductive definitions. </title> <editor> In Alan Bundy, editor, </editor> <booktitle> Proceedings of the Twelfth In 16 ternational Conference on Automated Deduction, </booktitle> <pages> pages 821-825. </pages> <publisher> Springer-Verlag LNAI 814, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Moreover, in order to establish consistency for their meta-logic, they limit induction to natural numbers, which also complicates automation. In fact, their implementation based on the Pi proof editor <ref> [Eri94] </ref> is entirely interactive. On the other hand, McDowell has demonstrated the flexibility of his approach in his thesis [McD97] where he also treats a logical framework which incorporates linearity.
Reference: [Geu92] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduction in typed - calculi. </title> <editor> In A. Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In a slight departure from [HHP93] we take fi-conversion as our notion of definitional equality, since this guarantees that every well-typed object has an equivalent canonical form, that is, a long fi-normal form. The requisite theory may, for example, be found in <ref> [Geu92] </ref>. As a running example we will use Mini-ML in the formulation of [Pfe92] which goes back to [MP91], culminating in an automatic proof of type preservation.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The logical framework LF <ref> [HHP93] </ref> has been designed as a meta-language for representing deductive systems which are common in the study of logics and programming languages. <p> It also appears under the name P in Baren-dregt's -cube [Bar92]. It is defined by three syntactic categories of objects, type families, and kinds <ref> [HHP93] </ref>. 2 See Section 5 for a more detailed comparison. 2 Kinds: K ::= type j x : A: K Type Families: A ::= a j A M j x : A 1 : A 2 Objects: M ::= c j x j x : A: M j M 1 M <p> We generally assume that signature is valid and fixed and therefore omit it from the typing and other related judgments introduced later on. We will also need to explicitly require the validity of contexts, written as ` ctx. In a slight departure from <ref> [HHP93] </ref> we take fi-conversion as our notion of definitional equality, since this guarantees that every well-typed object has an equivalent canonical form, that is, a long fi-normal form. The requisite theory may, for example, be found in [Geu92]. <p> By using the limited permutation properties of LF <ref> [HHP93] </ref> this can always be established.
Reference: [Mag95] <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: However, various lemmas regarding substitution must still be shown and used, which severely limits the degree of automation which can be achieved. Most closely related to our own efforts in this area is the work on ALF <ref> [Mag95] </ref>, since ALF also employ dependently typed pattern matching and termination orderings, although without the benefits of higher-order abstract syntax.
Reference: [McD97] <author> Raymond McDowell. </author> <title> Reasoning in a logic with definitions and induction. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1997. </year>
Reference-contexts: Moreover, in order to establish consistency for their meta-logic, they limit induction to natural numbers, which also complicates automation. In fact, their implementation based on the Pi proof editor [Eri94] is entirely interactive. On the other hand, McDowell has demonstrated the flexibility of his approach in his thesis <ref> [McD97] </ref> where he also treats a logical framework which incorporates linearity. Since the overall architecture is quite similar, this gives us confidence that our approach may be extended to a linear logical framework [CP96], which is planned in future work.
Reference: [MM97] <author> Raymond McDowell and Dale Miller. </author> <title> A logic for reasoning with higher-order abstract syntax: An extended abstract. </title> <editor> In Glynn Winskel, editor, </editor> <booktitle> Proceedings of the Twelfth Annual Symposium on Logic in Computer Science, </booktitle> <address> Warsaw, Poland, </address> <month> June </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: In this approach, we have no automation besides 15 type reconstruction. The expressive power of LF makes this feasible, but it remains tedious. Most closely related to our approach is work by McDowell and Miller <ref> [MM97] </ref> who also define a meta-logic F O IN for a logical framework (hereditary Harrop formulas) and then reason in the meta-logic. Their approach is based entirely on simple types and does not incorporate proof terms, which makes it less suitable for automation.
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: The requisite theory may, for example, be found in [Geu92]. As a running example we will use Mini-ML in the formulation of [Pfe92] which goes back to <ref> [MP91] </ref>, culminating in an automatic proof of type preservation. While space only permits showing the fragment including abstraction, application, and recursion, our automatic proof also treats the remaining features of Mini-ML including polymorphism and an inductively defined type. Mini-ML expressions are represented by canonical LF objects of type exp.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Also, because of the higher-order nature of the term language, we need to deal with the undecidability of the full higher-order unification problem. Our solution is to restrict the analysis of possible cases to Miller's higher-order patterns, generalized to the setting of dependent types <ref> [Pfe91] </ref>. However, we do not restrict our system to patterns statically, since this would preclude, for example, the direct appeal to substitution or substitution lemmas at the level of LF. Instead, we simply rule out definition by cases where determining the possible cases would require unification beyond the pattern fragment.
Reference: [Pfe92] <author> Frank Pfenning. </author> <title> Computation and deduction. </title> <booktitle> Unpublished lecture notes, </booktitle> <pages> 277 pp. </pages> <month> Revised May </month> <year> 1994, </year> <month> April </month> <year> 1996, </year> <month> May </month> <year> 1992. </year>
Reference-contexts: The requisite theory may, for example, be found in [Geu92]. As a running example we will use Mini-ML in the formulation of <ref> [Pfe92] </ref> which goes back to [MP91], culminating in an automatic proof of type preservation. While space only permits showing the fragment including abstraction, application, and recursion, our automatic proof also treats the remaining features of Mini-ML including polymorphism and an inductively defined type.
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: It allows concise encodings of many common inference systems, such as natural deduction and sequent calculi, type systems, operational semantics, compilers, abstract machines, etc. (see [Pfe96] for a survey). These representations often lead directly to implementations, either via the constraint logic programming paradigm <ref> [Pfe94] </ref> or via general search using tactics and tacticals. The logical framework derives its expressive power from the use of dependent types together with "higher-order" representation techniques which directly support common concepts in deductive systems, such as variable binding and capture-avoiding substitution, parametric and hypothetical judgments, and substitution properties. <p> We call this step filling. It is basically a straightforward, iterative-deepening search over an LF signature and is derived from a related implementation of resolution for logic programming <ref> [Pfe94] </ref>.
Reference: [Pfe96] <author> Frank Pfenning. </author> <title> The practice of logical frameworks. </title> <editor> In Helene Kirchner, editor, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 119-134, </pages> <address> Linkoping, Sweden, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1059. Invited talk. </note>
Reference-contexts: It allows concise encodings of many common inference systems, such as natural deduction and sequent calculi, type systems, operational semantics, compilers, abstract machines, etc. (see <ref> [Pfe96] </ref> for a survey). These representations often lead directly to implementations, either via the constraint logic programming paradigm [Pfe94] or via general search using tactics and tacticals. <p> The first called schema-checking [Roh94,RP96] implements meta-theoretic proofs as relations whose ? This work was sponsored by NSF Grant CCR-9619584 1 See [DPS97] for a detailed analysis. operational reading as logic programs realizes the informal proofs. This has been applied successfully in many case studies (see <ref> [Pfe96] </ref>), but lacks automation. The second is based on reflection via a modal provability operator. At present it is unclear how this idea, developed for simple types in [DPS97], interacts with dependent types, and if it is flexible enough for many of the theorems that can be treated with schema-checking. <p> From the area of category theory, it proved that Cartesian closed categories can be embedded into the simply-typed -calculus. 5 Related Work and Future Work There have been many mechanized proofs of meta-theoretic properties of logics or programming languages in the literature (see the survey <ref> [Pfe96] </ref>). Most of these do not use techniques from logical frameworks, but represent the languages via standard inductive types and their semantics by inductively defined predicates. A popular choice for such encodings are de Bruijn indices, since they eliminate the problem of ff-conversion from consideration.
Reference: [PR92] <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: At the opposite extreme we have work on representing meta-theoretic proofs as relations in LF, which leaves the progress and termination properties above to an external check on relations (only type soundness is directly guaranteed by type-checking in LF) <ref> [PR92] </ref>. In this approach, we have no automation besides 15 type reconstruction. The expressive power of LF makes this feasible, but it remains tedious.
Reference: [Roh94] <author> Ekkehard Rohwedder. </author> <title> Verifying the meta-theory of deductive systems. </title> <type> Thesis Proposal, </type> <month> February </month> <year> 1994. </year>
Reference-contexts: Nonetheless, we have currently no plans for developing Twelf into a general-purpose theorem prover, because we feel that its present success owes mostly to its design as a special-purpose prover for properties of programming languages and logics. We are currently investigating how to incorporate ideas from schema-checking <ref> [Roh94] </ref> and primitive recursion over higher-order abstract syntax [DPS97] into our meta-logical framework in order to make progress on item (3), that is, allow reasoning over terms which may have free variables from certain "regular" contexts which arises in many practical examples.
Reference: [RP96] <author> Ekkehard Rohwedder and Frank Pfenning. </author> <title> Mode and termination checking for higher-order logic programs. </title> <editor> In Hanne Riis Nielson, editor, </editor> <booktitle> Proceedings of the European Symposium on Programming, </booktitle> <pages> pages 296-310, </pages> <address> Linkoping, Sweden, April 1996. </address> <publisher> Springer-Verlag LNCS 1058. </publisher>
Reference-contexts: Thus the side condition on the rule. For termination we use arbitrary lexicographic extensions of the subterm ordering on LF objects described in <ref> [RP96] </ref>, all of which are well-founded orderings and easy to check due to the restricted nature of our meta-logic. 3.4 Adding Case Analysis The context of Eigenvariables in the judgment ; ` P 2 F represents all LF variables which might occur free in the proof term P . <p> It is now possible to appeal to the induction hypothesis in an operation we call recursion. The termination condition of the fix-rule requires that it is only applied to a term smaller than D = ev fix D 1 . According to the termination ordering in <ref> [RP96] </ref> there is only one possibility, namely D 1 . We cannot appeal to the induction hypothesis without providing a typing derivation as second argument. Formally, the representation of this derivation must be of type `of (E (fix E)) T'. <p> In particular, we completely avoid backtracking except during the filling step which is implemented as an iterative deepening depth-first search. Splitting and filling (and sometimes also recursion) use unification to analyze cases and to select constants. Recursion triggers the calculation of possible recursion arguments according to the termination ordering <ref> [RP96] </ref>. For a given theorem and induction principle, Twelf attempts to construct a derivation in M 2 using the strategy sketched in Figure 4. There is a global store of yet to be proven subgoals, initialized with the formula representing the theorem.
Reference: [Sch98] <author> Carsten Schurmann. </author> <title> Automating the meta theory of deductive systems. </title> <type> Technical Report CMU-CS-98-???, </type> <institution> Carnegie Mellon University, </institution> <year> 1998. </year> <month> forthcoming. </month>
Reference-contexts: We therefore present here only a restriction of M 2 , where pattern matching subjects must be of atomic type. For a complete presentation of the meta logic we refer the interested reader to the detailed forthcoming technical report <ref> [Sch98] </ref>. <p> A further extension of M 2 is the introduction of conjunction as formula and corresponding 8 pairs as proof terms. These constructs are required for the representation of mutual inductive proofs, but omitted here for the sake of brevity (see <ref> [Sch98] </ref>). 3.3 Adding Recursion The recursion operator x 2 F: P is the standard fixed point operator at the level of proof terms with the following introduction rule. ; ; x 2 F ` P 2 F fix (where x 2 F: P terminates in x) ; ` x 2 F: <p> Assume we would like to distinguish all possible cases for a a given LF variable x of type A declared in . For simplicity, we assume that A is a base type, even though in the full system <ref> [Sch98] </ref> function types are also permitted which is needed, for example, in the proof of the deduction theorem. The top-level structure of a closed canonical term of base type is always c x 1 : : : x n , where x i are new variables 3 . <p> Unfortunately, space does not permit us to show the details of this proof or even the definition of the operational semantics. The interested reader is referred to <ref> [Sch98] </ref>. 4 Twelf Twelf is a theorem prover for LF which directly implements the meta-logic M 2 (including mutual induction and distinction by cases over functions). It provides an interactive mode for experimentation and an automatic mode in which only the theorem and the termination ordering are specified.
Reference: [SH93] <author> Peter Schroeder-Heister. </author> <title> Rules of definitional reflection. </title> <editor> In M. Vardi, editor, </editor> <booktitle> Proceedings of the Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 222-232, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: This idea is very similar to the realization of partial inductive definitions and definitional reflection <ref> [SH93] </ref>, except that dependent types can eliminate more cases statically. Also, because of the higher-order nature of the term language, we need to deal with the undecidability of the full higher-order unification problem.
References-found: 19

