URL: ftp://ftp.cs.princeton.edu/pub/lcc/contrib/overview.ps.gz
Refering-URL: http://www.cs.princeton.edu/software/lcc/doc/
Root-URL: http://www.cs.princeton.edu
Title: A Retargetable Compiler for ANSI C  
Author: Christopher W. Fraser David R. Hanson 
Address: 600 Mountain Avenue 2C-464, Murray Hill, NJ 07974  Princeton, NJ 08544  
Affiliation: AT&T Bell Laboratories,  Department of Computer Science, Princeton University,  
Abstract: lcc is a new retargetable compiler for ANSI C. Versions for the VAX, Motorola 68020, SPARC, and MIPS are in production use at Princeton University and at AT&T Bell Laboratories. With a few exceptions, little about lcc is unusual | it integrates several well engineered, existing techniques | but it is smaller and faster than most other C compilers, and it generates code of comparable quality. lcc's target-independent front end performs a few simple, but effective, optimizations that contribute to good code; examples include simulating register declarations and partitioning switch statement cases into dense tables. It also implements target-independent function tracing and expression-level profiling.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Keywords are recognized by a hard-coded decision tree, e.g., case 'i': if (rcp [0] == 'f' && !(map [rcp <ref> [1] </ref>]&(DIGIT|LETTER))) - cp = rcp + 1; return IF; - && rcp [1] == 't' && !(map [rcp [2]]&(DIGIT|LETTER))) - cp = rcp + 2; return INT; - goto id; IF and INT are defined as the token codes for the keywords if and int, respectively, and id labels the code that scans identifiers. <p> As in other compilers <ref> [1] </ref>, strings that must be saved (identifiers and string literals) are hashed into a table in which a string appears only once, which saves space. For performance, there are variants for installing strings of digits and strings of known length.
Reference: [2] <institution> American National Standards Institute, Inc., </institution> <address> New York. </address> <booktitle> American National Standard for Information Systems, Programming Language C ANSI X3.159-1989, </booktitle> <year> 1990. </year>
Reference-contexts: Introduction Reprinted from SIGPLAN Notices 26, 10 (Oct. 1991), 29-43. Copyright 1991, Association for Computing Machinery, Inc., reprinted by permission. lcc is a new retargetable compiler for ANSI C <ref> [2] </ref>. It has been ported to the VAX, Motorola 68020, SPARC, and MIPS R3000, and it is in production use at Princeton University and at AT&T Bell Laboratories.
Reference: [3] <author> F. Baskett. </author> <title> The best simple code generation technique for while, for, and do loops. </title> <journal> SIGPLAN Notices, </journal> <volume> 13(4) </volume> <pages> 31-32, </pages> <month> Apr. </month> <year> 1978. </year>
Reference-contexts: Many of these improvements are simple tree transformations that lead to better addressing code. The front end lays out loops so as to reduce the number of unconstructive branches <ref> [3] </ref>, e.g., the code for for (e 1 ; e 2 ; e 3 ) S has the form goto L1 L2: S L1: if (e 2 ) goto L2 The goto L1 is omitted if e 2 is initially non-zero.
Reference: [4] <author> J. L. Bentley. </author> <title> Writing Efficient Programs. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982. </year> <month> 42 </month>
Reference-contexts: Such data can also help identify functions that might profitably be replaced with two functions so that one can handle the common case more efficiently <ref> [4, Sec. 5.3] </ref>. Expression execution frequency profiling is implemented entirely by the front end. The only machine dependency is the name of the ultimate termination function in the revised exit function that writes prof.out at program termination. The implementation is a machine-independent variation of the method described in Reference [21].
Reference: [5] <author> R. L. Bernstein. </author> <title> Producing good code for the case statement. </title> <journal> Software|Practice and Experi--ence, </journal> <volume> 15(10) </volume> <pages> 1021-1024, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: In addition, the front end eliminates branch chains and dead branches. The selection code for switch statements is generated entirely by the front end. It generates a binary search of dense branch tables <ref> [5] </ref>, where the density is the percentage of non-default branch table entries. For example, with the default density of 0.5, a switch statement with the case values 1, 2, 6-8, 1001-1004, and 2001-2002 has the following VAX selection code.
Reference: [6] <institution> Computer Science Division, Department of Electrical Engineering and Computer Science, University of California, Berkeley, CA. </institution> <note> UNIX User's Manual, Reference Guide, virtual VAX-11 version edition, </note> <month> Mar. </month> <year> 1984. </year>
Reference-contexts: The numbers that follow function names, e.g., #2, are activation numbers and can help locate a specific call and its return. These debugging options are implemented entirely in the front end and thus are available on all of lcc's targets. 37 Profiling lcc supports prof-style (viz. <ref> [6, prof command] </ref>) and gprof-style [10] execution profiling on VAXes and Suns. These profilers sample the location counter periodically to obtain an estimate of the percentage of total execution time spent in each function, and they report the number of calls to each function.
Reference: [7] <author> C. W. Fraser. </author> <title> A language for writing code generators. </title> <booktitle> Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> 24(7) </volume> <pages> 238-245, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: When used with a compliant preprocessor and library, lcc passes the conformance section of Version 2.00 of the Plum-Hall Validation Suite for ANSI C. 1 Other reports describe lcc's storage manager [13], intermediate language [8], code generator <ref> [7] </ref>, and register manager [9]. This report surveys the remaining features of lcc that may interest some readers. Chief among these are its performance, some aspects of its design that support this performance, and some features for debugging and profiling user code. <p> Reference [8] describes the interface. Code generators are generated automatically from compact, rule-based specifications <ref> [7] </ref>. Some rules rewrite intermediate code as naive assembly code. Others peephole-optimize the result. They are compiled into a monolithic hard-coded program that accepts dags annotated with intermediate code, and generates, optimizes, and emits code for the target machine. Hard-coding contributes significantly to lcc's speed. <p> In practice, new back ends are implemented by writing new rules and editing copies of an existing configuration and set of interface functions. All of lcc's production back ends use the technology summarized above and detailed in Reference <ref> [7] </ref>. The interface between the front and back end does not depend on this technology; other back ends that conform to the interface specification can be used. For example, Reference [8] details a hand-written code generator that emits naive VAX code.
Reference: [8] <author> C. W. Fraser and D. R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <journal> Software|Practice and Experience, </journal> <volume> 21(9) </volume> <pages> 963-988, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: When used with a compliant preprocessor and library, lcc passes the conformance section of Version 2.00 of the Plum-Hall Validation Suite for ANSI C. 1 Other reports describe lcc's storage manager [13], intermediate language <ref> [8] </ref>, code generator [7], and register manager [9]. This report surveys the remaining features of lcc that may interest some readers. Chief among these are its performance, some aspects of its design that support this performance, and some features for debugging and profiling user code. <p> Reference <ref> [8] </ref> describes the interface. Code generators are generated automatically from compact, rule-based specifications [7]. Some rules rewrite intermediate code as naive assembly code. Others peephole-optimize the result. <p> All of lcc's production back ends use the technology summarized above and detailed in Reference [7]. The interface between the front and back end does not depend on this technology; other back ends that conform to the interface specification can be used. For example, Reference <ref> [8] </ref> details a hand-written code generator that emits naive VAX code. While lcc uses well established techniques, it uses some of their more recent incarnations, each of which contributes to lcc's efficiency as described below.
Reference: [9] <author> C. W. Fraser and D. R. Hanson. </author> <title> Simple register spilling in a retargetable compiler. </title> <journal> Software| Practice and Experience, </journal> <volume> 22(1) </volume> <pages> 85-99, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: When used with a compliant preprocessor and library, lcc passes the conformance section of Version 2.00 of the Plum-Hall Validation Suite for ANSI C. 1 Other reports describe lcc's storage manager [13], intermediate language [8], code generator [7], and register manager <ref> [9] </ref>. This report surveys the remaining features of lcc that may interest some readers. Chief among these are its performance, some aspects of its design that support this performance, and some features for debugging and profiling user code. Design With a few exceptions, lcc uses well established compiler techniques.
Reference: [10] <author> S. L. Graham, P. B. Kessler, and M. K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 13(8) </volume> <pages> 671-685, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: These debugging options are implemented entirely in the front end and thus are available on all of lcc's targets. 37 Profiling lcc supports prof-style (viz. [6, prof command]) and gprof-style <ref> [10] </ref> execution profiling on VAXes and Suns. These profilers sample the location counter periodically to obtain an estimate of the percentage of total execution time spent in each function, and they report the number of calls to each function. Heeding long-standing advice [15, 17], lcc also supports frequency-based profiling.
Reference: [11] <author> R. E. Griswold and M. T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Target-specific files include a configuration header file, which defines parameters like the widths and alignments of the basic datatypes, target-specific interface functions, e.g., those that emit function prologues, and code generation rules, from which the code generators are generated by the rule compiler, which is written in Icon <ref> [11] </ref>. Retargeting lcc requires involves writing these three back-end components, which vary from 377 to 522 lines in existing back ends. In practice, new back ends are implemented by writing new rules and editing copies of an existing configuration and set of interface functions. <p> If a zero pointer is detected, the offending file name and line number are reported on the standard error, e.g., null pointer dereferenced @foo.c:36 and the program terminates by calling the standard library function abort. Some languages provide built-in facilities for tracing function calls and returns <ref> [11] </ref>. An option instructs lcc to generate calls to printf (or a user-specified equivalent) just after entry to each function and just before each return. The entry code prints the arguments and the return code prints the value returned.
Reference: [12] <author> D. R. Hanson. </author> <title> Simple code optimizations. </title> <journal> Software|Practice and Experience, </journal> <volume> 13(8) </volume> <pages> 745-763, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: Its front end does, however, perform some simple, target-independent transformations that help its back ends generate good local code. The front end eliminates local common subexpressions, folds constant expressions, and makes numerous simple transformations that improve the quality of local code <ref> [12] </ref>. Many of these improvements are simple tree transformations that lead to better addressing code.
Reference: [13] <author> D. R. Hanson. </author> <title> Fast allocation and deallocation of memory based on object lifetimes. </title> <journal> Software| Practice and Experience, </journal> <volume> 20(1) </volume> <pages> 5-12, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: When used with a compliant preprocessor and library, lcc passes the conformance section of Version 2.00 of the Plum-Hall Validation Suite for ANSI C. 1 Other reports describe lcc's storage manager <ref> [13] </ref>, intermediate language [8], code generator [7], and register manager [9]. This report surveys the remaining features of lcc that may interest some readers. Chief among these are its performance, some aspects of its design that support this performance, and some features for debugging and profiling user code. <p> Storage Management Allocation and deallocation in early versions of lcc accounted for a significant portion of the total execution time. Replacing the naive use of malloc and free reduced total execution time by about 8-10 percent. As detailed in Reference <ref> [13] </ref>, allocation is based on the lifetime of the objects allocated, and all objects with the same lifetime are freed at once. This approach to storage management simplified lcc's code. Initially, each object type had explicit deallocation code, perhaps replicated at several points.
Reference: [14] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: For example, an option causes lcc to print ANSI-style C declarations for all defined globals and functions. For instance, the code (adapted from Section 6.2 of Reference <ref> [14] </ref>) typedef struct point - int x,y; point; typedef struct rect point pt1, pt2; - rect; 36 point addpoint (p1, p2) point p1, p2; - p1.x += p2.x; return p1; - int ptinrect (p, r) point p; rect r; - return p.x &gt;= r.pt1.x && p.x &lt; r.pt2.x && p.y &gt;=
Reference: [15] <author> D. E. Knuth. </author> <title> An empirical study of FORTRAN programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 1(2) </volume> <pages> 105-133, </pages> <month> Apr. </month> <year> 1971. </year>
Reference-contexts: These profilers sample the location counter periodically to obtain an estimate of the percentage of total execution time spent in each function, and they report the number of calls to each function. Heeding long-standing advice <ref> [15, 17] </ref>, lcc also supports frequency-based profiling. An option causes lcc to emit counters that record the number of times each expression is executed, and the values of these counters are written to the file prof.out when the program terminates.
Reference: [16] <author> R. Sedgewick. </author> <title> Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: Despite the conventional wisdom about hashing functions <ref> [16] </ref>, using a power of two for HASHSIZE gave better performance; using a prime instead and modulus in place of masking slowed lcc. This variation reduced the scope exit code to tp = tp-&gt;previous for table *tp.
Reference: [17] <author> R. L. </author> <title> Sites. Programming tools: Statement counts and procedure timings. </title> <journal> SIGPLAN Notices, </journal> <volume> 13(12) </volume> <pages> 98-101, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: These profilers sample the location counter periodically to obtain an estimate of the percentage of total execution time spent in each function, and they report the number of calls to each function. Heeding long-standing advice <ref> [15, 17] </ref>, lcc also supports frequency-based profiling. An option causes lcc to emit counters that record the number of times each expression is executed, and the values of these counters are written to the file prof.out when the program terminates.
Reference: [18] <institution> Standards Performance Evaluation Corp. SPEC Benchmark Suite Release 1.0, </institution> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: The total number of calls to each function is correct, however. Performance lcc emits local code that is comparable to that emitted by the generally available alternatives. Table 2 summarizes the results of compiling and executing the C programs in the SPEC benchmarks <ref> [18] </ref> with three compilers on the four machines listed above. Configuration details are listed with each machine. cc and gcc denote, respectively, the manufacturer's C compiler and the GNU C compiler from the Free Software Foundation.
Reference: [19] <author> K. Thompson. </author> <title> A new C compiler. </title> <booktitle> In Proceedings of the Summer 1990 UKUUG Conference, </booktitle> <pages> pages 41-51, </pages> <address> London, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: The gcc and gcc -O figures for gcc1.35 on the MIPS are missing because this benchmark did not execute correctly when compiled with gcc. lcc is faster than many (but not all <ref> [19] </ref>) other C compilers. Table 3 parallels Table 2, but shows compilation time instead of execution time. Except for the MIPS, the times are for running only the compiler proper; preprocessing, assembly, and linking time are not included.
Reference: [20] <author> W. M. Waite. </author> <title> The cost of lexical analysis. </title> <journal> Software|Practice and Experience, </journal> <volume> 16(5) </volume> <pages> 473-488, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Lexical Analysis The design of the input module and of the lexical analyzer and judicious code tuning of the lexical analyzer contribute to lcc's speed. Input and lexical analysis use variations of the design described in Reference <ref> [20] </ref>. Since the lexical analyzer is the only module that inspects every input character, the design avoids extraneous per-character processing and minimizes character movement by scanning tokens directly out of a large input buffer. <p> Using rcp improves performance and makes scanning loops compact and fast, e.g., white space is elided by while (map [*rcp]&BLANK) rcp++; map [c] is a mask that classifies character c as suggested in Reference <ref> [20] </ref>; e.g., map [c]&BLANK is non-zero if c is a white-space character (but not a newline). lcc generates four VAX instructions for the body of this loop: 31 jbr L142 L141: incl r11 L142: cvtbl (r11),r5 bicl3 $-2,_map [r5],r5 jneq L141 rcp is register r11.
Reference: [21] <author> P. J. Weinberger. </author> <title> Cheap dynamic instruction counting. </title> <journal> Bell System Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1815-1826, </pages> <month> Oct. </month> <year> 1984. </year> <month> 43 </month>
Reference-contexts: Expression execution frequency profiling is implemented entirely by the front end. The only machine dependency is the name of the ultimate termination function in the revised exit function that writes prof.out at program termination. The implementation is a machine-independent variation of the method described in Reference <ref> [21] </ref>. The front end generates an array of counters for each file and starts each expression with code to increment the appropriate counter. In also builds a parallel array that holds the source coordinates corresponding to each counter.
References-found: 21

