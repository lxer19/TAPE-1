URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/threads-with-regwindows.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Title: Register Windows and User-Space Threads on the SPARC  
Author: David Keppel 
Date: 1 August 1991  
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Pubnum: Technical Report #91-08-01  
Abstract: Multiple lightweight processes or threads have multiple stacks, and a thread context switch moves execution from one stack to another. On the SPARC 1 architecture, parts of a thread's stack can be cached in register windows while the thread is running. The cached data must be flushed to memory when the thread is suspended. Doing the flushing both efficiently and correctly can be tricky. This document discusses the implementation of a non-preemptive user-space threads package under SunOS 2 . 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson et al. 89] <author> T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> The performance implications of thread management alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(12), </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: A disadvantage is that creating, scheduling, and destroying threads are all done in the kernel, which makes threads expensive because all thread operations cross kernel protection boundaries. An alternative is user-space threads (or just user threads) such as Presto [Bershad et al. 88] and Fast-Threads <ref> [Anderson et al. 89] </ref>. User-space threads are managed entirely within the user address space. User threads can be faster because they don't cross protection boundaries and because their total state can be minimized for each application.
Reference: [Bershad et al. 88] <author> B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> PRESTO: A system for object-oriented parallel programming. </title> <journal> Software Practice and Experience, </journal> <volume> 18(8), </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: A disadvantage is that creating, scheduling, and destroying threads are all done in the kernel, which makes threads expensive because all thread operations cross kernel protection boundaries. An alternative is user-space threads (or just user threads) such as Presto <ref> [Bershad et al. 88] </ref> and Fast-Threads [Anderson et al. 89]. User-space threads are managed entirely within the user address space. User threads can be faster because they don't cross protection boundaries and because their total state can be minimized for each application.
Reference: [Birrell 89] <author> A. D. Birrell. </author> <title> An introduction to programming with threads. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Lightweight processes executing in a single address space are called threads <ref> [Birrell 89] </ref>. Conceptually, each of the threads of control can run independently and concurrently, and, since they share one address space, they can share data. An implementation can run a large number of threads on a small number of processors by multiplexing the threads onto the processors.
Reference: [CSR 86] <institution> CSRG Computer Science Division, Department of EE/CS, University of California, Berkeley, California 94720. </institution> <note> Unix Programmer's Reference Manual, </note> <year> 1986. </year>
Reference: [Fischer & LeBlanc 88] <author> C. N. Fischer and R. J. LeBlanc, Jr. </author> <title> Crafting A Compiler. </title> <address> Benjamin/Cummings, </address> <year> 1988. </year>
Reference-contexts: These are called caller-save registers. Another set of registers (usually all of the remaining registers) are assumed to be unused by the callee. If the callee wants to use them, it must save them. These are callee-save registers <ref> [Fischer & LeBlanc 88] </ref>. * In, local, out and global registers: The SPARC integer registers are divided in to four groups. The in registers hold the first six incoming function parameters (%i0..%i5), the frame pointer (%i6) and the function return address (%i7). <p> This document uses the term inlining to mean that the code for a procedure is inserted into the code for another procedure. Inlining is also called open-coding, inline expansion <ref> [Fischer & LeBlanc 88] </ref>, procedure integration, or procedure hoisting. 3 Generic Thread Swaps A thread context swap is when one thread (old) is stopped and another thread (new) is started. A thread context swap requires saving the state of the old thread and restoring the state of the new thread.
Reference: [Maturana 91] <author> G. </author> <title> Maturana. </title> <type> Personal communication, </type> <month> April </month> <year> 1991. </year>
Reference: [Sun 91] <author> Sun Microsystems. </author> <title> The SPARC Architecture Manual, </title> <type> Version 8, </type> <year> 1991. </year>
Reference-contexts: This document assumes familiarity with the basics of SPARC register windows and assembly language <ref> [Sun 91] </ref>. The key concepts include: * Caller-save and callee-save registers: Two functions (the caller and the callee) will both use registers. The caller and the callee follow a protocol to ensure that the callee does not clobber (fill with garbage values) registers that have valid caller data. <p> Saving cached register sets is discussed in the following section. 5.1 Regular, Leaf, or Inlined Procedure? Different implementations of cswap will need to save different registers. Several choices are discussed below. If the thread context swap routine is not treated as a leaf function <ref> [Sun 91] </ref>, then only the frame pointer (%fp) and function return address (%i7) registers need to be saved. As discussed in x2, globals and floating-point registers do not usually need to be saved, because most compilers and systems assume that they are clobbered across function calls.
Reference: [Thacker et al. 88] <author> C. Thacker, L. Stewart, and E. Satterthwaite Jr. Firefly: </author> <title> A multiprocessor workstation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 909-920, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: An implementation can run a large number of threads on a small number of processors by multiplexing the threads onto the processors. There are two alternatives for threads. Systems such as Mach [Young et al. 87] and Topaz <ref> [Thacker et al. 88] </ref> have kernel threads. Each thread is created in the operating system kernel and thread scheduling decisions, such as which thread to run and on which processor, are made in the kernel.
Reference: [Young et al. 87] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year> <note> 13 0 1 2 3 | | 1 | | | WIM +---+---+---+---+ | | | U | | ^CWIN </note>
Reference-contexts: An implementation can run a large number of threads on a small number of processors by multiplexing the threads onto the processors. There are two alternatives for threads. Systems such as Mach <ref> [Young et al. 87] </ref> and Topaz [Thacker et al. 88] have kernel threads. Each thread is created in the operating system kernel and thread scheduling decisions, such as which thread to run and on which processor, are made in the kernel.
References-found: 9

