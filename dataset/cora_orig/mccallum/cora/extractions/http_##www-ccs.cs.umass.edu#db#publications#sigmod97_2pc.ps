URL: http://www-ccs.cs.umass.edu/db/publications/sigmod97_2pc.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/publications/
Root-URL: 
Email: framesh, haritsag@serc.iisc.ernet.in  krithi@cs.umass.edu  
Title: Revisiting Commit Processing in Distributed Database Systems  
Author: Ramesh Gupta Jayant Haritsa Krithi Ramamritham 
Address: Bangalore 560012, India  Amherst 01003, U.S.A.  
Affiliation: Supercomputer Education and Research Centre Indian Institute of Science,  Department of Computer Science Univ. of Massachusetts,  
Abstract: A significant body of literature is available on distributed transaction commit protocols. Surprisingly, however, the relative merits of these protocols have not been studied with respect to their quantitative impact on transaction processing performance. In this paper, using a detailed simulation model of a distributed database system, we profile the transaction throughput performance of a representative set of commit protocols. A new commit protocol, OPT, that allows transactions to "optimistically" borrow uncommitted data in a controlled manner is also proposed and evaluated. The new protocol is easy to implement and incorporate in current systems, and can coexist with most other optimizations proposed earlier. For example, OPT can be combined with current industry standard protocols such as Presumed Commit and Presumed Abort. The experimental results show that distributed commit processing can have considerably more influence than distributed data processing on the throughput performance and that the choice of commit protocol clearly affects the magnitude of this influence. Among the protocols evaluated, the new optimistic commit protocol provides the best transaction throughput performance for a variety of workloads and system configurations. In fact, OPT's peak throughput is often close to the upper bound on achievable performance. Even more interestingly, a three-phase (i.e., non-blocking) version of OPT provides better peak throughput performance than all of the standard two-phase (i.e., blocking) protocols evaluated in our study. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Al-Houmaily and P. Chrysanthis, </author> <title> "Two-Phase Commit in Gigabit-Networked Distributed Databases", </title> <booktitle> Proc. of 8th Intl. Conf. on Parallel and Distributed Computing Systems, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Surprisingly, however, most of the earlier performance studies of commit protocols (e.g., <ref> [1, 18, 21, 23] </ref>) have been limited to comparing protocols based on the number of messages and the number of forced-writes that they incur. <p> It should be noted, however, that a variety of other protocols have also been proposed. These include linear 2PC [15], distributed 2PC [22], Unsolicited Vote (UV) [28], Early Prepare (EP) and Coordinator Log (CL) [24, 25] protocols. Very recently, the Implicit Yes Vote (IYV) protocol <ref> [1, 2] </ref> and the two-phase abort (2PA) protocol [4, 5] have been proposed for distributed database systems that are expected to be connected by extremely high speed networks. 3 Optimistic Commit Processing In all of the protocols described in the previous section, a cohort that reaches the PREPARED state can release
Reference: [2] <author> Y. Al-Houmaily and P. Chrysanthis, </author> <title> "The Implicit-Yes Vote Commit Protocol with Delegation of Commitment", </title> <booktitle> Proc. of 9th Intl. Conf. on Parallel and Distributed Computing Systems, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: It should be noted, however, that a variety of other protocols have also been proposed. These include linear 2PC [15], distributed 2PC [22], Unsolicited Vote (UV) [28], Early Prepare (EP) and Coordinator Log (CL) [24, 25] protocols. Very recently, the Implicit Yes Vote (IYV) protocol <ref> [1, 2] </ref> and the two-phase abort (2PA) protocol [4, 5] have been proposed for distributed database systems that are expected to be connected by extremely high speed networks. 3 Optimistic Commit Processing In all of the protocols described in the previous section, a cohort that reaches the PREPARED state can release
Reference: [3] <author> R. Agrawal, M. Carey and M. Livny, </author> <title> "Concurrency Control Performance Modeling: Alternatives and Implications", </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 12(4), </volume> <year> 1987. </year>
Reference-contexts: A transaction that is aborted is restarted after a delay and makes the same data accesses as its original incarnation. The length of the delay is equal to the average transaction response time this is the same heuristic as that used in most transaction management studies <ref> [3, 9, 10, 11] </ref>. After a transaction completes, a new one is submitted immediately at its originating site. The physical resources at each site consist of N umCP U s processors, N umDataDisks data disks, and N umLogDisks log disks. <p> For this experiment, the physical resources (CPUs and disks) were made "infinite", that is, there is no queueing for these resources <ref> [3] </ref>. The other parameter values are the same as those used in Experiment 1. The results of this experiment are shown in Figures 2a through 2c. In these figures, as in the previous experiment, CENT shows the best performance and the performance of DPCC is close to that of CENT. <p> The reason for the crossover is the following: In our model, as in earlier transaction management studies (for example, <ref> [3] </ref>), aborted transactions are delayed before restarting with the delay period being equal to the average response time. This delay effectively becomes a crude way of controlling the data contention in the system.
Reference: [4] <author> S. Banerjee and P. Chrysanthis, </author> <title> "Data Sharing and Recovery in Gigabit-Networked Databases", </title> <booktitle> Proc. of 4th Intl. Conf. on Computer Communications and Networks, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: These include linear 2PC [15], distributed 2PC [22], Unsolicited Vote (UV) [28], Early Prepare (EP) and Coordinator Log (CL) [24, 25] protocols. Very recently, the Implicit Yes Vote (IYV) protocol [1, 2] and the two-phase abort (2PA) protocol <ref> [4, 5] </ref> have been proposed for distributed database systems that are expected to be connected by extremely high speed networks. 3 Optimistic Commit Processing In all of the protocols described in the previous section, a cohort that reaches the PREPARED state can release all of its read locks.
Reference: [5] <author> S. Banerjee and P. Chrysanthis, </author> <title> "A Fast and Robust Failure Recovery Scheme for Shared-Nothing Gigabit-Networked Databases", </title> <booktitle> Proc. of 9th Intl. Conf. on Parallel and Distributed Computing Systems, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: These include linear 2PC [15], distributed 2PC [22], Unsolicited Vote (UV) [28], Early Prepare (EP) and Coordinator Log (CL) [24, 25] protocols. Very recently, the Implicit Yes Vote (IYV) protocol [1, 2] and the two-phase abort (2PA) protocol <ref> [4, 5] </ref> have been proposed for distributed database systems that are expected to be connected by extremely high speed networks. 3 Optimistic Commit Processing In all of the protocols described in the previous section, a cohort that reaches the PREPARED state can release all of its read locks.
Reference: [6] <editor> B. Bhargava, (editor), </editor> <title> Concurrency and Reliability in Distributed Database Systems, </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Distributed database systems implement a transaction commit protocol to ensure transaction atomicity. Over the last two decades, a variety of commit protocols have been proposed by database researchers <ref> [6, 22] </ref>. These include the classical two phase commit (2PC) protocol [15, 19], its variations such as presumed commit and presumed abort [18, 21], and three phase commit (3PC) [27].
Reference: [7] <author> P. Bernstein, V. Hadzilacos and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Non-blocking protocols, on the other hand, are designed to ensure that such major disruptions do not occur. To achieve their functionality, however, they usually incur additional messages and forced-writes than their "blocking" counterparts. In general, "two-phase" commit protocols are susceptible to blocking whereas "three-phase" commit protocols are non-blocking <ref> [7] </ref>. Speed of Recovery: This refers to the time required for the database to be recovered when the failed site comes back up after a crash. <p> We propose and evaluate a new commit protocol, called OPT, that, in contrast to earlier commit protocols, allows transactions to "optimistically" borrow dirty (uncommitted) data. Although dirty reads are permitted, there is no danger of incurring cascading aborts <ref> [7] </ref> since the borrowing is done in a controlled manner. The protocol is easy to implement and to incorporate in current systems, and can be integrated with most other optimizations proposed earlier. <p> We will hereafter refer to this protocol as OPT. 3.1 Aborts in OPT do not Cascade An important point to note here is that OPT's policy of using uncommitted data is generally not recommended in database systems since this can potentially lead to the well-known problem of cascading aborts <ref> [7] </ref> if the transaction whose dirty data has been accessed is later aborted. However, for the OPT protocol, this problem is alleviated due to two reasons: 1. <p> We assume sufficient buffer space to allow the retention of data updates until commit time. The commit protocol is initiated when the transaction has completed its data processing. 4.2 Concurrency Control For transaction concurrency control (CC), we use the distributed strict two-phase locking (2PL) protocol <ref> [7] </ref>. Transactions, through their cohorts, set read locks on pages that they read and update locks on pages that need to be updated. All locks are held until the receipt of the PREPARE message from the master.
Reference: [8] <author> M. Carey, S. Krishnamurthi and M. Livny, </author> <title> "Load Control for Locking: The `Half-and-Half' Approach", </title> <booktitle> Proc. of 9th Symp. on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: performance metric of our experiments is transaction throughput , that is, the rate at which the system completes transactions. 5 We also emphasize the peak throughput that is achievable by each protocol since this represents the maximum attainable performance and by using a suitable admission control policy (for example, Half-and-Half <ref> [8] </ref>), the throughput can be maintained at this level in high-performance systems.
Reference: [9] <author> M. Carey and M. Livny, </author> <title> "Distributed Concurrency Control Performance: A Study of Algorithms, Distribution, and Replication", </title> <booktitle> Proc. of 14th Intl. Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: In light of the above discussion, it seems reasonable to expect that the results of detailed studies of commit protocol performance would be available to assist distributed database system designers in making an informed choice (as is the case with, for example, distributed concur-rency control <ref> [9, 10, 11] </ref>). Surprisingly, however, most of the earlier performance studies of commit protocols (e.g., [1, 18, 21, 23]) have been limited to comparing protocols based on the number of messages and the number of forced-writes that they incur. <p> Our simulation model is similar to the one used in <ref> [9] </ref> to study distributed concurrency control protocols. A summary of the key model parameters is given in Table 1. The database is modeled as a collection of DBSize pages that are uniformly distributed across all the N umSites sites. <p> A transaction that is aborted is restarted after a delay and makes the same data accesses as its original incarnation. The length of the delay is equal to the average transaction response time this is the same heuristic as that used in most transaction management studies <ref> [3, 9, 10, 11] </ref>. After a transaction completes, a new one is submitted immediately at its originating site. The physical resources at each site consist of N umCP U s processors, N umDataDisks data disks, and N umLogDisks log disks. <p> We do not explicitly model the overheads for detecting deadlocks or for concurrency control since (a) these costs would be similar across all the commit protocols, and (b) they are usually negligible compared to the overall cost of accessing data <ref> [9] </ref>.
Reference: [10] <author> M. Carey and M. Livny, </author> <title> "Parallelism and Concurrency Control Performance in Distributed Database Machines", </title> <booktitle> Proc. of ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: In light of the above discussion, it seems reasonable to expect that the results of detailed studies of commit protocol performance would be available to assist distributed database system designers in making an informed choice (as is the case with, for example, distributed concur-rency control <ref> [9, 10, 11] </ref>). Surprisingly, however, most of the earlier performance studies of commit protocols (e.g., [1, 18, 21, 23]) have been limited to comparing protocols based on the number of messages and the number of forced-writes that they incur. <p> A transaction that is aborted is restarted after a delay and makes the same data accesses as its original incarnation. The length of the delay is equal to the average transaction response time this is the same heuristic as that used in most transaction management studies <ref> [3, 9, 10, 11] </ref>. After a transaction completes, a new one is submitted immediately at its originating site. The physical resources at each site consist of N umCP U s processors, N umDataDisks data disks, and N umLogDisks log disks.
Reference: [11] <author> M. Carey and M. Livny, </author> <title> "Conflict Detection Tradeoffs for Replicated Data", </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 16(4), </volume> <year> 1991. </year>
Reference-contexts: In light of the above discussion, it seems reasonable to expect that the results of detailed studies of commit protocol performance would be available to assist distributed database system designers in making an informed choice (as is the case with, for example, distributed concur-rency control <ref> [9, 10, 11] </ref>). Surprisingly, however, most of the earlier performance studies of commit protocols (e.g., [1, 18, 21, 23]) have been limited to comparing protocols based on the number of messages and the number of forced-writes that they incur. <p> A transaction that is aborted is restarted after a delay and makes the same data accesses as its original incarnation. The length of the delay is equal to the average transaction response time this is the same heuristic as that used in most transaction management studies <ref> [3, 9, 10, 11] </ref>. After a transaction completes, a new one is submitted immediately at its originating site. The physical resources at each site consist of N umCP U s processors, N umDataDisks data disks, and N umLogDisks log disks.
Reference: [12] <author> K. Eswaran et al, </author> <title> "The Notions of Consistency and Predicate Locks in a Database Systems", </title> <journal> Comm. of ACM , 19(11), </journal> <year> 1976. </year>
Reference-contexts: In fact, if we assume that a locking-based concurrency control mechanism such as 2PL <ref> [12] </ref> is used, it is easy to verify that there is no possibility of sibling cohorts aborting, during the commit processing period, due to serializability considerations. Therefore, an abort vote can arise only due to other reasons such as, violation of integrity constraints, software errors, system failure, etc.
Reference: [13] <author> R. Gupta, J. Haritsa and K. Ramamritham, </author> <title> "Revisiting Commit Processing in Distributed Database Systems", </title> <institution> TR-97-01 , DSL/SERC, Indian Institute of Science, </institution> <year> 1997. </year>
Reference-contexts: With blocking 1 The only work that we are aware of which discusses these issues is reported in [16] wherein commit processing in a client-server type of environment is studied but the scope and methodology of their study is considerably different from ours as explained in <ref> [13] </ref>. Also, we present and evaluate a new high-performance protocol (OPT) that is easy to implement and incorporate in current systems. protocols, there is a possibility of transaction process-ing grinding to a halt in the presence of failures (as explained in Section 2.4). <p> with protocols such as Unsolicited Vote and IYV which do not guarantee that a cohort which has unilaterally entered the prepared state will not be forced back later into an active state OPT can lead to cascading aborts, long "on-the-shelf"-times for borrowers, deadlocks involving the lender and the borrower, etc. <ref> [13] </ref>. Barring these exceptions, virtually all of the above optimizations can be integrated with an OPT implementation to produce enhanced performance. 3.3 System Integration We now comment on the implementation issues related to the OPT protocol: 1. <p> Due to space limitations, we discuss only a representative set of results here the complete details are available in <ref> [13] </ref>. <p> The experiment was conducted for both resource-cum-data contention (RC+DC) and pure data contention (DC) scenarios. 6 For brevity, we only discuss the results of this experiment here - the graphs are available in <ref> [13] </ref>: First, the performance of all the protocols becomes closer to that of CENT as compared to the previous experiments, and in fact, DPCC and CENT are virtually indistinguishable. <p> These included workloads with sequential transactions, reduced update probabilities, small database sizes, etc. The relative performance of the protocols in these additional experiments remained qualitatively similar to that seen in the experiments described here (see <ref> [13] </ref> for details), with the performance improvement delivered by OPT being dependent on the level of data contention in the system.
Reference: [14] <author> R. Gupta, J. Haritsa, K. Ramamritham and S. Seshadri, </author> <title> "Commit Processing in Distributed Real-Time Database Systems", </title> <booktitle> Proc. of 17th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: At this stage, the cohort has entered a prepared state wherein it cannot unilaterally commit or abort the transaction but has 2 A suitably modified version of OPT exhibited similar good performance characteristics in our recent research on commit processing in distributed real-time database systems <ref> [14] </ref>. 3 An alternative "peer-to-peer" model is discussed in [20, 23]. 4 In the most general case, each of the cohorts may itself spawn off sub-transactions at other sites, leading to the "tree of processes" transaction structure of System R fl [17] for simplicity, we only consider a two-level tree here.
Reference: [15] <author> J. Gray, </author> <booktitle> "Notes on Database Operating Systems", Operating Systems: An Advanced Course, Lecture Notes in Computer Science, </booktitle> <volume> 60, </volume> <year> 1978 </year>
Reference-contexts: 1 Introduction Distributed database systems implement a transaction commit protocol to ensure transaction atomicity. Over the last two decades, a variety of commit protocols have been proposed by database researchers [6, 22]. These include the classical two phase commit (2PC) protocol <ref> [15, 19] </ref>, its variations such as presumed commit and presumed abort [18, 21], and three phase commit (3PC) [27]. To achieve their func tionality, these commit protocols typically require exchange of multiple messages, in multiple phases, between the participating sites where the distributed transaction executed. <p> a set of other processes, called cohorts, which execute on behalf of the transaction at the various sites that are accessed by the transaction. 4 For this model, a variety of transaction commit protocols have been devised, most of which are based on the classical two phase commit (2PC) protocol <ref> [15] </ref>. <p> It should be noted, however, that a variety of other protocols have also been proposed. These include linear 2PC <ref> [15] </ref>, distributed 2PC [22], Unsolicited Vote (UV) [28], Early Prepare (EP) and Coordinator Log (CL) [24, 25] protocols. <p> (cohorts enter prepared state and vote yes without waiting for a prepare request from coordinator), Long Locks (cohorts piggyback their commit acknowledgments onto subsequent messages), Shared Logs (cohorts share a common log with the master), Group Commit (forced writes are batched together to save on disk I/O), and linear 2PC <ref> [15] </ref> (message overheads are reduced by ordering the sites in a linear chain for communication purposes). OPT is especially attractive to integrate with protocols such as 3PC , Group Commit and linear 2PC , since they extend the period during which data is held in the prepared state.
Reference: [16] <author> M. Liu, D. Agrawal and A. El Abbadi, </author> <title> "The Performance of Two-Phase Commit Protocols in the Presence of Site Failures", </title> <booktitle> Proc. of 24th Intl. Symp. on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: With blocking 1 The only work that we are aware of which discusses these issues is reported in <ref> [16] </ref> wherein commit processing in a client-server type of environment is studied but the scope and methodology of their study is considerably different from ours as explained in [13].
Reference: [17] <author> B. Lindsay et al, </author> <title> "Computation and Communication in R fl </title> : 
Reference-contexts: research on commit processing in distributed real-time database systems [14]. 3 An alternative "peer-to-peer" model is discussed in [20, 23]. 4 In the most general case, each of the cohorts may itself spawn off sub-transactions at other sites, leading to the "tree of processes" transaction structure of System R fl <ref> [17] </ref> for simplicity, we only consider a two-level tree here. to wait for the final decision from the master. On the other hand, each cohort that decides to abort force-writes an abort log record and sends a NO vote to the master.
References-found: 17

