URL: http://www.cs.purdue.edu/Renaissance/overview.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmuckel|russog@cs.purdue.edu  
Title: The Renaissance Distributed Object System  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: Object-oriented techniques stress modularity through narrow and rigidly defined interfaces as a way of achieving low coupling between individual software components and high cohesion in the implementation of each component. Unfortunately, in a distributed environment object-oriented interfaces are usually only enforced and usable through language mechanisms or rigid programming conventions. Both of these limitations make it difficult for components in a large-scale distributed environment to interact. This paper discusses a technique that overcomes these limitations and allows for strong interface descriptions that are available at runtime with very small overheads. Our system allows for the dynamic querying of objects for their conformance to a client's requirements specified as an interface description. We also support the automatic generation of local proxy objects to access remote objects once their conformance is confirmed. The conformance rules we have chosen are more flexible than other approaches and allow for a high degree of autonomy between client and server. The approach we use converts interface descriptions into code that can be linked to programs written in various object-oriented and non-object-oriented languages. It differs from other similar systems in both the conformance checking rules used and in the ability to specify semantic attributes of distributed objects separate from their interfaces. The result is an environment that yields many of the benefits of tightly coupled systems (e.g. strong interfaces and support for static type checking) but maintains many of the benefits of loosely coupled systems (e.g. higher degrees of autonomy, dynamic type checking when necessary, and dynamic operating invocation).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta et al. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of the 8 USENIX Conference, </booktitle> <pages> pages 93-111, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking. Clients in traditional distributed systems such as V [6, 5], Mach <ref> [1] </ref>, and Chorus [20] acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [2] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> "Implementing Signatures for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1994. </year>
Reference-contexts: due to its availability and our previous work on integrating the signature 6 Kernel Server Application Server UNIX Server Kernel 0.8s 1,869s 2,058s Application 128s 2,049s 2,087s UNIX 2,041s 3,192s 1,824s Kernel Application UNIX 1 105s 4,682s 7,091s 3 127s 9,290s 11,799s 5 156s 13,568s 16,539s concept into the language <ref> [9, 2] </ref>. The transport mechanisms we use to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross domain method invocations using shared memory and, UDP/IP packet transport.
Reference: [3] <author> John K. Bennett. </author> <title> The Design and Implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: All type checking must be done at message sending time. Distributed object languages, such as Argus [16], Distributed Smalltalk <ref> [3] </ref>, and Emerald [19], and distributed object systems, such as Clouds [7] and Eden [15], not only provide a notion of objects and type conformance but are also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [4] <author> Andrew Birrell and Bruce Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: All the methods in all the signatures were null methods, so these times represent the minimum cost of narrowing references in each case. Argument/result conformance checking will add to the expense depending on the complexity of the types involved. 6 Related Work Clients in remote procedure call <ref> [4] </ref> (RPC) based systems such as SUN RPC [25] acquire system services by invoking local functions that transparently access remote services.
Reference: [5] <author> David R. Cheriton. </author> <title> The V Kernel: A Software Base for Distributed Systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking. Clients in traditional distributed systems such as V <ref> [6, 5] </ref>, Mach [1], and Chorus [20] acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [6] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking. Clients in traditional distributed systems such as V <ref> [6, 5] </ref>, Mach [1], and Chorus [20] acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [7] <author> Partha Dasgupta, Richard LeBlanc, and William Appelbe. </author> <title> The Clouds Distributed Operating System:Functional Description, Implementation Details, and Related Work. Technical Report GIT-ICS-87/42Functional Description, Implementation Details, and Related Work, </title> <type> Georgia Tech, 87. </type>
Reference-contexts: All type checking must be done at message sending time. Distributed object languages, such as Argus [16], Distributed Smalltalk [3], and Emerald [19], and distributed object systems, such as Clouds <ref> [7] </ref> and Eden [15], not only provide a notion of objects and type conformance but are also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [8] <author> Carlo Ghezze, Mehdi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Well defined interfaces are a way of achieving low coupling between individual software components. Coupling measures the interdependencies between components. Low coupling is a desirable feature of a system because it decreases the difficulty of separating, understanding, maintaining and reusing its individual components <ref> [8] </ref>. It would seem, therefore, that object-oriented programming should be an ideal approach to use in the construction of operating system software. Due to the even greater need for low coupling introduced by the desire for autonomy, distributed operating system software should also benefit well from object-oriented techniques.
Reference: [9] <author> Elana D. Granston and Vincent F. Russo. </author> <title> "Signature-Based Polymorphism for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1991. </year>
Reference-contexts: due to its availability and our previous work on integrating the signature 6 Kernel Server Application Server UNIX Server Kernel 0.8s 1,869s 2,058s Application 128s 2,049s 2,087s UNIX 2,041s 3,192s 1,824s Kernel Application UNIX 1 105s 4,682s 7,091s 3 127s 9,290s 11,799s 5 156s 13,568s 16,539s concept into the language <ref> [9, 2] </ref>. The transport mechanisms we use to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross domain method invocations using shared memory and, UDP/IP packet transport.
Reference: [10] <author> Daniel C. Halbert and Patrick D. O'Brien. </author> <title> Using Types and Inheritance in Object-Oriented Programming. </title> <journal> IEEE Software, </journal> <pages> pages 71-79, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Distributed systems exacerbate these problems since even more components must be maintained and integrated. The use of object-oriented techniques is proposed as a solution to these types of software engineering problems <ref> [17, 10, 13] </ref>. Object-oriented programming and design stresses modularity and data encapsulation through narrow and rigidly defined interfaces. An object-oriented operating system could internally structure itself as objects and present all kernel accessible resources to client applications as a set of objects [21]. <p> Class inheritance is a mechanism which allows a new class to copy of the parent's implementation, modify some of the inherited methods, and add additional methods. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [10, 23, 13, 17] </ref>. When using classes for type conformance checking a client specifies its requirements (needed interface) as a class. Server objects which are instances of that class or any of its subclasses conform by definition to the required interface.
Reference: [11] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: While Renaissance is obviously similar in philosophy to a number of other efforts including OMG's CORBA [18], Microsoft's OLE-II [?], IBM's SOM/DSOM [12] and Sun's Spring <ref> [11] </ref>, it differs in a number of substantial ways. 1. Our substrate and translators provide automatic runtime type information about objects. This allows for the dynamic querying of an object for its conformance to a client's interface, and assists both in dynamic type discovery and dynamic method invocation. 2.
Reference: [12] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: The translators generate language specific module constructs (usually classes) that provide an interface to the distributed object substrate and support transparent invocation of operations on remote objects. While Renaissance is obviously similar in philosophy to a number of other efforts including OMG's CORBA [18], Microsoft's OLE-II [?], IBM's SOM/DSOM <ref> [12] </ref> and Sun's Spring [11], it differs in a number of substantial ways. 1. Our substrate and translators provide automatic runtime type information about objects. <p> A common approach to address some of the goals we address in our work is to build an interface description translator. Most closely related to our work are system such as Matchmaker [14], OMG's CORBA [18], Microsoft's OLE-II [?], and IBM's SOM/DSOM <ref> [12] </ref>. These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking.
Reference: [13] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing Reusable Classes. </title> <journal> The Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: Distributed systems exacerbate these problems since even more components must be maintained and integrated. The use of object-oriented techniques is proposed as a solution to these types of software engineering problems <ref> [17, 10, 13] </ref>. Object-oriented programming and design stresses modularity and data encapsulation through narrow and rigidly defined interfaces. An object-oriented operating system could internally structure itself as objects and present all kernel accessible resources to client applications as a set of objects [21]. <p> Class inheritance is a mechanism which allows a new class to copy of the parent's implementation, modify some of the inherited methods, and add additional methods. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [10, 23, 13, 17] </ref>. When using classes for type conformance checking a client specifies its requirements (needed interface) as a class. Server objects which are instances of that class or any of its subclasses conform by definition to the required interface.
Reference: [14] <author> Michael B. Jones and Richard F. Rashid. </author> <title> Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 67-86, </pages> <year> 1986. </year>
Reference-contexts: For this reason RPC-based systems are not well suited for modeling object-oriented applications. A common approach to address some of the goals we address in our work is to build an interface description translator. Most closely related to our work are system such as Matchmaker <ref> [14] </ref>, OMG's CORBA [18], Microsoft's OLE-II [?], and IBM's SOM/DSOM [12]. These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking.
Reference: [15] <author> E. Lazowska, H. Levy, G. Almes, M. Fischer, R. Fowler, and S. Vestal. </author> <title> The Architecture of the Eden System. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 148-159, </pages> <year> 1981. </year>
Reference-contexts: All type checking must be done at message sending time. Distributed object languages, such as Argus [16], Distributed Smalltalk [3], and Emerald [19], and distributed object systems, such as Clouds [7] and Eden <ref> [15] </ref>, not only provide a notion of objects and type conformance but are also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration. Unfortunately, the requirements placed on these systems to support these features makes it difficult for them to scale and interoperate with one another.
Reference: [16] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. Technical Report Programming Methodology Group Memo 58, </title> <publisher> MIT, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: All type checking must be done at message sending time. Distributed object languages, such as Argus <ref> [16] </ref>, Distributed Smalltalk [3], and Emerald [19], and distributed object systems, such as Clouds [7] and Eden [15], not only provide a notion of objects and type conformance but are also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [17] <author> Bertrand Meyer. </author> <title> Reusability: The Case for Object-Oriented Design. </title> <journal> IEEE Software, </journal> <pages> pages 50-64, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: Distributed systems exacerbate these problems since even more components must be maintained and integrated. The use of object-oriented techniques is proposed as a solution to these types of software engineering problems <ref> [17, 10, 13] </ref>. Object-oriented programming and design stresses modularity and data encapsulation through narrow and rigidly defined interfaces. An object-oriented operating system could internally structure itself as objects and present all kernel accessible resources to client applications as a set of objects [21]. <p> Class inheritance is a mechanism which allows a new class to copy of the parent's implementation, modify some of the inherited methods, and add additional methods. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [10, 23, 13, 17] </ref>. When using classes for type conformance checking a client specifies its requirements (needed interface) as a class. Server objects which are instances of that class or any of its subclasses conform by definition to the required interface.
Reference: [18] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1991. </year>
Reference-contexts: The translators generate language specific module constructs (usually classes) that provide an interface to the distributed object substrate and support transparent invocation of operations on remote objects. While Renaissance is obviously similar in philosophy to a number of other efforts including OMG's CORBA <ref> [18] </ref>, Microsoft's OLE-II [?], IBM's SOM/DSOM [12] and Sun's Spring [11], it differs in a number of substantial ways. 1. Our substrate and translators provide automatic runtime type information about objects. <p> The space required for the runtime type information is only about 5200 bytes. Looking at a smaller domain, one with 1 signature and 9 methods, the space required is only about 300 bytes. Other systems employing some form of runtime type identification, for example the CORBA interface repositories <ref> [18] </ref>, would be expected to have similar costs. 4 Current Status The design and specification of RIDL is complete. It includes signatures for describing object interfaces and supports a set of primitive types for describing simple data which have no methods. <p> For this reason RPC-based systems are not well suited for modeling object-oriented applications. A common approach to address some of the goals we address in our work is to build an interface description translator. Most closely related to our work are system such as Matchmaker [14], OMG's CORBA <ref> [18] </ref>, Microsoft's OLE-II [?], and IBM's SOM/DSOM [12]. These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking.
Reference: [19] <author> Rajendra K. Raj, Ewan Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchison, and Eric Jul. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software Practice and Experience, </journal> <volume> 2(1) </volume> <pages> 91-118, </pages> <month> January </month> <year> 1991. </year> <month> 9 </month>
Reference-contexts: All type checking must be done at message sending time. Distributed object languages, such as Argus [16], Distributed Smalltalk [3], and Emerald <ref> [19] </ref>, and distributed object systems, such as Clouds [7] and Eden [15], not only provide a notion of objects and type conformance but are also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [20] <author> M. Rozier, V. Abrossimov, and W Neuhauser. </author> <title> CHORUS-V3 Kernel Specification and Interface, </title> <type> Draft. Technical Report CS/TN-87-25.10, </type> <institution> CHORUS Systems, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: These systems provide an object-based interface description language that provide a convenient mechanism for varying programming languages to incorporate remote objects. Unlike our system, however, they use classes for type checking. Clients in traditional distributed systems such as V [6, 5], Mach [1], and Chorus <ref> [20] </ref> acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [21] <author> Vincent F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1991. </year>
Reference-contexts: Object-oriented programming and design stresses modularity and data encapsulation through narrow and rigidly defined interfaces. An object-oriented operating system could internally structure itself as objects and present all kernel accessible resources to client applications as a set of objects <ref> [21] </ref>. Distribution naturally follows once a mechanism for cross address space and cross machine object messaging is provided. Well defined interfaces are a way of achieving low coupling between individual software components. Coupling measures the interdependencies between components.
Reference: [22] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the 6th. International Conference on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: We do not wish to limit ourselves solely to object-oriented languages and will integrate our notion in a procedural manner into traditional programming languages. Transparent access to remote objects is provided through the use of proxies <ref> [22] </ref>. As shown in figure 3, a proxy is a local representation of a remote object and maps the language notion of procedure call or method invocation transparently into a remote method invocation mechanism.
Reference: [23] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 38-45, </pages> <year> 1986. </year>
Reference-contexts: Class inheritance is a mechanism which allows a new class to copy of the parent's implementation, modify some of the inherited methods, and add additional methods. Inheritance is useful for code and interface sharing, for factoring code into common places, and for incremental development and documentation <ref> [10, 23, 13, 17] </ref>. When using classes for type conformance checking a client specifies its requirements (needed interface) as a class. Server objects which are instances of that class or any of its subclasses conform by definition to the required interface.
Reference: [24] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: The language specific interface is used by programmers to construct objects (via subclassing of automatically generated parent classes) and/or to generate typed references to remote objects after narrowing. Currently, we map RIDL into the C ++ <ref> [24] </ref> programming language. Once a reference is narrowed at runtime, it is cast into a pointer to a C ++ class type generated from an abstract signature description.
Reference: [25] <author> Sun Microsystems. </author> <title> Networking on the SUN Workstation, </title> <booktitle> 1985. </booktitle> <pages> 10 </pages>
Reference-contexts: Argument/result conformance checking will add to the expense depending on the complexity of the types involved. 6 Related Work Clients in remote procedure call [4] (RPC) based systems such as SUN RPC <ref> [25] </ref> acquire system services by invoking local functions that transparently access remote services.
References-found: 25

