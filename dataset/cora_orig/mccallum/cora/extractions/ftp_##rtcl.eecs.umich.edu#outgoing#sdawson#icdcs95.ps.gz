URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/icdcs95.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnamg@eecs.umich.edu  
Title: Probing and Fault Injection of Protocol Implementations a probing and fault injection tool, called the
Author: Scott Dawson Farnam Jahanian 
Note: To demonstrate the capabilities of this technique, the paper describes  (GMP) [17].  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: Ensuring that a distributed system with strict dependability constraints meets its prescribed specification is a growing challenge that confronts software developers and system engineers. This paper presents a technique for probing and fault injection of fault-tolerant distributed protocols. The proposed technique, called script-driven probing and fault injection, can be used for studying the behavior of distributed systems and for detecting design and implementation errors of fault-tolerant protocols. The focus of this work is on fault injection techniques that can be used to demonstrate three aspects of a target protocol: i) detection of design or implementation errors, ii) identification of violations of protocol specifications, and iii) insight into design decisions made by the implementors. The emphasis of our approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie. </author> <title> Fault injection for dependability validation of fault-tolerant computing systems. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [1, 25] </ref>) and simulation approaches for injecting hardware failures (e.g. [8, 12]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24].
Reference: [2] <author> Jean Arlat, Martine Aguera, Yves Crouzet, Jean-Charles Fabre, Eliane Martins, and David Powell. </author> <title> Experimental evaluation of the fault tolerance of an atomic multicast system. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 13]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [2] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [3, 10].
Reference: [3] <author> D. Avresky, J. Arlat, J.C. Laprie, and Yves Crouzet. </author> <title> Fault injection for the formal testing of fault tolerance. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 13] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 10] </ref>. The work reported in [13] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [4] <author> R. Braden. RFC-1122: </author> <title> Requirements for internet hosts. Request for Comments, </title> <month> October </month> <year> 1989. </year> <institution> Network Information Center. </institution>
Reference-contexts: Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 [22] and was updated in RFC-1122 <ref> [4] </ref>. In order to meet the TCP standard, an implementation must follow both RFCs. To test vendor TCP implementations, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data. Probing of zero (offered) windows MUST be supported <ref> [4, 22] </ref> because an ACK segment which reopens the window may be lost if it contains no data, since ACK packets which carry no data are not transmitted reliably. "If zero window probing is not supported, a connection may hang forever when an ACK segment that re-opens the window is lost."
Reference: [5] <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding large system failures | a fault injection experiment. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection (e.g. [1, 25]) and simulation approaches for injecting hardware failures (e.g. [8, 12]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 24] </ref>. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 13]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [6] <author> Douglas E. Comer and John C. Lin. </author> <title> Probing TCP implementations. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Another closely related work is the active probing approach proposed in a recent paper by Comer and Lin <ref> [6] </ref> to study five TCP implementations. Active probing treats a TCP implementation as a black box, and it uses a set of user-level procedures to probe the black box. Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. <p> Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. In addition to repeating TCP experiments similar to those reported in <ref> [6] </ref>, our approach allows other tests that are not possible with techniques that are based primarily on monitoring and gathering trace data. In particular, our approach differs from the active probing technique in four major aspects.
Reference: [7] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> (4):175-187, 1991. 
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [7, 20, 23] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [17], ensures that membership changes are seen in the same order by all members.
Reference: [8] <author> E. Czeck and D. Siewiorek. </author> <title> Effects of transient gate-level faults on program behaviour. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [1, 25]) and simulation approaches for injecting hardware failures (e.g. <ref> [8, 12] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 13].
Reference: [9] <author> Scott Dawson and Farnam Jahanian. </author> <title> Probing and fault injection of protocol implementations. </title> <type> Technical Report CSE-TR-217-94, </type> <institution> The University of Michigan, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Solaris, which is a System V implementation, behaved somewhat differently than the others in most experiments. A brief description of five experiments and their results follows. A more detailed description can be found in <ref> [9] </ref>. Experiment: TCP retransmission intervals This experiment examines how different implemen tations of TCP retransmit dropped data segments. TCP uses timeouts and retransmission of segments to assure reliable delivery of data segments. Each time the sender sends a data segment, a timeout for the segment is set. <p> While performing these tests, we found several implementation errors and protocol specification violations which went unnoticed during testing by the implementors. An in depth explanation of the tests and their results appears in <ref> [9] </ref>. 5 Related Work Numerous approaches have been proposed in the past for evaluation and validation of system dependability including formal methods, analytical modeling, and simulation and experimental techniques.
Reference: [10] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 13] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 10] </ref>. The work reported in [13] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. <p> The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using. This work and that reported in <ref> [10] </ref> are closest to the approach proposed here. Rather than estimating fault coverages for evaluating dependability of distributed systems, this work focuses on techniques for identifying violations of protocol specifications and for detecting design or implementations errors.
Reference: [11] <author> Klaus Echtle and Martin Leu. </author> <title> The EFA fault injector for fault-tolerant distributed system testing. </title> <booktitle> In Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 13] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [12] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software be-haviour under hardware faults. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [1, 25]) and simulation approaches for injecting hardware failures (e.g. <ref> [8, 12] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 13].
Reference: [13] <author> Seungjae Han, Harold A. Rosenberg, and Kang G. Shin. DOCTOR: </author> <title> An integrateD sOftware fault in-jeCTOn enviRonment. </title> <type> Technical Report CSE-TR-192-93, </type> <institution> The University of Michigan, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 13] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Other work can be characterized as probabilistic approaches to test generation [3, 10]. The work reported in <ref> [13] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in [15] allows the user to introduce delays into user-level protocols.
Reference: [14] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: 6 presents concluding remarks and describes future directions of this work. 2 Approach 2.1 Script-Driven Probing and Fault In jection The proposed approach views a distributed protocol as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-Kernel <ref> [14] </ref>. In this model, we make no distinction between application-level protocols, interprocess communication protocols, network protocols, or device layer protocols.
Reference: [15] <author> David B. Ingham and Graham D. Parrington. Delay-line: </author> <title> A wide-area network emulation tool. </title> <journal> Computing Systems, </journal> <volume> 7(3) </volume> <pages> 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: The work reported in [13] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in <ref> [15] </ref> allows the user to introduce delays into user-level protocols. The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using.
Reference: [16] <author> Van Jacobson. </author> <title> Congestion avoidance and control. </title> <booktitle> In Proc. of ACM SIGCOMM, </booktitle> <pages> pages 314-329, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The RTO value for a TCP connection is calculated based on measured round trip time (RTT) from the time each packet is sent until the ACK for the packet is received. RFC-1122 specifies that a TCP must use Jacobson's algorithm <ref> [16] </ref> for computing the retransmission timeout coupled with Karn's algorithm [18] for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. In the experiment, ACK messages for data segments were delayed. Two variations of the experiment were run.
Reference: [17] <author> Farnam Jahanian, Ragunathan Rajkumar, and Sameh Fakhouri. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: When the data from the first segment arrived at the receiver, the receiver ACKed the data from both segments. 4.2 Testing of GMP The objective of the experiments described in this subsection was to test the fault-tolerance capabilities of a prototype implementation of the strong group membership protocol <ref> [17] </ref> using the probe and fault injection technique presented earlier. In a distributed environment, a collection of processes (or processors) can be grouped together to provide a service. <p> The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., [7, 20, 23]. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in <ref> [17] </ref>, ensures that membership changes are seen in the same order by all members. In this protocol, a group of processors have a unique leader based on the processor id of each member.
Reference: [18] <author> Phil Karn and Craig Partridge. </author> <title> Round trip time estimation. </title> <booktitle> In Proc. SIGCOMM 87, </booktitle> <address> Stowe, Vermont, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: RFC-1122 specifies that a TCP must use Jacobson's algorithm [16] for computing the retransmission timeout coupled with Karn's algorithm <ref> [18] </ref> for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. In the experiment, ACK messages for data segments were delayed. Two variations of the experiment were run.
Reference: [19] <author> Steven McCanne and Van Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [21], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [19] </ref>, and the Mach Packet Filter (MPF) [26] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [20] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [7, 20, 23] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [17], ensures that membership changes are seen in the same order by all members.
Reference: [21] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [21] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [19], and the Mach Packet Filter (MPF) [26] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [22] <author> Jon Postel. RFC-793: </author> <title> Transmission control protocol. Request for Comments, </title> <month> September </month> <year> 1981. </year> <institution> Network Information Center. </institution>
Reference-contexts: TCP is a connection-oriented protocol and uses flow-control between protocol participants to operate over network connections that are inherently unreliable. Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 <ref> [22] </ref> and was updated in RFC-1122 [4]. In order to meet the TCP standard, an implementation must follow both RFCs. To test vendor TCP implementations, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data. Probing of zero (offered) windows MUST be supported <ref> [4, 22] </ref> because an ACK segment which reopens the window may be lost if it contains no data, since ACK packets which carry no data are not transmitted reliably. "If zero window probing is not supported, a connection may hang forever when an ACK segment that re-opens the window is lost."
Reference: [23] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Mon-treal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [7, 20, 23] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [17], ensures that membership changes are seen in the same order by all members.
Reference: [24] <author> Z. Segall et al. </author> <title> Fiat fault injection based automated testing environment. </title> <booktitle> In FTCS-18, </booktitle> <pages> pages 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection (e.g. [1, 25]) and simulation approaches for injecting hardware failures (e.g. [8, 12]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 24] </ref>. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 13]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [25] <author> K. G. Shin and Y. H. Lee. </author> <title> Measurement and application of fault latency. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35(4):370-375, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [1, 25] </ref>) and simulation approaches for injecting hardware failures (e.g. [8, 12]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 24].
Reference: [26] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [21], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [19], and the Mach Packet Filter (MPF) <ref> [26] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
References-found: 26

