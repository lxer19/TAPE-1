URL: ftp://flint.cs.yale.edu/pub/flint/publications/tcc.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: shao-zhong@cs.yale.edu  
Title: Typed Cross-Module Compilation  
Author: Zhong Shao 
Address: New Haven, CT 06520  
Affiliation: Dept. of Computer Science Yale University  
Abstract: Higher-order modules are very effective in structuring large programs and defining generic, reusable software components. Unfortunately, many compilation techniques for the core languages do not work across the module boundaries. As a result, few optimizing compilers support these module facilities well. This paper exploits the semantic property of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules into a predicative variant of the polymorphic -calculus F ! . Because modules can be compiled in the same way as ordinary polymorphic functions, standard type-based optimizations such as representation analysis immediately carry over to the module languages. We further show that the full-transparency property of the MacQueen-Tofte system yields a near optimal cross-module compilation framework. By propagating various static information through the module boundaries, many static program analyses for the core languages can be extended to work across higher-order modules. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and N. Heintze. </author> <title> Constraint-based program analysis. </title> <booktitle> POPL'95 Tutorial, </booktitle> <month> January </month> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining [2], partial evaluation [17], and constraint-based analysis <ref> [1] </ref>, lose all their information at the functor-application boundaries.
Reference: [2] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining <ref> [2] </ref>, partial evaluation [17], and constraint-based analysis [1], lose all their information at the functor-application boundaries.
Reference: [3] <author> E. Biagioni, R. Harper, P. Lee, and B. Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 55-64, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [3, 31, 9] </ref>. Many modern programming languages such as Modula-3 [31] and Standard ML [26, 27] provide support for both core-level and module-level programming.
Reference: [4] <author> S. K. Biswas. </author> <title> Higher-order functors with transparent signatures. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 154-163, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Several recent papers <ref> [13, 4, 20] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [13], no parameterized types [4], 2 kind t ::= j t ! 0 t j fl :: t ; :::; l 0 <p> Several recent papers [13, 4, 20] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [13], no parameterized types <ref> [4] </ref>, 2 kind t ::= j t ! 0 t j fl :: t ; :::; l 0 :: 0 tycon t ::= ff j Int j t ! 0 t j ff :: t : t j t [ 0 t g j t :l type t ::= T ( <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [13, 4, 20] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Harper and Stone [15] give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. Biswas <ref> [4] </ref> gives a semantics for the MacQueen-Tofte modules based on simple polymorphic types; however, his algorithm does not support parameterized type constructors.
Reference: [5] <author> M. Blume and A. W. Appel. Lambda-splitting: </author> <title> A higher-order approach to cross-module optimizations. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 112-124. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Both Lillibridge [23] and Leroy [21] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel <ref> [5] </ref> proposed a cross-module inlining algorithm that supports in-lining of functions with free variables. Their algorithm is 2 Although the paper by Harper et al [13] was published in 1990, the importance of its phase-splitting algorithm was not recognized until very recently.
Reference: [6] <author> C. Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Stan-ford, California, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Unfortunately, many compilation techniques do not work on programs that use higher-order modules. In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis [18, 33], type specialization <ref> [6] </ref>, intensional type analysis [14], typed closure conversion [28], tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32].
Reference: [7] <author> J. Courant. </author> <title> An applicative module calculus. </title> <editor> In M. Bidoit and M. Dauchet, editors, TAPSOFT'97: </editor> <booktitle> Theory and Practice of Software Development: </booktitle> <volume> LNCS Vol 1214, </volume> <pages> pages 622-636, </pages> <address> New York, 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors <ref> [20, 7] </ref>, or abstract functors [11, 19, 23]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19].
Reference: [8] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 207-212, </pages> <address> New York, Jan 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages <ref> [8] </ref>. This semantic difference between the core and module languages poses great challenges to compiler writers. Although the module code itself seldom needs to be compiled efficiently, optimizations used for the core language must be compatible with the module constructs in order to have a coherent compiler. <p> Take the area of type-directed compilation as an example: recent work includes representation analysis [18, 33], type specialization [6], intensional type analysis [14], typed closure conversion [28], tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML <ref> [8] </ref> or the polymorphic -calculus F ! [10, 32]. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [9] <author> L. George. MLRISC: </author> <title> Customizable and reusable code generators. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [3, 31, 9] </ref>. Many modern programming languages such as Modula-3 [31] and Standard ML [26, 27] provide support for both core-level and module-level programming.
Reference: [10] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! <ref> [10, 32] </ref>. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [11] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [25, 11, 20] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. <p> A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [25, 11, 20] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [11, 19, 27] </ref> has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. <p> Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures <ref> [11, 19] </ref>. MacQueen and Tofte [25] have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. MacQueen and Tofte [25] have shown that even a small restriction on signature matching <ref> [19, 11] </ref> can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages [8]. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors <ref> [11, 19, 23] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19].
Reference: [12] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types <ref> [24, 12] </ref> or translucent signatures [11, 19]. MacQueen and Tofte [25] have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The ML module system was first proposed by Mac-Queen [24] and later incorporated into Standard ML [26]. Harper and Mitchell <ref> [12] </ref> show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable [13], thanks to the phase-distinction property of ML-style modules.
Reference: [13] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-344, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The challenge then is to deduce these properties statically while still supporting separate compilation. This paper exploits the semantic property <ref> [13] </ref> of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules [25] into a pred-icative variant of the F ! calculus. <p> Because modules can be compiled in the same way as ordinary polymorphic functions, all the type-based optimizations mentioned above immediately carry over to the module languages. The basic idea of our algorithm is similar to phase-splitting <ref> [13] </ref>: we notice that every ML module can be split into a type part and a value part; the type (value) part of a structure includes all of its type (value) components plus the type (value) parts of its structure and functor components; the type part of a functor is a <p> Several recent papers <ref> [13, 4, 20] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [13], no parameterized types [4], 2 kind t ::= j t ! 0 t j fl :: t ; :::; l 0 <p> Several recent papers [13, 4, 20] have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures <ref> [13] </ref>, no parameterized types [4], 2 kind t ::= j t ! 0 t j fl :: t ; :::; l 0 :: 0 tycon t ::= ff j Int j t ! 0 t j ff :: t : t j t [ 0 t g j t :l type <p> We show how to exploit the full-transparency property to support cross-module program analysis. Finally, we discuss implementation details, related work, and then conclude. 2 An F ! -based target calculus Our target calculus TGC is a predicative variant <ref> [13] </ref> of the polymorphic -calculus F ! . The syntax of TGC is given in Figure 2. Here, kinds classify type constructors (tycon); types classify terms. Declarations (dec) and the term let d t in e t are syntactic sugar introduced to simplify the presentation of our translation algorithm. <p> Harper and Mitchell [12] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable <ref> [13] </ref>, thanks to the phase-distinction property of ML-style modules. The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [13, 4, 20] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Several recent papers [13, 4, 20] have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper <ref> [13] </ref> is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett [30] and also demonstrated in this paper. <p> Blume and Appel [5] proposed a cross-module inlining algorithm that supports in-lining of functions with free variables. Their algorithm is 2 Although the paper by Harper et al <ref> [13] </ref> was published in 1990, the importance of its phase-splitting algorithm was not recognized until very recently. In fact, we reinvented the same algorithm while working on the type-directed compilation of ML-style modules during 1996. <p> The first version of our algorithm was presented at the IFIP WG2.8 meeting in September 1996. It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett [30] told us that he had problems adapting the original phase-splitting algorithm <ref> [13] </ref> to SML [27] since it does not support type abbreviations in signatures.
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis [18, 33], type specialization [6], intensional type analysis <ref> [14] </ref>, typed closure conversion [28], tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32]. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis [18, 33] and intensional type analysis <ref> [14] </ref> can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [18, 40, 14, 28, 33] </ref> to programs using ML-style modules. <p> The product and selection constructors correspond to the product kind fl :: t ; :::; l 0 :: 0 t g. Types in TGC include the monotypes, and are closed under products, function spaces, and polymorphic quantification. Following Harper and Morrisett <ref> [14] </ref>, we use T () to denote the corresponding monotype of the constructor . The terms are an explicitly typed -calculus with explicit constructor abstraction (fl) and application forms. <p> The rest of the rules are all standard, as shown in the companion technical report [35]. It is well known that type-checking for the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly defined operational semantics <ref> [29, 14] </ref>. 3 Access paths: strpath p s ::= s i j p s :s i fctpath p f ::= f i j p s :f i typpath p t ::= t i j p s :t i Signatures and specifications: spec D ::= " j DD 0 j type t <p> Shao and Appel [36] extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [18, 33, 14, 28, 40] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [14, 33, 34] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries.
Reference: [15] <author> R. Harper and C. Stone. </author> <title> An interpretation of Standard ML in type theory. </title> <type> Technical Report CMU-CS-97-147, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper [13] is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett [30] and also demonstrated in this paper. Harper and Stone <ref> [15] </ref> give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. Biswas [4] gives a semantics for the MacQueen-Tofte modules based on simple polymorphic types; however, his algorithm does not support parameterized type constructors.
Reference: [16] <author> M. P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Twenty-third Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 68-78, </pages> <address> New York, Jan 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23].
Reference: [17] <author> N. D. Jones. </author> <title> Partial evaluation. </title> <booktitle> POPL'91, tutorial handout, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Higher-order modules also make it very difficult to carry out static program analysis across the module boundaries. Because the module signature does not propagate any static information other than types, many existing techniques, such as constant propagation, function inlining [2], partial evaluation <ref> [17] </ref>, and constraint-based analysis [1], lose all their information at the functor-application boundaries.
Reference: [18] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: Unfortunately, many compilation techniques do not work on programs that use higher-order modules. In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis <ref> [18, 33] </ref>, type specialization [6], intensional type analysis [14], typed closure conversion [28], tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32]. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis <ref> [18, 33] </ref> and intensional type analysis [14] can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [18, 40, 14, 28, 33] </ref> to programs using ML-style modules. <p> We are currently working together on an inlin-ing algorithm that combines the best of both schemes. Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel [36] extended Leroy's representation analysis <ref> [18] </ref> to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. <p> Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel [36] extended Leroy's representation analysis <ref> [18] </ref> to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations [18, 33, 14, 28, 40] that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. <p> Shao and Appel [36] extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [18, 33, 14, 28, 40] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
Reference: [19] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [25, 11, 20] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [11, 19, 27] </ref> has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. <p> Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures <ref> [11, 19] </ref>. MacQueen and Tofte [25] have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. MacQueen and Tofte [25] have shown that even a small restriction on signature matching <ref> [19, 11] </ref> can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. It is fair to say that the type systems for higher-order modules is much more elaborate than (or at least very different from) those for the core-ML-like languages [8]. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors <ref> [11, 19, 23] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19]. <p> Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation <ref> [19] </ref>. This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while.
Reference: [20] <author> X. Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 142-153, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [25, 11, 20] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. <p> Several recent papers <ref> [13, 4, 20] </ref> have attacked similar problems but with completely different motivations; they also impose severe restrictions to their module languages (e.g., no type abbreviation or sharing inside signatures [13], no parameterized types [4], 2 kind t ::= j t ! 0 t j fl :: t ; :::; l 0 <p> g t ; ` t e t : t ::: ; ` t e 0 t t g : fl : t ; :::; l 0 : 0 (prod ) ; ` t e t : f:::; l : t ; :::g (select ) and limited forms of functor arguments <ref> [20] </ref>). * Our compilation algorithm can handle the entire SML'97 language [27] including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors <ref> [20, 7] </ref>, or abstract functors [11, 19, 23]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19]. <p> This paper shows that at least from the implementation point of view, full transparency is important in providing optimal support to efficient cross-module compilation. The question of whether higher-order modules can be compiled into simple F ! -like calculus has been open for a while. Several recent papers <ref> [13, 4, 20] </ref> have attacked variants of this problem with different motivations; however, they all impose severe restrictions to their module languages. <p> Another difference is that in his scheme, functors are not considered as higher-order type constructors, instead, he has to encode certain type constructors of kind using higher-order types; this significantly complicates his semantics. Finally, Leroy <ref> [20] </ref> uses applicative functors to achieve full transparency, but his approach handles limited functor arguments only; Courant [7]'s semantics does not have such restriction, but he did not give a translation of his calculus into the F ! calculus.
Reference: [21] <author> X. Leroy. </author> <title> A modular module system. </title> <type> Technical report 2866, </type> <institution> INRIA, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: Finally, Leroy [20] uses applicative functors to achieve full transparency, but his approach handles limited functor arguments only; Courant [7]'s semantics does not have such restriction, but he did not give a translation of his calculus into the F ! calculus. Both Lillibridge [23] and Leroy <ref> [21] </ref> discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel [5] proposed a cross-module inlining algorithm that supports in-lining of functions with free variables.
Reference: [22] <author> X. Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 1-32, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: A signature contains a list of type, structure, and functor specifications (D). A type specification can either be a flexible one| specifying only the arity of the underlying type constructor; or it can be a type abbreviation. Type-sharing specifications in SFC are converted into type abbreviations <ref> [22] </ref>. A structure expression can be a structure path (p s ), a functor application (f i (s i )), a structure matched by a signature (s i : M s ), or a definitional structure (m b ).
Reference: [23] <author> M. Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1997. </year> <note> Tech Report CMU-CS-97-122. </note>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors <ref> [11, 19, 23] </ref>. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19]. <p> Finally, Leroy [20] uses applicative functors to achieve full transparency, but his approach handles limited functor arguments only; Courant [7]'s semantics does not have such restriction, but he did not give a translation of his calculus into the F ! calculus. Both Lillibridge <ref> [23] </ref> and Leroy [21] discussed how to add value identities to their module interfaces though neither of them gave any actual algorithm. Blume and Appel [5] proposed a cross-module inlining algorithm that supports in-lining of functions with free variables.
Reference: [24] <author> D. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types <ref> [24, 12] </ref> or translucent signatures [11, 19]. MacQueen and Tofte [25] have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> Recent work [36, 38, 33] shows that type-based optimizations dramatically improve the performance of heavily modularized ML programs. 10 6 Related work Module systems have been an active research area in the past decade. The ML module system was first proposed by Mac-Queen <ref> [24] </ref> and later incorporated into Standard ML [26]. Harper and Mitchell [12] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types.
Reference: [25] <author> D. MacQueen and M. Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: The module language, on the other hand, provides glue to organize large programs and to build generic and reusable components. A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules <ref> [25, 11, 20] </ref> are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. <p> Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. MacQueen and Tofte <ref> [25] </ref> have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The challenge then is to deduce these properties statically while still supporting separate compilation. This paper exploits the semantic property [13] of ML-style modules to support efficient cross-module compilation. More specifically, we present a type-directed translation of the MacQueen-Tofte higher-order modules <ref> [25] </ref> into a pred-icative variant of the F ! calculus. Because modules can be compiled in the same way as ordinary polymorphic functions, all the type-based optimizations mentioned above immediately carry over to the module languages. <p> Other kinds of program analysis can be extended to work across higher-order modules in the same way. * To facilitate our presentation, we give a new and more complete formal definition for the MacQueen-Tofte higher-order modules. MacQueen and Tofte's original semantics <ref> [25] </ref> does not address many important features such as type specifications, type declarations, and hidden module components. Our new semantics covers a much richer language and solves the remaining technical problems. <p> ::= p f j funct (s i : M s )m b 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language [27] extended with the MacQueen-Tofte higher-order modules <ref> [25] </ref>. We divide the translation from SFC to TGC into two steps: * First, we perform a series of syntactic transformations and normalizations, and then translate the SFC pro gram into a normalized module calculus (NRC); * Second, we translate the NRC program into the TGC calculus. <p> ` x M =) t Figure 9 module type translation ` x (M ; r ) =) t ; t Figure 9 3.2 Static semantics for NRC Before presenting the translation from NRC to TGC, we first give a new and more complete formal semantics for the MacQueen-Tofte higher-order modules <ref> [25] </ref> in the context of NRC. Under our stamp-based approach, the "type" of a module|also called the modtype in this paper|is expressed as a pair of a signature and a realization. <p> The most unusual aspect of our semantics is the rules for signature subsumption (see Rules 1-8 in Figure 7): they are much more restrictive than those used by MacQueen and Tofte <ref> [25] </ref>. To have one signature subsume another, both must contain the same number of components, following the same order (Rules 2 and 3); furthermore, the respective functor components must have syntactically equivalent signature (Rule 4). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones <ref> [25] </ref>, to applicative functors [20, 7], or abstract functors [11, 19, 23]. Fully transparent modules are most expressive, but it is not clear whether they are absolutely necessary; they also interact poorly with true separate compilation [19]. <p> Finally, we have presented a new and more complete formal definition for the MacQueen-Tofte higher-order modules; our new semantics covers a much richer language and solves all the remaining technical problems in MacQueen and Tofte's original proposal <ref> [25] </ref>. Availability The implementation discussed in this paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler [34]. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&T. FLINT is a modern compiler infrastructure developed at Yale University.
Reference: [26] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [3, 31, 9]. Many modern programming languages such as Modula-3 [31] and Standard ML <ref> [26, 27] </ref> provide support for both core-level and module-level programming. The core fl This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No. <p> ML-style higher-order modules [25, 11, 20] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules [11, 19, 27] has cleaned up many rough spots in the original design <ref> [26] </ref>. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. MacQueen and Tofte [25] have shown that even a small restriction on signature matching [19, 11] can significantly compromise the overall expressiveness (i.e., full transparency) of the underlying module language. <p> The ML module system was first proposed by Mac-Queen [24] and later incorporated into Standard ML <ref> [26] </ref>. Harper and Mitchell [12] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types.
Reference: [27] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [3, 31, 9]. Many modern programming languages such as Modula-3 [31] and Standard ML <ref> [26, 27] </ref> provide support for both core-level and module-level programming. The core fl This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No. <p> A mature and scalable compiler must support both styles of programming well, generating decent code even for heavily modularized programs. ML-style higher-order modules [25, 11, 20] are widely recognized as one of the most powerful module constructs in existence today. Recent work on the type-theoretic foundations of ML modules <ref> [11, 19, 27] </ref> has cleaned up many rough spots in the original design [26]. Still, the semantics for higher-order modules involves the use of dependent types [24, 12] or translucent signatures [11, 19]. <p> ` t e 0 t t g : fl : t ; :::; l 0 : 0 (prod ) ; ` t e t : f:::; l : t ; :::g (select ) and limited forms of functor arguments [20]). * Our compilation algorithm can handle the entire SML'97 language <ref> [27] </ref> including both transparent and opaque signature matching. In fact, the algorithm has been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> ::= struct d end fct m f ::= p f j funct (s i : M s )m b 3 Module semantics and translation To show how we translate the ML-style modules into the TGC calculus, we choose a surface language (SFC) that is similar to the SML'97 module language <ref> [27] </ref> extended with the MacQueen-Tofte higher-order modules [25]. <p> The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). In our implementation, we extended the NRC-to-TGC translation to handle other features in SML'97 <ref> [27] </ref> such as value components, opaque signature matching, polymorphic types, and recursive datatypes. The translation makes it possible to support type-based optimizations even in the presence of higher-order modules. <p> Under our implementation, only type-related components are re-elaborated at each functor application; all value-related components are type-checked once and for all when the functor definition is processed. Opaque signature matching <ref> [27] </ref> can be implemented using the same signature-instantiation algorithm given in Figure 8. All flexible type components are turned into "abstract" types, represented as fresh stamps annotated with its representation type (e.g., n (; )). <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched [11, 19, 20, 23, 39, 25, 16] and mostly resolved in SML'97 <ref> [27] </ref>. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23]. <p> It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett [30] told us that he had problems adapting the original phase-splitting algorithm [13] to SML <ref> [27] </ref> since it does not support type abbreviations in signatures.
Reference: [28] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Proc. 23rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 271-283. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis [18, 33], type specialization [6], intensional type analysis [14], typed closure conversion <ref> [28] </ref>, tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32]. <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [18, 40, 14, 28, 33] </ref> to programs using ML-style modules. <p> Shao and Appel [36] extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [18, 33, 14, 28, 40] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
Reference: [29] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: The rest of the rules are all standard, as shown in the companion technical report [35]. It is well known that type-checking for the TGC-like calculus is decidable, and furthermore, its typing rules are consistent with properly defined operational semantics <ref> [29, 14] </ref>. 3 Access paths: strpath p s ::= s i j p s :s i fctpath p f ::= f i j p s :f i typpath p t ::= t i j p s :t i Signatures and specifications: spec D ::= " j DD 0 j type t
Reference: [30] <author> G. Morrisett. </author> <type> Personal Communication, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: The algorithm hidden inside Harper, Mitchell, and Moggi's phase-distinction paper [13] is most related, however, it does not support type abbreviation and sharing in signatures. 2 Supporting type abbreviation is non-trivial, as discovered by Morrisett <ref> [30] </ref> and also demonstrated in this paper. Harper and Stone [15] give a new type-theoretical semantics for the entire SML'97, however, their internal language, IL, contains a separate module calculus that uses translucent signatures. <p> The first version of our algorithm was presented at the IFIP WG2.8 meeting in September 1996. It was at that meeting when Bob Harper pointed us to the phase-distinction paper. In January 1997, Greg Morrisett <ref> [30] </ref> told us that he had problems adapting the original phase-splitting algorithm [13] to SML [27] since it does not support type abbreviations in signatures.
Reference: [31] <author> G. Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems <ref> [3, 31, 9] </ref>. Many modern programming languages such as Modula-3 [31] and Standard ML [26, 27] provide support for both core-level and module-level programming. <p> 1 Introduction Modular programming has proven to be extremely valuable in the development and maintenance of large software systems [3, 31, 9]. Many modern programming languages such as Modula-3 <ref> [31] </ref> and Standard ML [26, 27] provide support for both core-level and module-level programming. The core fl This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Software Evolution using HOT Language Technology," DARPA Order No. D888, issued under Contract No.
Reference: [32] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! <ref> [10, 32] </ref>. While they have all demonstrated that types can be used to make programs run faster and consume less space, it is not obvious how any of these would work in the presence of higher-order modules (which make use of dependent types).
Reference: [33] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Unfortunately, many compilation techniques do not work on programs that use higher-order modules. In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis <ref> [18, 33] </ref>, type specialization [6], intensional type analysis [14], typed closure conversion [28], tagless garbage collection [40], to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32]. <p> Therefore, polymorphic functions in F ! or core ML can be specialized to particular type arguments at compile time. Furthermore, both representation analysis <ref> [18, 33] </ref> and intensional type analysis [14] can be performed, inserting coercions or runtime type parameters at every type-application site. Higher-order modules, on the other hand, express both the type and value abstractions through a single construct (i.e., functor). <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [18, 40, 14, 28, 33] </ref> to programs using ML-style modules. <p> Although the translation algorithm itself does not improve the efficiency of the module code, it does allow many type-based optimizations to be applied to languages that use ML-style modules. Recent work <ref> [36, 38, 33] </ref> shows that type-based optimizations dramatically improve the performance of heavily modularized ML programs. 10 6 Related work Module systems have been an active research area in the past decade. The ML module system was first proposed by Mac-Queen [24] and later incorporated into Standard ML [26]. <p> Shao and Appel [36] extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [18, 33, 14, 28, 40] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997). <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [14, 33, 34] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries.
Reference: [34] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The elaboration is simple and very efficient because the module-level code is always small and non-recursive. 5 Implementation We have implemented both the translation algorithm and the cross-module inlining algorithm in the SML/NJ compiler [36] and the FLINT/ML compiler <ref> [34] </ref>. The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). In our implementation, we extended the NRC-to-TGC translation to handle other features in SML'97 [27] such as value components, opaque signature matching, polymorphic types, and recursive datatypes. <p> The main contribution of our work is the translation algorithm from ML-style modules (SML'97 extended with MacQueen-Tofte higher-order modules) to the F ! calculus. Without such translation, none of those important type-based optimizations <ref> [14, 33, 34] </ref> would apply to the full SML language. We have also presented ways to extend various program analyses to work across higher-order modules; in fact, we show that for fully transparent modules, static information can always be optimally propagated across the module boundaries. <p> Availability The implementation discussed in this paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler <ref> [34] </ref>. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&T. FLINT is a modern compiler infrastructure developed at Yale University.
Reference: [35] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <type> Technical Report YALEU/DCS/RR-1126, </type> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Figure 3 gives the typing rules for the product-related constructors and terms. The rest of the rules are all standard, as shown in the companion technical report <ref> [35] </ref>. <p> To make the paper more focused, we will only briefly explain the first step, and then concentrate on describing the NRC calculus and how we translate NRC into the TGC calculus. The companion TR <ref> [35] </ref> gives more details about the SFC calculus and the SFC-to-NRC translation. 3.1 Normalization and the NRC calculus The syntax of our normalized module calculus NRC is defined in Figure 4. <p> The translation from SFC to NRC does a series of normalizations that turn complex SFC constructs into simpler and more primitive NRC constructs. The most important transformation is to make explicit all enrichment coercions occurring at every signature matching (see the companion TR <ref> [35] </ref> for details). <p> Meanwhile, functor application such as F (S) is translated into: let structure T = F (S) in T:R end. Finally, all module declarations inside the let expressions in SFC are pushed upwards and then turned into the NRC local declarations (see the companion TR <ref> [35] </ref> for details). 4 Stamp n same as i Tycon m ::= n ( c ; t ) j ff j int j m ! 0 m m ] TypRlzn r t ::= m StrRlzn r s ::= R FctRlzn r f ::= (m b ; B; A t ) j <p> In the companion TR <ref> [35] </ref>, we show that as long as the basis B satisfies certain pre-conditions (i.e., it is well-formed and it preserves TGC typing, see TR [35] for detailed definitions), our translation algorithm preserves typing. <p> In the companion TR <ref> [35] </ref>, we show that as long as the basis B satisfies certain pre-conditions (i.e., it is well-formed and it preserves TGC typing, see TR [35] for detailed definitions), our translation algorithm preserves typing. <p> The new inlining algorithm replaced the old ad-hoc algorithm in SML/NJ which does not even propagate inlin-ing information across signature matching. In the following, we briefly explain some of these implementation issues; more details can be found in the companion TR <ref> [35] </ref>. Adding value components to the NRC calculus is quite trivial. Handling value specifications in signatures requires a utility function (i.e., c2m) to convert source-level types ( c ) into internal semantic types ( m ).
Reference: [36] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: The elaboration is simple and very efficient because the module-level code is always small and non-recursive. 5 Implementation We have implemented both the translation algorithm and the cross-module inlining algorithm in the SML/NJ compiler <ref> [36] </ref> and the FLINT/ML compiler [34]. The implementation in SML/NJ has been released and in production use since version 109.24 (January 9, 1997). In our implementation, we extended the NRC-to-TGC translation to handle other features in SML'97 [27] such as value components, opaque signature matching, polymorphic types, and recursive datatypes. <p> Although the translation algorithm itself does not improve the efficiency of the module code, it does allow many type-based optimizations to be applied to languages that use ML-style modules. Recent work <ref> [36, 38, 33] </ref> shows that type-based optimizations dramatically improve the performance of heavily modularized ML programs. 10 6 Related work Module systems have been an active research area in the past decade. The ML module system was first proposed by Mac-Queen [24] and later incorporated into Standard ML [26]. <p> We are currently working together on an inlin-ing algorithm that combines the best of both schemes. Type-directed compilation has received much attention lately, but little has been done to extend it to work across higher-order modules. Shao and Appel <ref> [36] </ref> extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18].
Reference: [37] <author> O. Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon Univ., Pittsburgh, Pennsylvania, </institution> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Under this algorithm, the binding information of each value component is always propagated optimally even across higher-order modules. A more traditional approach would compile the higher-order modules into the usual higher-order functions in the core language, and then perform the heavyweight control flow analysis <ref> [37] </ref> on them. Our module elaboration algorithm is somewhat similar to the abstract execution, but it separates the module-level declarations from the the core-language expressions within.
Reference: [38] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Although the translation algorithm itself does not improve the efficiency of the module code, it does allow many type-based optimizations to be applied to languages that use ML-style modules. Recent work <ref> [36, 38, 33] </ref> shows that type-based optimizations dramatically improve the performance of heavily modularized ML programs. 10 6 Related work Module systems have been an active research area in the past decade. The ML module system was first proposed by Mac-Queen [24] and later incorporated into Standard ML [26].
Reference: [39] <author> M. Tofte. </author> <title> Principal signatures for high-order ML functors. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 189-199, </pages> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [11, 19, 20, 23, 39, 25, 16] </ref> and mostly resolved in SML'97 [27]. The main remaining issue is with the design of higher-order modules, with proposals ranging from fully transparent ones [25], to applicative functors [20, 7], or abstract functors [11, 19, 23].
Reference: [40] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher> <pages> 12 </pages>
Reference-contexts: In fact, most recent work on compiling functional languages have ignored issues on the necessary module support. Take the area of type-directed compilation as an example: recent work includes representation analysis [18, 33], type specialization [6], intensional type analysis [14], typed closure conversion [28], tagless garbage collection <ref> [40] </ref>, to name just a few. All of these are performed on the variants of core ML [8] or the polymorphic -calculus F ! [10, 32]. <p> The main contributions of this paper are: * As far as we know, our work is the first comprehensive and formal study on how to apply type-based compilation techniques <ref> [18, 40, 14, 28, 33] </ref> to programs using ML-style modules. <p> Shao and Appel [36] extended Leroy's representation analysis [18] to work for the SML'90 modules; their algorithm works only for the pure-coercion-based representation analysis [18]. The algorithm in this paper translates the module language into the F ! calculus, so type-based optimizations <ref> [18, 33, 14, 28, 40] </ref> that work for F ! immediately work for higher-order modules as well. 7 Conclusions We have presented a series of techniques for compiling across higher-order modules. These techniques have been implemented and released with the SML/NJ compiler since version 109.24 (January 9, 1997).
References-found: 40

