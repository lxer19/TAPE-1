URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/locks.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: [flanagan|ma]@pa.dec.com  
Title: Types for Safe Locking  
Author: Cormac Flanagan and Martin Abadi 
Affiliation: Systems Research Center, Compaq  
Abstract: A race condition is a situation where two threads manipulate a data structure simultaneously, without synchronization. Race conditions are common errors in multithreaded programming. They often lead to unintended nondeterminism and wrong results. Moreover, they are notoriously hard to diagnose, and attempts to eliminate them can introduce deadlocks. In practice, race conditions and deadlocks are often avoided through prudent programming discipline: protecting each shared data structure with a lock and imposing a partial order on lock acquisitions. In this paper we show that this discipline can be captured (if not completely, to a significant extent) through a set of static rules. We present these rules as a type system for a concurrent, imperative language. Although weaker than a full-blown program-verification calculus, the type system is effective and easy to apply. We emphasize a core, first-order type system focused on race conditions; we also consider extensions with polymorphism, existential types, and a partial order on lock types. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abramsky, S. Gay, and R. Nagarajan. </author> <title> A type-theoretic approach to deadlock-freedom of asynchronous systems. </title> <booktitle> In Theoretical Aspects of Computer Software, volume 1281 of Lecture Notes in Computer Science, </booktitle> <pages> pages 295-320. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) [22], deal only with finite state spaces [7, 10, 12], or do not handle mainstream shared-variable programming paradigms <ref> [1, 16] </ref>. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. We defer a more detailed discussion of related work to section 7. <p> His type system has a deadlock-free subset, and uses the notion of time tags, which are similar to our locking levels. Although Kobayashi considers some sophisticated determinism properties, he does not address race conditions directly. Abramsky, Gay, and Nagarajan <ref> [1] </ref> present another type-based technique for avoiding deadlocks. Their work is based on interaction categories inspired by linear logic. It emphasizes issues of type structure, rather than their application to a specific programming language.
Reference: 2. <author> A. Aiken and D. Gay. </author> <title> Barrier inference. </title> <booktitle> In Proceedings of the 25th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 243-354, </pages> <year> 1998. </year>
Reference-contexts: First, Warlock works by tracing execution paths, but it fails to trace paths through loops or recursive function calls. Second, Warlock appears to merge different locks of the same type, and so may fail to detect inconsistent locking. Aiken and Gay <ref> [2] </ref> also investigate static race detection, in the somewhat different setting of SPMD programs. They present a system that has been used successfully on a variety of SPMD programs. Synchronization in these programs is performed using barriers.
Reference: 3. <author> T. Amtoft, F. Nielson, and H. R. Nielson. </author> <title> Type and behaviour reconstruction for higher-order concurrent programs. </title> <journal> Journal of Functional Programming, </journal> <volume> 7(3) </volume> <pages> 321-347, </pages> <year> 1997. </year>
Reference-contexts: The permissions that we use are similar to effects [15, 17, 18] in that the permission of an expression constrains the effects that it may produce. Much work has been done on effect reconstruction <ref> [3, 23-25] </ref>. It may be possible to adapt these inference methods in our setting in order to remove the need for explicit lock annotations. 8 Conclusions This paper describes how a type system can be used for avoiding two major pitfalls of multithreaded programming, namely race conditions and deadlocks.
Reference: 4. <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <year> 1991. </year>
Reference-contexts: Dwyer and Clarke [11] describe a data-flow analysis for verifying certain correctness properties of concurrent programs, for example mutual exclusion on particular resources. The authors suggest that their analysis is not well suited for detecting global properties such as deadlock. Avrunin et al. <ref> [4] </ref> describe a toolset for analyzing concurrent programs. This toolset has been used for detecting race conditions and deadlocks in a variety of benchmarks, on a case-by-case basis. Savage et al. [21] describe Eraser, a tool for detecting race conditions and deadlocks dynamically (rather than statically, as in our method).
Reference: 5. <author> A. D. Birrell. </author> <title> An introduction to programming with threads. </title> <type> Research Report 35, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: A deadlock occurs when no thread can make progress because each is blocked on a lock held by some other thread. In practice, both race conditions and deadlocks are often avoided through careful programming discipline <ref> [5] </ref>. Race conditions are avoided by protecting each shared data structure with a lock, and accessing the data structure only when the protecting lock is held. Deadlocks are avoided by imposing a strict partial order on locks and ensuring that each thread acquires locks only in increasing order. <p> In addition, our type system is somewhat over-conservative in that it does not allow simultaneous reads of a data structure, even though simultaneous reads are not normally considered race conditions, and in fact many programs use reader-writer locks to permit such simultaneous reads <ref> [5] </ref>. We believe that adding a treatment of reader-writer locks to our type system should not be difficult. 3 Operational Semantics We specify the operational semantics of our language using the abstract machine described in figure 3. The machine evaluates a program by stepping through a sequence of states. <p> Extending the type system for deadlock elimination (highlights). In practice, deadlocks are commonly avoided by imposing a strict partial order on locks, and respecting this order when acquiring locks <ref> [5] </ref>. We capture this discipline by embodying it in an extension of our type system. Our extended type system relies on annotations that specify a lock ordering.
Reference: 6. <author> L. Cardelli. </author> <title> Type systems. </title> <booktitle> Handbook of Computer Science and Engineering, </booktitle> <pages> pages 2208-2236, </pages> <year> 1997. </year>
Reference-contexts: This insight suggests the use of existential types for typing such programs. It is straightforward to extend the type system with existential types, as outlined in figure 7. The type rules closely follow the conventional rules for existential types <ref> [6] </ref>. In the rule for pack , the lock type n is hidden and replaced with the type variable m in the resulting existential type (9m :: Lock : t). <p> We do not explicitly allow for renaming in the rule for open, since renaming can be accomplished using ff-conversion, if necessary. Examples Some of the following examples use product, sum, and recursive types, which are easily added to the type system, as in <ref> [6] </ref>.
Reference: 7. <author> A. T. Chamillard, L. A. Clarke, and G. S. Avrunin. </author> <title> An empirical comparison of static concurrency analysis techniques. </title> <type> Technical Report 96-084, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst, </institution> <year> 1996. </year>
Reference-contexts: There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) [22], deal only with finite state spaces <ref> [7, 10, 12] </ref>, or do not handle mainstream shared-variable programming paradigms [1, 16]. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. We defer a more detailed discussion of related work to section 7. <p> In general, static checking and testing are complementary, and they should both be used in the development of reliable software. Hybrid approaches (like that of the Cilk Determinator [8]) seem promising. There is a large amount of work on model-checking of concurrent programs, particularly focused on finite-state systems (e.g., <ref> [7, 10, 12] </ref>). Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis.
Reference: 8. <author> G.-I. Cheng, M. Feng, C. E. Leiserson, K. H. Randall, and A. F. Stark. </author> <title> Detecting data races in Cilk programs that use locks. </title> <booktitle> In Proceedings of the 10th Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 298-309, </pages> <year> 1998. </year>
Reference-contexts: Although quite effective, Eraser may fail to detect certain race conditions and deadlocks because of insufficient test coverage. In general, static checking and testing are complementary, and they should both be used in the development of reliable software. Hybrid approaches (like that of the Cilk Determinator <ref> [8] </ref>) seem promising. There is a large amount of work on model-checking of concurrent programs, particularly focused on finite-state systems (e.g., [7, 10, 12]). Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis.
Reference: 9. <author> C. Colby. </author> <title> Analyzing the communication topology of concurrent programs. </title> <booktitle> In ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 202-213, </pages> <year> 1995. </year>
Reference-contexts: A number of analyses have been developed for concurrent languages such as CML [20]. Nielson and Nielson [19] present an analysis that predicts process and channel utilization and uses this information for optimization. Their analysis is based on the notion of behaviors, which are similar to our permissions. Colby <ref> [9] </ref> also presents an analysis that infers information about channel usage. Neither work treats race conditions or deadlocks. Kobayashi [16] presents a first-order type system for a process calculus. His type system has a deadlock-free subset, and uses the notion of time tags, which are similar to our locking levels.
Reference: 10. <author> J. C. Corbett. </author> <title> Evaluating deadlock detection methods for concurrent software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(3) </volume> <pages> 161-180, </pages> <year> 1996. </year>
Reference-contexts: There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) [22], deal only with finite state spaces <ref> [7, 10, 12] </ref>, or do not handle mainstream shared-variable programming paradigms [1, 16]. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. We defer a more detailed discussion of related work to section 7. <p> In general, static checking and testing are complementary, and they should both be used in the development of reliable software. Hybrid approaches (like that of the Cilk Determinator [8]) seem promising. There is a large amount of work on model-checking of concurrent programs, particularly focused on finite-state systems (e.g., <ref> [7, 10, 12] </ref>). Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis.
Reference: 11. <author> M. B. Dwyer and L. A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <type> Technical Report 94-045, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst, </institution> <year> 1994. </year>
Reference-contexts: Abramsky, Gay, and Nagarajan [1] present another type-based technique for avoiding deadlocks. Their work is based on interaction categories inspired by linear logic. It emphasizes issues of type structure, rather than their application to a specific programming language. Dwyer and Clarke <ref> [11] </ref> describe a data-flow analysis for verifying certain correctness properties of concurrent programs, for example mutual exclusion on particular resources. The authors suggest that their analysis is not well suited for detecting global properties such as deadlock. Avrunin et al. [4] describe a toolset for analyzing concurrent programs.
Reference: 12. <author> L. Fajstrup, E. Goubault, and M. Raussen. </author> <title> Detecting deadlocks in concurrent systems. </title> <booktitle> In CONCUR'98: Concurrency Theory, volume 1466 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) [22], deal only with finite state spaces <ref> [7, 10, 12] </ref>, or do not handle mainstream shared-variable programming paradigms [1, 16]. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. We defer a more detailed discussion of related work to section 7. <p> In general, static checking and testing are complementary, and they should both be used in the development of reliable software. Hybrid approaches (like that of the Cilk Determinator [8]) seem promising. There is a large amount of work on model-checking of concurrent programs, particularly focused on finite-state systems (e.g., <ref> [7, 10, 12] </ref>). Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis.
Reference: 13. <author> P. Godefroid. </author> <title> Model checking for programming languages using VeriSoft. </title> <booktitle> In Proceedings of the 24th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-186, </pages> <year> 1997. </year>
Reference-contexts: Hybrid approaches (like that of the Cilk Determinator [8]) seem promising. There is a large amount of work on model-checking of concurrent programs, particularly focused on finite-state systems (e.g., [7, 10, 12]). Recently, Godefroid has applied model-checking techniques to C programs <ref> [13] </ref>; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis. The permissions that we use are similar to effects [15, 17, 18] in that the permission of an expression constrains the effects that it may produce. Much work has been done on effect reconstruction [3, 23-25].
Reference: 14. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: It also introduces the type variable m which denotes the singleton lock type of the new lock. The expression sync e 1 e 2 is evaluated in a manner similar to Java's synchronized statement <ref> [14] </ref>: the subexpression e 1 is evaluated first, and should yield a lock, which is then acquired; the subexpression e 2 is then evaluated; and finally the lock is released. The result of e 2 is returned as the result of the sync expression.
Reference: 15. <author> P. Jouvelot and D. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Proceedings of the 18th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310, </pages> <year> 1991. </year>
Reference-contexts: Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis. The permissions that we use are similar to effects <ref> [15, 17, 18] </ref> in that the permission of an expression constrains the effects that it may produce. Much work has been done on effect reconstruction [3, 23-25].
Reference: 16. <author> N. Kobayashi. </author> <title> A partially deadlock-free typed process calculus. </title> <booktitle> In Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 128-139, </pages> <year> 1997. </year>
Reference-contexts: There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) [22], deal only with finite state spaces [7, 10, 12], or do not handle mainstream shared-variable programming paradigms <ref> [1, 16] </ref>. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. We defer a more detailed discussion of related work to section 7. <p> Their analysis is based on the notion of behaviors, which are similar to our permissions. Colby [9] also presents an analysis that infers information about channel usage. Neither work treats race conditions or deadlocks. Kobayashi <ref> [16] </ref> presents a first-order type system for a process calculus. His type system has a deadlock-free subset, and uses the notion of time tags, which are similar to our locking levels. Although Kobayashi considers some sophisticated determinism properties, he does not address race conditions directly.
Reference: 17. <author> J. M. Lucassen and D. K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 47-57, </pages> <year> 1988. </year>
Reference-contexts: Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis. The permissions that we use are similar to effects <ref> [15, 17, 18] </ref> in that the permission of an expression constrains the effects that it may produce. Much work has been done on effect reconstruction [3, 23-25].
Reference: 18. <author> F. Nielson. </author> <title> Annotated type and effect systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(2) </volume> <pages> 344-345, </pages> <year> 1996. </year> <title> Invited position statement for the Symposium on Models of Programming Languages and Computation. </title>
Reference-contexts: Recently, Godefroid has applied model-checking techniques to C programs [13]; his approach, stateless state-space exploration, relies on dynamic observation rather than static analysis. The permissions that we use are similar to effects <ref> [15, 17, 18] </ref> in that the permission of an expression constrains the effects that it may produce. Much work has been done on effect reconstruction [3, 23-25].
Reference: 19. <author> H. R. Nielson and F. Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Proceedings of the 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1994. </year>
Reference-contexts: Since a barrier is a global operation not associated with any particular variable in the program, they do not develop machinery for tracking the association between reference cells and their protecting locks. A number of analyses have been developed for concurrent languages such as CML [20]. Nielson and Nielson <ref> [19] </ref> present an analysis that predicts process and channel utilization and uses this information for optimization. Their analysis is based on the notion of behaviors, which are similar to our permissions. Colby [9] also presents an analysis that infers information about channel usage. Neither work treats race conditions or deadlocks.
Reference: 20. <author> J. H. Reppy. </author> <title> CML: a higher-order concurrent language. </title> <booktitle> In ACM '91 Conference on Programming Language Design and Implementation., </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: Since a barrier is a global operation not associated with any particular variable in the program, they do not develop machinery for tracking the association between reference cells and their protecting locks. A number of analyses have been developed for concurrent languages such as CML <ref> [20] </ref>. Nielson and Nielson [19] present an analysis that predicts process and channel utilization and uses this information for optimization. Their analysis is based on the notion of behaviors, which are similar to our permissions. Colby [9] also presents an analysis that infers information about channel usage.
Reference: 21. <author> S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and T. E. Anderson. Eraser: </author> <title> A dynamic data race detector for multi-threaded programs. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 15(4) </volume> <pages> 391-411, </pages> <year> 1997. </year>
Reference-contexts: Avrunin et al. [4] describe a toolset for analyzing concurrent programs. This toolset has been used for detecting race conditions and deadlocks in a variety of benchmarks, on a case-by-case basis. Savage et al. <ref> [21] </ref> describe Eraser, a tool for detecting race conditions and deadlocks dynamically (rather than statically, as in our method). Although quite effective, Eraser may fail to detect certain race conditions and deadlocks because of insufficient test coverage.
Reference: 22. <author> N. Sterling. Warlock: </author> <title> A static data race analysis tool. </title> <booktitle> In USENIX Winter Technical Conference, </booktitle> <pages> pages 97-106, </pages> <year> 1993. </year>
Reference-contexts: We simply assume that the programmer can provide such information explicitly, and leave type inference as an open problem. There is a significant body of previous work in this area, but most earlier approaches are either unsound (i.e., do not detect all race conditions) <ref> [22] </ref>, deal only with finite state spaces [7, 10, 12], or do not handle mainstream shared-variable programming paradigms [1, 16]. In contrast, we aim to give a sound type system for statically verifying the absence of race conditions in a programming language with shared variables. <p> In this section, we mention some of the work most closely related to ours. Warlock <ref> [22] </ref> is a system for detecting race conditions and deadlocks statically. Its goals are similar to those of our type system. The major differences are that Warlock is an implemented system applicable to substantial programs, and that Warlock may fail to detect certain race conditions.
Reference: 23. <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 245-271, </pages> <year> 1992. </year>
Reference: 24. <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the typed call-by-value lambda-calculus using a stack of regions. </title> <booktitle> In Proceedings of the 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <year> 1994. </year>
Reference: 25. <author> M. Tofte and J.-P. Talpin. </author> <title> Region-based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176, </pages> <year> 1997. </year>
References-found: 25

