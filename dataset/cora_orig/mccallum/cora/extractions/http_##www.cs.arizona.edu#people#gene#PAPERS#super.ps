URL: http://www.cs.arizona.edu/people/gene/PAPERS/super.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Super-Pattern Matching  
Author: James R. Knight Eugene W. Myers 
Date: Revised April 26, 1996  
Pubnum: TR 92-29  
Abstract: Some recognition problems are either too complex or too ambiguous to be expressed as a simple pattern matching problem using a sequence or regular expression pattern. In these cases, a richer environment is needed to describe the patterns and recognition techniques used to perform the recognition. Some researchers have turned to artificial intelligence techniques and multi-step matching approaches for the problems of gene recognition [5, 7, 18], protein structure recognition [13] and on-line character recognition [6]. This paper presents a class of problems which involve finding matches to patterns of patterns or super-patterns, given solutions to the lower-level patterns. The expressiveness of this problem class rivals that of traditional artifical intelligence characterizations, and yet polynomial time algorithms are described for each problem in the class. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, F. E. </author> <title> Control Flow Analysis. </title> <booktitle> SIGPLAN Notices 5 (1970), </booktitle> <pages> 1-19. </pages>
Reference-contexts: Note that the graph restricted to the set of DAG edges is acyclic. Moreover, it can be shown that any cycle-free path in F has at most one back edge. Graphs with this property are commonly referred to as being reducible <ref> [1] </ref> or as having a loop connectedness parameter of 1 [8].
Reference: [2] <author> Arbarbanel, R. M., P. R. Wieneke, E. Mansfield, D. A. Jaffe, and D. L. </author> <title> Brutlag Rapid searches for complex patterns in biological molecules. </title> <journal> Nucleic Acids Research 12,1 (1984), </journal> <pages> 263-280. </pages>
Reference-contexts: This view is by no means a complete description, and is still developing as biologists learn more. At the current time, much work has been done on building recognizers for individual features using, for example, regular expressions <ref> [2] </ref>, consensus matrices [19], and neural nets [12]. Libraries of these component recognizers are currently being used to recognize either pieces of gene encodings or complete encodings. One gene recognition system, GM [5], uses eighteen modules in its gene recognition procedure.
Reference: [3] <author> Brzozowski, J. A. </author> <title> Derivatives of Regular Expressions. </title> <editor> J. </editor> <booktitle> ACM 11 (1964), </booktitle> <pages> 481-494. </pages>
Reference-contexts: Finally, the super-pattern describes the gene encoding structure using the interval types identifying the recognizers. The actual matching occurs between the sub-intervals of [0; N ] and sub-expressions of the super-pattern. A set of recursive matching rules (similar to those of <ref> [3] </ref> for pattern matching over sequences) defines the intervals matching an expression P in terms of matches to P 's sub-expressions. Formally, an interval [i; j] matches P if and only if 1. If P a where a 2 , then [i; j] 2 I a . 2.
Reference: [4] <author> Earley, J. </author> <title> An Efficient Context-Free Parsing Algorithm. </title> <editor> C. </editor> <booktitle> ACM 13,2 (1970), </booktitle> <pages> 94-102. </pages>
Reference-contexts: The extended NFA provides a solution which can be explained as an extension to the NFA simulation and can be easily recast as a super-pattern matching algorithm. In fact, the ENFA state simulation is reminiscent of Earley's algorithm <ref> [4] </ref> for context-free grammar parsing, and it is a sparse, scanning version of the Hopcroft and Ullman's naive dynamic programming algorithm analogously to the way Earley's algorithm is a sparse, scanning version of the CYK algorithm [11, 22].
Reference: [5] <author> Fields, C. and C. A. Soderlund gm: </author> <title> A Practical Tool for Automating DNA Sequence Analysis. </title> <booktitle> CABIOS 6 (1990), </booktitle> <pages> 263-270. </pages>
Reference-contexts: Libraries of these component recognizers are currently being used to recognize either pieces of gene encodings or complete encodings. One gene recognition system, GM <ref> [5] </ref>, uses eighteen modules in its gene recognition procedure. Less work has been done on integrating these subrecognizers into an overall gene recognizer. The current methods involve hand coded search procedures [5], backtracking tree-search algorithms [7], and context-sensitive, definite clause grammars [18]. <p> One gene recognition system, GM <ref> [5] </ref>, uses eighteen modules in its gene recognition procedure. Less work has been done on integrating these subrecognizers into an overall gene recognizer. The current methods involve hand coded search procedures [5], backtracking tree-search algorithms [7], and context-sensitive, definite clause grammars [18]. These techniques either lack sufficient expressiveness or contain potentially exponential computations. Super-pattern matching attempts to provide the expressiveness needed to search for these patterns while keeping within polynomial time bounds in the worst case and being efficient in practice.
Reference: [6] <author> Fujisaki, T., T. E. Chefalas, J. Kim, C. C. Tappert and C. G. </author> <title> Wolf Online Run-On Character Recognition: Design and Performance. </title> <journal> International Journal of Pattern Recognition and Artificial Intelligence 5 (1991), </journal> <pages> 123-137. </pages>
Reference-contexts: Super-pattern matching attempts to provide the expressiveness needed to search for these patterns while keeping within polynomial time bounds in the worst case and being efficient in practice. This multi-step approach to pattern matching has also appeared for such problems as protein structure prediction [13] and on-line character recognition <ref> [6] </ref>. In general terms, the matching proce 1 2 dure forms a recognition hierarchy, as depicted in Figure 2, where successively larger patterns are matched at higher and higher levels in the hierarchy. Super-pattern matching characterizes an isolated recognition problem in a general recognition hierarchy.
Reference: [7] <author> Guigo, R., S. Knudsen, N. Drake and T. </author> <title> Smith Prediction of Gene Structure. </title> <editor> J. </editor> <booktitle> of Molecular Biology 226 (1992), </booktitle> <pages> 141-157. </pages>
Reference-contexts: One gene recognition system, GM [5], uses eighteen modules in its gene recognition procedure. Less work has been done on integrating these subrecognizers into an overall gene recognizer. The current methods involve hand coded search procedures [5], backtracking tree-search algorithms <ref> [7] </ref>, and context-sensitive, definite clause grammars [18]. These techniques either lack sufficient expressiveness or contain potentially exponential computations. Super-pattern matching attempts to provide the expressiveness needed to search for these patterns while keeping within polynomial time bounds in the worst case and being efficient in practice.
Reference: [8] <author> Hecht, M. S. and J. D. </author> <title> Ullman A Simple Algorithm for Global Dataflow Analysis Programs. </title> <journal> SIAM J. Computing 4,4 (1975), </journal> <pages> 519-532. </pages>
Reference-contexts: Moreover, it can be shown that any cycle-free path in F has at most one back edge. Graphs with this property are commonly referred to as being reducible [1] or as having a loop connectedness parameter of 1 <ref> [8] </ref>.
Reference: [9] <author> Hirst, S. C. </author> <title> A New Algorithm Solving Membership of Extended Regular Expressions. </title> <type> draft. </type>
Reference-contexts: There have been two previous solutions to this problem of recognizing ERE's, one by Hopcroft and Ullman [10] and one by Hirst <ref> [9] </ref>. The Hopcroft and Ullman algorithm is a naive dynamic programming solution taking (N 3 ) time for any expression containing a Kleene closure operator. Hirst's algorithm, on the other hand, is essentially equivalent to the algorithm below in both complexity and algorithmic structure.
Reference: [10] <author> Hopcroft, J. E. and J. D. </author> <title> Ullman Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> (1979), </year> <note> Chapter 2. </note>
Reference-contexts: We use the recursive definition of a matching interval for two reasons, one practical and one computational. First, extended regular expressions under the recursive definition provide a natural method for specifying overlapping signals, one not permitted under the set-theoretic definition. Given a super-pattern ABA & AC and intervals <ref> [0; 10] </ref>; [40; 50] 2 I A , [10; 40] 2 I B and [10; 50] 2 I C , the interval [0; 50] matches both ABA and AC and so can be reported as a match to ABA & AC under the recursive definition. <p> First, extended regular expressions under the recursive definition provide a natural method for specifying overlapping signals, one not permitted under the set-theoretic definition. Given a super-pattern ABA & AC and intervals [0; 10]; [40; 50] 2 I A , <ref> [10; 40] </ref> 2 I B and [10; 50] 2 I C , the interval [0; 50] matches both ABA and AC and so can be reported as a match to ABA & AC under the recursive definition. <p> First, extended regular expressions under the recursive definition provide a natural method for specifying overlapping signals, one not permitted under the set-theoretic definition. Given a super-pattern ABA & AC and intervals [0; 10]; [40; 50] 2 I A , [10; 40] 2 I B and <ref> [10; 50] </ref> 2 I C , the interval [0; 50] matches both ABA and AC and so can be reported as a match to ABA & AC under the recursive definition. <p> There have been two previous solutions to this problem of recognizing ERE's, one by Hopcroft and Ullman <ref> [10] </ref> and one by Hirst [9]. The Hopcroft and Ullman algorithm is a naive dynamic programming solution taking (N 3 ) time for any expression containing a Kleene closure operator. Hirst's algorithm, on the other hand, is essentially equivalent to the algorithm below in both complexity and algorithmic structure.
Reference: [11] <author> Kasami, T. </author> <title> An Efficient Recognition and Syntax-Analysis Algorithm for Context-Free Languages. </title> <institution> AFCRL-65-758, Air Force Cambridge Research Laboratory, Bedford, </institution> <address> Mass. </address> <year> (1965). </year>
Reference-contexts: In fact, the ENFA state simulation is reminiscent of Earley's algorithm [4] for context-free grammar parsing, and it is a sparse, scanning version of the Hopcroft and Ullman's naive dynamic programming algorithm analogously to the way Earley's algorithm is a sparse, scanning version of the CYK algorithm <ref> [11, 22] </ref>. This section first presents the ENFA construction and its state simulation, and then develops the super-pattern matching algorithm from the state simulation.
Reference: [12] <author> Lapedes, A., C. Barnes, C. Burks, R. Farber and K. </author> <title> Sirotkin Application of Neural Networks and Other Machine Learning Algorithms to DNA Sequence Analysis. Computers and DNA, </title> <booktitle> SFI Studies in the Sciences of Complexity, </booktitle> <volume> vol. </volume> <editor> VII (Eds. G. Bell and T. Marr). </editor> <publisher> Addison-Wesley, </publisher> <address> Redwood City, CA. </address> <year> (1989). </year>
Reference-contexts: This view is by no means a complete description, and is still developing as biologists learn more. At the current time, much work has been done on building recognizers for individual features using, for example, regular expressions [2], consensus matrices [19], and neural nets <ref> [12] </ref>. Libraries of these component recognizers are currently being used to recognize either pieces of gene encodings or complete encodings. One gene recognition system, GM [5], uses eighteen modules in its gene recognition procedure. Less work has been done on integrating these subrecognizers into an overall gene recognizer.
Reference: [13] <author> Lathrop, R. H., T. A. Webster and T. F. Smith Ariadne: </author> <title> Pattern-Directed Inference and Hierarchical Abstraction in Protein Structure Recognition. </title> <editor> C. </editor> <booktitle> ACM 30,11 (1987), </booktitle> <pages> 909-921. </pages>
Reference-contexts: Super-pattern matching attempts to provide the expressiveness needed to search for these patterns while keeping within polynomial time bounds in the worst case and being efficient in practice. This multi-step approach to pattern matching has also appeared for such problems as protein structure prediction <ref> [13] </ref> and on-line character recognition [6]. In general terms, the matching proce 1 2 dure forms a recognition hierarchy, as depicted in Figure 2, where successively larger patterns are matched at higher and higher levels in the hierarchy. Super-pattern matching characterizes an isolated recognition problem in a general recognition hierarchy.
Reference: [14] <author> Lectures and discussions. </author> <title> Workshop on Recognizing Genes. </title> <institution> Aspen Center for Physics (May-June, </institution> <year> 1990). </year>
Reference-contexts: The problem is to find regions of newly sequenced DNA that code for protein or RNA products, and is basically a pattern recognition problem over the four letter alphabet fa; c; g; tg. Molecular biologists <ref> [14] </ref> have developed a basic picture of a gene encoding structure, illustrated in certain positional relationships with each other. An important aspect is that the features are not linearly ordered, but frequently coincide or overlap each other.
Reference: [15] <author> Myers, E. W. and W. </author> <title> Miller Approximate Matching of Regular Expressions. </title> <journal> Bull. Math. Biology 51,1 (1989), </journal> <pages> 5-37. </pages>
Reference-contexts: for computing an affine scored spacer uses the bottommost three terms of the repair interval rule. 4 Solving the Basic Problem The solutions to each of the super-pattern matching problems employ a framework similar to that developed for sequence-based approximate pattern matching of sequences [16, 17, 20] and regular expressions <ref> [15, 21] </ref>. The framework for super-pattern matching involves four major steps common for all of the algorithmic solutions. The first step is to construct a state machine equivalent to the super-pattern, i.e. a machine which accepts the same language as the super-pattern expression. <p> The finite automata used in this paper are the state-labeled automata used by Myers and Miller <ref> [15] </ref> for approximate regular expression pattern matching over sequences. <p> Successive states in F are labeled with successive symbols of P . This is illustrated in Figure 5 for P = aba. For the full regular expressions, a straightforward induction (given in <ref> [15] </ref>) shows that automata constructed by the above process have the following properties: (1) the in-degree of is 0; (2) the out-degree of is 0; (3) every state has an in-degree and an out-degree of 2 or less; and (4) 11 jV j 2 jP j, i.e. the number of states <p> This is useful because the recurrences above involve computing the shortest paths to a particular graph vertex, so only acyclic paths need to be considered. By the reducibility of F and as proved in <ref> [15] </ref> for a similar graph, it follows that any acyclic path through the matching graph contains at most one back edge from each column's copy of F . These observations led Myers and Miller [15] to a column-based, two sweeps per column, dynamic programming algorithm for the approximate regular expression pattern <p> By the reducibility of F and as proved in <ref> [15] </ref> for a similar graph, it follows that any acyclic path through the matching graph contains at most one back edge from each column's copy of F . These observations led Myers and Miller [15] to a column-based, two sweeps per column, dynamic programming algorithm for the approximate regular expression pattern matching problem over sequences. Their algorithm, applied here to the matching graph, sweeps the j th column twice in topological order, computing the relevant terms of the recurrence in each sweep.
Reference: [16] <author> Needleman, S. B. and C. D. </author> <title> Wunsch A General Method Applicable to the Search for Similarities in the Amino Acid Sequence of Two Proteins. </title> <editor> J. </editor> <booktitle> Molecular Biology 48 (1970), </booktitle> <pages> 443-453. </pages> <note> 26 [17] Sankoff, </note> <author> D. </author> <title> Matching Sequences Under Deletion/InsertionConstraints. </title> <booktitle> Proc. </booktitle> <institution> Nat. Acad. </institution> <note> Sci. </note> <author> U. S. A. </author> <month> 69 </month> <year> (1972), </year> <pages> 4-6. </pages>
Reference-contexts: The rule for computing an affine scored spacer uses the bottommost three terms of the repair interval rule. 4 Solving the Basic Problem The solutions to each of the super-pattern matching problems employ a framework similar to that developed for sequence-based approximate pattern matching of sequences <ref> [16, 17, 20] </ref> and regular expressions [15, 21]. The framework for super-pattern matching involves four major steps common for all of the algorithmic solutions. The first step is to construct a state machine equivalent to the super-pattern, i.e. a machine which accepts the same language as the super-pattern expression.
Reference: [18] <author> Searls, D. </author> <title> Investigating the Linguistics of DNA with Definite Clause Grammars. </title> <booktitle> Proc. of the N. American Conf. on Logic Programming, </booktitle> <volume> Vol. 1 (1989), </volume> <pages> 189-208. </pages>
Reference-contexts: One gene recognition system, GM [5], uses eighteen modules in its gene recognition procedure. Less work has been done on integrating these subrecognizers into an overall gene recognizer. The current methods involve hand coded search procedures [5], backtracking tree-search algorithms [7], and context-sensitive, definite clause grammars <ref> [18] </ref>. These techniques either lack sufficient expressiveness or contain potentially exponential computations. Super-pattern matching attempts to provide the expressiveness needed to search for these patterns while keeping within polynomial time bounds in the worst case and being efficient in practice.
Reference: [19] <author> Stormo, G. </author> <title> Computer Methods for Analyzing Sequence Recognition of Nucleic Acids. </title> <journal> Rev. Biophys. Chem. </journal> <volume> 17 (1988), </volume> <pages> 241-263. </pages>
Reference-contexts: This view is by no means a complete description, and is still developing as biologists learn more. At the current time, much work has been done on building recognizers for individual features using, for example, regular expressions [2], consensus matrices <ref> [19] </ref>, and neural nets [12]. Libraries of these component recognizers are currently being used to recognize either pieces of gene encodings or complete encodings. One gene recognition system, GM [5], uses eighteen modules in its gene recognition procedure.
Reference: [20] <author> Wagner, R. A. and M. J. </author> <title> Fischer The String-to-String Correction Problem. </title> <editor> J. </editor> <booktitle> ACM 21,1 (1974), </booktitle> <pages> 168-173. </pages>
Reference-contexts: The rule for computing an affine scored spacer uses the bottommost three terms of the repair interval rule. 4 Solving the Basic Problem The solutions to each of the super-pattern matching problems employ a framework similar to that developed for sequence-based approximate pattern matching of sequences <ref> [16, 17, 20] </ref> and regular expressions [15, 21]. The framework for super-pattern matching involves four major steps common for all of the algorithmic solutions. The first step is to construct a state machine equivalent to the super-pattern, i.e. a machine which accepts the same language as the super-pattern expression.
Reference: [21] <author> Wagner, R. A. and J. I. </author> <title> Seiferas Correcting Counter-Automaton-Recognizable Languages. </title> <journal> SIAM J. Computing 7,3 (1978), </journal> <pages> 357-375. </pages>
Reference-contexts: for computing an affine scored spacer uses the bottommost three terms of the repair interval rule. 4 Solving the Basic Problem The solutions to each of the super-pattern matching problems employ a framework similar to that developed for sequence-based approximate pattern matching of sequences [16, 17, 20] and regular expressions <ref> [15, 21] </ref>. The framework for super-pattern matching involves four major steps common for all of the algorithmic solutions. The first step is to construct a state machine equivalent to the super-pattern, i.e. a machine which accepts the same language as the super-pattern expression.
Reference: [22] <author> Younger, D. H. </author> <title> Recognition and Parsing of Context-Free Languages in Time n 3 . Information and Control 10,2 (1967), </title> <type> 189-208. </type>
Reference-contexts: In fact, the ENFA state simulation is reminiscent of Earley's algorithm [4] for context-free grammar parsing, and it is a sparse, scanning version of the Hopcroft and Ullman's naive dynamic programming algorithm analogously to the way Earley's algorithm is a sparse, scanning version of the CYK algorithm <ref> [11, 22] </ref>. This section first presents the ENFA construction and its state simulation, and then develops the super-pattern matching algorithm from the state simulation.
References-found: 21

