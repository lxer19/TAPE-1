URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-93-13.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: Making C++ Objects Persistent: The Hidden Pointers  
Author: A. Biliris S. Dar N. H. Gehani 
Address: Murray Hill, New Jersey 07974  Murray Hill, New Jersey 07974  Madison, WI 53706  Murray Hill, New Jersey 07974  
Affiliation: AT&T Bell Labs  AT&T Bell Labs  University of Wisconsin  AT&T Bell Labs  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> ``Vbase Technical Notes'', ONTOS Inc., Burlington, </institution> <address> MA, </address> <year> 1987. </year> <title> [2] ``ONTOS Object Database (Release 2.0) Data Sheet'', </title> <publisher> ONTOS, Inc., </publisher> <address> Burlington, MA, </address> <month> Nov. </month> <year> 1989. </year> <title> [3] ``Product Profile'', </title> <publisher> Versant Object Technology Co., </publisher> <address> Menlo Park, CA, </address> <year> 1990. </year>
Reference-contexts: However, users are allowed to define their own version of the assignment operator. This may invalidate our solution, if the explicitly defined assignment operator does not perform member-wise assignment, or has side effects. 6. RELATED WORK The hidden pointers problem was also identified in Vbase <ref> [1] </ref> and E [16]. The approach taken in Vbase was to make the vtbls persistent objects. The E compiler efront replaces the virtual base class pointer by an offset, an implementation that will probably be used in future C++ compilers as well.
Reference: [4] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++'', </title> <booktitle> 2nd Int'l Workshop on Database Programming Languages, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION O++ <ref> [4, 5, 9] </ref> is a database programming language based on C++ [11, 18]. Amongst other things, O++ provides facilities for making C++ objects persistent. Objects of any class can be allocated on the stack, on the heap, or in persistent store.
Reference: [5] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Ode (Object Database and Environment): The Language and the Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 36-45. </pages>
Reference-contexts: 1. INTRODUCTION O++ <ref> [4, 5, 9] </ref> is a database programming language based on C++ [11, 18]. Amongst other things, O++ provides facilities for making C++ objects persistent. Objects of any class can be allocated on the stack, on the heap, or in persistent store. <p> In addition, when the object is read from disk, the hidden pointers must be initialized to their appropriate values. - 2 - C++ has emerged as the de facto standard language for software development, and database systems based on C++ have attracted much attention <ref> [2, 3, 5, 10, 13, 16] </ref>. We hope that the details and techniques presented will be useful to database researchers and to implementors of object-oriented database systems based on C++. We expect the reader to be familiar with C++ [18]. The paper is organized as follows. <p> This is why in 3. PERSISTENCE AND THE HIDDEN POINTERS PROBLEM The database programming language O++ <ref> [5] </ref>, which is an upward compatible extension of C++, models its persistent store on the heap. An object allocated on the persistent store becomes persistent. Each persistent object is uniquely identified by its object id (oid). A pointer to a persistent object is called a persistent pointer, for short.
Reference: [6] <author> A. Biliris and T. Panagos, </author> <title> ``The Architecture of the EOS Object Store'', </title> <type> Tech. Rep. 91-014, </type> <institution> Computer Science Dept., Boston Univ. </institution> , <year> 1991. </year>
Reference-contexts: O++ compiler ofront C++ C++ compiler object code Linker executable code Ode Object Manager Library The Ode object manager is a software layer built on top of the EOS storage system <ref> [6] </ref>. EOS manipulates objects as uninterpreted sequence of bytes stored on disk pages, the unit of I/O.
Reference: [7] <author> A. Biliris, </author> <title> ``An Efficient Database Storage Structure for Large Dynamic Objects'', </title> <booktitle> Proc. IEEE 8th Int'l Data Engineering Conference 1992, </booktitle> <address> Phoenix, Arizona, </address> <month> February </month> <year> 1992, </year> <pages> 301-308. </pages>
Reference-contexts: If the object is large, i.e., it cannot fit in a single page, then the object is stored in as many pages as necessary to hold the entire object, and a directory to these pages is stored right after the object header <ref> [7] </ref>. - 8 - When a persistent pointer is dereferenced, the entire page the referenced object resides on is brought from disk to memory. Once the object is in memory, its starting address is computed and used to reference the object.
Reference: [8] <author> G. Copeland and D. Maier, </author> <title> ``Making Smalltalk a Database System'', </title> <booktitle> Proceedings of the 1984 ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1984, </year> <pages> 316-325. </pages>
Reference-contexts: By default, C++ generates multiple copies of such a base class. If only one copy of the base class is to be generated, that is, the base class is to be shared as in other object-oriented languages (e.g., <ref> [8, 12, 14] </ref> ), then the base class must be declared to be a virtual base class.
Reference: [9] <author> S. Dar, R. Agrawal and N. H. Gehani, </author> <title> ``The O++ Database Programming Language: Implementation and Experience'', </title> <booktitle> Proc. IEEE 9th Int'l Conf. Data Engineering, </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: 1. INTRODUCTION O++ <ref> [4, 5, 9] </ref> is a database programming language based on C++ [11, 18]. Amongst other things, O++ provides facilities for making C++ objects persistent. Objects of any class can be allocated on the stack, on the heap, or in persistent store.
Reference: [10] <author> O. </author> <title> Deux, ``The O 2 Database Programming Language'', </title> <journal> Communications of the ACM, </journal> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: In addition, when the object is read from disk, the hidden pointers must be initialized to their appropriate values. - 2 - C++ has emerged as the de facto standard language for software development, and database systems based on C++ have attracted much attention <ref> [2, 3, 5, 10, 13, 16] </ref>. We hope that the details and techniques presented will be useful to database researchers and to implementors of object-oriented database systems based on C++. We expect the reader to be familiar with C++ [18]. The paper is organized as follows.
Reference: [11] <author> M. A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1. INTRODUCTION O++ [4, 5, 9] is a database programming language based on C++ <ref> [11, 18] </ref>. Amongst other things, O++ provides facilities for making C++ objects persistent. Objects of any class can be allocated on the stack, on the heap, or in persistent store. Objects allocated in persistent store are called persistent objects, and pointers to such objects are called persistent pointers.
Reference: [12] <author> S. E. Keene, </author> <title> Object-Oriented Programming in Common Lisp, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: By default, C++ generates multiple copies of such a base class. If only one copy of the base class is to be generated, that is, the base class is to be shared as in other object-oriented languages (e.g., <ref> [8, 12, 14] </ref> ), then the base class must be declared to be a virtual base class.
Reference: [13] <author> C. Lamb, G. Landis, J. Orenstein and D. Weinreb, </author> <title> ``The ObjectStore Database System'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 50-63. </pages>
Reference-contexts: In addition, when the object is read from disk, the hidden pointers must be initialized to their appropriate values. - 2 - C++ has emerged as the de facto standard language for software development, and database systems based on C++ have attracted much attention <ref> [2, 3, 5, 10, 13, 16] </ref>. We hope that the details and techniques presented will be useful to database researchers and to implementors of object-oriented database systems based on C++. We expect the reader to be familiar with C++ [18]. The paper is organized as follows. <p> The identical on-disk and in-memory object layout allows for code compatibility of O++ and C++. Systems that implement pointer swizzling <ref> [13, 15, 19] </ref> encounter problems similar to those that arise from hidden pointers: different formats must be used to refer to objects in memory and on disk. <p> It is the C++ compiler that generates the hidden pointers and their locations within an object depends solely upon the code generated by the C++ compiler. - 15 - In ObjectStore <ref> [13] </ref>, the object manager knows the location of the hidden pointers in an object of a given type. 7 In addition, the object manager has a table that maps type names into vtbl addresses; the table is created during schema generation time.
Reference: [14] <author> B. Meyer, </author> <title> Eiffel: The Language Version 3, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: By default, C++ generates multiple copies of such a base class. If only one copy of the base class is to be generated, that is, the base class is to be shared as in other object-oriented languages (e.g., <ref> [8, 12, 14] </ref> ), then the base class must be declared to be a virtual base class.
Reference: [15] <author> J. E. B. Moss, </author> <title> ``Working with Persistent Objects: To Swizzle or Not to Swizzle'', </title> <type> COINS Technical Report, </type> <month> May </month> <year> 1990. </year>
Reference-contexts: The identical on-disk and in-memory object layout allows for code compatibility of O++ and C++. Systems that implement pointer swizzling <ref> [13, 15, 19] </ref> encounter problems similar to those that arise from hidden pointers: different formats must be used to refer to objects in memory and on disk.
Reference: [16] <author> J. E. Richardson and M. J. Carey, </author> <title> ``Persistence in the E Language: Issues and Implementation'', </title> <note> SoftwarePractice & Experience 19, 12 (Dec. </note> <year> 1989), </year> <pages> 1115-1150. </pages>
Reference-contexts: In addition, when the object is read from disk, the hidden pointers must be initialized to their appropriate values. - 2 - C++ has emerged as the de facto standard language for software development, and database systems based on C++ have attracted much attention <ref> [2, 3, 5, 10, 13, 16] </ref>. We hope that the details and techniques presented will be useful to database researchers and to implementors of object-oriented database systems based on C++. We expect the reader to be familiar with C++ [18]. The paper is organized as follows. <p> However, users are allowed to define their own version of the assignment operator. This may invalidate our solution, if the explicitly defined assignment operator does not perform member-wise assignment, or has side effects. 6. RELATED WORK The hidden pointers problem was also identified in Vbase [1] and E <ref> [16] </ref>. The approach taken in Vbase was to make the vtbls persistent objects. The E compiler efront replaces the virtual base class pointer by an offset, an implementation that will probably be used in future C++ compilers as well. <p> In addition, the complexity of recursively fixing the hidden pointers in base class and member sub-objects is simply transferred to the C++ compiler, by calling a constructor. The problem of adjusting a base class pointer to a derived class object also arose in the implementation of collections in E <ref> [16] </ref>. Collections are implemented using EXODUS files. A collection whose objects of some type can contain derived type objects. Therefore, an EXODUS iterator over a collection must return an adjusted pointer. This special case was handled by storing the appropriate offset in the object header. 7.
Reference: [17] <author> B. Stroustrup, </author> <title> ``16 Ways to Stack a Cat'', </title> <booktitle> Proc. USENIX Winter Conf., </booktitle> <year> 1991. </year>
Reference-contexts: If C has an overloaded C::operator new, then it is called, otherwise the global ::operator new is used. 3. The idea of using an overloaded operator new to invoke a constructor on an existing object was suggested in a different con text in <ref> [17] </ref>. 4.
Reference: [18] <author> B. Stroustrup, </author> <title> The C++ Programming Language (2nd Ed.), </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: 1. INTRODUCTION O++ [4, 5, 9] is a database programming language based on C++ <ref> [11, 18] </ref>. Amongst other things, O++ provides facilities for making C++ objects persistent. Objects of any class can be allocated on the stack, on the heap, or in persistent store. Objects allocated in persistent store are called persistent objects, and pointers to such objects are called persistent pointers. <p> We hope that the details and techniques presented will be useful to database researchers and to implementors of object-oriented database systems based on C++. We expect the reader to be familiar with C++ <ref> [18] </ref>. The paper is organized as follows. Section 2 illustrates the main memory layout of objects used by C++. A reader familiar with the C++ implementation may skip this section.

References-found: 16

