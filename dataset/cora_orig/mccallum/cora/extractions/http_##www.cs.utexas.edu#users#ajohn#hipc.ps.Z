URL: http://www.cs.utexas.edu/users/ajohn/hipc.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/ajohn/publications.html
Root-URL: 
Email: E-mail: fajohn,browneg@cs.utexas.edu  
Title: Compilation to Parallel Programs from Constraints  
Author: Ajita John, J.C. Browne 
Address: Austin, TX 78712  
Affiliation: Dept. of Computer Sciences University of Texas at Austin  
Abstract: This paper describes the first results from research 1 on the compilation of constraint systems into task level parallel programs in a procedural language. This is the only research of which we are aware which attempts to generate efficient parallel programs for numerical computation from constraint systems. Computations are expressed as constraint systems. A dependence graph is derived from the constraint system and a set of input variables. The dependence graph, which exploits the parallelism in the constraints, is mapped to the language CODE, which represents parallel computation structures as generalized dependence graphs. Finally, parallel C programs are generated. To extract parallel programs of appropriate granularity, the following features are included: (i) modularity, (ii) operations over structured types as primitives, (iii) sequential C functions. A prototype of the compiler has been implemented. The domain of matrix computations is targeted for applications. Initial results are very encouraging. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Baldwin. </author> <title> Consul: A parallel constraint language. </title> <journal> IEEE Software, </journal> <year> 1989. </year>
Reference-contexts: 1. Introduction Representing a computation as a set of constraints upon the state variables defining the solution is an attractive approach to specification of programs, but there has been little success previously in attaining efficient execution of parallel programs derived from constraint representations <ref> [1] </ref>. There are however, both motivations for continuing research in this direction and reasons for optimism concerning success. <p> Consul <ref> [1] </ref> is a parallel constraint language that uses an interpretive technique (local propagation) to find satisfying values for the system of constraints. This system offers performance only in the range of logic languages. <p> This will be relaxed in later versions of the compiler. E.g. AND FOR (i 1 2) f A [i] == A [i-1], B [i+1] == A [i] g captures the constraints A <ref> [1] </ref> == A [0] AND A [2] == A [1] AND B [2] == A [1] Constraints constructed from applications of Rule 1 are referred to as simple constraints, which form the building blocks for non-simple constraints, constructed from applications of Rules 2-4. 4.3. <p> This will be relaxed in later versions of the compiler. E.g. AND FOR (i 1 2) f A [i] == A [i-1], B [i+1] == A [i] g captures the constraints A <ref> [1] </ref> == A [0] AND A [2] == A [1] AND B [2] == A [1] Constraints constructed from applications of Rule 1 are referred to as simple constraints, which form the building blocks for non-simple constraints, constructed from applications of Rules 2-4. 4.3. <p> This will be relaxed in later versions of the compiler. E.g. AND FOR (i 1 2) f A [i] == A [i-1], B [i+1] == A [i] g captures the constraints A <ref> [1] </ref> == A [0] AND A [2] == A [1] AND B [2] == A [1] Constraints constructed from applications of Rule 1 are referred to as simple constraints, which form the building blocks for non-simple constraints, constructed from applications of Rules 2-4. 4.3.
Reference: [2] <author> K. Chandy and J. Misra. </author> <title> Parallel Program Design </title> : 
Reference-contexts: Constraint systems have attractive properties for compi 1 This work was supported in part through a grant from the Advanced Research Projects Office/CSTO, subcontract to Syra-cuse University #3531427 lation to parallel computation structures. A constraint system gives the minimum specification (See <ref> [2] </ref> for the benefits from postponing imposition of program structure) for a computation, thereby offering the compiler freedom of choice for derivation of control structure. Constraint systems offer some unique advantages as a representation from which parallel programs are to be extracted. <p> However, both require the programmer to provide explicit operators for specification of parallelism and the dependence graph structures which could be generated were restricted to trees. Equational specifications of computations is a restriction of constraint specifications. Unity <ref> [2] </ref> is the equational programming representation around which Chandy and Misra have built a powerful paradigm for the design of parallel programs. Again, Unity requires addition of explicit specifications for parallelism. <p> This will be relaxed in later versions of the compiler. E.g. AND FOR (i 1 2) f A [i] == A [i-1], B [i+1] == A [i] g captures the constraints A [1] == A [0] AND A <ref> [2] </ref> == A [1] AND B [2] == A [1] Constraints constructed from applications of Rule 1 are referred to as simple constraints, which form the building blocks for non-simple constraints, constructed from applications of Rules 2-4. 4.3. <p> This will be relaxed in later versions of the compiler. E.g. AND FOR (i 1 2) f A [i] == A [i-1], B [i+1] == A [i] g captures the constraints A [1] == A [0] AND A <ref> [2] </ref> == A [1] AND B [2] == A [1] Constraints constructed from applications of Rule 1 are referred to as simple constraints, which form the building blocks for non-simple constraints, constructed from applications of Rules 2-4. 4.3.
References-found: 2

