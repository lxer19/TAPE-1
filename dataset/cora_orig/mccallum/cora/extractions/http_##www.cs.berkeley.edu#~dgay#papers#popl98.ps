URL: http://www.cs.berkeley.edu/~dgay/papers/popl98.ps
Refering-URL: http://www.cs.berkeley.edu/Research/Projects/titanium/papers.html
Root-URL: 
Email: faiken,dgayg@cs.berkeley.edu  
Title: Barrier Inference  
Author: Alexander Aiken and David Gay 
Address: Berkeley, CA 94720-1776  
Affiliation: EECS Department University of California, Berkeley  
Abstract: Many parallel programs are written in SPMD style, i.e. by running the same sequential program on all processes. SPMD programs include synchronization, but it is easy to write incorrect synchronization patterns. We propose a system that verifies a program's synchronization pattern. We also propose language features to make the synchronization pattern more explicit and easily checked. We have implemented a prototype of our system for Split-C and successfully verified the synchronization structure of realistic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Auslander, M. Philipose, C. Chambers, S. J. Eggers, and B. N. Bershad. </author> <title> Fast, Effective Dynamic Compilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 149-159, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Algorithms for binding-time analysis for C, such as <ref> [1] </ref>, handle unstructured control-flow and can be modified to compute single-valued variables and synchronization sequences. In the presence of pointers, detecting single-valued variables can require alias analysis, a well-known hard problem [15]. <p> It verifies all specifications are correct. Our implementation follows the guidelines of Section 4.2 for supporting C, except we have not implemented the analysis of data structures (which was only needed by one of the Split-C programs). The algorithm for inferring single-valued variables is similar to <ref> [1] </ref>, but includes synchronization sequence analysis. Table 5.1 presents the programs and summarizes our results. The second column counts the static occurrences of barriers in the program, while the third column reports the number of branches that control the execution of a barrier and whose condition is single-valued.
Reference: [2] <author> D. Callahan, K. Kennedy, and J. Subhlok. </author> <title> Analysis of Event Synchronization in a Parallel Programming Tool. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 21-30, </pages> <address> Seattle WA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [3] <author> D. Callahan and J. Subhlok. </author> <title> Static Analysis of Low-Level Synchronization. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <address> Madison, WI USA, [1] 1989. </address> <publisher> ACM Press , New York, </publisher> <address> NY , USA. </address> <booktitle> Published as SIGPLAN Notices, </booktitle> <volume> volume 24, number 1. </volume>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [4] <author> Cray Research Incorporated. </author> <title> The CRAY T3D Hardware Reference Manual, </title> <year> 1993. </year>
Reference-contexts: Usually named barriers are implemented using a broadcast (so the names can be compared) which is much slower than special-purpose barrier hardware (e.g., on the CM5 [17] and T3D <ref> [4] </ref>). But L already effectively has two barrier names: barrier and broadcast. Adding more names increases the alphabet of synchronization strings but has no impact on inference complexity. Our system thus allows named barriers to be checked at compile-time, allowing their implementation with more efficient anonymous barriers.
Reference: [5] <author> D. E. Culler, A. Dusseau, S. C. Goldstein, A. Krishna-murthy, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Introduction to Split-C. </title> <institution> University of California, Berke-ley, </institution> <year> 1993. </year>
Reference-contexts: For these situations a mechanism is needed for the programmer to assert a particular expression is single-valued. In the tradition of C, we call this a single-valued cast. Use of this feature should of course be minimized. 5 Experiments We implemented a prototype of our inference system for Split-C <ref> [5] </ref>, an explicitly parallel extension to C. We tested our prototype on Split-C kernels and applications. The empirical question we sought to answer is: How well does barrier inference integrate with real SPMD programming? Our measure is the number of changes preexisting programs required to conform to our system.
Reference: [6] <author> D. Gay. </author> <title> Barrier Inference. </title> <type> Technical Report UCB//CSD-97-965, </type> <institution> EECS Computer Science Division, University of California, Berkeley, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The [Let] rule introduces a new variable, which is initially single-valued as it is initialized to 0 in all processes. A new function is introduced into the function environment by the [LetRec] rule. This rule, and the [Fun] rule, express constraints on the function's signature; in <ref> [6] </ref> we outline an implementation that finds a solution to these constraints by fixed-point iteration. The two rules for if are interesting. The rule [If-Single] applies when the predicate is single-valued. All processes take the same branch, but we do not know which branch. <p> Then [hF; E 1 ; I; ei; : : : ; hF; E n ; I; ei] ; [(E 1 ; v 1 ); : : : ; (E n ; v n )] or some process diverges. The proofs of Lemma 3.2 and Theorem 3.3 are given in <ref> [6] </ref>. The semantics of Figure 2 does not handle synchronization errors, i.e. the cases where barriers and broadcasts are mismatched or when some processes waits at a barrier while other processes have terminated. In those cases, the evaluation hangs.
Reference: [7] <author> D. Gifford, P. Jouvelot, J. Lucassen, and M. Shel-don. </author> <title> FX-87 REFERENCE MANUAL. </title> <type> Technical Report MIT-LCS//MIT/LCS/TR-407, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: Our methods are capable of statically checking realistic programs for (1) and (2). 3 Barrier Inference Barrier Inference is an example of an effect system <ref> [7] </ref>. An effect associated with each expression models two aspects of SPMD computation. The first aspect is the sequence of barriers and broadcasts executed in evaluating an expression e.
Reference: [8] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The synchronization kernel is sufficiently important that it should be explicitly visible in source code. We propose language features that make SPMD programs clearer and easier to check. We are integrating these language extensions into Titanium, a Java-based <ref> [8] </ref> successor to Split-C. This requires extending the application of the single-valued concept to more complex data structures, including references and objects, and to support language features such as exception handling.
Reference: [9] <author> D. P. Helmbold and C. E. McDowell. </author> <title> Computing Reachable States of Parallel Programs. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 26(12) </volume> <pages> 76-84, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [10] <author> T. Jeremiassen and S. Eggers. </author> <title> Computing Per-Process Summary Side-Effect Information. </title> <booktitle> In Proceedings of the 5th International Workshop on Languages and Compilers for Parallel Computing, number 757 in Lecture Notes in Computer Science, </booktitle> <pages> pages 175-191, </pages> <address> New Haven, Connecticut, </address> <month> August 3-5, </month> <title> 1992. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Jeremiassen and Eggers [11] analyse barrier synchronization for SPMD programs to improve the precision of optimization. They do not attempt to verify synchronization correctness. Their analysis relies on named barriers for precision and does not consider single-valued variables, though they do consider dependencies on multi-valued constants like pid <ref> [10] </ref>. A number of papers analyse 2-way synchronization, such as post/wait or Ada's accept/call mechanism, between explicitly specified tasks. As each task is specified with different code, there is no analogue of single-valued variables.
Reference: [11] <author> T. E. Jeremiassen and S. J. Eggers. </author> <title> Static Analysis of Barrier Synchronization in Explicitly Parallel Systems. </title> <booktitle> In Proceedings of the IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Techniques, PACT '94, </booktitle> <pages> pages 171-180, </pages> <address> Montreal, Quebec, </address> <month> August 24-26, </month> <title> 1994. </title> <publisher> North-Holland Publishing Co. </publisher>
Reference-contexts: The programming model is also very different. Analysis of the synchronization of parallel programs has been extensively studied for the purposes of deadlock and data-race detection as well as for optimization. Our survey of this work is necessarily partial, and covers only static techniques. Jeremiassen and Eggers <ref> [11] </ref> analyse barrier synchronization for SPMD programs to improve the precision of optimization. They do not attempt to verify synchronization correctness. Their analysis relies on named barriers for precision and does not consider single-valued variables, though they do consider dependencies on multi-valued constants like pid [10].
Reference: [12] <author> N. D. Jones, C. K. Gomard, and P. Sestoff. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: Unstructured control-flow, aliasing, function pointers, and unitialized data structures are problematic. The inference of single-valued variables is very similar to the problem of binding-time analysis in partial evaluation <ref> [12] </ref>: Given a set of variables whose value is assumed known (or single-valued in our case), determine which expressions and variables have a value that depends solely on these variables.
Reference: [13] <author> A. Krishnamurthy, D. E. Culler, A. Dusseau, S. C. Goldstein, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Parallel Programming in Split-C. </title> <booktitle> In Proceedings of the Supercomputing '93 Conference, </booktitle> <pages> pages 262-273, </pages> <address> Port-land, OR, November 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our system was developed in the context of a distributed memory, shared address space programming language (Split fl This material is based in part upon work supported by NSF Young Investigator Award No. CCR-9457812, DARPA contract F30602-95-C-0136 and a Microsoft graduate fellowship. C, an SPMD language developed at Berkeley <ref> [13] </ref>), but we found it equally applicable to checking the synchronization structure of shared memory, shared address space parallel programs; our method can show the synchronization correctness of the SPLASH-2 [25] benchmarks.
Reference: [14] <author> A. Krishnamurthy and K. Yelick. </author> <title> Optimizing Paral--lel Programs with Explicit Synchronization. </title> <booktitle> In ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-204, </pages> <address> New York, NY, USA, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In our experience, this extra information is extremely useful for understanding SPMD programs written by others. Barrier inference also gives the compiler a more precise understanding of the portions of the program that execute in parallel, which makes SPMD optimizations, e.g. <ref> [14] </ref>, more precise. There are structurally correct programs our system cannot verify, such as Figure 1h.
Reference: [15] <author> W. Landi and B. G. Ryder. </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing. </title> <booktitle> In ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Algorithms for binding-time analysis for C, such as [1], handle unstructured control-flow and can be modified to compute single-valued variables and synchronization sequences. In the presence of pointers, detecting single-valued variables can require alias analysis, a well-known hard problem <ref> [15] </ref>. We have found very conservative assumptions suffice in practice (see Section 5.1): a variable whose address is taken is multi-valued; any pointer dereference is multi-valued.
Reference: [16] <author> D. H. Lawrie, T. Layman, D. Baer, and J. M. Ran-dal. </author> <title> Glypnir A Programming Language for Illiac IV. </title> <journal> Communications of the ACM, </journal> <volume> 18(3) </volume> <pages> 157-164, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: Control unit variables resemble our single-valued variables: they are variables that have only one value. Unlike single-valued variables, control unit variables are stored in only one location. Control unit variables are declared with a CU keyword in the Illiac IV programming language Glypnir <ref> [16] </ref>. The Connection Machine language C* [23] calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics.
Reference: [17] <author> C. E. Leiserson, Z. S. Abuhamdeh, D. C. Douglas, C. R. Feynman, M. N. Ganmukhi, J. V. Hill, W. D. Hillis, B. C. Kuszmaul, M. A. St. Pierre, D. S. Wells, M. C. Wong, S. Yang, and R. Zak. </author> <title> The Network Architecture of the CM-5. </title> <booktitle> In Symposium on Parallel and Distributed Algorithms '92, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Usually named barriers are implemented using a broadcast (so the names can be compared) which is much slower than special-purpose barrier hardware (e.g., on the CM5 <ref> [17] </ref> and T3D [4]). But L already effectively has two barrier names: barrier and broadcast. Adding more names increases the alphabet of synchronization strings but has no impact on inference complexity. Our system thus allows named barriers to be checked at compile-time, allowing their implementation with more efficient anonymous barriers.
Reference: [18] <author> S. P. Masticola and B. G. Ryder. </author> <title> Non-concurrency Analysis. </title> <booktitle> In Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 129-138, </pages> <address> New York, NY, USA, July 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [19] <author> C. E. McDowell. </author> <title> A Practical Algorithm for Static Analysis of Parallel Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6(3) </volume> <pages> 515-536, </pages> <month> [6] </month> <year> 1989. </year>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [20] <author> Message Passing Interface Forum. </author> <title> Document for a standard message-passing interface. </title> <type> Technical Report UT-CS-93-214, </type> <institution> University of Tennessee, Knoxville, </institution> <year> 1993. </year>
Reference-contexts: There are two basic forms of incorrect synchronization. In 1 Such programs may not rely on global synchronization to the same degree as shared address space programs, but standard message passing libraries such as MPI <ref> [20] </ref> do include global synchronization primitives. if (different ()) barrier; work1 (); barrier; work2 (); if (x) barrier else work (); (a) processes left behind (e) correct if processes agree on x's value while (different ()) barrier; work1 (); barrier; work2 (); barrier; work3 (); i &lt;- 0; while i &lt;
Reference: [21] <author> M. A. Nichols, H. J. Siegel, and H. G. Dietz. </author> <title> Data Management and Control-Flow Aspects of an SIMD/SPMD Parallel Language/Compiler. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(2) </volume> <pages> 222-234, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: SPMD languages. The ELP language <ref> [21, 24] </ref>, a joint SIMD/SPMD programming language where both "modes" have the same semantics, allows declaration of single-valued variables with a mono keyword.
Reference: [22] <author> R. N. Taylor. </author> <title> A General-Purpose Algorithm for Analyzing Concurrent Programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
Reference: [23] <institution> Thinking Machines Corporation. C fl Programming Guide, </institution> <year> 1993. </year>
Reference-contexts: Control unit variables resemble our single-valued variables: they are variables that have only one value. Unlike single-valued variables, control unit variables are stored in only one location. Control unit variables are declared with a CU keyword in the Illiac IV programming language Glypnir [16]. The Connection Machine language C* <ref> [23] </ref> calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics.
Reference: [24] <author> L. Wang. </author> <title> ELP User's Manual. Parallel Processing Laboratory, </title> <institution> School of Electrical and Computer Engineering, Purdue University, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: SPMD languages. The ELP language <ref> [21, 24] </ref>, a joint SIMD/SPMD programming language where both "modes" have the same semantics, allows declaration of single-valued variables with a mono keyword.
Reference: [25] <author> S. Cameron Woo, M. Ohara, E. Torrie, J. Pal Shingh, and A. Gupta. </author> <title> The SPLASH-2 Programs: Characterization and Methodological Considerations. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 24-36, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year> <journal> ACM SIGARCH and IEEE Computer Society TCCA. </journal>
Reference-contexts: CCR-9457812, DARPA contract F30602-95-C-0136 and a Microsoft graduate fellowship. C, an SPMD language developed at Berkeley [13]), but we found it equally applicable to checking the synchronization structure of shared memory, shared address space parallel programs; our method can show the synchronization correctness of the SPLASH-2 <ref> [25] </ref> benchmarks. Whether a similar result holds for pure message passing programs requires further research. 1 1.1 Global Synchronization A simple and popular parallel programming model is SPMD (for Single Program, Multiple Data). SPMD programs are explicitly-parallel programs written in sequential languages extended with communication and synchronization primitives. <p> We tested the prototype on a substantial number of Split-C programs (Section 5). Experience with our implementation is positive; the system successfully checks the benchmarks with a few minor modifications to the programs, including one to correct a bug detected by our system. We also examined the Splash-2 benchmarks <ref> [25] </ref> by hand and found that all but one can be checked with our system (Section 5.2). <p> The times, measured on a Sun Ultra-1/167Mhz, represent the time spent in our system and do not include the time to build the standard SSA representation used by our prototype. 5.2 The SPLASH-2 Benchmarks As a further validation of our approach, we examined the synchronization structure of the SPLASH-2 benchmarks <ref> [25] </ref>, 4 Checking use of setjmp and longjmp in C is almost impossible in any program analysis. In `barnes', when an exception arises in one process, the whole program is terminated.
Reference: [26] <author> M. Young and R. N. Taylor. </author> <title> Combining Static Con-currency Analysis with Symbolic Execution. </title> <booktitle> In Proceedings Workshop on Software Testing, </booktitle> <pages> pages 10-18, </pages> <year> 1986. </year>
Reference-contexts: Analyzing synchronization in this context is similar to analyzing the synchronization between the two branches in the [If-Multi] case, for which we only allow very simple synchronization sequences. None of the many papers on this subject present exact solutions for more general situations <ref> [2, 3, 9, 18, 19, 22, 26] </ref>. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization that is identical across all processes. This synchronization kernel structures the entire application.
References-found: 26

