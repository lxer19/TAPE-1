URL: http://www.cs.ucsb.edu/oocsb/self/papers/write-barrier.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/write-barrier.html
Root-URL: http://www.cs.ucsb.edu
Email: urs@cs.stanford.edu  
Title: A Fast Write Barrier for Generational Garbage Collectors  
Author: Urs Hlzle 
Address: Stanford University  
Affiliation: Computer Systems Laboratory  
Abstract-found: 0
Intro-found: 1
Reference: [Cha91] <author> Craig Chambers. </author> <title> Cost of garbage collection in the Self system. </title> <booktitle> OOPSLA'91 GC Workshop, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: For the programs we measured, card marking consumed between 40% and 100% of the total write barrier cost. Discussion Our numbers differ somewhat from those obtained in Chambers study of garbage collection overhead in the SELF system <ref> [Cha91] </ref>. Generally, Chambers measurements of store checking overhead showed even higher overheads than our study, ranging from 3% to 24% for a similar set of programs. However, these measurements cannot be directly compared to ours for several reasons.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. Thesis, </type> <institution> Computer Science Department, Stanford University, </institution> <year> 1992. </year>
Reference-contexts: In addition, bit manipulations usually require several instructions on RISC processors. Chambers and Ungar improved on Wilsons scheme by using bytes instead of bits to mark cards <ref> [Cha92] </ref>. That is, every card in the heap has one byte associated with it; a card is marked simply by storing a special value (e.g., zero) into the corresponding byte. <p> Similar but less efficient schemes have been proposed by Sobalvarro [Sob88] and Shaw [Sha88]. Presented at the OOPSLA93 Garbage Collection Workshop, Washington, D.C., October 1993. 2 The big advantage of the byte marking scheme is its speed. In the SELF system described in <ref> [Cha92] </ref>, a store check requires just 3 SPARC instructions in addition to the actual store: st [%obj + offset], %ptr store ptr into objects field add %obj, offset, %temp calculate address of updated word sll %temp, k, %temp divide by card size 2 k (shift left) st %g0, [%byte_map + %temp]
Reference: [Hos92] <author> Antony Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In OOPSLA'92 Proceedings, </booktitle> <pages> pp. 92-109, </pages>
Reference-contexts: The only write barrier with comparably low mutator overhead that we are aware of is the sequential store buffer (SSB) described by Hosking et al. <ref> [Hos92] </ref>. The SSB records all locations being stored into; like our scheme, an SSB store barrier takes two instructions (a store and an add). At scavenge time, the SSB is scanned and the locations referenced by the pointers in the buffer are examined.
Reference: [LH83] <author> Henry Lieberman and Carl Hewitt. </author> <title> A Real-Time Garbage Collector Based on the Lifetime of Objects. </title> <booktitle> Communications of the ACM 26 (6): </booktitle> <pages> 419-429. </pages>
Reference-contexts: Introduction Generational garbage collectors need to keep track of references from older to younger generations so that younger generations can be garbage-collected without inspecting every object in the older generation (s) <ref> [LH83] </ref>, [Ung86]. The set of locations potentially containing pointers to newer objects is often called the remembered set [Ung86]. At every store, the system must ensure that the updated location is added to the remembered set if the store creates a reference from an older to a newer object.
Reference: [Sha88] <author> Robert A. Shaw. </author> <title> Empirical Analysis of a LISP System. </title> <institution> Stanford University, Computer Systems Laboratory, </institution> <type> Technical Report CSL-TR-88-351, </type> <year> 1988. </year>
Reference-contexts: Similar but less efficient schemes have been proposed by Sobalvarro [Sob88] and Shaw <ref> [Sha88] </ref>. Presented at the OOPSLA93 Garbage Collection Workshop, Washington, D.C., October 1993. 2 The big advantage of the byte marking scheme is its speed.
Reference: [Sob88] <author> Patrick G. Sobalvarro. </author> <title> A lifetime-based collector for LISP systems on general-purpose computers. B.S. </title> <type> Thesis, </type> <institution> MIT EECS Dept., </institution> <address> Cambridge Ma, </address> <year> 1988. </year>
Reference-contexts: Similar but less efficient schemes have been proposed by Sobalvarro <ref> [Sob88] </ref> and Shaw [Sha88]. Presented at the OOPSLA93 Garbage Collection Workshop, Washington, D.C., October 1993. 2 The big advantage of the byte marking scheme is its speed.
Reference: [Ung86] <author> David Ungar, </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Introduction Generational garbage collectors need to keep track of references from older to younger generations so that younger generations can be garbage-collected without inspecting every object in the older generation (s) [LH83], <ref> [Ung86] </ref>. The set of locations potentially containing pointers to newer objects is often called the remembered set [Ung86]. At every store, the system must ensure that the updated location is added to the remembered set if the store creates a reference from an older to a newer object. <p> Introduction Generational garbage collectors need to keep track of references from older to younger generations so that younger generations can be garbage-collected without inspecting every object in the older generation (s) [LH83], <ref> [Ung86] </ref>. The set of locations potentially containing pointers to newer objects is often called the remembered set [Ung86]. At every store, the system must ensure that the updated location is added to the remembered set if the store creates a reference from an older to a newer object. This mechanism is usually referred to as a write barrier or store check.
Reference: [Wil89] <author> Paul R Wilson and Thomas G Moher. </author> <title> A card-marking scheme for controlling intergenera-tional references in generation-based GC on stock hardware. </title> <journal> SIGPLAN Notices 24 (5), </journal> <pages> pp. 87-92. </pages>
Reference-contexts: The write barrier implementation described here reduces the write barrier overhead in the mutator to only two extra instructions per checked store. Card Marking Our new write barrier implementation is based on Wilsons card marking scheme <ref> [Wil89] </ref>. In this scheme, the heap is divided into cards of size 2 k words (typically, k = 5..7), and every card has an associated bit in a separate bit vector. A store check simply marks the bit corresponding to the location being updated.
Reference: [Zor90] <author> Benjamin Zorn. </author> <title> Barrier Methods for Garbage Collection. </title> <type> Technical Report CU-CS-494-90, </type> <institution> University of Colorado at Boulder, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: All of the programs show scavenging overheads of between five and ten percent of total runtime, and store check overheads between roughly 0.5% and 8% (which agrees well with measurements of Lisp programs taken by Zorn <ref> [Zor90] </ref>). Even with the fast store check code, the card marking overhead significantly exceeds the card scanning time for three of the benchmarks (Richards, DeltaBlue, and PrimMaker). For the other two benchmarks, the card marking and card scanning overheads are about equal.
References-found: 9

