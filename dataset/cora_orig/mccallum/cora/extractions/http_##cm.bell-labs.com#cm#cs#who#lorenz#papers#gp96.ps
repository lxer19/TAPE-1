URL: http://cm.bell-labs.com/cm/cs/who/lorenz/papers/gp96.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: lorenz@research.bell-labs.com  
Title: Toward Simulated Evolution of Machine-Language Iteration  
Author: Lorenz Huelsbergen 
Date: 315-320.  
Note: Appears in 1996 Conference on Genetic Programming, pp.  
Address: 600 Mountain Avenue Murray Hill, NJ 07974  
Affiliation: Bell Laboratories Lucent Technologies  
Abstract: We use a simulated evolution search (genetic programming) for the automatic synthesis of small iterative machine-language programs. For an integer register machine with an addition instruction as its sole arithmetic operator, we show that genetic programming can produce exact and general multiplication routines by synthesizing the necessary iterative control structures from primitive machine-language instructions. Our program representation is a virtual register machine that admits arbitrary control flow. Our evolution strategy furthermore does not artificially restrict the synthesis of any control structure; we only place an upper bound on program evaluation time. A program's fitness is the distance between the output produced by a test case and the desired output (multiplication). The test cases exhaustively cover multiplication over a finite subset of the natural numbers (N 10 ); yet the derived solutions constitute general multiplication for the positive integers. For this problem, simulated evolution with a two-point crossover operator examines significantly fewer individuals in finding a solution than random search. Introduction of a small rate of mutation fur ther increases the number of solutions.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel and D. B. MacQueen. </author> <title> A Standard ML compiler. </title> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <volume> 274 </volume> <pages> 301-324, </pages> <year> 1987. </year>
Reference-contexts: It is written in the Standard ML (SML) programming language [12] and implemented using the Standard ML of New Jersey (SML/NJ) compiler <ref> [1] </ref>. The SML/NJ implementation supports parameterized modules [10] which are indispensable in an experimentation framework. SML's strong static typing ensures that module implementations match their declared interfaces (signatures).
Reference: [2] <author> S. Brave. </author> <title> Evolving recursive programs for tree search. </title> <editor> In P. Angeline and K. E. Kinnear Jr., editors, </editor> <booktitle> Advances in Genetic Programming II, chapter 10. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1996. </year> <note> (To appear). </note>
Reference-contexts: Kinnear also uses a specialized loop construct, dobl, to evolve sorting algorithms [6]. As with iteration, GP experiments with recursion restrict the scope and generality of the recursion. Recent work by Brave <ref> [2] </ref> investigates restricted recursion over trees to solve state-space exploration problems. The external system again restrictively curbs the maximum depth of a recursion. With constructs such as LOOP, DU, or dobl as its only means of iteration, GP can only evolve programs with structured control flow.
Reference: [3] <author> N. L. Cramer. </author> <title> A representation for the adaptive generation of simple sequential programs. </title> <booktitle> In Proceeding of the International Conference on Genetic Algorithms and their Applications, </booktitle> <pages> pages 183-187. </pages> <institution> Texas Instruments, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: Applications of genetic programming that do use iteration do so by restricting its form to a single type of loop and by bounding its extent to a fixed number of iterations. Cramer <ref> [3] </ref> describes simulated evolution of programs in a machine language with a high-level LOOP construct parameterized by an expression e and an integer variable denoting the number of iterative executions of e; the system externally limits a program's running time. <p> Do-Until [8])|as in e.g. <ref> [3] </ref>, we instead limit the total number of instructions a program may execute, i.e. its running time. <p> Section 3 specifies the virtual machine language; Section 4 details the experimental setup for the multiplication problem. Results are in Section 5. We conclude with a discussion in Section 6. 1 A high-level if control structure also requires such synthesis from primitive VRM-M instructions. 2 Cramer <ref> [3] </ref> also studied simulated evolution of multiplication in machine languages with high-level loop constructs. 2 Finnegan System Finnegan is a framework for experimenting with simulated evolution. It is written in the Standard ML (SML) programming language [12] and implemented using the Standard ML of New Jersey (SML/NJ) compiler [1].
Reference: [4] <author> R. M. Friedberg. </author> <title> A learning machine: Part I. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 2 </volume> <pages> 2-13, </pages> <year> 1958. </year>
Reference-contexts: To this end, we study the evolution of unrestricted iteration in the context of machine-language programs. Little GP research to date addresses the problem of general iteration. Early work modeled the synthesis of machine-language programs as evolutionary processes <ref> [5, 4] </ref>, but did not outperform random search. Applications of genetic programming that do use iteration do so by restricting its form to a single type of loop and by bounding its extent to a fixed number of iterations.
Reference: [5] <author> R. M. Friedberg, B. Dunham, and J. H. </author> <title> North. A learning machine: Part II. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 3 </volume> <pages> 282-287, </pages> <year> 1959. </year>
Reference-contexts: To this end, we study the evolution of unrestricted iteration in the context of machine-language programs. Little GP research to date addresses the problem of general iteration. Early work modeled the synthesis of machine-language programs as evolutionary processes <ref> [5, 4] </ref>, but did not outperform random search. Applications of genetic programming that do use iteration do so by restricting its form to a single type of loop and by bounding its extent to a fixed number of iterations.
Reference: [6] <author> K. E. Kinnear Jr. </author> <title> Evolving a sort: Lessons in genetic programming. </title> <booktitle> In International Conference on Neural Networks, </booktitle> <address> New York, NY, 1993. </address> <publisher> IEEE. </publisher>
Reference-contexts: Each DU operator in the program is, however, restricted in that the number of its iterations is externally bounded from above. Kinnear also uses a specialized loop construct, dobl, to evolve sorting algorithms <ref> [6] </ref>. As with iteration, GP experiments with recursion restrict the scope and generality of the recursion. Recent work by Brave [2] investigates restricted recursion over trees to solve state-space exploration problems. The external system again restrictively curbs the maximum depth of a recursion.
Reference: [7] <editor> K. E. Kinnear Jr., editor. </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Genetic programming (GP) [8] uses principles of evolution (populations, fitness measures, recombination) to perform directed non-linear searches in the space of computer programs. GP has successfully produced solution programs in many problem domains, e.g. <ref> [7, 9, 8] </ref>. For the most part however, GP solutions are restricted to non-iterative (non-looping) programs. To both broaden the domain of GP applications and to scale to larger problem sizes, it is necessary to extend GP to iterative programs.
Reference: [8] <author> J. Koza. </author> <title> Genetic Programming: On the Programming of Computers by the Means of Natural Selection. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Genetic programming (GP) <ref> [8] </ref> uses principles of evolution (populations, fitness measures, recombination) to perform directed non-linear searches in the space of computer programs. GP has successfully produced solution programs in many problem domains, e.g. [7, 9, 8]. For the most part however, GP solutions are restricted to non-iterative (non-looping) programs. <p> 1 Introduction Genetic programming (GP) [8] uses principles of evolution (populations, fitness measures, recombination) to perform directed non-linear searches in the space of computer programs. GP has successfully produced solution programs in many problem domains, e.g. <ref> [7, 9, 8] </ref>. For the most part however, GP solutions are restricted to non-iterative (non-looping) programs. To both broaden the domain of GP applications and to scale to larger problem sizes, it is necessary to extend GP to iterative programs. <p> Cramer [3] describes simulated evolution of programs in a machine language with a high-level LOOP construct parameterized by an expression e and an integer variable denoting the number of iterative executions of e; the system externally limits a program's running time. Koza <ref> [8] </ref> similarly introduces the Do-Until (DU) iterative language construct; parameterized by an expression e and a predicate p, DU iteratively evaluates e until p is true. Each DU operator in the program is, however, restricted in that the number of its iterations is externally bounded from above. <p> In this manner, F selects for programs that resemble multiplication and that ter minate. 4.3 Population Selection Population selection, for the construction of successive generations, is performed via proportional selection (see, e.g., <ref> [8, 11] </ref>). Let P be a population (set) of N programs.
Reference: [9] <editor> J. Koza. </editor> <booktitle> Genetic Programming II. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Genetic programming (GP) [8] uses principles of evolution (populations, fitness measures, recombination) to perform directed non-linear searches in the space of computer programs. GP has successfully produced solution programs in many problem domains, e.g. <ref> [7, 9, 8] </ref>. For the most part however, GP solutions are restricted to non-iterative (non-looping) programs. To both broaden the domain of GP applications and to scale to larger problem sizes, it is necessary to extend GP to iterative programs.
Reference: [10] <author> D. B. MacQueen. </author> <title> Modules for Standard ML (revised version). Polymorphism, </title> <address> II(2), </address> <month> October </month> <year> 1985. </year>
Reference-contexts: It is written in the Standard ML (SML) programming language [12] and implemented using the Standard ML of New Jersey (SML/NJ) compiler [1]. The SML/NJ implementation supports parameterized modules <ref> [10] </ref> which are indispensable in an experimentation framework. SML's strong static typing ensures that module implementations match their declared interfaces (signatures).
Reference: [11] <author> Z. Michalewicz. </author> <title> Genetic Algorithms + Data Structures = Evolution Programs. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: In this manner, F selects for programs that resemble multiplication and that ter minate. 4.3 Population Selection Population selection, for the construction of successive generations, is performed via proportional selection (see, e.g., <ref> [8, 11] </ref>). Let P be a population (set) of N programs.
Reference: [12] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 6 </month>
Reference-contexts: It is written in the Standard ML (SML) programming language <ref> [12] </ref> and implemented using the Standard ML of New Jersey (SML/NJ) compiler [1]. The SML/NJ implementation supports parameterized modules [10] which are indispensable in an experimentation framework. SML's strong static typing ensures that module implementations match their declared interfaces (signatures).
References-found: 12

