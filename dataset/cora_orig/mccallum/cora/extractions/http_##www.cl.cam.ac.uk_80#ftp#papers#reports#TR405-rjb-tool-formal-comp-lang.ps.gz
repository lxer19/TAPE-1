URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR405-rjb-tool-formal-comp-lang.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Title: A Tool to Support Formal Reasoning about Computer Languages  
Author: Richard J. Boulton 
Date: November 1996  
Address: New Museums Site, Pembroke Street Cambridge CB2 3QG, United Kingdom  
Affiliation: University of Cambridge Computer Laboratory  
Abstract: A tool to support formal reasoning about computer languages and specific language texts is described. The intention is to provide a tool that can build a formal reasoning system in a mechanical theorem prover from two specifications, one for the syntax of the language and one for the semantics. A parser, pretty-printer and internal representations are generated from the former. Logical representations of syntax and semantics, and associated theorem proving tools, are generated from the combination of the two specifications. The main aim is to eliminate tedious work from the task of prototyping a reasoning tool for a computer language, but the abstract specifications of the language also assist the automation of proof. 
Abstract-found: 1
Intro-found: 1
Reference: [BCD + 88] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> CENTAUR: the system. </title> <booktitle> In Henderson [Hen88], </booktitle> <pages> pages 14-24. </pages>
Reference-contexts: Since CLaReT also supports a different style of semantics it is complementary to the work of Reetz and Kropf. 6.2 Software Development Environments There are a number of language-independent software development environments that provide similar features to CLaReT, e.g. Centaur <ref> [BCD + 88] </ref>, the Ergo Support System (ESS) [LPRS88], the programming system generator PSG [BS86], and the Synthesizer Generator [RT89]. These systems have not been used by researchers who embed computer languages in interactive theorem provers.
Reference: [BGG + 92] <author> R. Boulton, A. Gordon, M. Gordon, J. Harrison, J. Herbert, and J. Van Tassel. </author> <title> Experience with embedding hardware description languages in HOL. </title> <editor> In Stavridou et al. </editor> <booktitle> [SMB92], </booktitle> <pages> pages 129-156. </pages>
Reference-contexts: the Engineering and Physical Sciences Research Council of Great Britain under grant GR/J42236. 1 work on the Piton assembly language [Moo89] using an operational semantics in the Boyer-Moore logic [BM79], Gordon's axiomatic semantics for a simple imperative language [Gor89] in the HOL system [GM93], embeddings of various hardware description languages <ref> [Goo91, BHY92, BGG + 92, Ree95] </ref>, a compiler correctness proof for a simple functional programming language in the LF logical framework [HP92], and reasoning about the core of Standard ML [Sym93, VG93] and its module system [GM95].
Reference: [BHK89] <author> J. A. Bergstra, J. Heering, and P. Klint, </author> <title> editors. Algebraic Specification. </title> <publisher> ACM Press in co-operation with Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The data structures that abstractly represent the information required as input to parser generators, etc., are available and documented. The intention is to make it easy to retarget the output for other tools and other programming languages. 6.2.1 Centaur and ASF+SDF Centaur has two collections of specification languages: ASF+SDF <ref> [BHK89] </ref> (a combination of ASF and SDF) and Metal/PPML/Typol. SDF [HHKR89] and Metal [KLMM83] are specification languages for concrete and abstract syntax.
Reference: [BHY92] <author> B. C. Brock, W. A. Hunt, Jr., and W. D. Young. </author> <title> Introduction to a formally defined hardware description language. </title> <editor> In Stavridou et al. </editor> <booktitle> [SMB92], </booktitle> <pages> pages 3-35. </pages>
Reference-contexts: the Engineering and Physical Sciences Research Council of Great Britain under grant GR/J42236. 1 work on the Piton assembly language [Moo89] using an operational semantics in the Boyer-Moore logic [BM79], Gordon's axiomatic semantics for a simple imperative language [Gor89] in the HOL system [GM93], embeddings of various hardware description languages <ref> [Goo91, BHY92, BGG + 92, Ree95] </ref>, a compiler correctness proof for a simple functional programming language in the LF logical framework [HP92], and reasoning about the core of Standard ML [Sym93, VG93] and its module system [GM95].
Reference: [BM79] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: an early compiler correctness proof for a simple ALGOL-like language [MW72] mechanised in Stanford LCF [Mil72], Moore's fl Research supported by the Engineering and Physical Sciences Research Council of Great Britain under grant GR/J42236. 1 work on the Piton assembly language [Moo89] using an operational semantics in the Boyer-Moore logic <ref> [BM79] </ref>, Gordon's axiomatic semantics for a simple imperative language [Gor89] in the HOL system [GM93], embeddings of various hardware description languages [Goo91, BHY92, BGG + 92, Ree95], a compiler correctness proof for a simple functional programming language in the LF logical framework [HP92], and reasoning about the core of Standard ML
Reference: [BMW92] <author> D. F. Brown, H. Moura, and D. A. Watt. Actress: </author> <title> an action semantics directed compiler generator. </title> <editor> In U. Kastens and P. Pfahler, editors, </editor> <booktitle> Proceedings of the 4th International Conference on Compiler Construction (CC'92), volume 641 of Lecture Notes in Computer Science, </booktitle> <pages> pages 95-109, </pages> <address> Paderborn, FRG, </address> <month> October </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: One tool in current use is Actress <ref> [BMW92] </ref>, a semantics-directed compiler generator for Mosses' action semantics [Mos92]. This uses ML-Lex and ML-Yacc to generate a parser, so its syntactic specification is at a lower level than in CLaReT, but the big difference is that Actress is not intended to support formal reasoning.
Reference: [Bou94] <author> R. J. Boulton. </author> <title> Efficiency in a Fully-Expansive Theorem Prover. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> New Museums Site, Pembroke Street, Cambridge CB2 3QG, U.K., </address> <month> May </month> <year> 1994. </year> <type> Technical Report 337. </type>
Reference-contexts: This approach produces a fast evaluator that also allows some symbolic entities. Rajan [Raj92] describes the necessary translation between terms and ML programs, and the current author has described a theorem proving framework in which the use of a hybrid evaluator can be mixed with normal logical inferences <ref> [Bou94] </ref>. Kaufmann and Moore take a different approach in the ACL2 theorem prover [KM94]; their logic is an applicative sublanguage of 9 Common Lisp, so their terms are inherently executable. The drawback is that this language lacks the expressive power of higher-order logic.
Reference: [Bou96] <author> R. J. Boulton. Syn: </author> <title> A single language for specifying abstract syntax trees, lexical analysis, parsing and pretty-printing. </title> <type> Technical Report 390, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> New Museums Site, Pembroke Street, Cambridge CB2 3QG, UK, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: The language for specifying syntax is unusual in allowing the form of the abstract syntax trees (ASTs), the lexical analysis, the parsing, and pretty-printing information, all to be given in a single non-redundant formalism. Details of the language can be found in a separate paper <ref> [Bou96] </ref>. The tools for semantics are still under development. Collectively the tools are called "CLaReT" which is an abbreviation for "Computer Language Reasoning Tool". CLaReT has been developed within the framework of a wider project. <p> This allows them to be used in a graphical user interface. The next level of the system is called ML-Syn. It takes a single specification for syntax (an extended BNF grammar) and produces input for ML-Lex, ML-Yacc, and ML-Pretty. The specification language, called Syn <ref> [Bou96] </ref>, is at a higher level than the languages used by ML-Lex, etc., and other syntax-specification languages could be generated from it. ML-Syn overcomes the problem of maintaining consistency between the abstract syntax representations used by the parser, pretty-printer and other tools by generating them from one specification. <p> Both the latter work and the formatting in CLaReT's Syn language are based on PPML. For a discussion of how Syn compares with the syntactic specification languages of Centaur and the other software development environments, see the paper on Syn <ref> [Bou96] </ref>. ASF is an algebraic specification language and Typol [Des84] implements Kahn's natural semantics [Kah87]. ASF specifies semantics by means of conditional equations. The equations can be written over a concrete syntax specified in SDF. Currently, CLaReT is limited to specifications over the abstract syntax.
Reference: [BS86] <author> R. Bahlke and G. Snelting. </author> <title> The PSG system: From formal language definitions to interactive programming environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 547-576, </pages> <month> Oc-tober </month> <year> 1986. </year> <month> 16 </month>
Reference-contexts: Centaur [BCD + 88], the Ergo Support System (ESS) [LPRS88], the programming system generator PSG <ref> [BS86] </ref>, and the Synthesizer Generator [RT89]. These systems have not been used by researchers who embed computer languages in interactive theorem provers. This suggests that the effort involved in integrating such systems to theorem provers for one-off embeddings is prohibitive.
Reference: [BS89] <editor> G. Birtwistle and P. A. Subrahmanyam, editors. </editor> <title> Current Trends in Hardware Verification and Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [Cam88] <author> A. J. Camilleri. </author> <title> Executing Behavioural Definitions in Higher Order Logic. </title> <type> PhD thesis, </type> <institution> University of Cambridge, </institution> <month> July </month> <year> 1988. </year> <note> Available as University of Cambridge Computer Laboratory Technical Report 140. </note>
Reference-contexts: It is not clear that this can be done in general (at least not efficiently). Practical experience is required to determine the extent to which quantifiers, etc., should be allowed in the specification language. Camilleri <ref> [Cam88] </ref> and, more recently, Rajan [Raj92] have investigated the execution of logical for mulas in the HOL system. 5.1 Denotation Language Features The specification language has built-in support for environments (or states, as appropriate). The intention is that these be implicit wherever possible to avoid verbosity.
Reference: [Coq94] <institution> INRIA Rocquencourt and ENS Lyon. </institution> <note> The Coq Proof Assistant Reference Manual, version 5.10 edition, </note> <year> 1994. </year>
Reference-contexts: Typol is particularly suited to static semantics, e.g. type checking, and there exists a means of translating natural semantics in Typol to inductive definitions in the Coq theorem prover <ref> [Coq94] </ref>. It is questionable whether the ASF language would be accepted by researchers who use theorem provers to reason about languages, since it limits them to using equations for specification and rewriting for proof.
Reference: [CZ94] <author> J. Camilleri and V. Zammit. </author> <title> Symbolic animation as a proof tool. </title> <booktitle> In Melham and Camilleri [MC94], </booktitle> <pages> pages 113-127. </pages>
Reference-contexts: Structured operational semantics may be supported in the future. From a denotational specification CLaReT generates definitions of logical functions over the abstract syntax and, if required, analogous ML functions. The latter allow rapid `execution' of the semantics. For rigorous execution a symbolic evaluator <ref> [CZ94] </ref> is also generated. This uses logical inference rules to ensure the correctness of the evaluation. Such symbolic evaluators can be implemented as a brute-force application of the semantic functions as rewrite rules. However, evaluators written in this fashion are notoriously slow. <p> However, this does not allow parts of the syntax or the environment to be `symbolic', i.e. a meta-variable, as is allowed in the logic of the theorem prover <ref> [CZ94] </ref>. On the other hand, evaluation in the logic requires the definitions of the denotation functions (and any auxiliary functions used) to be applied as rewrite rules. Writing such an evaluator by hand is straightforward but time-consuming and error-prone. CLaReT generates the evaluator automatically.
Reference: [Des84] <author> T. Despeyroux. </author> <title> Executable specification of static semantics. </title> <editor> In G. Kahn, D. B. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Symposium on the Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, Sophia-Antipolis, </booktitle> <address> France, June 1984. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Both the latter work and the formatting in CLaReT's Syn language are based on PPML. For a discussion of how Syn compares with the syntactic specification languages of Centaur and the other software development environments, see the paper on Syn [Bou96]. ASF is an algebraic specification language and Typol <ref> [Des84] </ref> implements Kahn's natural semantics [Kah87]. ASF specifies semantics by means of conditional equations. The equations can be written over a concrete syntax specified in SDF. Currently, CLaReT is limited to specifications over the abstract syntax.
Reference: [GB88] <author> G. D. Gough and H. Barringer. </author> <title> A semantics driven temporal verification system. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the 2nd Euro-pean Symposium on Programming (ESOP'88), volume 300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 21-33, </pages> <address> Nancy, France, March 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PSG, on the other hand, requires that place holders be instantiated before execution can proceed. 6.3 A Generic State Machine Generator The SMG system <ref> [GB88] </ref> supports temporal logic model checking for languages by transforming programs to suitable finite state models. The languages are specified by syntax and structured operational semantics, and the tool interfaces to various temporal logic model checkers.
Reference: [GM93] <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: LCF [Mil72], Moore's fl Research supported by the Engineering and Physical Sciences Research Council of Great Britain under grant GR/J42236. 1 work on the Piton assembly language [Moo89] using an operational semantics in the Boyer-Moore logic [BM79], Gordon's axiomatic semantics for a simple imperative language [Gor89] in the HOL system <ref> [GM93] </ref>, embeddings of various hardware description languages [Goo91, BHY92, BGG + 92, Ree95], a compiler correctness proof for a simple functional programming language in the LF logical framework [HP92], and reasoning about the core of Standard ML [Sym93, VG93] and its module system [GM95].
Reference: [GM95] <author> E. Gunter and S. Maharaj. </author> <title> Studying the ML module system in HOL. </title> <journal> The Computer Journal, </journal> <volume> 38(2) </volume> <pages> 142-151, </pages> <year> 1995. </year>
Reference-contexts: imperative language [Gor89] in the HOL system [GM93], embeddings of various hardware description languages [Goo91, BHY92, BGG + 92, Ree95], a compiler correctness proof for a simple functional programming language in the LF logical framework [HP92], and reasoning about the core of Standard ML [Sym93, VG93] and its module system <ref> [GM95] </ref>. Formalisms such as temporal logics and process algebras have also been embedded in theorem proving systems. Increasingly the embedding technique is being applied to industrial-strength computer languages.
Reference: [GMM + 78] <author> M. Gordon, R. Milner, L. Morris, M. Newey, and C. Wadsworth. </author> <title> A metalanguage for interactive proof in LCF. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 119-130, </pages> <address> Tucson, Arizona, </address> <month> January </month> <year> 1978. </year> <note> Also issued as Report CSR-16-77, </note> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1977. </year>
Reference-contexts: This is not a coincidence; the ML programming language evolved from the meta-language <ref> [GMM + 78] </ref> of the LCF theorem prover [GMW79]. 3 CLaReT ML-Syn Lex Yacc ML Pretty Pretty-Printer for ML ASTs Standard ML of New Jersey language. Each such tool generates an ML AST and passes it to the pretty-printer to produce an output file.
Reference: [GMW79] <author> M. J. Gordon, A. J. Milner, and C. P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF: </publisher>
Reference-contexts: This is not a coincidence; the ML programming language evolved from the meta-language [GMM + 78] of the LCF theorem prover <ref> [GMW79] </ref>. 3 CLaReT ML-Syn Lex Yacc ML Pretty Pretty-Printer for ML ASTs Standard ML of New Jersey language. Each such tool generates an ML AST and passes it to the pretty-printer to produce an output file.
References-found: 19

