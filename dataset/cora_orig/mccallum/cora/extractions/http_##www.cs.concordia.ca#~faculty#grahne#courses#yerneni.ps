URL: http://www.cs.concordia.ca/~faculty/grahne/courses/yerneni.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/courses/
Root-URL: http://www.cs.concordia.ca
Email: hectorg@cs.stanford.edu,  
Title: Optimizing Large Join Queries in Mediation Systems  
Author: Ramana Yerneni, Chen Li Jeffrey Ullman, Hector Garcia-Molina fyerneni, chenli, ullman, 
Address: USA  
Affiliation: University,  
Note: Stanford  
Abstract: In data integration systems, queries posed to a mediator need to be translated into a sequence of queries to the underlying data sources. In a heterogeneous environment, with sources of diverse and limited query capabilities, not all the translations are feasible. In this paper, we study the problem of finding feasible and efficient query plans for mediator systems. We consider conjunctive queries on mediators and model the source capabilities through attribute-binding adornments. We use a simple cost model that focuses on the major costs in mediation systems, those involved with sending queries to sources and getting answers back. Under this metric, we develop two algorithms for source query sequencing one based on a simple greedy strategy and another based on a partitioning scheme. The first algorithm produces optimal plans in some scenarios, and we show a linear bound on its worst case performance when it misses optimal plans. The second algorithm generates optimal plans in more scenarios, while having no bound on the margin by which it misses the optimal plans. We also report on the results of the experiments that study the performance of the two algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Apers, A. Hevner, S. Yao. </author> <title> Optimization Algorithms for Distributed Queries. </title> <journal> In IEEE Trans. Software Engineering, </journal> <volume> 9(1), </volume> <year> 1983. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 2. <author> P. Bernstein, N. Goodman, E. Wong, C. Reeve, J. Rothnie. </author> <title> Query Processing in a System for Distributed Databases (SDD-1). </title> <journal> In ACM Trans. Database Systems, </journal> <volume> 6(4), </volume> <year> 1981. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 3. <author> S. Chawathe, H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. Ullman, J. Widom. </author> <title> The TSIMMIS project: Integration of heterogeneous information sources. </title> <booktitle> In IPSJ, </booktitle> <address> Japan, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Integration systems based on a mediation architecture [31] provide users with seamless access to data from many heterogeneous sources. Examples of such systems are TSIMMIS <ref> [3] </ref>, Garlic [8], Information Manifold [14], and DISCO [26]. In these systems, mediators define integrated views based on the data provided by the sources. They translate user queries on integrated views into source queries and postprocessing operations on the source query results. <p> In order to find the best feasible plan for a user query, we assume that the mediator processes the logical plan one conjunctive query at a time (as in <ref> [3, 8, 14] </ref>). Thus, we reduce the problem of finding the best feasible plan for the user query to the problem of finding the best feasible plan for a conjunctive query in the logical plan.
Reference: 4. <author> S. Cluet, G. Moerkotte. </author> <title> On the Complexity of Generating Optimal Left-deep Processing Trees with Cross Products. </title> <booktitle> In ICDT Conference, </booktitle> <year> 1995. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 5. <author> R. Epstein, M. Stonebraker. </author> <title> Analysis of Distributed Database Strategies. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1980. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 6. <author> C. Galindo-Legaria, A. Pellenkoft, M. Kersten. </author> <title> Fast, Randomized Join Order Selection Why Use Transformations? In VLDB Conference, </title> <year> 1994. </year>
Reference-contexts: In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. Some other solutions reduce the search space through techniques like simulated annealing, random probes, or other heuristics <ref> [6, 11, 12, 16, 18, 23-25] </ref>. While these approaches may generate efficient plans in some cases, they do not have any performance guarantees in terms of the quality of plans generated (i.e., the plans generated by them can be arbitrarily far from the optimal one).
Reference: 7. <author> M. Garey, D. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference: 8. <author> L. Haas, D. Kossman, E.L. Wimmers, J. Yang. </author> <title> Optimizing queries across diverse data sources. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Integration systems based on a mediation architecture [31] provide users with seamless access to data from many heterogeneous sources. Examples of such systems are TSIMMIS [3], Garlic <ref> [8] </ref>, Information Manifold [14], and DISCO [26]. In these systems, mediators define integrated views based on the data provided by the sources. They translate user queries on integrated views into source queries and postprocessing operations on the source query results. <p> The translation process can be quite challenging when integrating a large number of heterogeneous sources. One of the important challenges for integration systems is to deal with the diverse capabilities of sources in answering queries <ref> [8, 15, 19] </ref>. This problem arises due to the heterogeneity in sources ranging from simple file systems to full-fledged relational databases. The problem we address in this paper is how to generate efficient mediator query plans that respect the limited and diverse capabilities of data sources. <p> More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. <p> In order to find the best feasible plan for a user query, we assume that the mediator processes the logical plan one conjunctive query at a time (as in <ref> [3, 8, 14] </ref>). Thus, we reduce the problem of finding the best feasible plan for the user query to the problem of finding the best feasible plan for a conjunctive query in the logical plan.
Reference: 9. <author> J. Hammer, H. Garcia-Molina, S. Nestorov, R. Yerneni, M. Breunig, V. Vassalos. </author> <title> Template-Based Wrappers in the TSIMMIS System. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1997. </year>
Reference-contexts: To simplify the presentation, we assume that sources provide their data in the form of relations. If sources have other data models, one could use wrappers <ref> [9] </ref> to create the simple relational view of data. Each source is assumed to provide a single relation. If a source provides multiple relations, we can model it in our framework as a set of logical sources, all having the same physical source.
Reference: 10. <author> T. Ibaraki, T. Kameda. </author> <title> On the Optimal Nesting Order for Computing N-relational Joins. </title> <journal> In ACM Trans. Database Systems, </journal> <volume> 9(3), </volume> <year> 1984. </year>
Reference-contexts: Many of these techniques may even fail to generate a feasible plan, while the user query does have a feasible plan. The remaining solutions <ref> [10, 13, 21] </ref> use specific cost models and clever techniques that exploit them to produce optimal join orders efficiently. While these solutions are very good for the join-order problem where those cost models are appropriate, they are hard to adopt in our context because of two difficulties.
Reference: 11. <author> Y. Ioannidis, Y. Kang. </author> <title> Randomized Algorithms for Optimizing Large Join Queries. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1990. </year>
Reference-contexts: In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. Some other solutions reduce the search space through techniques like simulated annealing, random probes, or other heuristics <ref> [6, 11, 12, 16, 18, 23-25] </ref>. While these approaches may generate efficient plans in some cases, they do not have any performance guarantees in terms of the quality of plans generated (i.e., the plans generated by them can be arbitrarily far from the optimal one).
Reference: 12. <author> Y. Ioannidis, E. Wong. </author> <title> Query Optimization by Simulated Annealing. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. Some other solutions reduce the search space through techniques like simulated annealing, random probes, or other heuristics <ref> [6, 11, 12, 16, 18, 23-25] </ref>. While these approaches may generate efficient plans in some cases, they do not have any performance guarantees in terms of the quality of plans generated (i.e., the plans generated by them can be arbitrarily far from the optimal one).
Reference: 13. <author> R. Krishnamurthy, H. Boral, C. Zaniolo. </author> <title> Optimization of Non-recursive Queries. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1986. </year>
Reference-contexts: Many of these techniques may even fail to generate a feasible plan, while the user query does have a feasible plan. The remaining solutions <ref> [10, 13, 21] </ref> use specific cost models and clever techniques that exploit them to produce optimal join orders efficiently. While these solutions are very good for the join-order problem where those cost models are appropriate, they are hard to adopt in our context because of two difficulties.
Reference: 14. <author> A. Levy, A. Rajaraman, J. Ordille. </author> <title> Querying Heterogeneous Information Sources Using Source Descriptions. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1996. </year>
Reference-contexts: 1 Introduction Integration systems based on a mediation architecture [31] provide users with seamless access to data from many heterogeneous sources. Examples of such systems are TSIMMIS [3], Garlic [8], Information Manifold <ref> [14] </ref>, and DISCO [26]. In these systems, mediators define integrated views based on the data provided by the sources. They translate user queries on integrated views into source queries and postprocessing operations on the source query results. <p> In order to find the best feasible plan for a user query, we assume that the mediator processes the logical plan one conjunctive query at a time (as in <ref> [3, 8, 14] </ref>). Thus, we reduce the problem of finding the best feasible plan for the user query to the problem of finding the best feasible plan for a conjunctive query in the logical plan.
Reference: 15. <author> C. Li, R. Yerneni, V. Vassalos, H. Garcia-Molina, Y. Papakonstantinou, J. Ullman, M. Valiveti. </author> <title> Capability Based Mediation in TSIMMIS. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1998. </year>
Reference-contexts: The translation process can be quite challenging when integrating a large number of heterogeneous sources. One of the important challenges for integration systems is to deal with the diverse capabilities of sources in answering queries <ref> [8, 15, 19] </ref>. This problem arises due to the heterogeneity in sources ranging from simple file systems to full-fledged relational databases. The problem we address in this paper is how to generate efficient mediator query plans that respect the limited and diverse capabilities of data sources. <p> More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 16. <author> K. Morris. </author> <title> An algorithm for ordering subgoals in NAIL!. </title> <booktitle> In ACM PODS, </booktitle> <year> 1988. </year>
Reference-contexts: In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. Some other solutions reduce the search space through techniques like simulated annealing, random probes, or other heuristics <ref> [6, 11, 12, 16, 18, 23-25] </ref>. While these approaches may generate efficient plans in some cases, they do not have any performance guarantees in terms of the quality of plans generated (i.e., the plans generated by them can be arbitrarily far from the optimal one).
Reference: 17. <author> K. Ono, G. Lohman. </author> <title> Measuring the Complexity of Join Enumeration in Query Optimization. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1990. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 18. <author> C. Papadimitriou, K. Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive. Some other solutions reduce the search space through techniques like simulated annealing, random probes, or other heuristics <ref> [6, 11, 12, 16, 18, 23-25] </ref>. While these approaches may generate efficient plans in some cases, they do not have any performance guarantees in terms of the quality of plans generated (i.e., the plans generated by them can be arbitrarily far from the optimal one).
Reference: 19. <author> Y. Papakonstantinou, A. Gupta, L. Haas. </author> <title> Capabilities-based Query Rewriting in Mediator Systems. </title> <booktitle> In PDIS Conference, </booktitle> <year> 1996. </year>
Reference-contexts: The translation process can be quite challenging when integrating a large number of heterogeneous sources. One of the important challenges for integration systems is to deal with the diverse capabilities of sources in answering queries <ref> [8, 15, 19] </ref>. This problem arises due to the heterogeneity in sources ranging from simple file systems to full-fledged relational databases. The problem we address in this paper is how to generate efficient mediator query plans that respect the limited and diverse capabilities of data sources. <p> More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 20. <author> A. Pellenkoft, C. Galindo-Legaria, M. Kersten. </author> <title> The Complexity of Transformation-Based Join Enumeration. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1997. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 21. <author> W. Scheufele, G. Moerkotte. </author> <title> On the Comlexity of Generating Optimal Plans with Cartesian Products. </title> <booktitle> In PODS Conference, </booktitle> <year> 1997. </year>
Reference-contexts: Many of these techniques may even fail to generate a feasible plan, while the user query does have a feasible plan. The remaining solutions <ref> [10, 13, 21] </ref> use specific cost models and clever techniques that exploit them to produce optimal join orders efficiently. While these solutions are very good for the join-order problem where those cost models are appropriate, they are hard to adopt in our context because of two difficulties.
Reference: 22. <author> P. Selinger, M. Adiba. </author> <title> Access Path Selection in Distributed Databases Management Systems. In Readings in Database Systems. Edited by M. Stonebraker. </title> <publisher> Morgan-Kaufman Publishers, </publisher> <year> 1994. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 23. <author> M. Steinbrunn, G. Moerkotte, A. Kemper. </author> <title> Heuristic and Randomized Optimization for the Join Ordering Problem. </title> <journal> In VLDB Journal, </journal> <volume> 6(3), </volume> <year> 1997. </year>
Reference: 24. <author> A. Swami. </author> <title> Optimization of Large Join Queries: Combining Heuristic and Combinatorial Techniques. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1989. </year>
Reference: 25. <author> A. Swami, A. Gupta. </author> <title> Optimization of Large Join Queries. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1988. </year>
Reference: 26. <author> A. Tomasic, L. Raschid, P. Valduriez. </author> <title> Scaling Heterogeneous Databases and the Design of Disco. </title> <booktitle> In Int. Conf. on Distributed Computing Systems, </booktitle> <year> 1996. </year>
Reference-contexts: 1 Introduction Integration systems based on a mediation architecture [31] provide users with seamless access to data from many heterogeneous sources. Examples of such systems are TSIMMIS [3], Garlic [8], Information Manifold [14], and DISCO <ref> [26] </ref>. In these systems, mediators define integrated views based on the data provided by the sources. They translate user queries on integrated views into source queries and postprocessing operations on the source query results. The translation process can be quite challenging when integrating a large number of heterogeneous sources.
Reference: 27. <author> J. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Volumes I, II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD. </address>
Reference-contexts: A source supports a set of access templates on its relation that specify binding adornment requirements for source queries. 1 In Example 1, source S 2 had one access template: 1 We consider source-capabilities described as bf adornment patterns that distinguish bound (b) and free (f) argument positions <ref> [27] </ref>. The techniques developed in this paper can also be employed to solve the problem of mediator query planning when other source capability description languages are used. S bf (title; year), while source S 1 had two access templates: R bf (studio; title) and R fb (studio; title).
Reference: 28. <author> J. Ullman, M. Vardi. </author> <title> The Complexity of Ordering Subgoals. </title> <booktitle> In ACM PODS, </booktitle> <year> 1988. </year>
Reference-contexts: Proof. For any feasible execution of the logical plan based on a bushy tree of subgoals, we can construct another feasible execution based on a left-deep tree of subgoals (with the same leaf order). This is similar to the bound-is-easier assumption of <ref> [28] </ref>. See the full version of our paper [32] for a detailed proof. 2.4 The Formal Cost Model Our cost model is defined as follows: 1. The cost of a subgoal in the feasible plan is the number of source queries needed to answer this subgoal. 2.
Reference: 29. <author> B. Vance, D. Maier. </author> <title> Rapid Bushy Join-Order Optimization with Cross Products. </title> <booktitle> In SIGMOD Conference, </booktitle> <year> 1996. </year>
Reference-contexts: More precisely, we can assign infinite cost to infeasible sequences and then find the best join order. The join-order problem has been extensively studied in the literature, and many solutions have been proposed. Some solutions perform a rather exhaustive enumeration of plans, and hence do not scale well <ref> [1, 2, 4, 5, 8, 15, 17, 19, 20, 22, 29] </ref>. In particular, we are interested in Internet scenarios with many sources and subgoals, so these schemes are too expensive.
Reference: 30. <author> V. Vassalos, Y. Papakonstantinou. </author> <title> Describing and using query capabilities of heterogeneous sources. </title> <booktitle> In VLDB Conference, </booktitle> <year> 1997. </year>
Reference: 31. <author> G. Wiederhold. </author> <booktitle> Mediators in the Architecture of Future Information Systems. In IEEE Computer, </booktitle> <volume> 25 </volume> <pages> 38-49, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Integration systems based on a mediation architecture <ref> [31] </ref> provide users with seamless access to data from many heterogeneous sources. Examples of such systems are TSIMMIS [3], Garlic [8], Information Manifold [14], and DISCO [26]. In these systems, mediators define integrated views based on the data provided by the sources.
Reference: 32. <author> R. Yerneni, C. Li, J. Ullman, H. Garcia-Molina. </author> <title> Optimizing Large Join Queries in Mediation Systems. </title> <address> http://www-db.stanford.edu/pub/papers/ljq.ps </address>
Reference-contexts: For any feasible execution of the logical plan based on a bushy tree of subgoals, we can construct another feasible execution based on a left-deep tree of subgoals (with the same leaf order). This is similar to the bound-is-easier assumption of [28]. See the full version of our paper <ref> [32] </ref> for a detailed proof. 2.4 The Formal Cost Model Our cost model is defined as follows: 1. The cost of a subgoal in the feasible plan is the number of source queries needed to answer this subgoal. 2. <p> Theorem 3. We do not miss the optimal plan by not considering the executions of the logical plan based on bushy trees of subgoals. Proof. See the full version of our paper <ref> [32] </ref> for the proof. 3 The CHAIN Algorithm In this section, we present the CHAIN algorithm for finding the best feasible query plan. This algorithm is based on a greedy strategy of building a single sequence of subgoals that is feasible and efficient. <p> Due to space limitations, we have not provided proofs for all the lemmas and theorems. They are available in the full version of the paper <ref> [32] </ref>. Lemma 1. CHAIN runs in O (n 2 ) time, where n is the number of subgoals. 3 Lemma 2. CHAIN will generate a feasible plan, if the logical plan has feasible physical plans. Lemma 3. <p> PARTITION takes a very different approach to solve the plan generation problem. It is guaranteed to generate optimal plans in more scenarios than CHAIN but has a worse running time. 4.1 PARTITION The formal description of PARTITION is available in the full version of the paper <ref> [32] </ref>. Here, we present the essential aspects of the algorithm. The PARTITION algorithm has two phases. In the first phase, it organizes the subgoals into clusters based on the capabilities of the sources. The property satisfied by the clusters generated by the first phase of PARTITION is as follows. <p> Lemma 9. For any integer m &gt; 0, there exists a logical plan and a database for which PARTITION generates a plan that is at least m times as expensive as the optimal plan. Proof. Refer to <ref> [32] </ref> for the detailed proof. The essential idea is to construct a logical plan and a database for any given m that will make PARTITION miss the optimal plan by a factor greater than m. Lemma 10. <p> We used both the simple cost model of Section 2.4 as well as the more complex cost model M 2 of Section 5 in our performance analysis. The results did not deviate much from one cost model to the other. The details of the experiments are in <ref> [32] </ref>. Here, we briefly mention the important results based on the simpler cost model of Section 2.4. Fig. 3. Rate of Missing Optimal Plans Fig. 4. Margin of Missing Optimal Plans plans vs. number of query subgoals.
References-found: 32

