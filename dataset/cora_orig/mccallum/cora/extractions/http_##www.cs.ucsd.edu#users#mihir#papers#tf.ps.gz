URL: http://www.cs.ucsd.edu/users/mihir/papers/tf.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/tf.html
Root-URL: http://www.cs.ucsd.edu
Title: Many-to-one Trapdoor Functions and their Relation to Public-key Cryptosystems  
Author: M. Bellare S. Halevi A. Sahai S. Vadhan 
Keyword: One-way functions, trapdoor functions, public key cryptosystems, relations amongst primitives.  
Address: San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA.  P.O. Box 704, Yorktown Heights, NY 10598, USA.  545 Technology Square, Cambridge, MA 02139, USA.  545 Technology Square, Cambridge, MA 02139, USA.  
Affiliation: Dept. of Computer Science Engineering, University of California at  Science and Engineering. IBM T. J. Watson Research Center,  MIT Laboratory for Computer Science,  MIT Laboratory for Computer Science,  
Note: Lecture Notes in Computer Science Vol. H. Krawczyk ed., Springer-Verlag, 1998.  Supported in part by NSF CAREER Award CCR-9624439 and a 1996 Packard Foundation Fellowship in  Supported by a DOD/NDSEG Graduate Fellowship and partially by DARPA grant DABT-96-C-0018.  Supported by a DOD/NDSEG Graduate Fellowship and partially by DARPA grant DABT-96-C-0018.  
Email: E-Mail: mihir@cs.ucsd.edu.  E-Mail: shaih@watson.ibm.com.  E-Mail: amits@theory.lcs.mit.edu.  E-Mail: salil@math.mit.edu.  
Web: URL: http://www-cse.ucsd.edu/users/mihir.  URL: http://www-math.mit.edu/~salil.  
Date: June 1998  
Abstract: A preliminary version of this paper appears in Advances in Cryptology - Crypto 98 Proceedings, Abstract The heart of the task of building public key cryptosystems is viewed as that of "making trapdoors;" in fact, public key cryptosystems and trapdoor functions are often discussed as synonymous. How accurate is this view? In this paper we endeavor to get a better understanding of the nature of "trapdoorness" and its relation to public key cryptosystems, by broadening the scope of the investigation: we look at general trapdoor functions; that is, functions that are not necessarily injective (ie., one-to-one). Our first result is somewhat surprising: we show that non-injective trapdoor functions (with super-polynomial pre-image size) can be constructed from any one-way function (and hence it is unlikely that they suffice for public key encryption). On the other hand, we show that trapdoor functions with polynomial pre-image size are sufficient for public key encryption. Together, these two results indicate that the pre-image size is a fundamental parameter of trapdoor functions. We then turn our attention to the converse, asking what kinds of trapdoor functions can be constructed from public key cryptosystems. We take a first step by showing that in the random-oracle model one can construct injective trapdoor functions from any public key cryptosystem. 
Abstract-found: 1
Intro-found: 1
Reference: [AjDw] <author> M. Ajtai and C. Dwork. </author> <title> A public-key cryptosystem with worst-case / average-case equivalence. </title> <booktitle> Proceedings of the 29th Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1997. </year>
Reference-contexts: It is now understood that secure encryption must be probabilistic [GoMi].) Theorem 5.2 has several corollaries. (Caveat: All in the random oracle model). First, by applying a transformation of [BeRo], it follows that we can construct non-malleable and chosen-ciphertext secure encryption schemes based on the Ajtai-Dwork cryptosystem <ref> [AjDw] </ref>. Second, combining Theorems 5.2 and 4.1, the existence of trapdoor functions with polynomially bounded pre-image size implies the existence of injective trapdoor functions. (With high probability over the choice of oracle.
Reference: [AMM] <author> Adleman, Manders and Miller. </author> <title> On taking roots in finite fields. </title> <booktitle> Proceedings of the 18th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1977. </year>
Reference-contexts: The inversion algorithm Rab-Inv, given N , (p; q), and a quadratic-residue y mod N , computes the square roots of y modulo both p and q (which can be done in polynomial time <ref> [Be, AMM] </ref>) and then uses the Chinese Remainder Theorem to obtain a square root of y modulo N .
Reference: [BHSV] <author> M. Bellare, S. Halevi, A. Sahai, and S. Vadhan. </author> <title> Many-to-one trapdoor functions and their relation to public-key cryptosystems. </title> <booktitle> Advances in Cryptology - Crypto 98 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> ??, <editor> H. Krawczyk ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference: [BeRo] <author> M. Bellare and P. Rogaway. </author> <title> Random oracles are practical: a paradigm for designing efficient protocols. </title> <booktitle> Proceedings of the First Annual Conference on Computer and Communications Security, ACM, </booktitle> <year> 1993. </year>
Reference-contexts: not only an open question, but seems a hard one. (In particular, a positive answer would imply injective trapdoor functions based on the Diffie-Hellman assumption, a long standing open problem.) In order to get some insight and possible approaches to it, we consider it in a random oracle model (cf. <ref> [ImRu, BeRo] </ref>). Theorem 5.2 says that here the answer is affirmative: given an arbitrary secure public key cryptosystem, we present a function that has access to an oracle H, and prove the function is injective, trapdoor, and one-way when H is random. <p> It is now understood that secure encryption must be probabilistic [GoMi].) Theorem 5.2 has several corollaries. (Caveat: All in the random oracle model). First, by applying a transformation of <ref> [BeRo] </ref>, it follows that we can construct non-malleable and chosen-ciphertext secure encryption schemes based on the Ajtai-Dwork cryptosystem [AjDw]. Second, combining Theorems 5.2 and 4.1, the existence of trapdoor functions with polynomially bounded pre-image size implies the existence of injective trapdoor functions. (With high probability over the choice of oracle. <p> We now proceed with a more formal description of the random oracle model and our result. The random oracle model. In any cryptographic scheme which operates in the random oracle model, all parties are given (in addition to their usual resources) the ability to make oracle queries <ref> [BeRo] </ref>. It is postulated that all oracle queries, independent of the party which makes them, are answered by a single function, denoted O, which is uniformly selected among all possible functions (where the set of possible functions is determined by the security parameter).
Reference: [Be] <author> E. Berlekamp. </author> <title> Factoring polynomials over large finite fields. </title> <journal> Mathematics of Computation, </journal> <volume> Vol. 24, </volume> <year> 1970, </year> <pages> pp. 713-735. </pages>
Reference-contexts: The inversion algorithm Rab-Inv, given N , (p; q), and a quadratic-residue y mod N , computes the square roots of y modulo both p and q (which can be done in polynomial time <ref> [Be, AMM] </ref>) and then uses the Chinese Remainder Theorem to obtain a square root of y modulo N .
Reference: [BlMi] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 13, No. 4, </volume> <pages> 850-864, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: The construction of Theorem 5.2 is quite simple, and the natural next question is whether the random oracle H can be replaced by some constructible cryptographic primitive. We show that this may be difficult, by showing that a cryptographically strong pseudorandom bit generator <ref> [BlMi, Ya] </ref>, which seems like a natural choice for this construction, does not suffice. (See Appendix A).
Reference: [Ca] <author> R. Canetti. </author> <title> Towards realizing random oracles: Hash functions that hide all partial information. </title> <booktitle> Advances in Cryptology - Crypto 97 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1294, </volume> <editor> B. Kaliski ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <month> 16 </month>
Reference-contexts: We show that this may be difficult, by showing that a cryptographically strong pseudorandom bit generator [BlMi, Ya], which seems like a natural choice for this construction, does not suffice. (See Appendix A). The next step may be to follow the approach initiated by Canetti <ref> [Ca] </ref>: find an appropriate cryptographic notion which, if satisfied by H, would suffice for the correctness of the construction, and then try to implement H via a small family of functions.
Reference: [CGH] <author> R. Canetti, O. Goldreich and S. Halevi. </author> <title> The random oracle model, revisited. </title> <booktitle> Proceedings of the 30th Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1998. </year>
Reference-contexts: However, one should keep in mind that replacement of a random oracle by a suitable constructible function is not always possible <ref> [CGH] </ref>. Thus, our last result should be interpreted with care. 1.3 Discussion and implications Theorems 3.1 and 4.1 indicate that pre-image size is a crucial parameter when considering the power of trapdoor functions, particularly with respect to constructing public-key cryptosystems.
Reference: [DiHe] <author> W. Diffie and M. Hellman. </author> <title> New directions in cryptography. </title> <journal> IEEE Trans. Info. Theory, </journal> <volume> Vol. IT-22, No. 6, </volume> <month> November </month> <year> 1976, </year> <pages> pp. 644-654. </pages>
Reference-contexts: Amongst these are that "trapdoor one-way functions" are not necessarily hard to build, and their relation to public key encryption is more subtle than it might seem. 1.1 Background The main notions discussed and related in this paper are one-way functions <ref> [DiHe] </ref>, trapdoor (one-way) functions [DiHe], semantically secure encryption schemes [GoMi], and unapproximable trapdoor predicates [GoMi]. <p> Amongst these are that "trapdoor one-way functions" are not necessarily hard to build, and their relation to public key encryption is more subtle than it might seem. 1.1 Background The main notions discussed and related in this paper are one-way functions <ref> [DiHe] </ref>, trapdoor (one-way) functions [DiHe], semantically secure encryption schemes [GoMi], and unapproximable trapdoor predicates [GoMi]. <p> that the functions need not be injective: careful distinctions are made between "(general) one-way functions", "injective one-way functions," and "one-way permutations." In principle, the distinction applies equally well to trapdoor one-way functions. (In the non-injective case, knowledge of the trapdoor permits recovery of some pre-image of any given range point <ref> [DiHe] </ref>.) However, all attention in the literature has focused on injective trapdoor functions, perhaps out of the sense that this is what is necessary for constructing encryption schemes: the injectivity of the trapdoor function guarantees the unique decryptability of the encryption scheme. <p> Moreover, it may no longer have a (full) trapdoor, since it may not be possible to recover the randomness from the ciphertext. (Public key cryptosystems in the Diffie and Hellman sense <ref> [DiHe] </ref> imply injective trapdoor one-way functions as the authors remark, but that's because encryption there is deterministic. It is now understood that secure encryption must be probabilistic [GoMi].) Theorem 5.2 has several corollaries. (Caveat: All in the random oracle model).
Reference: [DDN] <author> D. Dolev, C. Dwork, and M. Naor. </author> <title> Non-Malleable Cryptography. </title> <booktitle> Proceedings of the 23rd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1991. </year>
Reference: [ElG] <author> T. El Gamal. </author> <title> A public key cryptosystem and a signature scheme based on discrete logarithms. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> Vol. 31, </volume> <year> 1985, </year> <pages> pp. 469-472. </pages>
Reference-contexts: Second, combining Theorems 5.2 and 4.1, the existence of trapdoor functions with polynomially bounded pre-image size implies the existence of injective trapdoor functions. (With high probability over the choice of oracle. See Remark 5.11.) Third, if the Decisional Diffie-Hellman problem is hard (this means the El Gamal <ref> [ElG] </ref> cryptosystem is semantically secure) then there exists an injective trapdoor function.
Reference: [GoLe] <author> O. Goldreich and L. Levin. </author> <title> A hard predicate for all one-way functions. </title> <booktitle> Proceedings of the 21st Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: The construction is in two steps. We first build an unapproximable family of trapdoor predicates P with decryption error 1=2 1= poly (k), and then reduce the decryption error by repetition to get the family claimed in the theorem. The first step uses the Goldreich-Levin inner-product construction <ref> [GoLe] </ref>. This construction says that if f is a one-way function, one can securely encrypt a bit b via the triple (f (x); r; ) where = b (x fi r) with r a random string, x 2 Dom (f ), and fi denoting the inner-product mod 2. <p> A full description and proof follow. We may assume wlog that there is a polynomial l (k) such that Range (f ) f0; 1g l (k) for all f 2 [F k ] and all k 2 N. We now describe how to use the Goldreich-Levin inner-product construction <ref> [GoLe] </ref> to build P = fP k g k2N . <p> Claim 4.2 P is an unapproximable trapdoor predicate family, with decryption error at most (1=2) 1=[2Q (k)]. Proof: We know that F is one-way. Thus, the inner product is a hardcore bit for F <ref> [GoLe] </ref>. This implies that P is unapproximable. <p> It is known that the existence of unapproximable trapdoor predicates is equivalent to the existence of semantically secure public-key encryption [GoMi]. It is also known that injective trapdoor one-way functions can be used to construct unapproximable trapdoor predicates [Ya] (see also <ref> [GoLe] </ref>). In this section, we ask whether the converse is true: Question 5.1 Can unapproximable trapdoor predicates be used to construct injective trapdoor one-way functions? Note the importance of the injectiveness condition in Question 5.1.
Reference: [GoMi] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic Encryption. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 28, </volume> <month> April </month> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference-contexts: Indeed, the understanding is that the problem of building public key cryptosystems is the problem of "making trapdoors." Is it really? It is well known that injective (ie. one-to-one) trapdoor functions suffice for public key cryptography <ref> [Ya, GoMi] </ref>. <p> Amongst these are that "trapdoor one-way functions" are not necessarily hard to build, and their relation to public key encryption is more subtle than it might seem. 1.1 Background The main notions discussed and related in this paper are one-way functions [DiHe], trapdoor (one-way) functions [DiHe], semantically secure encryption schemes <ref> [GoMi] </ref>, and unapproximable trapdoor predicates [GoMi]. <p> one-way functions" are not necessarily hard to build, and their relation to public key encryption is more subtle than it might seem. 1.1 Background The main notions discussed and related in this paper are one-way functions [DiHe], trapdoor (one-way) functions [DiHe], semantically secure encryption schemes <ref> [GoMi] </ref>, and unapproximable trapdoor predicates [GoMi]. <p> Unapproximable trapdoor predicates are equivalent to semantically secure public key schemes for encrypting a single bit, and these in turn are equivalent to general semantically secure cryptosystems <ref> [GoMi] </ref>. 1.2 Results We have three main results. They are displayed in Figure 1 together with known relations. We now discuss them. 3 in the random oracle model. One-way functions imply trapdoor functions. <p> From trapdoor predicates to trapdoor functions. We then turn to the other side of the coin and ask what kinds of trapdoor functions must necessarily exist to have a public key cryptosystem. Since unapproximable trapdoor predicates and semantically secure public key cryptosystems are equivalent <ref> [GoMi] </ref> we consider the question of whether unapproximable trapdoor predicates imply injective trapdoor functions. <p> The significance and interpretation of Theorem 5.2, however, requires a bit more discussion. At first glance, it may seem that public key cryptosystems "obviously imply" injective trapdoor functions. After all, a public key cryptosystem permits unique decryptability; doesn't this mean the encryption algorithm is injective? No, because, as per <ref> [GoMi] </ref>, it is a probabilistic algorithm, and thus not a function. <p> It is now understood that secure encryption must be probabilistic <ref> [GoMi] </ref>.) Theorem 5.2 has several corollaries. (Caveat: All in the random oracle model). First, by applying a transformation of [BeRo], it follows that we can construct non-malleable and chosen-ciphertext secure encryption schemes based on the Ajtai-Dwork cryptosystem [AjDw]. <p> However, for trapdoor functions, one must talk of families. To maintain consistency, we use the family view of one-way functions as well. 2.2 Trapdoor Predicate Families We define unapproximable trapdoor predicate families <ref> [GoMi] </ref>. Recall that such a family is equiv alent to a semantically secure public-key encryption scheme for a single bit [GoMi]. <p> To maintain consistency, we use the family view of one-way functions as well. 2.2 Trapdoor Predicate Families We define unapproximable trapdoor predicate families <ref> [GoMi] </ref>. Recall that such a family is equiv alent to a semantically secure public-key encryption scheme for a single bit [GoMi]. A predicate in our context means a probabilistic function with domain f0; 1g, meaning a predicate p takes a bit b and flips coins r to generate some output y = p (b; r). <p> Theorem 4.1 extends the well-known result of <ref> [Ya, GoMi] </ref> that injective trapdoor functions yield semantically secure public-key cryptosystems, by showing that the injectivity requirement can be relaxed. <p> It outputs b 0 which is 1 if the majority of the values b 0 1 ; : : : ; b 0 q (k) are 1, and 0 otherwise. Chernoff bounds show that DecErr P q (P q -Inv; k) e k . Furthermore standard "hybrid"arguments <ref> [GoMi, Ya] </ref> show that P q inherits the unapproximability of P . This concludes the proof of Theorem 4.1. <p> It is known that the existence of unapproximable trapdoor predicates is equivalent to the existence of semantically secure public-key encryption <ref> [GoMi] </ref>. It is also known that injective trapdoor one-way functions can be used to construct unapproximable trapdoor predicates [Ya] (see also [GoLe]).
Reference: [GNW] <author> O. Goldreich, N. Nisan, and A. Wigderson. </author> <title> On Yao's XOR Lemma. </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <address> TR95-050. </address> <month> March </month> <year> 1995. </year> <note> http://www.eccc.uni-trier.de/eccc/ </note>
Reference-contexts: Claim 5.8 For every PPT A, the probability that z = b 1 b k in Experiment 5.7 is a negligible function of k. Claim 5.8 follows from standard direct product arguments <ref> [Ya, GNW] </ref>. Specifically, Claim 5.8 is a special case of the uniform complexity version of the Concatenation Lemma in [GNW, Lemma 10]. <p> Claim 5.8 follows from standard direct product arguments [Ya, GNW]. Specifically, Claim 5.8 is a special case of the uniform complexity version of the Concatenation Lemma in <ref> [GNW, Lemma 10] </ref>. Claim 5.9 For every PPT A, the probability that O is queried at point b 1 b k during the execution of A O (1 k ; p; x) in Step 6 of Experiment 5.7 is a negligible function of k.
Reference: [HILL] <author> J. H -astad, R. Impagliazzo, L. Levin and M. Luby. </author> <title> Construction of a pseudo-random generator from any one-way function. </title> <type> Manuscript. </type> <note> Earlier versions in STOC 89 and STOC 90. </note>
Reference: [ImLu] <author> R. Impagliazzo and M. Luby. </author> <title> One-way Functions are Essential for Complexity-Based Cryptography. </title> <booktitle> Proceedings of the 30th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1989. </year>
Reference-contexts: We already know that non-injective trapdoor functions can be constructed from trapdoor predicates (whether the latter are injective or not) because trapdoor predicates imply one-way functions <ref> [ImLu] </ref> which in turn imply trapdoor functions by Theorem 3.1. We suggest a construction which requires an additional "random looking" function G and prove that the scheme is secure when G is implemented as a random oracle (to which the adversary also has access). <p> Hence, IF it is possible to implement using one-way functions a function G with "sufficiently strong randomness properties" to maintain the security of this scheme, then Question 5.1 would have a positive answer (as one-way functions can be constructed from unapproximable trapdoor predicates <ref> [ImLu] </ref>). 12 The key difference between trapdoor functions and trapdoor predicates is that predicates are probabilistic, in that their evaluation is a probabilistic process. Hence, our construction is essentially a de-randomization process.
Reference: [ImRu] <author> R. Impagliazzo and S. Rudich. </author> <title> Limits on the provable consequences of one-way permutations. </title> <booktitle> Proceedings of the 21st Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Thus the "curtain" between one-way and trapdoor primitives is not quite as opaque as it may seem. What does this mean for public key cryptography? Impagliazzo and Rudich <ref> [ImRu] </ref> show that it would be very hard, or unlikely, to get a proof that one-way functions (even if injective) imply public key cryptosystems. Hence, our result shows that it is unlikely that any known technique can be used to construct public key encryption schemes from generic, non-injective, trapdoor functions. <p> Hence, our result shows that it is unlikely that any known technique can be used to construct public key encryption schemes from generic, non-injective, trapdoor functions. As one might guess given <ref> [ImRu] </ref>, our construction does not preserve injectivity, so even if the starting one-way function is injective, the resulting trapdoor one-way function is not. Trapdoor functions with poly pre-image size yield cryptosystems. <p> not only an open question, but seems a hard one. (In particular, a positive answer would imply injective trapdoor functions based on the Diffie-Hellman assumption, a long standing open problem.) In order to get some insight and possible approaches to it, we consider it in a random oracle model (cf. <ref> [ImRu, BeRo] </ref>). Theorem 5.2 says that here the answer is affirmative: given an arbitrary secure public key cryptosystem, we present a function that has access to an oracle H, and prove the function is injective, trapdoor, and one-way when H is random. <p> However, random oracles do not directly or naturally give rise to trapdoors <ref> [ImRu] </ref>. <p> Another interpretation of Theorem 5.2 is as a demonstration that there exists a model in which semantically secure encryption implies injective trapdoor functions, and hence it may be hard 5 to prove a separation result, in the style of <ref> [ImRu] </ref>, between injective trapdoor functions and probabilistic encryption schemes. 2 Definitions We present definitions for one-way functions, trapdoor functions, and unapproximable trapdoor predicates. Preliminaries. <p> Thus, adding regularity as a requirement is not likely to suffice for making public-key cryptosystems. 4 From trapdoor functions to cryptosystems Theorem 3.1 coupled with <ref> [ImRu] </ref> says that it is unlikely that general trapdoor functions will yield semantically secure public-key cryptosystems. However, in our construction of Section 3.1 the resulting trapdoor function was "very non-injective" in the sense that the pre-image size was exponential in the security parameter. <p> Theorem 4.1 extends the well-known result of [Ya, GoMi] that injective trapdoor functions yield semantically secure public-key cryptosystems, by showing that the injectivity requirement can be relaxed. Coupled with <ref> [ImRu] </ref> this also implies that it is unlikely that the analogue of Theorem 3.1 can be shown for trapdoor functions with polynomially bounded pre-image sizes. 4.1 Proof of Theorem 4.1 Let F = fF k g k2N be a family of trapdoor one-way functions with pre-image size bounded by a polynomial
Reference: [NaYu] <author> M. Naor and M. Yung. </author> <title> Public-Key Cryptosystems Provably Secure against Chosen Ciphertext Attacks. </title> <booktitle> Proceedings of the 22nd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference: [Rab] <author> M. Rabin. </author> <title> Digitalized Signatures and Public Key Functions as Intractable as Factoring. </title> <address> MIT/LCS/TR-212, </address> <year> 1979. </year>
Reference-contexts: A family of trapdoor functions is said to be one-way if it is also a family of one-way functions. Example 2.1 [The Rabin family of trapdoor functions] The Rabin family <ref> [Rab] </ref> is a good example in our setting since it consists of non-injective trapdoor functions. It is captured as follows. We set Rab = f Rab N : N 2 Rab-Keys g, where Rab-Keys is the set of all numbers which are the product of two primes.
Reference: [Ya] <author> A. Yao. </author> <title> Theory and applications of trapdoor functions. </title> <booktitle> Proceedings of the 23rd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1982. </year>
Reference-contexts: Indeed, the understanding is that the problem of building public key cryptosystems is the problem of "making trapdoors." Is it really? It is well known that injective (ie. one-to-one) trapdoor functions suffice for public key cryptography <ref> [Ya, GoMi] </ref>. <p> The construction of Theorem 5.2 is quite simple, and the natural next question is whether the random oracle H can be replaced by some constructible cryptographic primitive. We show that this may be difficult, by showing that a cryptographically strong pseudorandom bit generator <ref> [BlMi, Ya] </ref>, which seems like a natural choice for this construction, does not suffice. (See Appendix A). <p> Theorem 4.1 extends the well-known result of <ref> [Ya, GoMi] </ref> that injective trapdoor functions yield semantically secure public-key cryptosystems, by showing that the injectivity requirement can be relaxed. <p> It outputs b 0 which is 1 if the majority of the values b 0 1 ; : : : ; b 0 q (k) are 1, and 0 otherwise. Chernoff bounds show that DecErr P q (P q -Inv; k) e k . Furthermore standard "hybrid"arguments <ref> [GoMi, Ya] </ref> show that P q inherits the unapproximability of P . This concludes the proof of Theorem 4.1. <p> It is known that the existence of unapproximable trapdoor predicates is equivalent to the existence of semantically secure public-key encryption [GoMi]. It is also known that injective trapdoor one-way functions can be used to construct unapproximable trapdoor predicates <ref> [Ya] </ref> (see also [GoLe]). In this section, we ask whether the converse is true: Question 5.1 Can unapproximable trapdoor predicates be used to construct injective trapdoor one-way functions? Note the importance of the injectiveness condition in Question 5.1. <p> Standard direct product arguments <ref> [Ya] </ref> imply that F constructed in this manner is one-way. However, F may fail to be trapdoor; the trapdoor information associated with p only allows one to recover b 1 ; : : : ; b k , but not r 1 ; : : : ; r k . <p> Claim 5.8 For every PPT A, the probability that z = b 1 b k in Experiment 5.7 is a negligible function of k. Claim 5.8 follows from standard direct product arguments <ref> [Ya, GNW] </ref>. Specifically, Claim 5.8 is a special case of the uniform complexity version of the Concatenation Lemma in [GNW, Lemma 10].
References-found: 20

