URL: http://www.cs.umn.edu/Users/mirrors01/sup.netbsd.org/NetBSD-current/src/usr.sbin/named/doc/misc/purdue-thesis.ps
Refering-URL: http://www.cs.umn.edu/Users/mirrors01/sup.netbsd.org/NetBSD-current/src/usr.sbin/named/doc/misc/
Root-URL: http://www.cs.umn.edu
Email: fschuba,spafg@cs.purdue.edu  
Title: Addressing Weaknesses in the Domain Name System Protocol  
Author: Christoph L. Schuba and Eugene H. Spafford 
Address: West Lafayette, IN 47907-1398  
Affiliation: COAST Laboratory Department of Computer Sciences Purdue University  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 85 BIBLIOGRAPHY </institution>
Reference: [AL92] <author> Paul Albitz and Cricket Liu. </author> <title> DNS and BIND. </title> <publisher> O'Reilley & Associates, Inc. </publisher> <address> Sebastopol, CA., </address> <year> 1992. </year>
Reference: [Bel89] <author> Steven M. Bellovin. </author> <title> Security Problems in the TCP/IP Protocol Suite. </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: addresses cannot be trusted fully, no one can rely on an authentication process on a high level. 3.2 The Problem in the DNS Many security problems of the TCP/IP protocol suite rely on the ability of the attacker to spoof the IP address of a trusted machine, as described in <ref> [Bel89] </ref>.
Reference: [Bel90a] <author> Steven M. Bellovin. </author> <title> Pseudo-Network Drivers and Virtual Networks. </title> <booktitle> In Proc. Winter USENIX Conference, </booktitle> <pages> pages 229-244, </pages> <address> Washington, D.C., </address> <year> 1990. </year>
Reference: [Bel90b] <author> Steven M. Bellovin. </author> <title> Using the Domain Name System for System Break-ins. </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <year> 1990. </year> <note> (unpublished technical report). </note>
Reference-contexts: We are not discussing random patterns of trust that might exist between hosts, but two common patterns using a systematic approach. The following discussion is based on section 3 in <ref> [Bel90b] </ref>. In a cluster of time-sharing machines, each machine is likely to extend trust to all its peers. This pattern is not common to the general user population, but it is applicable to systems programming and operational staff.
Reference: [Bel92] <author> Steven M. Bellovin. </author> <title> There Be Dragons. </title> <booktitle> In UNIX Security Symposium III Proceedings, </booktitle> <pages> pages 1-16, </pages> <address> Baltimore, MD, </address> <year> 1992. </year>
Reference-contexts: The idea is to validate the inverse mapping tree by looking at the corresponding node on the forward mapping tree. S. Bellovin describes the method used by the patch in <ref> [Bel92] </ref> as follows: "To detect 62 this, we perform a cross-check; using the returned name, we do a forward check to learn the legal address for that host.
Reference: [BG92] <author> Dimitri Bertsekas and Robert Gallager. </author> <title> Data Networks. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1992. </year>
Reference: [CD88] <author> George F. Coulouris and Jean Dollimore. </author> <title> Distributed Systems. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference: [Com91] <author> Douglas E. Comer. </author> <title> Internetworking with TCP/IP. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1991. </year>
Reference: [Den82] <author> Dorothy E. Denning. </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1982. </year>
Reference-contexts: Data encrypted with a sender's private key can be decrypted using his public key, and vice versa. These keys are usually large integer numbers, several hundred decimal digits long with special, mathematical properties. (ex. <ref> [Den82] </ref>). "RSA" is an example of a public key encryption algorithm ([RSA78]). 76 The following procedure and Figure 4.2 outline how we would use the public key cryptoalgorithm to ensure originator authentication.
Reference: [DK84] <author> Kevin J. Dunlap and Michael J. Karels. </author> <title> Name Server Operations Guide for BIND, Release 4.8. </title> <institution> University of California, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1984. </year>
Reference: [DOK92] <author> Peter B. Danzig, Katia Obraczka, and Anant Kumar. </author> <title> An Analysis of Wide-Area Name Server Traffic. </title> <journal> Computer Communications Review, </journal> <volume> 22(4) </volume> <pages> 281-92, </pages> <month> October </month> <year> 1992. </year>
Reference: [GS91] <author> Simson Garfinkel and Gene Spafford. </author> <title> Practical UNIX Security. </title> <publisher> O'Reilley & Associates, Inc. </publisher> <address> Sebastopol, CA., </address> <year> 1991. </year> <month> 86 </month>
Reference: [Hun92] <author> Craig Hunt. </author> <title> TCP/IP Network Administration. </title> <publisher> O'Reilley & Associates, Inc. </publisher> <address> Sebastopol, CA., </address> <year> 1992. </year>
Reference: [Kal92] <author> Burton S. Kaliski. </author> <title> RFC-1319 The MD2 Message-Digest Algorithm. </title> <institution> Network Working Group, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: They are one-way hash functions that compute a checksum of some data (in our case the DNS message | see Figure 4.1). They have the following features: 75 * they are easy to compute (examples are the MD2, MD4, and MD5 algorithms in <ref> [Kal92, Riv92a, Riv92b] </ref> and the Snefru algorithm in [Mer89]) * the signature (message digest or fingerprint) is only a few bytes per message * they are computationally hard to invert * they usually require a certain size of input data An originator would calculate the message digest of a DNS message
Reference: [Ken93a] <author> Stephen T. Kent. </author> <title> Internet Privacy Enhanced Mail. </title> <journal> Communications of the ACM, </journal> <volume> 36(8) </volume> <pages> 48-59, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: elaborate on these three features and present techniques and ideas for their possible implementation. 4.11.1 Data Integrity Integrity service means that a recipient is provided with assurance that the content of a received message is identical to the content of a message (including its header) sent by its originator (see <ref> [Ken93a] </ref>). In our case, we want to ensure the integrity of transmitted DNS messages. There are several approaches to protect a message against unauthorized change: prevention techniques, avoidance techniques, and detection and recovery techniques. All these techniques have inherent advantages and disadvantages.
Reference: [Ken93b] <author> Stephen T. Kent. </author> <title> RFC-1422 Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management. </title> <institution> Network Working Group, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Obtaining memory for them, as well as additional cache memory for larger resource records, is not a problem in current architectures. The keys have to be obtained before they can be used. S. Kent describes in <ref> [Ken93b] </ref> certificate based key management; X.509 is the equivalent in the OSI 2 -world. We will not go into detail regarding the key distribution process. The registering process is rather cumbersome.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> Programmieren in C. </title> <type> Carl Hanser Verlag Munchen Wien, </type> <note> second edition, </note> <year> 1988. </year>
Reference: [Lot93] <author> Mark Lottor. </author> <title> Internet Domain Survey Apr 93. </title> <booktitle> SRI International, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: HOSTS.TXT was abandoned because 200,000 hosts was too much to be managed. Are currently about 1.5 million (see <ref> [Lot93] </ref>) easier to handle? Certainly not. Overall, abandoning the Domain Name System would drag the name resolution task in the Internet out of a functioning state with a not easily exploitable security breach, into an unmanageable, not working state of prehistoric system design.
Reference: [LR93] <author> Daniel C. Lynch and Marshall T. Rose. </author> <title> Internet System Handbook. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1993. </year>
Reference: [Mad92] <author> Jtrgen Bo Madsen. </author> <title> The greatest cracker-case in Denmark: The detecting, tracing and arresting of two international crackers. </title> <booktitle> In UNIX Security Symposium III Proceedings, </booktitle> <pages> pages 17-40, </pages> <address> Baltimore, MD, </address> <year> 1992. </year>
Reference-contexts: It is not much easier for an attacker to satisfy this second assumption than the first one. The control must include the associated inverse mapping tree. The attacker might have successfully subverted such a machine or simply be a renegade system administrator. Both have happened in the past (i.e. <ref> [Sto89, Mad92] </ref>). We can relax this assumption further.
Reference: [Mer89] <author> Ralph C. </author> <type> Merkle. </type> <institution> Snefru. Xerox Corporation, </institution> <address> Palo Alto, CA, </address> <year> 1989. </year>
Reference-contexts: They have the following features: 75 * they are easy to compute (examples are the MD2, MD4, and MD5 algorithms in [Kal92, Riv92a, Riv92b] and the Snefru algorithm in <ref> [Mer89] </ref>) * the signature (message digest or fingerprint) is only a few bytes per message * they are computationally hard to invert * they usually require a certain size of input data An originator would calculate the message digest of a DNS message immediately before it is sent out.
Reference: [Moc83a] <author> Paul Mockapetris. </author> <title> RFC-882 Domain Names Concepts and Facilities. </title> <institution> Network Working Group, </institution> <month> November </month> <year> 1983. </year>
Reference: [Moc83b] <author> Paul Mockapetris. </author> <title> RFC-883 Domain Names Implementation and Specification. </title> <institution> Network Working Group, </institution> <month> November </month> <year> 1983. </year>
Reference: [Moc87a] <author> Paul Mockapetris. </author> <title> RFC-1034 Domain Names Concepts and Facilities. </title> <institution> Network Working Group, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: Therefore, each resource record contains a time to live field which ensures that name servers do not cache data without time bound. The actual algorithm name servers use depends on the local operating system and data structures used to store resource records. A basic outline can be found in <ref> [Moc87a, section 4.3.2] </ref> and in section 2.9.2 of this thesis. 2.4.5 Resolvers The interface between the Domain Name System and user programs is the name resolver. <p> To obtain higher efficiency, it is reasonable to have all resolvers on one machine share their cache. An algorithm outline for the resolver can be found in <ref> [Moc87a, section 5.3.3] </ref> and in section 2.9.3 of this thesis. 2.5 Forward and Inverse Mapping Tree The Domain Name Space consists of a hierarchy of domain names. <p> C 4 A queries C 5 C refers A to other name servers, incl. D 6 A queries D 7 D answers 8 D returns the answer to the resolver 2.9 The Domain Name System Protocol The official design documents <ref> [Moc87a] </ref> and [Moc87b] state and describe concepts and facilities, implementation and specification. In the following sections, we will discuss topics related to the data structures and data organization, and present the name server and the resolver algorithm on a fairly high level. <p> The algorithms of the name server and the resolver assume an organization of the data as described in the previous section: several tree structures, one for each zone. In the following presentation of the algorithm we stay close to the outline specified in <ref> [Moc87a] </ref>. 1. Set or clear the RA bit in the response depending on whether the name server is willing to provide recursive service. If recursive service is available and requested via the RD bit in the query, branch to step 5, otherwise step 2. 2. <p> As soon as a reply returns, it checks for answer, name error, delegation, canonical name expansion, or failure of the server and reacts properly. The following steps describe the algorithm in more detail. They are derived from <ref> [Moc87a] </ref>: 1. See if the answer to the query is in the local information, and if so, return it to the client. 2. Find the best servers to ask. 3. Send them queries until one returns a response. 4. <p> A similar attack is based on the fact that the standard for the DNS implicitly determines that the first answer a resolver receives to a query is returned to the user program. The standard states in <ref> [Moc87a] </ref> : "Get the answer as quickly as possible". If a query is answered by more than one host (and one of the hosts supplying an answer can be the attacker who has intercepted the query, like in the previously described problem) the fastest answer wins.
Reference: [Moc87b] <author> Paul Mockapetris. </author> <title> RFC-1035 Domain Names Implementation and Specification. </title> <institution> Network Working Group, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: C 4 A queries C 5 C refers A to other name servers, incl. D 6 A queries D 7 D answers 8 D returns the answer to the resolver 2.9 The Domain Name System Protocol The official design documents [Moc87a] and <ref> [Moc87b] </ref> state and describe concepts and facilities, implementation and specification. In the following sections, we will discuss topics related to the data structures and data organization, and present the name server and the resolver algorithm on a fairly high level. <p> We describe two more problems in this section. Imagine again the scenario we described in the previous section, where the originator of a query receives more than one response and one of the responses contains false information supplied by an attacker. The standard states in <ref> [Moc87b, 7.4] </ref> "When several RRs of the same type are available for a particular owner name, the resolver should either cache them all or none at all." The fact that the responses come from different IP addresses, does not matter to the originator. <p> The standard states in [Moc87b, 7.4] "When several RRs of the same type are available for a particular owner name, the resolver should either cache them all or none at all." The fact that the responses come from different IP addresses, does not matter to the originator. In <ref> [Moc87b] </ref> the standard deals with the fact that name servers are sometimes multi-homed hosts and respond to queries using another network interface than where the query arrived.
Reference: [Moc89] <author> Paul Mockapetris. </author> <title> RFC-1123 Requirements for Internet Hosts - Application and Support. </title> <institution> Network Working Group, </institution> <year> 1989. </year>
Reference: [Mor85] <author> R. T. Morris. </author> <title> A Weakness in the 4.2BSD UNIX TCP/IP Software. </title> <note> Computing Science Technical Report No. 117, </note> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <month> February </month> <year> 1985. </year> <month> 87 </month>
Reference-contexts: An attack based on TCP sequence number prediction to construct a TCP packet sequence that allows an attacker to spoof a trusted host's identity on a local 39 network was described in <ref> [Mor85] </ref>. This example shows the feasibility of ID number prediction. In the following discussion we will assume that the attacker has indeed superuser access to a primary name server. <p> This would not solve the problem, because the problem is not the DNS, but inadequate methods of host authentication. IP addresses of trusted machines could still be imitated. This is a somewhat harder task, but the know-how has been published for quite some time (see <ref> [Mor85] </ref>). Would it be safer to transmit updates to a central site? Email, telephone calls, or conventional paper are not necessarily a reliable way to transmit mapping information updates. <p> The name server that was originally addressed, or its network connection, can be manipulated by the attacker in a way that they either not receive any query at all, or that their response gets lost (see <ref> [Mor85] </ref> for an example). A similar attack is based on the fact that the standard for the DNS implicitly determines that the first answer a resolver receives to a query is returned to the user program. The standard states in [Moc87a] : "Get the answer as quickly as possible".
Reference: [Par91] <author> T. A. Parker. </author> <title> A Secure System for Applications in a Multi-vendor Environment (The SESAME project). </title> <booktitle> In 14 th NCSC Conference Proceedings, 1991. </booktitle> <volume> Vol. II. </volume>
Reference: [PL91] <author> R. Paans and H. de Lange. </author> <title> Auditing the SNA/SNI Environment. </title> <journal> Computer & Security, </journal> <volume> 10(3) </volume> <pages> 251-61, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: This authentication is usually based on the verification of the user's login name along with the associated password and the host name of the machine on which the user starts his requests. Networks may be classified into different partitions 1 : Closed Networks, Open Networks, and Trusted Networks <ref> [PL91] </ref>. Closed Networks can be accessed only within certain boundaries. Sessions are controlled and secured in accordance with the rules implied by an organization's business goals. In a Closed Network, the location of all resources is well known and specified.
Reference: [Riv92a] <author> Ronald L. Rivest. </author> <title> RFC-1320 The MD4 Message-Digest Algorithm. </title> <institution> Network Working Group, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: They are one-way hash functions that compute a checksum of some data (in our case the DNS message | see Figure 4.1). They have the following features: 75 * they are easy to compute (examples are the MD2, MD4, and MD5 algorithms in <ref> [Kal92, Riv92a, Riv92b] </ref> and the Snefru algorithm in [Mer89]) * the signature (message digest or fingerprint) is only a few bytes per message * they are computationally hard to invert * they usually require a certain size of input data An originator would calculate the message digest of a DNS message
Reference: [Riv92b] <author> Ronald L. Rivest. </author> <title> RFC-1321 The MD5 Message-Digest Algorithm. </title> <institution> Network Working Group, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: They are one-way hash functions that compute a checksum of some data (in our case the DNS message | see Figure 4.1). They have the following features: 75 * they are easy to compute (examples are the MD2, MD4, and MD5 algorithms in <ref> [Kal92, Riv92a, Riv92b] </ref> and the Snefru algorithm in [Mer89]) * the signature (message digest or fingerprint) is only a few bytes per message * they are computationally hard to invert * they usually require a certain size of input data An originator would calculate the message digest of a DNS message
Reference: [RSA78] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A Method for Obtaining Digital Signatures and Public Key Cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-6, </pages> <month> February </month> <year> 1978. </year>
Reference: [SNS88] <author> J.G. Steiner, C. Neuman, and J.I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> In Proceedings, Winter USENIX, </booktitle> <address> Dal-las, Texas, </address> <year> 1988. </year>
Reference: [Spa88] <author> Eugene H. Spafford. </author> <title> The Internet Worm Program: An Analysis. </title> <type> Technical Report CSD-TR-823, </type> <institution> Purdue University, West Lafayette, IN, </institution> <year> 1988. </year>
Reference: [Ste90] <author> Richard W. Stevens. </author> <title> UNIX Network Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: In our setup, host NS A trusts host H A via the file "/etc/hosts.equiv" containing host H A 's host name. 47 3.5.4 Authentication in Berkeley "r-Commands" The main two "r-command" applications we deal with are "rlogin" and "rsh," both of which consist of a client and a server side. <ref> [Ste90, Chapter 14] </ref> gives an overview of remote command execution under UNIX and [Ste90, Chapter 15] gives many details about the remote login procedure. Examining the source code for the client "rlogin" and the server "rlogind" yields the following security check procedure: 1. <p> "/etc/hosts.equiv" containing host H A 's host name. 47 3.5.4 Authentication in Berkeley "r-Commands" The main two "r-command" applications we deal with are "rlogin" and "rsh," both of which consist of a client and a server side. [Ste90, Chapter 14] gives an overview of remote command execution under UNIX and <ref> [Ste90, Chapter 15] </ref> gives many details about the remote login procedure. Examining the source code for the client "rlogin" and the server "rlogind" yields the following security check procedure: 1. Check if the client uses a reserved TCP port. Abort if not. 2.
Reference: [Sto89] <author> Clifford P. Stoll. </author> <title> The Cuckoo's Egg: Tracing a Spy Through the Maze of Computer Espionage. </title> <publisher> Doubleday, </publisher> <year> 1989. </year>
Reference-contexts: It is not much easier for an attacker to satisfy this second assumption than the first one. The control must include the associated inverse mapping tree. The attacker might have successfully subverted such a machine or simply be a renegade system administrator. Both have happened in the past (i.e. <ref> [Sto89, Mad92] </ref>). We can relax this assumption further.
Reference: [Sun91] <author> Sun Microsystems. </author> <title> manual pages, </title> <address> 4.1 edition, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: It is also possible to force remote users to always supply a password when using the "r-commands," by prefixing entries in ".rhosts" by a dash. These files bypass the standard password-based user authentication mech anism. To maintain system security, care must be taken in creating and maintaining these files. <ref> [Sun91, HOSTS.EQUIV (5)] </ref> These features have caused many security breaches in the past, but still most system administrators do not disable them. Trust in networks is a transitive relation, in the sense that if A trusts B, and B trusts C, then A trusts C.
Reference: [Tan92] <author> Andrew S. Tanenbaum. </author> <title> Modern Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference: [Tho84] <author> Ken Thompson. </author> <title> Reflections on Trusting Trust. </title> <journal> Communications of the ACM, </journal> <volume> 27(8) </volume> <pages> 761-3, </pages> <month> August </month> <year> 1984. </year>
References-found: 40

