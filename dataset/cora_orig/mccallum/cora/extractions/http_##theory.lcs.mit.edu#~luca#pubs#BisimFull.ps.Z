URL: http://theory.lcs.mit.edu/~luca/pubs/BisimFull.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~luca/papers.html
Root-URL: 
Email: Email: fmichele,trevisang@dsi.uniroma1.it  Email: michele@dsi.uniroma1.it  
Title: A Complexity Analysis of Bisimilarity for Value-Passing Processes  
Author: Michele Boreale and Luca Trevisan Michele Boreale 
Note: Corresponding author:  
Date: February 8, 1996  
Address: Via Salaria 113, 00198 Roma  Via Salaria 113, 00198 Roma, Italy  
Affiliation: Dipartimento di Scienze dell'Informazione Universita di Roma "La Sapienza"  Dipartimento di Scienze dell'Informazione Universita degli Studi di Roma "La Sapienza"  
Abstract: We study the complexity of deciding bisimilarity between non-deterministic processes with explicit primitives for manipulating data values. In particular, we consider a language with value-passing (input/output of data) and parametric definitions of processes. We distinguish the case in which data cannot be tested and the case in which a simple equality test over data is permitted. In the first case, our main result shows that the problem is PSPACE-hard for the full calculus. In the second case, we first show that the problem is coNP-complete in the fragment with value-passing and no parametric definitions. We then define a compositional polynomial-time translation of the full calculus to the fragment with parametric definitions but no value-passing. The translation preserves bisimilarity: this fact establishes the decidability of the full calculus and shows that the fragment without value-passing is computationally equivalent to the full calculus. For the latter, bisimilarity is then proved to be EXP-complete. Finally, we add to our language a parallel composition operator and show that, for a certain fl An extended abstract of part of the material contained in this paper appears in the Proceedings of 15th Conference on Software Technology and Theoretical Computer Science (FSTTCS95), published by Springer Verlag. restricted syntactic format, the bisimilarity problem is still decidable and EXP-complete.
Abstract-found: 1
Intro-found: 1
Reference: [BC93] <author> D.P. Bovet and P. Crescenzi. </author> <title> Introduction to the Theory of Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Then we asses the decidability and the difference in complexity of these languages. In this analysis, we refer to the complexity classes NP, coNP, PSPACE and EXP (the latter contains the first three and PSPACE contains the first two, see e.g. <ref> [BC93] </ref>). In the data-independent regime, we first note that the bisimilarity problem is solvable in polynomial time for the calculi allowing either, but not both, of recursive definitions or value-passing. For the calculus allowing both these primitives, we then prove that the problem is PSPACE-hard. <p> It is easy to show that a problem is LIN-EXP-hard if and only if it is EXP-hard. See e.g. <ref> [BC93, Pap94] </ref> for a more complete introduction to complexity classes. Here we recall the following result due to Hartmanis and Stearns that states the provable intractability of LIN-EXP-hard problem.
Reference: [BD94] <author> M. Boreale and R. De Nicola. </author> <title> A symbolic semantics for the -calculus- Extended abstract. </title> <editor> In B. Jonsson and J. Parrow, editors, </editor> <booktitle> Proceedings of Concur '94, </booktitle> <volume> LNCS 836, </volume> <pages> pages 299-314. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year> <note> Full version to appear in Information and Computation. </note>
Reference-contexts: The algebraic aspects of this problem are becoming now well-understood, also for value-passing processes <ref> [HL93, PS95, BD94] </ref>. On the contrary, a lot of questions concerning the decidability and the computational complexity of verification remain unanswered. A basic problem is to determine meaningful fragments of the calculi with values over which the verification problem is decidable. <p> It would be interesting to find, in the spirit of the translation from L m;v;r;p to L m;r;p , a compositional reduction from L m;r;p to L m;r that would show how to "express" the parallel composition operator using the other operators. In <ref> [HL95, HL93, San93, BD94] </ref>, notions of symbolic bisimulation are investigated for both CCS with value-passing and -calculus, aiming at a more efficient representation of bisimilarity. Our results show that, even for very simple fragments, it is very unlikely that efficient algorithms exist.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: In this paper we shall only consider time-bounded ATM's, that is, machines having a finite computation tree for any input. Acceptance is defined in a quite involved way for general ATM's (see <ref> [CKS81] </ref>). In the case of timed bounded ATM's, however, a much simpler inductive definition can be given. Definition 2.5 (Acceptance) Let AT be a time-bounded ATM, x be a string, c 2 GC AT (x) be a configuration. 1.
Reference: [Coo71] <author> S.A. Cook. </author> <title> The complexity of theorem proving procedures. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: Then we will show that it belongs to the class coNP. The 3-Tautology problem consists in testing whether a given formula in 3DNF (see the preceding section) is a tautology or not. From the results of <ref> [Coo71] </ref> it follows that any problem in coNP is polynomial-time reducible to 3-Tautology, that is, the 3-Tautology problem is coNP-hard. Theorem 5.1 The bisimilarity problem in L m;v is coNP-hard.
Reference: [HL93] <author> M. Hennessy and H. Lin. </author> <title> Proof systems for message-passing process algebras. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR '93, </booktitle> <publisher> LNCS 715. Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in process calculi with explicit primitives to manipulate data values. In particular, several enriched versions of Milner's CCS <ref> [Mil80, Mil89, JP93, HL95, HL93] </ref> have been studied. In pure, i.e. data-less, process calculi such as CCS, beside standard operators for describing behaviours of processes (such as non-determinism + and parallel composition j) only pure-synchronization actions (also called "pure" actions) are provided. <p> The algebraic aspects of this problem are becoming now well-understood, also for value-passing processes <ref> [HL93, PS95, BD94] </ref>. On the contrary, a lot of questions concerning the decidability and the computational complexity of verification remain unanswered. A basic problem is to determine meaningful fragments of the calculi with values over which the verification problem is decidable. <p> It would be interesting to find, in the spirit of the translation from L m;v;r;p to L m;r;p , a compositional reduction from L m;r;p to L m;r that would show how to "express" the parallel composition operator using the other operators. In <ref> [HL95, HL93, San93, BD94] </ref>, notions of symbolic bisimulation are investigated for both CCS with value-passing and -calculus, aiming at a more efficient representation of bisimilarity. Our results show that, even for very simple fragments, it is very unlikely that efficient algorithms exist.
Reference: [HL95] <author> M. Hennessy and H. Lin. </author> <title> Symbolic bisimulations. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 353-389, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in process calculi with explicit primitives to manipulate data values. In particular, several enriched versions of Milner's CCS <ref> [Mil80, Mil89, JP93, HL95, HL93] </ref> have been studied. In pure, i.e. data-less, process calculi such as CCS, beside standard operators for describing behaviours of processes (such as non-determinism + and parallel composition j) only pure-synchronization actions (also called "pure" actions) are provided. <p> It would be interesting to find, in the spirit of the translation from L m;v;r;p to L m;r;p , a compositional reduction from L m;r;p to L m;r that would show how to "express" the parallel composition operator using the other operators. In <ref> [HL95, HL93, San93, BD94] </ref>, notions of symbolic bisimulation are investigated for both CCS with value-passing and -calculus, aiming at a more efficient representation of bisimilarity. Our results show that, even for very simple fragments, it is very unlikely that efficient algorithms exist.
Reference: [HS65] <author> J. Hartmanis and R.E. Stearns. </author> <title> On the computational complexity of algorithms. </title> <journal> Transactions of the AMS, </journal> <volume> 117 </volume> <pages> 285-306, </pages> <year> 1965. </year>
Reference: [JP93] <author> B. Jonsson and J. Parrow. </author> <title> Deciding bisimulation equivalences for a class of non-finite state programs. </title> <journal> Information and Computation, </journal> <volume> 107 </volume> <pages> 272-302, </pages> <year> 1993. </year> <month> 29 </month>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in process calculi with explicit primitives to manipulate data values. In particular, several enriched versions of Milner's CCS <ref> [Mil80, Mil89, JP93, HL95, HL93] </ref> have been studied. In pure, i.e. data-less, process calculi such as CCS, beside standard operators for describing behaviours of processes (such as non-determinism + and parallel composition j) only pure-synchronization actions (also called "pure" actions) are provided. <p> This is due to the fact that each input action a (x): gives rise to infinitely many actual transitions, one for each different value. In <ref> [JP93] </ref>, Jonsson and Parrow concentrate on a particular class of processes with values, the data independent ones, which cannot test data nor perform any kind of operation over them. They prove that the bisimilarity problem for such processes can be transformed into a bisimilarity problem for finite-state processes. <p> For the latter, decision algorithms exist [PT87, KS90], which are polynomial in the sizes of the involved graphs (that can be however much larger than the syntactical size of the processes). A detailed comparison of our work with <ref> [JP93] </ref> is contained in Section 9. <p> Therefore, in order to establish decidability of bisimilarity in a given language, it suffices to show how to reduce the problem to a bisimilarity problem over finite labeled transition systems. This reduction is shown to be possible for data-independent languages in <ref> [JP93] </ref>. Theorem 4.1 The bisimilarity problems for L v and L r are in P. Proof: From the results of [JP93] it follows that, given two data-independent processes P and Q we can construct two finite labeled transition systems G P and G Q such that P ~ Q if and <p> This reduction is shown to be possible for data-independent languages in <ref> [JP93] </ref>. Theorem 4.1 The bisimilarity problems for L v and L r are in P. Proof: From the results of [JP93] it follows that, given two data-independent processes P and Q we can construct two finite labeled transition systems G P and G Q such that P ~ Q if and only if G P is bisimilar to G Q . <p> The theorem follows from the above considerations and the results of [KS90, PT87]. 2 Let us now consider the complexity of the bisimilarity problem in L v;r . Jonsson and Parrow proved that such a problem is decidable and NP-hard <ref> [JP93] </ref>, we will improve on this result and we will show that the problem is indeed PSPACE-hard. We first need some preliminary definitions in order to introduce quantified boolean formulas. Let U = fx 1 ; : : : ; x n g be a set of boolean variables. <p> Many of the results presented in the paper extend to these equivalences. In particular, both late and open bisimilarity are PSPACE-hard over the data-independent processes, because the three equivalences coincide in this case (see e.g. [PS95]). Our paper is mainly related to <ref> [JP93] </ref>. There, Jonsson and Parrow prove that bisimilarity is decidable in the data-independent language L v;r , by showing that the infinitely many transitions due to an input action can be reduced to a single, suitably chosen, schematic action [JP93]. <p> Our paper is mainly related to <ref> [JP93] </ref>. There, Jonsson and Parrow prove that bisimilarity is decidable in the data-independent language L v;r , by showing that the infinitely many transitions due to an input action can be reduced to a single, suitably chosen, schematic action [JP93]. The latter is characterized as the receipt of the least value (w.r.t. to a fixed ordering of values) not "used" in the considered process. This approach yields the polynomial-time tractability of some restricted cases.
Reference: [KS90] <author> P.C. Kanellakis and S.A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86 </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference-contexts: They prove that the bisimilarity problem for such processes can be transformed into a bisimilarity problem for finite-state processes. For the latter, decision algorithms exist <ref> [PT87, KS90] </ref>, which are polynomial in the sizes of the involved graphs (that can be however much larger than the syntactical size of the processes). A detailed comparison of our work with [JP93] is contained in Section 9. <p> We will first restrict ourselves to the simple value-passing case (i.e. we assume that V ar, V al and Act are pairwise disjoint) and then we will argue how the achieved results extend to the name-passing case. Recall that in <ref> [KS90, PT87] </ref> it has been shown that the bisimilarity problem for finite labeled transition systems can be solved in time polynomial in the sizes of the systems. <p> Under this assumption, it easily follows that any term P has an associated labeled transition system whose size is polynomially bounded in the size of P and Eq. The theorem follows from the above considerations and the results of <ref> [KS90, PT87] </ref>. 2 Let us now consider the complexity of the bisimilarity problem in L v;r . Jonsson and Parrow proved that such a problem is decidable and NP-hard [JP93], we will improve on this result and we will show that the problem is indeed PSPACE-hard.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems. </title> <publisher> LNCS, 92. Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in process calculi with explicit primitives to manipulate data values. In particular, several enriched versions of Milner's CCS <ref> [Mil80, Mil89, JP93, HL95, HL93] </ref> have been studied. In pure, i.e. data-less, process calculi such as CCS, beside standard operators for describing behaviours of processes (such as non-determinism + and parallel composition j) only pure-synchronization actions (also called "pure" actions) are provided. <p> By contrast, process calculi with explicit treatment of data contain primitives for expressing transmission and receipt of values at communication ports: this feature is known as value-passing. Using the notation of <ref> [Mil80] </ref>, output of v at port a is written av:, while input at a is written a (x):; here the variable x acts as a formal parameter. <p> Comparison with related work and conclusive remarks are contained in Section 9. 2 Preliminaries 2.1 The language Below, we present first the syntax and then operational and bisimulation semantics of the language. The notation we use is that of value-passing CCS <ref> [Mil80, Mil89] </ref> and of -calculus [MPW92]. <p> Note that we have not made any assumption on whether the sets V ar, V al and Act are pairwise disjoint or not. We will consider two particularly interesting cases: * Act, V ar and V al are pairwise disjoint. This gives rise to a sublanguage of value-passing CCS <ref> [Mil80, Mil89] </ref> and will be referred to as the simple value-passing case. * Act = V ar = V al. This gives rise to a sublanguage of the -calculus [MPW92] and will be referred to as the name-passing case.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Recently, there has been a renewed interest in process calculi with explicit primitives to manipulate data values. In particular, several enriched versions of Milner's CCS <ref> [Mil80, Mil89, JP93, HL95, HL93] </ref> have been studied. In pure, i.e. data-less, process calculi such as CCS, beside standard operators for describing behaviours of processes (such as non-determinism + and parallel composition j) only pure-synchronization actions (also called "pure" actions) are provided. <p> In the present work, we will try to address some of these issues. We will restrict our attention to one of the most widely studied equivalences, Milner's bisimulation equivalence (also called "bisimilarity"), written ~ and described e.g. in <ref> [Mil89] </ref>. For processes manipulating values, a non-trivial aspect of the problem is that they have usually an operational description in terms of an infinite state-transition graph (they are infinite state), at least if the domain of data values is infinite. <p> Comparison with related work and conclusive remarks are contained in Section 9. 2 Preliminaries 2.1 The language Below, we present first the syntax and then operational and bisimulation semantics of the language. The notation we use is that of value-passing CCS <ref> [Mil80, Mil89] </ref> and of -calculus [MPW92]. <p> Note that we have not made any assumption on whether the sets V ar, V al and Act are pairwise disjoint or not. We will consider two particularly interesting cases: * Act, V ar and V al are pairwise disjoint. This gives rise to a sublanguage of value-passing CCS <ref> [Mil80, Mil89] </ref> and will be referred to as the simple value-passing case. * Act = V ar = V al. This gives rise to a sublanguage of the -calculus [MPW92] and will be referred to as the name-passing case. <p> We let range over actions. The transition relation is defined by the inference rules in Table 2.1. Note that ! leads processes into processes. On the top of the transition relation ! , we define strong bisimulation equivalence ~ , <ref> [Mil89, MPW92, PS95] </ref> as usual: Definition 2.1 (Strong bisimulation equivalence) A binary symmetric relation R over pro cesses in L m;v;r is a bisimulation if, whenever P RQ and P ! P 0 , there exists Q 0 s.t. Q and P 0 RQ 0 . <p> The proof of the following theorem, which states the soundness of the technique, is reported in <ref> [Mil89] </ref>. Theorem 3.5 Let R be a bisimulation up to ~ and let P; Q be two processes. Then P R Q implies P ~ Q. We will rely on a "finitary" characterization of bisimulation. <p> We will first deal with simple value-passing, and then indicate the necessary modifications to accommodate name-passing. We will first give an informal account of the translation. The basic idea stems from Definition 3.6 and from Milner's translation of CCS with values into pure CCS with infinite summation <ref> [Mil89] </ref>. As a first approximation, we express each input process a (x):P as a nondeterministic sum P v2V av:P f v =xg. <p> that any algorithm that decides the bisimilarity problem in L m;r has a worst-case running time no better than 2 n c , where n is the size of the input. 26 8 The Parallel Composition Operator In this section we consider adding the parallel composition operator j (see e.g. <ref> [Mil89] </ref>) to the language described in Section 2. We will show that, for a certain restricted syntactic format, that of finite control processes, the bisimilarity problem with parallel composition is decidable and EXP-complete. <p> The syntax of the language L m;v;r is extended with the clause P ::= P j P : All definitions and notions given for L m;v;r (such as free variables, subterms etc.) are extended to the new language in the expected way. Following <ref> [Mil89] </ref>, the operational semantics of the new operator is given by the rules: (P ar) 1 1 j P 2 P 1 ! P 0 0 2 t 1 j P 0 with ( = a and 0 = a) or ( = a (v) and 0 = av), plus the <p> It is worth to notice that, even in the absence of values, the presence of parallel composition implies an exponential blow-up of the number of states. This is implicitly present, for example, in the so-called "expansion law" <ref> [Mil89] </ref>: a j b ~ a:b + b:a. In general, it is easy to see that the process a 1 j j a n (for distinct a i 's) has 2 n states.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, part I and II. Information and Computation, </title> <address> 100:1 -41 and 42-78, </address> <year> 1992. </year>
Reference-contexts: A very peculiar kind of value-passing language is Milner, Parrow and Walker's -calculus <ref> [MPW92] </ref>, where the values being exchanged among processes are communication ports themselves (name-passing). This permits the description of systems with dynamical communication linkage. <p> The latter is done via the matching predicate [a = b], also considered in the -calculus <ref> [MPW92] </ref>. This is perhaps the most elementary form of test one would admit on data. Not even negative tests, to decide inequality of data, are permitted. <p> Comparison with related work and conclusive remarks are contained in Section 9. 2 Preliminaries 2.1 The language Below, we present first the syntax and then operational and bisimulation semantics of the language. The notation we use is that of value-passing CCS [Mil80, Mil89] and of -calculus <ref> [MPW92] </ref>. <p> This may involve renaming of bound names with fresh names, as usual, to prevent captures of free names (see <ref> [MPW92] </ref>). <p> This gives rise to a sublanguage of value-passing CCS [Mil80, Mil89] and will be referred to as the simple value-passing case. * Act = V ar = V al. This gives rise to a sublanguage of the -calculus <ref> [MPW92] </ref> and will be referred to as the name-passing case. Most of our results will not depend on a particular such assumption. <p> We let range over actions. The transition relation is defined by the inference rules in Table 2.1. Note that ! leads processes into processes. On the top of the transition relation ! , we define strong bisimulation equivalence ~ , <ref> [Mil89, MPW92, PS95] </ref> as usual: Definition 2.1 (Strong bisimulation equivalence) A binary symmetric relation R over pro cesses in L m;v;r is a bisimulation if, whenever P RQ and P ! P 0 , there exists Q 0 s.t. Q and P 0 RQ 0 . <p> Before proving the alternative characterization, we need a few properties of the transition system. In the following lemma and in the next theorem, we will suppose for simplicity that V ar, V al and Act are disjoint (the name-passing case requires only notational changes, which are covered, e.g., in <ref> [MPW92] </ref>). <p> In the literature, some variants of bisimulation have been proposed, such as late bisimilarity <ref> [MPW92, PS95] </ref> and open bisimilarity [San93]. Many of the results presented in the paper extend to these equivalences. In particular, both late and open bisimilarity are PSPACE-hard over the data-independent processes, because the three equivalences coincide in this case (see e.g. [PS95]). Our paper is mainly related to [JP93].
Reference: [Pap94] <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: It is easy to show that a problem is LIN-EXP-hard if and only if it is EXP-hard. See e.g. <ref> [BC93, Pap94] </ref> for a more complete introduction to complexity classes. Here we recall the following result due to Hartmanis and Stearns that states the provable intractability of LIN-EXP-hard problem.
Reference: [PS95] <author> J. Parrow and D. Sangiorgi. </author> <title> Algebraic theories for name-passing calculi. </title> <journal> Information and Computation, </journal> <volume> 120(2) </volume> <pages> 174-197, </pages> <year> 1995. </year>
Reference-contexts: The algebraic aspects of this problem are becoming now well-understood, also for value-passing processes <ref> [HL93, PS95, BD94] </ref>. On the contrary, a lot of questions concerning the decidability and the computational complexity of verification remain unanswered. A basic problem is to determine meaningful fragments of the calculi with values over which the verification problem is decidable. <p> We let range over actions. The transition relation is defined by the inference rules in Table 2.1. Note that ! leads processes into processes. On the top of the transition relation ! , we define strong bisimulation equivalence ~ , <ref> [Mil89, MPW92, PS95] </ref> as usual: Definition 2.1 (Strong bisimulation equivalence) A binary symmetric relation R over pro cesses in L m;v;r is a bisimulation if, whenever P RQ and P ! P 0 , there exists Q 0 s.t. Q and P 0 RQ 0 . <p> In the literature, some variants of bisimulation have been proposed, such as late bisimilarity <ref> [MPW92, PS95] </ref> and open bisimilarity [San93]. Many of the results presented in the paper extend to these equivalences. In particular, both late and open bisimilarity are PSPACE-hard over the data-independent processes, because the three equivalences coincide in this case (see e.g. [PS95]). Our paper is mainly related to [JP93]. <p> Many of the results presented in the paper extend to these equivalences. In particular, both late and open bisimilarity are PSPACE-hard over the data-independent processes, because the three equivalences coincide in this case (see e.g. <ref> [PS95] </ref>). Our paper is mainly related to [JP93]. There, Jonsson and Parrow prove that bisimilarity is decidable in the data-independent language L v;r , by showing that the infinitely many transitions due to an input action can be reduced to a single, suitably chosen, schematic action [JP93].
Reference: [PT87] <author> R. Paige and R.E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16(6) </volume> <pages> 973-989, </pages> <year> 1987. </year>
Reference-contexts: They prove that the bisimilarity problem for such processes can be transformed into a bisimilarity problem for finite-state processes. For the latter, decision algorithms exist <ref> [PT87, KS90] </ref>, which are polynomial in the sizes of the involved graphs (that can be however much larger than the syntactical size of the processes). A detailed comparison of our work with [JP93] is contained in Section 9. <p> We will first restrict ourselves to the simple value-passing case (i.e. we assume that V ar, V al and Act are pairwise disjoint) and then we will argue how the achieved results extend to the name-passing case. Recall that in <ref> [KS90, PT87] </ref> it has been shown that the bisimilarity problem for finite labeled transition systems can be solved in time polynomial in the sizes of the systems. <p> Under this assumption, it easily follows that any term P has an associated labeled transition system whose size is polynomially bounded in the size of P and Eq. The theorem follows from the above considerations and the results of <ref> [KS90, PT87] </ref>. 2 Let us now consider the complexity of the bisimilarity problem in L v;r . Jonsson and Parrow proved that such a problem is decidable and NP-hard [JP93], we will improve on this result and we will show that the problem is indeed PSPACE-hard. <p> Note that k too is a polynomial function of the size of the problem. It follows the bisimilarity problem in L m;r;p can be solved in exponential time using, for example, the algorithm by Page and Tarjan <ref> [PT87] </ref>. Putting together the latter fact, Theorem 6.7 and Theorem 7.5, the above Proposition 8.1, we have the following result of equivalence between languages: Theorem 8.2 The bisimilarity problems for the languages L m;r , L m;v;r , L m;r;p and L m;v;r;p are all EXP-complete.
Reference: [San93] <author> D. Sangiorgi. </author> <title> A theory of bisimulation for the -calculus. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR '93, </booktitle> <publisher> LNCS 715. Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year> <note> To appear in Acta Informatica. </note>
Reference-contexts: In the literature, some variants of bisimulation have been proposed, such as late bisimilarity [MPW92, PS95] and open bisimilarity <ref> [San93] </ref>. Many of the results presented in the paper extend to these equivalences. In particular, both late and open bisimilarity are PSPACE-hard over the data-independent processes, because the three equivalences coincide in this case (see e.g. [PS95]). Our paper is mainly related to [JP93]. <p> It would be interesting to find, in the spirit of the translation from L m;v;r;p to L m;r;p , a compositional reduction from L m;r;p to L m;r that would show how to "express" the parallel composition operator using the other operators. In <ref> [HL95, HL93, San93, BD94] </ref>, notions of symbolic bisimulation are investigated for both CCS with value-passing and -calculus, aiming at a more efficient representation of bisimilarity. Our results show that, even for very simple fragments, it is very unlikely that efficient algorithms exist.
Reference: [SM73] <author> L. Stockmeyer and A. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proceedings of the 5th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1973. </year> <month> 30 </month>
Reference-contexts: Given a QBF , the QBF problem consists of deciding whether is valid: this is a PSPACE-complete problem <ref> [SM73] </ref>, and it is easy to see that it remains PSPACE-complete even when restricted to formulas = Q 1 x 1 Q 2 x 2 : : : ; Q n x n : 0 such that n is even and Q i = 9 if and only if Q i
References-found: 17

