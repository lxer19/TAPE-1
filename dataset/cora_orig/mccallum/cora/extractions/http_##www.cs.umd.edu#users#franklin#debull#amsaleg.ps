URL: http://www.cs.umd.edu/users/franklin/debull/amsaleg.ps
Refering-URL: http://www.cs.umd.edu/projects/dimsum/papers/
Root-URL: 
Title: Improving Responsiveness for Wide-Area Data Access  
Author: Laurent Amsaleg Philippe Bonnet Michael J. Franklin Anthony Tomasic Tolga Urhan 
Affiliation: INRIA Bull University of Maryland  INRIA University of Maryland  
Abstract: In a wide-area environment, the time required to obtain data from remote sources can vary unpredictably due to network congestion, link failure or other problems. Traditional techniques for query optimization and query execution do not cope well with such unpredictability. The static nature of those techniques prevents them from adapting to remote access delays that arise at runtime. In this paper we describe two separate, but related techniques aimed at tackling this problem. The first technique, called Query Scrambling, hides relatively short, intermittent delays by dynamically adjusting query execution plans on-the-fly. The second technique addresses the longer-term unavailability of data sources by allowing the return of partial query answers when some of the data needed to fully answer a query are missing.
Abstract-found: 1
Intro-found: 1
Reference: [ACPS96] <author> S. Adali, K. Candan, Y. Papakonstantinou, and V. Subrahmanian. </author> <title> Query caching and optimization in distributed mediator systems. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Montreal, Canada, </address> <year> 1996. </year>
Reference-contexts: The approaches we describe differ significantly from previous dynamic query optimization techniques. One popular approach to dynamic query optimization has been to delay binding of certain execution choices until query execution time (e.g., <ref> [CG94, ACPS96, SAL + 96, LP97] </ref>). In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution.
Reference: [AFT97] <author> L. Amsaleg, M. Franklin, and A. Tomasic. </author> <title> Dynamic query operator scheduling for wide-area remote access. </title> <type> Tech. </type> <institution> Report CS-TR-3811 and UMIACS-TR-97-54, Univ. of MD, College Park, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Adapting to unexpected delays requires more flexible approaches, such as those we describe in the following sections. 3 Query Scrambling Using Query Scrambling <ref> [AFTU96, AFT97] </ref>, a query is initially executed according to the original plan and associated schedule generated by the query optimizer. <p> Two factors are relevant here: the speed of the network compared to the speed of the local disk (s) and the way data is obtained through the network (i.e., page-at-a-time versus streaming) <ref> [AFT97] </ref>. A second set of tradeoffs revolve around the question of whether to Reschedule individual operators (in a bottom-up fashion) or entire subtrees. Subtrees can be rescheduled (i.e., executed out of order) given sufficient available memory.
Reference: [AFTU96] <author> L. Amsaleg, M. Franklin, A. Tomasic, and T. Urhan. </author> <title> Scrambling query plans to cope with unexpected delays. </title> <booktitle> In Proc. of the Int. Conf. on Parallel and Distributed Information Systems (PDIS), </booktitle> <address> Miami Beach, Florida, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: Unfortunately , the apparent randomness of such delays makes planning for them during query optimization impossible. We have developed two different but complementary approaches to address the issue of unpredictable delays in the wide-area environment. In <ref> [AFTU96] </ref> we introduced the concept of Query Scrambling, which reacts to delays by modifying the query execution plan on-the-fly so that progress can be made on other parts of the plan. <p> Adapting to unexpected delays requires more flexible approaches, such as those we describe in the following sections. 3 Query Scrambling Using Query Scrambling <ref> [AFTU96, AFT97] </ref>, a query is initially executed according to the original plan and associated schedule generated by the query optimizer. <p> This coordinator passively supervises the execution of the query and watches for remote access delays. When a delay is detected, the coordinator reacts by performing Scrambling actions that it deems to be advantageous based on the current state of the system. In <ref> [AFTU96] </ref> we described a simple, heuristic-based algorithm for choosing scrambling actions. In our current work, we have developed cost-based scrambling policies, that use a query optimizer to help direct Scrambling. <p> Thrashing could then arise due to operators that repeatedly stall and un-stall. In contrast, materializing base relations to the local disk requires only minimal memory, but of course, requires additional I/O. 5 Finally, choosing which specific operator (s) to reschedule is also fundamental. In <ref> [AFTU96] </ref> the operator to reschedule was elected depending on the original order of the operators in the query before any rescheduling. As illustrated in [AFTU96], this simplistic policy has several severe performance drawbacks. <p> In <ref> [AFTU96] </ref> the operator to reschedule was elected depending on the original order of the operators in the query before any rescheduling. As illustrated in [AFTU96], this simplistic policy has several severe performance drawbacks. As with Operator Synthesis, we have developed cost-based approaches to this problem that avoid the pitfalls of the simpler heuristic policies. <p> If the synthesized operations are too expensive Query Scrambling could result in a net degradation in performance. Operation Synthesis, therefore, has the potential to negate or even reverse the benefits of Scrambling if care is not taken. In <ref> [AFTU96] </ref> we used the simple heuristic of avoiding Cartesian products to prevent the creation of overly expensive joins. This approach has the advantage of avoiding the need to do cost-based optimization, but its performance was shown to be highly sensitive to the cardinalities of the new operators created.
Reference: [Ant93] <author> G. Antoshenkov. </author> <title> Dynamic query optimization in Rdb/VMS. </title> <booktitle> In Proc. of the Data Engineering Int. Conf., </booktitle> <pages> pages 538-547, </pages> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution. Approaches that do change the query plan during execution, have been proposed in <ref> [TTC + 90, Ant93, ONK + 96] </ref>, to account for inaccurate estimates of selectivities, cardinal-ities, or costs, etc. made during query optimization, and in [Sar95] to adjust to the location of data in a deep-store memory hierarchy.
Reference: [BT97] <author> P. Bonnet and A. Tomasic. </author> <title> Partial answers for unavailable data sources. </title> <type> Technical Report RR-3127, </type> <institution> INRIA, Rocquencourt, France, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: If the delays are too long, a user may not find it tolerable to wait for a complete answer. An approach to coping with longer-term delays is described in <ref> [BT97] </ref>. This latter approach allows the system to time-out on a data source or sources and return a partial answer , which encapsulates data obtained from available sources along with a description of the work remaining to be done. <p> For an interactive system, if a delay lasts longer than a user is willing to wait, then in effect, the delayed data is unavailable. Because Query Scrambling returns only complete answers to users, it does not solve the problem of unavailable data. <ref> [BT97] </ref> proposes an approach where in the presence of unavailable data, a partial answer is returned to the user. The motivation behind this approach is that even when one or more needed sites are unavailable, some useful work can be done with the data from the sites that are available. <p> To understand our approach, consider a query that involves several sites, such as the query of complete answer. Suppose, however, that site B is unavailable. In this case a complete answer to this query cannot be produced. The system proposed in <ref> [BT97] </ref> would perform the following steps: * Phase 1 each available site is contacted, and all processing based on available data is performed. The results that are obtained are materialized on the query source site. <p> Using parachute queries, the user can still collect useful information concerning patients or surgeons in case the complete answer to the original query cannot be computed. <ref> [BT97] </ref> proposes an initial algorithm for the extraction of information using parachute queries. When a parachute query is submitted, it is tested for containment against the queries generated in Phase 2.
Reference: [CG94] <author> R. Cole and G. Graefe. </author> <title> Optimization of dynamic query execution plans. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 150-160, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The approaches we describe differ significantly from previous dynamic query optimization techniques. One popular approach to dynamic query optimization has been to delay binding of certain execution choices until query execution time (e.g., <ref> [CG94, ACPS96, SAL + 96, LP97] </ref>). In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution.
Reference: [Gra93] <author> G. Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The actual schedule of the operators that comprise the query shown in Figure 1 (joins, selects, etc.) depends on the execution model used (e.g., iterators, activation records) and on whether or not parallelism is supported. For simplicity, assume an iterator-based scheduler <ref> [Gra93] </ref>, where the first data access would be to request a tuple of Relation A (from site 2). If there is a delay in accessing that site (say, because the site is temporarily down), then the scan of A is blocked until the site recovers.
Reference: [LP97] <author> L. Liu and C. Pu. </author> <title> A dynamic query scheduling framework for distributed and evolving information systems. </title> <booktitle> In The IEEE Int. Conf. on Distributed Computing Systems (ICDCS-17), </booktitle> <address> Baltimore, </address> <year> 1997. </year>
Reference-contexts: The approaches we describe differ significantly from previous dynamic query optimization techniques. One popular approach to dynamic query optimization has been to delay binding of certain execution choices until query execution time (e.g., <ref> [CG94, ACPS96, SAL + 96, LP97] </ref>). In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution.
Reference: [ONK + 96] <author> F. Ozcan, S. Nural, P. Koksal, C. Evrendilek, and A. Dogac. </author> <title> Dynamic query optimization on a distributed object management platform. </title> <booktitle> In Conference on Information and Knowledge Management, </booktitle> <address> Baltimore, Maryland, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution. Approaches that do change the query plan during execution, have been proposed in <ref> [TTC + 90, Ant93, ONK + 96] </ref>, to account for inaccurate estimates of selectivities, cardinal-ities, or costs, etc. made during query optimization, and in [Sar95] to adjust to the location of data in a deep-store memory hierarchy.
Reference: [SAL + 96] <author> M. Stonebraker, P. Aoki, W. Litwin, A. Pfeffer, A. Sah, J. Sidell, C. Staelin, and A. Yu. Mariposa: </author> <title> A wide-area distributed database system. </title> <journal> The VLDB Journal, </journal> <volume> 5(1) </volume> <pages> 48-63, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The approaches we describe differ significantly from previous dynamic query optimization techniques. One popular approach to dynamic query optimization has been to delay binding of certain execution choices until query execution time (e.g., <ref> [CG94, ACPS96, SAL + 96, LP97] </ref>). In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution.
Reference: [Sar95] <author> S. Sarawagi. </author> <title> Query processing and caching in tertiary memory. </title> <booktitle> In Proc. of the 21st Conference on Very Large Databases, </booktitle> <address> Zurich, </address> <year> 1995. </year>
Reference-contexts: Approaches that do change the query plan during execution, have been proposed in [TTC + 90, Ant93, ONK + 96], to account for inaccurate estimates of selectivities, cardinal-ities, or costs, etc. made during query optimization, and in <ref> [Sar95] </ref> to adjust to the location of data in a deep-store memory hierarchy. In contrast, our work is focused on adjusting to the time-varying performance of loosely-coupled data sources in a wide-area network, and as a result, we have developed quite different solutions.
Reference: [TRV96] <author> A. Tomasic, L. Raschid, and P. Valduriez. </author> <title> Scaling heterogeneous databases and the design of DISCO. </title> <booktitle> In The IEEE Int. Conf. on Distributed Computing Systems (ICDCS-16), </booktitle> <address> Hong Kong, </address> <year> 1996. </year>
Reference-contexts: In the example, relations A and B reside at 1 Note that as currently specified, both the Query Scrambling and Partial Answer approaches treat remote sources as black boxes, regardless of whether they provide raw data or the answers to sub-queries (e.g., <ref> [TRV96] </ref>). Therefore, both approaches operate solely at the query source site. 2 separate remote sites (sites 2 and 3 respectively), relation C resides locally at the query source (i.e., site 1), and relations D and E are co-located at site 4.
Reference: [TTC + 90] <author> G. Thomas, G. Thompson, C. Chung, E. Barkmeyer, F. Carter, M. Templeton, S. Fox, and B. Hart-man. </author> <title> Heterogeneous distributed database systems for product use. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3), </volume> <year> 1990. </year>
Reference-contexts: In these approaches the final query plan is produced immediately prior to execution and then remains fixed for the duration of the query. Such approaches, therefore, cannot adapt to unexpected problems that arise during the execution. Approaches that do change the query plan during execution, have been proposed in <ref> [TTC + 90, Ant93, ONK + 96] </ref>, to account for inaccurate estimates of selectivities, cardinal-ities, or costs, etc. made during query optimization, and in [Sar95] to adjust to the location of data in a deep-store memory hierarchy.
References-found: 13

