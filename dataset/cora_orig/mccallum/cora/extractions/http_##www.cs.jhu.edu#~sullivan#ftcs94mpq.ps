URL: http://www.cs.jhu.edu/~sullivan/ftcs94mpq.ps
Refering-URL: http://www.cs.jhu.edu/~sullivan/ftdownload.html
Root-URL: http://www.cs.jhu.edu
Title: Checking Mergeable Priority Queues  
Author: Jonathan Bright Gregory Sullivan 
Address: 3400 N. Charles Street, Baltimore, MD 21218  
Affiliation: Computer Science Department The Johns Hopkins University  
Abstract: We present an efficient algorithm which can check the answers given by the fundamental abstract data types priority queues and mergeable priority queues. This is the first linear-time checker for mergeable priority queues. These abstract data types are widely used in routing, scheduling, simulation, computational geometry and many other algorithmic domains. We have implemented our answer checker and have performed experiments comparing the speed of our checker to recently benchmarked priority queue and mergeable priority queue implementations, and our checker is substantially faster than the best of these implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A. V., Hopcroft, J. E., Ullman, J. D., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974, </year> <pages> pp. 145-157. </pages>
Reference-contexts: These abstract data types have been recognized as centrally important from the early days of computer-algorithm design. They appear in seminal algorithm texts such as Knuth's [10] and Aho, Hopcroft and Ullman's <ref> [1] </ref>. Data structure implementations for these abstract data types continue to proliferate and currently include: binomial queues, AVL trees, leftist trees, skew heaps, pairing heaps, Fibonacci heaps, 2-3 trees, b-trees and others.
Reference: [2] <author> Anderson, T., and Lee, P., </author> <title> Fault Tolerance: Principles and Practices, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Our checkers provide an error-detection capability for other fundamental operations, viz., PQ and MPQ operations. Program checkers are also studied in [3], though the approach there is slightly different than the approach in this paper. Our checkers can also be used as acceptance tests in the recovery-block approach <ref> [14, 2] </ref> to software fault tolerance. After an error is detected many methods of recovery are possible. For example, the data contents of the abstract data type might be extracted and placed in a new abstract data type which is based on an alternative implementation strategy.
Reference: [3] <author> Blum, M., Kannan, S., </author> <title> "Designing Programs that Check Their Work," </title> <booktitle> Proc. of the 1989 ACM Symp. on Theory of Computing,, </booktitle> <pages> pp. 86-97. </pages>
Reference-contexts: That approach is particularly valuable for detecting errors in fundamental operations such as matrix multiplication and FFT. Our checkers provide an error-detection capability for other fundamental operations, viz., PQ and MPQ operations. Program checkers are also studied in <ref> [3] </ref>, though the approach there is slightly different than the approach in this paper. Our checkers can also be used as acceptance tests in the recovery-block approach [14, 2] to software fault tolerance. After an error is detected many methods of recovery are possible.
Reference: [4] <author> Cheriton, D., Tarjan, R. E., </author> <title> "Finding Minimum Spanning Trees," </title> <journal> SIAM J. Comput., </journal> <volume> 5 (1976), </volume> <pages> 724-742. </pages>
Reference: [5] <author> Dixon, B., Rauch, M., Tarjan, R. E., </author> <title> "Verification and Sensitivity Analysis of Minimum Spanning Trees in Linear Time," </title> <journal> SIAM J. Comput., </journal> <volume> 21 (1992), </volume> <pages> 1184-1192. </pages>
Reference-contexts: This same technique also applies to the part of deletemin which is responsible for creating a check edge. Finally, Dixon et al. <ref> [5] </ref> show how the correctness of an MST can be checked in linear time. Note that their result also works with the generalized definition of minimum spanning trees which we use.
Reference: [6] <author> Fredman, M. L., et al., </author> <title> "The Pairing Heap: a New Form of Self-Adjusting Heap," </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> 111-129. </pages>
Reference-contexts: In our tables, PHp is pairing heap <ref> [6] </ref>, SHp is skew heap [15], BHp is binomial queue [20], LHp is leftist tree [11], and FHp is Fibonacci heap [7]. Our first set of test cases consisted of a sequence of operations on only one priority queue.
Reference: [7] <author> Fredman, M. L., Tarjan, R. E., </author> <title> "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms," </title> <journal> Journal of the ACM 34 1987, </journal> <pages> 596-615. </pages>
Reference-contexts: In our tables, PHp is pairing heap [6], SHp is skew heap [15], BHp is binomial queue [20], LHp is leftist tree [11], and FHp is Fibonacci heap <ref> [7] </ref>. Our first set of test cases consisted of a sequence of operations on only one priority queue. Here, N insert operations were followed by N deletemin operations, for several different values of N . See Table 1 for the results.
Reference: [8] <author> Gabow, H. N., Tarjan, R. E., </author> <title> "A Linear-Time Algorithm for a Special Case of Disjoint Set Union," </title> <journal> J. Comput. System Sci., </journal> <volume> 30 (1985), </volume> <pages> 209-221. </pages>
Reference-contexts: Now, consider the delete operations. Our algorithm requires the name of the set from which the element was deleted. We can also postpone all of the processing of the delete operations until the final stage. Then, the linear-time off-line union/find algorithm <ref> [8] </ref> can be used to process these operations. Since delete operations only create check edges, and check edges are only used during the final stage, the behavior of the algorithm is not altered by delaying this processing.
Reference: [9] <author> Huang, K.-H., and Abraham, J., </author> <title> "Algorithm-based Fault Tolerance for Matrix Operations," </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 518-529, vol. C-33, </volume> <month> June, </month> <year> 1984. </year>
Reference-contexts: The desirability of using software to monitor a computation to attempt to determine if it is executing properly has long been recognized in the fault-tolerance community. For example, the general approach designated algorithm-based fault tolerance <ref> [9] </ref> uses software and additional data to attempt to detect errors. That approach is particularly valuable for detecting errors in fundamental operations such as matrix multiplication and FFT. Our checkers provide an error-detection capability for other fundamental operations, viz., PQ and MPQ operations.
Reference: [10] <author> Knuth, D. E., </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 1, </volume> <booktitle> 2nd edn., </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: 1 Introduction This paper concerns the fundamental abstract data types of priority queues (PQs) and mergeable priority queues (MPQs). These abstract data types have been recognized as centrally important from the early days of computer-algorithm design. They appear in seminal algorithm texts such as Knuth's <ref> [10] </ref> and Aho, Hopcroft and Ullman's [1]. Data structure implementations for these abstract data types continue to proliferate and currently include: binomial queues, AVL trees, leftist trees, skew heaps, pairing heaps, Fibonacci heaps, 2-3 trees, b-trees and others. <p> As an example application, the MPQ checker can be used to build a certification trail solution for constructing optimal alphabetic search trees. See <ref> [10] </ref> for a method of building optimal alphabetic search trees. The resulting certifier program will run in O (n) time, where n is the size of the search tree constructed.
Reference: [11] <author> Knuth, D. E., </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 3, </volume> <booktitle> 2nd edn., </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: In our tables, PHp is pairing heap [6], SHp is skew heap [15], BHp is binomial queue [20], LHp is leftist tree <ref> [11] </ref>, and FHp is Fibonacci heap [7]. Our first set of test cases consisted of a sequence of operations on only one priority queue. Here, N insert operations were followed by N deletemin operations, for several different values of N . See Table 1 for the results.
Reference: [12] <author> Liao, A. M., </author> <title> "Three Priority Queue Applications Revisited," </title> <journal> Algorithmica, </journal> <volume> 7 (1992), </volume> <pages> 415-427. </pages>
Reference-contexts: In order to evaluate the relative speed and effectiveness of our MPQ checker, we obtained the code to five different PQ and MPQ implementations which were recently tested in an article which appeared in the Application Experience section of the Journal Algorithmica <ref> [12] </ref>. This study is an extensive evaluation of different PQ and MPQ implementations. Our results show that the checker is substantially faster than the fastest of these implementations of PQs and MPQs on a wide variety of operation sequences. <p> A vivid example of the value of our checkers in the software development and debugging process was provided when we performed our experimental timing studies. To conduct our experiments we first searched for pre-existing PQ and MPQ implementations. The author of <ref> [12] </ref> graciously provided us with copies of his extensively benchmarked and tested implementations to use in our studies. We generated many random sequences of operations and used our MPQ checker to check each of the five implementations provided.
Reference: [13] <author> Ramanan, P., </author> <title> "Testing the Optimality of Alphabetic Trees," </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 93, </volume> <pages> pp. 279-302, </pages> <month> February, </month> <year> 1992. </year>
Reference-contexts: The resulting certifier program will run in O (n) time, where n is the size of the search tree constructed. This result is better than the previously best known checker for optimal alphabetic search trees, which ran in O (n) time only for certain special cases <ref> [13] </ref>. 2 Definitions We now describe the operations that we consider. The basic operand type is a pair (it; val ). it is a positive integer, and is called the item number for the pair.
Reference: [14] <author> Randell, B., </author> <title> "System Structure for Software Fault Tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June, </month> <year> 1975. </year>
Reference-contexts: Our checkers provide an error-detection capability for other fundamental operations, viz., PQ and MPQ operations. Program checkers are also studied in [3], though the approach there is slightly different than the approach in this paper. Our checkers can also be used as acceptance tests in the recovery-block approach <ref> [14, 2] </ref> to software fault tolerance. After an error is detected many methods of recovery are possible. For example, the data contents of the abstract data type might be extracted and placed in a new abstract data type which is based on an alternative implementation strategy.
Reference: [15] <author> Sleator, D. D., Tarjan, R. E., </author> <title> "Self-Adjusting Heaps," </title> <journal> SIAM J. Comput., </journal> <volume> 15 (1986), </volume> <pages> 52-69. </pages>
Reference-contexts: In our tables, PHp is pairing heap [6], SHp is skew heap <ref> [15] </ref>, BHp is binomial queue [20], LHp is leftist tree [11], and FHp is Fibonacci heap [7]. Our first set of test cases consisted of a sequence of operations on only one priority queue.
Reference: [16] <author> Sullivan, G. F., Masson, G. M., </author> <title> "Using Certification Trails to Achieve Software Fault Tolerance," </title> <booktitle> Dig. of the 1990 IEEE Fault Tol. Comput. Symp., </booktitle> <year> 1990, </year> <pages> pp. 423-431. </pages>
Reference-contexts: When an error is detected, a repair of the data structure can be attempted. In some cases, recovery and continued execution will be possible. Finally, we mention that these checkers can be used to generate certification trails. The notion of a certification trail was introduced in <ref> [16] </ref> and a general method for utilizing checkers of the type presented here to generate certification trails is described in [17]. As an example application, the MPQ checker can be used to build a certification trail solution for constructing optimal alphabetic search trees.
Reference: [17] <author> Sullivan, G. F., Masson, G. M., </author> <title> "Certification Trails for Data Structures," </title> <booktitle> Dig. of the 1991 IEEE Fault Tol. Comput. Symp., </booktitle> <year> 1991, </year> <pages> pp. 240-247. </pages>
Reference-contexts: However, we have designed an O (N )-time algorithm which checks the answers given by these abstract data types. This linear-time answer checker is the first known for the MPQ abstract data type. In a previous paper <ref> [17] </ref> we presented a linear-time algorithm for checking the answers from PQs. We have found that the MPQ algorithm can also be used as a new efficient linear-time checker for PQs. <p> Finally, we mention that these checkers can be used to generate certification trails. The notion of a certification trail was introduced in [16] and a general method for utilizing checkers of the type presented here to generate certification trails is described in <ref> [17] </ref>. As an example application, the MPQ checker can be used to build a certification trail solution for constructing optimal alphabetic search trees. See [10] for a method of building optimal alphabetic search trees.
Reference: [18] <author> Tarjan, R. E., </author> <title> "Applications of Path Compression on Balanced Trees," </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 26 (1979), </volume> <pages> pp. 690-715. </pages>
Reference-contexts: We use the definition below which is a generalization of the standard minimum spanning tree definition, see <ref> [18] </ref>. Let G be a graph with vertices V and edges E. Also, let G have a weight function defined on E. Let T E be a spanning tree of G. <p> First we will discuss the notion of computing functions on paths in trees <ref> [18] </ref>.
Reference: [19] <author> Taylor, D., </author> <title> "Error Models for Robust Data Structures," </title> <booktitle> Dig. 20th Annual Int. Symp. Fault Tolerant Comput., </booktitle> <pages> pp. 416-422, </pages> <year> 1990 </year> <month> June 26-28. </month>
Reference-contexts: Another possible application for our checkers occurs when one is used in conjunction with a repairable data structure which allows for repair but does not automatically attempt to detect faults <ref> [19] </ref>. Suppose a PQ or MPQ abstract data type is implemented with a repairable data structure. One can use one of our checkers to detect errors in the answers generated by the abstract data type. When an error is detected, a repair of the data structure can be attempted.
Reference: [20] <author> Vuillemin, J., </author> <title> "A Data Structure for Manipulating Priority Queues," </title> <journal> Comm. ACM, </journal> <volume> 21 (1978), </volume> <pages> 309-314. </pages>
Reference-contexts: In our tables, PHp is pairing heap [6], SHp is skew heap [15], BHp is binomial queue <ref> [20] </ref>, LHp is leftist tree [11], and FHp is Fibonacci heap [7]. Our first set of test cases consisted of a sequence of operations on only one priority queue. Here, N insert operations were followed by N deletemin operations, for several different values of N .
References-found: 20

