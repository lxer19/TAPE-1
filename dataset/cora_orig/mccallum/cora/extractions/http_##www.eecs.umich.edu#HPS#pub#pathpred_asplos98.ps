URL: http://www.eecs.umich.edu/HPS/pub/pathpred_asplos98.ps
Refering-URL: http://www.eecs.umich.edu/HPS/hps_branchpred.html
Root-URL: http://www.cs.umich.edu
Title: Variable Length Path Branch Prediction  
Abstract: Copyright c fl1998 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or permissions@acm.org. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Calder and D. Grunwald, </author> <title> "Reducing indirect function call overhead in C++ programs," </title> <booktitle> in 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 397-408, </pages> <year> 1994. </year>
Reference-contexts: Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques [2, 13, 15, 18]. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table <ref> [1, 6] </ref>. Any of the predictors presented in this paper may be used as a component of a hybrid predictor [14] or a cascaded predictor [7]. 5.1 Methodology The results presented in this paper are for the eight SPECint95 benchmarks.
Reference: [2] <author> P.-Y. Chang, M. Evers, and Y. N. Patt, </author> <title> "Improving branch prediction accuracy by reducing pattern history table interference," </title> <booktitle> in Proceedings of the 1996 ACM/IEEE Conference on Parallel Architectures and Compilation Techniques, </booktitle> <year> 1996. </year>
Reference-contexts: Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques <ref> [2, 13, 15, 18] </ref>. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6].
Reference: [3] <author> P.-Y. Chang, E. Hao, and Y. N. Patt, </author> <title> "Predicting indirect jumps using a target cache," </title> <booktitle> in Proceedings of the 24th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 274 - 283, </pages> <year> 1997. </year>
Reference-contexts: As the pipeline depths and the issue rates increase, the amount of speculative work that must be thrown away in the event of a branch misprediction also increases. Thus, tomorrow's processors will require even more accurate branch prediction to deliver their potential performance. Recent studies <ref> [3, 6, 10, 16] </ref> have shown that conditional and indirect (or computed) branch targets can be accurately predicted by recording the path leading up to the branch. The path consists of the target addresses of the branches leading up to the current branch. <p> Jacobson et. al. [10] proposed a path based mechanism for predicting indirect branches in the multiscalar architecture. Their correlated task target buffer achieved substantial improvements in indirect branch prediction on the 5 SPECint92 benchmarks they used. Chang, Hao and Patt <ref> [3] </ref> proposed several mechanisms for applying the 2-level prediction algorithm to the prediction of indirect branches. They showed that a history based predictor dramatically improved prediction accuracy over a branch target buffer based predictor. <p> We compare the performance of these predictors to the performance of basic versions of other predictors (gshare [14] for conditional branches, and pattern and path based predictors for indirect branches <ref> [3] </ref>). Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques [2, 13, 15, 18]. <p> For conditional branch prediction, these are compared to gshare [14], and for indirect branch prediction, they are compared to the path and pattern based predictors presented in <ref> [3] </ref>. For the fixed length path predictor, the same path length was used for all benchmarks. The length used was that for which the average misprediction rate for all the benchmarks was the lowest. <p> These results are compared to the misprediction rates of both the pattern and path based predictors from <ref> [3] </ref>. For these figures, the predictor size is fixed at 2K bytes 1 . The 8 benchmarks with the highest indirect branch frequencies are marked in bold on the figures. <p> The remaining 32 bits are taken from the current fetch address. The results for the 8 benchmarks with frequent in-direct branches are shown in Table 3. The variable length path (VLP) predictor achieves a 24.5% to 94.9% reduction in mispredictions compared to the pattern based variation from <ref> [3] </ref>. Even the fixed length path (FLP) predictor, which does not require profiling, is significantly better than the pattern based predictor for 6 of the 8 benchmarks. This shows that for indirect branches, the path predictor presented in this paper is superior. Benchmark path [3] pattern [3] FLP VLP 124.m88ksim 58.24% <p> to the pattern based variation from <ref> [3] </ref>. Even the fixed length path (FLP) predictor, which does not require profiling, is significantly better than the pattern based predictor for 6 of the 8 benchmarks. This shows that for indirect branches, the path predictor presented in this paper is superior. Benchmark path [3] pattern [3] FLP VLP 124.m88ksim 58.24% 41.31% 13.79% 15.96% 126.gcc 50.42% 32.75% 27.64% 19.12% 134.perl 4.56% 9.54% 0.80% 0.49% groff 83.97% 25.00% 28.36% 14.10% gs 37.31% 18.12% 19.13% 13.68% plot 51.19% 11.00% 5.04% 4.06% python 42.87% 50.42% 34.75% 29.09% Table 3: Misprediction Rates for Indirect Branches on Selected Benchmarks 5.2.3 <p> pattern based variation from <ref> [3] </ref>. Even the fixed length path (FLP) predictor, which does not require profiling, is significantly better than the pattern based predictor for 6 of the 8 benchmarks. This shows that for indirect branches, the path predictor presented in this paper is superior. Benchmark path [3] pattern [3] FLP VLP 124.m88ksim 58.24% 41.31% 13.79% 15.96% 126.gcc 50.42% 32.75% 27.64% 19.12% 134.perl 4.56% 9.54% 0.80% 0.49% groff 83.97% 25.00% 28.36% 14.10% gs 37.31% 18.12% 19.13% 13.68% plot 51.19% 11.00% 5.04% 4.06% python 42.87% 50.42% 34.75% 29.09% Table 3: Misprediction Rates for Indirect Branches on Selected Benchmarks 5.2.3 Gcc rate
Reference: [4] <author> P.-Y. Chang, E. Hao, T.-Y. Yeh, and Y. N. Patt, </author> <title> "Branch classification: A new mechanism for improving branch predictor performance," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 22-31, </pages> <year> 1994. </year>
Reference-contexts: They gave examples of branches being predictable using a path history but not with a pattern history. They also introduced a transformation using code duplication and profile generated path information to transform a program for better static prediction accuracy. Chang et. al. <ref> [4] </ref> proposed a hybrid predictor consisting of two GAs predictors with different history lengths using a shared set of pattern history tables. They showed that this predictor narrowly outperformed gshare for the SPECint92 benchmarks.
Reference: [5] <author> J. Dean, J. E. Hicks, C. A. Waldspurger, W. E. Weihl, and G. Chrysos, "ProfileMe: </author> <title> Hardware support for instruction-level profiling on out-of-order processors," </title> <booktitle> in Proceedings of the 30th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 292 - 302, </pages> <year> 1997. </year>
Reference-contexts: In our experiments, we show that even when this default value is used, the resulting prediction accuracy is still higher than that of competing predictors. Dean et. al. <ref> [5] </ref> presented an unobtrusive way to gather profiling data. With this technique, the processor's state is randomly sampled and then squirreled away for later processing. For a variable length path predictor, the contents of the THB could be sampled after some random number of branches.
Reference: [6] <author> K. Driesen and U. Holzle, </author> <title> "Accurate indirect branch prediction," </title> <booktitle> in Proceedings of the 25th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 167-178, </pages> <year> 1998. </year>
Reference-contexts: As the pipeline depths and the issue rates increase, the amount of speculative work that must be thrown away in the event of a branch misprediction also increases. Thus, tomorrow's processors will require even more accurate branch prediction to deliver their potential performance. Recent studies <ref> [3, 6, 10, 16] </ref> have shown that conditional and indirect (or computed) branch targets can be accurately predicted by recording the path leading up to the branch. The path consists of the target addresses of the branches leading up to the current branch. <p> For each static branch, the compiler used profiling information to determine the number of his tory bits that should be used to predict the branch. These variations significantly outperformed the predictors in which the number of history bits was fixed. Driesen and Holzle <ref> [6] </ref> explored a large space of path based indirect branch predictors. In their experiments, a global path history was shown to be better than per-address (i.e., per branch address) path histories. <p> Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques [2, 13, 15, 18]. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table <ref> [1, 6] </ref>. Any of the predictors presented in this paper may be used as a component of a hybrid predictor [14] or a cascaded predictor [7]. 5.1 Methodology The results presented in this paper are for the eight SPECint95 benchmarks.
Reference: [7] <author> K. Driesen and U. Holzle, </author> <title> "Improving indirect branch prediction with source- and arity-based classification and cascaded prediction," </title> <type> Technical Report TRCS98-07, </type> <institution> Department of Computer Science, University of Cal-ifornia, Santa Barbara, </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6]. Any of the predictors presented in this paper may be used as a component of a hybrid predictor [14] or a cascaded predictor <ref> [7] </ref>. 5.1 Methodology The results presented in this paper are for the eight SPECint95 benchmarks. We also present the results for eight other commonly used programs.
Reference: [8] <author> M. Evers, S. J. Patel, R. S. Chappell, and Y. N. Patt, </author> <title> "An analysis of correlation and predictability: What makes two-level branch predictors work," </title> <booktitle> in Proceedings of the 25th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 52-61, </pages> <year> 1998. </year>
Reference-contexts: This advantage is only slight for conditional branches, but great for indirect branches. The second effect is due to the variable nature of the path length. Evers et. al. <ref> [8] </ref> showed that only a small amount of the path information leading up to a branch is needed for prediction.
Reference: [9] <author> L. Gwennap, </author> <title> "Intel's MMX speeds multimedia," </title> <type> Microprocessor Report, </type> <month> March </month> <year> 1996. </year>
Reference-contexts: The exact number within a range would be determined by the hardware. If the ISA does not have any bits set aside for profiling information, then the ISA could be augmented. (Existing ISAs have been extensively augmented. For example, multimedia instructions were recently added to the venerable x86 ISA <ref> [9] </ref>.) 4.3 Pipelining the Predictor A variable length path predictor requires two sequential table accesses to make a prediction.
Reference: [10] <author> Q. Jacobson, S. Bennett, N. Sharma, and J. E. Smith, </author> <title> "Control flow speculation in multiscalar processors," </title> <booktitle> in Proceedings of the Third IEEE International Symposium on High Performance Computer Architecture, </booktitle> <year> 1997. </year>
Reference-contexts: As the pipeline depths and the issue rates increase, the amount of speculative work that must be thrown away in the event of a branch misprediction also increases. Thus, tomorrow's processors will require even more accurate branch prediction to deliver their potential performance. Recent studies <ref> [3, 6, 10, 16] </ref> have shown that conditional and indirect (or computed) branch targets can be accurately predicted by recording the path leading up to the branch. The path consists of the target addresses of the branches leading up to the current branch. <p> This has the advantage of being able to represent the path, albeit imperfectly. It has the disadvantage that information from fewer branches could be captured in the history. Jacobson et. al. <ref> [10] </ref> proposed a path based mechanism for predicting indirect branches in the multiscalar architecture. Their correlated task target buffer achieved substantial improvements in indirect branch prediction on the 5 SPECint92 benchmarks they used.
Reference: [11] <author> Q. Jacobson, E. Rotenberg, and J. E. Smith, </author> <title> "Path-based next trace prediction," </title> <booktitle> in Proceedings of the 30th Annual ACM/IEEE International Symposium on Mi-croarchitecture, </booktitle> <year> 1997. </year>
Reference-contexts: One promising idea is to save some history from before certain control structures such as loops or subroutines and then restore the history after the control structure ends. For instance, Jacobson et. al. <ref> [11] </ref> proposed to store some of the history information on a stack whenever a subroutine call was made. When returning from a subroutine, the old history would be popped from the stack. The old history would be combined with the more recent history to make any further predictions.
Reference: [12] <author> T. Juan, S. Sanjeevan, and J. J. Navarro, </author> <title> "Dynamic history-length fitting: A third level of adaptivity for branch prediction," </title> <booktitle> in Proceedings of the 25th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 155-166, </pages> <year> 1998. </year>
Reference-contexts: In their experiments, a global path history was shown to be better than per-address (i.e., per branch address) path histories. They also introduced a hybrid predictor where both components used global path histories but each component used a different length history. Juan et. al. <ref> [12] </ref> proposed variations of global pattern history based prediction schemes in which the number of pattern history bits used to generate an index into the PHT (s) was not fixed. At regular intervals, the hardware selected the number of history bits to be used for making predictions.
Reference: [13] <author> C.-C. Lee, I.-C. K. Chen, and T. N. Mudge, </author> <title> "The bi-mode branch predictor," </title> <booktitle> in Proceedings of the 30th Annual ACM/IEEE International Symposium on Microar-chitecture, </booktitle> <pages> pp. 4 - 13, </pages> <year> 1997. </year>
Reference-contexts: Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques <ref> [2, 13, 15, 18] </ref>. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6].
Reference: [14] <author> S. McFarling, </author> <title> "Combining branch predictors," </title> <type> Technical Report TN-36, </type> <institution> Digital Western Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: The lower bits of the branch address select the appropriate Pattern History Table (PHT) and the value in the branch history register (BHR) selects the appropriate 2-bit counter to use within that PHT. McFarling <ref> [14] </ref> introduced gshare, improving the GAs 2-level predictor by XORing the global branch history with bits of the branch address to generate the index into the PHT. This results in better utilization of the PHT, reducing interference and improving performance. <p> We compare the performance of these predictors to the performance of basic versions of other predictors (gshare <ref> [14] </ref> for conditional branches, and pattern and path based predictors for indirect branches [3]). Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques [2, 13, 15, 18]. <p> The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6]. Any of the predictors presented in this paper may be used as a component of a hybrid predictor <ref> [14] </ref> or a cascaded predictor [7]. 5.1 Methodology The results presented in this paper are for the eight SPECint95 benchmarks. We also present the results for eight other commonly used programs. <p> Two versions of the path predictor are used for both indirect and conditional predictions, the fixed length path predictor (without profiling) and the variable length path predictor (with profiling). For conditional branch prediction, these are compared to gshare <ref> [14] </ref>, and for indirect branch prediction, they are compared to the path and pattern based predictors presented in [3]. For the fixed length path predictor, the same path length was used for all benchmarks.
Reference: [15] <author> P. Michaud, A. Seznec, and R. Uhlig, </author> <title> "Trading conflict and capacity aliasing in conditional branch predictors," </title> <booktitle> in Proceedings of the 24th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 292-303, </pages> <year> 1997. </year>
Reference-contexts: Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques <ref> [2, 13, 15, 18] </ref>. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6].
Reference: [16] <author> R. Nair, </author> <title> "Dynamic path-based branch correlation," </title> <booktitle> in Proceedings of the 28th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 15-23, </pages> <year> 1995. </year>
Reference-contexts: As the pipeline depths and the issue rates increase, the amount of speculative work that must be thrown away in the event of a branch misprediction also increases. Thus, tomorrow's processors will require even more accurate branch prediction to deliver their potential performance. Recent studies <ref> [3, 6, 10, 16] </ref> have shown that conditional and indirect (or computed) branch targets can be accurately predicted by recording the path leading up to the branch. The path consists of the target addresses of the branches leading up to the current branch. <p> They showed that this predictor narrowly outperformed gshare for the SPECint92 benchmarks. They also proposed branch classification, a mechanism for letting the compiler select the predictor to use for each branch. Nair <ref> [16] </ref> proposed a dynamic path based predictor similar to the global version of the 2-level predictor. Instead of shifting branch outcomes into the branch history register, Nair's predictor would shift q bits of the branch target address into the history register.
Reference: [17] <author> R. L. </author> <title> Sites, Alpha Architecture Reference Manual, </title> <publisher> Dig--ital Press, </publisher> <address> Burlington, MA, </address> <year> 1992. </year>
Reference-contexts: Some ISAs already set aside a few bits in each branch instruction for profiling information. For example, the Alpha AXP ISA <ref> [17] </ref> sets aside 14 bits in each indirect branch instruction for profiling information.
Reference: [18] <author> E. Sprangle, R. S. Chappell, M. Alsup, and Y. N. Patt, </author> <title> "The agree predictor: A mechanism for reducing negative branch history interference," </title> <booktitle> in Proceedings of the 24th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 284-291, </pages> <year> 1997. </year>
Reference-contexts: Both the variable length path predictor and the predictors we compared it to can be enhanced. The conditional branch predictors can benefit from interference reduction techniques <ref> [2, 13, 15, 18] </ref>. The indirect branch predictors can benefit from better replacement algorithms for the target addresses stored in the predictor table [1, 6].
Reference: [19] <author> A. Srivastava and A. Eustace, </author> <title> "ATOM: A system for building customized program analysis tools," </title> <booktitle> in Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 196-205, </pages> <year> 1994. </year>
Reference-contexts: All benchmarks were compiled for the DEC Alpha architecture and instrumented with code to simulate the branch prediction structures using the ATOM instrumentation tool <ref> [19] </ref>. For those experiments requiring profiling, different profile and test input sets were used. Table 1 lists the benchmarks along with the static and dynamic count of conditional and indirect branches seen when running the test input set.
Reference: [20] <author> A. R. Talcott, M. Nemirovsky, and R. C. Wood, </author> <title> "The influence of branch prediction table interference on branch prediction scheme performance," </title> <booktitle> in Proceedings of the 1995 ACM/IEEE Conference on Parallel Architectures and Compilation Techniques, </booktitle> <year> 1995. </year>
Reference-contexts: In the variable length path predictor, N hash functions use one predictor table. Two branches that did not use the same predictor table entry during the first step may end up using the same predictor table entry in the variable length path predictor. This is called branch interference <ref> [20, 24] </ref>. The second step is used to reduce this interference. The second step is performed by simulating one variable length path predictor on the program being profiled. It is iterated several times. On each iteration, a set of candidates is selected and then tested.
Reference: [21] <author> M.-D. Tarlescu, K. B. Theobald, and G. R. Gao, </author> <title> "Elastic history buffer: A low-cost method to improve branch prediction accuracy," </title> <booktitle> in Proceedings of the 1997 International IEEE Conference on Computer Design, </booktitle> <pages> pp. 82-87, </pages> <year> 1997. </year>
Reference-contexts: The study included both pattern and path based predictors, and did not conclude which of the two was better. The path and pattern based predictors of the "tagless" variety from that study are used as the baseline for comparisons of indirect branch predictors in this paper. Tarlescu et. al. <ref> [21] </ref> proposed variations of the GAs 2-level predictor and the gshare predictor in which the number of pattern history bits used to generate an index into the PHT (s) was not fixed.
Reference: [22] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 24th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 51-61, </pages> <year> 1991. </year>
Reference-contexts: Section 4 discusses some of the implementation considerations. Experimental results are presented and discussed in Section 5, and some concluding remarks are provided in Section 6. 2 Related Work Various branch prediction strategies have been studied to improve prediction accuracy. Yeh and Patt proposed the Two-Level Adaptive Branch Predictor <ref> [22, 23] </ref> (referred to henceforth as the 2-level predictor) which uses two levels of history to make branch predictions.
Reference: [23] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Alternative implementations of two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 124-134, </pages> <year> 1992. </year>
Reference-contexts: Section 4 discusses some of the implementation considerations. Experimental results are presented and discussed in Section 5, and some concluding remarks are provided in Section 6. 2 Related Work Various branch prediction strategies have been studied to improve prediction accuracy. Yeh and Patt proposed the Two-Level Adaptive Branch Predictor <ref> [22, 23] </ref> (referred to henceforth as the 2-level predictor) which uses two levels of history to make branch predictions. <p> If the hardware is involved in the selection, run-time information can be incorporated into the decision. Storage structures are added to the branch predictor that record how accurately the hash functions have predicted each past branch. As with 2-level predictors <ref> [23] </ref>, this information may be recorded either per branch address, per branch set, or globally. For each branch, the hardware uses the information in the storage structures to dynamically select the hash function that has provided the highest accuracy in the past.
Reference: [24] <author> C. Young, N. Gloy, and M. D. Smith, </author> <title> "A comparative analysis of schemes for correlated branch prediction," </title> <booktitle> in Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 276-286, </pages> <year> 1995. </year>
Reference-contexts: In the variable length path predictor, N hash functions use one predictor table. Two branches that did not use the same predictor table entry during the first step may end up using the same predictor table entry in the variable length path predictor. This is called branch interference <ref> [20, 24] </ref>. The second step is used to reduce this interference. The second step is performed by simulating one variable length path predictor on the program being profiled. It is iterated several times. On each iteration, a set of candidates is selected and then tested.
Reference: [25] <author> C. Young and M. D. Smith, </author> <title> "Improving the accuracy of static branch prediction using branch correlation," </title> <booktitle> in Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 232-241, </pages> <year> 1994. </year>
Reference-contexts: McFarling also introduced the concept of hybrid branch predictors. A hybrid branch predictor consists of two or more component branch predictors and a mechanism to select which of these to use for each branch. Young and Smith <ref> [25] </ref> introduced the difference between pattern histories, containing branch outcomes, and path histories, containing branch addresses. They gave examples of branches being predictable using a path history but not with a pattern history.
References-found: 25

