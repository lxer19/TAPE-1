URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/podc.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Title: Open Systems in TLA  
Author: Martin Abadi and Leslie Lamport 
Affiliation: Digital Equipment Corporation Systems Research Center  
Abstract: We describe a method for writing assumption/guarantee specifications of concurrent systems. We also provide a proof rule for reasoning about the composition of these systems. Specifications are written in TLA (the Temporal Logic of Actions), and all reasoning is performed within the logic. Our proof rule handles internal variables and both safety and live-ness properties. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi and Leslie Lamport. </author> <title> Decomposing specifications of concurrent systems. </title> <booktitle> To appear in PROCOMET '94, Proceedings of the IFIP Working Conference on Programming Concepts, Methods and Calculi. </booktitle>
Reference-contexts: In this paper, we study how to specify open systems and how to reason about their composition. A companion paper considers the different problems that arise when a given system is decomposed into components <ref> [1] </ref>. Decomposition and composition are both discussed in more detail in [4]. 0 - System C d System D The setting for our work is temporal logic, where specifications are formulas and programs are viewed as lower-level specifications. <p> M 0 c implies M 0 d . As a less trivial example, in Section 6 we sketch the proof that the composition of two queues implements a larger queue. In Section 2, we review TLA and our method of specifying components. Much of this section also appears in <ref> [1] </ref>. Section 3 defines the operator + and Section 4 defines some additional operators. The Composition Theorem is given in Section 5. Section 6 illustrates how the concepts and results fit together. <p> Each formula P ^ V n is the conjunction of the specifications of components that together form a complete system. In fact, simple logical manipulation shows that this formula is equivalent to a canonical-form specification of that complete system <ref> [1] </ref>. Thus, each hypothesis asserts that a complete system satisfies a property R. In other words, the theorem reduces reasoning about assump tion/guarantee specifications to the kind of reasoning used for complete-system specifications. <p> = 999 999 q : IQM The specification of the environment as a separate component is QE = Init E ^ 2 [Q E ] hi:snd; o:acki (2) Page 7 - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ ^ Init E ^ Init <ref> [1] </ref> M ^ Init [2] ^ 2 6 4 _ Q M ^ hq 2 ; oi 0 = hq 2 ; oi [2] 3 7 hi; o; z; q 1 ; q 2 i CDQ = 999 999 q 1 ; q 2 : ICDQ system of Figure 7. 6.4 <p> QM , where QM and QE are defined in (1) and (2) of Section 6.3. The assumption/guarantee specifications of the two queues in Figure 7 are obtained from QE + . QM by substi tution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + We want to show that their composition implements the (2N + 1)-element queue specified by QE [dbl] + . The obvious thing to try to prove is (QE [1] + . QM [2] ) . <p> QM , where QM and QE are defined in (1) and (2) of Section 6.3. The assumption/guarantee specifications of the two queues in Figure 7 are obtained from QE + . QM by substi tution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + We want to show that their composition implements the (2N + 1)-element queue specified by QE [dbl] + . The obvious thing to try to prove is (QE [1] + . QM [2] ) . <p> QM by substi tution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + We want to show that their composition implements the (2N + 1)-element queue specified by QE [dbl] + . The obvious thing to try to prove is (QE [1] + . QM [2] ) . QM [dbl] ) We could prove this had we used a noninterleaving representation of the queue. However, (3) is not valid for an interleaving representation, for the following reason. <p> A similar problem is caused by simultaneous changes Page 8 1. C (QE [dbl] ) ^ C (G) ^ C (QM <ref> [1] </ref> ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> A similar problem is caused by simultaneous changes Page 8 1. C (QE [dbl] ) ^ C (G) ^ C (QM <ref> [1] </ref> ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> The resulting formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q <p> formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. <p> internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M <p> C (QE [dbl] ) +hi; o; zi ^ C (QM <ref> [1] </ref> ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. <p> C (IQM <ref> [1] </ref> ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. <p> (IQM <ref> [1] </ref> ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 4 (since disjointness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] <p> ; q 2 : Init <ref> [1] </ref> M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 4 (since disjointness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) C (QM [dbl] ) Proof: We use Propositions 2 and 1 to remove the quantifiers and closures from the formula. The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 3. 3. <p> The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 3. 3. QE [dbl] ^ G ^ QM <ref> [1] </ref> ^ QM [2] ) QM [dbl] Proof: A direct calculation shows that the left-hand side of the implication implies CDQ , the complete-system specification of the double queue. We already observed in Section 6.4 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. <p> We already observed in Section 6.4 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM <ref> [1] </ref> M 3 QM [2] M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. <p> We already observed in Section 6.4 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM <ref> [1] </ref> M 3 QM [2] M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [2] ) . <p> QM [dbl] E 1 true E 2 QE <ref> [1] </ref> E 3 QE [2] E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [2] ) .
Reference: [2] <author> Martin Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <type> Research Report 91, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1992. </year> <title> An earlier version, without proofs, </title> <booktitle> appeared in [8, </booktitle> <pages> pages 1-27]. </pages>
Reference-contexts: Page 3 Proposition 1 shows that this is the case when L is the conjunction of fairness properties (under reasonable assumptions). It is an immediate consequence of a result proved in <ref> [2] </ref>. <p> We can still apply Proposition 1 because, if C (P ^ L) = P and L implies R, then C (P ^ R) = P <ref> [2, Proposition 3] </ref>. 4 Additional Temporal Operators We now define two additional temporal operators. The first is useful in stating the Composition Principle; the second is an auxiliary operator important in verifying the hypotheses of the Composition Princi ple. <p> : IQM The specification of the environment as a separate component is QE = Init E ^ 2 [Q E ] hi:snd; o:acki (2) Page 7 - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ ^ Init E ^ Init [1] M ^ Init <ref> [2] </ref> ^ 2 6 4 _ Q M ^ hq 2 ; oi 0 = hq 2 ; oi [2] 3 7 hi; o; z; q 1 ; q 2 i CDQ = 999 999 q 1 ; q 2 : ICDQ system of Figure 7. 6.4 Implementing a Queue The <p> E ] hi:snd; o:acki (2) Page 7 - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ ^ Init E ^ Init [1] M ^ Init <ref> [2] </ref> ^ 2 6 4 _ Q M ^ hq 2 ; oi 0 = hq 2 ; oi [2] 3 7 hi; o; z; q 1 ; q 2 i CDQ = 999 999 q 1 ; q 2 : ICDQ system of Figure 7. 6.4 Implementing a Queue The complete system composed of two queues in series and their environment, shown in Figure 7, implements a single larger <p> QM , where QM and QE are defined in (1) and (2) of Section 6.3. The assumption/guarantee specifications of the two queues in Figure 7 are obtained from QE + . QM by substi tution; they are QE [1] + . QM [1] and QE <ref> [2] </ref> + We want to show that their composition implements the (2N + 1)-element queue specified by QE [dbl] + . The obvious thing to try to prove is (QE [1] + . QM [2] ) . <p> QM by substi tution; they are QE [1] + . QM [1] and QE <ref> [2] </ref> + We want to show that their composition implements the (2N + 1)-element queue specified by QE [dbl] + . The obvious thing to try to prove is (QE [1] + . QM [2] ) . QM [dbl] ) We could prove this had we used a noninterleaving representation of the queue. However, (3) is not valid for an interleaving representation, for the following reason. <p> However, a step that changes both z.snd and o.ack violates the second component queue's environment assumption QE <ref> [2] </ref> , permitting the component queue to make arbitrary changes to o.snd in the next step. A similar problem is caused by simultaneous changes Page 8 1. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: <p> violates the second component queue's environment assumption QE <ref> [2] </ref> , permitting the component queue to make arbitrary changes to o.snd in the next step. A similar problem is caused by simultaneous changes Page 8 1. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> QE <ref> [2] </ref> , permitting the component queue to make arbitrary changes to o.snd in the next step. A similar problem is caused by simultaneous changes Page 8 1. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> The resulting formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q <p> of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) <p> the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 <p> C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM <ref> [2] </ref> ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. <p> C (QM <ref> [2] </ref> ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 4 (since disjointness is a safety property). 2.2. <p> C (IQM <ref> [2] </ref> ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 4 (since disjointness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) C (QM <p> [1] M ^ Init <ref> [2] </ref> Proof: 2.1.1 and Proposition 2 (since any predicate is a safety property). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 4 (since disjointness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) C (QM [dbl] ) Proof: We use Propositions 2 and 1 to remove the quantifiers and closures from the formula. The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 3. 3. <p> The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 3. 3. QE [dbl] ^ G ^ QM [1] ^ QM <ref> [2] </ref> ) QM [dbl] Proof: A direct calculation shows that the left-hand side of the implication implies CDQ , the complete-system specification of the double queue. We already observed in Section 6.4 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. <p> We already observed in Section 6.4 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM [1] M 3 QM <ref> [2] </ref> M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. <p> Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM [1] M 3 QM <ref> [2] </ref> M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [2] ) . <p> true E 2 QE [1] E 3 QE <ref> [2] </ref> E QE [dbl] to i.snd and z.ack . We prove that the composition implements the larger queue under the assumption that the outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [2] ) .
Reference: [3] <author> Martin Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: Because E + . M is equivalent to C (E) . (C (M ) ^ (E ) M )), we can in principle convert any assumption/guarantee specification to one whose assumption is a safety property. (A similar observation appears as Theorem 1 of <ref> [3] </ref>.) However, this equivalence is of intellectual interest only. <p> To handle live ness, he wrote assumption/guarantee specifications Page 9 with implication instead of + ., so he did not obtain a strong composition theorem. Stark [15] also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work <ref> [3] </ref> was semantic, in a more complicated model with agents. It lacked practical proof rules for handling fairness and hiding. Collette [7] adapted this work to Unity. Abadi and Plotkin [5] used a propositional logic with agents, and considered only safety properties.
Reference: [4] <author> Martin Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <type> Research Report 118, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: In this paper, we study how to specify open systems and how to reason about their composition. A companion paper considers the different problems that arise when a given system is decomposed into components [1]. Decomposition and composition are both discussed in more detail in <ref> [4] </ref>. 0 - System C d System D The setting for our work is temporal logic, where specifications are formulas and programs are viewed as lower-level specifications. A specification S l implements another specification S iff S l ) S is valid. <p> We also consider only interleaving specifications, which assert that inputs and outputs do not change simultaneously. We discuss other specification styles in <ref> [4] </ref>. The specification M of a component has the "canonical form" 999 999x : Init ^ 2 [N ] v ^ L, where: v is the tuple hm; xi.
Reference: [5] <author> Martin Abadi and Gordon Plotkin. </author> <title> A logical view of composition and refinement. </title> <journal> Theoretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 3-30, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Perhaps the most obvious form for this assumption/guarantee specification is E ) M . Another appealing form is E . M , which asserts that M holds at least as long as E does <ref> [5] </ref>. Instead, we take as the specification the formula E + . M , which we define to mean that, for any n, if the environment satisfies E through "time" n, then the system must satisfy M through "time" n+1. More precisely, E . <p> Our earlier work [3] was semantic, in a more complicated model with agents. It lacked practical proof rules for handling fairness and hiding. Collette [7] adapted this work to Unity. Abadi and Plotkin <ref> [5] </ref> used a propositional logic with agents, and considered only safety properties. So far, we have applied our Composition Theorem only to toy examples. Formal reasoning about systems is still rare, and it generally occurs on a case-by-case basis.
Reference: [6] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: This argument does not apply to the second example, because violating M 1 c and M 1 d are sins of omission that do not occur at any particular instant. A property that can be made false only by being violated at some instant is called a safety property <ref> [6] </ref>. As the examples suggest, reasoning about the composition of assumption/guarantee specifications is easiest when assumptions are safety properties. Our rules for reasoning about the composition of assumption/guarantee specifications are embodied in the Composition Theorem of Section 5. <p> A safety property is a formula that is satisfied by an infinite behavior oe iff it is satisfied by every prefix of oe <ref> [6] </ref>. It can be shown that, for any TLA formula F , there is a TLA formula C (F ), called the closure of F , such that a behavior oe satisfies C (F ) iff every prefix of oe satisfies F .
Reference: [7] <author> Pierre Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, TAPSOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 230-242, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Stark [15] also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work [3] was semantic, in a more complicated model with agents. It lacked practical proof rules for handling fairness and hiding. Collette <ref> [7] </ref> adapted this work to Unity. Abadi and Plotkin [5] used a propositional logic with agents, and considered only safety properties. So far, we have applied our Composition Theorem only to toy examples. Formal reasoning about systems is still rare, and it generally occurs on a case-by-case basis.
Reference: [8] <editor> J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <title> Proceedings of a REX Real-Time Workshop, held in The Netherlands in June, </title> <year> 1991. </year>
Reference: [9] <author> Cliff B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332. </pages> <publisher> IFIP, North-Holland, </publisher> <month> September </month> <year> 1983. </year>
Reference-contexts: The specification of the circuit's environment must rule out such improper inputs. An open system calls for an assumption/guarantee specification, asserting that the system satisfies a guarantee only as long as its environment satisfies an assumption <ref> [9] </ref>. In this paper, we study how to specify open systems and how to reason about their composition. A companion paper considers the different problems that arise when a given system is decomposed into components [1].
Reference: [10] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year> <note> To appear in Transactions on Programming Languages and Systems. </note>
Reference-contexts: For such a theorem to be of any value, it must be accompanied by a precise logic for writing specifications and a method for verifying its hypotheses. The logic we use is TLA, the Temporal Logic of Actions <ref> [10] </ref>. We prove propositions helpful in verifying the hypotheses of the theorem for TLA specifications. Together with these propositions, the Composition Theorem allows us to reason about open systems using well-established, effective methods for reasoning about complete sys tems. <p> and no input variables, so its specification has this same form with v the tuple of all relevant variables. 2.3 Conditional Implementation A specification M l implements a specification M iff every behavior that satisfies M l also satisfies M , that is, iff M l ) M is valid <ref> [10] </ref>. Instead of proving that a specification M l implements a specification M , we sometimes want to prove the weaker condition that M l implements M assuming a formula G. <p> The composite system implements a (2N + 1)- element queue; formally, CDQ ) CQ [dbl] is valid. This result is proved by standard TLA reasoning using a simple refinement mapping <ref> [10] </ref>. 6.5 Composing Open Queues In Section 6.4, we specified the composition of two queues with their environment directly as a complete system, and stated that it implements a larger queue with its environment. We now consider open queues, described by assumption/guarantee specifications.
Reference: [11] <author> Carver Mead and Lynn Conway. </author> <title> Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1980. </year>
Reference-contexts: M l ) ) (E + . M ). Page 5 6 The Queue Example 6.1 Informal Description of the Queue In our example, we consider systems that communicate by using a standard two-phase handshake protocol <ref> [11] </ref> to send values over channels. The state of a channel c is described by three components: the value c.val that is being sent, and two bits c.sig and c.ack used for synchronization. We let c:snd denote the pair hc:sig ; c:val i. <p> This problem is not an artifact of our particular representation of the queue; actual hardware implementations of a queue can enter metastable states, consequently producing bizarre, unpredictable behavior, if their inputs are changed when they are not supposed to be <ref> [11] </ref>.
Reference: [12] <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(4):417-426, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: Like ours, most previous composition theorems were strong, in the sense that they could handle circularities in reasoning about safety properties. Our approach differs from previous ones in its general treatment of fairness properties and hiding. The first strong composition theorem we know is that of Misra and Chandy <ref> [12] </ref>, who considered safety properties of processes communicating by means of CSP primitives. They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph [13] extended this approach to handle some liveness properties. Pnueli [14] was the first to use temporal logic to write assumption/guarantee specifications.
Reference: [13] <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logic|a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference-contexts: The first strong composition theorem we know is that of Misra and Chandy [12], who considered safety properties of processes communicating by means of CSP primitives. They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph <ref> [13] </ref> extended this approach to handle some liveness properties. Pnueli [14] was the first to use temporal logic to write assumption/guarantee specifications. He had a strong composition theorem for safety properties with no hiding.
Reference: [14] <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI Series, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1984. </year>
Reference-contexts: They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph [13] extended this approach to handle some liveness properties. Pnueli <ref> [14] </ref> was the first to use temporal logic to write assumption/guarantee specifications. He had a strong composition theorem for safety properties with no hiding. To handle live ness, he wrote assumption/guarantee specifications Page 9 with implication instead of + ., so he did not obtain a strong composition theorem.
Reference: [15] <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391, </pages> <address> Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher> <pages> Page 10 </pages>
Reference-contexts: He had a strong composition theorem for safety properties with no hiding. To handle live ness, he wrote assumption/guarantee specifications Page 9 with implication instead of + ., so he did not obtain a strong composition theorem. Stark <ref> [15] </ref> also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work [3] was semantic, in a more complicated model with agents. It lacked practical proof rules for handling fairness and hiding. Collette [7] adapted this work to Unity.
References-found: 15

