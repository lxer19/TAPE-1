URL: http://bugle.cs.uiuc.edu/People/elford/phd/Papers/thesis.ps.gz
Refering-URL: http://bugle.cs.uiuc.edu/People/elford/phd/
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by Christopher Lloyd Elford 
Date: 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Almasi, G. S., and Gottlieb, A. </author> <title> Highly Parallel Computing. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: If the array is stored in column major order, a single, large input/output disk transaction results. Using Fortran-D and HPF data array distributions <ref> [1] </ref> as a model, Bordawekar et al [3] considered a variety of multiple disk mappings for out of core arrays. Allowing applications to explicitly control out of core array data layout can reduce the occurrence of small disk accesses that cause poor performance.
Reference: [2] <author> Bennett, R., Bryant, K., Sussman, A., Das, R., and Saltz, J. Jovian: </author> <title> A Framework for Optimizing Parallel I/O. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference (Mississippi State, </booktitle> <address> MS, October 1994), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 10-20. </pages>
Reference-contexts: If the file system API provides unique routines for each common access pattern, the file system will implicitly know the access pattern whenever they are used (e.g., row or column access methods for accessing out of core arrays). Substantial performance improvements have been reported using these implicit techniques <ref> [2, 4, 46, 55] </ref>. Unfortunately, this approach forces users to modify their applications to perform input/output using only supported access patterns. This may constrain application scientists as they choose algorithms, potentially reducing the feasibility of parallel computation for new application domains. <p> Two-phase input/output determines the aggregate portions of the out of core array accessed across the processors, schedules the largest possible disk transfers to read or write this data, then redistributes the data portions to the appropriate processors. Galley [46], Panda [55], PASSION [4], and Jovian <ref> [2] </ref> all support out of core multi-dimensional arrays. These array based systems can reorder disk data distributions and aggregate input/output requests to more effectively utilize disk bandwidth. In addition to providing out of core array access primitives, Galley also provides a suite of explicit data layout primitives. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output [3, 37] are applied to optimize performance. Most out of core interfaces <ref> [2, 4, 46, 55] </ref> require the application programmer to explicitly read and write out of core data slices using row and column file access primitives.
Reference: [3] <author> Bordawekar, R., del Rosario, J. M., and Choudhary, A. </author> <title> Design and Evaluation of Primitives for Parallel I/O. </title> <booktitle> In Proceedings of Supercomputing '93 (Portland, </booktitle> <address> OR, 1993), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 452-461. </pages>
Reference-contexts: If the array is stored in column major order, a single, large input/output disk transaction results. Using Fortran-D and HPF data array distributions [1] as a model, Bordawekar et al <ref> [3] </ref> considered a variety of multiple disk mappings for out of core arrays. Allowing applications to explicitly control out of core array data layout can reduce the occurrence of small disk accesses that cause poor performance. When explicit control over data layout is impossible, Bordawekar et al apply two-phase input/output. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output <ref> [3, 37] </ref> are applied to optimize performance. Most out of core interfaces [2, 4, 46, 55] require the application programmer to explicitly read and write out of core data slices using row and column file access primitives.
Reference: [4] <author> Bordawekar, R., Thakur, R., and Choudhary, A. </author> <title> Efficient Compilation of Out-of-Core Data Parallel Programs. </title> <type> Tech. Rep. SCCS-622, </type> <institution> NPAC, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: If the file system API provides unique routines for each common access pattern, the file system will implicitly know the access pattern whenever they are used (e.g., row or column access methods for accessing out of core arrays). Substantial performance improvements have been reported using these implicit techniques <ref> [2, 4, 46, 55] </ref>. Unfortunately, this approach forces users to modify their applications to perform input/output using only supported access patterns. This may constrain application scientists as they choose algorithms, potentially reducing the feasibility of parallel computation for new application domains. <p> Two-phase input/output determines the aggregate portions of the out of core array accessed across the processors, schedules the largest possible disk transfers to read or write this data, then redistributes the data portions to the appropriate processors. Galley [46], Panda [55], PASSION <ref> [4] </ref>, and Jovian [2] all support out of core multi-dimensional arrays. These array based systems can reorder disk data distributions and aggregate input/output requests to more effectively utilize disk bandwidth. In addition to providing out of core array access primitives, Galley also provides a suite of explicit data layout primitives. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output [3, 37] are applied to optimize performance. Most out of core interfaces <ref> [2, 4, 46, 55] </ref> require the application programmer to explicitly read and write out of core data slices using row and column file access primitives. <p> Ideally, if the user allocates an array larger than the physical memory, compiler optimizations could automatically generate these row and column file access primitives to stage data through memory. PASSION <ref> [4] </ref> has been used as a compiler target that allows such compile time input/output optimizations. With these compiler optimizations, the user can potentially use conventional memory array traversal techniques on out of core arrays that are automatically translated into efficient PASSION operations. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in x3.1 3.3.5 Sequential Subfile Access Many parallel input/output systems such as PFS [29], PIOFS [35], Vesta [20], Passion <ref> [4] </ref>, and PPFS [28] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [5] <author> Box, G. E., and Draper, N. R. </author> <title> Evolutionary Operation. </title> <publisher> John Wiley and Sons, </publisher> <year> 1969. </year>
Reference-contexts: and x7.7, we discuss the limitations of our stable sensor algorithm and how they impact dynamic steering. 7.1 Sensor Metric Variability In any computing environment, independent system factors impact the performance of a steady stream of otherwise identical user input/output requests (i.e., noise factors unrelated to the input/output request stream) <ref> [5, 7, 31] </ref>. On parallel platforms, these factors include periodic file system cache flushes, network hot spots, operating system bookkeeping operations, and virtual 93 a) Individual Read Durations b) Read Duration Averages memory paging overheads.
Reference: [6] <author> Brogan, W. L. </author> <title> Modern Control Theory. </title> <publisher> Quantum Publishers Inc., </publisher> <year> 1974. </year>
Reference-contexts: Closed loop, or feedback based control systems, in contrast to open loop systems can maintain a high degree of accuracy even in the presence of system complications. 5.2 Classical Control Theory Feedback control theory applies mathematical analysis to solve closed loop control problems <ref> [6, 15, 63] </ref>. This subject allows rigorous mathematical modeling and design of feedback control systems. The following process applies formal control theory to a problem [54]. 1. Establish performance specifications (i.e., define what constitutes good or optimal perfor mance). 2.
Reference: [7] <author> Brown, R. G. </author> <title> Smoothing, Forcasting and Prediction of Discrete Time Series. </title> <publisher> Prentice Hall, </publisher> <year> 1963. </year>
Reference-contexts: and x7.7, we discuss the limitations of our stable sensor algorithm and how they impact dynamic steering. 7.1 Sensor Metric Variability In any computing environment, independent system factors impact the performance of a steady stream of otherwise identical user input/output requests (i.e., noise factors unrelated to the input/output request stream) <ref> [5, 7, 31] </ref>. On parallel platforms, these factors include periodic file system cache flushes, network hot spots, operating system bookkeeping operations, and virtual 93 a) Individual Read Durations b) Read Duration Averages memory paging overheads.
Reference: [8] <author> Chen, P. M., and Patterson, D. A. </author> <title> A New Approach to I/O Performance Evaluation - Self-Scaling I/O Benchmarks, Predicted I/O Performance. </title> <booktitle> In Proceedings of the 1993 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems (May 1993), Association For Computing Machinery, </booktitle> <pages> pp. 1-12. </pages>
Reference-contexts: These monotonic ranges are directly related to the resources available for use by the input/output library on the underlying platform. Monotonic policy ranges for continuous policy factors such as cache sizes or prefetch quantities can be conservatively estimated using a variation of self scaling input/output benchmarks <ref> [8] </ref> (e.g., to identify a monotonic range for the cache size, start with a small cache and incrementally double its size until performance degrades). After identifying the low to high range for each of the k factors, one must observe the performance of the resulting 2 k cross product combinations.
Reference: [9] <author> Corbett, P. F., Prost, J.-P., Demetriou, C., Gibson, G., Reidel, E., Zelenka, J., Chen, Y., Felten, E., Li, K., Hartman, J., Peterson, L., Bershad, B., Wol 180 man, A., and Aydt, R. </author> <title> Proposal for a Common Parallel File System Programming Interface. </title> <note> WWW http://www.cs.arizona.edu/sio/api1.0.ps, September 1996. Version 1.0. </note>
Reference-contexts: The simplest approach for obtaining access pattern information allows the user to explicitly tell the file system about the access pattern. If possible, the file system enables policies that optimize performance when users specify this access pattern information <ref> [35, 29, 61, 9] </ref>. Unfortunately, users may not know enough about the spatial and temporal aspects of their 1 access patterns to inform the file system. Users may need to invest considerable effort manually analyzing their applications and data before specifying appropriate explicit access patterns. <p> MPI-IO also provides file views similar to those provided by PIOFS. While MPI-IO is intended as a user-level programming interface, the Scalable Input/Output Initiative (SIO) has defined a low level portable parallel input/output interface <ref> [9] </ref>. The SIO API supports synchronous and asynchronous input/output, several types of collective input/output operations, and a rich variety of hints for specifying access pattern information. The low level SIO API is intended to facilitate the creation of high performance higher level portable input/output libraries.
Reference: [10] <author> Cox, E. </author> <title> The Fuzzy Systems Handbook. </title> <publisher> The Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: In actuality, there is really little difference between requests at the upper end of one selector rule and the lower end of another rule. Fuzzy sets and fuzzy logic potentially allow a more continuous gradation of policy choices as access pattern characteristics change <ref> [10] </ref>. As shown in Figure 10.1, rather than declaring that all requests for fewer than 4096 bytes are small, a fuzzy set would state that one byte requests are certainly small and that 128 KB requests are certainly large.
Reference: [11] <author> Crandall, P. E., Aydt, R. A., Chien, A. A., and Reed, D. A. </author> <title> Input/Output Characteristics of Scalable Parallel Applications. </title> <booktitle> In Proceedings of Supercomputing '95 (San Diego, </booktitle> <address> CA, December 1995), </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Parallel scientific applications frequently access non-sequential but non-random parts of shared parallel files (e.g., data is often equally partitioned among processors). Unfortunately, this non-sequential behavior often defeats traditional input/output optimization strategies. The variety of parallel input/output taxonomies and parallel application characterization from the Scalable Input/Output Initiative (SIO) <ref> [11, 57] </ref> demonstrate the complex input/output resource requirements of parallel applications. Because parallel input/output is typically more varied than uniprocessor input/output, it is unlikely that uniprocessor file system policies are sufficient to optimize parallel file system performance. <p> We begin in x3.1 by describing a suite of high performance, parallel scientific applications and their approach to performing input/output. We continue in x3.2 with a discussion of the input/output characterization of these applications. This characterization helps demonstrate the complexity of parallel scientific input/output workloads <ref> [11, 57] </ref>. In x3.3, we present a parallel access pattern taxonomy based on the parallel input/output characterization effort and extant taxonomies. Our taxonomy allows us to more formally compare and contrast the SIO applications. <p> pattern differs from the write access pattern in the ESCAT application for which each node sequentially wrote a contiguous block of records to the file. 3.1.3 Hartree-Fock Calculations (MESSKIT) The Hartree-Fock (MESSKIT) application is an ab initio chemistry code that computes the bond strengths and reaction energies for chemical reactions <ref> [11] </ref>. The MESSKIT implementation of the Hartree Fock calculations consists of three separate programs that cooperate to calculate the non-relativistic interactions between atomic nuclei and electrons using a self consistent field (SCF) technique until the molecular density converges. <p> In contrast to uniprocessor applications which typically exhibit simple, sequential access patterns, these applications exhibit a variety of complex file access techniques. To emphasize the complexity and variety of parallel input/output, we now summarize part of the input/output performance characterization of the four applications described in x3.1 <ref> [11, 57] </ref>. 3.2.1 SIO Application Characterization The ESCAT application discussed in x3.1.1 is typical of many parallel applications. It begins with an initialization input phase, followed by periodic input/output during application execution, coupled with a final result output phase. <p> The input/output characterization of the SIO application suite such as that shown in Figures 3.1-3.4 has resulted in several general observations <ref> [11, 57] </ref> about parallel scientific input/output. 27 Intel Paragon; 128 Application Nodes Intel Paragon; 64 Application Nodes 28 3.2.2.1 Portable Input/Output Interfaces Some application developers are willing to forgo portable UNIX input/output constructs and instead use system dependent API routines to improve parallel input/output performance. <p> In particular, we considered the MESSKIT Hartree Fock application discussed in x3.1.3. We chose this application because it is one of more heavily input/output bound applications in the SIO application suite and it has been heavily characterized <ref> [11] </ref>. 9.3.1 Baseline Application Performance Recall from chapter 3 that the MESSKIT application consists of three phases. The brief initialization phase configures application data structures and files. The second, write intensive, phase performs numerical quadrature to compute electron energies and writes the resulting 80 KB integral results to a file.
Reference: [12] <author> Crockett, T. W. </author> <title> File Concepts for Parallel I/O. </title> <booktitle> In Proceedings of Supercomputing '89 (1989), </booktitle> <pages> pp. 574-579. </pages>
Reference-contexts: In particular, uniprocessor workloads are either sequential or random. Because most accesses are sequential, simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output workloads, on the other hand, have been described using several taxonomies <ref> [12, 36, 43] </ref>. Parallel scientific applications frequently access non-sequential but non-random parts of shared parallel files (e.g., data is often equally partitioned among processors). Unfortunately, this non-sequential behavior often defeats traditional input/output optimization strategies. <p> Input/output performance is often determined by the specific input/output routines applied rather than the application level input/output cause. Consequently, cause based taxonomies does not provide sufficient information to optimize input/output performance. In contrast to typed input/output taxonomies, other input/output taxonomies such as Crockett <ref> [12] </ref> and Kotz [36] define parallel input/output by the relative sizes and spacings of requests within a file. Neither of these taxonomies are sufficiently rich to describe the input/output behavior exhibited by the SIO application suite.
Reference: [13] <author> DeGroot, M. H. </author> <title> Probability and Statistics. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: As described in chapter 6, our original prototype infrastructure used Pablo SWAVE window averages as sensor metrics. To estimate the central tendency of a data series with an average (i.e., the sample mean), one must ensure that the underlying sample distribution is neither bimodal nor skewed <ref> [13, 30] </ref>. If the the underlying sample distribution is bimodal, averaging very large samples with very small samples will generate a mean that is representative of neither subset. In these cases, the mode (i.e., the most common sample value) may be the most effective 96 estimator of central tendency [30]. <p> Because the trimmed mean metric is the average of several event values, the confidence interval is a function of the variance of these values. The median metric, on the other hand, selects a single, representative, event value from the data series. The confidence interval of the median <ref> [13] </ref> is simply the range between two fixed members of the sorted data series (i.e., it ignores the variance of the data). We use trimmed sensor metrics and median sensor metrics instead of sample mean metrics because they effectively reduce outlier effects.
Reference: [14] <author> Douglis, F. </author> <title> Process Migration in the Sprint Operating System. </title> <type> Tech. rep., </type> <institution> University of California at Berkeley, </institution> <month> Feb. 87. </month>
Reference-contexts: As one example of these systems, the Sprite operating system <ref> [14] </ref> applied several rules to determine when and where processes should be migrated. One rule verified that the load on the destination was lower than on the source.
Reference: [15] <author> Doyle, J. C., Francis, B. A., and Tannenbaum, A. R. </author> <title> Feedback Control Theory. </title> <publisher> Macmillan Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: Closed loop, or feedback based control systems, in contrast to open loop systems can maintain a high degree of accuracy even in the presence of system complications. 5.2 Classical Control Theory Feedback control theory applies mathematical analysis to solve closed loop control problems <ref> [6, 15, 63] </ref>. This subject allows rigorous mathematical modeling and design of feedback control systems. The following process applies formal control theory to a problem [54]. 1. Establish performance specifications (i.e., define what constitutes good or optimal perfor mance). 2.
Reference: [16] <author> Eisenhauer, G., Gu, W., Schwan, K., and Mallavarupu, N. </author> <title> Falcon Toward Interactive Parallel Programs: The On-line Steering of a Molecular Dynamics Application. </title> <booktitle> In Proceedings of High-Performance Distributed Computing '94 (August 1994). </booktitle>
Reference-contexts: Using a basic feedback system as a model, the Falcon project has produced a general framework for computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions. Using Falcon, Eisenhauer et al <ref> [16] </ref> modified a parallel molecular dynamics application to allow interactive 15 steering using three different actuators. By interactively changing policies for a four processor parallel execution, they achieved near linear speedup. While interactive steering accommodates significant performance improvements, Eisenhauer et al discuss the limitations of interactive steering.
Reference: [17] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Design of a Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Policies that provide effective parallel input/output performance can be set aside for eventual inclusion in vendor file system library implementations. 4.3.1 PPFS Input/Output Model In designing PPFS, we invested substantial effort to create an extensible infrastructure for portable parallel input/output <ref> [17, 18, 19] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers that are accessed by application clients.
Reference: [18] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Portable Parallel File System Detailed Design. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Policies that provide effective parallel input/output performance can be set aside for eventual inclusion in vendor file system library implementations. 4.3.1 PPFS Input/Output Model In designing PPFS, we invested substantial effort to create an extensible infrastructure for portable parallel input/output <ref> [17, 18, 19] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers that are accessed by application clients.
Reference: [19] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Scenarios for the Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Policies that provide effective parallel input/output performance can be set aside for eventual inclusion in vendor file system library implementations. 4.3.1 PPFS Input/Output Model In designing PPFS, we invested substantial effort to create an extensible infrastructure for portable parallel input/output <ref> [17, 18, 19] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers that are accessed by application clients.
Reference: [20] <author> Feitelson, D. G., Corbett, P. F., and Prost, J.-P. </author> <title> Performance of the Vesta parallel file system. </title> <booktitle> In Proceedings of the Ninth International Parallel Processing Symposium (April 1995), </booktitle> <pages> pp. 150-158. </pages>
Reference-contexts: This interface accommodates specification of a rich variety of input/output workloads. Most commercial parallel file systems offer some user control over data distribution and cache consistency. IBM's PIOFS [35], the commercial offshoot of Vesta <ref> [20] </ref>, allows users to specify the number of cells (i.e., logical disks) to use for a file, as well as a sophisticated technique for partitioning data among these logical cells so that more than simple data striping can be 12 achieved. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in x3.1 3.3.5 Sequential Subfile Access Many parallel input/output systems such as PFS [29], PIOFS [35], Vesta <ref> [20] </ref>, Passion [4], and PPFS [28] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [21] <author> Foster, I., and Nieplocha, J. </author> <title> ChemIO: High-Performance I/O for Computational Chemistry Applications. </title> <note> WWW http://www.mcs.anl.gov/chemio/, February 1996. </note>
Reference-contexts: Implementations of these user interfaces can provide platform dependent optimizations. Unfortunately, these interfaces tend to provide little standardized support for converting files between different systems and application domains. 10 As an example of these domain specific input/output libraries, ChemIO <ref> [21] </ref> is an API that allows the development of portable, high-performance computational chemistry codes without requiring the user to concentrate on making system dependent parallel input/output optimizations.
Reference: [22] <author> Gheith, A., Mukherjee, B., Silva, D., and Schwan, K. KTK: </author> <title> Kernel Support for Configurable Objects and Invocations. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-11, College of Computing, Georgia Institute of Technology, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Using computational steering, we hope to provide high performance to users without requiring them to invest substantial effort manually optimizing policies. Computational steering has been successfully applied in other application domains to choose effective policies (e.g., dynamic spin lock policy management <ref> [22, 44] </ref>). Dynamic computational steering of parallel file system policies requires the system to monitor workloads and performance metrics summarizing system behavior. The system then uses these metrics to detect conditions requiring policy refinement and enables the resulting policy choices. <p> Falcon supports both interactive and automated steering. Automated run time steering is used in Falcon to select different mutual exclusion lock configurations based on the number of threads blocked on the lock <ref> [22, 44] </ref>. An adaptation module executes code that examines sensor variables and sets the lock parameters. For example, if the number of threads waiting on a lock exceeds some threshold, the lock manager changes the number of iterations that a given thread should spin on the lock before sleeping.
Reference: [23] <author> Grimshaw, A. S., and Loyot, Jr., E. C. </author> <title> ELFS: object-oriented extensible file systems. </title> <booktitle> In Proceedings of the First International Conference on Parallel and Distributed Information Systems (December 1991), </booktitle> <address> p. </address> <month> 177. </month>
Reference-contexts: Using an object-oriented design, other systems allow the definition of additional input/output file data models. The ELFs system <ref> [23] </ref> defines an extensible framework of file types. When one creates a new type of ELFs file, [s]he not only implements an appropriate interface but also implements performance optimizations for the new file type.
Reference: [24] <author> Gropp, W., and Lusk, E. </author> <title> User's Guide for MPICH, a Portable Implementation of MPI. </title> <type> Tech. Rep. </type> <institution> ANL/MCS-TM-000, Argonne National Lab, </institution> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: These interfaces allow users to use the same input/output syntax across parallel platforms. Using hints, the user can inform the underlying implementations of important characteristics of their input/output access patterns. The implementation can use these hints to optimize performance. The emerging MPI-IO [61] interface for MPI <ref> [24] </ref> provides an extensive set of processor local and collective input/output routines. The user can create files composed of MPI data type elements and provide hints detailing input/output coordination between nodes using MPI groups and communicators. MPI-IO also provides file views similar to those provided by PIOFS.
Reference: [25] <author> Gu, W., Eisenhauer, G., Kraemer, E., Schwan, K., Stasko, J., and Vetter, J. </author> <title> Falcon: On-Line Monitoring and Steering of Large-Scale Parallel Programs. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-21, College of Computing, Georgia Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: Essentially, SciRun is a toolkit that enables computational steering for computational chemistry applications. The application scientist can concentrate on their chemistry algorithms and utilize SciRun visualization widgets rather than having to implement their own. While SciRun concentrates on the visualization aspects of interactive steering, the Falcon project <ref> [65, 25] </ref> provides a more general framework for dynamic steering. Using a basic feedback system as a model, the Falcon project has produced a general framework for computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions.
Reference: [26] <author> Gu, W., Vetter, J., and Schwan, K. </author> <title> An Annotated Bibliography of Interactive Program Steering. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-15, College of Computing, Georgia Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: The Meta-Toolkit also defines the NPL expression language for expressing rules that map sensors to actuators. While this section has summarized several representative examples of interactive and automated computational steering projects, these projects abound because dynamic performance optimization is a common goal in computer science. Gu, Vetter, and Schwan <ref> [26] </ref> have compiled a literature survey of many of these computational steering projects. 17 2.4 Summary As described in x2.1, a variety of policies for optimizing parallel input/output performance have been proposed. To complement these proposed policies, x2.2 discusses the range of parallel input/output systems that attempt to implement them.
Reference: [27] <author> Henderson, R. D., and Karniadakis, G. E. </author> <title> Unstructured Spectral Element Methods for Simulation of Turbulent Flows. </title> <journal> Journal of Computational Physics 122(2) (1995), </journal> <pages> 191-217. </pages>
Reference-contexts: However, instead of using small accesses for each shell level record, all energy shell records are accessed as a single, large read. 3.1.2 Incompressible Navier-Stokes (PRISM) The incompressible Navier-Stokes (PRISM) application performs a 3-D numerical simulation of periodic fluid flow <ref> [27] </ref> such as flow past a cylinder or over a step. This application calculates the dynamics of turbulent flow subject to initial velocity conditions and a set of constraints. For each time step, numerical integration is used to compute the advection and momentum diffusion of the fluid.
Reference: [28] <author> Huber, J., Elford, C. L., Reed, D. A., Chien, A. A., and Blumenthal, D. S. </author> <title> PPFS: A High Performance Portable Parallel File System. </title> <booktitle> In Proceedings of the 9th ACM International Conference on Supercomputing (Barcelona, </booktitle> <address> July 1995), </address> <publisher> ACM Press, </publisher> <pages> pp. 385-394. </pages>
Reference-contexts: This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in x3.1 3.3.5 Sequential Subfile Access Many parallel input/output systems such as PFS [29], PIOFS [35], Vesta [20], Passion [4], and PPFS <ref> [28] </ref> implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file. <p> By manually specifying data distribution, caching, write back, and prefetch controls, we dramatically improved the input/output performance of several benchmarks and production parallel applications relative to native parallel file system performance <ref> [28, 58] </ref>. Unfortunately, to obtain good performance using PPFS, the user must invest considerable effort exploring file system policies to determine the best one for their workload. <p> The results in Table 4.1 are representative of the performance improvements that are possible by manually configuring policies to match the workload for a variety of access patterns <ref> [28, 58] </ref>. 64 Application nodes, 12 MAXTOR RAID-3 Devices 4.4.2 PPFS Application Performance File access pattern benchmarks such as those discussed above allow one to estimate asymptotic performance of file system policies.
Reference: [29] <author> Intel Corporation. </author> <title> Paragon System User's Guide. </title> <publisher> Intel SSD, </publisher> <address> Beaverton, OR, </address> <year> 1995. </year>
Reference-contexts: The simplest approach for obtaining access pattern information allows the user to explicitly tell the file system about the access pattern. If possible, the file system enables policies that optimize performance when users specify this access pattern information <ref> [35, 29, 61, 9] </ref>. Unfortunately, users may not know enough about the spatial and temporal aspects of their 1 access patterns to inform the file system. Users may need to invest considerable effort manually analyzing their applications and data before specifying appropriate explicit access patterns. <p> A CAUTIOUS/RECKLESS mode switch allows users to specify cache consistency requirements. Intel's PFS <ref> [29] </ref>, on the other hand, provides a series of ioctl () calls to specify the striping unit and the number of disks to use. In addition, ioctl () calls can be used to gain more control over caching behavior. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in x3.1 3.3.5 Sequential Subfile Access Many parallel input/output systems such as PFS <ref> [29] </ref>, PIOFS [35], Vesta [20], Passion [4], and PPFS [28] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [30] <author> Jain, R. </author> <title> The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1991. </year>
Reference-contexts: As described in chapter 6, our original prototype infrastructure used Pablo SWAVE window averages as sensor metrics. To estimate the central tendency of a data series with an average (i.e., the sample mean), one must ensure that the underlying sample distribution is neither bimodal nor skewed <ref> [13, 30] </ref>. If the the underlying sample distribution is bimodal, averaging very large samples with very small samples will generate a mean that is representative of neither subset. In these cases, the mode (i.e., the most common sample value) may be the most effective 96 estimator of central tendency [30]. <p> If the the underlying sample distribution is bimodal, averaging very large samples with very small samples will generate a mean that is representative of neither subset. In these cases, the mode (i.e., the most common sample value) may be the most effective 96 estimator of central tendency <ref> [30] </ref>. If the underlying sample distribution is skewed, averaging a few samples from a substantially different distribution may generate a deceptive mean. <p> While some policies can be pruned using common sense, the relative importance of other policies must be determined experimentally for each workload. To determine which of a set of policies most impact performance, we apply factor analysis <ref> [30, 59] </ref>. Factor analysis generates a breakdown of each policy and combination of policies and the degree they affect input/output performance. By removing all policies that account for less than five to ten percent of performance variation, the size of the cross product policy search space can be further reduced. <p> selector rule creation heuristic that seeks to improve input/output performance and reduce overall input/output resource requirements. 8.2 Primary Factor Analysis Factor analysis is a technique to statistically determine the dominant subset of a set of discrete variables or factors each of which impacts the performance or response of a process <ref> [30, 59] </ref>. <p> Variation 2 2 q 2 B + q 2 A 2 2 fi q 2 AB Fraction 1 q 2 q 2 B +q 2 q 2 q 2 B +q 2 q 2 q 2 B +q 2 Table 8.1: 2 2 Factor Analysis Sign Table As described in <ref> [30] </ref>, the 2 k cross product performance observations are then used as y i to solve for the 2 k unknown q i regression coefficients. Because of the simple positive/negative definition of the x i regression variables, a sign matrix can be used to simplify the nonlinear regression calculations. <p> The values of the q i coefficients in the nonlinear regression Equation 8.2 can now be computed by calculating the dot product of the observation vector Y with each column vector X of regression variables as shown in Table 8.1 <ref> [30] </ref>. As derived in [30], after computing the q i regression coefficients, the variation attributable to a given q i is 2 k q 2 i . <p> The values of the q i coefficients in the nonlinear regression Equation 8.2 can now be computed by calculating the dot product of the observation vector Y with each column vector X of regression variables as shown in Table 8.1 <ref> [30] </ref>. As derived in [30], after computing the q i regression coefficients, the variation attributable to a given q i is 2 k q 2 i . Similarly, the fraction of variation is the variation attributable to q i divided by the sum of the variation attributed to all the q i . <p> If executing 2 k experiments for each workload is prohibitively expensive, the number of experiments can be reduced using 2 (kn) factor analysis at the expense of design resolution <ref> [30, 59] </ref>. In this type of analysis, n is a parameter that determines the number of experiments required. The resolution of a factor analysis design is a measure of its ability to differentiate between different combinations of factors. <p> Sign matrices for 2 (kn) factor analysis with the highest possible resolution for a wide range of k and n are given in [59]. In addition, <ref> [30] </ref> discusses how sign matrices can be created for arbitrary k and n. One must be sure to choose a sign matrix that maximizes factor analysis design resolution.
Reference: [31] <author> Kanjilal, P. P. </author> <title> Adaptive Prediction and Pedictive Control. </title> <note> Short Run Press, 1995. 182 </note>
Reference-contexts: In contrast to simple control theory models, which can be solved using linear partial differential equation techniques, complex control processes require a nonlinear optimization. A host of methods potentially improve the tractability of special instances of nonlinear, complex control models <ref> [31] </ref>. Unfortunately, no standard methodology exists to solve an arbitrary nonlinear control problem. Instead, designers must apply different methods until they find a tractable approach. <p> and x7.7, we discuss the limitations of our stable sensor algorithm and how they impact dynamic steering. 7.1 Sensor Metric Variability In any computing environment, independent system factors impact the performance of a steady stream of otherwise identical user input/output requests (i.e., noise factors unrelated to the input/output request stream) <ref> [5, 7, 31] </ref>. On parallel platforms, these factors include periodic file system cache flushes, network hot spots, operating system bookkeeping operations, and virtual 93 a) Individual Read Durations b) Read Duration Averages memory paging overheads.
Reference: [32] <author> Kasabov, N. K. </author> <title> Foundations of Neural Networks, Fuzzy Systems, and Knowledge Engi--neering. </title> <publisher> The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Even if one designs such a controller, analyzing the model and solving the resulting nonlinear differential equations to produce a dynamic control function f (x 1 ; x 2 ; : : : ; x n ) is difficult or perhaps impossible <ref> [32, 56] </ref>. Unfortunately, if one designs such a dynamic controller, it only applies to a fixed system with a fixed workload. <p> If the user request workload changes, or if the system design changes even slightly, the stability of the system may change dramatically, requiring a new analytic model be designed and solved <ref> [32] </ref>. 5.3.2 Portable Input/Output Steering Complications As discussed above, parallel file system policy control is a complex dynamic steering problem. Even if a control theory steering model could be designed and solved, it would not apply on a system with markedly different design parameters.
Reference: [33] <author> Kimbrel, T., Cao, P., Felten, E., Karlin, A., and Li, K. </author> <title> Integrating Parallel Prefetching and Caching. </title> <booktitle> In Proceedings of the 1996 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems (Philadelphia, </booktitle> <address> PA, May 1996), </address> <publisher> ACM Press, </publisher> <pages> pp. 262-263. </pages> <note> Poster paper. </note>
Reference-contexts: Con--sequently, the cache may inadvertently evict prefetched blocks before they are read. Similarly, the prefetching policy may prefetch too many blocks, potentially forcing the file cache to evict working set data. In contrast, Kimbrel et al <ref> [33, 34] </ref> discuss integrated prefetching and caching strategies. Integrated strategies allow cache replacement policies to prioritize prefetched blocks, potentially preventing premature eviction. Similarly, using an integrated policy, prefetching can fetch exactly the number of blocks that can be evicted from the cache without compromising the working set.
Reference: [34] <author> Kimbrel, T., Tomkins, A., Patterson, R. H., Bershad, B., Cao, P., Felten, E., Gibson, G., Karlin, A. R., and Li, K. </author> <title> A Trace-Driven Comparison of Algorithms for Parallel Prefetching and Caching. </title> <booktitle> In Proceedings of the 1996 Symposium on Operating Systems Design and Implementation (October 1996), USENIX Association, </booktitle> <pages> pp. 19-34. </pages>
Reference-contexts: Con--sequently, the cache may inadvertently evict prefetched blocks before they are read. Similarly, the prefetching policy may prefetch too many blocks, potentially forcing the file cache to evict working set data. In contrast, Kimbrel et al <ref> [33, 34] </ref> discuss integrated prefetching and caching strategies. Integrated strategies allow cache replacement policies to prioritize prefetched blocks, potentially preventing premature eviction. Similarly, using an integrated policy, prefetching can fetch exactly the number of blocks that can be evicted from the cache without compromising the working set.
Reference: [35] <author> King, S. M. Installing, </author> <title> Managing, and Using the IBM AIX Parallel I/O File System. </title> <institution> Information Development Department, IBM Kingston, </institution> <address> New York, </address> <year> 1994. </year>
Reference-contexts: The simplest approach for obtaining access pattern information allows the user to explicitly tell the file system about the access pattern. If possible, the file system enables policies that optimize performance when users specify this access pattern information <ref> [35, 29, 61, 9] </ref>. Unfortunately, users may not know enough about the spatial and temporal aspects of their 1 access patterns to inform the file system. Users may need to invest considerable effort manually analyzing their applications and data before specifying appropriate explicit access patterns. <p> To help maintain the users' mental model of input/output, these file systems generally provide an extended UNIX input/output interface. This interface accommodates specification of a rich variety of input/output workloads. Most commercial parallel file systems offer some user control over data distribution and cache consistency. IBM's PIOFS <ref> [35] </ref>, the commercial offshoot of Vesta [20], allows users to specify the number of cells (i.e., logical disks) to use for a file, as well as a sophisticated technique for partitioning data among these logical cells so that more than simple data striping can be 12 achieved. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in x3.1 3.3.5 Sequential Subfile Access Many parallel input/output systems such as PFS [29], PIOFS <ref> [35] </ref>, Vesta [20], Passion [4], and PPFS [28] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [36] <author> Kotz, D. </author> <title> Prefetching and Caching Techniques in File Systems for MIMD Multiprocessors. </title> <type> PhD thesis, </type> <institution> Duke University, </institution> <month> April </month> <year> 1991. </year> <note> Available as technical report CS-1991-016. </note>
Reference-contexts: This approach allows users to focus on enhancing the algorithms in their applications rather than forcing them to concentrate on input/output concerns. Substantial performance improvements are possible by changing policies based on automatically detected partial access pattern information <ref> [36, 40] </ref>. In this thesis, we propose a closed loop optimization strategy that automatically monitors parallel input/output access pattern and performance metrics and adaptively refines file system policies as bottlenecks appear. <p> In particular, uniprocessor workloads are either sequential or random. Because most accesses are sequential, simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output workloads, on the other hand, have been described using several taxonomies <ref> [12, 36, 43] </ref>. Parallel scientific applications frequently access non-sequential but non-random parts of shared parallel files (e.g., data is often equally partitioned among processors). Unfortunately, this non-sequential behavior often defeats traditional input/output optimization strategies. <p> TIPs uses a simple model of cache buffer copy overheads, transaction overheads, and input/output device delays to determine which hinted blocks should be prefetched. When multiple applications specify hints, TIPs uses this model to prioritize input/output resource allocation among them. Kotz <ref> [36] </ref> explores prefetching and caching strategies for MIMD multiprocessors. This work provides a run time model for detecting access patterns and predicting blocks that should be prefetched. <p> Input/output performance is often determined by the specific input/output routines applied rather than the application level input/output cause. Consequently, cause based taxonomies does not provide sufficient information to optimize input/output performance. In contrast to typed input/output taxonomies, other input/output taxonomies such as Crockett [12] and Kotz <ref> [36] </ref> define parallel input/output by the relative sizes and spacings of requests within a file. Neither of these taxonomies are sufficiently rich to describe the input/output behavior exhibited by the SIO application suite.
Reference: [37] <author> Kotz, D. </author> <title> Disk-Directed I/O for MIMD Multiprocessors. </title> <booktitle> In Proceedings of the 1994 Symposium on Operating Systems Design and Implementation (November 1994), USENIX Association, </booktitle> <pages> pp. 61-74. </pages> <note> Updated as Dartmouth TR PCS-TR94-226 on November 8, </note> <year> 1994. </year>
Reference-contexts: In the same way that two-phase input/output schedules out of core array accesses, disk-directed input/output presented by Kotz <ref> [37] </ref>, allows efficient access to any file data. Disk-directed input/output allows users to specify arbitrary file data blocks for retrieval. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output <ref> [3, 37] </ref> are applied to optimize performance. Most out of core interfaces [2, 4, 46, 55] require the application programmer to explicitly read and write out of core data slices using row and column file access primitives.
Reference: [38] <author> Krieger, O., and Stumm, M. </author> <title> HFS: A Performance-Oriented Flexible File System Based on Building-Block Compositions. </title> <journal> ACM Transactions on Computer Systems (1997). </journal> <note> To appear. </note>
Reference-contexts: While ELFs allows the definition of arbitrary file objects and their associated performance optimization policies, the authors experimented extensively with external array row and column accesses and with ranged relational database queries. The Hurricane File System (HFS) <ref> [38] </ref> defines a building block approach to parallel input/output. They assume that files are composed of application data structures (e.g., a file 11 may consist of a file header, an out of core array, and a set of vectors). <p> By defining and using HFS building blocks, input/output policies can be precisely matched to application access patterns. HFS has been developed as part of the extensible Hurricane operating system for the Hector shared memory multiprocessor <ref> [38] </ref>. Hurricane services such as input/output are provided by user level servers; a fast protected procedure call (PPC) interface allows rapid service of requests across address space boundaries.
Reference: [39] <author> Kuppermann, A., and Wu, Y.-S. M. </author> <title> The Quantitative Prediction and Lifetime of a Pronounced Reactive Scattering Resonance. </title> <journal> Chemical Physics Letters 241 (1995), </journal> <pages> 229-240. </pages>
Reference-contexts: These molecular level details are evident in the state-to-state differential and integral cross sections. The QCRD application solves the Schrodinger equation for the cross section of the scattering of an atom by a diatomic molecule <ref> [39, 69] </ref>. This parallel version of the code decomposes global matrices equally among the different processors to achieve satisfactory load balance. This application is executed as five separate, input/output intensive programs.
Reference: [40] <author> Madhyastha, T. </author> <title> Automatic Classification of Input/Output Access Patterns. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: This approach allows users to focus on enhancing the algorithms in their applications rather than forcing them to concentrate on input/output concerns. Substantial performance improvements are possible by changing policies based on automatically detected partial access pattern information <ref> [36, 40] </ref>. In this thesis, we propose a closed loop optimization strategy that automatically monitors parallel input/output access pattern and performance metrics and adaptively refines file system policies as bottlenecks appear. <p> Hints In contrast to systems that require the user to either explicitly select file system policies or hints that provide implicit access pattern information to the file system policy selectors, automatic access pattern classification has been used in the Portable Parallel File System (PPFS) effort to detect UNIX access patterns <ref> [40] </ref>. The resulting access pattern information was used by neural networks and hidden Markov models to automatically select effective file system policies on the Intel Paragon PFS without requiring application level policy controls. <p> In addition, the presence of mountains, which are not directly associated with compass directions, can dramatically impact the state of the aircraft. Another example of an open loop control framework is an input/output policy optimization infrastructure that bases policy decisions solely on access pattern information <ref> [40] </ref>. Because changing file system policies does not directly impact the access pattern, such a steering model is an open loop control framework. If multiple applications execute concurrently, resource availability for file buffering may change dynamically due to interapplication contention. <p> Reference or workload sensor metrics are important because they determine the workload intensity of an application access pattern. In the presence of access pattern specific API routines such as those in PFS or MPI-IO [61], or automated access pattern classification <ref> [40] </ref>, workload sensor metrics may be generated directly by the API interface or from a classification module rather than by input/output library monitoring routines. The second class of sensor metrics suitable for dynamic steering correspond to the feedback sensors discussed in chapter 5. <p> As shown in chapter 3, several additional classes of parallel access pattern can occur. As one example of another access pattern, only some of the processors may perform parallel input/output. Madhyastha <ref> [40] </ref> has proposed a promising framework using neural networks and hidden Markov models for distinguishing and parameterizing a rich variety of parallel input/output access patterns. An interesting research direction combines this automatic access pattern classification with our methodology for automatically determining effective parallel file system policies.
Reference: [41] <author> Martin, C. F. </author> <title> Large-Scale Dynamic Systems. </title> <journal> NASA Scientific and Technical Information Office, </journal> <year> 1975. </year> <month> 183 </month>
Reference-contexts: Unfortunately, as described above, control theory models often require simplification to improve tractability. For simple problems such as the classic cart example described above, stable control theory models can be designed and solved. For more complex control problems <ref> [41] </ref>, however, interacting effects hamper the design of a control theory model. In particular, a control system is complex when the controller must manage multiple actuators whose effects are are not independent. In other words, when changes to multiple actuators can cause competing sensor metric changes, the system is complex. <p> whether analytic models of large systems, even when they can predict system behavior, can be expected to predict behavior for significantly longer than the sensor measurement time (i.e., by the time sensor metrics propagate through the sigma module shown in Figure 5.4, the system state may already have changed dramatically) <ref> [41] </ref>. Formal control theory alone cannot effectively control large, complex systems. In these cases, either a hybrid modeling and experimental or purely experimental approach must be taken to design an effective complex dynamic control mechanism.
Reference: [42] <author> Marzullo, K., and Wood, M. </author> <title> Tools for Constructiong Distributed Reactive Systems. </title> <type> Tech. rep., </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Many steering projects assume that when users add actuators to a system they maintain system correctness. To facilitate actuator creation and maintenance, the Meta-Toolkit provides a framework of guards for maintaining mutual exclusion of critical state variables <ref> [42, 68] </ref>. When an actuator is invoked, the appropriate guards are executed before the system module is modified.
Reference: [43] <author> Miller, E. L., and Katz, R. H. </author> <title> Input/Output Behavior of Supercomputer Applications. </title> <booktitle> In Proceedings of Supercomputing '91 (Albuquerque, </booktitle> <address> NM, November 1991), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 567-576. </pages>
Reference-contexts: In particular, uniprocessor workloads are either sequential or random. Because most accesses are sequential, simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output workloads, on the other hand, have been described using several taxonomies <ref> [12, 36, 43] </ref>. Parallel scientific applications frequently access non-sequential but non-random parts of shared parallel files (e.g., data is often equally partitioned among processors). Unfortunately, this non-sequential behavior often defeats traditional input/output optimization strategies. <p> To this end, several parallel input/output taxonomies have been defined that describe the similarities and differences among approaches to parallel input/output. 30 Some of these taxonomies have attached a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core <ref> [43] </ref>. Unfortunately, the sequence of input/output calls that perform one type of input/output may be identical to those performed for another type of input/output (e.g., the same input/output call sequence may be used by one application to perform checkpointing and in another application to store out of core data).
Reference: [44] <author> Mukherjee, B., and Schwan, K. </author> <title> Improving Performance by Use of Adaptive Objects: Experimentation with a Configurable Multiprocessor Thread Package. </title> <type> Tech. Rep. </type> <institution> GIT-CC-93-17, College of Computing, Georgia Institute of Technology, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Using computational steering, we hope to provide high performance to users without requiring them to invest substantial effort manually optimizing policies. Computational steering has been successfully applied in other application domains to choose effective policies (e.g., dynamic spin lock policy management <ref> [22, 44] </ref>). Dynamic computational steering of parallel file system policies requires the system to monitor workloads and performance metrics summarizing system behavior. The system then uses these metrics to detect conditions requiring policy refinement and enables the resulting policy choices. <p> Falcon supports both interactive and automated steering. Automated run time steering is used in Falcon to select different mutual exclusion lock configurations based on the number of threads blocked on the lock <ref> [22, 44] </ref>. An adaptation module executes code that examines sensor variables and sets the lock parameters. For example, if the number of threads waiting on a lock exceeds some threshold, the lock manager changes the number of iterations that a given thread should spin on the lock before sleeping.
Reference: [45] <author> Nickolayev, O. </author> <title> Performance Data Reduction Using Dynamic Statistical Clustering. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: In addition to allowing run time performance steering, this SWAVE function interface has also been used to perform real time data clustering of sensor metric values <ref> [45] </ref>. 74 Sensor Metric Description Reference Inputs (Monitor Request Attributes) PROCS Number of clients performing input/output Computation Time Average temporal request interval Access Stride Average spatial request interval Operation Count Total number of input/output requests Read Count Number of read requests Read Byte Count Number of bytes read Write Count Number
Reference: [46] <author> Nieuwejaar, N., and Kotz, D. </author> <title> The Galley Parallel File System. </title> <booktitle> In Proceedings of the 10th ACM International Conference on Supercomputing (Philadelphia, </booktitle> <address> PA, May 1996), </address> <publisher> ACM Press, </publisher> <pages> pp. 374-381. </pages>
Reference-contexts: If the file system API provides unique routines for each common access pattern, the file system will implicitly know the access pattern whenever they are used (e.g., row or column access methods for accessing out of core arrays). Substantial performance improvements have been reported using these implicit techniques <ref> [2, 4, 46, 55] </ref>. Unfortunately, this approach forces users to modify their applications to perform input/output using only supported access patterns. This may constrain application scientists as they choose algorithms, potentially reducing the feasibility of parallel computation for new application domains. <p> Two-phase input/output determines the aggregate portions of the out of core array accessed across the processors, schedules the largest possible disk transfers to read or write this data, then redistributes the data portions to the appropriate processors. Galley <ref> [46] </ref>, Panda [55], PASSION [4], and Jovian [2] all support out of core multi-dimensional arrays. These array based systems can reorder disk data distributions and aggregate input/output requests to more effectively utilize disk bandwidth. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output [3, 37] are applied to optimize performance. Most out of core interfaces <ref> [2, 4, 46, 55] </ref> require the application programmer to explicitly read and write out of core data slices using row and column file access primitives.
Reference: [47] <author> Ousterhout, J. K., et al. </author> <title> A Trace-Driven Analysis of the UNIX 4.2 BSD File System. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating System Principles (Dec. 1985), Association For Computing Machinery, </booktitle> <pages> pp. 35-50. </pages>
Reference-contexts: Until very recently, the design of parallel file systems and parallelizing techniques for optimizing parallel application input/output remained largely unexplored. 2 Uniprocessor workstation applications tend to exhibit very simple and predictable access patterns <ref> [47] </ref>. In particular, uniprocessor workloads are either sequential or random. Because most accesses are sequential, simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output workloads, on the other hand, have been described using several taxonomies [12, 36, 43].
Reference: [48] <author> Parker, S. G., and Johnson, C. R. SCIRun: </author> <title> A Scientific Programming Environment for Computational Steering. </title> <booktitle> In Proceedings of Supercomputing '95 (December 1995). </booktitle>
Reference-contexts: SciRun <ref> [48] </ref> is a representative example of an interactive steering infrastructure. SciRun's main goal is to provide a rich visualization environment for computational chemistry applications. SciRun provides interfaces to view scalars, vectors, arrays and surfaces.
Reference: [49] <author> Patterson, R. H., Gibson, G. A., Ginting, E., Stodolsky, D., and Zelenka, J. </author> <title> Informed prefetching and caching. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles (Copper Mountain, </booktitle> <address> CO, December 1995), </address> <publisher> ACM Press, </publisher> <pages> pp. 79-95. </pages>
Reference-contexts: This policy uses knowledge of the input/output access stream to ensure that (a) the cache replacement policy does not replace blocks that will be accessed soon, and (b) the prefetch policy always fetches the next block in the access stream that is not yet cached. Transparent Informed Prefetching (TIPs) <ref> [49] </ref> allows the user to specify in advance files and file fragments that will be accessed. The underlying file system library uses this information to modify the prefetch parameters and cache replacement priorities to optimize performance. <p> Using the Autopilot system [53], a generalized 171 sensor/actuator dynamic steering framework, the next generation of the Portable Parallel File System (PPFS II) will incorporate these enhanced monitoring extensions. As discussed in chapter 2, the Transparent Informed Prefetching (TIPs) project <ref> [49] </ref> examines access pattern hints to prioritize input/output resource allocation among files and applications using a simple model of device delays and transaction overheads.
Reference: [50] <author> Poole, J. T. </author> <title> Scalable I/O Initiative. </title> <institution> California Institute of Technology, </institution> <note> Available at http://www.ccsf.caltech.edu/SIO/, 1996. </note>
Reference-contexts: parameterize taxonomy access patterns with request size and spacing information as well as inter-request computation intervals to provide a measure of the intensity of an input/output access pattern (i.e., the bandwidth and latency characteristics of each application's access patterns). 3.1 Parallel Scientific Application Access Patterns The Scalable Input/Output Initiative (SIO) <ref> [50] </ref> is a multidisciplinary effort whose primary goal is to assemble and characterize a set of production input/output intensive national challenge parallel applications. In contrast to benchmarks, these applications exhibit complex interactions among computation, message passing, application memory use, and parallel input/output.
Reference: [51] <author> Reed, D. A. </author> <title> Pablo Performance Analysis Environment, </title> <month> Jan. </month> <year> 1995. </year> <note> http://www-pablo.cs.uiuc.edu/Projects/Pablo/pablo.html. 184 </note>
Reference-contexts: monitor the performance of PPFS, we instrumented it with the Pablo trace library to generate trace records detailing information such as request sizes, client and server input/output overheads, and queuing delays. 6.2.1 PPFS Sensor Methodology The Pablo trace library is an extensible infrastructure for monitoring sequential and parallel application performance <ref> [51, 52] </ref>. The Pablo trace library provides a sliding window average 73 extension (SWAVE) that allows a user level library such as PPFS or an application to register an arbitrary set of metric dimensions and then provide event values to these dimensions.
Reference: [52] <author> Reed, D. A., Aydt, R. A., Noe, R. J., Roth, P. C., Shields, K. A., Schwartz, B. W., and Tavera, L. F. </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference, </booktitle> <editor> A. Skjellum, Ed. </editor> <publisher> IEEE Computer Society, </publisher> <year> 1993, </year> <pages> pp. 104-113. </pages>
Reference-contexts: monitor the performance of PPFS, we instrumented it with the Pablo trace library to generate trace records detailing information such as request sizes, client and server input/output overheads, and queuing delays. 6.2.1 PPFS Sensor Methodology The Pablo trace library is an extensible infrastructure for monitoring sequential and parallel application performance <ref> [51, 52] </ref>. The Pablo trace library provides a sliding window average 73 extension (SWAVE) that allows a user level library such as PPFS or an application to register an arbitrary set of metric dimensions and then provide event values to these dimensions.
Reference: [53] <author> Ribler, R. L., Simitci, H., and Reed, D. A. </author> <title> The Autopilot Performance-Directed Adaptive Control System. In Special Issue on Performance Data Mining, </title> <note> Future Generations Computer Systems (FGCS) (submitted for publication (Nov 1997)). </note>
Reference-contexts: Using the Autopilot system <ref> [53] </ref>, a generalized 171 sensor/actuator dynamic steering framework, the next generation of the Portable Parallel File System (PPFS II) will incorporate these enhanced monitoring extensions.
Reference: [54] <author> Saucedo, R., and Schiring, E. E. </author> <title> Introduction to Continuous and Digital Control Systems. </title> <publisher> The Macmillan Company, </publisher> <year> 1968. </year>
Reference-contexts: Figure 5.1 shows a block diagram of such an open loop control system <ref> [54] </ref>. A reference input, usually some measure of the system goal, is amplified or otherwise transformed into a value that a decision control process can use. This control process modifies the state of the controlled system to better achieve the system goal. <p> Figure 5.2 shows a block diagram 55 of a closed loop control mechanism <ref> [54] </ref>. In addition to accounting for reference inputs, a closed loop control mechanism also incorporates sensors that monitor system output. The system incorporates a comparator that detects anomalous behavior. The comparator amplifies the sensor outputs for the control mechanism which makes system control changes. <p> This subject allows rigorous mathematical modeling and design of feedback control systems. The following process applies formal control theory to a problem <ref> [54] </ref>. 1. Establish performance specifications (i.e., define what constitutes good or optimal perfor mance). 2. Derive a mathematical model of the system (i.e, write equations that represent the state of all factors affecting the system). 3. Analyze the system with the mathematics of control theory. 4.
Reference: [55] <author> Seamons, K. E., Chen, Y., Jones, P., Jozwiak, J., and Winslett, M. </author> <title> Server-Directed Collective I/O in Panda. </title> <booktitle> In Proceedings of Supercomputing '95 (San Diego, </booktitle> <address> CA, December 1995), </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: If the file system API provides unique routines for each common access pattern, the file system will implicitly know the access pattern whenever they are used (e.g., row or column access methods for accessing out of core arrays). Substantial performance improvements have been reported using these implicit techniques <ref> [2, 4, 46, 55] </ref>. Unfortunately, this approach forces users to modify their applications to perform input/output using only supported access patterns. This may constrain application scientists as they choose algorithms, potentially reducing the feasibility of parallel computation for new application domains. <p> Two-phase input/output determines the aggregate portions of the out of core array accessed across the processors, schedules the largest possible disk transfers to read or write this data, then redistributes the data portions to the appropriate processors. Galley [46], Panda <ref> [55] </ref>, PASSION [4], and Jovian [2] all support out of core multi-dimensional arrays. These array based systems can reorder disk data distributions and aggregate input/output requests to more effectively utilize disk bandwidth. <p> Applications that extensively use out of core arrays can achieve good performance using these systems. When processors request adjacent rows, columns, or blocks of file data, techniques such as two phase input/output or disk directed input/output [3, 37] are applied to optimize performance. Most out of core interfaces <ref> [2, 4, 46, 55] </ref> require the application programmer to explicitly read and write out of core data slices using row and column file access primitives.
Reference: [56] <author> Sensicle, A. </author> <title> Introduction to Control Theory, for Engineers. </title> <publisher> Robert Cunningham and Sons, </publisher> <year> 1968. </year>
Reference-contexts: Even if one designs such a controller, analyzing the model and solving the resulting nonlinear differential equations to produce a dynamic control function f (x 1 ; x 2 ; : : : ; x n ) is difficult or perhaps impossible <ref> [32, 56] </ref>. Unfortunately, if one designs such a dynamic controller, it only applies to a fixed system with a fixed workload.
Reference: [57] <author> Smirni, E., Aydt, R. A., Chien, A. A., and Reed, D. A. </author> <title> I/O Requirements of Scientific Applications: An Evolutionary View. </title> <booktitle> In Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing (Syracuse, </booktitle> <address> NY, 1996), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 49-59. </pages>
Reference-contexts: Parallel scientific applications frequently access non-sequential but non-random parts of shared parallel files (e.g., data is often equally partitioned among processors). Unfortunately, this non-sequential behavior often defeats traditional input/output optimization strategies. The variety of parallel input/output taxonomies and parallel application characterization from the Scalable Input/Output Initiative (SIO) <ref> [11, 57] </ref> demonstrate the complex input/output resource requirements of parallel applications. Because parallel input/output is typically more varied than uniprocessor input/output, it is unlikely that uniprocessor file system policies are sufficient to optimize parallel file system performance. <p> We begin in x3.1 by describing a suite of high performance, parallel scientific applications and their approach to performing input/output. We continue in x3.2 with a discussion of the input/output characterization of these applications. This characterization helps demonstrate the complexity of parallel scientific input/output workloads <ref> [11, 57] </ref>. In x3.3, we present a parallel access pattern taxonomy based on the parallel input/output characterization effort and extant taxonomies. Our taxonomy allows us to more formally compare and contrast the SIO applications. <p> In contrast to uniprocessor applications which typically exhibit simple, sequential access patterns, these applications exhibit a variety of complex file access techniques. To emphasize the complexity and variety of parallel input/output, we now summarize part of the input/output performance characterization of the four applications described in x3.1 <ref> [11, 57] </ref>. 3.2.1 SIO Application Characterization The ESCAT application discussed in x3.1.1 is typical of many parallel applications. It begins with an initialization input phase, followed by periodic input/output during application execution, coupled with a final result output phase. <p> The input/output characterization of the SIO application suite such as that shown in Figures 3.1-3.4 has resulted in several general observations <ref> [11, 57] </ref> about parallel scientific input/output. 27 Intel Paragon; 128 Application Nodes Intel Paragon; 64 Application Nodes 28 3.2.2.1 Portable Input/Output Interfaces Some application developers are willing to forgo portable UNIX input/output constructs and instead use system dependent API routines to improve parallel input/output performance.
Reference: [58] <author> Smirni, E., Elford, C. L., Lavery, A. J., Reed, D. A., and Chien, A. A. </author> <title> Algorithmic Influences on I/O Access Patterns and Parallel File System Performance. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: By manually specifying data distribution, caching, write back, and prefetch controls, we dramatically improved the input/output performance of several benchmarks and production parallel applications relative to native parallel file system performance <ref> [28, 58] </ref>. Unfortunately, to obtain good performance using PPFS, the user must invest considerable effort exploring file system policies to determine the best one for their workload. <p> The results in Table 4.1 are representative of the performance improvements that are possible by manually configuring policies to match the workload for a variety of access patterns <ref> [28, 58] </ref>. 64 Application nodes, 12 MAXTOR RAID-3 Devices 4.4.2 PPFS Application Performance File access pattern benchmarks such as those discussed above allow one to estimate asymptotic performance of file system policies.
Reference: [59] <author> Statistical Engineering Laboratory. </author> <title> Fractional Factorial Experiment Designs for Factors at Two Levels. </title> <booktitle> National Bureau of Standards Applied Mathmatics Series 48 (Apr. </booktitle> <year> 1957), </year> <pages> 1-85. </pages>
Reference-contexts: While some policies can be pruned using common sense, the relative importance of other policies must be determined experimentally for each workload. To determine which of a set of policies most impact performance, we apply factor analysis <ref> [30, 59] </ref>. Factor analysis generates a breakdown of each policy and combination of policies and the degree they affect input/output performance. By removing all policies that account for less than five to ten percent of performance variation, the size of the cross product policy search space can be further reduced. <p> selector rule creation heuristic that seeks to improve input/output performance and reduce overall input/output resource requirements. 8.2 Primary Factor Analysis Factor analysis is a technique to statistically determine the dominant subset of a set of discrete variables or factors each of which impacts the performance or response of a process <ref> [30, 59] </ref>. <p> If executing 2 k experiments for each workload is prohibitively expensive, the number of experiments can be reduced using 2 (kn) factor analysis at the expense of design resolution <ref> [30, 59] </ref>. In this type of analysis, n is a parameter that determines the number of experiments required. The resolution of a factor analysis design is a measure of its ability to differentiate between different combinations of factors. <p> Sign matrices for 2 (kn) factor analysis with the highest possible resolution for a wide range of k and n are given in <ref> [59] </ref>. In addition, [30] discusses how sign matrices can be created for arbitrary k and n. One must be sure to choose a sign matrix that maximizes factor analysis design resolution.
Reference: [60] <author> Thakur, R., Lusk, E., and Gropp, W. </author> <title> Users Guide for ROMIO, a High-Performance, Portable MPI-IO Implementation. </title> <institution> Argonne National Lab, </institution> <note> Available at http://www.mcs.anl.gov/home/thakur/romio/, 1997. 185 </note>
Reference-contexts: Portable specification allows rapid, optimal policy recalibration when new installations are configured or when system upgrades affect input/output performance. The importance of portable optimal policy specification increases as the popularity of portable parallel input/output library implementations such as ROMIO for MPI-IO (MPI-2) <ref> [60] </ref> grows. To this end, we created a portable selector library that implements the selector table rules discussed in chapter 5. Recall from chapter 5 that we enumerate policy rules with selector tables because they are extensible and can be easily ported to new hardware configurations.
Reference: [61] <author> The MPI-IO Committee. </author> <title> MPI-IO: A Parallel File I/O Interface for MPI, </title> <month> April </month> <year> 1996. </year> <note> Version 0.5. </note>
Reference-contexts: The simplest approach for obtaining access pattern information allows the user to explicitly tell the file system about the access pattern. If possible, the file system enables policies that optimize performance when users specify this access pattern information <ref> [35, 29, 61, 9] </ref>. Unfortunately, users may not know enough about the spatial and temporal aspects of their 1 access patterns to inform the file system. Users may need to invest considerable effort manually analyzing their applications and data before specifying appropriate explicit access patterns. <p> These interfaces allow users to use the same input/output syntax across parallel platforms. Using hints, the user can inform the underlying implementations of important characteristics of their input/output access patterns. The implementation can use these hints to optimize performance. The emerging MPI-IO <ref> [61] </ref> interface for MPI [24] provides an extensive set of processor local and collective input/output routines. The user can create files composed of MPI data type elements and provide hints detailing input/output coordination between nodes using MPI groups and communicators. <p> Reference or workload sensor metrics are important because they determine the workload intensity of an application access pattern. In the presence of access pattern specific API routines such as those in PFS or MPI-IO <ref> [61] </ref>, or automated access pattern classification [40], workload sensor metrics may be generated directly by the API interface or from a classification module rather than by input/output library monitoring routines. The second class of sensor metrics suitable for dynamic steering correspond to the feedback sensors discussed in chapter 5.
Reference: [62] <author> Tomovic, R. </author> <title> Sensitivity Analysis of Dynamic Systems. </title> <address> Beogradski Graficki Zavod, </address> <year> 1963. </year>
Reference-contexts: This simplification loses high order effects that may affect the physical system. The stability of applying a control theory mathematical model to a physical, dynamic system can be determined by the Liapunov <ref> [62] </ref> criteria.
Reference: [63] <author> Vaccaro, R. J. </author> <title> Digital Control: A State-Space Approach. </title> <publisher> McGraw-Hill, </publisher> <year> 1963. </year>
Reference-contexts: Closed loop, or feedback based control systems, in contrast to open loop systems can maintain a high degree of accuracy even in the presence of system complications. 5.2 Classical Control Theory Feedback control theory applies mathematical analysis to solve closed loop control problems <ref> [6, 15, 63] </ref>. This subject allows rigorous mathematical modeling and design of feedback control systems. The following process applies formal control theory to a problem [54]. 1. Establish performance specifications (i.e., define what constitutes good or optimal perfor mance). 2.
Reference: [64] <author> Vengroff, D. E., and Vitter, J. S. </author> <title> I/O-Efficient Scientific Computation Using TPIE. </title> <type> Tech. Rep. </type> <institution> CS-1995-18, Dept. of Computer Science, Duke University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: With these compiler optimizations, the user can potentially use conventional memory array traversal techniques on out of core arrays that are automatically translated into efficient PASSION operations. In many cases, users wish to perform simple transformations on external data structures. TPIE <ref> [64] </ref> provides an inverted approach to parallel input/output by attaching user computation callbacks to file data streams rather than invoking input/output calls in computation threads. Using this interface, applications do not perform input/output followed by transformation algorithms but instead tell the input/output system to perform the algorithm directly.
Reference: [65] <author> Vetter, J., and Schwan, K. </author> <title> Models for Computational Steering. </title> <booktitle> In Proceedings International Conference on Configurable Distributed Systems Annapolis (May 1996). </booktitle>
Reference-contexts: Essentially, SciRun is a toolkit that enables computational steering for computational chemistry applications. The application scientist can concentrate on their chemistry algorithms and utilize SciRun visualization widgets rather than having to implement their own. While SciRun concentrates on the visualization aspects of interactive steering, the Falcon project <ref> [65, 25] </ref> provides a more general framework for dynamic steering. Using a basic feedback system as a model, the Falcon project has produced a general framework for computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions. <p> We develop and quantify the effectiveness of an experimental infrastructure for dynamically controlling real parallel file system policies. 5.4 Parallel File System Policy Selection Infrastructure We present a closed loop parallel input/output policy control model using the basic computational feedback system shown in Figure 5.7 <ref> [65] </ref>, we describe closed loop control of parallel input/output policies. As shown in the figure, an application transforms input into output. A feedback control framework consists of three components that interact with an executing application.
Reference: [66] <author> Wickins, C. D. </author> <title> Engineering Psychology and Human Performance. </title> <publisher> Harper Collins, </publisher> <year> 1992. </year>
Reference-contexts: Certain conditions in control theory dramatically affect the stability of a dynamic control system. In particular, instability is often caused in negative feedback control systems with high gain and long lag delays <ref> [66] </ref>. In this case, a condition called oscillation is likely to occur in the system. Oscillation is one of a class of possible steering errors characterized by cycling actuators back and forth between a set of possible values rather than converging to a single actuator setting.
Reference: [67] <author> Winstead, C., and McKoy, V. </author> <title> Studies of Electron-Molecule Collisions on Massively Parallel Computers. In Modern Electronic Structure Theory, </title> <editor> D. R. Yarkony, Ed., </editor> <volume> vol. 2. </volume> <publisher> World Scientific, </publisher> <year> 1994. </year>
Reference-contexts: Before examining application input/output performance, it is constructive to outline the input/output characteristics of the SIO application suite. 3.1.1 SMC Electron Scattering (ESCAT) The SMC electron scattering application (ESCAT) is used to study low-energy electron-molecule collisions <ref> [67] </ref>. This application is important for certain types of aerospace research, atmospheric sciences and to explore semiconductor fabrication issues. ESCAT is a parallel implementation of the Schwinger Multichannel method and generates electron scattering probabilities that result from molecular collisions.
Reference: [68] <author> Wood, M. D. </author> <title> Fault-Tolerant Management of Distributed Applications Using the Reactive System Architecture. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1992. </year> <note> Available as technical report TR91-1252. </note>
Reference-contexts: Many steering projects assume that when users add actuators to a system they maintain system correctness. To facilitate actuator creation and maintenance, the Meta-Toolkit provides a framework of guards for maintaining mutual exclusion of critical state variables <ref> [42, 68] </ref>. When an actuator is invoked, the appropriate guards are executed before the system module is modified.
Reference: [69] <author> Wu, Y.-S. M., Cuccaro, S. A., Hipes, P. G., and Kuppermann, A. </author> <title> Quantum Chemical Reaction Dynamics on a Highly Parallel Supercomputer. </title> <journal> Theoretica Chimica Acta 79 (1991), </journal> <pages> 225-239. 186 </pages>
Reference-contexts: These molecular level details are evident in the state-to-state differential and integral cross sections. The QCRD application solves the Schrodinger equation for the cross section of the scattering of an atom by a diatomic molecule <ref> [39, 69] </ref>. This parallel version of the code decomposes global matrices equally among the different processors to achieve satisfactory load balance. This application is executed as five separate, input/output intensive programs.
References-found: 69

