URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/98/tr1386.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/98/
Root-URL: http://www.cs.wisc.edu
Title: Program Analysis via Graph Reachability  
Author: Thomas Reps 
Affiliation: University of Wisconsin  
Abstract: This paper describes how a number of program-analysis problems can be solved by transforming them to graph-reachability problems. Some of the program-analysis problems that are amenable to this treatment include program slicing, certain dataflow-analysis problems, one version of the problem of approximating the possible shapes that heap-allocated structures in a program can take on, and flow-insensitive points-to analysis. Relationships between graph reachability and other approaches to program analysis are described. Some techniques that go beyond pure graph reachability are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Afrati, F. and Papadimitriou, C. H., </author> <title> The parallel complexity of simple chain queries, pp. </title> <booktitle> 210-214 in Proc. of the Sixth ACM Symp. on Princ. of Database Syst., </booktitle> <address> (San Diego, CA, </address> <month> Mar. </month> <year> 1987), (1987). </year>
Reference: 2. <author> Agrawal, H., </author> <title> On slicing programs with jump statements, </title> <booktitle> Proc. of the ACM SIGPLAN 94 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Orlando, FL, </address> <month> June 22-24, </month> <year> 1994), </year> <journal> SIGPLAN Not. </journal> <pages> 29(6) pp. </pages> <month> 302-312 (June </month> <year> 1994). </year>
Reference: 3. <author> Aho, A.V., Hopcroft, J.E., and Ullman, J.D., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1974). </address>
Reference: 4. <author> Aho, </author> <title> A.V., Algorithms for finding patterns in strings, </title> <note> pp. 255-300 in Handbook of Theor. Comp. Sci., Vol. A: Algorithms and Complexity, </note> <editor> ed. J. </editor> <publisher> van Leeuwen,The M.I.T. Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference: 5. <author> Aiken, A. and Murphy, B.R., </author> <title> Implementing regular tree expressions, pp. </title> <booktitle> 427-447 in Func. Prog. and Comp. Arch., Fifth ACM Conf., </booktitle> <address> (Cambridge, MA, </address> <month> Aug. </month> <pages> 26-30, </pages> <year> 1991), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 523, </volume> <editor> ed. J. Hughes,Springer-Verlag, </editor> <address> New York, NY (1991). </address>
Reference: 6. <author> Aiken, A. and Murphy, B.R., </author> <title> Static type inference in a dynamically typed language, pp. </title> <booktitle> 279-290 in Conf. Rec. of the Eighteenth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Orlando, FL, </address> <month> Jan. </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address> - <month> 28 </month> - 
Reference: 7. <author> Aiken, A. and Wimmers, E.L., </author> <title> Type inclusion constraints and type inference, pp. </title> <booktitle> 31-41 in Sixth Conf. on Func. Prog. and Comp. Arch., </booktitle> <address> (Copenhagen, Denmark), </address> <month> (June </month> <year> 1993). </year>
Reference: 8. <author> Allen, R., Baumgartner, D., Kennedy, K., and Porterfield, A., </author> <title> PTOOL: A semi-automatic parallel programming assistant, pp. </title> <booktitle> 164-170 in Proc. of the 1986 Int. Conf. on Parallel Processing, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <address> Wash., DC (1986). </address>
Reference-contexts: It is desirable to have program-development tools in which the user can ask questions interactively about various aspects of a program [62]. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine <ref> [8] </ref>. Because it is unlikely that a programmer will ask questions about all program points, solving just the user's sequence of demands is likely to be significantly less costly than performing an exhaustive analysis.
Reference: 9. <author> Andersen, L.O., </author> <title> Program analysis and specialization for the C programming language, </title> <type> Ph.D. </type> <institution> diss. and Report TOPPS D-203, Datalogisk Institut, Univ. of Copenhagen, Copenhagen, </institution> <address> Denmark (May 1994). </address>
Reference-contexts: A flow-insensitive analysis of a program is one that ignores the actual structure of the program's control-flow graph, and instead assumes that any statement can be executed immediately after any other statement. (Many type-inference algorithms are examples of flow-insensitive analyses.) Flow-insensitive points-to analyses have been developed by Andersen <ref> [9] </ref>, Steensgaard [91], and Shapiro and Horwitz [89]. In this section, we show how a variant of Andersen's analysis, as reformulated by Shapiro and Horwitz [89], can be expressed as a CFL-reachability problem.
Reference: 10. <author> Assmann, U., </author> <title> On edge addition rewrite systems and their relevance to program analysis, </title> <booktitle> in Proc. of the 5th Workshop on Graph Grammars and their Application to Comp. Sci., </booktitle> <address> (Williamsburg, VA, </address> <month> Nov. </month> <year> 1994), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 1073, </volume> <editor> ed. J. Cuny,Springer-Verlag, </editor> <address> New York, NY (1995). </address>
Reference-contexts: For instance, one of the examples in Ullman's book shows how a logic database can be used to solve the intraprocedural reaching-definitions problem [94, pp. 984-987]. Assmann has examined a variety of other intraprocedural program-analysis problems <ref> [10] </ref>. Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog. 7.3.
Reference: 11. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data flow analysis: Part II. Demand analysis, </title> <journal> Acta Inf. </journal> <pages> 10(3) pp. </pages> <month> 265-272 (Oct. </month> <year> 1978). </year>
Reference: 12. <author> Ball, T. and Horwitz, S., </author> <title> Slicing programs with arbitrary control flow, pp. </title> <booktitle> 206-222 in Proc. of the First Int. Workshop on Automated and Algorithmic Debugging, </booktitle> <address> (Linko .. ping, Sweden, </address> <month> May </month> <year> 1993), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 749, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1993). </address>
Reference: 13. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, pp. </title> <booktitle> 1-15 in Proc. of the Fifth ACM Symp. on Princ. of Database Syst., </booktitle> <address> (Cambridge, MA, </address> <month> Mar. </month> <year> 1986), (1986). </year>
Reference: 14. <author> Bannerjee, U., </author> <title> Speedup of ordinary programs, </title> <type> Ph.D. </type> <institution> diss. and Tech. </institution> <type> Rep. </type> <institution> R-79-989, Dept. of Comp. Sci., Univ. of Illinois, Urbana, </institution> <address> IL (Oct. </address> <year> 1979). </year>
Reference: 15. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conf. Rec. of the Sixth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Antonio, TX, </address> <month> Jan. </month> <pages> 29-31, </pages> <address> 1979), </address> <publisher> ACM, </publisher> <address> New York, NY (1979). </address>
Reference-contexts: For example, the MayMod problem determines, for each call site, which variables may be modified during the call. This problem can be decomposed into two phases: computing side effects disregarding aliases (the so-called DMod problem), and computing alias information <ref> [15] </ref>.
Reference: 16. <author> Bates, S. and Horwitz, S., </author> <title> Incremental program testing using program dependence graphs, pp. </title> <booktitle> 384-396 in Conf. Rec. of the Twentieth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Charleston, SC, </address> <month> Jan. </month> <pages> 10-13, </pages> <address> 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (1993). </address>
Reference: 17. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proc. of the Sixth ACM Symp. on Princ. of Database Syst., </booktitle> <address> (San Diego, CA, </address> <month> Mar. </month> <year> 1987), (1987). </year>
Reference: 18. <author> Binkley, D., </author> <title> Using semantic differencing to reduce the cost of regression testing, pp. </title> <booktitle> 41-50 in Proc. of the IEEE Conf. on Softw. </booktitle> <address> Maint. (Orlando, FL, </address> <month> Nov. </month> <pages> 9-12, </pages> <year> 1992), </year> <institution> IEEE Comp. Soc., </institution> <address> Wash., DC (1992). </address>
Reference: 19. <author> Binkley, D. and Gallagher, K., </author> <title> Program slicing, </title> <booktitle> in Advances in Computers, </booktitle> <volume> Vol. 43, </volume> <editor> ed. M. </editor> <publisher> Zelkowitz,Academic Press, </publisher> <address> San Diego, CA (1996). </address>
Reference: 20. <author> Callahan, D., </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis, </title> <booktitle> Proc. of the ACM SIGPLAN 88 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Atlanta, GA, June 22-24, 1988), </address> <publisher> SIG-PLAN Not. </publisher> <pages> 23(7) pp. </pages> <month> 47-56 (July </month> <year> 1988). </year>
Reference-contexts: Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [23] and alias analysis [24]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis <ref> [20] </ref> and Horwitz, Reps, and Binkley's work on interprocedural slicing [43,46].
Reference: 21. <author> Chase, D.R., Wegman, M., and Zadeck, F.K., </author> <title> Analysis of pointers and structures, </title> <booktitle> Proc. of the ACM SIGPLAN 90 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> SIGPLAN Not. </journal> <pages> 25(6) pp. </pages> <month> 296-310 (June </month> <year> 1990). </year>
Reference: 22. <author> Choi, J.-D. and Ferrante, J., </author> <title> Static slicing in the presence of GOTO statements, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 16(4) pp. </pages> <month> 1097-1113 (July </month> <year> 1994). </year>
Reference: 23. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proc. of the ACM SIGPLAN 88 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> SIGPLAN Not. </journal> <pages> 23(7) pp. </pages> <month> 57-66 (July </month> <year> 1988). </year>
Reference-contexts: Kou [57] and Hecht [38] gave linear-time graph-reachability algorithms for solving intrapro-cedural bit-vector dataflow-analysis problems. This approach was later applied to intraprocedural bidirectional bit-vector problems by Khedker and Dhamdhere [53]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis <ref> [23] </ref> and alias analysis [24]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [20] and Horwitz, Reps, and Binkley's work on interprocedural slicing [43,46].
Reference: 24. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conf. Rec. of the Sixteenth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: Kou [57] and Hecht [38] gave linear-time graph-reachability algorithms for solving intrapro-cedural bit-vector dataflow-analysis problems. This approach was later applied to intraprocedural bidirectional bit-vector problems by Khedker and Dhamdhere [53]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [23] and alias analysis <ref> [24] </ref>. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [20] and Horwitz, Reps, and Binkley's work on interprocedural slicing [43,46].
Reference: 25. <author> Cousot, P. and Cousot, R., </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints, pp. </title> <booktitle> 238-252 in Conf. Rec. of the Fourth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Los Angeles, CA, </address> <month> Jan. </month> <pages> 17-19, </pages> <address> 1977), </address> <publisher> ACM, </publisher> <address> New York, NY (1977). </address>
Reference-contexts: Program-analysis frameworks abstract on the common characteristics of some class of program-analysis problems. Examples of analysis frameworks range from the gen/kill dataflow-analysis problems described in many compiler textbooks to much more elaborate frameworks <ref> [25] </ref>. Typically, there is an analysis engine that can find solutions to all problems that can be specified within the framework.
Reference: 26. <author> Cousot, P. and Cousot, R., </author> <title> Static determination of dynamic properties of recursive procedures, pp. 237-277 in Formal Descriptions of Programming Concepts, </title> <booktitle> (IFIP WG 2.2, </booktitle> <address> St. Andrews, Canada, </address> <month> Aug. </month> <year> 1977), </year> <editor> ed. E.J. Neuhold,North-Holland, </editor> <address> New York, NY (1978). </address>
Reference-contexts: handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen [55].) IFDS and IDE problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli, and the algorithm of Cousot and - 25 - Cousot <ref> [26] </ref>. However, for general IFDS and IDE problems, both the iterative and call-strings algorithms can take exponential time in the worst case. Knoop and Steffen [55] give an algorithm similar to Sharir and Pnueli's elimination algorithm.
Reference: 27. <author> Deransart, P., Jourdan, M., and Lorho, B., </author> <title> Attribute Grammars: Definitions, Systems and Bibliography, Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 323, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference: 28. <author> Dolev, D, Even, S., and Karp, </author> <title> R.M., On the security of ping-pong protocols, </title> <note> Information and Control 55(1-3) pp. </note> <month> 57-68 </month> <year> (1982). </year>
Reference-contexts: He discusses many types of graph-reachability problems, including CFL-reachability. Dolev, Even, and Karp used CFL-reachability to devise a formal model for studying the vulnerability to intrusion by a third party of a class of two-party (ping-pong) protocols in distributed systems to intrusion by a third party <ref> [28] </ref>. Although messages in the system are protected by public-key encryption, in the setting studied by Dolev, Even, and Karp, the intruder - 27 - . . . may be a legitimate user in the network. <p> Acknowledgements This paper is based, in part, on joint work with S. Horwitz, M. Sagiv, G. Rosay, and D. Melski. Section 4.4 is based on a heretofore unpublished result by D. Melski. J. Kleinberg pointed out the use of CFL-reachability in reference <ref> [28] </ref>.
Reference: 29. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven program analysis, </title> <type> Tech. Rep. </type> <institution> TR-93-15, Dept. of Comp. Sci., Univ. of Pittsburgh, </institution> <address> Pittsburgh, PA (Oct. </address> <year> 1993). </year> <month> - 29 </month> - 
Reference: 30. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven computation of interprocedural data flow, pp. </title> <booktitle> 37-48 in Conf. Rec. of the Twenty-Second ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 31. <author> Fa hndrich, M., Foster, J.S., Su, Z., and Aiken, A., </author> <title> Partial online cycle elimination in inclusion constraint graphs, </title> <booktitle> Proc. of the ACM SIGPLAN 98 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Montreal, Canada, </address> <month> June 17-19, </month> <year> 1998), </year> <pages> pp. </pages> <publisher> 85-96 ACM Press, </publisher> <year> (1998). </year>
Reference-contexts: Set constraints have been used both for program analysis [85,50,5,40,41], and for type inference [6,7]. In some papers in the literature, the value of converting set-constraint problems to graph-reachability problems has been exploited, both from the conceptual standpoint [70], as well as from the implementation standpoint <ref> [31] </ref>. Melski and Reps have obtained a number of results on the relationship between set constraints and graph reachability [66]. Their results establish a relationship in both directions: They showed that CFL-reachability problems and a subclass of what have been called definite set constraints [39] are equivalent.
Reference: 32. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference: 33. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: The IFDS problems include, but are not limited to, the classical gen/kill problems (also known as the bit-vector or separable problems), e.g., reaching definitions, available expressions, live variables, etc. In addition, the IFDS problems include many non-gen/kill problems, including possibly-uninitialized variables, truly-live variables [35], and copy-constant propagation <ref> [33, pp. 660] </ref>. Expressing a problem so that it falls within the IFDS framework may, in some cases, involve a loss of precision. For example, there may be a loss of precision involved in formulating an IFDS version of a problem that must account for aliasing.
Reference: 34. <author> Gallagher, K.B. and Lyle, J.R., </author> <title> Using program slicing in software maintenance, </title> <journal> IEEE Trans. on Softw. Eng. SE-17(8) pp. </journal> <month> 751-761 (Aug. </month> <year> 1991). </year>
Reference-contexts: Interprocedural Program Slicing Slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not necessarily textually contiguous [98,72,32,46,77,92,19]. Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, - 11 - including tools for program understanding, maintenance <ref> [34] </ref>, debugging [61], testing [18,16], differencing [45,47], specialization [83], reuse [71], and merging [45].
Reference: 35. <author> Giegerich, R., Mo .. ncke, U., and Wilhelm, R., </author> <title> Invariance of approximative semantics with respect to program transformation, pp. </title> <booktitle> 1-10 in GI 81: 11th GI Conf., Inf.-Fach. </booktitle> <volume> 50, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1981). </address>
Reference-contexts: The IFDS problems include, but are not limited to, the classical gen/kill problems (also known as the bit-vector or separable problems), e.g., reaching definitions, available expressions, live variables, etc. In addition, the IFDS problems include many non-gen/kill problems, including possibly-uninitialized variables, truly-live variables <ref> [35] </ref>, and copy-constant propagation [33, pp. 660]. Expressing a problem so that it falls within the IFDS framework may, in some cases, involve a loss of precision. For example, there may be a loss of precision involved in formulating an IFDS version of a problem that must account for aliasing.
Reference: 36. <author> Goff, G., Kennedy, K., and Tseng, C.-W., </author> <title> Practical dependence testing, </title> <booktitle> Proc. of the ACM SIGPLAN 91 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> SIGPLAN Not. </journal> <pages> 26(6) pp. </pages> <month> 15-29 (June </month> <year> 1991). </year>
Reference: 37. <author> Grove, D. and Torczon, L., </author> <title> Interprocedural constant propagation: A study of jump function implementation, pp. </title> <booktitle> 90-99 in Proc. of the ACM SIGPLAN 93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Albuquerque, NM, June 23-25, 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (June 1993). </address>
Reference-contexts: An experiment was carried out in which the exhaustive and demand algorithms were used to perform constant propagation on 38 C programs, which ranged in size from 300 lines to 6,000 lines. The experiment found that g In contrast to previous results for numeric Fortran programs <ref> [37] </ref>, linear-constant propagation found more constants than copy-constant propagation in 6 of the 38 programs. g The demand algorithm, when used to demand values for all uses of scalar integer variables, was faster than the exhaustive algorithm by a factor ranging from 1.14 to about 6. 7.
Reference: 38. <author> Hecht, </author> <title> M.S., Flow Analysis of Computer Programs, </title> <publisher> North-Holland, </publisher> <address> New York, NY (1977). </address>
Reference-contexts: This section discusses how the CFL-reachability approach relates to previous work on program analysis. 7.1. The Use of Graph Reachability for Analyzing Programs A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [57] and Hecht <ref> [38] </ref> gave linear-time graph-reachability algorithms for solving intrapro-cedural bit-vector dataflow-analysis problems. This approach was later applied to intraprocedural bidirectional bit-vector problems by Khedker and Dhamdhere [53]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [23] and alias analysis [24].
Reference: 39. <author> Heintze, N. and Jaffar, J., </author> <title> A decision procedure for a class of set constraints, </title> <type> Tech. Rep. </type> <institution> CMU-CS-91-110, School of Computer Science, Carnegie Mellon Univ., </institution> <address> Pittsburgh, PA (1991). </address>
Reference-contexts: Melski and Reps have obtained a number of results on the relationship between set constraints and graph reachability [66]. Their results establish a relationship in both directions: They showed that CFL-reachability problems and a subclass of what have been called definite set constraints <ref> [39] </ref> are equivalent. That is, given a CFL-reachability problem, it is possible to construct a set-constraint problem whose answer gives the solution to the CFL-reachability problem; likewise, given a set-constraint problem, it is possible to construct a CFL-reachability problem whose answer gives the solution to the set-constraint problem.
Reference: 40. <author> Heintze, N., </author> <title> Set-based analysis of ML programs, </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-193, School of Computer Science, Carnegie Mellon Univ., </institution> <address> Pittsburgh, PA (July 1993). </address>
Reference-contexts: In [67], these results have been extended to cover a class of set constraints that is known to be useful for analyzing programs written in higher-order languages <ref> [40] </ref>. <p> Set constraints have been used for analyzing programs written in higher-order languages, whereas applications of CFL-reachability to program analysis have been limited to first-order languages. However, recent work on the interconvertibility of CFL-reachability problems and the class of set constraints used in <ref> [40] </ref> for analyzing programs written in higher-order languages, shows that the CFL-reachability framework is capable of expressing analysis problems, such as program slicing and shape analysis, for higher-order languages [67].
Reference: 41. <author> Heintze, N. and Jaffar, J., </author> <title> Set constraints and set-based analysis, </title> <booktitle> in 2nd Workshop on Principles and Practice of Constraint Programming, </booktitle> <month> (May </month> <year> 1994). </year>
Reference: 42. <author> Holley, L.H. and Rosen, B.K., </author> <title> Qualified data flow problems, </title> <journal> IEEE Trans. on Softw. Eng. SE-7(1) pp. </journal> <month> 60-78 (Jan. </month> <year> 1981). </year>
Reference-contexts: Holley and Rosen investigated qualified dataflow analysis problems, where qualifications are a device to specify that only certain paths in the flow graph are to be considered <ref> [42] </ref>. They employ an expansion phase that has some similarities to the creation of the exploded supergraph described in Section 4.1. However, Holley and Rosen do not take advantage of distributivity to do the expansion pointwise. Furthermore, for interprocedural problems the Holley-Rosen approach is equivalent to the Sharir-Pnueli call-strings approach.
Reference: 43. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <booktitle> Proc. of the ACM SIGPLAN 88 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> SIGPLAN Not. </journal> <pages> 23(7) pp. </pages> <month> 35-46 (July </month> <year> 1988). </year>
Reference: 44. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proc. of the ACM SIGPLAN 89 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> SIGPLAN Not. </journal> <pages> 24(7) pp. </pages> <month> 28-40 (July </month> <year> 1989). </year>
Reference: 45. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, - 11 - including tools for program understanding, maintenance [34], debugging [61], testing [18,16], differencing [45,47], specialization [83], reuse [71], and merging <ref> [45] </ref>.
Reference: 46. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (Jan. </month> <year> 1990). </year>
Reference-contexts: The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls. For this purpose, it is convenient to use system dependence graphs (SDGs), which are a variant of PDGs extended to handle multiple procedures <ref> [46] </ref>. An SDG consists of a collection of procedure dependence graphs (which we will refer to as PDGs)one for each procedure, including the main procedure. <p> A large body of work exists concerning techniques for building dependence graphs for a wide variety of programming-language features and constructs. For example, previous work has addressed arrays [14,99,63,36,73,74], reference parameters <ref> [46] </ref>, pointers [60,44,21,87], and non-structured control flow [12,22,2]. The issue of how to create appropriate PDGs/SDGs is mostly orthogonal to the issue of how to slice them. Once an SDG has been constructed, slicing can be formulated as a CFL-reachability problem. <p> Horwitz, Reps, and Binkley pointed out a correspondence between the call structure of a program and a context-free grammar, and between the intraprocedural transitive dependences among a PDG's parameter nodes and the dependences among attributes in an attribute grammar <ref> [46] </ref>. They exploited this correspondence to compute the summary edges used in the hybrid (i.e., partly exhaustive, partly demand) scheme for interprocedural slicing discussed in Section 5.
Reference: 47. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proc. of the ACM SIGPLAN 90 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> SIGPLAN Not. </journal> <pages> 25(6) pp. </pages> <month> 234-245 (June </month> <year> 1990). </year>
Reference: 48. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <institution> TR-1283, Comp. Sci. Dept., Univ. of Wisconsin, Madison, </institution> <address> WI (Aug. </address> <year> 1995). </year>
Reference: 49. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <booktitle> SIGSOFT 95: Proc. of the Third ACM SIGSOFT Symp. on the Found. of Softw. </booktitle> <address> Eng., (Wash., DC, </address> <month> Oct. </month> <pages> 10-13, </pages> <year> 1995), </year> <journal> ACM SIGSOFT Softw. Eng. </journal> <note> Notes 20(4) pp. </note> <month> 104-115 </month> <year> (1995). </year>
Reference-contexts: For program-analysis problems that can be expressed as CFL-reachability problems, demand algorithms are easily obtained by solving single-source, single-target, multi-source, or multi-target CFL-reachability problems <ref> [49] </ref>. g Graph reachability offers insight into the O (n 3 ) bottleneck that exists for certain kinds of program-analysis problems. That is, a number of program-analysis problems are known to be solvable in time O (n 3 ), but no sub-cubic-time algorithm is known.
Reference: 50. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Flow analysis and optimization of Lisp-like structures, pp. 102-131 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: two tree grammars: (i) v r,A fi cons (v p,B , v p,C ) | cons (v q,D , v q,E ) (ii) v r,A fi cons (v p,B | v q,D , v p,C | v q,E ) Grammar (i) uses multiple cons right-hand sides for a given nonterminal <ref> [50] </ref>. In grammar (ii), the link between branches in different cons alternatives is broken, and a single cons right-hand side is formed with a collection of alternative nonterminals in each arm [68]. <p> Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog. 7.3. Relationship of CFL-Reachability Problems to Set-Constraint Problems Following earlier work by Reynolds [85] and Jones and Muchnick <ref> [50] </ref>, a number of people in recent years have explored the use of set constraints for analyzing programs. Set constraints are typically used to collect a superset of the set of values that the program's variables may hold during execution.
Reference: 51. <author> Kastens, U., </author> <title> Ordered attribute grammars, </title> <journal> Acta Inf. </journal> <pages> 13(3) pp. </pages> <month> 229-256 </month> <year> (1980). </year>
Reference-contexts: More generally, the computation of IO graphs of attribute grammars [52,27,69] and other similar approximations to the characteristic graphs of an attribute grammar's nonterminals that can be computed in polynomial time, such as TDS graphs of ordered attribute grammars <ref> [51] </ref> can be expressed as CFL-reachability problems.
Reference: 52. <author> Kennedy, K. and Warren, </author> <title> S.K., Automatic generation of efficient evaluators for attribute grammars, pp. </title> <booktitle> 32-49 in Conf. Rec. of the Third ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Atlanta, GA, </address> <month> Jan. </month> <pages> 19-21, </pages> <address> 1976), </address> <publisher> ACM, </publisher> <address> New York, NY (1976). </address>
Reference: 53. <author> Khedker, </author> <title> U.P. and Dhamdhere, D.M., A generalized theory of bit vector data flow analysis, </title> <journal> ACM Trans. Pro gram. Lang. Syst. </journal> <pages> 16(5) pp. </pages> <month> 1472-1511 (Sept. </month> <year> 1994). </year>
Reference-contexts: Kou [57] and Hecht [38] gave linear-time graph-reachability algorithms for solving intrapro-cedural bit-vector dataflow-analysis problems. This approach was later applied to intraprocedural bidirectional bit-vector problems by Khedker and Dhamdhere <ref> [53] </ref>. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [23] and alias analysis [24]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [20] and Horwitz, Reps, and Binkley's work on interprocedural slicing [43,46].
Reference: 54. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conf. Rec. of the First ACM Symp. on Princ. of Prog. Lang., ACM, </booktitle> <address> New York, NY (1973). </address> - <month> 30 </month> - 
Reference-contexts: of q; the goal is to determine, for each node n, the meet-over-all-paths solution: MOP n = q Paths (start, n) c dd c pf q ( i c i ), where Paths (start, n) denotes the set of paths in the control-flow graph from the start node to n <ref> [54] </ref>. 2 MOP n represents a summary of the possible execution states that can arise at n; i c i V is a special value that represents the execution state at the beginning of the program; pf q ( i c i ) represents the contribution of path q to the
Reference: 55. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proc. of the Fourth Int. Conf. on Comp. Construct., (Paderborn, </booktitle> <address> FRG, </address> <month> Oct. </month> <pages> 5-7, </pages> <year> 1992), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler,Springer-Verlag, </editor> <address> New York, NY (1992). </address>
Reference-contexts: Both the IFDS framework for interprocedural dataflow analysis [76,81,49,48] as well as the IDE framework for interprocedural dataflow analysis [88], which are summarized in Sections 4.1 and 6, respectively, are related to earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [90] and Knoop and Steffen <ref> [55] </ref>. <p> Condition (iii), however, generalizes the Sharir-Pnueli framework and permits it to cover programming languages in which recursive procedures have local variables and parameters (which the Sharir-Pnueli framework does not). (A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen <ref> [55] </ref>.) IFDS and IDE problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli, and the algorithm of Cousot and - 25 - Cousot [26]. <p> However, for general IFDS and IDE problems, both the iterative and call-strings algorithms can take exponential time in the worst case. Knoop and Steffen <ref> [55] </ref> give an algorithm similar to Sharir and Pnueli's elimination algorithm. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [90] and [55]; however, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather <p> Knoop and Steffen <ref> [55] </ref> give an algorithm similar to Sharir and Pnueli's elimination algorithm. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [90] and [55]; however, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, they are not as efficient as the algorithms presented in [81] and [88].
Reference: 56. <author> Knuth, D.E., Morris, J.H., and Pratt, </author> <title> V.R., Fast pattern matching in strings, </title> <note> SIAM J. Computing 6(2) pp. </note> <month> 323-350 </month> <year> (1977). </year>
Reference: 57. <author> Kou, L.T., </author> <title> On live-dead analysis for global data flow problems, </title> <journal> J. ACM 24(3) pp. </journal> <month> 473-483 (July </month> <year> 1977). </year>
Reference-contexts: This section discusses how the CFL-reachability approach relates to previous work on program analysis. 7.1. The Use of Graph Reachability for Analyzing Programs A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou <ref> [57] </ref> and Hecht [38] gave linear-time graph-reachability algorithms for solving intrapro-cedural bit-vector dataflow-analysis problems. This approach was later applied to intraprocedural bidirectional bit-vector problems by Khedker and Dhamdhere [53]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [23] and alias analysis [24].
Reference: 58. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conf. Rec. of the Eighth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Williamsburg, VA, </address> <month> Jan. </month> <pages> 26-28, </pages> <address> 1981), </address> <publisher> ACM, </publisher> <address> New York, NY (1981). </address>
Reference: 59. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conf. Rec. of the Eighteenth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Orlando, FL, </address> <month> Jan. </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference: 60. <author> Larus, J.R. and Hilfinger, </author> <title> P.N., Detecting conflicts between structure accesses, </title> <booktitle> Proc. of the ACM SIGPLAN 88 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> SIGPLAN Not. </journal> <pages> 23(7) pp. </pages> <month> 21-34 (July </month> <year> 1988). </year>
Reference: 61. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proc. of the First Conf. on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, - 11 - including tools for program understanding, maintenance [34], debugging <ref> [61] </ref>, testing [18,16], differencing [45,47], specialization [83], reuse [71], and merging [45].
Reference: 62. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Res. Cent., </institution> <address> Palo Alto, CA (Jan. </address> <year> 1980). </year>
Reference-contexts: It is desirable to have program-development tools in which the user can ask questions interactively about various aspects of a program <ref> [62] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine [8].
Reference: 63. <author> Maydan, D.E., Hennessy, J.L., and Lam, </author> <title> M.S., Efficient and exact data dependence analysis, </title> <booktitle> Proc. of the ACM SIGPLAN 91 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> SIGPLAN Not. </journal> <pages> 26(6) pp. </pages> <month> 1-14 (June </month> <year> 1991). </year>
Reference: 64. <author> McCarthy, J., </author> <title> A basis for a mathematical theory of computation, </title> <note> pp. 33-70 in Computer Programming and Formal Systems, </note> <editor> ed. Braffort and Hershberg,North-Holland, </editor> <address> Amsterdam (1963). </address>
Reference-contexts: Thus, the second and third rules of the L 1 grammar are the grammar-theoretic analogs of McCarthy's rules: car (cons (x, y)) = x and cdr (cons (x, y)) = y <ref> [64] </ref>. The language L 2 represents paths that are slightly unbalancedthose with one unmatched hd ; these paths correspond to the possible values that could be accessed by performing one additional car operation (which would extend the path with an additional hd -1 ).
Reference: 65. <author> Melski, D., </author> <title> Personal communication to T. </title> <type> Reps, </type> <month> Fall </month> <year> 1996. </year>
Reference-contexts: The way to overcome this difficulty is shown in Figure 9: Figure 9 (a) shows the revised set of base facts generated for hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 The construction we give for this step is due to David Melski <ref> [65] </ref>. - 19 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Statement Facts generated iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii p = &q; fi assignAddr (p,q). assignAddr hhhhhhhhh (q,p). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii p = q; fi assign (p,q). assign hhhhh (q,p). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii p = *q; fi assignStar (p,q). assignStar hhhhhhhhh (q,p). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii *p = q; fi starAssign (p,q). starAssign hhhhhhhhh (q,p).
Reference: 66. <author> Melski, D. and Reps, T., </author> <title> Interconvertibility of set constraints and context-free language reachability, pp. </title> <booktitle> 74-89 in Proc. of the ACM SIGPLAN Symp. on Part. Eval. and Sem.-Based Prog. </booktitle> <address> Manip. (PEPM 97), (Amsterdam, The Netherlands, June 12-13, 1997), </address> <publisher> ACM, </publisher> <address> New York, NY (1997). </address>
Reference-contexts: The solution is obtained from the edges labeled with the grammar's root symbol. When an appropriate worklist algorithm is used (together with suitable indexing structures), the running time of this algorithm is cubic in the number of nodes in the graph <ref> [66] </ref>. (This algorithm can be thought of as a generalization of the CYK algorithm for CFL-recognition [101].) Although all CFL-reachability problems can be solved in time cubic in the number of graph nodes, one can sometimes do asymptotically better than this by taking advantage of the structure of the graph that <p> Melski and Reps have obtained a number of results on the relationship between set constraints and graph reachability <ref> [66] </ref>. Their results establish a relationship in both directions: They showed that CFL-reachability problems and a subclass of what have been called definite set constraints [39] are equivalent. <p> Because the CFL-reachability-to-set-constraint construction can be performed in log-space, the set-constraint problems considered in <ref> [66] </ref> are also PTIME-complete. Because PTIME-complete problems are believed not to be efficiently parallelizable (i.e., cannot be solved in polylog time on a polynomial number of processors), this extends the class of program-analysis problems that are unlikely to have efficient parallel algorithms.
Reference: 67. <author> Melski, D. and Reps, T., </author> <title> Interconvertibility of set constraints and context-free language reachability, </title> <journal> Theor. Comp. </journal> <note> Sci., (). (Accepted, pending minor revisions.) </note>
Reference-contexts: That is, given a CFL-reachability problem, it is possible to construct a set-constraint problem whose answer gives the solution to the CFL-reachability problem; likewise, given a set-constraint problem, it is possible to construct a CFL-reachability problem whose answer gives the solution to the set-constraint problem. In <ref> [67] </ref>, these results have been extended to cover a class of set constraints that is known to be useful for analyzing programs written in higher-order languages [40]. <p> However, recent work on the interconvertibility of CFL-reachability problems and the class of set constraints used in [40] for analyzing programs written in higher-order languages, shows that the CFL-reachability framework is capable of expressing analysis problems, such as program slicing and shape analysis, for higher-order languages <ref> [67] </ref>. In particular, one of the constructions given in [67] shows how CFL-reachability can be applied to the problem of slicing programs written in a higher-order language that manipulates heap-allocated data structures (but does not permit destructive updating of fields). <p> interconvertibility of CFL-reachability problems and the class of set constraints used in [40] for analyzing programs written in higher-order languages, shows that the CFL-reachability framework is capable of expressing analysis problems, such as program slicing and shape analysis, for higher-order languages <ref> [67] </ref>. In particular, one of the constructions given in [67] shows how CFL-reachability can be applied to the problem of slicing programs written in a higher-order language that manipulates heap-allocated data structures (but does not permit destructive updating of fields). This problem had not been previously addressed in the literature on program slicing. 7.4.
Reference: 68. <author> Mogensen, T., </author> <title> Separating binding times in language specifications, pp. </title> <booktitle> 12-25 in Fourth Int. Conf. on Func. Prog. and Comp. Arch., </booktitle> <address> (London, UK, </address> <month> Sept. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: In our work, however, we use an alternative approach: The value of each dataflow variable is a single Shape (i.e., a single set of root-to-leaf paths), and the join operation is union <ref> [68] </ref>. Functions cons, car, and cdr are functions from Shape to Shape. For example, cons is defined as: cons = df lS 1 .lS 2 .- hd.p 1 | p 1 S 1 - - tl.p 2 | p 2 S 2 -. <p> In grammar (ii), the link between branches in different cons alternatives is broken, and a single cons right-hand side is formed with a collection of alternative nonterminals in each arm <ref> [68] </ref>. The shape descriptions are sharper with grammars of type (i): With grammar (i), nonterminals v p,B and v q,E can never occur simultaneously as children of v r,A , whereas grammar (ii) associates nonterminal v r,A with trees of the form cons (v p,B , v q,E ).
Reference: 69. <author> Mo ncke, U. and Wilhelm, R., </author> <title> Grammar flow analysis, pp. 151-186 in Attribute Grammars, </title> <booktitle> Applications and Systems, (Int. Summer School SAGA, </booktitle> <address> Prague, Czechoslovakia, </address> <month> June </month> <year> 1991), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 545, </volume> <editor> ed. H. Alblas and B. Melichar,Springer-Verlag, </editor> <address> New York, NY (1991). </address>
Reference: 70. <author> Nielson, F., Nielson, H.R., and Hankin, C., </author> <title> Principles of Program Analysis: Flows and Effects, </title> <publisher> Cambridge Univ. Press, </publisher> <address> Cambridge, </address> <note> UK (). (In preparation.) </note>
Reference-contexts: Set constraints have been used both for program analysis [85,50,5,40,41], and for type inference [6,7]. In some papers in the literature, the value of converting set-constraint problems to graph-reachability problems has been exploited, both from the conceptual standpoint <ref> [70] </ref>, as well as from the implementation standpoint [31]. Melski and Reps have obtained a number of results on the relationship between set constraints and graph reachability [66].
Reference: 71. <author> Ning, J.Q., Engberts, A., and Kozaczynski, W., </author> <title> Automated support for legacy code understanding, </title> <journal> Commun. ACM 37(5) pp. </journal> <month> 50-57 (May </month> <year> 1994). </year>
Reference-contexts: Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, - 11 - including tools for program understanding, maintenance [34], debugging [61], testing [18,16], differencing [45,47], specialization [83], reuse <ref> [71] </ref>, and merging [45].
Reference: 72. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <journal> Proc. of the ACM SIGSOFT/SIGPLAN Softw. Eng. Symp. on Practical Softw. </journal> <pages> Develop. </pages> <address> Env., (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> SIGPLAN Not. </journal> <pages> 19(5) pp. </pages> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: Consequently, a slice can be obtained by following chains of dependences in the directly-affects relation. This observation is due to Ottenstein and Ottenstein <ref> [72] </ref>, who noted that program dependence graphs (PDGs), which were originally devised for use in parallelizing and vectorizing compilers, are a convenient data structure for slicing. The PDG for a program is a directed graph whose nodes are connected by several kinds of edges.
Reference: 73. <author> Pugh, W., </author> <title> The Omega test: A fast and practical integer programming algorithm for dependence analysis, </title> <booktitle> in Supercomputing 1991, </booktitle> <month> (Nov. </month> <year> 1991). </year>
Reference: 74. <author> Pugh, W. and Wonnacott, D., </author> <title> Eliminating false data dependences using the Omega test, </title> <booktitle> Proc. of the ACM SIG-PLAN 92 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (San Francisco, CA, </address> <month> June 17-19, </month> <year> 1992), </year> <journal> SIGPLAN Not. </journal> <pages> 27(7) pp. </pages> <month> 140-151 (July </month> <year> 1992). </year>
Reference: 75. <author> Ramalingam, G., </author> <title> Data flow frequency analysis, </title> <booktitle> Proc. of the ACM SIGPLAN 96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> (Philadelphia, PA, </address> <month> May 21-24, </month> <year> 1996), </year> <pages> pp. </pages> <publisher> 267-277 ACM Press, </publisher> <year> (1996). </year>
Reference-contexts: Recently, Ramalingam has shown how a framework very similar to the IDE framework can be used to develop a theory of dataflow frequency analysis, in which information is obtained about how often and with what probability a dataflow fact holds true during program execution <ref> [75] </ref>. Holley and Rosen investigated qualified dataflow analysis problems, where qualifications are a device to specify that only certain paths in the flow graph are to be considered [42]. They employ an expansion phase that has some similarities to the creation of the exploded supergraph described in Section 4.1.
Reference: 76. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> TR 94-14, </type> <institution> Datalogisk Institut, Univ. of Copenhagen, Copenhagen, Denmark (Apr. </institution> <year> 1994). </year>
Reference-contexts: We assume that the meet operator is union; it is not hard to show that IFDS problems in which the meet operator is intersection can always be handled by dualizing, i.e., by transforming such a problem into a complementary problem in which the meet operator is union <ref> [76] </ref>. (Informally, if the must-be-X problem is an intersection IFDS problem, then the may-not-be-X problem is a union IFDS problem. <p> those that correspond to realizable paths in G * ; these are exactly the realizable paths in G # . (For a proof that a dataflow fact d is in MRP n iff there is a realizable path in G # from node start main ,L to node n,d, see <ref> [76] </ref>.) Example. The exploded supergraph that corresponds to the instance of the possibly-uninitialized variables problem shown in Fig. 1 is shown in Fig. 4. The dataflow functions are replaced by their representation relations. In Fig. 4, closed circles represent nodes that are reachable along realizable paths from start main ,L. <p> certain kinds of infeasible execution paths should be filtered out [90]; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps, Sagiv, and Horwitz to be of utility for a wide variety of interprocedural program-analysis problems <ref> [76] </ref>. These ideas were elaborated on in a sequence of papers [77,81,49], and also applied to the shape-analysis problem [80]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: 77. <author> Reps, T., Horwitz, S., Sagiv, M., and Rosay, G., </author> <title> Speeding up slicing, </title> <booktitle> SIGSOFT 94: Proc. of the Second ACM SIGSOFT Symp. on the Found. of Softw. </booktitle> <address> Eng., (New Orleans, LA, </address> <month> Dec. </month> <pages> 7-9, </pages> <year> 1994), </year> <journal> ACM SIGSOFT Softw. Eng. </journal> <note> Notes 19(5) pp. 11-20 (Dec. </note> <year> 1994). </year>
Reference-contexts: A similar improvement over the general-case time bound can be obtained for the interprocedural-slicing problem, discussed in Section 4.2 <ref> [77] </ref>. <p> There are no more than CallSites Params 2 summary edges, and the task of identifying all summary edges can be performed in time O ((P E Params) + (CallSites Params 3 )) <ref> [77] </ref>. By the augmented SDG, we mean the SDG after all appropriate summary edges have been added to it. The second, demand-driven, stage involves only regular-reachability problems on the augmented SDG.
Reference: 78. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, </title> <note> pp. 163-196 in Applications of Logic Databases, </note> <editor> ed. R. </editor> <publisher> Ramakrishnan,Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address>
Reference-contexts: fact that CFL-reachability problems are related to chain programs, together with the fact that chain programs are just a special case of the logic programs to which tabulation and transformation techniques apply, suggests that more powerful program-analysis algorithms can be obtained by going outside the class of pure chain programs <ref> [78] </ref>. A different way to generalize the CFL-reachability approach so as to bring more powerful techniques to bear on interprocedural dataflow analysis was presented in [88].
Reference: 79. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, pp. </title> <booktitle> 389-403 in Proc. of the Fifth Int. Conf. on Comp. Construct., </booktitle> <address> (Edinburgh, Scotland, </address> <month> Apr. </month> <pages> 7-9, </pages> <year> 1994), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson,Springer-Verlag, </editor> <address> New York, NY (1994). </address> - <month> 31 </month> - 
Reference: 80. <author> Reps, T., </author> <title> Shape analysis as a generalized path problem, pp. </title> <booktitle> 1-11 in Proc. of the ACM SIGPLAN Symp. on Part. Eval. and Sem.-Based Prog. </booktitle> <address> Manip. (PEPM 95), (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: These ideas were elaborated on in a sequence of papers [77,81,49], and also applied to the shape-analysis problem <ref> [80] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. Although the author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994, of the papers mentioned above, only [80] mentions CFL-reachability explicitly and references Yannakakis's <p> also applied to the shape-analysis problem <ref> [80] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. Although the author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994, of the papers mentioned above, only [80] mentions CFL-reachability explicitly and references Yannakakis's paper [100].
Reference: 81. <author> Reps, T., Horwitz, S., and Sagiv, M., </author> <title> Precise interprocedural dataflow analysis via graph reachability, pp. </title> <booktitle> 49-61 in Conf. Rec. of the Twenty-Second ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: No representations are discussed in [90] and [55]; however, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, they are not as efficient as the algorithms presented in <ref> [81] </ref> and [88]. Recently, Ramalingam has shown how a framework very similar to the IDE framework can be used to develop a theory of dataflow frequency analysis, in which information is obtained about how often and with what probability a dataflow fact holds true during program execution [75]. <p> Thus, another way to obtain implementations of demand algorithms for interprocedural dataflow analysis, interprocedural slicing, and other CFL-reachability problems is to make use of the SUNY-Stony Brook XSB system [97]. The algorithms described in <ref> [81] </ref> and [88] for the IFDS and IDE frameworks, respectively, have straightforward implementations as logic programs. Thus, demand algorithms for these frameworks can be obtained either by applying the magic-sets transformation or by using a tabulating top-down evaluator.
Reference: 82. <author> Reps, T., </author> <title> On the sequential nature of interprocedural program-analysis problems, </title> <journal> Acta Inf. </journal> <pages> 33 pp. </pages> <month> 739-757 </month> <year> (1996). </year>
Reference-contexts: The connection between program analysis and CFL-reachability has been used to establish a number of results that very likely imply that there are limitations on the ability to create efficient parallel algorithms for interprocedural slicing and interprocedural dataflow analysis <ref> [82] </ref>.
Reference: 83. <author> Reps, T. and Turnidge, T., </author> <title> Program specialization via program slicing, pp. </title> <booktitle> 409-429 in Proc. of the Dagstuhl Seminar on Partial Evaluation, </booktitle> <address> (Schloss Dagstuhl, Wadern, Ger., </address> <month> Feb. </month> <pages> 12-16, </pages> <year> 1996), </year> <title> Lec. </title> <booktitle> Notes in Comp. Sci., </booktitle> <volume> Vol. 1110, </volume> <editor> ed. O. Danvy, R. Glueck, and P. Thiemann,Springer-Verlag, </editor> <address> New York, NY (1996). </address>
Reference-contexts: Slicing, and subsequent manipulation of slices, has applications in many software-engineering tools, - 11 - including tools for program understanding, maintenance [34], debugging [61], testing [18,16], differencing [45,47], specialization <ref> [83] </ref>, reuse [71], and merging [45].
Reference: 84. <author> Reps, T., </author> <title> Program analysis via graph reachability, pp. </title> <booktitle> 5-19 in Proc. of ILPS 97: Int. Logic Program. Symp., (Port Jefferson, </booktitle> <address> NY, </address> <month> Oct. </month> <pages> 12-17, </pages> <year> 1997), </year> <editor> ed. J. </editor> <publisher> Maluszynski,The M.I.T. Press, </publisher> <address> Cambridge, MA (1997). </address>
Reference-contexts: CFL-reachability is defined in Section 2. Some of the program-analysis problems that are amenable to this treatment include: hhhhhhhhhhhhhhhhhhhhhhhh An abbreviated version of this paper appeared as an invited paper in the Proceedings of the 1997 International Symposium on Logic Programming <ref> [84] </ref>.
Reference: 85. <author> Reynolds, </author> <title> J.C., Automatic computation of data set definitions, pp. </title> <booktitle> 456-461 in Information Processing 68: Proc. of the IFIP Congress 68, </booktitle> <publisher> North-Holland, </publisher> <address> New York, NY (1968). </address>
Reference-contexts: This indirect information can be viewed as a simplified set of equations <ref> [85] </ref>, or, equivalently, as a regular-tree grammar [50,68]. The use of domain Shape in place of 2 Shape does involve some loss of precision. <p> Assmann has examined a variety of other intraprocedural program-analysis problems [10]. Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog. 7.3. Relationship of CFL-Reachability Problems to Set-Constraint Problems Following earlier work by Reynolds <ref> [85] </ref> and Jones and Muchnick [50], a number of people in recent years have explored the use of set constraints for analyzing programs. Set constraints are typically used to collect a superset of the set of values that the program's variables may hold during execution.
Reference: 86. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference: 87. <author> Ross, J.L. and Sagiv, M., </author> <title> Building a bridge between pointer aliases and program dependences, </title> <booktitle> in Proc. of the European Symp. on Programming, </booktitle> <address> (Lisbon, Portugal, </address> <month> April 2-3, </month> <year> 1998), (1998). </year>
Reference: 88. <author> Sagiv, M., Reps, T., and Horwitz, S., </author> <title> Precise interprocedural dataflow analysis with applications to constant propagation, </title> <journal> Theor. Comp. Sci. </journal> <pages> 167 pp. </pages> <month> 131-170 </month> <year> (1996). </year>
Reference-contexts: A different way to generalize the CFL-reachability approach so as to bring more powerful techniques to bear on interprocedural dataflow analysis was presented in <ref> [88] </ref>. This method applies to problems in which the dataflow information at a program point is represented by a finite environment (i.e., a mapping from a finite set of symbols to a finite-height domain of values), and the effect of a program operation is captured by a distributive environment-transformer function. <p> transformation similar to the one utilized in Section 4.1, an interprocedural distributive-environment-transformer problem can be transformed from a meet-over-all-realizable-paths problem on a program's supergraph to a meet-over-all-realizable-paths problem on a graph that is larger, but in which every edge is labeled with a much simpler edge function (a so-called micro-function) <ref> [88] </ref>. Each micro-function on an edge d 1 fi d 2 captures the effect that the value of symbol d 1 in the argument environment has on the value of symbol d 2 in the result environment. <p> The exploded representations of four environment-transformer functions used in constant propagation. - 24 - particular program point <ref> [88] </ref>. An experiment was carried out in which the exhaustive and demand algorithms were used to perform constant propagation on 38 C programs, which ranged in size from 300 lines to 6,000 lines. <p> Both the IFDS framework for interprocedural dataflow analysis [76,81,49,48] as well as the IDE framework for interprocedural dataflow analysis <ref> [88] </ref>, which are summarized in Sections 4.1 and 6, respectively, are related to earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [90] and Knoop and Steffen [55]. <p> No representations are discussed in [90] and [55]; however, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, they are not as efficient as the algorithms presented in [81] and <ref> [88] </ref>. Recently, Ramalingam has shown how a framework very similar to the IDE framework can be used to develop a theory of dataflow frequency analysis, in which information is obtained about how often and with what probability a dataflow fact holds true during program execution [75]. <p> Thus, another way to obtain implementations of demand algorithms for interprocedural dataflow analysis, interprocedural slicing, and other CFL-reachability problems is to make use of the SUNY-Stony Brook XSB system [97]. The algorithms described in [81] and <ref> [88] </ref> for the IFDS and IDE frameworks, respectively, have straightforward implementations as logic programs. Thus, demand algorithms for these frameworks can be obtained either by applying the magic-sets transformation or by using a tabulating top-down evaluator.
Reference: 89. <author> Shapiro, M. and Horwitz, S., </author> <title> Fast and accurate flow-insensitive points-to analysis, </title> <booktitle> in Conf. Rec. of the Twenty-Fourth ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (Paris, France, </address> <month> Jan. </month> <pages> 15-17, </pages> <address> 1997), </address> <publisher> ACM, </publisher> <address> New York, NY (1997). </address>
Reference-contexts: program is one that ignores the actual structure of the program's control-flow graph, and instead assumes that any statement can be executed immediately after any other statement. (Many type-inference algorithms are examples of flow-insensitive analyses.) Flow-insensitive points-to analyses have been developed by Andersen [9], Steensgaard [91], and Shapiro and Horwitz <ref> [89] </ref>. In this section, we show how a variant of Andersen's analysis, as reformulated by Shapiro and Horwitz [89], can be expressed as a CFL-reachability problem. <p> statement can be executed immediately after any other statement. (Many type-inference algorithms are examples of flow-insensitive analyses.) Flow-insensitive points-to analyses have been developed by Andersen [9], Steensgaard [91], and Shapiro and Horwitz <ref> [89] </ref>. In this section, we show how a variant of Andersen's analysis, as reformulated by Shapiro and Horwitz [89], can be expressed as a CFL-reachability problem. <p> Shapiro and Horwitz reformulate Andersen's algorithm as one that builds up a graph that represents points-to relationships among the program's variables <ref> [89] </ref>. 3 The nodes of the points-to graph represent the program's variables; an edge from the node for variable p to the node for variable q means p might point to q. <p> Example 4.2. Suppose that the program contains the following assignment statements: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 Reference <ref> [89] </ref> does not actually give a full description of the method; only an example of the final points-to graph is given, and the steps by which the graph is created are not explained. - 17 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Statement Fact generated iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii p = &q; fi assignAddr (p,q). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii <p> Points-to analysis expressed as a Datalog program: (a) Examples of base facts generated for each of the four statement kinds. (b) Examples illustrating how each kind of statement causes the points-to graph to be modified in the Shapiro-Horwitz formulation of Andersen's algorithm <ref> [89] </ref>.
Reference: 90. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: kinds of matched-parenthesis (Dyck) languages, and neither paper relates the work to the more general concept of CFL-reachability. (Dyck languages had been used in earlier work on interprocedural dataflow analysis by Sharir and Pnueli to specify that the contributions of certain kinds of infeasible execution paths should be filtered out <ref> [90] </ref>; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps, Sagiv, and Horwitz to be of utility for a wide variety of interprocedural program-analysis problems [76]. <p> Both the IFDS framework for interprocedural dataflow analysis [76,81,49,48] as well as the IDE framework for interprocedural dataflow analysis [88], which are summarized in Sections 4.1 and 6, respectively, are related to earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli <ref> [90] </ref> and Knoop and Steffen [55]. <p> Knoop and Steffen [55] give an algorithm similar to Sharir and Pnueli's elimination algorithm. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in <ref> [90] </ref> and [55]; however, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, they are not as efficient as the algorithms presented in [81] and [88].
Reference: 91. <author> Steensgaard, B., </author> <title> Points-to analysis in almost-linear time, pp. </title> <booktitle> 32-41 in Conf. Rec. of the Twenty-Third ACM Symp. on Princ. of Prog. </booktitle> <address> Lang., (St. Petersburg, FL, </address> <month> Jan. </month> <pages> 22-24, </pages> <address> 1996), </address> <publisher> ACM, </publisher> <address> New York, NY (1996). </address>
Reference-contexts: A flow-insensitive analysis of a program is one that ignores the actual structure of the program's control-flow graph, and instead assumes that any statement can be executed immediately after any other statement. (Many type-inference algorithms are examples of flow-insensitive analyses.) Flow-insensitive points-to analyses have been developed by Andersen [9], Steensgaard <ref> [91] </ref>, and Shapiro and Horwitz [89]. In this section, we show how a variant of Andersen's analysis, as reformulated by Shapiro and Horwitz [89], can be expressed as a CFL-reachability problem.
Reference: 92. <author> Tip, F., </author> <title> A survey of program slicing techniques, </title> <editor> J. </editor> <booktitle> Program. Lang. </booktitle> <pages> 3 pp. </pages> <month> 121-181 </month> <year> (1995). </year>
Reference: 93. <author> Ullman, J.D. and Van Gelder, A., </author> <title> Parallel complexity of logical query programs, pp. </title> <booktitle> 438-454 in Proc. of the Twenty-Seventh IEEE Symp. on Found. </booktitle> <institution> of Comp. Sci., IEEE Comp. Soc., </institution> <address> Wash., DC (1986). </address>
Reference: 94. <author> Ullman, J.D., </author> <title> Principles of Database and Knowledge-Base Systems, Vol. II: The New Technologies, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD (1989). </address>
Reference-contexts: There has been some previous work in which intraprocedural dataflow-analysis problems have been expressed using Horn clauses. For instance, one of the examples in Ullman's book shows how a logic database can be used to solve the intraprocedural reaching-definitions problem <ref> [94, pp. 984-987] </ref>. Assmann has examined a variety of other intraprocedural program-analysis problems [10]. Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog. 7.3.
Reference: 95. <author> Valiant, L.G., </author> <title> General context-free recognition in less than cubic time, </title> <journal> J. Comp. Syst. Sci. </journal> <pages> 10(2) pp. </pages> <month> 308-315 (Apr. </month> <year> 1975). </year>
Reference-contexts: This is sometimes erroneously attributed to the need to perform transitive closure when a problem is solved. However, because transitive closure can be performed in sub-cubic time <ref> [95] </ref>, this is not the correct explanation. We have long believed that, in many cases, the real source of the O (n 3 ) bottleneck is that a CFL-reachability problem needs to be solved. The constructions given in [66,67] show that this is indeed the case for certain set-constraint problems. <p> the general case relates to the special cases of ordinary reachability and CFL-recognition: g A single-source ordinary reachability problem can be solved in time linear in the size of the graph (nodes plus edges) using depth-first search. g Valiant showed that CFL-recognition can be performed in less than cubic time <ref> [95] </ref>. The algorithm han dles CFL-reachability problems on trees and directed acyclic graphs, as well as on chain graphs. Unfor tunately, the algorithm does not seem to generalize to CFL-reachability problems on arbitrary graphs.
Reference: 96. <author> Warren, </author> <title> D.S., Memoing for logic programs, </title> <journal> Commun. ACM 35(3) pp. </journal> <month> 93-111 (Mar. </month> <year> 1992). </year>
Reference-contexts: A CFL-reachability problem can be solved using bottom-up semi-naive evaluation of the chain program [100]. This observation provides a way for program-analysis tools to take advantage of the methods developed in the logic-programming and deductive-database communities for the efficient evaluation of recursive queries in deductive databases, such as tabulation <ref> [96] </ref> and the Magic-sets transformation [86,13,17,94]. For instance, algorithms for demand versions of program-analysis problems can be obtained from their exhaustive counterparts essentially for free by specifying the problem with Horn clauses and then applying the Magic-sets transformation [79,78,80]. <p> The work by D.S. Warren and others concerning the use of tabulation techniques in top-down evaluation of logic programs <ref> [96] </ref> provides an alternative method for obtaining demand algorithms for such program-analysis problems. Rather than applying the magic-sets transformation to a Horn-clause encoding of the (exhaustive) dataflow-analysis algorithm and then using a bottom-up evaluator, the original (untransformed) Horn-clause encoding can simply be evaluated by an OLDT (top-down, tabulating) evaluator.
Reference: 97. <author> Warren, </author> <title> D.S., XSB Logic Programming System, Software system, </title> <institution> Comp. Sci. Dept., State Univ. of New York, Stony Brook, </institution> <address> NY (1993). </address> <note> (Available via ftp from sbcs.sunysb.edu.) </note>
Reference-contexts: Thus, another way to obtain implementations of demand algorithms for interprocedural dataflow analysis, interprocedural slicing, and other CFL-reachability problems is to make use of the SUNY-Stony Brook XSB system <ref> [97] </ref>. The algorithms described in [81] and [88] for the IFDS and IDE frameworks, respectively, have straightforward implementations as logic programs. Thus, demand algorithms for these frameworks can be obtained either by applying the magic-sets transformation or by using a tabulating top-down evaluator.
Reference: 98. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Trans. on Softw. Eng. SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: The issue of how to create appropriate PDGs/SDGs is mostly orthogonal to the issue of how to slice them. Once an SDG has been constructed, slicing can be formulated as a CFL-reachability problem. One algorithm for interprocedural slicing was presented in Weiser's original paper on slicing <ref> [98] </ref>. This algorithm is equivalent to solving an ordinary reachability problem on the SDG. However, Weiser's algorithm is imprecise in the sense that it may report effects that are transmitted through paths that have mismatched calls and returns (and hence do not represent feasible execution paths).
Reference: 99. <author> Wolfe, M.J., </author> <title> Optimizing supercompilers for supercomputers, </title> <type> Ph.D. </type> <institution> diss. and Tech. </institution> <type> Rep. </type> <institution> R-82-1105, Dept. of Comp. Sci., Univ. of Illinois, Urbana, </institution> <address> IL (Oct. </address> <year> 1982). </year> <note> 100. </note> <editor> Yannakakis, M., </editor> <booktitle> Graph-theoretic methods in database theory, </booktitle> <pages> pp. </pages> <booktitle> 230-242 in Proc. of the Ninth ACM Symp. on Princ. of Database Syst., </booktitle> <year> (1990). </year> <title> 101. Younger, D.H., Recognition and parsing of context-free languages in time n**3, </title> <journal> Inf. and Cont. </journal> <pages> 10 pp. </pages> <month> 189-208 </month> <year> (1967). </year> <title> 102. Zadeck, F.K., Incremental data flow analysis in a structured program editor, </title> <booktitle> Proc. of the SIGPLAN 84 Symp. on Comp. Construct., </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> SIGPLAN Not. </journal> <pages> 19(6) pp. </pages> <month> 132-143 (June </month> <year> 1984). </year>
References-found: 99

