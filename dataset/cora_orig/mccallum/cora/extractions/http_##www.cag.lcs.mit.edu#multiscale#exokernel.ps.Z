URL: http://www.cag.lcs.mit.edu/multiscale/exokernel.ps.Z
Refering-URL: http://www.cag.lcs.mit.edu/multiscale/
Root-URL: 
Email: fengler,kaashoek,jamesg@lcs.mit.edu  
Title: Exokernel: an operating system architecture for application-level resource management  
Author: Dawson R. Engler, M. Frans Kaashoek and James O'Toole Jr. 
Date: March 24, 1995  
Address: Cambridge, MA 02139  
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: We describe an operating system architecture that securely multiplexes machine resources while permitting an unprecedented degree of application-specific customization of traditional operating system abstractions. By abstracting physical hardware resources, traditional operating systems have significantly limited the performance, flexibility, and functionality of applications. The exokernel architecture removes these limitations by allowing untrusted software to implement traditional operating system abstractions entirely at application-level. We have implemented a prototype exokernel-based system that includes Aegis, an exokernel, and ExOS, an untrusted application-level operating system. Aegis defines the low-level interface to machine resources. Applications can allocate and use machine resources, efficiently handle events, and participate in resource revocation. Measurements show that most primitive Aegis operations are 10-100 times faster than Ultrix, a mature monolithic UNIX operating system. ExOS implements processes, virtual memory, and inter-process communication abstractions entirely within a library. Measurements show that ExOS's application-level virtual memory and IPC primitives are 5-50 times faster than Ultrix's primitives. These results demonstrate that the exokernel operating system design is practical and offers an excellent combination of performance and flexibility. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: a new kernel foundation for UNIX development. </title> <booktitle> Proc. Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to trade between a wide array of IPC semantics that differ in performance by a factor of 10. In contrast, microkernel systems such as Amoeba [44], Chorus [39], Mach <ref> [1] </ref>, and V [13], do not allow untrusted application software to define specialized IPC primitive because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other microkernel abstractions, such as page-table structures and process abstractions, are fixed. <p> Once resources have been allocated to applications there must be a way to reclaim them. Revocation can either be invisible or visible to applications. Traditionally, operating systems have performed revocation invisibly, deallocating resources without application involvement. For example, with the exception of some external pagers <ref> [1, 39] </ref>, most operating systems deallocate (and allocate) physical memory without informing applications. This form of revocation has lower latency than visible revocation since it requires no application involvement. Its disadvantage is that applications have no control over deallocation and no knowledge of whether resources are scarce. <p> Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility <ref> [1, 15, 36, 39, 44] </ref>. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel).
Reference: [2] <author> T.E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 92-94, </pages> <year> 1992. </year>
Reference-contexts: The four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel [35], the open operating system [28], Anderson's argument for application-specific operating systems <ref> [2] </ref> and the Cache Kernel [11]. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [35]. <p> Therefore, protection is not an issue in the open operating system, whereas secure multiplexing is the main task of an exoker-nel. In addition, the exokernel attempts to define no core abstractions, while in the open operating systems the file system and communications are standardized. Anderson <ref> [2] </ref> made a clear argument for application-specific library operating systems and proposed that the kernel concentrate solely on the adjudication of hardware resources. The exokernel design addresses how to provide secure multiplexing of physical resources in such a system, and moves the kernel interface to a lower level of abstraction.
Reference: [3] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proc. Thirteenth Symposium on Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: For example, database implementations must struggle to emulate random-access record storage on top of file systems [43]. Implementing light-weight threads on top of heavy-weight processes usually requires compromises in correctness and performance because the operating system hides page faults and timer interrupts <ref> [3] </ref>. In both of these cases, the complexity of applications increases because of the difficulty of getting good performance from high-level core abstractions. <p> Because all applications must share the core abstractions, changes to core abstractions occur rarely, if ever. This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations <ref> [3] </ref>, multiple protection domains within a single address space [10], efficient IPC [29], or efficient and flexible virtual memory primitives [4, 21, 25]? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. <p> Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson et al. [28], Anderson et al. <ref> [3] </ref> and Massalin [31], general-purpose implementations of core abstractions force applications that do not need a given feature to pay substantial overhead costs. This longstanding problem has become more important with explosive improvements in raw hardware performance and enormous growth in diversity of the application software base.
Reference: [4] <author> A.W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on ASPLOS, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Substantial evidence exists that applications can benefit greatly from having more control over how machine resources are used to implement higher-level abstractions. Ap-pel et al. <ref> [4] </ref> reported that the high cost of general-purpose virtual memory primitives reduces the performance of persistent stores, garbage collectors, and distributed shared memory systems. Cao et al. demonstrated that application-level control over file caching can reduce the number of I/O operations by up to 80% [9]. <p> This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations [3], multiple protection domains within a single address space [10], efficient IPC [29], or efficient and flexible virtual memory primitives <ref> [4, 21, 25] </ref>? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. Traditional operating systems attempt to provide all the features needed by all applications. <p> For example, it performs two to three times better than Mach 3.0 in a set of I/O benchmarks [33]. Also, its virtual memory performance is approximately twice that of Mach 2.5 and three times that of Mach 3.0 <ref> [4] </ref>. A few of our benchmarks were extremely sensitive to instruction cache conflicts. In some cases the effects amounted to a factor of three performance penalty. Changing the order in which ExOS's object files were linked was sufficient to remove most conflicts. <p> Ensuring that applications can return from their own exceptions (without kernel intervention) requires that all exception state be available for user reconstruction. The means that all registers that are saved must be in user-accessible memory locations, etc. Fast exceptions enable a number of intriguing applications <ref> [4, 45] </ref>. For example, efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores and garbage collectors [4, 45]. <p> The means that all registers that are saved must be in user-accessible memory locations, etc. Fast exceptions enable a number of intriguing applications <ref> [4, 45] </ref>. For example, efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores and garbage collectors [4, 45]. In general, most of these operations could be done by inserting explicit checks in code (e.g., hardware page-protection can be emulated by checking every load and store). The obvious advantage to using exceptions instead of explicit checks is efficiency. <p> We compare Aegis and ExOS to Ultrix on seven virtual memory experiments, based on those used by Appel and Li <ref> [4] </ref>: dirty: Measures the time to query whether a page is dirty or not. Since it does not require examination of the TLB, this measurement is used to test the base cost of looking up a virtual address in ExOS's page-table structure. <p> 100 pages. unprot100: Measures the time required to remove read protections on 100 pages. trap: Time to take a page-protection trap. appel1: Time to access a random protected page and, in the fault-handler, protect some other page and unprotect the faulting page (this benchmark is prot1+trap+unprot in Appel et al. <ref> [4] </ref>). appel2: Time to protect 100 pages, then access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is protN+trap+unprot in Appel et al. [4]). <p> the fault-handler, protect some other page and unprotect the faulting page (this benchmark is prot1+trap+unprot in Appel et al. <ref> [4] </ref>). appel2: Time to protect 100 pages, then access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is protN+trap+unprot in Appel et al. [4]). Note that appel2 requires less time than appel1 since appel1 must both unprotect and protect different pages in the fault handler. dirty measures the average time to parse the page-table for a random entry.
Reference: [5] <author> K. Bala, M.F. Kaashoek, and W.E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 243-253, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The application performs cleanup and resumes execu tion. The obvious challenge in supporting AVM is making it fast. The primary bottleneck that must be overcome is the cost of TLB refills. We do this by overlaying the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [5, 23] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB; if so, Aegis installs it and resumes execution. Otherwise, the miss is forwarded to the application. Aegis currently uses a unified STLB.
Reference: [6] <author> B. N. Bershad. </author> <title> High performance cross-address space communication. </title> <type> Technical Report 90-06-02 (PhD Thesis), </type> <institution> University of Washington, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Of course, this is hardly a conclusive proof; see Section 5.2 for a discussion of the ExOS virtual memory system. 4.6 Protected Control Transfers Aegis provides a protected control transfer mechanism as a substrate for implementing efficient IPC mechanisms <ref> [6, 22, 29] </ref>. Operationally, a protected control transfer changes the program counter to an agreed-upon value in the callee, donates the current time-slice to the callee's processor environment, and installs required elements of the callee's processor context (addressing-context identifier, address space tag, and processor status word). <p> Due to space constraints we focus on IPC and virtual memory. 5.1 Fast IPC Abstractions Fast inter-process communication is crucial for building efficient and decoupled systems <ref> [6, 22, 29] </ref>. As described in Section 4, the Aegis protected control transfer mechanism is an efficient substrate for implementing fast IPC mechanisms.
Reference: [7] <author> B.N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. Sirer. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> TR 94-03-03, </type> <institution> Univ. of Wash-ington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages <ref> [7, 32, 37] </ref> and software fault-isolation [16, 46], are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. <p> These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. Another current extensible OS project, the SPIN project, investigates adaptable kernels that allow applications to make policy decisions <ref> [7] </ref>. The SPIN system encapsulates policies in spindles that can be dynamically loaded into the kernel. To ensure safety, spindles will be written in a pointer-safe language and will be translated by a trusted compiler.
Reference: [8] <author> B.N. Bershad, D.D. Redell, and J.R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Proc. of the Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-237, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The application's handlers are responsible for general-purpose context-switching: saving and restoring live registers, releasing locks, etc. The flexibility this framework provides allows a number of optimizations. For example, context-switching code can implement efficient uni-processor synchronization by moving (pc-lusering) the program counter out of critical sections at context-switching time <ref> [8] </ref>.
Reference: [9] <author> Pei Cao, Edward W. Felten, and Kai Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 165-178, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Ap-pel et al. [4] reported that the high cost of general-purpose virtual memory primitives reduces the performance of persistent stores, garbage collectors, and distributed shared memory systems. Cao et al. demonstrated that application-level control over file caching can reduce the number of I/O operations by up to 80% <ref> [9] </ref>. Cheriton et al. [21] and Krueger et al. [25] showed how application-specific virtual memory policies can increase application performance. Stone-braker [43] demonstrated that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. <p> The difference in file-caching under an exokernel system is that the applications manage these caches: whether this is done through proxy servers or directly is of little concern. Application-controlled file caching, as explored by Cao et al. <ref> [9] </ref>, can be directly used in an exokernel architecture.
Reference: [10] <author> Jeffrey S. Chase, Henry M. Levy, Michel Baker-Harvey, and Edward D. Lazowska. </author> <title> How to use a 64-bit virtual address space. </title> <type> Technical Report TR 92-03-02, </type> <institution> University of Washington, </institution> <year> 1992. </year>
Reference-contexts: This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations [3], multiple protection domains within a single address space <ref> [10] </ref>, efficient IPC [29], or efficient and flexible virtual memory primitives [4, 21, 25]? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. Traditional operating systems attempt to provide all the features needed by all applications.
Reference: [11] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: To the best of our knowledge ExOS and the Cache Kernel <ref> [11] </ref> are the first general-purpose library operating systems implemented in a multiprogramming environment. The Cache Kernel, however, supports library operating systems primarily for kernel simplification instead of for performance and extensibility. <p> The four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel [35], the open operating system [28], Anderson's argument for application-specific operating systems [2] and the Cache Kernel <ref> [11] </ref>. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [35]. <p> In addition, Aegis and ExOS demonstrate that low-level secure multiplexing and library operating systems can offer excellent performance. Like Aegis, the Cache Kernel <ref> [11] </ref> provides a low-level kernel that can support multiple application-level operating systems. The difference between the Cache Kernel and Aegis is mainly one of high-level philosophy: the Cache Kernel focuses primarily on reliability, rather than securely exporting hardware resources to applications.
Reference: [12] <author> D. R. Cheriton. </author> <title> An experiment using registers for fast message-based interprocess communication. </title> <journal> Operating Systems Review, </journal> <volume> 18 </volume> <pages> 12-20, </pages> <month> [10] </month> <year> 1984. </year>
Reference-contexts: 9.1 Aegis DEC3100/ 16.67MHz L3 486/50MHz (normalized) 6.67 micro-seconds of control transfer guarantee two important properties: (1) to applications, a protected control transfer is atomic, and (2) Aegis will not overwrite any application-visible register, allowing the large register set of modern processors to be used as a temporary message buffer <ref> [12] </ref>. Currently, our synchronous protected control transfer operation costs 30 instructions. Roughly ten of these instructions are required in order to distinguish the system call exception from other hardware exceptions on the MIPS architecture. The remaining twenty instructions could benefit from additional optimizations.
Reference: [13] <author> D. R. Cheriton. </author> <title> The v kernel: A software base for distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to trade between a wide array of IPC semantics that differ in performance by a factor of 10. In contrast, microkernel systems such as Amoeba [44], Chorus [39], Mach [1], and V <ref> [13] </ref>, do not allow untrusted application software to define specialized IPC primitive because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other microkernel abstractions, such as page-table structures and process abstractions, are fixed.
Reference: [14] <author> R. J. Creasy. </author> <title> The origin of the VM/370 time-sharing system. </title> <journal> IBM J. Research and Development, </journal> <volume> 25(5) </volume> <pages> 483-490, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: To ensure safety, spindles will be written in a pointer-safe language and will be translated by a trusted compiler. We view the SPIN project as complementary to the exokernel design and hope to use their results to optimize application-level library operating systems. The interface provided by the VM/370 OS <ref> [14] </ref> is very similar to what would be provided by our ideal OS: namely, the raw hardware. However, the important difference is that VM/370 provides this interface by virtualizing the entire base-machine.
Reference: [15] <author> H. Custer. </author> <title> Inside Windows/NT. </title> <publisher> Microsoft Press, </publisher> <address> Red-mond, WA, </address> <year> 1993. </year>
Reference-contexts: Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility <ref> [1, 15, 36, 39, 44] </ref>. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel).
Reference: [16] <author> P. Deutsch and C.A. Grant. </author> <title> A flexible measurement tool for software systems. </title> <booktitle> Information Processing 71, </booktitle> <year> 1971. </year>
Reference-contexts: In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages [7, 32, 37] and software fault-isolation <ref> [16, 46] </ref>, are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. Another current extensible OS project, the SPIN project, investigates adaptable kernels that allow applications to make policy decisions [7].
Reference: [17] <author> Richard Draves. </author> <title> Private Communication, </title> <month> December </month> <year> 1994. </year>
Reference-contexts: To avoid the worst-case behavior of a direct mapped STLB, we will likely move to a two-way set-associative structure as the implementation matures (as is used in the Rialto <ref> [17] </ref> and PA-RISC operating systems [23]). As dictated by the exokernel principle of exposing kernel book-keeping structures, the STLB is mapped using a well-known capability, allowing applications to efficiently probe for entries, etc. The overhead of application-level memory is measured by performing a 150 by 150 matrix multiplication.
Reference: [18] <author> Peter Druschel, Larry L. Peterson, and Bruce S. Davie. </author> <title> Experiences with a high-speed network adaptor: A software perspective. </title> <booktitle> In SIGCOMM`94, </booktitle> <pages> pages 2-13, </pages> <year> 1994. </year>
Reference-contexts: Sharing the network interface for outgoing messages is relatively much easier. Transmission buffers can be allocated, shared, and protected by the exokernel just as easily as physical memory pages. Applications could map these message transmission buffers into their address space as suggested by Druschel et al. <ref> [18] </ref> DRAFT COPY Do not distribute or cite. 6 3.3 Revocation An exokernel pushes as much resource management as it can to application level. Once resources have been allocated to applications there must be a way to reclaim them. Revocation can either be invisible or visible to applications.
Reference: [19] <author> Per Brinch Hansen. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-241, </pages> <month> April </month> <year> 1970. </year> <title> DRAFT COPY Do not distribute or cite. </title> <type> 16 </type>
Reference-contexts: Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper <ref> [19] </ref> are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility [1, 15, 36, 39, 44].
Reference: [20] <author> J.H. Hartman, A.B. Montz, David Mosberger, S.W. O'Malley, L.L. Peterson, and T.A. Proebsting. </author> <title> Scout: A communication-oriented operating system. </title> <type> Technical Report TR 94-20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout <ref> [20] </ref>, Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages [7, 32, 37] and software fault-isolation [16, 46], are also applicable to exok-ernels.
Reference: [21] <author> K. Harty and D.R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the Fifth International Conference on ASPLOS, </booktitle> <pages> pages 187-199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Cao et al. demonstrated that application-level control over file caching can reduce the number of I/O operations by up to 80% [9]. Cheriton et al. <ref> [21] </ref> and Krueger et al. [25] showed how application-specific virtual memory policies can increase application performance. Stone-braker [43] demonstrated that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. <p> This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations [3], multiple protection domains within a single address space [10], efficient IPC [29], or efficient and flexible virtual memory primitives <ref> [4, 21, 25] </ref>? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. Traditional operating systems attempt to provide all the features needed by all applications.
Reference: [22] <author> W.C. Hsieh, M.F. Kaashoek, and W.E. Weihl. </author> <title> The persistent relevance of IPC performance: New techniques for reducing the IPC penalty. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 186-190, </pages> <month> Octo-ber </month> <year> 1993. </year>
Reference-contexts: Of course, this is hardly a conclusive proof; see Section 5.2 for a discussion of the ExOS virtual memory system. 4.6 Protected Control Transfers Aegis provides a protected control transfer mechanism as a substrate for implementing efficient IPC mechanisms <ref> [6, 22, 29] </ref>. Operationally, a protected control transfer changes the program counter to an agreed-upon value in the callee, donates the current time-slice to the callee's processor environment, and installs required elements of the callee's processor context (addressing-context identifier, address space tag, and processor status word). <p> Due to space constraints we focus on IPC and virtual memory. 5.1 Fast IPC Abstractions Fast inter-process communication is crucial for building efficient and decoupled systems <ref> [6, 22, 29] </ref>. As described in Section 4, the Aegis protected control transfer mechanism is an efficient substrate for implementing fast IPC mechanisms.
Reference: [23] <author> J. Huck and J. Hays. </author> <title> Architectural support for translation table management in large address space machines. </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <year> 1992. </year>
Reference-contexts: The application performs cleanup and resumes execu tion. The obvious challenge in supporting AVM is making it fast. The primary bottleneck that must be overcome is the cost of TLB refills. We do this by overlaying the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [5, 23] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB; if so, Aegis installs it and resumes execution. Otherwise, the miss is forwarded to the application. Aegis currently uses a unified STLB. <p> To avoid the worst-case behavior of a direct mapped STLB, we will likely move to a two-way set-associative structure as the implementation matures (as is used in the Rialto [17] and PA-RISC operating systems <ref> [23] </ref>). As dictated by the exokernel principle of exposing kernel book-keeping structures, the STLB is mapped using a well-known capability, allowing applications to efficiently probe for entries, etc. The overhead of application-level memory is measured by performing a 150 by 150 matrix multiplication.
Reference: [24] <author> SPARC International. </author> <title> The SPARC Architecture Manual Verson 8. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1992. </year>
Reference-contexts: For example, on a MIPS processor, the general-purpose registers are best allocated entirely to a single application at a time, because subdividing the registers seems inconvenient. However, on a SPARC processor <ref> [24] </ref> it could be useful to allocate register windows individually. The number, format, and current set of TLB mappings should be visible to and replaceable by applications, as should other privileged co-processor state.
Reference: [25] <author> Keith Krueger, David Loftesness, Amin Vahdat, and Thomas Anderson. </author> <title> Tools for development of application-specific virtual memory management. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <pages> pages 48-64, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Cao et al. demonstrated that application-level control over file caching can reduce the number of I/O operations by up to 80% [9]. Cheriton et al. [21] and Krueger et al. <ref> [25] </ref> showed how application-specific virtual memory policies can increase application performance. Stone-braker [43] demonstrated that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. <p> This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations [3], multiple protection domains within a single address space [10], efficient IPC [29], or efficient and flexible virtual memory primitives <ref> [4, 21, 25] </ref>? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. Traditional operating systems attempt to provide all the features needed by all applications. <p> It is possible that object-oriented programming methods, overloading, and inheritance can provide useful operating system service imple DRAFT COPY Do not distribute or cite. 4 mentations that can be easily specialized and extended, as in Anderson's VM++ library <ref> [25] </ref>. To control the space used by these libraries, good support for shared libraries and dynamic linking will be an essential part of a complete exokernel-based system. Backward compatibility can be provided as in microkernel-based systems.
Reference: [26] <author> B. W. Lampson. </author> <title> Hints for computer system design. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 33-48, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Supporting this illusion precludes application resources management: Because the application is not supposed to see VM/370 it is unable to communicate with it about issues such as explicit allocation, revocation, naming and sharing (sharing is particularly difficult across virtual machines <ref> [26] </ref>). The four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel [35], the open operating system [28], Anderson's argument for application-specific operating systems [2] and the Cache Kernel [11].
Reference: [27] <author> B.W. Lampson. </author> <title> On reliable and extendable operating systems. State of the Art Report, </title> <journal> Infotech, </journal> <volume> 1, </volume> <year> 1971. </year>
Reference-contexts: An interesting research question is whether distributed control can be extended to an environment with malicious applications; we plan to investigate this question in future research. 7 Related work Many early OS papers discussed the need for extendible, flexible kernels <ref> [27, 37, 48] </ref>. Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. <p> An interesting research question is whether distributed control can be extended to an environment with malicious applications; we plan to investigate this question in future research. 7 Related work Many early OS papers discussed the need for extendible, flexible kernels [27, 37, 48]. Lampson's description of CAL-TSS <ref> [27] </ref> and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility [1, 15, 36, 39, 44].
Reference: [28] <author> B.W. Lampson and R.F. Sproull. </author> <title> An open operating system for a single-user machine. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 98-105, </pages> <year> 1979. </year>
Reference-contexts: Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson et al. <ref> [28] </ref>, Anderson et al. [3] and Massalin [31], general-purpose implementations of core abstractions force applications that do not need a given feature to pay substantial overhead costs. <p> The application can access the frame buffer hardware directly because the hardware checks the ownership tag when I/O takes place. Similarly, the label feature of the Xerox Alto disk device <ref> [28] </ref> could be used by an exoker-nel to cheaply implement secure bindings for individual disk blocks. Multiplexing the Network If there is no hardware capability support that can be used to efficiently multiplex a device, secure bindings can be implemented by the exokernel. <p> The four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel [35], the open operating system <ref> [28] </ref>, Anderson's argument for application-specific operating systems [2] and the Cache Kernel [11]. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [35]. <p> Its close coupling to the architecture makes it similar in many ways to an exokernel, but we have not been able to make detailed comparisons because its design methodology and performance are not yet published. The open operating system for a single-user machine <ref> [28] </ref> is motived by a rationale similar to that of the exokernel. However, the approach taken to extensibility is very different because it is designed for a single-user machine. Therefore, protection is not an issue in the open operating system, whereas secure multiplexing is the main task of an exoker-nel.
Reference: [29] <author> Jochen Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 175-188, </pages> <year> 1993. </year>
Reference-contexts: In practice, our implementation provides applications with greater flexibility and better performance than in a monolithic system. Aegis's low-level interface allows application-level software, such as ExOS, to manipulate resources very efficiently. Aegis's protected control transfer is three times faster than the best reported implementation <ref> [29] </ref>. Aegis's exception forwarding and control transfers are close to 100 times faster than in Ultrix 4.2, a mature monolithic system using identical hardware. Because of this efficiency, ExOS is able to implement virtual memory entirely at application level. <p> This is perhaps why few good ideas from the last decade of operating systems research have been adopted into widespread use. What operating systems support scheduler activations [3], multiple protection domains within a single address space [10], efficient IPC <ref> [29] </ref>, or efficient and flexible virtual memory primitives [4, 21, 25]? 2.2 Exokernels: An End-to-End Argument The essential observation about core abstractions in traditional operating systems is that they are overly general. Traditional operating systems attempt to provide all the features needed by all applications. <p> Of course, this is hardly a conclusive proof; see Section 5.2 for a discussion of the ExOS virtual memory system. 4.6 Protected Control Transfers Aegis provides a protected control transfer mechanism as a substrate for implementing efficient IPC mechanisms <ref> [6, 22, 29] </ref>. Operationally, a protected control transfer changes the program counter to an agreed-upon value in the callee, donates the current time-slice to the callee's processor environment, and installs required elements of the callee's processor context (addressing-context identifier, address space tag, and processor status word). <p> For example, control transfers between clients and trusted servers can be optimized by allowing the server to save and restore only the registers it uses, rather than requiring that the client save and restore the entire register state on every call. L3 appears to provide similar IPC semantics <ref> [29] </ref>. We measure the bare-bones overhead of our protected control transfer mechanism in Figure 9. Times are given in micro-seconds, and were derived by dividing the time to perform a call and reply by 2 (i.e., we measure the time to perform a uni-directional control transfer). <p> We attempt a crude comparison of our protected control transfer operation to the L3 RPC mechanism. The L3 implementation is the fastest published result <ref> [29] </ref>, but it runs on an Intel 486. For Figure 9, we scaled the published L3 results based on the MIPS rating of our DECstation. Aegis's trusted control transfer mechanism performs 3 times faster than L3's trusted RPC mechanism. <p> Due to space constraints we focus on IPC and virtual memory. 5.1 Fast IPC Abstractions Fast inter-process communication is crucial for building efficient and decoupled systems <ref> [6, 22, 29] </ref>. As described in Section 4, the Aegis protected control transfer mechanism is an efficient substrate for implementing fast IPC mechanisms.
Reference: [30] <author> Steven Lucco. </author> <title> High-performance microkernel systems (abstract). </title> <booktitle> In Proc. of the first Symp. on OSDI, </booktitle> <month> Novem-ber </month> <year> 1994. </year>
Reference-contexts: The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge <ref> [30] </ref>, and Vino [41]. Some of the techniques used in these systems, such as type-safe languages [7, 32, 37] and software fault-isolation [16, 46], are also applicable to exok-ernels.
Reference: [31] <author> H. Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson et al. [28], Anderson et al. [3] and Massalin <ref> [31] </ref>, general-purpose implementations of core abstractions force applications that do not need a given feature to pay substantial overhead costs. This longstanding problem has become more important with explosive improvements in raw hardware performance and enormous growth in diversity of the application software base.
Reference: [32] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of 11th SOSP, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: For example, ATM cells contain a virtual circuit identifier that might uniquely identify the application that should receive the data. However, in general, protocol-specific knowledge must be used to interpret the contents of incoming messages and identify the intended recipient. Packet filters <ref> [32] </ref> can be used, with simple security precautions, to distribute incoming messages among applications without incorporating protocol-specific knowledge into the exokernel. Sharing the network interface for outgoing messages is relatively much easier. Transmission buffers can be allocated, shared, and protected by the exokernel just as easily as physical memory pages. <p> In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages <ref> [7, 32, 37] </ref> and software fault-isolation [16, 46], are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular.
Reference: [33] <author> David Nagle, Richard Uhlig, Tim Stanley, Stuart Sechrest, Trevor Mudge, and Richard Brown. </author> <title> Design tradeoffs for software-managed TLBs. </title> <booktitle> 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 27-38, </pages> <year> 1993. </year>
Reference-contexts: It is a mature monolithic system that performs quite well in comparison to other research operating systems. For example, it performs two to three times better than Mach 3.0 in a set of I/O benchmarks <ref> [33] </ref>. Also, its virtual memory performance is approximately twice that of Mach 2.5 and three times that of Mach 3.0 [4]. A few of our benchmarks were extremely sensitive to instruction cache conflicts. In some cases the effects amounted to a factor of three performance penalty.
Reference: [34] <author> G.J. Popek et al. </author> <title> UCLA data secure UNIX. </title> <booktitle> In Proc. of the 1979 National Computer Conference, </booktitle> <pages> pages 355-364, </pages> <year> 1979. </year>
Reference-contexts: The difference between the Cache Kernel and Aegis is mainly one of high-level philosophy: the Cache Kernel focuses primarily on reliability, rather than securely exporting hardware resources to applications. For example, the Cache Kernel attempts to eliminate all dynamic memory allocation (similar to Popek and Klines' Data Secure Unix <ref> [34] </ref>). Unsurprisingly, this single constraint lowers the kernel interface as compared to traditional operating systems. However, the deemphasis on application flexibility and extensibility is telling; the Cache Kernel is biased towards a server-based system structure (for example, it supports only 16 application-level kernels concurrently).
Reference: [35] <author> D. Probert, J.L. Bruno, and M. Karzaorman. </author> <title> SPACE: A new approach to operating system abstraction. </title> <booktitle> In IWOOS, </booktitle> <year> 1991. </year>
Reference-contexts: The four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel <ref> [35] </ref>, the open operating system [28], Anderson's argument for application-specific operating systems [2] and the Cache Kernel [11]. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [35]. <p> four approaches we view as most similar to the ex-okernel philosophy are the SPACE kernel <ref> [35] </ref>, the open operating system [28], Anderson's argument for application-specific operating systems [2] and the Cache Kernel [11]. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [35]. Its close coupling to the architecture makes it similar in many ways to an exokernel, but we have not been able to make detailed comparisons because its design methodology and performance are not yet published.
Reference: [36] <author> R.F. Rashid and G. Robertson. </author> <title> Accent: A communication oriented network operating system kernel. </title> <booktitle> Proceedings of the Eighth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 64-75, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility <ref> [1, 15, 36, 39, 44] </ref>. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel).
Reference: [37] <author> D.D. Redell, Y.K. Dalal, T.R. Horsley, H.C. Lauer, W.C. Lynch, P.R. McJones, H.G. Murray, </author> <title> and S.C. Purcell. Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: An interesting research question is whether distributed control can be extended to an environment with malicious applications; we plan to investigate this question in future research. 7 Related work Many early OS papers discussed the need for extendible, flexible kernels <ref> [27, 37, 48] </ref>. Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. <p> In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages <ref> [7, 32, 37] </ref> and software fault-isolation [16, 46], are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular.
Reference: [38] <author> Theodore H. Romer, Dennis Lee, Brian N. Bershad, and J. Bradley Chen. </author> <title> Dynamic page mapping policies for cache conflict resolution on standard hardware. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 255-266, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: For instance, in a system with direct-mapped caches, the name of the physical page (i.e., the page number) determines which pages it conflicts with. If applications can request specific physical pages they can reduce cache conflicts among the pages in their working set <ref> [38] </ref>. The hardware namespaces should be enumerable by applications so that applications can tailor their requests to the available resources. Resource revocation should be visible to applications to support lightweight application-level resource management.
Reference: [39] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <year> 1988. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to trade between a wide array of IPC semantics that differ in performance by a factor of 10. In contrast, microkernel systems such as Amoeba [44], Chorus <ref> [39] </ref>, Mach [1], and V [13], do not allow untrusted application software to define specialized IPC primitive because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other microkernel abstractions, such as page-table structures and process abstractions, are fixed. <p> Once resources have been allocated to applications there must be a way to reclaim them. Revocation can either be invisible or visible to applications. Traditionally, operating systems have performed revocation invisibly, deallocating resources without application involvement. For example, with the exception of some external pagers <ref> [1, 39] </ref>, most operating systems deallocate (and allocate) physical memory without informing applications. This form of revocation has lower latency than visible revocation since it requires no application involvement. Its disadvantage is that applications have no control over deallocation and no knowledge of whether resources are scarce. <p> Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility <ref> [1, 15, 36, 39, 44] </ref>. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel).
Reference: [40] <author> J.H. Saltzer, D.P. Reed, and D.D. Clark. </author> <title> End-to-end arguments in system design. </title> <journal> Trans. on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: This longstanding problem has become more important with explosive improvements in raw hardware performance and enormous growth in diversity of the application software base. The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communications protocols <ref> [40] </ref>. Applications know better than operating systems what the goal of their resource management decisions should be, and should therefore be given as much control as possible over those decisions. Our proposed solution is a new operating system architecture in which traditional abstractions are implemented entirely at application level.
Reference: [41] <editor> Margo Seltzer et al. </editor> <title> An introduction to the architecture of the VINO kernel, </title> <month> November </month> <year> 1994. </year>
Reference-contexts: In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino <ref> [41] </ref>. Some of the techniques used in these systems, such as type-safe languages [7, 32, 37] and software fault-isolation [16, 46], are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular.
Reference: [42] <author> R.L. </author> <title> Sites. Alpha axp architecture. </title> <journal> Comm. of the ACM, </journal> <volume> 36(2), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: System call Description Yield Yield processor Scall Synchronous protected control transfer Acall Asynchronous protected control transfer Alloc Allocation of resources (e.g., page) Dealloc Deallocation of resources DMA Two DMA calls (not discussed in this paper) Clock Two calls related to the clock instructions (similar to the Alpha's use of PALcode <ref> [42] </ref>). In this subsection we examine how Aegis protects time-slices and environments; other resources are protected as described in the previous section. 4.2.1 Processor Time Slices The CPU representation is unique and deserves a brief discussion.
Reference: [43] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> CACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Cao et al. demonstrated that application-level control over file caching can reduce the number of I/O operations by up to 80% [9]. Cheriton et al. [21] and Krueger et al. [25] showed how application-specific virtual memory policies can increase application performance. Stone-braker <ref> [43] </ref> demonstrated that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. Thekkath et al. [45] showed that by deferring signal handling to applications the cost of exceptions can be reduced by an order of magnitude. <p> Unfortunately, hiding this information makes it difficult or impossible for applications to implement their own resource management abstractions. For example, database implementations must struggle to emulate random-access record storage on top of file systems <ref> [43] </ref>. Implementing light-weight threads on top of heavy-weight processes usually requires compromises in correctness and performance because the operating system hides page faults and timer interrupts [3]. In both of these cases, the complexity of applications increases because of the difficulty of getting good performance from high-level core abstractions.
Reference: [44] <author> A.S. Tanenbaum, R. van Renesse, H. van Staveren, G. Sharp, S.J. Mullender, A. Jansen, and G. van Rossum. </author> <title> Experiences with the Amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Aegis also permits ExOS (or other application-level software) flexibility that is not available in microkernel-based systems. Aegis's efficient protected control transfer allows applications to trade between a wide array of IPC semantics that differ in performance by a factor of 10. In contrast, microkernel systems such as Amoeba <ref> [44] </ref>, Chorus [39], Mach [1], and V [13], do not allow untrusted application software to define specialized IPC primitive because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other microkernel abstractions, such as page-table structures and process abstractions, are fixed. <p> Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. Modern revisita-tions of microkernels have also argued for kernel extensibility <ref> [1, 15, 36, 39, 44] </ref>. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions. In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel).
Reference: [45] <author> C. A. Thekkath and Henry M. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <year> 1994. </year> <title> DRAFT COPY Do not distribute or cite. </title> <type> 17 </type>
Reference-contexts: Cheriton et al. [21] and Krueger et al. [25] showed how application-specific virtual memory policies can increase application performance. Stone-braker [43] demonstrated that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. Thekkath et al. <ref> [45] </ref> showed that by deferring signal handling to applications the cost of exceptions can be reduced by an order of magnitude. <p> this will be the common case with all exokernels, since they should be quite small and therefore not require paging of kernel text and code. 4.4 Exceptions Aegis forwards to applications all hardware exceptions save for system calls and interrupts, using techniques similar to those described in Thekkath et al. <ref> [45] </ref>. To forward an exception, Aegis performs the following actions: 1. It saves three scratch registers into an agreed-upon save area. (To avoid TLB exceptions, Aegis does this op eration using physical addresses.) 2. <p> Ensuring that applications can return from their own exceptions (without kernel intervention) requires that all exception state be available for user reconstruction. The means that all registers that are saved must be in user-accessible memory locations, etc. Fast exceptions enable a number of intriguing applications <ref> [4, 45] </ref>. For example, efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores and garbage collectors [4, 45]. <p> The means that all registers that are saved must be in user-accessible memory locations, etc. Fast exceptions enable a number of intriguing applications <ref> [4, 45] </ref>. For example, efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores and garbage collectors [4, 45]. In general, most of these operations could be done by inserting explicit checks in code (e.g., hardware page-protection can be emulated by checking every load and store). The obvious advantage to using exceptions instead of explicit checks is efficiency. <p> Currently, Aegis dispatches exceptions in 18 instructions. The low-level nature of Aegis allows an extremely efficient implementation: exception forwarding requires almost four times fewer instructions than the most highly-tuned implementation in the literature <ref> [45] </ref>. Part of the reason for this improvement is that Aegis does not used mapped data structures, and so does not have to carefully separate out kernel TLB misses from the more general class of exceptions in its exception demultiplexing routine.
Reference: [46] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <year> 1993. </year>
Reference-contexts: In other systems, the effective operating system interface is much higher-level (e.g., page-tables are implemented by the kernel). Current extensible OS projects include Scout [20], Bridge [30], and Vino [41]. Some of the techniques used in these systems, such as type-safe languages [7, 32, 37] and software fault-isolation <ref> [16, 46] </ref>, are also applicable to exok-ernels. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. Another current extensible OS project, the SPIN project, investigates adaptable kernels that allow applications to make policy decisions [7].
Reference: [47] <author> Carl A. Waldspurger and William E. Weihl. </author> <title> Lottery scheduling: Flexible proportional-share resource management. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 1-11, </pages> <year> 1994. </year>
Reference-contexts: This simple scheduler can support a wide range of higher-level scheduling policies. For example, a server could enforce proportional sharing (perhaps through lottery scheduling <ref> [47] </ref>) on a collection of sub-processes by allocating a number of time-slices; as each time-slice is initiated the server first determines which of its sub-process should run and then enables it by performing a yield system call to the chosen process.
Reference: [48] <author> W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, and F. Pollack. HYDRA: </author> <title> The kernel of a multiprocessing operating system. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: An interesting research question is whether distributed control can be extended to an environment with malicious applications; we plan to investigate this question in future research. 7 Related work Many early OS papers discussed the need for extendible, flexible kernels <ref> [27, 37, 48] </ref>. Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets [48]. <p> Lampson's description of CAL-TSS [27] and Brinch Hansen's microkernel paper [19] are two classic rationales. Hydra was the most ambitious system to have the separation of kernel policy and mechanism as one of its central tenets <ref> [48] </ref>. Modern revisita-tions of microkernels have also argued for kernel extensibility [1, 15, 36, 39, 44]. The most important difference between our work and previous approaches is the explicit view that the kernel should not provide high-level core abstractions.
References-found: 48

