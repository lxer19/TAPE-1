URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR98-06/TR.ps.gz
Refering-URL: http://www.cs.iastate.edu/~anandg/
Root-URL: http://www.cs.iastate.edu
Title: Preliminary Design of JML: A Behavioral Interface Specification Language for Java Keywords: Behavioral interface specification,
Author: Gary T. Leavens, Albert L. Baker and Clyde Ruby TR #-c Gary T. Leavens, Albert L. Baker and Clyde Ruby. 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1996 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  Copyright c 1998 by  
Date: June 1998, revised July, November 1998, January 1999  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: 1 Introduction JML stands for "Java Modeling Language." JML is a behavioral interface specification language (BISL) [42] designed to specify Java <ref> [1, 7] </ref> modules. Java modules are classes and interfaces. The main goal of the research presented in this paper is to better understand how to make BISLs (and BISL tools) that are practical and effective for production software environments.
Reference: [2] <author> Alex Borgida, John Mylopoulos, and Rayomnd Reiter. </author> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Following the initially clauses are the expected specifications of the pop, push, and top methods. The use of the modifiable clauses in the behavioral specifications of pop and push is interesting (and another difference from Eiffel). These give frame conditions <ref> [2] </ref>, which say that no objects, other than those mentioned (and those on which these objects depend, as explained below) may have their values changed. 2 When the modifiable clause is omitted, as it is in the specification of top, this means that no objects can have their state modified by
Reference: [3] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: =&gt; o instanceof NodeType && nodes.isIn (o)]; ensures result.equals (nodeSet.union ( new JMLValueSet - NodeType n | exists (ArcType a) [arcs.isIn (a) && ( nodeSet.isIn (a.from) && n.equals (a.to) || nodeSet.isIn (a.to) && n.equals (a.from) )]-)); - - // end of class Digraph 28 2.7 Subtyping Following Dhara and Leavens <ref> [3, 15] </ref>, a subtype inherits the specifications of its supertype's public and protected members (fields and methods), as well as invariants and history constraints.
Reference: [4] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <type> Technical Report 95-20c, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, December </month> <year> 1997. </year> <booktitle> Also in Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <year> 1996, </year> <pages> pp. 258-267. </pages> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [4, 15, 44, 41] </ref>. In Figure 6 we show the expanded specification of pop from Figure 5. As can be seen from this example, the expanded specification has a postcondition that is a conjunction of implications, one for each case.
Reference: [5] <author> Kate Finney. </author> <title> Mathematical notation in formal specification: </title> <journal> Too difficult for the masses? IEEE Transactions on Software Engineering, </journal> <volume> 22(2) </volume> <pages> 158-159, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: A preliminary study by Finney <ref> [5] </ref> indicates that graphic mathematical notations, such as those found in Z [9, 35] may make such specifications hard to read, even for programmers trained in the notation. This accords with our experience in teaching formal specification notations to programmers.
Reference: [6] <author> David K. Gifford and John M. Lucassen. </author> <title> Integrating functional and imperative programming. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 28-38. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year> <month> 34 </month>
Reference-contexts: Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [6, 24, 25, 30, 36, 45] </ref> to make sure that only pure methods and constructors may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [7] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction JML stands for "Java Modeling Language." JML is a behavioral interface specification language (BISL) [42] designed to specify Java <ref> [1, 7] </ref> modules. Java modules are classes and interfaces. The main goal of the research presented in this paper is to better understand how to make BISLs (and BISL tools) that are practical and effective for production software environments.
Reference: [8] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: We also have in mind a long range goal of a specification compiler, that would produce prototypes from constructive specifications [39]. As a general strategy for achieving these goals, we have tried to blend the Eiffel [27, 28, 29] and Larch <ref> [42, 43, 8, 16] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions. We also use the old notation from Eiffel, as described below, instead of the Larch style annotation of names with state functions.
Reference: [9] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: A preliminary study by Finney [5] indicates that graphic mathematical notations, such as those found in Z <ref> [9, 35] </ref> may make such specifications hard to read, even for programmers trained in the notation. This accords with our experience in teaching formal specification notations to programmers.
Reference: [10] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: The precondition says what must be true about the arguments (and other parts of the state); if the precondition is true, then the method must terminate in a state that satisfies the postcondition. This is a contract between the caller of the method and the implementor <ref> [10, 27] </ref>. The caller is obligated to make the precondition true, and gets the benefit of having the postcondition then be satisfied. The implementor gets the benefit of being able to assume the precondition, and is obligated to make the postcondition true in that case.
Reference: [11] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: represents clause gives additional facts that can be used in reasoning about the specification; in essence it tells how to extract the value of size from the value of theStack. 5 It serves the same purpose as an abstraction function in various proof methods for abstract data types (such as <ref> [11] </ref>). The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification [17, 37, 38]. This concept is signaled in JML by the use of the keyword redundantly. <p> * pennies); //@ example pennies == 400 && factor == 1.01 //@ && result.pennies == 404; //@ - 18 2.4 Implementation of Class and Interface Specifications The key to proofs that an implementation of a class or interface specification is correct lies in the use of depends and represents clauses <ref> [11, 21] </ref>. Consider, for example, the abstract class MoneyAC given in Figure 11. This class is abstract and has no constructors. The class declares a concrete field numCents, which is related to the model field pennies by the represents clause.
Reference: [12] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: We also use the old notation from Eiffel, as described below, instead of the Larch style annotation of names with state functions. However, Eiffel specifications, as written by Meyer, are typically not as detailed as model-based specifications written, for example, in Larch BISLs or VDM <ref> [12] </ref>. Hence, we have combined these approaches, by using syntactic ideas from Eiffel and semantic ideas from model-based specification languages. JML also has some other differences from Eiffel (and its cousins Sather and Sather-K). The most important is the concept of specification-only declarations.
Reference: [13] <author> K. Lano and H. Haughton, </author> <title> editors. Object-Oriented Specification Case Studies. The Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: [14] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioral specifications for C++ modules. </title> <editor> In Haim Kilov and William Harvey, editors, </editor> <booktitle> Specification of Behavioral Semantics in Object-Oriented Information Modeling, chapter 8, </booktitle> <pages> pages 121-142. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1996. </year> <note> An extended version is TR #96-01d, </note> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011. </month>
Reference-contexts: This interface has a history constraint, which says that the number of pennies in an object cannot change. 7 The interesting aspect of the operations is another kind of redundancy, given by the example clauses <ref> [14, 17] </ref>. Any number of examples can be given for a specification case. Here there are three examples in the specification of dollars and two in the specification of cents. <p> This interface is given in Figure 8. It says that objects should have equals and clone methods. The specification of JMLType is noteworthy in its use of informal predicates <ref> [14] </ref>. In this instance, the informal predicates are used as an escape from formality. The use of informal predicates avoids the delicate issues of saying what observable aliasing means 8 , and what equality of values means. As specified in Figure 7, the type Money lacks some useful operations. <p> In this example the redundant modifiable clause follows from the given modifiable clause and the meaning of the depends clause inherited from the superclass MoneyAC. The second constructor in Figure 13 is noteworthy in that there is a redundant ensures clauses that uses an informal predicate <ref> [14] </ref>. In this instance, the informal predicate is used as a comment (which could also be used).
Reference: [15] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.14. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, October 1997. </note>
Reference-contexts: Because they describe interface details for clients written in a specific programming language, BISLs are inherently language-specific [42]. For example, a BISL tailored to C++, such as Larch/C++ <ref> [15] </ref>, describes how to use a module in a C++ program. A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). <p> In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [4, 15, 44, 41] </ref>. In Figure 6 we show the expanded specification of pop from Figure 5. As can be seen from this example, the expanded specification has a postcondition that is a conjunction of implications, one for each case. <p> =&gt; o instanceof NodeType && nodes.isIn (o)]; ensures result.equals (nodeSet.union ( new JMLValueSet - NodeType n | exists (ArcType a) [arcs.isIn (a) && ( nodeSet.isIn (a.from) && n.equals (a.to) || nodeSet.isIn (a.to) && n.equals (a.from) )]-)); - - // end of class Digraph 28 2.7 Subtyping Following Dhara and Leavens <ref> [3, 15] </ref>, a subtype inherits the specifications of its supertype's public and protected members (fields and methods), as well as invariants and history constraints.
Reference: [16] <author> Gary T. Leavens. </author> <title> Larch frequently asked questions. </title> <note> Version 1.89. Available in http://www.cs.iastate.edu/~leavens/larch-faq.html, January 1998. </note>
Reference-contexts: We also have in mind a long range goal of a specification compiler, that would produce prototypes from constructive specifications [39]. As a general strategy for achieving these goals, we have tried to blend the Eiffel [27, 28, 29] and Larch <ref> [42, 43, 8, 16] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions. We also use the old notation from Eiffel, as described below, instead of the Larch style annotation of names with state functions.
Reference: [17] <author> Gary T. Leavens and Albert L. Baker. </author> <title> Enhancing the pre- and postcondition technique for more expressive specifications. </title> <type> Technical Report 97-19, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification <ref> [17, 37, 38] </ref>. This concept is signaled in JML by the use of the keyword redundantly. It says both that the stated property is specified to hold and that this property is believed to follow from the other properties of the specification. <p> This interface has a history constraint, which says that the number of pennies in an object cannot change. 7 The interesting aspect of the operations is another kind of redundancy, given by the example clauses <ref> [14, 17] </ref>. Any number of examples can be given for a specification case. Here there are three examples in the specification of dollars and two in the specification of cents.
Reference: [18] <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 520-534. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1997. </year>
Reference-contexts: Note the use of the cast in the postcondition of clone, which is necessary, since the type of result is Object. (This also adheres to our goal of using Java syntax and semantics to the extent possible.) Note also that the conjunct result instanceof BoundedThing "protects" the next conjunct <ref> [18] </ref> since if it is false the meaning of the cast does not matter. 4 Java does not allow fields to be declared in interfaces, but JML allows model fields in interfaces, since these are essential for defining the abstract values of the objects being specified. 8 package edu.iastate.cs.jml.samples.stacks; public interface <p> As specified in Figure 7, the type Money lacks some useful operations. The extensions in Figures 9 and 10 provide specifications of comparison operations and arithmetic, respectively. The specification in Figure 9 is interesting because each of the specified preconditions protects the postcondition from undefinedness in the postcondition <ref> [18] </ref>. For example, if the argument m2 in the greaterThan method were null, then the expression m2.pennies would not be defined. The specification of MoneyOps in Figure 10 is interesting for the use of a model method, inRange.
Reference: [19] <author> Henry. F. Ledgard. </author> <title> A human engineered variant of bnf. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 15(10) </volume> <pages> 57-62, </pages> <month> October </month> <year> 1980. </year>
Reference: [20] <author> K. Rustan M. Leino. </author> <title> A myth in the modular specification of programs. </title> <type> Technical Report KRML 63, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> November </month> <year> 1995. </year> <title> Obtain from the author, </title> <booktitle> at rustan@pa.dec.com. </booktitle> <pages> 35 </pages>
Reference-contexts: Our interpretation of this is very strict, as even benevolent side effects are disallowed if the modifiable clause is omitted <ref> [21, 20] </ref>. When a method can modify some objects, these objects have different values in the pre-state and post-state of that method. Often the post-condition must refer to both of them. This is a notation similar to Eiffel's is used, to refer to the pre-state value of a variable. <p> In this expansion, the model fields size and theStack are asserted to be unmodified in the second case's translation. The depends clause is important in "loosening up" the modifiable clause, for example to permit the fields of an object that implement the abstract model to be changed <ref> [21, 20] </ref>. This "loosening up" also applies to model fields that have dependencies declared. For example, since size depends on theStack, i.e., size is in some sense represented by theStack, if size is mentioned in a modifiable clause, then theStack is implicitly allowed to be modified.
Reference: [21] <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: Our interpretation of this is very strict, as even benevolent side effects are disallowed if the modifiable clause is omitted <ref> [21, 20] </ref>. When a method can modify some objects, these objects have different values in the pre-state and post-state of that method. Often the post-condition must refer to both of them. This is a notation similar to Eiffel's is used, to refer to the pre-state value of a variable. <p> In this expansion, the model fields size and theStack are asserted to be unmodified in the second case's translation. The depends clause is important in "loosening up" the modifiable clause, for example to permit the fields of an object that implement the abstract model to be changed <ref> [21, 20] </ref>. This "loosening up" also applies to model fields that have dependencies declared. For example, since size depends on theStack, i.e., size is in some sense represented by theStack, if size is mentioned in a modifiable clause, then theStack is implicitly allowed to be modified. <p> * pennies); //@ example pennies == 400 && factor == 1.01 //@ && result.pennies == 404; //@ - 18 2.4 Implementation of Class and Interface Specifications The key to proofs that an implementation of a class or interface specification is correct lies in the use of depends and represents clauses <ref> [11, 21] </ref>. Consider, for example, the abstract class MoneyAC given in Figure 11. This class is abstract and has no constructors. The class declares a concrete field numCents, which is related to the model field pennies by the represents clause.
Reference: [22] <author> Richard Allen Lerner. </author> <title> Specifying objects of concurrent systems. </title> <type> Ph.D. Thesis CMU-CS-91-131, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: When executing predicates, errors will also be ignored, but will cause run time errors. 4 Conclusions One area of future work for JML is concurrency. Our current plan is to use when clauses that say when a method may proceed to execute, after it is called <ref> [22, 34] </ref>. This permits the specification of when the caller is delayed to obtain a lock, for example. While syntax for this exists in the JML parser, our exploration of this topic is still in an early stage.
Reference: [23] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The figure's invariant says that in every visible state, the MAX SIZE variable has to be positive, and that every reachable object that is a BoundedThing must have a size field that has a value less than or equal to MAX SIZE. Following the invariant is a history constraint <ref> [23] </ref>. A history constraint is used to say how values can change between earlier and later states, such as a method's pre-state and its post-state. This prohibits subtypes from making certain state changes, even if they implement more methods than are specified in a given class.
Reference: [24] <author> John M. Lucassen. </author> <title> Types and effects: Towards the integration of functional and imperative programming. </title> <type> Technical Report TR-408, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [6, 24, 25, 30, 36, 45] </ref> to make sure that only pure methods and constructors may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [25] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 47-57. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [6, 24, 25, 30, 36, 45] </ref> to make sure that only pure methods and constructors may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [26] <author> David Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. </author> <title> ANNA </title>
Reference-contexts: A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). JML specifications are designed to be annotations in Java code files <ref> [26, 37, 38] </ref>. To a Java compiler such annotations are comments that are ignored. This allows JML specifications, such as the specification in Figure 1, to be embedded in Java code files.
References-found: 26

