URL: http://theory.lcs.mit.edu/~alex/ftcs97.ps
Refering-URL: http://theory.lcs.mit.edu/~alex/ls9697.html
Root-URL: 
Title: Robust emulation of shared memory using dynamic quorum-acknowledged broadcasts  
Author: N. A. Lynch A. A. Shvartsman 
Address: 545 Technology Square, Cambridge, MA 02139  
Affiliation: Massachusetts Institute of Technology, Laboratory for Computer Science  
Abstract: This paper presents a robust emulation of multi-writer/multi-reader registers in message-passing systems using dynamic quorum configurations. In addition to processor and link failures, this emulation tolerates changes in quorum configurations, i.e., on-line replacements of one quorum system consisting of read and write quorums with another such system. The new emulation is specified using a modular two-layer architecture. The lower layer uses unreliable broadcast to disseminate a client request to a set of processors, and then to collect responses from a subset of the processors. The higher layer emulates robust multi-writer/multi-reader registers where quorum configurations are used to ensure register atomicity. A unique feature of the read/write service is that it implements dynamically changing quorum configurations. The processor designated as the reconfigurer executes requests that replace the current configuration with a new configuration. The combination of the higher and lower layers allows essentially unlimited concurrency and does not involve locks. Waiting can occur only due to processor or link failures that disconnect at least one processor in each read quorum or at least one processor in each write quorum of the specified configurations. Additional computation and communication overhead can be incurred by the read and write operations when they encounter frequent reconfigurations. The algorithms are specified here in terms of I/O automata and their correctness is proved using invariants and partial-order methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal and A. El Abbadi, </author> <title> Resilient Logical Structures for Efficient Management of Replicated Data, </title> <type> TR, </type> <institution> Univ. of California Santa Barbara, </institution> <year> 1992. </year>
Reference-contexts: Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums <ref> [1, 6, 7, 10] </ref>. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2.
Reference: [2] <author> H. Attiya, A. Bar-Noy and D. Dolev, </author> <title> Sharing Memory Robustly in Message Passing Systems, </title> <journal> J. of the ACM, </journal> <volume> vol. 42, no. 1, </volume> <pages> pp. 124-142, </pages> <year> 1996. </year>
Reference-contexts: Consequently, in such cases there is value in developing an algorithm first for the shared-memory model and then automatically converting it to run in the message-passing model. Among the important results in this area are the algorithms of Attiya, Bar-Noy and Dolev <ref> [2] </ref> who showed that it is possible to emulate shared memory robustly in message-passing systems. Our work is inspired by and builds on their results. In more detail, [2] shows that any wait-free algorithm for the shared-memory model that uses atomic single-writer/multi-reader registers can be emulated in the message-passing model where <p> Among the important results in this area are the algorithms of Attiya, Bar-Noy and Dolev <ref> [2] </ref> who showed that it is possible to emulate shared memory robustly in message-passing systems. Our work is inspired by and builds on their results. In more detail, [2] shows that any wait-free algorithm for the shared-memory model that uses atomic single-writer/multi-reader registers can be emulated in the message-passing model where processors or links are subject to crash failures. The authors of [2] give a basic algorithm for complete networks using unbounded timestamps, a version for arbitrary network topologies, <p> Our work is inspired by and builds on their results. In more detail, <ref> [2] </ref> shows that any wait-free algorithm for the shared-memory model that uses atomic single-writer/multi-reader registers can be emulated in the message-passing model where processors or links are subject to crash failures. The authors of [2] give a basic algorithm for complete networks using unbounded timestamps, a version for arbitrary network topologies, and a version that uses only bounded timestamps. <p> These algorithms are based on processor majorities and thus are able to tolerate scenarios where any minority of processors are disabled or are unable to communicate. The algorithms in <ref> [2] </ref> are constructed with the help of a communicate procedure that uses half-duplex, ping-pong, point-to-point links to broadcast messages and to collect responses from any majority of processors. Using majorities is a special case of quorum systems [9]. <p> Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of <ref> [2] </ref> is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10]. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] <p> <ref> [2] </ref> is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10]. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2. We generalize the majority-based approaches of [2] to a quorum-based approach. 3. <p> Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev <ref> [2] </ref> in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2. We generalize the majority-based approaches of [2] to a quorum-based approach. 3. We introduce a management interface used to reconfigure the quorum system on-the-fly without changing the functional interface of the service and without suspending any reads/writes in progress or disabling new requests. 4. <p> Our use of the primitives illustrates how they can be effective tools in developing distributed algorithms. The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum systems are used to ensure that the registers are atomic [13, 12, 14]. This layer extends the single writer protocol of <ref> [2] </ref> to a multi-writer protocol. We use quorum systems in a way that ensures the atomicity of the multi-writer/multi-reader registers without resorting to locking or mutual exclusion. A unique feature of this layer is that we deal with dynamically changing quorum configurations. <p> In general, using a quorum system that is k versions older than the current system increases time by at most 2dk, thus reads and writes take at most time 4d + 2dk. In our implementation, we assume the availability of unbounded counters, whereas <ref> [2] </ref> also provides an implementation using bounded counters. We discuss this assumption at the end of the paper. In this work we do not consider the orthogonal issues of performance and availability of quorum systems (cf. [19]). The rest of this paper is as follows. <p> We sketch a proof that A FQ implements an atomic multi-reader/multi-writer register and analyze its performance. The presentation illustrates the main ideas and techniques used in the next section for the more complicated algorithm using dynamic quorum configurations. 4.1 Algorithm specification In the approach of Attiya, Bar-Noy and Dolev <ref> [2] </ref>, each copy of the register is stored together with a label used to order the writes and to determine which write's result is returned by each read. In their single-writer approach the monotonically increasing label is maintained by the writer. <p> One of our extensions is to use a quorum configuration instead of majorities. Our solution uses nearly identical algorithms for the readers and the (now multiple) writers. We replace the labels of <ref> [2] </ref> with tags generated by the writers. Each tag is a pair consisting of the sequence number seq and the processor identifier pid. The tags are compared lexicographically (&lt; lex ). Each register is represented locally at each processor by its value val and its tag tag. <p> On efficient atomic read/write registers and bounded sequence numbers: Our algorithms assume the availability of unbounded counters used to number register versions and quorum configurations. The single-writer algorithm of At-tiya, Bar-Noy and Dolev <ref> [2] </ref> is refined by the authors to use bounded counters at a modest increase in storage and message sizes. The implementation of [2] assumes a reliable ping-pong mechanism. This is done to allow, in a particular section of the protocol, only a single unacknowledged message between any two processors. <p> The single-writer algorithm of At-tiya, Bar-Noy and Dolev <ref> [2] </ref> is refined by the authors to use bounded counters at a modest increase in storage and message sizes. The implementation of [2] assumes a reliable ping-pong mechanism. This is done to allow, in a particular section of the protocol, only a single unacknowledged message between any two processors. Furthermore, any link is assumed to be reliable unless it crashes, after which the link remains forever inoperable.
Reference: [3] <author> P.A. Bernstein, V. Hadzilacos and N. Goodman, </author> <title> Con-currency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. <ref> [3] </ref>), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10]. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations.
Reference: [4] <author> S.E. Deering and D.R. Cheriton, </author> <title> Multicast Routing in Datagram Internetworks and Extended LANs, </title> <journal> ACM TOCS, </journal> <volume> vol. 8, no. 2, </volume> <year> 1990. </year>
Reference-contexts: In network settings where processors cooperate closely, it is increasingly important to assume the availability of efficient broadcast or multicast. This assumption is reasonable for LAN-based environments and for emerging high-speed WANs. The availability of hardware-assisted broadcast <ref> [21, 4] </ref> makes the cost of using broadcast much smaller than the the cost of sending multiple point-to-point messages. Our robust emulation can tolerate a broad range of patterns of processor and link failures.
Reference: [5] <author> S.B. Davidson, H. Garcia-Molina and D. Skeen, </author> <title> Consistency in Partitioned Networks, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 341-370, </pages> <year> 1985. </year>
Reference-contexts: read quorums and a collection of write quorums such that any read quorum intersects any write quorum and any two write quorums intersect. (In this work we do not require the intersection property of write quorums.) Quorums have been used to implement distributed mutual exclusion [8] and data replication protocols <ref> [5, 11] </ref>. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10].
Reference: [6] <author> A. El Abbadi, D. Skeen and F. Cristian, </author> <title> An Efficient Fault-Tolerant Protocol for Replicated Data Management, </title> <booktitle> in Proc. of the Fourth ACM Symp. on Princ. of Databases, </booktitle> <pages> pp. 215-228, </pages> <year> 1985. </year>
Reference-contexts: Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums <ref> [1, 6, 7, 10] </ref>. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2.
Reference: [7] <author> A. El Abbadi and S. Toueg, </author> <title> Maintaining Availability in Partitioned Replicated Databases, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> vol. 14, no. 2, </volume> <pages> pp. 264-290, </pages> <year> 1989. </year>
Reference-contexts: Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums <ref> [1, 6, 7, 10] </ref>. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2.
Reference: [8] <author> H. Garcia-Molina and D. Barbara, </author> <title> How to Assign Votes in a Distributed System, </title> <journal> J. of the ACM, </journal> <volume> vol. 32, no. 4, </volume> <pages> pp. 841-860, </pages> <year> 1985. </year>
Reference-contexts: Using majorities is a special case of quorum systems [9]. A simple quorum system (also called a coterie) is a collection of sets such that any two sets, called quorums, intersect <ref> [8] </ref>. <p> system into a collection of read quorums and a collection of write quorums such that any read quorum intersects any write quorum and any two write quorums intersect. (In this work we do not require the intersection property of write quorums.) Quorums have been used to implement distributed mutual exclusion <ref> [8] </ref> and data replication protocols [5, 11]. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10].
Reference: [9] <author> D.K. Gifford, </author> <title> Weighted Voting for Replicated Data, </title> <booktitle> in Proc. of 7th ACM Symp. on Oper. Sys. Princ., </booktitle> <pages> pp. 150-162, </pages> <year> 1979. </year>
Reference-contexts: The algorithms in [2] are constructed with the help of a communicate procedure that uses half-duplex, ping-pong, point-to-point links to broadcast messages and to collect responses from any majority of processors. Using majorities is a special case of quorum systems <ref> [9] </ref>. A simple quorum system (also called a coterie) is a collection of sets such that any two sets, called quorums, intersect [8].
Reference: [10] <author> K. Goldman and N. Lynch, </author> <title> Nested Transactions and Quorum Consensus, </title> <booktitle> in Proc. of the 6th ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 27-41, </pages> <year> 1987 </year>
Reference-contexts: Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums <ref> [1, 6, 7, 10] </ref>. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers [13, 12, 14]. 2.
Reference: [11] <author> M.P. Herlihy, </author> <title> Replication Methods for Abstract Data Types, Doctoral Dissert., </title> <publisher> MIT, </publisher> <address> LCS/TR-319, </address> <year> 1984. </year>
Reference-contexts: read quorums and a collection of write quorums such that any read quorum intersects any write quorum and any two write quorums intersect. (In this work we do not require the intersection property of write quorums.) Quorums have been used to implement distributed mutual exclusion [8] and data replication protocols <ref> [5, 11] </ref>. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [3]), whereas our goal and the goal of [2] is to reduce restrictions on asynchrony and concurrency. Many other replication techniques use quorums [1, 6, 7, 10].
Reference: [12] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 12, no. 3, </volume> <pages> pp. 463-492, </pages> <year> 1990. </year>
Reference-contexts: In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers <ref> [13, 12, 14] </ref>. 2. We generalize the majority-based approaches of [2] to a quorum-based approach. 3. We introduce a management interface used to reconfigure the quorum system on-the-fly without changing the functional interface of the service and without suspending any reads/writes in progress or disabling new requests. 4. <p> Each primitive admits a straightforward message-passing implementation. Our use of the primitives illustrates how they can be effective tools in developing distributed algorithms. The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum systems are used to ensure that the registers are atomic <ref> [13, 12, 14] </ref>. This layer extends the single writer protocol of [2] to a multi-writer protocol. We use quorum systems in a way that ensures the atomicity of the multi-writer/multi-reader registers without resorting to locking or mutual exclusion.
Reference: [13] <author> L. Lamport, </author> <title> On Interprocess Communication: Part I and II, </title> <journal> Dist. Comput., </journal> <volume> vol. 1, </volume> <pages> pp. 77-101, </pages> <year> 1986. </year>
Reference-contexts: In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers <ref> [13, 12, 14] </ref>. 2. We generalize the majority-based approaches of [2] to a quorum-based approach. 3. We introduce a management interface used to reconfigure the quorum system on-the-fly without changing the functional interface of the service and without suspending any reads/writes in progress or disabling new requests. 4. <p> Each primitive admits a straightforward message-passing implementation. Our use of the primitives illustrates how they can be effective tools in developing distributed algorithms. The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum systems are used to ensure that the registers are atomic <ref> [13, 12, 14] </ref>. This layer extends the single writer protocol of [2] to a multi-writer protocol. We use quorum systems in a way that ensures the atomicity of the multi-writer/multi-reader registers without resorting to locking or mutual exclusion.
Reference: [14] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1996. </year>
Reference-contexts: In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [2] in four ways: 1. Our construction emulates multi-writer/multi-reader atomic registers <ref> [13, 12, 14] </ref>. 2. We generalize the majority-based approaches of [2] to a quorum-based approach. 3. We introduce a management interface used to reconfigure the quorum system on-the-fly without changing the functional interface of the service and without suspending any reads/writes in progress or disabling new requests. 4. <p> Each primitive admits a straightforward message-passing implementation. Our use of the primitives illustrates how they can be effective tools in developing distributed algorithms. The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum systems are used to ensure that the registers are atomic <ref> [13, 12, 14] </ref>. This layer extends the single writer protocol of [2] to a multi-writer protocol. We use quorum systems in a way that ensures the atomicity of the multi-writer/multi-reader registers without resorting to locking or mutual exclusion. <p> A resource manager can monitor system performance and availability and evolve the quorum system using the management interface. Our algorithms are specified and analyzed in terms of I/O automata <ref> [14, 15] </ref>. We use invariants and partial-order methods to prove algorithm correctness. The correctness analysis assumes no bounds on message delivery times. We analyze performance by assuming that point-to-point messages are either delivered in bounded time d or not delivered at all. Moreover, local processor step time is negligible. <p> Let C be the set of configurations. C 0 is a distinguished configuration. * For any set A we define A ? to be A [ f?g, where ? is a distinguished null value. The specifications in this paper are done in terms of I/O automata <ref> [14, 15] </ref>. Each automaton models a state machine with states and transitions between states. Actions are associated with sets of state transitions. There are input, output and internal actions labeled by Inp, Out and Int respectively. An action is enabled iff the preconditions (labeled Pre:) are satisfied. <p> Theorem 4.1 A FQ implements an atomic multi-writer multi-reader register. To prove Theorem 4.1 we need to show the atomicity of the read and write operations for any execution. We show atomic-ity of the implementation by using Lemma 13.16 of <ref> [14] </ref>. This lemma gives sufficient conditions for showing atomicity of a sequence of actions of a read/write register. Namely, it gives conditions on a partial order of read and write operations in the sequence that imply that the sequence satisfies atomicity. <p> The key lemma showing that P O satisfies the conditions required by Lemma 13.16 of <ref> [14] </ref> is: Lemma 4.2 If in an execution ff of A FQ , 1 cp 2 , then (i) if the operation 2 is a read, then t ff ( 1 ) lex t ff ( 2 ), and (ii) if the operation 2 is a write, then t ff ( <p> Theorem 5.1 A RQ implements an atomic multi-writer multi-reader register. The proof parallels the proof of correctness of A FQ and is based on showing the atomicity of the read and write operations for any execution. Theorem 5.1 is shown by constructing a partial order and using Lemma 13.16 <ref> [14] </ref>. For an execution ff of A RQ containing no incomplete operations, let sequence fi be the projection of ff containing the invocation/confirm events of read and write operations. Let be the set of operations in fi. <p> define fill (i; id) if op (id) = ? then ? else if i 2 op (id):acks then op (id):acc [i] else if 9m : hm; idi 2 ack-q i then (the unique) m else i (m; state i ) 2 We show atomicity of A RQ using Lemma 13.16 <ref> [14] </ref>. The key to the proof is a multi-part invariant, which we present just below. Part I3 is the most important part; it mirrors Lemma 4.2 of the algorithm with fixed quorum configurations as it relates the tags of operations where one follows another. <p> It appears that such reliable ping-pong mechanism would assume too much reliability on the part of the communication subsystem. We conjecture that either the underlying subsystem may itself need to use either unbounded counters or messages of unbounded size (cf. the result <ref> [14, Thm. 22.11] </ref> of Lynch, Mansour and Fekete). On failure models: We have considered only the benign component failures the processor and link failures never create spontaneous messages and the messages that are sent are delivered without alteration.
Reference: [15] <author> N.A. Lynch and M.R. Tuttle, </author> <title> An Introduction to Input/Output Automata, </title> <journal> CWI Quarterly, vol.2, </journal> <volume> no. 3, </volume> <pages> pp. 219-246, </pages> <year> 1989. </year>
Reference-contexts: A resource manager can monitor system performance and availability and evolve the quorum system using the management interface. Our algorithms are specified and analyzed in terms of I/O automata <ref> [14, 15] </ref>. We use invariants and partial-order methods to prove algorithm correctness. The correctness analysis assumes no bounds on message delivery times. We analyze performance by assuming that point-to-point messages are either delivered in bounded time d or not delivered at all. Moreover, local processor step time is negligible. <p> Let C be the set of configurations. C 0 is a distinguished configuration. * For any set A we define A ? to be A [ f?g, where ? is a distinguished null value. The specifications in this paper are done in terms of I/O automata <ref> [14, 15] </ref>. Each automaton models a state machine with states and transitions between states. Actions are associated with sets of state transitions. There are input, output and internal actions labeled by Inp, Out and Int respectively. An action is enabled iff the preconditions (labeled Pre:) are satisfied.
Reference: [16] <author> D. Malki and M. Reiter, </author> <title> Byzantine Quorum Systems, </title> <booktitle> to appear in Proceedings of the 29th ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: On failure models: We have considered only the benign component failures the processor and link failures never create spontaneous messages and the messages that are sent are delivered without alteration. Malki and Reiter <ref> [16] </ref> recently explored the use of quorum systems in the presence of Byzantine failures. It would be interesting to examine additional failure models that can be handled by atomic register emulations.
Reference: [17] <author> M.H. Olsen, E. Oskiewicz and J.P. Warne, </author> <title> A Model for Interface Groups, </title> <booktitle> IEEE 10th Symp. on Reliable Distributed Systems, </booktitle> <pages> pp. 98-107, </pages> <year> 1991. </year>
Reference: [18] <author> J.-F. Paris and P.K.Sloope, </author> <title> Dynamic Management of Highly Replicated Data, </title> <booktitle> in IEEE 11th Symp. on Reliable Distr. Systems, </booktitle> <pages> pp. 20-27, </pages> <year> 1992. </year>
Reference: [19] <author> D. Peleg and A. Wool, </author> <title> How to be an Efficient Snoop, or the Probe Complexity of Quorum Systems, </title> <booktitle> in Proc. of the 15th ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 290-299, </pages> <year> 1996. </year>
Reference-contexts: In our implementation, we assume the availability of unbounded counters, whereas [2] also provides an implementation using bounded counters. We discuss this assumption at the end of the paper. In this work we do not consider the orthogonal issues of performance and availability of quorum systems (cf. <ref> [19] </ref>). The rest of this paper is as follows. In Section 2 we define models and conventions. In Section 3 we present the (C) and primitives. Section 4 deals with the multi-writer/multi-reader service that uses (C). Section 5 deals with the reconfigurable algorithm using . <p> It would be interesting to examine additional failure models that can be handled by atomic register emulations. Optimizing the communication efficiency of accessing quorum systems: In our solution we use unreliable broadcast (or simulated broadcast) to achieve substantial asynchrony, concur-rency and fault-tolerance. The results of Peleg and Wool <ref> [19] </ref> indicate that for many quorum systems a linear number of messages would in fact be required to reach a single active quorum or to detect a quorum all of whose members either have failed or are inaccessible.
Reference: [20] <author> A. Pogosyants, R. Segala and N. Lynch, </author> <title> Verification of the Randomized Consensus Algorithm of Aspens and Herlihy: a Case Study, </title> <type> manuscript, </type> <year> 1997. </year>
Reference-contexts: In showing the correctness of A RQ , we use a succinct and effective way of expressing the eventuality of certain outcomes based on the current knowledge. The proof uses a fill notion (also used in <ref> [20] </ref>), which we use to predict the acknowledgment vector for a current invocation. This notion can be used to great advantage in stating our invariants and in reducing the size of their proofs.
Reference: [21] <author> RFC 1112, </author> <title> Internet Group Multicast Protocol, Internet Standard Protocol (Recommended). </title>
Reference-contexts: In network settings where processors cooperate closely, it is increasingly important to assume the availability of efficient broadcast or multicast. This assumption is reasonable for LAN-based environments and for emerging high-speed WANs. The availability of hardware-assisted broadcast <ref> [21, 4] </ref> makes the cost of using broadcast much smaller than the the cost of sending multiple point-to-point messages. Our robust emulation can tolerate a broad range of patterns of processor and link failures.
Reference: [22] <author> A.A. Shvartsman, </author> <title> Dealing with History and Time in a Distributed Enterprise Manager, </title> <journal> IEEE Network, </journal> <volume> vol. 7, no. 6, </volume> <pages> pp. 32-41, </pages> <year> 1993. </year>
Reference-contexts: This is done transparently to the clients that are using the functional read/write interface. The management interface can be used to tune the performance of a distributed system based on current and historical observations with the help of a framework such as described in <ref> [22] </ref>. A resource manager can monitor system performance and availability and evolve the quorum system using the management interface. Our algorithms are specified and analyzed in terms of I/O automata [14, 15]. We use invariants and partial-order methods to prove algorithm correctness.
Reference: [23] <author> M. Sloman, </author> <title> Management: What and Why, in Network and Distributed Systems Management, </title> <editor> M. Sloman, Ed., </editor> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The solution implemented by the composition of the two layers reflects practical system concerns dealing with communication efficiency, with fault-tolerance and with system management (i.e., with supervision and control of the system so that it fulfills the requirements of its users, cf. <ref> [23] </ref>). Our services can be implemented by using point-to-point messages or by taking advantage of broadcast. In network settings where processors cooperate closely, it is increasingly important to assume the availability of efficient broadcast or multicast. This assumption is reasonable for LAN-based environments and for emerging high-speed WANs.
References-found: 23

