URL: ftp://cse.ogi.edu/pub/tech-reports/1997/97-008.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Title: Reactive Functional Programming  
Author: Richard B. Kieburtz 
Date: October 13, 1997  
Address: P.O. Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Reactive systems respond to concurrent, possibly unsynchronized streams of input events. Programming reactive systems is challenging without language support for event-triggered actions. It is even more challenging to reason about reactive systems. This paper explores a new conceptual basis for applying functional programming techniques to the design and formal verification of reactive systems. The mathematical foundation for this approach is based upon signature coalgebras and derived proof rules for coinduction. The concepts are illustrated with an example that has been used with the language Esterel. 
Abstract-found: 1
Intro-found: 1
Reference: [BG88] <author> Gerard Berry and Georges Gonthier. </author> <title> The ESTEREL synchronous programming language: Design, semantics, implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Formulating a reactive system as a coalgebra is easy because the use of multiple sorts provides a natural and detailed structure for the specification. We shall illustrate the technique with an example of a synchronous reactive system previously used to illustrate programming in Esterel <ref> [BG88] </ref>. Example 3.1 : The Reflex game The Reflex game is a coin-operated machine on which a player measures the time constant of her reflexes. After depositing a coin to start the game, she can depress a Ready button to signify that she is prepared to start a trial.
Reference: [Bir86] <author> Richard S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design, volume 36 of NATO Series F. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Section 4 presents conclusions. 1.2 Iterative functional programming In the past few years, several researchers have observed that programming with bounded recursion is algebraic in nature <ref> [Bir86, MFP91, Kie94] </ref>.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference: [Bry92] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference: [CGL92] <author> E. M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We shall attend to the first clause. The most successful way yet developed to verify temporal properties of a finite state system uses model checking of temporal logic formulas <ref> [EC82, CGL92] </ref>. The safety and liveness properties of the Reflex game example can obviously be verified by symbolic model checking. We describe a variant of the stardard technique that uses symbolic inference to check monotonicity properties of state variables over transition paths. We have not yet implemented this method.
Reference: [EC82] <author> E. A. Emerson and E. M. Clarke. </author> <title> Using branching time temporal logic to synthesize synchronizations skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: We shall attend to the first clause. The most successful way yet developed to verify temporal properties of a finite state system uses model checking of temporal logic formulas <ref> [EC82, CGL92] </ref>. The safety and liveness properties of the Reflex game example can obviously be verified by symbolic model checking. We describe a variant of the stardard technique that uses symbolic inference to check monotonicity properties of state variables over transition paths. We have not yet implemented this method.
Reference: [Kie94] <author> Richard B. Kieburtz. </author> <title> Programming with algebras. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute of Science & Technology, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Section 4 presents conclusions. 1.2 Iterative functional programming In the past few years, several researchers have observed that programming with bounded recursion is algebraic in nature <ref> [Bir86, MFP91, Kie94] </ref>.
Reference: [KL94] <author> Richard B. Kieburtz and Jeffrey Lewis. </author> <title> Algebraic Design Language|Preliminary definition. </title> <type> Technical report, </type> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: results of this body of research include the discovery that recursion over typed data structures has a logical counterpart in structural induction, that monads encapsulate effects in particular algebras, and that type-parametric 2 combinators can be embedded in a strict functional programming language to support this style of program construction <ref> [KL94] </ref>. There is a dual to algebraic programming and it is useful in another style of functional programming, which is the topic of this paper. Process-oriented programs are iterative. <p> The notation is used in DUALITY, which is a new functional language based upon algebras and coalgebras as its fundamental computational structures. In this paper we shall deal only with the coalgebraic part. An early version of this language has been implemented and is described in a technical report <ref> [KL94] </ref>. 2 Covarieties of coalgebras A covariety is a class of coalgebras with a common signature.
Reference: [MFP91] <author> Erik Meijer, Maarten Fokkinga, and Ross Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <booktitle> In Proc. of 5th ACM Conf. on Functional Programming Languages and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: Section 4 presents conclusions. 1.2 Iterative functional programming In the past few years, several researchers have observed that programming with bounded recursion is algebraic in nature <ref> [Bir86, MFP91, Kie94] </ref>. <p> The higher-order combinators in DUALITY substitute for the recursion operator found in conventional functional languages. The generator h : = gen [str ] intseq 1 Readers familiar with the notion of anamorphism <ref> [MFP91] </ref> may be tempted to identify generators with anamorphisms. The analogy is false, in general. It would be valid in a computational domain of cpo's, in which the function space encompasses all functions defineable by least fixpoints.
Reference: [Pau93] <author> Lawrence C. Paulson. </author> <title> Co-induction and co-recursion in higher-order logic. </title> <type> Technical Report TR 304, </type> <institution> Computing Laboratory, Cambridge University, </institution> <month> December </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary. An exposition of coinduction is given by Paulson <ref> [Pau93] </ref>. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
References-found: 10

