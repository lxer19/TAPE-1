URL: http://www.cs.ucsb.edu/conferences/java98/papers/jpvm.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Email: ferrari@cs.virginia.edu  
Title: JPVM: Network Parallel Computing in Java  
Author: Adam J. Ferrari 
Address: Charlottesville, VA 22903, USA  
Affiliation: University of Virginia,  
Abstract: The JPVM library is a software system for explicit message-passing based parallel programming in Java. The library supports an interface similar to the C and Fortran interface of the Parallel Virtual Machine (PVM) system, with modifications to better suit Java programming styles. The similarity between JPVM and the widely used PVM system supports a quick learning curve for experienced PVM programmers. At the same time, JPVM offers novel features not found in standard PVM such as thread safety, multiple communication endpoints per task, and default-case direct message routing. JPVM is implemented entirely in Java, and is thus highly portable among platforms supporting the Java Virtual Machine. This feature opens up the possibility of utilizing resources commonly excluded from network parallel computing systems such as Macintosh and Windows based workstations. Initial applications performance results achieved with a prototype JPVM system indicate that the Java-implemented approach can offer good performance at appropriately coarse granularities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.E. Anderson, D.E. Culler, D.A. Patterson, </author> <title> and the NOW team, A Case for NOW (networks of Workstations), </title> <journal> IEEE Micro , vol. </journal> <volume> 15, no. 1, </volume> <pages> pp. 54-64, </pages> <month> February, </month> <year> 1995. </year>
Reference-contexts: Network parallel computing systems allow individual applications to harness the aggregate power of increasingly powerful, well-networked, heterogeneous, and often largely under-utilized collections of resources available to many users <ref> [1] </ref>. Results obtained with network parallel computing systems have been encouraging [9], but the utilization of distributed, heterogeneous, shared resources connected by commodity networks as a single, virtual parallel computer poses serious problems for both the application and system software programmer.
Reference: [2] <author> P. Cappello, B.O. Christiansen, M.F. Ionescu, M.O. Neary, K.E. Schauser, and D. Wu, Javelin: </author> <title> Internet-based Parallel Computing Using Java, </title> <booktitle> ACM Workshop on Java for Science and Engineering Computation, </booktitle> <month> June, </month> <year> 1997. </year>
Reference-contexts: One common approach to this problem is the use of volunteer-based systems such as Bayanihan [7] and Javelin <ref> [2] </ref>. As opposed to JPVM which is based on standalone Java applications, these systems are based on the decomposition of programs into applets that are downloaded by volunteer clients, execute within the context of a web Table 1. Task creation, msecs.
Reference: [3] <author> A.J. Ferrari, JPVM, </author> <note> available from: http://www.cs.virginia.edu/~ajf2j/jpvm.html </note>
Reference-contexts: From the system implementation perspective, Java supports a high degree of code portability and a uniform API for operating system services such as network communications. The JPVM (Java Parallel Virtual Machine) library <ref> [3] </ref> is a software system for explicit message-passing based distributed memory MIMD parallel programming in Java.
Reference: [4] <author> A.J. Ferrari and V.S. Sunderam, </author> <title> Multiparadigm Distributed Computing with TPVM, </title> <journal> Concurrency, </journal> <note> Practice and Experience , (to appear). </note>
Reference-contexts: For example, from the application perspective, Java provides a portable, uniform interface to threads. Using threads instead of traditional heavyweight processes has been found to be an avenue for increasing latency tolerance and allowing finer-grained computations to achieve good performance in distributed memory parallel processing environments <ref> [4] </ref>. From the system implementation perspective, Java supports a high degree of code portability and a uniform API for operating system services such as network communications. The JPVM (Java Parallel Virtual Machine) library [3] is a software system for explicit message-passing based distributed memory MIMD parallel programming in Java.
Reference: [5] <author> A. Geist, A Beguelin, J. Dongarra, W. Jiang, R. Manchek, </author> <title> and V.S. Sunderam, PVM: Parallel Virtual Machine, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The JPVM (Java Parallel Virtual Machine) library [3] is a software system for explicit message-passing based distributed memory MIMD parallel programming in Java. The library supports an interface similar to the C and Fortran interfaces provided by the Parallel Virtual Machine (PVM) system <ref> [5] </ref>, but with syntax and semantics enhancements afforded by Java and better matched to Java programming styles.
Reference: [6] <author> P.A. Gray and V.S. Sunderam, IceT: </author> <title> Distributed Computing and Java, </title> <note> available from: http://www.mathcs.emory.edu/~gray/abstract7.html </note>
Reference-contexts: Furthermore, in being a simple wrapper around the standard PVM implementation, JavaPVM is limited by the semantic and syntactic features of PVM. For example, JavaPVM programs retain the less thread-friendly buffer interface provided by PVM. Another software package for network parallel computing in Java is the IceT system <ref> [6] </ref>. This system addresses a number of concerns not covered by the JPVM design. Whereas JPVM allows a single user to combine resources on which that user has access privileges, IceT is an inherently collaborative, multiuser environment.
Reference: [7] <author> L.F.G. Sarmenta, Bayanihan: </author> <title> Web-Based Volunteer Computing Using Java, </title> <note> available from: http://www.cag.lcs.mit.edu/bayanihan/ </note>
Reference-contexts: One common approach to this problem is the use of volunteer-based systems such as Bayanihan <ref> [7] </ref> and Javelin [2]. As opposed to JPVM which is based on standalone Java applications, these systems are based on the decomposition of programs into applets that are downloaded by volunteer clients, execute within the context of a web Table 1. Task creation, msecs.
Reference: [8] <author> D. Thurman, JavaPVM, </author> <note> available from: http://www.isye.gatech.edu/chmsr/JavaPVM/ </note>
Reference-contexts: The primary drawback of these approaches is the significant restriction placed on communications by the Java security model for applets, which rules out many potentially successful network parallel applications. A system similar to JPVM in its programming interface and model is the JavaPVM library <ref> [8] </ref>. This system also provides a PVM-like interface for Java applications. The primary difference between JavaPVM and JPVM is in implementation. Unlike JPVM which is implemented entirely in Java, JavaPVM is based on the Java Native Methods mechanism, providing native method wrappers around the existing standard PVM routines.
Reference: [9] <author> S. White, A. lund, </author> <title> and V.S. Sunderam, Performance of the NAS Parallel Benchmarks on PVM Based Networks, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp. 61-71, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Network parallel computing systems allow individual applications to harness the aggregate power of increasingly powerful, well-networked, heterogeneous, and often largely under-utilized collections of resources available to many users [1]. Results obtained with network parallel computing systems have been encouraging <ref> [9] </ref>, but the utilization of distributed, heterogeneous, shared resources connected by commodity networks as a single, virtual parallel computer poses serious problems for both the application and system software programmer. <p> In this section we describe the key features of our entirely Java-based JPVM implementation. The JPVM message passing implementation is based on communication over TCP sockets. The use of direct task-to-task TCP connections has been found to significantly outperform the older UDP-based daemon-routed message passing implementation in PVM <ref> [9] </ref>. Each jpvmEnvironment instance creates a server socket during initialization and embeds the host name and port number needed to connect to it within its jpvmTaskId identity. Internally, JPVM uses threads to manage connections and message delivery.
References-found: 9

