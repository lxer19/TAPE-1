URL: http://www.cs.utexas.edu/users/lorenzo/papers/icdcs98.1.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Low-overhead Protocols for Fault-tolerant File Sharing  
Author: Lorenzo Alvisi Sriram Rao Harrick M. Vin 
Address: Austin, Texas 78712-1188, USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: In this paper, we quantify the adverse effect of file-sharing on the performance of reliable distributed applications. We demonstrate that file-sharing incurs significant overhead, which is likely to triple over the next five years. We present a novel approach that eliminates this overhead. Our approach (1) tracks causal dependencies resulting from file-sharing using determinants, (2) efficiently replicates the determinants in the volatile memory of agents to ensure their availability during recovery, and (3) reproduces during recovery the interactions with the file server as well as the file data lost in a failure. Our approach allows agents to exchange files directly, without first saving the files on disks at the server. As a consequence, the costs of supporting file-sharing and message passing in reliable distributed application become virtually identical. The result is a simple, uniform approach, which can provide low-overhead fault-tolerance to applications in which communication is performed through message passing, file-sharing, or a combination of the two. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblock-ing and Orphan-Free Message Logging Protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145154, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We treat write events similarly. The resulting determinants can be efficiently encoded using compression techniques discussed elsewhere <ref> [1] </ref>. We can reduce the number of file versions logged in the volatile memory of agents. Suppose an agent p acquires write ownership on a file F and repeatedly modifies it before its ownership is revoked.
Reference: [2] <author> L. Alvisi and K. Marzullo. </author> <title> Message Logging: Pessimistic, Optimistic, and Causal. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 229236. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-overhead rollback-recovery protocolssuch as checkpointing and message logging <ref> [2, 3, 9, 17, 18] </ref> have been extensively studied for message passing applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> In fact, if there is a unique way to associate data with the corresponding determinant, and all determinants are available during recovery, then a simple induction on the length of the execution shows that delivered messages and file versions accessed for reading or writing can be deterministically regenerated <ref> [2] </ref>. Therefore, assuming that we can guarantee the availability of determinants (see Section 4.2), we substitute data in #e with following pair: hsource; sesni. The meaning of source and sesn depends on e. <p> This guarantees their availability during recovery. The performance of log-based protocols depends on the scheme used to make determinants stable. Our protocols are based on Family-Based Logging (FBL) a logging technique we have proved to be optimal with respect to several significant performance metrics <ref> [2] </ref>. FBL was originally designed to log determinants of deliver events. However, because the determinants of read, write, and deliver events that we have derived have an identical structure, we can naturally extend FBL protocols to handle communication resulting from file sharing.
Reference: [3] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in Implementing Optimal Message Logging Protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 5867. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Low-overhead rollback-recovery protocolssuch as checkpointing and message logging <ref> [2, 3, 9, 17, 18] </ref> have been extensively studied for message passing applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> We show that if determinants are available during recovery, then interactions with the file server can be reproduced, and file data lost in a failure can be regenerated. To ensure determinants availability, we use an efficient replication scheme <ref> [3] </ref> that stores determinants in agents' volatile memory. The final contribution of this paper is the introduction of a novel conceptimplementation in volatile memory of stable storage for files. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> To help agents keep their estimates accurate, different FBL protocols provide agents with different amount of information about the causal past of each non-deterministic event of which they log the determinant <ref> [3] </ref>. We describe here the simplest FBL protocol, in which an agent p estimates jLog (e)j as follows: 1. If p generates #e, it creates a corresponding entry dle in DetLog p and sets dle:logged at to fpg. 2.
Reference: [4] <author> T. Anderson, M. Dahlin, J. Neefe, D. Patterson, D. Roselli, and R. Wang. </author> <title> Serverless Network File Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1996. </year>
Reference-contexts: Traditionally, a file F modified by an agent p can be shared by another agent q only after p has synchronously written F to disks at the file server <ref> [4, 11] </ref>. In our solution, no synchronous write is needed, and p can send F to q without delays. <p> Agents communicate using both message passing and file sharing. Messages are exchanged over FIFO channels that can fail by transiently losing some messages. Files are shared according to an ownership-based consistency protocol <ref> [4, 11] </ref>. Specifically, the file server supports shared read-ownership, and exclusive write-ownership. At any point in time, the content of a file is uniquely identified by its version. We denote version v of file F by F:v. <p> The simulations were seeded by processor, network, and disk performance values that represent the state-of-the-art workstations and networks. To put these results in perspective, we need to account for the expected technological trends <ref> [4] </ref>. Figure 3 illustrates that O will more than triple over the next five years. From these experiments, we conclude that conventional file servers as well as fault-tolerance protocols developed for message passing applications incur substantial overhead for applications in which agents communicate also through file sharing. <p> File servers that support read and write events efficiently have been a topic of much research. For instance, the log-structured file system employ techniques for improving the performance of file writes [14]; xFS implements cooperative caching to improve the performance of file reads <ref> [4] </ref>. Additionally, several techniques for designing file servers that assist applications during failure recovery have been investigated. For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery.
Reference: [5] <author> M. Baker, S. Asami, E. Deprit, J. Ousterhout, and M. Seltzer. </author> <title> Non-Volatile Memory for Fast, Reliable File Systems. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASP-LOS), </booktitle> <pages> pages 1022, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery. Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM <ref> [5] </ref>, or a specialized operating system, such as the Rio file cache [7], in the memory sub-system at the server eliminates the need for synchronous writes to disks. Unfortunately, neither of these approaches address the problem of fault-tolerant file-sharing in its entirety.
Reference: [6] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1):6375, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: Two agents p and q are mutually consistent if they are both mutually message- and file-consistent. A collection of states, one from each agent, is a consistent global state if all pairs of states are mutually consistent <ref> [6] </ref>; otherwise it is inconsistent. We assume that agents fail according to the fail-stop model [15].
Reference: [7] <author> P. M. Chen, W. T. Ng, S. Chandra, C. Aycock, G. Ra-jamani, and D. Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <address> Cambridge, MA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM [5], or a specialized operating system, such as the Rio file cache <ref> [7] </ref>, in the memory sub-system at the server eliminates the need for synchronous writes to disks. Unfortunately, neither of these approaches address the problem of fault-tolerant file-sharing in its entirety.
Reference: [8] <author> E. N. Elnozahy. </author> <title> On the relevance of communication costs of rollback-recovery protocols. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 7479, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: If other processes fail while p is recovering, then determining when Phase 1 is complete is a non-trivial problem <ref> [8] </ref>. To solve it, we use an algorithm that detects the end of Phase 1 without forcing correct processes to block while p recovers. A detailed description of our algorithm is beyond the scope of this paper.
Reference: [9] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5):526531, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Low-overhead rollback-recovery protocolssuch as checkpointing and message logging <ref> [2, 3, 9, 17, 18] </ref> have been extensively studied for message passing applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F .
Reference: [10] <author> J. N. Gray. </author> <title> Notes on Data Base Operating Systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmueller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, </booktitle> <pages> pages 393481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1977. </year> <note> Lecture Notes on Computer Science 60. </note>
Reference-contexts: Finally, we assume that stable storage <ref> [10] </ref> is available throughout the system, persists across failures, and is implemented either using disks at the file server or through replication in the volatile memory of agents. 3 Problem Statement The next generation of distributed applications will be structured around groups of agents that communicate in different ways.
Reference: [11] <author> J. H. Howard, M. L. Kazar, S. G. Menees, D. A. Nichols, M. Satyanarayanan, R. N. Sidebotham, and M. J. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):5181, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Traditionally, a file F modified by an agent p can be shared by another agent q only after p has synchronously written F to disks at the file server <ref> [4, 11] </ref>. In our solution, no synchronous write is needed, and p can send F to q without delays. <p> Agents communicate using both message passing and file sharing. Messages are exchanged over FIFO channels that can fail by transiently losing some messages. Files are shared according to an ownership-based consistency protocol <ref> [4, 11] </ref>. Specifically, the file server supports shared read-ownership, and exclusive write-ownership. At any point in time, the content of a file is uniquely identified by its version. We denote version v of file F by F:v.
Reference: [12] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11:462 491, </volume> <year> 1990. </year>
Reference-contexts: On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> In this case, it may be possible to execute the output commit protocol asynchronously, albeit it must complete prior to the corresponding batched write <ref> [12] </ref>. Figure 3 demonstrate that the above optimizations do reduce O, but due to the orders of magnitude difference between memory and disk speeds, synchronous writes to the disk at the server significantly degrade applica tion performance. 2.
Reference: [13] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: On accessing F , the file server returns the latest version of F . The execution of the system is represented by a run, which is an irreflexive partial ordering of send, receive, read, write, and local events, ordered by potential causality <ref> [13] </ref>. For each agent p, a special class of events local to p are called deliver events. These events correspond to the delivery of a message to the application that p is part of. <p> To specify FBL's logging technique, we introduce two sets for each non-deterministic event e: Depend (e) This set includes the agent which executed e and any agent that executed an event e 0 such that e happens-before e 0 <ref> [13] </ref>. Log (e) This set includes the agents that maintain a copy of #e in volatile memory.
Reference: [14] <author> M. Rosenblum and J. K. Ousterhout. </author> <title> A Case for Log-Structured File Systems. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 115, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: However, it is straightforward to change the protocol so that modified files are asynchronously written back to the file server, thereby making them readily available during recovery. The file server in this case needs to support file versioning: this is achieved, for instance, using a log-structured file system <ref> [14] </ref>. 6 Protocol Design Issues Due to space limitations, we do not present the pseudo-code for our protocol. <p> File servers that support read and write events efficiently have been a topic of much research. For instance, the log-structured file system employ techniques for improving the performance of file writes <ref> [14] </ref>; xFS implements cooperative caching to improve the performance of file reads [4]. Additionally, several techniques for designing file servers that assist applications during failure recovery have been investigated.
Reference: [15] <author> F. B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2):145154, </volume> <month> May </month> <year> 1984. </year>
Reference-contexts: A collection of states, one from each agent, is a consistent global state if all pairs of states are mutually consistent [6]; otherwise it is inconsistent. We assume that agents fail according to the fail-stop model <ref> [15] </ref>.
Reference: [16] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3):204226, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F .
Reference: [17] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile Logging in n-Fault-Tolerant Distributed Systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44 49, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Low-overhead rollback-recovery protocolssuch as checkpointing and message logging <ref> [2, 3, 9, 17, 18] </ref> have been extensively studied for message passing applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> Deliver, read and write events are non-deterministic, because the order in which an agent receives messages and the file versions it accesses are execution-dependent. Send events and other local events are instead deterministic. Agent execution is piecewise deterministic <ref> [17] </ref>: It consists of a sequence of deterministic intervals of execution, joined by non-deterministic events. At any point during the execution, the state of an agent is a mapping of program variables and implicit variables (such as program counters) to their current values 1 . <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpoint-ing and message logging <ref> [2, 3, 9, 12, 16, 17] </ref> incur substantial overhead when used for applications in which agents communicate also through file sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F .
Reference: [18] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala. </author> <title> Checkpointing and Its Applications. </title> <booktitle> In Proceedings of the IEEE Fault-Tolerant Computing Symposium (FTCS-25), </booktitle> <pages> pages 2231, </pages> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-overhead rollback-recovery protocolssuch as checkpointing and message logging <ref> [2, 3, 9, 17, 18] </ref> have been extensively studied for message passing applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions.
References-found: 18

