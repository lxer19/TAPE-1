URL: ftp://grilled.cs.wisc.edu/technical_papers/kerninst.ps
Refering-URL: http://www.cs.wisc.edu/~paradyn/papers.html
Root-URL: http://www.cs.wisc.edu
Title: Fine-Grained Dynamic Instrumentation of Commodity Operating System Kernels  
Note: Page 1 Submitted for Publication,  
Date: July 29, 1998  July 1998  
Abstract: We have developed a technology, fine-grained dynamic instrumentation of commodity kernels, which can splice (insert) dynamically generated code before almost any machine code instruction of a completely unmodified commodity operating system kernel, as it runs. This technology is well-suited to performance profiling, debugging, code coverage, security auditing, runtime code optimizations, and kernel extensions. We have designed and implemented a tool called KernInst that performs dynamic instrumentation on a stock production Solaris 2.5.1 kernel running on an UltraSPARC. We have implemented a kernel performance profiling tool on top of KernInst, and show how it uses dynamic instrumentation to quickly identify bottlenecks in a Web proxy server. We found that 10-20% of the proxy servers time was due to the Unix file system semantics of synchronizing file changes when updating meta-data. We also found that a further 20-30% of the proxy servers time was spent translating file names when opening or creating files. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Almeida and P. Cao. </author> <title> Wisconsin Proxy Benchmark 1.0. </title> <address> http://www.cs.wisc.edu/~cao/wpb1.0.html. </address>
Reference-contexts: This unwinding is also done by Paradyn [9]. 4.2 Web Proxy Server Benchmark We used KernInst to study the performance of the Squid, a Web proxy server. We used version 1.0 of the Wisconsin Proxy Benchmark <ref> [1] </ref> running 100 client processes to drive Squid. All Squid files were stored on the local disk. KernInst was run on the same machine as Squid, an UltraSPARC 1 with 128 MB of RAM running Solaris 2.5.1.
Reference: [2] <author> J.M. Anderson, L.M. Berc, J. Dean, S. Ghemawat, M.R. Henzinger, S.-T. A. Leung, </author> <title> R.L. Sites, M.T. Vandervoorde, C.A. Waldspurger, and W.E. Weihl. Continuous Profiling: </title> <booktitle> Where Have All the Cycles Gone? 16th ACM Symp. on Operating Sys. Principles, </booktitle> <address> Saint-Malo, France, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Furthermore, with dynamic instrumentation, the overhead incurred by splicing is incurred only when it is being used. We note that KernInst is complementary to and could be used with these research kernels to provide additional splicing capabilities; see Figure 16. Digitals Continuous Profiling system (dcpi) <ref> [2] </ref> measures detailed performance metrics (such as cycles and icache misses) down to the instruction level of a commodity kernel (Digital UNIX). Unlike KernInst, dcpi does not instrument kernel code in any way. This technique simplifies some issues but precludes performance metrics that cannot be readily sampled.
Reference: [3] <author> J. Auslander, M. Philipose, C. Chambers, S.J. Eggers, and B.N. Bershad. </author> <title> Fast, Effective Dynamic Compilation. </title> <booktitle> SIGPLAN 1996 Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Thus, inserted code can only access kernel data structures and call kernel functions that have gone through the rigor of formally defining a safety policy. Combined approaches. A combination of static and dynamic checking, such as done with safe languages such as Java [7] and Modula-3 in SPIN <ref> [3] </ref>, potentially requires fewer run-time checks, but still needs a recovery strategy. Extension code can be classified by its interaction with the underlying kernel: Annotations. This code is executed in the kernel, but does not change the underlying computation.
Reference: [4] <author> B.N. Bershad, S.Savage, P. Pardyak, E. Sirer, M. Fiucynski, D. Becker, C. Chambers, and S.n Eggers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> 15th ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Security can be addressed much like safety, by verifying that formally-defined policies for all resources accessed by inserted code are respected. 6 Related Work KernInst allows arbitrary dynamically generated code to be inserted anywhere into a commodity kernels code space at runt-ime. Extensible operating systems such as SPIN <ref> [4] </ref>, Exokernel [5], and VINO [16] allow processes to download code into a kernel, but differ from our approach in two ways: they are not unmodified commodity kernels, and they restrict the number of places in the kernel where code may be inserted, and thus operate at a coarser grain.
Reference: [5] <author> D.R. Engler, M.F. Kaashoek, and J. OToole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> 15th ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Software fault isolation (SFI) techniques [21] augment the dynamic code with run-time checks to insure the code stays within a local space. VINO [16] and Exokernel <ref> [5] </ref> are two systems that use this technique. The dynamic code might be global, in common parts of the kernel and accessing data structures shared by other kernel threads. In this case, terminating the offending code may leave locks held or shared data structures in an inconsistent state. <p> Extensible operating systems such as SPIN [4], Exokernel <ref> [5] </ref>, and VINO [16] allow processes to download code into a kernel, but differ from our approach in two ways: they are not unmodified commodity kernels, and they restrict the number of places in the kernel where code may be inserted, and thus operate at a coarser grain.
Reference: [6] <author> D.R. Engler. </author> <title> VCODE: a Retargetable, Extensible, Very Fast Dynamic Code Generation System. </title> <booktitle> SIGPLAN 1996 Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: An important feature of our dynamic instrumentation is that splicing is independent of code generation. Kerninstd can splice machine code that has been created from code generation packages such as VCODE <ref> [6] </ref>, an interpreter performing just-in-time compilation, or from precompiled position-independent code. The structure of the KernInst system is shown in Figure 1. <p> The VCODE code generator <ref> [6] </ref> fits this model well, but many interpreters and runtime compilers do not. Statically generated position-independent code can also be used for instrumentation; at runtime, kerninstd resolves procedure calls, and brackets the code with register spills to ensure that no free registers are overwritten.
Reference: [7] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environment. </title> <address> http://java.sun.com/docs/white/langenv/index.html. </address>
Reference-contexts: Thus, inserted code can only access kernel data structures and call kernel functions that have gone through the rigor of formally defining a safety policy. Combined approaches. A combination of static and dynamic checking, such as done with safe languages such as Java <ref> [7] </ref> and Modula-3 in SPIN [3], potentially requires fewer run-time checks, but still needs a recovery strategy. Extension code can be classified by its interaction with the underlying kernel: Annotations. This code is executed in the kernel, but does not change the underlying computation.
Reference: [8] <author> J.K. Hollingsworth, B.P. Miller and J. Cargille. </author> <title> Dynamic Program Instrumentation for Scalable Performance Tools, </title> <booktitle> Scalable High Performance Computing Conference, </booktitle> <address> Knoxville, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: If a hazard is detected, then splicing is deferred (and retried later). This strategy is currently used in the Paradyn instrumentation system for user programs <ref> [8, 9] </ref>. However, it does not work in a kernel, for several reasons. First, pausing the kernel it is not allowed; even if it were, this would involve freezing all of the kernel threads (except, presumably, for the kerninstd thread, which is performing the splice), possibly disrupting critical background activities.
Reference: [9] <author> J.K. Hollingsworth, B.P. Miller, M.J.R. Gonalves, O. Naim, Z. Xu and L. Zheng. </author> <title> MDL: A Language and Compiler for Dynamic Program Instrumentation. </title> <booktitle> International Conference on Parallel Architectures and Compilation Techniques, </booktitle> <address> San Francisco, CA. </address> <month> Nov., </month> <year> 1997. </year>
Reference-contexts: If a hazard is detected, then splicing is deferred (and retried later). This strategy is currently used in the Paradyn instrumentation system for user programs <ref> [8, 9] </ref>. However, it does not work in a kernel, for several reasons. First, pausing the kernel it is not allowed; even if it were, this would involve freezing all of the kernel threads (except, presumably, for the kerninstd thread, which is performing the splice), possibly disrupting critical background activities. <p> To instrument at the exit point of B, KernInst first splices in a code sequence that de-optimizes the tail call sequence. This unwinding is also done by Paradyn <ref> [9] </ref>. 4.2 Web Proxy Server Benchmark We used KernInst to study the performance of the Squid, a Web proxy server. We used version 1.0 of the Wisconsin Proxy Benchmark [1] running 100 client processes to drive Squid. All Squid files were stored on the local disk. <p> Again, KernInst could be used in concert with continuous profiling to provide access to a great range of performance data. Paradyn <ref> [9] </ref> performs dynamic instrumentation of user programs.
Reference: [10] <author> G. H. Kuenning. </author> <title> Precise Interactive Measurement of Operating Systems Kernels, </title> <journal> SoftwarePractice & Experience 25, </journal> <month> 1 (January </month> <year> 1995). </year>
Reference-contexts: Using dynamic instrumentation allows the user to refine what is of interest at runtime. Kitrace <ref> [10] </ref> is a tool for tracing kernel code locations. It replaces instructions being traced with a trap, which transfers control to a custom handler. This handler appends an entry to the trace log, and resumes execution. Because trap instructions can be inserted at most kernel instructions, kitrace is fine-grained.
Reference: [11] <author> J.R. Larus and E. Schnarr. EEL: </author> <title> Machine-Independent Executable Editing. </title> <booktitle> ACM SIGPLAN 95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> La Jolla, CA. </address> <month> June, </month> <year> 1995. </year>
Reference-contexts: Other register-relative jumps are marked as unanalyzable. KernInsts control-ow graph construction is similar to that done by static binary rewriters for user programs, such as EEL <ref> [11] </ref> and ATOM [19]. However, since KernInst performs its processing at runtime, all code is available, including runtime-loaded modules. Furthermore, since our control-ow graph is interprocedural, more aggressive data-ow analyses are possible. Next, kerninstd performs an interprocedural live register analysis of the kernel code. <p> Static binary rewriters such as EEL <ref> [11] </ref> and ATOM [19] are fine-grained and allow arbitrary code to be inserted into user programs (and potentially to kernels). However, static rewriting requires the program to be taken off-line, instrumented, and then run. Applied to a kernel, this would require a system reboot.
Reference: [12] <author> D. Mosberger, L.L. Peterson, P.G. Bridges, and S. OMalley. </author> <title> Analysis of Techniques to Improve Protocol Processing Latency. </title> <booktitle> ACM SIGCOMM 96, </booktitle> <address> Stanford, CA. </address> <month> Aug., </month> <year> 1996. </year>
Reference-contexts: If so, the call site is altered to directly call the optimized version of the function. Outlining seldom-executed basic blocks to improve instruction-cache behavior <ref> [12] </ref> can be performed using fine-grained dynamic instrumentation. A functions entry and exit point (s) can be annotated to measure the number of icache misses it incurs. If the value is high, the functions basic blocks can be instrumented to count execution frequency. <p> Adaptations. The goal of an adaptation is to change the behavior of the underlying system in some way. For example, we may want to apply on-the-y fine- or coarse-grained optimizations (such as specialization [15] or outlining <ref> [12] </ref>) to the system. An adaptation may take some part of the kernel and replace it with code that accomplishes the same task, but in a more efficient or reliable manner. We are currently developing the mechanisms for closed-looped dynamic measurement and optimization.
Reference: [13] <author> G.C. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without Run-Time Checking. </title> <booktitle> 2nd USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Statically safe code. Code that can be identified statically as safe has two advantages. First, the code is potentially more efficient since no run-time checks are needed. Second, since the code can never misbehave, no recovery scheme is needed. Proof carrying code (PCC) <ref> [13] </ref> is an example of this approach. However, PCC requires a safety policy to be formally defined for all resources accessed by the extension. Thus, inserted code can only access kernel data structures and call kernel functions that have gone through the rigor of formally defining a safety policy. <p> We define a conservative annotation to be one that may only write to the annotations local data, does not transfer control outside of the annotations code, and is bounded in its time and resource requirements. These restrictions are similar to the ones used in downloaded packet filters <ref> [13] </ref>. Even with these restrictions, many useful tasks can still be accomplished. The semantics of SFI checks are relatively easy to define, and recovery actions for SFI are simple.
Reference: [14] <author> G.C. Necula and P. Lee. </author> <title> The Design and Implementation of a Certifying Compiler. </title> <booktitle> 1998 SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Specifying safe semantics for open annotations requires a specification of the semantics of kernel routines that are used in the dynamic code <ref> [14] </ref>. We plan on designing specifications that cover common synchronization scenarios. Recovery in a commodity operating system after an open annotation fault is an area we are actively researching. Adaptations. The goal of an adaptation is to change the behavior of the underlying system in some way.
Reference: [15] <author> C. Pu, T. Audrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System. </title> <booktitle> 15th ACM Symposium on Operating Sys. Principles, </booktitle> <address> Copper Mountain, CO. </address> <month> Dec., </month> <year> 1995. </year>
Reference-contexts: Recently, extensible kernels, such as SPIN, Exokernel, and VINO, have been designed to allow applications to extend functionality and specify kernel policies [4,5,16]. Synthetix allows specialized versions of certain kernel functions to be installed at runtime, providing dynamic optimization <ref> [15] </ref>. A design has even been proposed for a self-measuring and self-adapting extensible kernel [17]. All of the above work has been performed on customized kernels, so it is difficult to evaluate or use with real-world programs and workloads. <p> Fine-grained. Instrumentation points (locations where code can be spliced) can be almost any machine code instruction in the kernel (the few exceptions are discussed in Section 3.3 and Section 3.4.1). This contrasts with kernels that allow coarser-grained code changes such as at function granularity (e.g., VINO [16] or Synthetix <ref> [15] </ref>), or only allow entire kernel modules to be changed (which many commodity kernels allow). Runs on a commodity kernel. This allows us to immediately run real-world programs. <p> Note that this requires a fine-grained splicing mechanism, since auditing checks often take place in the middle of specific kernel functions. Dynamic instrumentation enables automated runtime code optimization, based on performance feedback gathered by dynamic profiling annotations. One example is automated runtime function specialization <ref> [15] </ref> based on an input parameter. A function can be dynamically instrumented at its entry point to add the desired parameter to a histogram, which is later examined for a frequent value. <p> Adaptations. The goal of an adaptation is to change the behavior of the underlying system in some way. For example, we may want to apply on-the-y fine- or coarse-grained optimizations (such as specialization <ref> [15] </ref> or outlining [12]) to the system. An adaptation may take some part of the kernel and replace it with code that accomplishes the same task, but in a more efficient or reliable manner. We are currently developing the mechanisms for closed-looped dynamic measurement and optimization. <p> VINO, for example, allows C++ classes to specify methods that can be customized on an per-object basis [18]. Thus, where it allows code to be made process-specific, it has whole-function granularity. Third, the limited number of instrumentation points are pre-coded in a way that allows easy instrumentation. In Synthetix <ref> [15] </ref>, a function pointer is loaded and jumped to at each instrumentation point, providing a level of call indirection. Specialized versions are then installed by writing to the function pointer. Requiring special code where process-specific customization might take place incurs a small overhead on methods that are not customized.
Reference: [16] <author> M.I. Seltzer, Y. Endo, C. Small, and K.A. Smith. </author> <title> Dealing With Disaster: Surviving Misbehaved Kernel Extensions. </title> <booktitle> 2nd USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Fine-grained. Instrumentation points (locations where code can be spliced) can be almost any machine code instruction in the kernel (the few exceptions are discussed in Section 3.3 and Section 3.4.1). This contrasts with kernels that allow coarser-grained code changes such as at function granularity (e.g., VINO <ref> [16] </ref> or Synthetix [15]), or only allow entire kernel modules to be changed (which many commodity kernels allow). Runs on a commodity kernel. This allows us to immediately run real-world programs. <p> Software fault isolation (SFI) techniques [21] augment the dynamic code with run-time checks to insure the code stays within a local space. VINO <ref> [16] </ref> and Exokernel [5] are two systems that use this technique. The dynamic code might be global, in common parts of the kernel and accessing data structures shared by other kernel threads. <p> Extensible operating systems such as SPIN [4], Exokernel [5], and VINO <ref> [16] </ref> allow processes to download code into a kernel, but differ from our approach in two ways: they are not unmodified commodity kernels, and they restrict the number of places in the kernel where code may be inserted, and thus operate at a coarser grain.
Reference: [17] <author> M.I. Seltzer and C. </author> <title> Small. Self-monitoring and Self-adapting Operating Systems. </title> <booktitle> 6th Workshop on Hot Topics in Operating Systems. </booktitle>
Reference-contexts: Synthetix allows specialized versions of certain kernel functions to be installed at runtime, providing dynamic optimization [15]. A design has even been proposed for a self-measuring and self-adapting extensible kernel <ref> [17] </ref>. All of the above work has been performed on customized kernels, so it is difficult to evaluate or use with real-world programs and workloads.
Reference: [18] <author> C. </author> <title> Small. A Tool for Constructing Safe Extensible C++ Systems. </title> <booktitle> 4th USENIX Conference on Object-Oriented Technologies and Systems (COOTS), </booktitle> <address> Santa Fe, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: VINO, for example, allows C++ classes to specify methods that can be customized on an per-object basis <ref> [18] </ref>. Thus, where it allows code to be made process-specific, it has whole-function granularity. Third, the limited number of instrumentation points are pre-coded in a way that allows easy instrumentation.
Reference: [19] <author> A. Srivastava and A. Eustace. </author> <title> ATOM: A System for Building Customized Program Analysis Tools. </title> <booktitle> SIGPLAN 1994 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Other register-relative jumps are marked as unanalyzable. KernInsts control-ow graph construction is similar to that done by static binary rewriters for user programs, such as EEL [11] and ATOM <ref> [19] </ref>. However, since KernInst performs its processing at runtime, all code is available, including runtime-loaded modules. Furthermore, since our control-ow graph is interprocedural, more aggressive data-ow analyses are possible. Next, kerninstd performs an interprocedural live register analysis of the kernel code. <p> Static binary rewriters such as EEL [11] and ATOM <ref> [19] </ref> are fine-grained and allow arbitrary code to be inserted into user programs (and potentially to kernels). However, static rewriting requires the program to be taken off-line, instrumented, and then run. Applied to a kernel, this would require a system reboot.
Reference: [20] <institution> U.S. Dept. of Defense. Department of Defense Trusted Computer System Evaluation Criteria. TCSEC DOD 5200.28-STD, </institution> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Instrumentation for a basic block can be removed as soon as the ag is set; thus, the expense of code coverage actually decreases over time. Basic block coverage demonstrates the need for instrumentation to be fine-grained. Security checks such as DoD C2-level auditing <ref> [20] </ref> are another form of annotation that can be installed using dynamic instrumentation.
Reference: [21] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> 14th ACM Symp. on Op. Sys. Principles, </booktitle> <month> Dec </month> <year> 1993. </year>
Reference-contexts: If the dynamic code is local, executing on behalf of a single user or process and not modifying any shared kernel data structures, then exiting the dynamic code is sufficient. Software fault isolation (SFI) techniques <ref> [21] </ref> augment the dynamic code with run-time checks to insure the code stays within a local space. VINO [16] and Exokernel [5] are two systems that use this technique. The dynamic code might be global, in common parts of the kernel and accessing data structures shared by other kernel threads.
References-found: 21

