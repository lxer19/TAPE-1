URL: http://www.cs.utah.edu/~ratan/papers/fmppta98.ps.gz
Refering-URL: http://www.cs.utah.edu/~ratan/res.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu,  
Title: Deriving Efficient Cache Coherence Protocols through Refinement  
Author: Ratan Nalumasu and Ganesh Gopalakrishnan 
Web: WWW page: http://www.cs.utah.edu/fratan,ganeshg  
Address: Salt Lake City, UT 84112, USA,  
Affiliation: University of Utah,  
Abstract: We address the problem of developing efficient cache coherence protocols implementing distributed shared memory (DSM) using message passing. A serious drawback of traditional approaches to this problem is that designers are required to state the desired coherence protocol at the level of asynchronous message interactions. We propose a method in which designers express the desired protocol at a high-level using rendezvous communication. These descriptions are much easier to understand and computationally more efficient to verify than asynchronous protocols due to their small state spaces. The rendezvous protocol can also be synthesized into efficient asynchronous protocols. We present our protocol refinement procedure, prove its soundness, and provide examples of its efficiency.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM TOPLAS, </journal> <volume> 5(2):223235, </volume> <month> April </month> <year> 1983. </year>
Reference-contexts: In contrast, in our approach, user writes the rendezvous protocol using only the rendezvous primitive, verifies the protocol at this level with great efficiency and compiles it into an efficient asynchronous protocol or object code. Our work closely resembles that of Buckley and Silberschatz <ref> [1] </ref>. Buckley and Sil-berschatz consider the problem of implementing rendezvous using message passing when the processes use generalized input/output guard to be implemented in software. Their solution is too expensive for DSM protocol implementations.
Reference: 2. <author> J. B. Carter, C. Kuo, and R. Kuramkote. </author> <title> A comparison of software and hardware synchronization mechanisms for distributed shared memory multiprocessors. </title> <type> Technical Report UUCS-96-011, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: We empirically show that the rendezvous protocols are several orders of magnitude more efficient to model-check than their corresponding detailed implementations. In addition, we also show that in the context of a state of the art DSM machine project called the Avalanche <ref> [2] </ref>, our procedure can automatically produce protocol implementations that are comparable in quality to hand-designed asynchronous protocols, where quality is measured in terms of (1) the number of request, acknowledge, and negative acknowledge (nack) messages needed for carrying out the rendezvous specified in the given specification, and (2) the buffering requirements <p> This assumption is justified in many machines, e.g., DASH [14], and Avalanche <ref> [2] </ref>. We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock.
Reference: 3. <author> S. Chandra, B. Richards, and J. R. Larus. Teapot: </author> <title> Language support for writing memory coherency protocols. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Section 5 presents an example protocol developed using the refinement rules, and the efficiency of model-checking the rendezvous protocol compared to the efficiency of model-checking the asynchronous protocol. Finally, Section 6 presents a discussion of buffering requirements and concludes the paper. Related Work Chandra et al <ref> [3] </ref> use a model based on continuations to help reduce the complexity of specifying the coherency protocols. The specification can then be model checked and compiled into an efficient object code.
Reference: 4. <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Their solution is too expensive for DSM protocol implementations. In contrast, we focus on a star configuration of processes with suitable syntactic restrictions on the high level specification language, so that an efficient asynchronous protocol can be automat-ically generated. Chandy and Misra <ref> [4] </ref> showed that under a strict condition called asynchrony, shared variables can be implemented by message passing. Unfortunately, this condition is not met in many practical protocols.
Reference: 5. <author> Cray Research, Inc. </author> <title> CRAY T3D System Architecture Overview, </title> <address> hr-04033 edition, </address> <month> September </month> <year> 1993. </year>
Reference: 6. <author> D. Dill, A.J. Drexler, A.J. Hu, and C.H. Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In ICCD, </booktitle> <pages> pages 522525, </pages> <year> 1992. </year>
Reference-contexts: Difficulty of designing these protocols is compounded by the fact that verifying such low-level descriptions invites state explosion (when done using model-checking <ref> [6, 7] </ref>) or tedious (when done using theorem-proving [18]) even for simple configurations. Often these low-level descriptions are model-checked for specific resource allocations (e.g. buffer sizes); it is often not known what would happen when these allocations are changed.
Reference: 7. <author> A. Th. Eiriksson and K. McMillan. </author> <title> Using formal verification/analysis methods on the critical path in system design: A case study. </title> <booktitle> In CAV, </booktitle> <pages> pages 367380, </pages> <address> 1995. </address> <publisher> Springer LNCS 939. </publisher>
Reference-contexts: Difficulty of designing these protocols is compounded by the fact that verifying such low-level descriptions invites state explosion (when done using model-checking <ref> [6, 7] </ref>) or tedious (when done using theorem-proving [18]) even for simple configurations. Often these low-level descriptions are model-checked for specific resource allocations (e.g. buffer sizes); it is often not known what would happen when these allocations are changed.
Reference: 8. <author> E. P. </author> <title> Gribo mont. From synchronous to asynchronous communication. </title> <editor> In C. Rattay, editor, </editor> <booktitle> Specification and Verification of Concurrent Systems, </booktitle> <pages> pages 368383. </pages> <institution> Springer-Verilog, University of Stirling, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: Chandy and Misra [4] showed that under a strict condition called asynchrony, shared variables can be implemented by message passing. Unfortunately, this condition is not met in many practical protocols. Gribo mont <ref> [8] </ref> explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication.
Reference: 9. <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Apporach. </title> <publisher> Mor-gan Kaufmann, </publisher> <year> 1996. </year> <note> Second Edition, Appendix E. </note>
Reference-contexts: DSM systems have been widely researched as the next logical step in parallel processing [2,5,12,14]. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing <ref> [9] </ref>. The present-day approach to this problem consists of specifying the detailed interactions possible between the nodes in terms of low-level requests, acknowledges, negative acknowledges, and dealing with unexpected messages. <p> We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock. If the assumption is not satisfied, then the solution proposed by Hennessy and Patterson in <ref> [9] </ref> can be used as a post-processing step of the refined protocol. They divide the messages into two categories: request and acknowledge. A request message may cause the recipient to generate more messages in order to complete the transactions, while an acknowledge message does not.
Reference: 10. <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM, </journal> <volume> 21(8):666677, </volume> <year> 1978. </year>
Reference-contexts: Instead, what gets written down as the highest level specification is a detailed protocol implementation which was arrived at through ad hoc reasoning of the situations that can arise. In this paper, we choose CSP <ref> [10] </ref> as our specification language to allow the designers to capture their initial atomic-transaction view (rendezvous protocol). The rendezvous protocol is then subjected to syntax-directed translation rules to modify the rendezvous communication primitives of CSP into asynchronous communication primitives yielding an efficient detailed implementation (asynchronous protocol). <p> As we shall see in Section 3, asynchronous protocol has two acknowledge messages: ack and nack. We use rendezvous communication primitives of CSP <ref> [10] </ref> to specify the home node and the remote nodes to simplify the DSM protocol design.
Reference: 11. <author> G. J. Holzmann and D. Peled. </author> <title> The state of SPIN. </title> <booktitle> In CAV, </booktitle> <pages> pages 385389, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Verification: As can be expected, verification of the rendezvous protocols is much simpler than verification the asynchronous protocols. We model-checked the rendezvous and asynchronous versions of the migratory protocol above and invalidate, another DSM protocol used in Avalanche, using the SPIN <ref> [11] </ref>. The number of states visited and time taken in seconds on these two protocols are shown in Figure 3 (c). The complexity of verifying the hand designed migratory or invalidate is comparable to the verification of asynchronous protocol.
Reference: 12. <author> J. Kuskin and D. Ofelt et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 302313, </pages> <month> May </month> <year> 1994. </year>
Reference: 13. <author> L. Lamport and F. B. Schneider. </author> <note> Pretending atomicity. In Research Report 44, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Gribo mont [8] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider <ref> [13] </ref> have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers [15], but have not considered specific refinement rules. 2 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the coherency of each line
Reference: 14. <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.-D. Weber, A. Gupta, J. Hennessy, M. Horowitz, and M. S. Lam. </author> <title> The Stanford DASH multiprocessor. </title> <journal> IEEE Computer, </journal> <volume> 25(3):6379, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: This assumption is justified in many machines, e.g., DASH <ref> [14] </ref>, and Avalanche [2]. We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock.
Reference: 15. <author> R. J. Lipton. </author> <title> Reduction: A method of proving properties of parallel programs. </title> <journal> CACM, </journal> <volume> 18(12):717721, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider [13] have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers <ref> [15] </ref>, but have not considered specific refinement rules. 2 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the coherency of each line of shared memory is managed by a CPU node, called home node, or simply home 1 .
Reference: 16. <author> A. Nowatzyk, G. Aybay, M. Browne, E. Kelly, M. Parkin, B. Radke, and S. Vishin. </author> <title> The S3.mp scalable shared memory multiprocessor. </title> <booktitle> In Proceedings of the 1995 International Conference on Parallel Processing, </booktitle> <year> 1995. </year>
Reference-contexts: However, virtually all modern processors have a bounded instruction issue window. Using this property, and the observation that the protocol actions of a line do not interfere with each other (as in the case of the DSM controller in <ref> [16] </ref>), one can show that forward progress is guaranteed per each line as well as each remote node.
Reference: 17. <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <booktitle> In CAV, </booktitle> <pages> pages 411414, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: Section 3 presents our syntax-directed translation rules, along with an important optimization called request/reply. Section 4 presents an informal argument that the refinement rules we present always produce correct result, and also points to a formal proof of correctness done using PVS <ref> [17] </ref>. Section 5 presents an example protocol developed using the refinement rules, and the efficiency of model-checking the rendezvous protocol compared to the efficiency of model-checking the asynchronous protocol. Finally, Section 6 presents a discussion of buffering requirements and concludes the paper. <p> An ack is generated only in case 2 which completes a rendezvous in asynchronous protocol. This rendezvous is also allowed by the rendezvous protocol. We formalized above argument in PVS <ref> [17] </ref> and proved that the refinement rules are safety preserving; i.e., we showed that if the a transition is taken in the refined protocol, then it is allowed in the original rendezvous protocol.
Reference: 18. <author> S. Park and D. L. Dill. </author> <title> Protocol verification by aggregation of distributed transactions. </title> <booktitle> In CAV, </booktitle> <pages> pages 300309, </pages> <address> New Brunswick, NJ, USA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Difficulty of designing these protocols is compounded by the fact that verifying such low-level descriptions invites state explosion (when done using model-checking [6, 7]) or tedious (when done using theorem-proving <ref> [18] </ref>) even for simple configurations. Often these low-level descriptions are model-checked for specific resource allocations (e.g. buffer sizes); it is often not known what would happen when these allocations are changed. <p> We formalized above argument in PVS [17] and proved that the refinement rules are safety preserving; i.e., we showed that if the a transition is taken in the refined protocol, then it is allowed in the original rendezvous protocol. We constructed an abstraction function, abs , based on <ref> [18] </ref>. abs maps a state in the asynchronous protocol to a state in the rendezvous protocol, and showing that for every sequence of states in the asynchronous protocol, there is an equivalent sequence of states in the rendezvous protocol.
References-found: 18

