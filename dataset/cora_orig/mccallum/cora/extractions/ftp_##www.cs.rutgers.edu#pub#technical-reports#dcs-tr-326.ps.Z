URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-326.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: framkrish,ryderg@cs.rutgers.edu  
Title: Scalable, flow-sensitive type inference for statically typed object-oriented languages  
Author: Ramkrishna Chatterjee Barbara Ryder 
Date: August 4, 1997  
Address: USA  
Affiliation: Department of Computer Science Rutgers University,  
Pubnum: DCS-TR-326  
Abstract-found: 0
Intro-found: 1
Reference: [ASU86] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The exit node is assumed to use all types in localTypesEl (P) and the extType. Using these assumptions, intraprocedural equations for def-use associations <ref> [ASU86] </ref> for types are solved using an iterative worklist algorithm, where each statement (including call nodes) kills previous definitions of types which it defines. 5.4 Complexity of preprocessing In this subsection we analyze the complexity of the algorithm for preprocessing.
Reference: [BS96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast static analysis of c++ virtual function calls. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: Call graph CG is constructed. All virtual function calls are resolved using hierarchy analysis [DMM96] and by considering only instantiated types as in Bacon and Sweeney's algorithm <ref> [BS96] </ref>. Calls through function pointers can also be resolved by only considering those functions whose addresses have been stored in a function pointer and whose signatures are compatible with the type of the function pointer through which the call has been made. 2.
Reference: [CLR92] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to algorithms. </title> <publisher> The MIT Press and McGraw-Hill Book Company, </publisher> <year> 1992. </year>
Reference-contexts: Directed acyclic graph SCCG of strongly connected components of CG is constructed. This can be done in linear time <ref> [CLR92] </ref>. 3. Types referenced and modified by each procedure/method are computed.
Reference: [DMM96] <author> Amer Diwan, J.Eliot B. Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically-typed object-oriented programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: This will become clear when we describe demand-driven computation in section 5.5. 5.3 Algorithm for Preprocessing using Types Preprocessing consists of the following steps: 1. Call graph CG is constructed. All virtual function calls are resolved using hierarchy analysis <ref> [DMM96] </ref> and by considering only instantiated types as in Bacon and Sweeney's algorithm [BS96].
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Effective use of such context insensitive information can increase both precision and efficiency as we shall see later. 3 Basic Algorithm for Type Inference using Points-To 3.1 Motivation for points-to Type inference, as defined in section 1, is essentially the points-to relation <ref> [EGH94] </ref>. So it is natural to compute points-to directly instead of obtaining this as a subset of alias solution [PR96] .
Reference: [JM79] <author> Jones and Muchnick. </author> <title> In Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 119-120. </pages> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: param ) - data = param; - Object V; f1 () - l1: p1 = new base; s1: p1-&gt;update ( &V ); t1: ... ... ln: pn = new base; sn: pn-&gt;update ( &V ); 1 k-limiting is a standard technique for approximating names in a priori unbounded heap structures <ref> [JM79] </ref> 3 tn: Suppose only one assumed-alias is used for representing context. Without loss of generality let this be h param,V i for the aliases h obj li.data, V i, where obj li represents the object created at location li.
Reference: [Lan92] <author> W. A. Landi. </author> <title> Interprocedural aliasing in the presence of pointers, </title> <type> phd thesis. Technical Report LCSR-TR-174, </type> <institution> Dept of CS, Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: Moreover, as shown by Bill Landi in his thesis <ref> [Lan92] </ref>, alias analysis has quadratic error propagation : a single spurious alias can give rise to O (n 2 ) spurious aliases at a program point. 2.
Reference: [LR91] <author> W.A. Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: This is the essence of the second technique - analysis-using-abstract-values. In the following sections, we first present an algorithm for points-to analysis using abstract values in the presence of only single-level <ref> [LR91] </ref> pointers and then show how to extend it for multi-level pointers.
Reference: [LR92] <author> W.A. Landi and Barbara G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1992. </year> <month> 40 </month>
Reference-contexts: In the following section we introduce our basic algorithm which can answer each of these three queries. 3.4 Outline of the Basic Algorithm Our basic algorithm for concrete type inference is an iterative worklist algorithm similar to Landi-Ryder algorithm <ref> [LR92] </ref> for alias analysis, but instead of aliases, points-tos are computed. <p> Again, if some approximation of the call stack is used to classify objects, n is replaced by it. In order to restrict data-flow only to realizable paths <ref> [LR92] </ref> , points-tos are computed conditioned on assumed points-tos ( akin to assumed alias in [LR92] [PR96] ), which represent points-tos reaching the entry of a procedure, and approximate the context in which the procedure has been called. <p> Again, if some approximation of the call stack is used to classify objects, n is replaced by it. In order to restrict data-flow only to realizable paths <ref> [LR92] </ref> , points-tos are computed conditioned on assumed points-tos ( akin to assumed alias in [LR92] [PR96] ), which represent points-tos reaching the entry of a procedure, and approximate the context in which the procedure has been called. We will refer to such points-tos as conditional points-tos in the rest of this paper. <p> Next we describe two other important aspects of this algorithm: how objects created at the same program point are distinguished and how hold-together relation is computed. 2 An invisible is a local variable of a caller, which is not syntactically visible inside a called procedure <ref> [LR92] </ref>. 3 We represent all the locations in an array using a single location. 5 3.4.1 Context for Objects In object-oriented programs the number of sites at which objects are created is relatively small compared to the size of the programs. <p> This makes this approach more scalable than the basic algorithm. Moreover, this bottom-up inference facilitates modular analysis as shown earlier. Note that if more than one condition is associated with a points-to, all of them are stored with the points-to. This is in contrast to the Landi-Ryder algorithm <ref> [LR92] </ref> which stores only one such condition (without affecting the safety of the solution). 8.2 Virtual function calls and calls through function pointers Virtual function calls and calls through function pointers can be handled as shown below. int i,j; int* x = NULL; class A - public: virtual void foo (void)
Reference: [LRZ93] <author> W.A. Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: We don't need to know whether the object pointed to was created at n1 or n2. On the other hand, if we are interested in finding the side-effects <ref> [LRZ93] </ref> of a statement, a different definition of concrete types is needed. For example, n4 modifies the data field of the object created at n2 and not the one created at n1.
Reference: [PR96] <author> Hemant Pande and Barbara G. Ryder. </author> <title> Data-flow-based virtual function resolution. </title> <booktitle> In LNCS 1145, Proceedings of the Third International Symposium on Static Analysis, </booktitle> <year> 1996. </year>
Reference-contexts: virtual void foo (void); -; class B: public A - public: void foo (void); -; func () - n1: ptr = new B; . n2: ptr = new B; n4: ptr-&gt;data = 1; - - func (); - - func (); - If we are interested in virtual function resolution <ref> [PR96] </ref> (i.e., whether a virtual function call can be statically resolved to remove the run-time overhead of dynamic dispatch), it is enough to know the class of an object pointed to by a pointer. <p> Finally, we conclude by summarizing the main contributions of this paper. 2 Drawbacks of type inference through alias analysis One of the approaches to type inference for C ++ is to do alias analysis as shown by Pande and Ryder <ref> [PR96] </ref>. They present a flow-sensitive algorithm which stores the context for interprocedural analysis using a single assumed alias an alias which holds at the entry of a procedure and approximately represents the context in which the procedure has been called. <p> So it is natural to compute points-to directly instead of obtaining this as a subset of alias solution <ref> [PR96] </ref> . <p> Again, if some approximation of the call stack is used to classify objects, n is replaced by it. In order to restrict data-flow only to realizable paths [LR92] , points-tos are computed conditioned on assumed points-tos ( akin to assumed alias in [LR92] <ref> [PR96] </ref> ), which represent points-tos reaching the entry of a procedure, and approximate the context in which the procedure has been called. We will refer to such points-tos as conditional points-tos in the rest of this paper.
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reacha-bility. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year> <month> 41 </month>
Reference-contexts: Similarly, using induction on the length of a balanced path 6 i.e., along which each entry node has a matching exit node except possibly for the initial entry node of P; this corresponds to the notion of balanced path in <ref> [RHS95] </ref> 23 associated with a points-to in the precise solution, we can show that the precise solution is a subset of the solution computed by phase I. Hence phase I computes the precise solution. A precise solution for phase II is defined as follows.
References-found: 12

