URL: http://www-cad.eecs.berkeley.edu/~orna/publications/cav97.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: orna@eecs.berkeley.edu  Email: vardi@cs.rice.edu,  
Phone: 2  
Title: Module Checking Revisited  
Author: Orna Kupferman ?? and Moshe Y. Vardi ??? 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: Berkeley, Berkeley CA 94720-1770, U.S.A.  Houston, TX 77251-1892, U.S.A.  
Affiliation: 1 EECS Department, UC  Rice University, Department of Computer Science,  
Abstract: When we verify the correctness of an open system with respect to a desired requirement, we should take into consideration the different environments with which the system may interact. Each environment induces a different behavior of the system, and we want all these behaviors to satisfy the requirement. Module checking is an algorithmic method that checks, given an open system (modeled as a finite structure) and a desired requirement (specified by a temporal-logic formula), whether the open system satisfies the requirement with respect to all environments. In this paper we extend the module-checking method with respect to two orthogonal issues. Both issues concern the fact that often we are not interested in satisfaction of the requirement with respect to all environments, but only with respect to these that meet some restriction. We consider the case where the environment has incomplete information about the system; i.e., when the system has internal variables, which are not readable by its environment, and the case where some assumptions are known about environment; i.e., when the system is guaranteed to satisfy the requirement only when its environment satisfies certain assumptions. We study the complexities of the extended module-checking problems. In particular, we show that for universal temporal logics (e.g., LTL, 8CTL, and 8CTL ? ), module checking with incomplete information coincides with module checking, which by itself coincides with model checking. On the other hand, for non-universal temporal logics (e.g., CTL and CTL ? ), module checking with incomplete information is harder than module checking, which is by itself harder than model checking.
Abstract-found: 1
Intro-found: 1
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th CAV, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 142-155, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Essentially, the automaton A M; is similar to the product alternating tree automaton obtained in the alternating-automata theoretic framework for CTL model checking <ref> [BVW94] </ref>. There, as there is a single computation tree with respect to which the formula is checked, the automaton obtained is a 1-letter automaton. <p> Also, as the transition associated with a state hw; '; mi depends on the successors of w, we have that jffij = O (jRj fl j j). Finally, jffj jQj, and we are done. ut Extending the alternating automata described in <ref> [BVW94] </ref> to handle incomplete information is possible thanks to the special structure of the automata, which alternate between universal and existential modes. This structure (the hesitation condition, as called in [BVW94]) exists also in automata associated with CTL ? formulas, and imply the following analogous theorem. Theorem 5. <p> Finally, jffj jQj, and we are done. ut Extending the alternating automata described in <ref> [BVW94] </ref> to handle incomplete information is possible thanks to the special structure of the automata, which alternate between universal and existential modes. This structure (the hesitation condition, as called in [BVW94]) exists also in automata associated with CTL ? formulas, and imply the following analogous theorem. Theorem 5.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. LP, </booktitle> <volume> LNCS 131, </volume> <pages> pp. 52-71, </pages> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal-logic properties of finite-state systems <ref> [CE81, QS81, LP85, CES86] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state systems, as well as from the great ease of use of fully algorithmic methods. We distinguish between two types of temporal logics: universal and non-universal.
Reference: [CGB86] <author> E.M. Clarke, O. Grumberg, and M.C. Browne. </author> <title> Reasoning about networks with many identical finite-state processes. </title> <booktitle> In Proc. 5th PODC, </booktitle> <pages> pp. 240-248, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: In both cases, the more behaviors the system has, the harder it is for the system to satisfy the requirements. Indeed, universal temporal logics induce the simulation order between systems <ref> [Mil71, CGB86] </ref>. That is, a system M simulates a system M 0 if and only if all universal temporal logic formulas that are satisfied in M 0 are satisfied in M as well.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM TPLS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal-logic properties of finite-state systems <ref> [CE81, QS81, LP85, CES86] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state systems, as well as from the great ease of use of fully algorithmic methods. We distinguish between two types of temporal logics: universal and non-universal.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th FOCS, </booktitle> <pages> pp. 368-377, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: By [VW86, MS95], checking the nonemptiness of A M;: is then exponential in the sizes of M and . When is a CTL ? formula, the automaton A M;: is an alternating Rabin automaton, with jW j fl 2 O (j j) states and two pairs. Accordingly, by <ref> [EJ88, MS95] </ref>, checking the nonemptiness of A M;: is exponential in jW j and double exponential in j j. ut By Lemma 2, the bounds above hold also for the problem of assume-guarantee module checking with incomplete information.
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, Hawaii, </booktitle> <year> 1985. </year>
Reference-contexts: The alternating-automata-theoretic approach to CTL and CTL ? model checking is extended in [KV95] to handle Fair-CTL and Fair-CTL ? <ref> [EL85] </ref>. Using the same extension, we can handle here modules augmented with fairness conditions. We now consider the complexity bounds that follow from our algorithm. Theorem 6. The module-checking problem with incomplete information is EXPTIME-complete for CTL and is 2EXPTIME-complete for CTL ? .
Reference: [Eme85] <author> E.A. Emerson. </author> <title> Automata, tableaux, and temporal logics. </title> <booktitle> In Proc. LP, </booktitle> <volume> LNCS 193, </volume> <pages> pp. 79-87, </pages> <year> 1985. </year>
Reference-contexts: A3. M j= r iff no composition M &lt; E satisfies : , thus iff the intersection of A M and A : is empty. The reduction of the module-checking problem to the emptiness problem for tree automata implies, by the finite-model property of tree automata <ref> [Eme85] </ref>, that defining reactive satisfaction with respect to only finite-state environments is equivalent to the current definition. In the presence of incomplete information, not all possible pruning of hT M ; V M i correspond to compositions of M with some E .
Reference: [FZ88] <author> M.J. Fischer and L.D. Zuck. </author> <title> Reasoning about uncertainty in fault-tolerant distributed systems. </title> <booktitle> In Proc. Formal Techniques in Real-Time and Fault-Tolerant Sys., </booktitle> <volume> LNCS 331, </volume> <pages> pp. 142-158, </pages> <year> 1988. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. In order to check whether an open system satisfies a required property, we should check the behavior of the system with respect to any environment, and often there is much uncertainty regarding the environment <ref> [FZ88] </ref>. In particular, it might be that the environment does not enable all the external nondeterministic choices. To see this, consider a sandwich-dispensing machine that serves, upon request, sandwiches with either ham or cheese.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: We distinguish between two types of temporal logics: universal and non-universal. Both logics describe the computation tree induced by the system. Formulas of universal temporal logics describe requirements that should hold in all the branches of the tree <ref> [GL94] </ref>. <p> A system M then satisfies a specification with assumption ' and guarantee if and only if in all compositions of M with E , if the composition satisfies ', then it satisfies as well. Checking assume-guarantee specifications is helpful in modular verification <ref> [GL94] </ref>. For universal temporal logics, automatic methods for this check are suggested in [Pnu85, Var95, KV95]. These methods depend on the fact that the simulation order captures agreement on universal temporal-logic formulas, and they cannot be extended to handle non-universal formulas.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Thus, while in a closed system all the nondeterministic choices are internal, and resolved by the system, in an open system there are also external nondeterministic choices, which are resolved by the environment <ref> [Hoa85] </ref>. In order to check whether a closed system satisfies a required property, we translate the system into some formal model, specify the property with a temporal-logic formula, and check formally that the model satisfies the formula. Hence the name model checking for the verification methods derived from this viewpoint.
Reference: [HP85] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. In Logics and Models of Concurrent Systems, </title> <booktitle> volume F-13 of NATO Advanced Summer Institutes, </booktitle> <pages> pp. 477-498, </pages> <year> 1985. </year>
Reference-contexts: Indeed, it might be that adding behaviors to the system helps it to satisfy a possibility requirement or, equivalently, that disabling some of its behaviors causes the requirement not to be satisfied. We also distinguish between two types of systems: closed and open <ref> [HP85] </ref>. A closed system is a system whose behavior is completely determined by the state of the system. An open system is a system that interacts with its environment and whose behavior depends on this interaction.
Reference: [Jon83] <author> C.B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <booktitle> In Proc. 9th IFIP, </booktitle> <pages> pp. 321-332, </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: Often, the environment is known to satisfy some assumptions. In the sandwich-dispensing machine example, it may be useful to know that the machine is located in a vegetarian village. In the assume-guarantee paradigm <ref> [Jon83, Lam83] </ref>, the specification of an open system consists of two parts. One part describes the guaranteed behavior of the system. The other part describes the assumed behavior of the environment with which the module is interacting.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th CONCUR, </booktitle> <volume> LNCS 962, </volume> <pages> pp. 408-422, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Checking assume-guarantee specifications is helpful in modular verification [GL94]. For universal temporal logics, automatic methods for this check are suggested in <ref> [Pnu85, Var95, KV95] </ref>. These methods depend on the fact that the simulation order captures agreement on universal temporal-logic formulas, and they cannot be extended to handle non-universal formulas. <p> Hence the following theorem. Theorem 1. (1) [KV96] The module-checking problem with incomplete information is PTIME-complete (and solvable in linear time) for 8CTL and is PSPACE-complete for LTL and 8CTL ? . (2) <ref> [Pnu85, KV95] </ref> The assume-guarantee module-checking problem is PSPACE-complete for LTL and 8CTL and is EXPSPACE-complete for 8CTL ? . As with module checking, things become more challenging when we turn to solve the problems for the case and ' are not necessarily universal temporal-logic formulas. <p> The alternating-automata-theoretic approach to CTL and CTL ? model checking is extended in <ref> [KV95] </ref> to handle Fair-CTL and Fair-CTL ? [EL85]. Using the same extension, we can handle here modules augmented with fairness conditions. We now consider the complexity bounds that follow from our algorithm. Theorem 6.
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Module checking. </title> <booktitle> In Proc. 8th CAV, </booktitle> <volume> LNCS 1102, </volume> <pages> pp. 75-86, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Accordingly, there are many different possible environments to consider. It turned out that model-checking methods are applicable also for verification of open systems with respect to universal temporal-logic formulas <ref> [MP92, KV96] </ref>. To see this, consider a composition of an open system with a maximal environment; i.e., an environment that enables all the external nondeterministic choices. This composition is a closed system, and it is simulated by any other composition of the system with some environment. <p> This composition is a closed system, and it is simulated by any other composition of the system with some environment. Therefore, one can check satisfaction of universal requirements in an open system by model checking the composition of the system with this maximal environment. As discussed in <ref> [KV96] </ref>, this approach can not be adapted when verifying an open system with respect to non-universal requirements. Here, satisfaction of the requirements with respect to the maximal environment does not imply their satisfaction with respect to all environments. <p> Note that while this requirement holds with respect to the maximal environment, it does not hold, for instance, in an environment in which all the people in line do not like ham. In <ref> [KV96] </ref>, we suggested module checking as a general method for verification of open systems. Given an open system M and a temporal-logic formula , the module-checking problem asks whether for all possible environments E , the composition of M with E satisfies . <p> This is, however, not true. While both problems can be solved in time that is exponential in the size of the formula, only the one with complete information can be solved in time that is polynomial in the size of the system <ref> [KV96] </ref>. On the other hand, module checking with incomplete information requires time that is exponential in both the formula and the system. <p> Does M &lt; E satisfy for every environment E for which M &lt; E is deadlock free? When the answer to the module-checking question is positive, we say that M reactively satisfies , denoted M j= r . The module-checking problem is introduced and solved in <ref> [KV96] </ref> 3 . We define two orthogonal extensions of the module-checking problem: Module Checking with Incomplete Information: Let M be a module and let be a temporal-logic formula over P . <p> We consider temporal-logic formulas in LTL, CTL, and CTL ? . We first handle the case where and ' are universal temporal-logic formulas. As shown in <ref> [KV96] </ref>, checking whether M reactively satisfies a universal formula can be reduced to checking whether M &lt; E max satisfies . <p> In addition, the assume-guarantee problem for LTL, 8CTL, and 8CTL ? (the universal fragments of CTL and CTL ? , in which only universal path quantification is allowed) has been studied in the literature. Hence the following theorem. Theorem 1. (1) <ref> [KV96] </ref> The module-checking problem with incomplete information is PTIME-complete (and solvable in linear time) for 8CTL and is PSPACE-complete for LTL and 8CTL ? . (2) [Pnu85, KV95] The assume-guarantee module-checking problem is PSPACE-complete for LTL and 8CTL and is EXPSPACE-complete for 8CTL ? . <p> We first show that assume-guarantee module checking can be easily reduced to module checking. Lemma 2. For every module M and formulas ' and , we have h'iM h i iff M j= r ' ! . 3 In <ref> [KV96] </ref>, we define a module using system and environment states, and only transitions from environment states may be disabled. Here, the interaction of the system with its environment is more explicit, and transitions are disabled by the environment assigning values to the system's input variables. <p> The reduction above implies that assume-guarantee module checking is not harder than module checking. As assume-guarantee module checking is also at least as hard as module checking, the theorem below follows from the known complexity bounds for the module-checking problem <ref> [KV96] </ref>. Theorem 3. The assume-guarantee module-checking problem is EXPTIME-complete for CTL and is 2EXPTIME-complete for CTL ? . While handling of assumptions about the environment is easy, handling incomplete information is complicated. The solution we suggest is based on alternating tree automata and is outlined below. <p> We now consider the complexity bounds that follow from our algorithm. Theorem 6. The module-checking problem with incomplete information is EXPTIME-complete for CTL and is 2EXPTIME-complete for CTL ? . Proof (sketch): The lower bounds follows from the known bounds for module checking with complete information <ref> [KV96] </ref>. For the upper bounds, in Theorems 4 and 5 we reduced the problem M j= r to the problem of checking the nonemptiness of the automaton A M;: . When is a CTL formula, A M;: is an alternating Buchi automaton of size O (jM j fl j j). <p> Let us define the program complexity of module checking as the complexity of the problem in terms of the size of the system, assuming that the specification is fixed [VW86]. Since the system is typically much bigger than the specification, this complexity is of particular interest [LP85]. By <ref> [KV96] </ref>, the program complexity of CTL module checking with complete information is PTIME-complete. On the other hand, the time complexity of the algorithm we present here is exponential in the size of the both the formula and the system. <p> The formal definition of M G and ' involves some technical complications required in order to make sure that the environment disables only transitions from OR-states. ut 4 Discussion Module checking considers the verification of open systems. In <ref> [KV96] </ref>, we claim that the complexity of the module-checking problem, which is EXPTIME for specifications in CTL and only PSPACE for specifications in LTL, questions the traditional belief of the computational superiority of the branching-time paradigm. In this paper we considered open systems that have internal variables. <p> Hence, it provides an additional evidence that checking CTL properties is actually harder than checking LTL properties. The setting we consider here is more general than the one in <ref> [KV96] </ref>, but can still be generalized further. In both [KV96] and here, we assume that an environment may disable some of the system's transition. More general settings allow more dominant environments. <p> Hence, it provides an additional evidence that checking CTL properties is actually harder than checking LTL properties. The setting we consider here is more general than the one in <ref> [KV96] </ref>, but can still be generalized further. In both [KV96] and here, we assume that an environment may disable some of the system's transition. More general settings allow more dominant environments.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. on Programming Languages and Systenms, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Often, the environment is known to satisfy some assumptions. In the sandwich-dispensing machine example, it may be useful to know that the machine is located in a vegetarian village. In the assume-guarantee paradigm <ref> [Jon83, Lam83] </ref>, the specification of an open system consists of two parts. One part describes the guaranteed behavior of the system. The other part describes the assumed behavior of the environment with which the module is interacting.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proc. 12th POPL, </booktitle> <pages> pp. 97-107, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal-logic properties of finite-state systems <ref> [CE81, QS81, LP85, CES86] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state systems, as well as from the great ease of use of fully algorithmic methods. We distinguish between two types of temporal logics: universal and non-universal. <p> Let us define the program complexity of module checking as the complexity of the problem in terms of the size of the system, assuming that the specification is fixed [VW86]. Since the system is typically much bigger than the specification, this complexity is of particular interest <ref> [LP85] </ref>. By [KV96], the program complexity of CTL module checking with complete information is PTIME-complete. On the other hand, the time complexity of the algorithm we present here is exponential in the size of the both the formula and the system.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. 2nd IJCAI, British Computer Society, </booktitle> <pages> pp. 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: In both cases, the more behaviors the system has, the harder it is for the system to satisfy the requirements. Indeed, universal temporal logics induce the simulation order between systems <ref> [Mil71, CGB86] </ref>. That is, a system M simulates a system M 0 if and only if all universal temporal logic formulas that are satisfied in M 0 are satisfied in M as well.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> Temporal specification and verification of reactive modules. </title> <year> 1992. </year>
Reference-contexts: Accordingly, there are many different possible environments to consider. It turned out that model-checking methods are applicable also for verification of open systems with respect to universal temporal-logic formulas <ref> [MP92, KV96] </ref>. To see this, consider a composition of an open system with a maximal environment; i.e., an environment that enables all the external nondeterministic choices. This composition is a closed system, and it is simulated by any other composition of the system with some environment.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: We now turn to a detailed description of the solution of the module-checking problem with incomplete information, and the complexity results it entails. For that, we first define formally alternating tree automata. 3.1 Alternating Tree Automata Alternating tree automata generalize nondeterministic tree automata and were first introduced in <ref> [MS87] </ref>. An alternating tree automaton A = h; Q; q 0 ; ffi; ffi runs on full -labeled -trees (for an agreed set of directions).
Reference: [MS95] <author> D.E. Muller and P.E. Schupp. </author> <title> Simulating aternating tree automata by nondeterministic automata: New results and new proofs of theorems of Rabin, McNaughton and Safra. </title> <journal> Theoretical Computer Science, </journal> <volume> 141 </volume> <pages> 69-107, </pages> <year> 1995. </year>
Reference-contexts: When is a CTL formula, A M;: is an alternating Buchi automaton of size O (jM j fl j j). By <ref> [VW86, MS95] </ref>, checking the nonemptiness of A M;: is then exponential in the sizes of M and . When is a CTL ? formula, the automaton A M;: is an alternating Rabin automaton, with jW j fl 2 O (j j) states and two pairs. <p> By [VW86, MS95], checking the nonemptiness of A M;: is then exponential in the sizes of M and . When is a CTL ? formula, the automaton A M;: is an alternating Rabin automaton, with jW j fl 2 O (j j) states and two pairs. Accordingly, by <ref> [EJ88, MS95] </ref>, checking the nonemptiness of A M;: is exponential in jW j and double exponential in j j. ut By Lemma 2, the bounds above hold also for the problem of assume-guarantee module checking with incomplete information.
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying reactive systems <ref> [Pnu81] </ref>. One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal-logic properties of finite-state systems [CE81, QS81, LP85, CES86].
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Applications of temporal logic to the specification and verification of reactive systems: A survey of current trends. </title> <booktitle> In Proc. Advanced School on Current Trends in Concurrency, </booktitle> <volume> LNCS 224, </volume> <pages> pp. 510-584, </pages> <year> 1985. </year>
Reference-contexts: Checking assume-guarantee specifications is helpful in modular verification [GL94]. For universal temporal logics, automatic methods for this check are suggested in <ref> [Pnu85, Var95, KV95] </ref>. These methods depend on the fact that the simulation order captures agreement on universal temporal-logic formulas, and they cannot be extended to handle non-universal formulas. <p> Hence the following theorem. Theorem 1. (1) [KV96] The module-checking problem with incomplete information is PTIME-complete (and solvable in linear time) for 8CTL and is PSPACE-complete for LTL and 8CTL ? . (2) <ref> [Pnu85, KV95] </ref> The assume-guarantee module-checking problem is PSPACE-complete for LTL and 8CTL and is EXPSPACE-complete for 8CTL ? . As with module checking, things become more challenging when we turn to solve the problems for the case and ' are not necessarily universal temporal-logic formulas.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> LNCS 137, </volume> <pages> pp. 337-351, </pages> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal-logic properties of finite-state systems <ref> [CE81, QS81, LP85, CES86] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state systems, as well as from the great ease of use of fully algorithmic methods. We distinguish between two types of temporal logics: universal and non-universal.
Reference: [Rei84] <author> J.H. Reif. </author> <title> The complexity of two-player games of incomplete information. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 29 </volume> <pages> 274-301, </pages> <year> 1984. </year>
Reference-contexts: Theorem 7. The program complexity of CTL module checking with incomplete information is EXPTIME-complete. Proof (sketch): The upper bound follows from Theorem 6. For the lower bound, we do a reduction from the outcome problem for two-players games with incomplete information, proved to be EXPTIME-hard in <ref> [Rei84] </ref>. A two-player game with incomplete information consists of an AND-OR graph with an initial state and a set of designated states. Each of the states in the graph is labeled by readable and unreadable observations. The game is played between two players, called the OR-player and the AND-player. <p> As in module checking, while verification of universal properties in these settings can be done using closed-system verification methods, there is a need to revise verification methods in order to handle non-universal properties. Acknowledgment We thank Rajeev Alur for referring us to <ref> [Rei84] </ref> and pointing its relevance to the lower bound in Theorem 7.
Reference: [Var95] <author> M.Y. Vardi. </author> <title> On the complexity of modular model checking. </title> <booktitle> In Proc. 10th LICS, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Checking assume-guarantee specifications is helpful in modular verification [GL94]. For universal temporal logics, automatic methods for this check are suggested in <ref> [Pnu85, Var95, KV95] </ref>. These methods depend on the fact that the simulation order captures agreement on universal temporal-logic formulas, and they cannot be extended to handle non-universal formulas.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: When is a CTL formula, A M;: is an alternating Buchi automaton of size O (jM j fl j j). By <ref> [VW86, MS95] </ref>, checking the nonemptiness of A M;: is then exponential in the sizes of M and . When is a CTL ? formula, the automaton A M;: is an alternating Rabin automaton, with jW j fl 2 O (j j) states and two pairs. <p> This is, however, not true. Let us define the program complexity of module checking as the complexity of the problem in terms of the size of the system, assuming that the specification is fixed <ref> [VW86] </ref>. Since the system is typically much bigger than the specification, this complexity is of particular interest [LP85]. By [KV96], the program complexity of CTL module checking with complete information is PTIME-complete.
References-found: 26

