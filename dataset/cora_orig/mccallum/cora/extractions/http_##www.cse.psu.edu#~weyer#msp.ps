URL: http://www.cse.psu.edu/~weyer/msp.ps
Refering-URL: http://www.cse.psu.edu/~weyer/
Root-URL: http://www.cse.psu.edu
Author: Geoffrey Ryan Weyer 
Note: I grant The Pennsylvania State University the nonexclusive right to use this work for the University's own purposes and to make single copies of the work available to the public on a not-for-profit basis if copies are not otherwise available.  
Abstract-found: 0
Intro-found: 1
Reference: [Ban79] <author> John Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> Conference Record of the Sixth ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: By definition, abstract interpretation simulates execution of a program over some abstract domain. In contrast, the methods of [Spi71] and [Bar87] collect information about a program in one pass, and then perform transitive closure operations to derive run-time properties. A similar method is that of <ref> [Ban79] </ref> which analyzes procedure call chains. Specifically, these methods produce may-alias information without abstract interpretation. While such methods are potentially faster than abstract interpretation, the trade off is in the reduced precision of the derived information. <p> Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. The method of <ref> [Ban79] </ref> calculates a fixpoint when solving a system of equations over flow graphs. Likewise, [SP81] solves systems of equations that represent call chains. Flow-insensitive analyzers need not simulate execution of a program, but must generally calculate a fix-point over some domain or set of equations. <p> The three optimizations just mentioned all require structure sharing information, which our abstract domain provides in a relatively precise manner. Again it should be noted that other methods can provide similar information faster if they are tailored to the specific task. The method of <ref> [Ban79] </ref> provides alias analysis without doing abstract interpretation at all, but in a relatively imprecise manner. The methods of [LR92], [Wei80] provide alias analysis in the prescence of procedure and label variables which we do not handle.
Reference: [Bar87] <author> Jeffrey M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: We note that abstract interpretation is not the only way to derive useful information about a program at compile time. By definition, abstract interpretation simulates execution of a program over some abstract domain. In contrast, the methods of [Spi71] and <ref> [Bar87] </ref> collect information about a program in one pass, and then perform transitive closure operations to derive run-time properties. A similar method is that of [Ban79] which analyzes procedure call chains. Specifically, these methods produce may-alias information without abstract interpretation.
Reference: [BC86] <author> Michael Burke and Ron Cytron. </author> <title> Interprocedural dependence analysis and paralleliza-tion. </title> <journal> ACM SIGPLAN., </journal> <volume> 21(7) </volume> <pages> 162-175, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: While such methods are potentially faster than abstract interpretation, the trade off is in the reduced precision of the derived information. Another alternative to abstract interpretation is to solve systems of equations to derive run time may-alias information at compile time. The method of <ref> [BC86] </ref> transforms matrix references into a system of indexed memory references, and solves the system to determine when matrix accesses may be parallelized.
Reference: [BGW92] <author> B. Burton, G. Gudjonsson, and W. Winsborough. </author> <title> An algorithm for computing alternating closure. </title> <type> Technical Report CS-92-15, </type> <institution> Penn State, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Creating such an analyzer remains an elusive task. Previous graph based abstract analyzers were precise but inefficient [BWM93, Jan90]. Simpler domains that omit structure shape information can be fast, but tend to miss opportunities for optimizations <ref> [BGW92] </ref>. Our approach attempts to capture efficiency and precision simultaneously. 1.2 Goals Our goal in this research is to define an abstract analysis system that is precise and efficient. To demonstrate the usefulness of this system, we implement and evaluate an abstract analyzer.
Reference: [BWM93] <author> M. Bruynooghe, W. Winsborough, and A. Mulkers. Type-graph unification. </author> , <year> 1993. </year>
Reference-contexts: A third motivation for research into analysis of structure shape and sharing information is the need for an analyzer that is both precise and efficient. Creating such an analyzer remains an elusive task. Previous graph based abstract analyzers were precise but inefficient <ref> [BWM93, Jan90] </ref>. Simpler domains that omit structure shape information can be fast, but tend to miss opportunities for optimizations [BGW92]. Our approach attempts to capture efficiency and precision simultaneously. 1.2 Goals Our goal in this research is to define an abstract analysis system that is precise and efficient. <p> Free variable sharing and structure sharing may be recorded in an auxiliary component or by additional cross arcs. Type graphs with additional sharing constructs have been employed by [Jan90], <ref> [BWM93] </ref>, and [JB90]. Abstract 18 nil a b c binding binding binding -1 -2 -3 -2 ps nil nilnil nil b c T T L L L term environment (with labels omitted). domains that contain type graphs often employ an explicit widening operation, applied to individual type graphs. <p> We can reduce the number of propagated unify sets by using an inductively constructed injectivity annotation on unify sets. These annotations are determined during the propagation process, and serve to guide it. A similar annotation scheme is used in <ref> [BWM93] </ref> to handle a similar problem that occurs when unifying type graphs. The injectivity annotations are 1-1, which indicates a one-to-one mapping, and M-1, to indicat a many-to-one mapping. <p> Such a complete abstract interpretation system is described in [Jan90], and a complete discussion of a simple abstract interpreter may be found in [Cou81]. Implementation of a more powerful version of [Jan90] is presented in <ref> [BWM93] </ref> In general, research on the above topics is carried out independently. This paper is such an example, as we present an abstract domain and widening operation, but omit in depth discussion of the fixpoint calculator. <p> In the case of the method presented in this paper, the widening operation is an implicit, integrated part of the abstract domain. However, widening may be defined as a distinct operation, executed when updates are made to elements of the abstract domain [Cou81], [Jan90], <ref> [BWM93] </ref>. We note that abstract interpretation is not the only way to derive useful information about a program at compile time. By definition, abstract interpretation simulates execution of a program over some abstract domain. <p> Note that a depth-k restriction may limit the absolute length of paths to length k [CWZ90], or may limit the number of occurrences of the same constructor on any given path to k [Jan90], <ref> [BWM93] </ref> As has been mentioned previously, some abstract interpretation methods use implicit widening, while others use explicit widening, but all must employ some form if the abstract domain being used contains infinite chains. Unfortunately, little research has been done on widening in isolation. <p> In general, an abstract domain designed for declarative languages may be easily applied to imperative languages by replacing the unification operation with an operation to model assignment. See [CWZ90] for an example of such an update operation. The graph based methods of <ref> [Jan90, JB90, BWM93] </ref> are designed for declarative languages, and therefore do handle unification. The distinction between these methods and ours is that these methods employ type graphs for individual program variables. A type graph is intended to record the possible structure (s) that a program variable may be bound to. <p> The advantage to our method is that alias information is implicit. The method of [Jan90] does retain alias information for free variables in an auxiliary structure, while the analysis of <ref> [BWM93] </ref> records structure sharing in the form of cross-arcs between type graphs. The method of [VCL94] is a hybrid that employs type graphs. This analysis takes the method of [LV92] which operates on sets of substitutions, and adds type graphs. <p> For the additional expressiveness, we sacrifice some simplicity and flexibility. This loss of simplicity leads to a unification operation that is more complicated than that of [Jan90] or <ref> [BWM93] </ref>. The use of structure shape graphs for analysis of declarative languages is a new direction in this field of study.
Reference: [CBC93] <author> J.D. Choi, M.G. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> Twentieth Annual ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Like our analysis, that of [KS94] can determine what free variables may be 75 shared by structures to which two different program variables are bound. As will be discussed below, this can be used for garbage collection and parallelization. A similar method by <ref> [CBC93] </ref> uses k-limiting, and alias pairs from which access paths can be constructed. The derivable information is similar to that produced by [KS94]. The access path based method of most recent significance is that of [Deu94].
Reference: [CC77a] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction of approximation of fixpoints. </title> <booktitle> Fourth Annual ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: ) ^ (a 2 ps a 3 ) ) (a 1 ps a 3 ) 17 a cons/2 cons/2 cons/2 a -2 -1 binding X cons/2 nil ab -2 MO -2 binding 2.5 Folding In abstract analysis methods that use graphs to represent heap structures, some type of "widening" operation <ref> [CC77a] </ref>, [JM82] is often employed to enable representation of unbounded structure in bounded graphs. When a graph is widened, it is modified to recognize a wider range of heap structures, hence the name. Alternative methods include truncation of graphs at a certain depth, and k-limiting [JM81]. <p> Unfortunately, little research has been done on widening in isolation. The idea was introduced in <ref> [CC77a] </ref>, and is defined and used explicitly in [Cou81]. Most abstract interpretation methods do not define widening as a separate operation, but incorporate it in some update operation as we have done in this paper. Recall that our domain, and its implicit folding was inspired by [CWZ90].
Reference: [CC77b] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of generalized type unions. </title> <journal> SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 77-94, </pages> <month> March </month> <year> 1977. </year>
Reference-contexts: While correctness is essential for any abstract interpretation technique, it is not necessarily true that analysis is required at all to derive certain useful information from a program. Specifically, <ref> [CC77b] </ref> presents a comparison of type checking to type discovering. The authors compare the information derived from abstract interpretation to information that can be derived directly by a compiler for a rigidly typed language.
Reference: [CFG + ] <author> A. Cortesi, G. File, R. Giacobazzi, C. Palamidessi, and F. Ranzato. </author> <title> Complementation in abstract interpretation. </title>
Reference-contexts: To the best of our knowledge, no one has attempted to answer the question as to whether combination is more accurate and efficient than integration. Some works on combined domains that the reader may refer to are [CMB + 93], [CLV94], and <ref> [CFG + ] </ref>. 6.3 Relevance and usefulness Finally, we discuss the relevance of the method presented in this paper, and some of the uses. We point out first that many abstract interpretation techniques are defined for imperative languages.
Reference: [CLV94] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Combinations of abstract domains for logic programming. </title> <booktitle> ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 227-239, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Finally, we contribute to the general study of the tradeoff between abstract domain complexity and accuracy. In particular, the question has been raised as to whether it is preferable to use one complex domain, or a combination of simple ones <ref> [CLV94] </ref>, [CMB + 93]. We believe that our abstract domain provides more accurate information than would a collection of simpler domains. Specifically, the alias information that our analyzer produces is more accurate because structure shape information is retained. The structure shape information is more accurate because groundness information is retained. <p> To the best of our knowledge, no one has attempted to answer the question as to whether combination is more accurate and efficient than integration. Some works on combined domains that the reader may refer to are [CMB + 93], <ref> [CLV94] </ref>, and [CFG + ]. 6.3 Relevance and usefulness Finally, we discuss the relevance of the method presented in this paper, and some of the uses. We point out first that many abstract interpretation techniques are defined for imperative languages.
Reference: [CMB + 93] <author> M. Codish, A. Mulkers, M. Bruynooghe, M. Garcia de la Banda, and M. Hermenegildo. </author> <title> Improving abstract interpretations by combining domains. </title> <booktitle> ACM Symposium on Partial Evaluation and Semantics-based Program Manipulation (PEPM-93), </booktitle> <pages> pages 194-205, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Finally, we contribute to the general study of the tradeoff between abstract domain complexity and accuracy. In particular, the question has been raised as to whether it is preferable to use one complex domain, or a combination of simple ones [CLV94], <ref> [CMB + 93] </ref>. We believe that our abstract domain provides more accurate information than would a collection of simpler domains. Specifically, the alias information that our analyzer produces is more accurate because structure shape information is retained. The structure shape information is more accurate because groundness information is retained. <p> To the best of our knowledge, no one has attempted to answer the question as to whether combination is more accurate and efficient than integration. Some works on combined domains that the reader may refer to are <ref> [CMB + 93] </ref>, [CLV94], and [CFG + ]. 6.3 Relevance and usefulness Finally, we discuss the relevance of the method presented in this paper, and some of the uses. We point out first that many abstract interpretation techniques are defined for imperative languages.
Reference: [Cou81] <author> P. Cousot. </author> <title> Semantic foudations of program analysis. </title> <editor> In Steven Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 303-342. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year> <month> 80 </month>
Reference-contexts: In some instances, complete analysis systems are presented that employ the presented domain and operations. Such a complete abstract interpretation system is described in [Jan90], and a complete discussion of a simple abstract interpreter may be found in <ref> [Cou81] </ref>. Implementation of a more powerful version of [Jan90] is presented in [BWM93] In general, research on the above topics is carried out independently. This paper is such an example, as we present an abstract domain and widening operation, but omit in depth discussion of the fixpoint calculator. <p> In the case of the method presented in this paper, the widening operation is an implicit, integrated part of the abstract domain. However, widening may be defined as a distinct operation, executed when updates are made to elements of the abstract domain <ref> [Cou81] </ref>, [Jan90], [BWM93]. We note that abstract interpretation is not the only way to derive useful information about a program at compile time. By definition, abstract interpretation simulates execution of a program over some abstract domain. <p> Unfortunately, little research has been done on widening in isolation. The idea was introduced in [CC77a], and is defined and used explicitly in <ref> [Cou81] </ref>. Most abstract interpretation methods do not define widening as a separate operation, but incorporate it in some update operation as we have done in this paper. Recall that our domain, and its implicit folding was inspired by [CWZ90].
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F.K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> Proceedings of the ACM SIGPLAN Conference on PLDI., </booktitle> <pages> pages 20-22, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: As was mentioned above, we have adapted some existing ideas to suit our needs. In particular, we use a fixed node set and construct arc sets over this set. We note that fixed node sets for graph-based abstract analysis is not new to our approach <ref> [CWZ90, JM81] </ref>. We believe that the 1 We define folding to be the process of merging like-labeled nodes in a graph. <p> In following with the definition of an SSG, such arcs should have an ns annotation between them, but this caused unnecessary complications in some of the implemented operations. 12 The multiplicity annotations act as simple reference counters, and provide information similar to the reference counts of <ref> [CWZ90] </ref>. We use multiplicity annotations to aid in the placement of the sharing annotations, and reduction of the number of unify sets. <p> The purpose of such operations is to guarantee termination. The size of our graphs is limited by what we refer to as implicit folding. This approach eliminates the need for an explicit widening, folding or truncating operation. Our implicit folding operation is derived from that of <ref> [CWZ90] </ref>. We allocate a fixed set of nodes in which there is exactly one node for each occurrence of a constructor in a given program [JM81]. Arcs are then added on top of this fixed node set. <p> In the TEG, we use a single arc labeled f1,2g rather than two arcs with identical sources and destinations. Also note that outarcs from program variable nodes and V-nodes always have the special label "binding". Nodes labeled with program variables always have indegree zero. This approach was used by <ref> [CWZ90] </ref>, and allows program variables to appear in graphs even if they are not actually stored in the heap. <p> C binding binding binding -1,2 f/2 g/1 Vb binding binding binding -1,2 f/2 a -1 binding binding -1,2 V V V f/2 binding a V binding binding binding X Y a binding Vb Vb Vb Vf Vf Vf f/2 binding -1,2 3.3 Fixed Node Sets In following the method of <ref> [CWZ90] </ref> and the data structures of [JM81], we employ a fixed node set determined at the beginning of the analysis. This node set consists of exactly one node for each program variable, and each constructor in a given program. <p> This new abstract element represents a wider array of concrete elements (lists) than did the original. Note that a depth-k restriction may limit the absolute length of paths to length k <ref> [CWZ90] </ref>, or may limit the number of occurrences of the same constructor on any given path to k [Jan90], [BWM93] As has been mentioned previously, some abstract interpretation methods use implicit widening, while others use explicit widening, but all must employ some form if the abstract domain being used contains infinite <p> Most abstract interpretation methods do not define widening as a separate operation, but incorporate it in some update operation as we have done in this paper. Recall that our domain, and its implicit folding was inspired by <ref> [CWZ90] </ref>. This method allocates one node for each occurrence of each constructor in a given program, following [JM81]. In contrast to our approach, [CWZ90] allows multiple occurrences of a constructor in their SSGs so long as each constructor meets a certain set of criteria. <p> Recall that our domain, and its implicit folding was inspired by <ref> [CWZ90] </ref>. This method allocates one node for each occurrence of each constructor in a given program, following [JM81]. In contrast to our approach, [CWZ90] allows multiple occurrences of a constructor in their SSGs so long as each constructor meets a certain set of criteria. When the criteria are no longer met for a certain node, it is merged with a common node for the given constructor. <p> These widening options effect the accuracy of a graph based method, but not the type of information that it may provide. To begin with, we consider graph based methods designed for imperative languages <ref> [CWZ90] </ref>, [LH88], [JM81] , [HPR89]. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate. <p> These widening options effect the accuracy of a graph based method, but not the type of information that it may provide. To begin with, we consider graph based methods designed for imperative languages <ref> [CWZ90] </ref>, [LH88], [JM81] , [HPR89]. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate. <p> To begin with, we consider graph based methods designed for imperative languages <ref> [CWZ90] </ref>, [LH88], [JM81] , [HPR89]. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate. In general, the graph based methods designed for imperative languages are no more or less powerful than those designed for declarative languages. <p> The abstraction of this operation is difficult, and tends to reduce the precision of the analysis. In general, an abstract domain designed for declarative languages may be easily applied to imperative languages by replacing the unification operation with an operation to model assignment. See <ref> [CWZ90] </ref> for an example of such an update operation. The graph based methods of [Jan90, JB90, BWM93] are designed for declarative languages, and therefore do handle unification. The distinction between these methods and ours is that these methods employ type graphs for individual program variables.
Reference: [Deb89] <author> S. Debray. </author> <title> Static inference of modes and data dependencies in logic programs. </title> <journal> TOPLAS, </journal> <volume> 11(3) </volume> <pages> 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: In imperative languages, values of non-pointer variables found through data flow analysis may be used to simplify conditionals, or for determining loop termination. In the realm of declarative languages, simple data flow analysis methods may be used for clause selection <ref> [Deb89] </ref>, and for success pretests for unification. In general, simple data flow methods do not compare with our approach in the amount of information that can be derived from a given program.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> SIGPLAN-94, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A similar method by [CBC93] uses k-limiting, and alias pairs from which access paths can be constructed. The derivable information is similar to that produced by [KS94]. The access path based method of most recent significance is that of <ref> [Deu94] </ref>. This method uses paths superscripted with variables in a manner that makes it both powerful and flexible. The main benefit of this method is that it can distinguish between a tree and a DAG, and between cyclic and acyclic lists. <p> This distinction is generally impossible in previous access path and graph based methods. The sharing annotations that we apply to our SSGs in this paper allows us to deduce this same information. While it is possible to record some information about ground and unaliased structure, the method of <ref> [Deu94] </ref> is intended to retain information about aliased free variables. Thus the recording of the additional information is awkward using that method. Our graph based method, on the other hand, records aliased ground structure, and unaliased free variables implicitly. <p> Our graph based method, on the other hand, records aliased ground structure, and unaliased free variables implicitly. We note that of all of the above methods, the only one that can retain information that we can not is that of <ref> [Deu94] </ref>. The variable indexed access paths of this method allow positional relations to be recorded. As an example, [Deu94] could deduce that every other free variable of list A is aliased to every third variable of list B. <p> We note that of all of the above methods, the only one that can retain information that we can not is that of <ref> [Deu94] </ref>. The variable indexed access paths of this method allow positional relations to be recorded. As an example, [Deu94] could deduce that every other free variable of list A is aliased to every third variable of list B. This information is not bounded by the length of the list, and is not distorted through widening. <p> This information is not bounded by the length of the list, and is not distorted through widening. While we can not retain such information, it is not clear that the additional information that <ref> [Deu94] </ref> can deduce is useful. Moreover, this information is only precise for lists, and tends to become blurred when applied to trees or DAGs. <p> Moreover, this information is only precise for lists, and tends to become blurred when applied to trees or DAGs. Specifically, our pairwise-sharing annotation can record stronger information about sharing between leaf elements of a tree, and nodes of a list than can the indexed variables of <ref> [Deu94] </ref>. 6.2.4 Combined domains In the interests of completeness, we turn to a brief discussion of the combined domain approach to abstract analysis. The philosophy that drives research in this area is that simple abstract domains may be combined.
Reference: [ELRV91] <author> V. Englebert, B. Le Charlier, D. Roland, and P. Van Hentenryck. </author> <title> Generic abstract interpretation algorithms for prolog: Two optimization techniques and their experimental evaluation. </title> <type> Technical Report CS-91-67, </type> <institution> Brown University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Generally speaking, data flow based techniques seek to obtain information about values that program variables may be bound to in a flow-sensitive manner. The actual information sought might be possible substitutions <ref> [ELRV91] </ref>, variable dependencies [Mye81], groundness [Six91] or sets of values. Our treatment of data flow based techniques here is somewhat misleading, as data flow is more a class of methods than an abstract domain.
Reference: [GW93] <author> G. Gudjonsson and W. Winsborough. </author> <title> Update in place: Overview of the siva project. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1993 Intl. Symposium, </booktitle> <pages> pages 94-113. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The structure may then be automatically deallocated when execution reaches that program point. Our second motivation is to satisfy the requirements of a specific optimizing compiler that performs update in place memory reuse. The abstract analyzer presented here is suitable for use in the Prolog compiler system discussed in <ref> [GW93] </ref>. This system, known as the SIVA project, performs efficient update-in-place optimizations on Prolog programs. The power of the optimizer depends in part on the amount of information provided by the abstract analyzer. We attempt to construct an analyzer that meets the specific needs of this system. <p> The expressiveness of the output enables both garbage collection, and update in place optimizations to be performed. These optimizations would be done by an optimizing compiler that would receive the output of our analyzer. The development of such a compiler is the subject of current research <ref> [GW93] </ref>. An aspect that we leave for future research is the actual speed of the analyzer. As was mentioned above, one of our motivations is efficiency and speed of abstract analysis. We define abstract operations that are theoretically efficient, and have reasonable orders of complexity. <p> Thus, all of the following optimizations may be performed using our analysis. One of the most common uses for structure shape and sharing information is compile time garbage collection [IT91] or update in place memory reuse <ref> [GW93] </ref>. Typically, a Prolog compiler generates code that allocates heap space for every allocation or copy operation. When the heap is exhausted, some form of garbage collection is applied to reclaim unreachable portions of the heap. <p> Such structures can be reclaimed automatically. A variation of compile time garbage collection is a scheme known as update-in-place <ref> [GW93] </ref>. This is a relatively new and innovative approach to memory management in Prolog that reuses dead structure when a copy is performed. Again, the structure can only be identified as dead if alias analysis is used to determine that all variables pointing to the structure are dead. <p> This should allow the compact efficiency of SSGs to be combined with the expressive power of type graphs. The expressiveness that is of greatest concern is identifying where aliasing does not exist, so that compile time garbage collection, or update in place optimizations may be performed <ref> [JM89, GW93] </ref> 79 The current hope is that our annotations will provide enough expressiveness to allow these optimizations to be performed. More importantly, the annotated graphs will provide more expressiveness than previous abstract analysis methods.
Reference: [Hei92a] <author> N. Heintze. </author> <title> Practical aspects of set based analysis. </title> <editor> In Krzysztok Apt, editor, </editor> <booktitle> Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 765-779. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The topic of dependence analysis is treated in detail in [Pfe91]. Lastly, we mention one area of research which which requires no interpretation, and no abstract domain. The set-based analysis of <ref> [Hei92a] </ref> and [Hei92b] operates on sets of values from the concrete domain. Rather than iterating simulation of a program to a fixpoint, a set of transformations is applied to the calculated sets exhaustively.
Reference: [Hei92b] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The topic of dependence analysis is treated in detail in [Pfe91]. Lastly, we mention one area of research which which requires no interpretation, and no abstract domain. The set-based analysis of [Hei92a] and <ref> [Hei92b] </ref> operates on sets of values from the concrete domain. Rather than iterating simulation of a program to a fixpoint, a set of transformations is applied to the calculated sets exhaustively.
Reference: [HJ91] <author> N. Heintze and J. Jaffar. </author> <title> An engine for logic program analysis. </title> <address> LICS-92, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Other necessary operations on the domain such as projection for procedure calls are also supplied with the abstract domain. While research has been done on generic fixpoint algorithms <ref> [HJ91, JM82] </ref>, examples of fixpoint algorithms are often included in discussions of complete abstract interpretation methods [LV92, VCL94, JM81]. Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> ACM conference on PLDI., </booktitle> <volume> 24(7) </volume> <pages> 28-40, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The methods that we have reviewed attempt to prove correctness by demonstrating that some certain properties are met, or that the method correctly models some notion of concrete execution or semantics <ref> [HPR89] </ref>. While correctness is essential for any abstract interpretation technique, it is not necessarily true that analysis is required at all to derive certain useful information from a program. Specifically, [CC77b] presents a comparison of type checking to type discovering. <p> These widening options effect the accuracy of a graph based method, but not the type of information that it may provide. To begin with, we consider graph based methods designed for imperative languages [CWZ90], [LH88], [JM81] , <ref> [HPR89] </ref>. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate. <p> A specific example of such an optimization can be found in [KS94], while an entire analysis method designed for parallelization is presented in <ref> [HPR89] </ref>. The three optimizations just mentioned all require structure sharing information, which our abstract domain provides in a relatively precise manner. Again it should be noted that other methods can provide similar information faster if they are tailored to the specific task. <p> The methods of [LR92], [Wei80] provide alias analysis in the prescence of procedure and label variables which we do not handle. This flow-insensitive analysis is a relatively imprecise, although the method of <ref> [HPR89] </ref> which is based on [Wei80] is significantly more accurate. As was mentioned above, the unification operation is implemented by generation of general code by the compiler. This code may be specialized if something is known about the structures being unified.
Reference: [IT91] <author> K. Inoue and K. Torii. </author> <title> Implementation and analysis of compile-time grabage collection. </title> <journal> New Generation Computing, </journal> <volume> 10 </volume> <pages> 101-119, </pages> <year> 1991. </year>
Reference-contexts: Thus, all of the following optimizations may be performed using our analysis. One of the most common uses for structure shape and sharing information is compile time garbage collection <ref> [IT91] </ref> or update in place memory reuse [GW93]. Typically, a Prolog compiler generates code that allocates heap space for every allocation or copy operation. When the heap is exhausted, some form of garbage collection is applied to reclaim unreachable portions of the heap.
Reference: [Jan90] <author> G. Janssens. </author> <title> Deriving Run Time Properties of Logic Programs by Means of Abstract Interpretation. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, K.U.Leuven, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: A third motivation for research into analysis of structure shape and sharing information is the need for an analyzer that is both precise and efficient. Creating such an analyzer remains an elusive task. Previous graph based abstract analyzers were precise but inefficient <ref> [BWM93, Jan90] </ref>. Simpler domains that omit structure shape information can be fast, but tend to miss opportunities for optimizations [BGW92]. Our approach attempts to capture efficiency and precision simultaneously. 1.2 Goals Our goal in this research is to define an abstract analysis system that is precise and efficient. <p> Free variable sharing and structure sharing may be recorded in an auxiliary component or by additional cross arcs. Type graphs with additional sharing constructs have been employed by <ref> [Jan90] </ref>, [BWM93], and [JB90]. Abstract 18 nil a b c binding binding binding -1 -2 -3 -2 ps nil nilnil nil b c T T L L L term environment (with labels omitted). domains that contain type graphs often employ an explicit widening operation, applied to individual type graphs. <p> Much of the research in abstract interpretation has been targeted at developing better abstract domains, and more efficient abstract operations. In some instances, complete analysis systems are presented that employ the presented domain and operations. Such a complete abstract interpretation system is described in <ref> [Jan90] </ref>, and a complete discussion of a simple abstract interpreter may be found in [Cou81]. Implementation of a more powerful version of [Jan90] is presented in [BWM93] In general, research on the above topics is carried out independently. <p> In some instances, complete analysis systems are presented that employ the presented domain and operations. Such a complete abstract interpretation system is described in <ref> [Jan90] </ref>, and a complete discussion of a simple abstract interpreter may be found in [Cou81]. Implementation of a more powerful version of [Jan90] is presented in [BWM93] In general, research on the above topics is carried out independently. This paper is such an example, as we present an abstract domain and widening operation, but omit in depth discussion of the fixpoint calculator. <p> In the case of the method presented in this paper, the widening operation is an implicit, integrated part of the abstract domain. However, widening may be defined as a distinct operation, executed when updates are made to elements of the abstract domain [Cou81], <ref> [Jan90] </ref>, [BWM93]. We note that abstract interpretation is not the only way to derive useful information about a program at compile time. By definition, abstract interpretation simulates execution of a program over some abstract domain. <p> This new abstract element represents a wider array of concrete elements (lists) than did the original. Note that a depth-k restriction may limit the absolute length of paths to length k [CWZ90], or may limit the number of occurrences of the same constructor on any given path to k <ref> [Jan90] </ref>, [BWM93] As has been mentioned previously, some abstract interpretation methods use implicit widening, while others use explicit widening, but all must employ some form if the abstract domain being used contains infinite chains. Unfortunately, little research has been done on widening in isolation. <p> In general, an abstract domain designed for declarative languages may be easily applied to imperative languages by replacing the unification operation with an operation to model assignment. See [CWZ90] for an example of such an update operation. The graph based methods of <ref> [Jan90, JB90, BWM93] </ref> are designed for declarative languages, and therefore do handle unification. The distinction between these methods and ours is that these methods employ type graphs for individual program variables. A type graph is intended to record the possible structure (s) that a program variable may be bound to. <p> In contrast, our graphs model complete heap environments, and record what program variables may point to which structures in the heap. The advantage to our method is that alias information is implicit. The method of <ref> [Jan90] </ref> does retain alias information for free variables in an auxiliary structure, while the analysis of [BWM93] records structure sharing in the form of cross-arcs between type graphs. The method of [VCL94] is a hybrid that employs type graphs. <p> Our method is also more powerful than previous methods that employ type graphs because type graphs do not retain structure sharing information. For the additional expressiveness, we sacrifice some simplicity and flexibility. This loss of simplicity leads to a unification operation that is more complicated than that of <ref> [Jan90] </ref> or [BWM93]. The use of structure shape graphs for analysis of declarative languages is a new direction in this field of study.
Reference: [JB90] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation. </title> <type> Technical Report CW 107, </type> <institution> Department of Computer Science, K.U.Leuven, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Free variable sharing and structure sharing may be recorded in an auxiliary component or by additional cross arcs. Type graphs with additional sharing constructs have been employed by [Jan90], [BWM93], and <ref> [JB90] </ref>. Abstract 18 nil a b c binding binding binding -1 -2 -3 -2 ps nil nilnil nil b c T T L L L term environment (with labels omitted). domains that contain type graphs often employ an explicit widening operation, applied to individual type graphs. <p> In general, an abstract domain designed for declarative languages may be easily applied to imperative languages by replacing the unification operation with an operation to model assignment. See [CWZ90] for an example of such an update operation. The graph based methods of <ref> [Jan90, JB90, BWM93] </ref> are designed for declarative languages, and therefore do handle unification. The distinction between these methods and ours is that these methods employ type graphs for individual program variables. A type graph is intended to record the possible structure (s) that a program variable may be bound to. <p> Our analysis provides structure information for the actual parameter at the call site, possibly allowing one of the clauses to be called explicitly rather than a trial of both. An abstract interpretation method aimed at solving clause selection problems can be found in <ref> [JB90] </ref>. The method put forth in those papers uses modes to determine clause selection. As mentioned in [JB90], modes can also be used to specialize unifications for WAM-based compilers. The general nature of our method provides mode information in the form of Vb and Vf-nodes as well as structure information. <p> An abstract interpretation method aimed at solving clause selection problems can be found in <ref> [JB90] </ref>. The method put forth in those papers uses modes to determine clause selection. As mentioned in [JB90], modes can also be used to specialize unifications for WAM-based compilers. The general nature of our method provides mode information in the form of Vb and Vf-nodes as well as structure information.
Reference: [JM81] <editor> N.D. Jones and S. Muchnick. </editor> <title> Flow analysis and optimzation of lisp-like structures. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: As was mentioned above, we have adapted some existing ideas to suit our needs. In particular, we use a fixed node set and construct arc sets over this set. We note that fixed node sets for graph-based abstract analysis is not new to our approach <ref> [CWZ90, JM81] </ref>. We believe that the 1 We define folding to be the process of merging like-labeled nodes in a graph. <p> When a graph is widened, it is modified to recognize a wider range of heap structures, hence the name. Alternative methods include truncation of graphs at a certain depth, and k-limiting <ref> [JM81] </ref>. Each of these methods requires application of the operation of choice whenever the graphs become too large (by some measure). The purpose of such operations is to guarantee termination. The size of our graphs is limited by what we refer to as implicit folding. <p> This approach eliminates the need for an explicit widening, folding or truncating operation. Our implicit folding operation is derived from that of [CWZ90]. We allocate a fixed set of nodes in which there is exactly one node for each occurrence of a constructor in a given program <ref> [JM81] </ref>. Arcs are then added on top of this fixed node set. It follows that the size of the graphs is implicitly limited by the number of nodes in the fixed node set. <p> g/1 Vb binding binding binding -1,2 f/2 a -1 binding binding -1,2 V V V f/2 binding a V binding binding binding X Y a binding Vb Vb Vb Vf Vf Vf f/2 binding -1,2 3.3 Fixed Node Sets In following the method of [CWZ90] and the data structures of <ref> [JM81] </ref>, we employ a fixed node set determined at the beginning of the analysis. This node set consists of exactly one node for each program variable, and each constructor in a given program. For each program variable node, we add two variable nodes labeled Vf and Vb. <p> Recall that our domain, and its implicit folding was inspired by [CWZ90]. This method allocates one node for each occurrence of each constructor in a given program, following <ref> [JM81] </ref>. In contrast to our approach, [CWZ90] allows multiple occurrences of a constructor in their SSGs so long as each constructor meets a certain set of criteria. When the criteria are no longer met for a certain node, it is merged with a common node for the given constructor. <p> Other necessary operations on the domain such as projection for procedure calls are also supplied with the abstract domain. While research has been done on generic fixpoint algorithms [HJ91, JM82], examples of fixpoint algorithms are often included in discussions of complete abstract interpretation methods <ref> [LV92, VCL94, JM81] </ref>. Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. The method of [Ban79] calculates a fixpoint when solving a system of equations over flow graphs. <p> These widening options effect the accuracy of a graph based method, but not the type of information that it may provide. To begin with, we consider graph based methods designed for imperative languages [CWZ90], [LH88], <ref> [JM81] </ref> , [HPR89]. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate.
Reference: [JM82] <editor> N.D. Jones and S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> Ninth Annual ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: ^ (a 2 ps a 3 ) ) (a 1 ps a 3 ) 17 a cons/2 cons/2 cons/2 a -2 -1 binding X cons/2 nil ab -2 MO -2 binding 2.5 Folding In abstract analysis methods that use graphs to represent heap structures, some type of "widening" operation [CC77a], <ref> [JM82] </ref> is often employed to enable representation of unbounded structure in bounded graphs. When a graph is widened, it is modified to recognize a wider range of heap structures, hence the name. Alternative methods include truncation of graphs at a certain depth, and k-limiting [JM81]. <p> Other necessary operations on the domain such as projection for procedure calls are also supplied with the abstract domain. While research has been done on generic fixpoint algorithms <ref> [HJ91, JM82] </ref>, examples of fixpoint algorithms are often included in discussions of complete abstract interpretation methods [LV92, VCL94, JM81]. Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. <p> The actual information sought might be possible substitutions [ELRV91], variable dependencies [Mye81], groundness [Six91] or sets of values. Our treatment of data flow based techniques here is somewhat misleading, as data flow is more a class of methods than an abstract domain. Specifically, <ref> [JM82] </ref> presents a data flow framework in the absence of a specific abstract domain, while [SP81] compares two data flow methods also independent of a specific domain. The method of [Mye81] is also a general framework, but is presented as a liveness tracer for the sake of example.
Reference: [JM89] <author> Simon B. Jones and Daniel Le Metayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> Proceedings of the fifth conference on functional programming languages and computer architecture., </booktitle> <pages> pages 54-74, </pages> <year> 1989. </year> <month> . 81 </month>
Reference-contexts: As above, our method provides this information. We note that structure shape and sharing information is not the only vehicle by which compile time garbage collection, and update-in-place in particular may be done. The method of <ref> [JM89] </ref> does a local update-in-place by determining when an allocation occurs in a clause that also generates a garbage cell. Yet another optimization that requires structure alias information is clause parallelization. <p> This should allow the compact efficiency of SSGs to be combined with the expressive power of type graphs. The expressiveness that is of greatest concern is identifying where aliasing does not exist, so that compile time garbage collection, or update in place optimizations may be performed <ref> [JM89, GW93] </ref> 79 The current hope is that our annotations will provide enough expressiveness to allow these optimizations to be performed. More importantly, the annotated graphs will provide more expressiveness than previous abstract analysis methods.
Reference: [KS94] <author> A. King and P. Soper. </author> <title> Depth-k sharing and freeness. </title> <booktitle> In ICLP conference, </booktitle> <pages> pages 553-568. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Because these methods solve a specific problem (alias detection) they can generally run faster than our method. The tradeoff is that arbitrary (unaliased) structure is not usually recorded, thus eliminating some useful information. The method of <ref> [KS94] </ref> records access paths as sequences of integers representing function argument positions of selectors along paths through a heap. While this looses all information about constructor labels, ground structure, or constructor arity, the usual trade off for speed and simplicity is substantial. Like our analysis, that of [KS94] can determine what <p> The method of <ref> [KS94] </ref> records access paths as sequences of integers representing function argument positions of selectors along paths through a heap. While this looses all information about constructor labels, ground structure, or constructor arity, the usual trade off for speed and simplicity is substantial. Like our analysis, that of [KS94] can determine what free variables may be 75 shared by structures to which two different program variables are bound. As will be discussed below, this can be used for garbage collection and parallelization. <p> As will be discussed below, this can be used for garbage collection and parallelization. A similar method by [CBC93] uses k-limiting, and alias pairs from which access paths can be constructed. The derivable information is similar to that produced by <ref> [KS94] </ref>. The access path based method of most recent significance is that of [Deu94]. This method uses paths superscripted with variables in a manner that makes it both powerful and flexible. <p> Yet another optimization that requires structure alias information is clause parallelization. Specifically, a set of clauses can be executed in parallel if it can be determined that the variables of each do not alias with variables of others. A specific example of such an optimization can be found in <ref> [KS94] </ref>, while an entire analysis method designed for parallelization is presented in [HPR89]. The three optimizations just mentioned all require structure sharing information, which our abstract domain provides in a relatively precise manner.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> ACM SIGPLAN '88 Conference on Programing Language Design and Implementation, </booktitle> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: These widening options effect the accuracy of a graph based method, but not the type of information that it may provide. To begin with, we consider graph based methods designed for imperative languages [CWZ90], <ref> [LH88] </ref>, [JM81] , [HPR89]. Many of our initial design decisions were inspired by [CWZ90], and our implementation is similar to their basic design. We note that [CWZ90] presents additional implementation optimizations that limit the amount of space required to store the graphs that we have not attempted to duplicate.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe, approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> ACM conference on PLDI, </booktitle> <volume> 27(7) </volume> <pages> 235-248, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Flow-insensitive analyzers need not simulate execution of a program, but must generally calculate a fix-point over some domain or set of equations. We note that flow-insensitive abstract analysis methods are generally less precise, but may be able to solve harder problems. Specifically, <ref> [LR92] </ref>, [Wei80] are able to cope with procedure and label variables, which our method does not handle. Fixpoint calculations may be simplified by program dependence information, especially in the analysis of imperative languages. <p> Again it should be noted that other methods can provide similar information faster if they are tailored to the specific task. The method of [Ban79] provides alias analysis without doing abstract interpretation at all, but in a relatively imprecise manner. The methods of <ref> [LR92] </ref>, [Wei80] provide alias analysis in the prescence of procedure and label variables which we do not handle. This flow-insensitive analysis is a relatively imprecise, although the method of [HPR89] which is based on [Wei80] is significantly more accurate.
Reference: [LV92] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for prolog (extended abstract). </title> <booktitle> Fourth IEEE International Conference on Computer Languages, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Other necessary operations on the domain such as projection for procedure calls are also supplied with the abstract domain. While research has been done on generic fixpoint algorithms [HJ91, JM82], examples of fixpoint algorithms are often included in discussions of complete abstract interpretation methods <ref> [LV92, VCL94, JM81] </ref>. Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. The method of [Ban79] calculates a fixpoint when solving a system of equations over flow graphs. <p> The method of [Jan90] does retain alias information for free variables in an auxiliary structure, while the analysis of [BWM93] records structure sharing in the form of cross-arcs between type graphs. The method of [VCL94] is a hybrid that employs type graphs. This analysis takes the method of <ref> [LV92] </ref> which operates on sets of substitutions, and adds type graphs. Specifically, the modified substitutions are allowed to contain variables which stand for type graphs which are stored as grammars. This allows the substitutions to incorporate complex and recursive structures.
Reference: [MSJ94] <author> K. Marriott, H. Sondergaard, and N.D. Jones. </author> <title> Denotational abstract interpretation of logic programs, </title> <month> May </month> <year> 1994. </year>
Reference-contexts: What we wish to discuss here is some of the research done on the fundamental properties of abstract domains, and the widening operation. Besides the study of specific domains, research is also carried out on general frameworks for abstract interpretation. Specifically, <ref> [MSJ94] </ref> shows correctness for a general abstract interpretation framework. Other abstract interpretation techniques can then be proven correct by reduction to the general framework. To the best of our knowledge, no abstract interpretation framework has been argued to be correct by reduction to the framework of [MSJ94]. <p> Specifically, <ref> [MSJ94] </ref> shows correctness for a general abstract interpretation framework. Other abstract interpretation techniques can then be proven correct by reduction to the general framework. To the best of our knowledge, no abstract interpretation framework has been argued to be correct by reduction to the framework of [MSJ94]. The methods that we have reviewed attempt to prove correctness by demonstrating that some certain properties are met, or that the method correctly models some notion of concrete execution or semantics [HPR89].
Reference: [Mye81] <author> Eugene W. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> ACM Symposium on principles of programming languages (8th), </booktitle> <pages> pages 219-230, </pages> <year> 1981. </year>
Reference-contexts: Generally speaking, data flow based techniques seek to obtain information about values that program variables may be bound to in a flow-sensitive manner. The actual information sought might be possible substitutions [ELRV91], variable dependencies <ref> [Mye81] </ref>, groundness [Six91] or sets of values. Our treatment of data flow based techniques here is somewhat misleading, as data flow is more a class of methods than an abstract domain. <p> Specifically, [JM82] presents a data flow framework in the absence of a specific abstract domain, while [SP81] compares two data flow methods also independent of a specific domain. The method of <ref> [Mye81] </ref> is also a general framework, but is presented as a liveness tracer for the sake of example. A general discussion of the applications of data flow analysis can be found in [SM89] along with a data flow method that operates on substitutions.
Reference: [Pfe91] <author> Phillip E. Pfeiffer IV. </author> <title> Dependence-Based Representations for Programs with Reference Variables. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1991. </year>
Reference-contexts: Program dependence information consists primarily of control flow graphs which indicate what statements "follow" a given statement, and more importantly, what statements may need to be evaluated again if some given statement is evaluated. The topic of dependence analysis is treated in detail in <ref> [Pfe91] </ref>. Lastly, we mention one area of research which which requires no interpretation, and no abstract domain. The set-based analysis of [Hei92a] and [Hei92b] operates on sets of values from the concrete domain.
Reference: [PW78] <author> M. S. Patterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of computer and system sciences, </journal> <volume> 16 </volume> <pages> 158-167, </pages> <year> 1978. </year>
Reference-contexts: The TEGs are used here to simplify the discussion of abstract unification. This is done by first defining concrete unification over TEGs, then expressing abstract unification over SSGs using the recognition function. A discussion of unification over DAGs that are similar to our TEGs can be found in <ref> [PW78] </ref>. We begin by defining term unify sets over TEGs. Intuitively, a term unify set is a set of TEG nodes that represent exactly a set of heap cells unified by a Prolog unification. We then introduce unify sets in the context of SSGs to abstract the term unify sets.
Reference: [Six91] <editor> Sixth Annual IEEE Symposium on LICS. </editor> <title> Propositional Logic as an Abstract Interpretation for Groundness Analysis, </title> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: Generally speaking, data flow based techniques seek to obtain information about values that program variables may be bound to in a flow-sensitive manner. The actual information sought might be possible substitutions [ELRV91], variable dependencies [Mye81], groundness <ref> [Six91] </ref> or sets of values. Our treatment of data flow based techniques here is somewhat misleading, as data flow is more a class of methods than an abstract domain. <p> For example, if it is known that the structures being unified are both ground, unification code can be written that includes tests only, with no updates. Such so called groundness analysis can be carried out using abstract interpretation as in <ref> [Six91] </ref> and can also be derived from our abstract domain. Finally, we mention an optimization particular to declarative languages. Clause selection in Prolog can be optimized using the structure information that our abstract domain provides.
Reference: [SM89] <author> H. Sondergaard and K. Marriott. </author> <title> Tutorial Note: T4: Abstract Interpretation on Logic Programs. </title> <booktitle> North American Conference on Logic Programming, Sponsored by the Association of Logic Programming, </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: The method of [Mye81] is also a general framework, but is presented as a liveness tracer for the sake of example. A general discussion of the applications of data flow analysis can be found in <ref> [SM89] </ref> along with a data flow method that operates on substitutions. What we wish to address here are abstract interpretation techniques that employ a data flow framework, but which use neither graphs nor access paths.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications., </booktitle> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. The method of [Ban79] calculates a fixpoint when solving a system of equations over flow graphs. Likewise, <ref> [SP81] </ref> solves systems of equations that represent call chains. Flow-insensitive analyzers need not simulate execution of a program, but must generally calculate a fix-point over some domain or set of equations. We note that flow-insensitive abstract analysis methods are generally less precise, but may be able to solve harder problems. <p> Our treatment of data flow based techniques here is somewhat misleading, as data flow is more a class of methods than an abstract domain. Specifically, [JM82] presents a data flow framework in the absence of a specific abstract domain, while <ref> [SP81] </ref> compares two data flow methods also independent of a specific domain. The method of [Mye81] is also a general framework, but is presented as a liveness tracer for the sake of example.
Reference: [Spi71] <author> T.C. Spillman. </author> <title> Exposing side-effects in a pl/1 optimizing compiler. </title> <booktitle> In IFIP Conference 1971., </booktitle> <volume> volume 1, </volume> <pages> pages 376-381. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: We note that abstract interpretation is not the only way to derive useful information about a program at compile time. By definition, abstract interpretation simulates execution of a program over some abstract domain. In contrast, the methods of <ref> [Spi71] </ref> and [Bar87] collect information about a program in one pass, and then perform transitive closure operations to derive run-time properties. A similar method is that of [Ban79] which analyzes procedure call chains. Specifically, these methods produce may-alias information without abstract interpretation.
Reference: [VCL94] <author> P. Van Hentenryck, A. Cortesi, and B Le Charlier. </author> <title> Type analysis of prolog using type graphs. </title> <booktitle> PLDI, </booktitle> <year> 1994. </year>
Reference-contexts: Other necessary operations on the domain such as projection for procedure calls are also supplied with the abstract domain. While research has been done on generic fixpoint algorithms [HJ91, JM82], examples of fixpoint algorithms are often included in discussions of complete abstract interpretation methods <ref> [LV92, VCL94, JM81] </ref>. Such fixpoint algorithms iterate through the statements and procedures of a program, thereby simulating execution. Precompilation optimizers that do not employ abstract interpretation may still require a fix-point calculation. The method of [Ban79] calculates a fixpoint when solving a system of equations over flow graphs. <p> A graph based method may limit the growth of a graph by setting the maximum length 73 of a path through a graph, or the maximum number of occurrences of the same constructor on any path <ref> [VCL94] </ref>. In addition, the action taken when a length condition is not met may vary. A graph based method may truncate graphs that have become too large, or may fold them as we have done. <p> The advantage to our method is that alias information is implicit. The method of [Jan90] does retain alias information for free variables in an auxiliary structure, while the analysis of [BWM93] records structure sharing in the form of cross-arcs between type graphs. The method of <ref> [VCL94] </ref> is a hybrid that employs type graphs. This analysis takes the method of [LV92] which operates on sets of substitutions, and adds type graphs. Specifically, the modified substitutions are allowed to contain variables which stand for type graphs which are stored as grammars.
Reference: [Wei80] <author> W.E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> Seventh Annual ACM Symposium on Principles of Programming Languages., </booktitle> <pages> pages 83-94, </pages> <year> 1980. </year> <month> 82 </month>
Reference-contexts: Flow-insensitive analyzers need not simulate execution of a program, but must generally calculate a fix-point over some domain or set of equations. We note that flow-insensitive abstract analysis methods are generally less precise, but may be able to solve harder problems. Specifically, [LR92], <ref> [Wei80] </ref> are able to cope with procedure and label variables, which our method does not handle. Fixpoint calculations may be simplified by program dependence information, especially in the analysis of imperative languages. <p> Again it should be noted that other methods can provide similar information faster if they are tailored to the specific task. The method of [Ban79] provides alias analysis without doing abstract interpretation at all, but in a relatively imprecise manner. The methods of [LR92], <ref> [Wei80] </ref> provide alias analysis in the prescence of procedure and label variables which we do not handle. This flow-insensitive analysis is a relatively imprecise, although the method of [HPR89] which is based on [Wei80] is significantly more accurate. <p> The methods of [LR92], <ref> [Wei80] </ref> provide alias analysis in the prescence of procedure and label variables which we do not handle. This flow-insensitive analysis is a relatively imprecise, although the method of [HPR89] which is based on [Wei80] is significantly more accurate. As was mentioned above, the unification operation is implemented by generation of general code by the compiler. This code may be specialized if something is known about the structures being unified.
References-found: 41

