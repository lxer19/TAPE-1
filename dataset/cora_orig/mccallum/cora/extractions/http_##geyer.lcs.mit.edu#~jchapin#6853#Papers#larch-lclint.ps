URL: http://geyer.lcs.mit.edu/~jchapin/6853/Papers/larch-lclint.ps
Refering-URL: http://geyer.lcs.mit.edu/~jchapin/6853/readinglist.html
Root-URL: 
Title: LCLint: A Tool for Using Specifications to Check Code  
Author: David Evans, John Guttag, James Horning, and Yang Meng Tan 
Keyword: C, Larch, LCLint, lint, specifications, static checking  
Abstract: This paper describes LCLint, an efficient and flexible tool that accepts as input programs (written in ANSI C) and various levels of formal specification. Using this information, LCLint reports inconsistencies between a program and its specification. We also describe our experience using LCLint to help understand, document, and re-engineer legacy code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> The Ada programming language reference manual. ANSI/MIL-STD 1815A, US Department of Defense, US Government Printing Office, </institution> <month> February </month> <year> 1983. </year>
Reference-contexts: CCEL differs from LCLint in that the specifications describe general constraints and naming conventions, but do not specify the properties of specific functions. LCLint can be viewed as a tool for promoting modular software designs and abstract data types in C. Many modern languages, including C++ [18], Ada <ref> [1] </ref>, Modula-3 [15] and CLU [11], support both. C++ adds support for abstract types and data encapsulation to C, using an object-oriented paradigm. For programmers who need type inheritance, using C with LCLint is not an alternative to C++.
Reference: [2] <author> Dan Craigen. </author> <title> Verification Environments, Software Engineer's Reference Book, </title> <editor> edited by John A. McDer-mid, </editor> <publisher> CRC Press, </publisher> <year> 1993. </year>
Reference-contexts: These checkers demand little effort from the user, and are frequently used. However, their utility is limited by their lack of information about the intent of the programmer. At the other extreme are program verification systems <ref> [2] </ref>. They are used to demonstrate that a program implements a specification. They require considerable effort from the user, and are seldom used in software development. Somewhere between these extremes are tools that use formal specifications, but don't attempt complete verification.
Reference: [3] <author> Carolyn K. Duby and Scott Meyers and Steven P. Reiss. CCEL: </author> <title> A Metalanguage for C++, </title> <booktitle> USENIX C++ Conference Proceedings, </booktitle> <month> August 10-13, </month> <year> 1992. </year>
Reference-contexts: LCLint doesn't provide such a guaranteesome spurious warnings may be generated, but they can all be turned off by the user. Other tools have been developed more along the lines of improving lint. CCEL <ref> [3] </ref> is a metalanguage that allows programmers to express constraints that can be checked automatically about C++ programs. Constraints are specified in a language similar to C++, and can constrain design, implementation, and style.
Reference: [4] <author> David Evans. </author> <title> Using Specifications to Check Source Code, </title> <institution> MIT/LCS/TR-628, MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: We had not looked at this program before running LCLint on it. It had no formal specifications, and we had no idea what style of programming had been employed. * LCLint itself. Running LCLint on the database example did not find many significant problems <ref> [4] </ref>. It did uncover two abstraction violations, and one undocumented modification that revealed a memory leak. It also generated five spurious modification warnings, because of LCLint's imprecise modifies checking. For example, it failed to determine that a series of assignments to an object culminated in restoring the object's initial value. <p> We then used LCLint to check the revised code against its new specification. In the process, LCLint uncovered various inconsistencies between the implementations of the modules and their specifications, including abstraction violations, unsanctioned object modifications, and unsanctioned global variable accesses. The most illuminating experiment was using LCLint on quake <ref> [4] </ref>. We applied it in the manner described in Section 3. We found two bugs (which could also have been found by a conventional lint) by running LCLint on the quake source without any specifications. <p> A report by Evans <ref> [4] </ref> contains a complete description of LCLint, and a discussion of how it can be used in developing new code, and in understanding and maintaining legacy code. Tan [19] presents a programming methodology based on the use of LCL and LCLint. <p> Some of the checks involving use-before-definition and modification are imprecise. There are cases where LCLint cannot determine if a suspected problem is present, so a message may be issued for a non-existent problem. In other cases, a real problem may go undetected. Early experience with LCLint <ref> [4, 19] </ref> suggests that relatively few spurious warnings are generated, and that the available command line options and syntactic comments are adequate to suppress inappropriate messages. It is more difficult to assess the impact of incomplete checks, since we cannot know how many undetected problems exist.
Reference: [5] <author> David Evans. </author> <note> LCLint User's Guide, Version 1.4. September 1994. Available in: ftp://larch.lcs.mit.edu/pub/Larch/ lclint/lclint1.4.userguide.ps.Z </note>
Reference: [6] <author> G. Feldman and J. Wild. </author> <title> The DECspec project: tools for Larch/C, </title> <booktitle> Proc. Fifth Int. Workshop on Computer-Aided Software Engineering, </booktitle> <address> Montreal, </address> <month> Jul. </month> <year> 1992. </year> <note> Revised version in [12]. </note>
Reference: [7] <author> L. D. Fosdick and Leon J. Osterweil. </author> <title> Data flow analysis in software reliability, </title> <journal> ACM Computing Surveys, </journal> <volume> 8(3), </volume> <month> September </month> <year> 1976. </year>
Reference-contexts: For example, a programmer could specify a file type that may be opened, written to multiple times, and closed, in that order. The prototype Cesar system was too inefficient to be a useful tool in real software development. Cesar built on other systems <ref> [7, 20] </ref> that use sequencing constraints to find errors in code. Inscape [17] uses a specification language that can specify pre-conditions and post-conditions of a procedure, as well as obligations on the caller following return from the call (such as closing a returned file).
Reference: [8] <author> J.V. Guttag and J.J. Horning with S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Appendix B shows how stylized comments can be used for local control of checking. Appendix C describes how to obtain LCLint by anonymous ftp. 2 An Overview of LCLint LCLint accepts as input programs written in ANSI C and various amounts of specification written in the LCL language <ref> [8, 19] </ref>. It is intended to be useful in developing new code and in helping to understand, document, and re-engineer legacy code. <p> We do, however, have some experience using LCLint to understand and maintain legacy code. We have used LCLint on several programs including: * A small database program, formally specified in <ref> [8] </ref>. * pm, an 1800-line portfolio management tool that had been in use for several years. This program had no formal specifications, but was structured around abstract data types. * quake, a 5000-line program for automating system builds in Modula-3.
Reference: [9] <author> Daniel Jackson. </author> <title> Aspect: A formal specification lan guage for detecting bugs, </title> <institution> MIT/LCS/TR-543, MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: LCL provides no way to express obligations on the caller after the called function returns. Some useful checking could be done if specifications could require, for example, that the caller eventually free a returned object, or that it not modify the returned object. Aspect <ref> [9] </ref> is a system for efficiently detecting bugs, by looking for unsatisfied dependencies. The specification language describes dependencies between aspects of objects (such as an array's size) in the post-state and pre-state, and the checker reports when a specified dependency is not present in the im plementation.
Reference: [10] <author> S.C. Johnson. </author> <title> Lint, a C Program Checker, Unix Docu mentation. </title>
Reference-contexts: 1 Introduction Software engineers have long understood that static analysis of program texts can both reduce the number of residual errors and improve the maintainability of programs. Traditional static checkers <ref> [10, 20] </ref> detect type errors and simple anomalies such as obviously uninitialized variables. These checkers demand little effort from the user, and are frequently used. However, their utility is limited by their lack of information about the intent of the programmer. At the other extreme are program verification systems [2]. <p> && (((y) % 100) != 0)) " #define isLeapMonth (m) ((m) == 2) #define days_in_month (y,m) " (date_tab [m] + " ((isLeapMonth (m) && isLeap (y)) ? 1 : 0)) int days_in_year (int y) return (isLeap (y) ? 366 : 365); void setToday (date * d, int local) char asciDate <ref> [10] </ref>; time_t tm = time ((time_t *) NULL); (void) strftime (asciDate, 10, "%D"0", 27 local ? localtime (&tm) : gmtime (&tm)); (void) date_parse (asciDate, d); void setTodayLocal (void) 32 - setToday (&today, TRUE); void setTodayGMT (void) 34 - setToday (&today, FALSE); void copyDate (date *d1, date *d2) -36 if (date_isNormal (*d1))
Reference: [11] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Spe cification in Program Development, </title> <publisher> MIT EECS Series, MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Abstract types are best thought of as collections of related operations on collections of related values <ref> [11, 14] </ref>. #include &lt;stdio.h&gt; #include "date.h" #include "error.h" int days_between (date startD, date endD) -6 if (startD.tag != NORMAL 7 || endD.tag != NORMAL) error ("days_between expects normal dates"); return -1; else if (date_isBefore (endD, startD)) -: : : Exposed types correspond exactly to types in C; abstract types do not <p> LCLint can be viewed as a tool for promoting modular software designs and abstract data types in C. Many modern languages, including C++ [18], Ada [1], Modula-3 [15] and CLU <ref> [11] </ref>, support both. C++ adds support for abstract types and data encapsulation to C, using an object-oriented paradigm. For programmers who need type inheritance, using C with LCLint is not an alternative to C++.
Reference: [12] <author> U. Martin and J.M. Wing. </author> <booktitle> Proc. First Intl. Workshop on Larch, Dedham, Jul. 1992, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [13] <author> Keith W. Miller, Larry J. Morell, and Fred Stevens. </author> <title> Adding data abstraction to Fortran software, </title> <journal> IEEE Software, </journal> <month> November </month> <year> 1988. </year>
Reference-contexts: defining the bool type as int, and exporting two constants: TRUE and FALSE. 2 The flags +boolint and +charint indicate that bools, ints, and chars are to be treated as equivalent. #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include "date.h" #include "error.h" /* defines error */ date today; date todayGMT; static int date_tab <ref> [13] </ref> = - 0, 31, 28, 31, 30, 31, 30, #define isLeap (y) " ((((y) % 4 == 0) && (((y) % 100) != 0)) " #define isLeapMonth (m) ((m) == 2) #define days_in_month (y,m) " (date_tab [m] + " ((isLeapMonth (m) && isLeap (y)) ? 1 : 0)) int days_in_year <p> But for C programmers who merely wish to use modules and abstract types, LCLint provides data encapsulation and type safety without the overhead and complexity of C++. The other checking done by LCLint is useful in both C and C++. Like LCLint, the Fortran Abstract Data (FAD) system <ref> [13] </ref> adds abstract types to an existing programming language. It extends the syntax of Fortran and provides a preprocessor to convert FAD declarations into standard Fortran.
Reference: [14] <author> James H. Morris, Jr. </author> <title> Types are Not Sets, </title> <booktitle> First ACM Symp. Principles of Programming Languages, </booktitle> <address> Boston, </address> <month> Oct. </month> <year> 1973. </year>
Reference-contexts: Abstract types are best thought of as collections of related operations on collections of related values <ref> [11, 14] </ref>. #include &lt;stdio.h&gt; #include "date.h" #include "error.h" int days_between (date startD, date endD) -6 if (startD.tag != NORMAL 7 || endD.tag != NORMAL) error ("days_between expects normal dates"); return -1; else if (date_isBefore (endD, startD)) -: : : Exposed types correspond exactly to types in C; abstract types do not
Reference: [15] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: LCLint can be viewed as a tool for promoting modular software designs and abstract data types in C. Many modern languages, including C++ [18], Ada [1], Modula-3 <ref> [15] </ref> and CLU [11], support both. C++ adds support for abstract types and data encapsulation to C, using an object-oriented paradigm. For programmers who need type inheritance, using C with LCLint is not an alternative to C++.
Reference: [16] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> Interproce dural static analysis of sequencing constraints, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(1), </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: By using LCLint, however, we could verify that the type was truly abstract, and change its implementation without concern that it might introduce bugs elsewhere. 5 Related Work Several checkers have been developed to analyze programs using some form of formal specifications. Cesar <ref> [16] </ref> allows programmers to specify sequencing constraints for an abstract type using a specification language based on regular expressions. For example, a programmer could specify a file type that may be opened, written to multiple times, and closed, in that order.
Reference: [17] <author> Dewayne E. Perry. </author> <title> The logic of propagation in the Inscape environment, </title> <booktitle> In Proceedings of the ACM SIG-SOFT'89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <year> 1989. </year>
Reference-contexts: The prototype Cesar system was too inefficient to be a useful tool in real software development. Cesar built on other systems [7, 20] that use sequencing constraints to find errors in code. Inscape <ref> [17] </ref> uses a specification language that can specify pre-conditions and post-conditions of a procedure, as well as obligations on the caller following return from the call (such as closing a returned file).
Reference: [18] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: CCEL differs from LCLint in that the specifications describe general constraints and naming conventions, but do not specify the properties of specific functions. LCLint can be viewed as a tool for promoting modular software designs and abstract data types in C. Many modern languages, including C++ <ref> [18] </ref>, Ada [1], Modula-3 [15] and CLU [11], support both. C++ adds support for abstract types and data encapsulation to C, using an object-oriented paradigm. For programmers who need type inheritance, using C with LCLint is not an alternative to C++.
Reference: [19] <author> Yang Meng Tan. </author> <title> Formal Specification Techniques for Promoting Software Modularity, Enhancing Software Documentation, and Testing Specifications, </title> <institution> MIT/LCS/TR-619, MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Appendix B shows how stylized comments can be used for local control of checking. Appendix C describes how to obtain LCLint by anonymous ftp. 2 An Overview of LCLint LCLint accepts as input programs written in ANSI C and various amounts of specification written in the LCL language <ref> [8, 19] </ref>. It is intended to be useful in developing new code and in helping to understand, document, and re-engineer legacy code. <p> For example, it failed to determine that a series of assignments to an object culminated in restoring the object's initial value. The pm program was used in a study of how formal specifications could facilitate a software re-engineering process aimed at making existing programs easier to maintain and reuse <ref> [19] </ref>. We wrote LCL specifications for the main modules of the program, and then tried to improve them. Modifications to the program were driven by changes made to the specifications of its modules. Each time the specification of a module changed, the code was revised. <p> A report by Evans [4] contains a complete description of LCLint, and a discussion of how it can be used in developing new code, and in understanding and maintaining legacy code. Tan <ref> [19] </ref> presents a programming methodology based on the use of LCL and LCLint. LCLint detects inconsistencies between code and a combination of specifications and programming conventions. Sometimes warnings expose errors in the specifications or in the code. Sometimes they indicate a violation of a programming convention. <p> Some of the checks involving use-before-definition and modification are imprecise. There are cases where LCLint cannot determine if a suspected problem is present, so a message may be issued for a non-existent problem. In other cases, a real problem may go undetected. Early experience with LCLint <ref> [4, 19] </ref> suggests that relatively few spurious warnings are generated, and that the available command line options and syntactic comments are adequate to suppress inappropriate messages. It is more difficult to assess the impact of incomplete checks, since we cannot know how many undetected problems exist.
Reference: [20] <author> Cindy Wilson and Leon J. Osterweil. </author> <title> Omegaa data flow analysis tool for the C programming language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(9), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Software engineers have long understood that static analysis of program texts can both reduce the number of residual errors and improve the maintainability of programs. Traditional static checkers <ref> [10, 20] </ref> detect type errors and simple anomalies such as obviously uninitialized variables. These checkers demand little effort from the user, and are frequently used. However, their utility is limited by their lack of information about the intent of the programmer. At the other extreme are program verification systems [2]. <p> For example, a programmer could specify a file type that may be opened, written to multiple times, and closed, in that order. The prototype Cesar system was too inefficient to be a useful tool in real software development. Cesar built on other systems <ref> [7, 20] </ref> that use sequencing constraints to find errors in code. Inscape [17] uses a specification language that can specify pre-conditions and post-conditions of a procedure, as well as obligations on the caller following return from the call (such as closing a returned file).
References-found: 20

