URL: file://ftp.cis.ohio-state.edu/pub/communication/papers/icpp98-sw-vs-nic.ps.Z
Refering-URL: http://www.cis.ohio-state.edu/~sivaram/publications.html
Root-URL: 
Email: Email: fsivaram,kesavan,pandag@cis.ohio-state.edu Email: stunkel@watson.ibm.com  
Title: Where to Provide Support for Efficient Multicasting in Irregular Networks: Network Interface or Switch?  
Author: Rajeev Sivaram Ram Kesavan Dhabaleswar K. Panda Craig B. Stunkel 
Address: P. O. Box 218 Columbus, OH 43210 Yorktown Heights, NY 10598  
Affiliation: Dept. of Computer and Information Science IBM T. J. Watson Research Center The Ohio State University  
Note: To appear in the Proceedings of the 27th International Conference on Parallel Processing (ICPP '98), August 1998, Minneapolis, MN  
Abstract: Recent research has proposed methods for enhancing the performance of multicast in networks with irregular topologies. These methods fall into two broad categories: (a) network interface (NI) based schemes that make use of enhanced functionality of the software/firmware running at the NI processor, and (b) switch-based methods that use enhancements to the switch architecture to support hardware multicast. However, it is not clear how these methods compare to each other and when it makes sense to use one over the other. In order to answer such questions, we perform a number of simulation experiments to compare the performance of three efficient multicasting schemes: an NI-based multicasting scheme that uses a k-binomial tree [5], a switch-based multicasting scheme that uses path-based multidestination worms [4], and a switch-based multicasting scheme that uses a single tree-based mul-tidestination worm [14]. We first study the performance of the three schemes for single multicast traffic while changing a number of system parameters one at a time to isolate their impact. We then study the performance of these schemes under increasing multicast load. Our results show that the switch-based multicasting scheme using a single tree-based multi-destination worm performs the best among the three schemes. However, the NI-based multicasting scheme is capable of delivering high performance compared to the switch-based mul-ticast using path-based worms especially when the software overhead at the network interface is less than half of the overhead at the host. We therefore conclude that support for multi-cast at the NI is an important first step to improving multicast performance. However, there is still considerable gain that can be achieved by supporting hardware multicast in switches. Finally, while supporting such hardware multicast, it is better to support schemes that can achieve multicast in one phase. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. J. Boden, D. Cohen, et al. Myrinet: </author> <title> A Gigabit-per-Second Local Area Network. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 2935, </pages> <month> Feb </month> <year> 1995. </year>
Reference-contexts: Thus, the interconnection topology of the network can be denoted by a graph G = (V,E) where V is the set of switches, and E is the set of bidirectional links between the switches <ref> [1, 12] </ref>. Figure 1 (b) shows the interconnection graph for the irregular network in Fig. 1 (a). <p> be noted that all links are bidirectional and multiple links between two switches are possible. terconnect and irregular topology; (b) corresponding in terconnection graph G; (c) corresponding BFS spanning tree rooted at node 6. 2.2 Routing Issues Several deadlock-free routing schemes have been proposed in the literature for irregular networks <ref> [1, 12] </ref>. Without loss of generality, in this paper we assume the routing scheme for our irregular network to be similar to that used in Autonet [12] due to its simplicity and its commercial implementation. Such routing allows adaptivity, and is deadlock-free.
Reference: [2] <author> D. Dai and D. K. Panda. </author> <title> Reducing Cache Invalidation Overheads in Wormhole DSMs Using Multidestination Message Passing. </title> <booktitle> In ICPP, pages I:138145, </booktitle> <address> Chicago, IL, </address> <month> Aug </month> <year> 1996. </year>
Reference-contexts: The importance of such operations is underlined by the inclusion of several primitives for collective communication in the Message Passing Interface (MPI) standard [7]. Such collective operations are also used for system level operations in distributed shared memory systems, such as for cache invalidations, acknowledgment collection, and synchronization <ref> [2] </ref>. Of these collective operations, multicast is most fundamental and important and is used for implementing several of the other collective operations. Traditionally, multicast has been implemented using the underlying support for point-to-point (unicast) communication.
Reference: [3] <author> R. Kesavan, K. Bondalapati, and D. K. Panda. </author> <title> Multi-cast on Irregular Switch-based Networks with Wormhole Routing. </title> <booktitle> In HPCA-3, </booktitle> <pages> pages 4857, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: This means that some destinations serve as intermediate sources, i.e., when they receive a message, they forward copies of it to other destinations. Many such hierarchical algorithms have been proposed in the literature <ref> [3] </ref> to implement multicast. Figure 2 shows an example of a multicast from a source node to seven other destinations. In the figure, the numbers in brackets indicate the step numbers. on a destination set size of 7. <p> In the figure, the numbers in brackets indicate the step numbers. on a destination set size of 7. It can be easily observed that dlog 2 (n+1)e communication steps are required for such a binomial tree based hierarchical multicast to be completed <ref> [3] </ref>. A communication step is the time required for a message to be sent from one host node to another. Even with lightweight messaging layers, the latency of such a multicast operation is still dominated by the communication software overhead.
Reference: [4] <author> R. Kesavan and D. K. Panda. </author> <title> Multicasting on Switch-based Irregular Networks using Multi-drop Path-based Multidestination Worms. </title> <booktitle> In PCRCW '97, </booktitle> <pages> pages 179 192, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Such a method allows messages (christened multidestination messages) to be communicated to multiple destinations incurring a single software overhead for sending the message. There are two subclasses of switch-based multicasting schemes: tree-based [14] and path-based <ref> [4] </ref>. In the best tree-based multicasting scheme, multicast can be performed in a single phase using one multi-destination worm from the source node to all the destinations [14, 15]. The path-based multicasting schemes typically require multiple multidestination worms to perform multicast 1 to arbitrary destination sets. <p> The path-based multicasting schemes typically require multiple multidestination worms to perform multicast 1 to arbitrary destination sets. These worms are transmitted in multiple phases with the destinations in a phase acting as secondary sources in succeeding phases of the multicast <ref> [4] </ref>. The second category of multicasting schemes is referred to as network interface-based or NI-based multicasting schemes. Typically, communication between two nodes incurs software overhead at both the host and at the network interface for both sending and receiving a message. <p> The number of destinations covered depends on the type of encoding/decoding used for the message header. Given support for replication at the switches, there are two schemes that have been proposed for carrying out multicast in switch based irregular networks: tree-based [14] and path-based <ref> [4] </ref>. The two schemes differ in the restrictions placed on worm replication, the number of worms required to perform multicast to an arbitrary destination set, the complexity of multicast header formation, and the complexity of the header decoding logic required at the switches. <p> The worm with the header shown in Fig. 4 (c) must be replicated to all the output ports of the switch. 3.2.4 Path-based Multicasting using Multidestination Worms Under the path-based multicasting scheme <ref> [4] </ref>, multidesti-nation worms use almost exactly the same path followed by a unicast worm from a source to one of its destinations (as allowed under the base routing algorithm). <p> Furthermore, to arrive at a relatively small number of multidestination worms that cover a given destination set, an algorithm is needed that chooses appropriate paths so that as many destinations as possible are covered by each of the worms. Multiple algorithms have been proposed for this <ref> [4] </ref>. In addition, a multi-phase algorithm is required to cover the destination set using the multidestination worms so that contention is reduced and multicast can be performed efficiently. <p> Details of this algorithm can be found in <ref> [4] </ref>, where this algorithm was shown to perform best among the proposed algorithms. multidestination worm and (b) the header encoding. The encoding used for the header of each of the multidesti-nation worms under the path-based scheme is as follows.
Reference: [5] <author> R. Kesavan and D. K. Panda. </author> <title> Optimal Multicast with Packetization and Network Interface Support. </title> <booktitle> In ICPP, </booktitle> <pages> pages 370377, </pages> <month> Aug </month> <year> 1997. </year>
Reference-contexts: Smart NI support can reduce this overhead for multicast, especially for multi-packet messages. Current lean messaging layers allow modification of part of the software running on the NI processor. This part of the software can be modified to allow it to identify a multicast packet <ref> [5, 16] </ref>. If the next outgoing packet in the send queue of the source node is a multicast packet, the NI processor forwards replicas of the packet to the nodes adjacent to the root of the multicast tree. <p> An implementation of such a smart network interface has been described in [16]. sage by intermediate node using (a) conventional NI support, and (b) smart NI support. In this paper, we use the FPFS (First-Packet-First-Served) implementation of the smart network interface support <ref> [5] </ref>. In this implementation, the NI forwards the message on a per-packet basis. The NI at the source node sends the first packet to all the children of the source, then sends the second packet to all the children of the source, and so on. <p> A k-binomial tree has been shown to be optimal for multi-packet multicast on systems with such smart NI support <ref> [5] </ref>. A k-binomial tree is defined as a recursively doubling tree where each vertex has at most k children. The value of k is a function of the size of the multicast set and the number of packets in the multicast message. <p> The value of k is a function of the size of the multicast set and the number of packets in the multicast message. A method for constructing k-binomial trees with minimized contention on irregular switch-based networks has been proposed in the literature <ref> [5] </ref>. In this paper we therefore use the k-binomial tree for our multicasting scheme using network interface support. 3.2.2 Multicasting using Switch Support Another method for improving multicast performance is to provide switches with support for replicating incoming messages to multiple output ports.
Reference: [6] <author> X. Lin and L. M. Ni. </author> <title> Deadlock-free Multicast Wormhole Routing in Multicomputer Networks. </title> <booktitle> In ISCA, </booktitle> <pages> pages 116124, </pages> <year> 1991. </year>
Reference-contexts: The basic idea behind such a 3 scheme is to communicate a single message (called a multi--destination message) from a source to multiple destinations in almost the same time it takes to send a unicast message to one node <ref> [6] </ref>. The number of destinations covered depends on the type of encoding/decoding used for the message header. Given support for replication at the switches, there are two schemes that have been proposed for carrying out multicast in switch based irregular networks: tree-based [14] and path-based [4].
Reference: [7] <author> Message Passing Interface Forum. </author> <title> MPI: A Message-Passing Interface Standard, </title> <month> Mar </month> <year> 1994. </year>
Reference-contexts: Examples of collective operations include multicast [8], barrier synchronization, reduction, etc. The importance of such operations is underlined by the inclusion of several primitives for collective communication in the Message Passing Interface (MPI) standard <ref> [7] </ref>. Such collective operations are also used for system level operations in distributed shared memory systems, such as for cache invalidations, acknowledgment collection, and synchronization [2]. Of these collective operations, multicast is most fundamental and important and is used for implementing several of the other collective operations.
Reference: [8] <author> L. Ni. </author> <title> Should Scalable Parallel Computers Support Efficient Hardware Multicasting? In ICPP Workshop on Challenges for Parallel Processing, </title> <booktitle> pages 27, </booktitle> <year> 1995. </year>
Reference-contexts: One such problem is that of collective communication. Collective communication plays an important role in parallel systems, and involves communication among groups of (2 or more) processes [9]. Examples of collective operations include multicast <ref> [8] </ref>, barrier synchronization, reduction, etc. The importance of such operations is underlined by the inclusion of several primitives for collective communication in the Message Passing Interface (MPI) standard [7].
Reference: [9] <author> D. K. Panda. </author> <title> Issues in Designing Efficient and Practical Algorithms for Collective Communication in Wormhole-Routed Systems. </title> <booktitle> In ICPP Workshop on Challenges for Parallel Processing, </booktitle> <pages> pages 815, </pages> <year> 1995. </year>
Reference-contexts: One such problem is that of collective communication. Collective communication plays an important role in parallel systems, and involves communication among groups of (2 or more) processes <ref> [9] </ref>. Examples of collective operations include multicast [8], barrier synchronization, reduction, etc. The importance of such operations is underlined by the inclusion of several primitives for collective communication in the Message Passing Interface (MPI) standard [7].
Reference: [10] <author> D. K. Panda, D. Basak, D. Dai, R. Kesavan, R. Sivaram, M. Banikazemi, and V. Moorthy. </author> <title> Simulation of Modern Parallel Systems: A CSIM-based approach. </title> <booktitle> In WSC'97, </booktitle> <pages> pages 10131020, </pages> <month> December </month> <year> 1997. </year>
Reference-contexts: The results of our experiments with single multicast are presented next, followed by the results for our experiments to measure the impact of increasing applied load on multicast latency. 4.1 Experiments and Performance Measures We used a C++/CSIM based simulation testbed <ref> [10] </ref> for our experiments. The simulation testbed models a large number of topologies, and uses cut-through routing as the flow control technique with an input buffer size of 640 flits. For each of our experiments, we assume the following default parameters.
Reference: [11] <author> D. K. Panda, S. Singal, and R. Kesavan. </author> <title> Multidestination Message Passing in Wormhole k-ary n-cube Networks with Base Routing Conformed Paths. </title> <journal> IEEE TPDS, </journal> <note> to appear. </note>
Reference-contexts: However, we assume the multidestination worms under either scheme conform to the base up*/down* routing algorithm, i.e., the path followed by a multicast packet does not violate any of the rules for routing unicast packets in the system <ref> [11] </ref>. These schemes are discussed in greater detail in the following two subsections. 3.2.3 Tree-based Multicasting using Multidestination Worms Tree-based multicasting places no restriction on the replication of a worm at a given switch.
Reference: [12] <author> M. D. Schroeder et al. Autonet: </author> <title> A High-speed, Self-configuring Local Area Network Using Point-to-point Links. </title> <type> Technical Report SRC research report 59, </type> <month> DEC, Apr </month> <year> 1990. </year>
Reference-contexts: Thus, the interconnection topology of the network can be denoted by a graph G = (V,E) where V is the set of switches, and E is the set of bidirectional links between the switches <ref> [1, 12] </ref>. Figure 1 (b) shows the interconnection graph for the irregular network in Fig. 1 (a). <p> be noted that all links are bidirectional and multiple links between two switches are possible. terconnect and irregular topology; (b) corresponding in terconnection graph G; (c) corresponding BFS spanning tree rooted at node 6. 2.2 Routing Issues Several deadlock-free routing schemes have been proposed in the literature for irregular networks <ref> [1, 12] </ref>. Without loss of generality, in this paper we assume the routing scheme for our irregular network to be similar to that used in Autonet [12] due to its simplicity and its commercial implementation. Such routing allows adaptivity, and is deadlock-free. <p> Without loss of generality, in this paper we assume the routing scheme for our irregular network to be similar to that used in Autonet <ref> [12] </ref> due to its simplicity and its commercial implementation. Such routing allows adaptivity, and is deadlock-free. In this routing scheme, a breadth-first spanning tree (BFS) is first computed on the graph G using a distributed algorithm. <p> Putting it in the negative, a packet may never traverse a link along the up direction after having traversed one in the down direction. Details of this routing scheme can be found in <ref> [12] </ref>. 3 Multicasting Approaches We now present an overview of the three multicasting schemes that we compare in this paper. We first describe the traditional approach to multicasting using multiple phases of unicast messages.
Reference: [13] <author> R. Sivaram, R. Kesavan, D. K. Panda, and C. B. Stunkel. </author> <title> Where to Provide Support for Efficient Multicasting in Irregular Networks: Network Interface or Switch? Technical Report OSU-CISRC-02/98-TR05, </title> <institution> The Ohio State University, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: We assume a default packet size of 128 flits, and a default message size of 1 packet. Finally, we assume a default system of 32 nodes that are interconnected by eight 8-port switches in an irregular topology. Our method for generating different irregular topologies is described in <ref> [13] </ref>. Using this method we generated 10 different topologies, and our results are averaged over all these topologies. We use two types of experiments to measure the performance of the three multicasting schemes. <p> We also performed a number of experiments to study the effect of startup overhead at the host, system size, and packet length. However, due to lack of space, these results are not presented. Interested readers may refer to <ref> [13] </ref> for details. 6 4.3 Latency versus Applied Load for Multicast We now present our results for multicast latency under an increasing multicast load for each of the three schemes.
Reference: [14] <author> R. Sivaram, D. K. Panda, and C. B. Stunkel. </author> <title> Multicas-ting in Irregular Networks with Cut-Through Switches using Tree-Based Multidestination Worms. </title> <booktitle> In PCRCW '97, </booktitle> <pages> pages 3548, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Such a method allows messages (christened multidestination messages) to be communicated to multiple destinations incurring a single software overhead for sending the message. There are two subclasses of switch-based multicasting schemes: tree-based <ref> [14] </ref> and path-based [4]. In the best tree-based multicasting scheme, multicast can be performed in a single phase using one multi-destination worm from the source node to all the destinations [14, 15]. The path-based multicasting schemes typically require multiple multidestination worms to perform multicast 1 to arbitrary destination sets. <p> There are two subclasses of switch-based multicasting schemes: tree-based [14] and path-based [4]. In the best tree-based multicasting scheme, multicast can be performed in a single phase using one multi-destination worm from the source node to all the destinations <ref> [14, 15] </ref>. The path-based multicasting schemes typically require multiple multidestination worms to perform multicast 1 to arbitrary destination sets. These worms are transmitted in multiple phases with the destinations in a phase acting as secondary sources in succeeding phases of the multicast [4]. <p> The number of destinations covered depends on the type of encoding/decoding used for the message header. Given support for replication at the switches, there are two schemes that have been proposed for carrying out multicast in switch based irregular networks: tree-based <ref> [14] </ref> and path-based [4]. The two schemes differ in the restrictions placed on worm replication, the number of worms required to perform multicast to an arbitrary destination set, the complexity of multicast header formation, and the complexity of the header decoding logic required at the switches. <p> The basic idea of tree based replication is to have multiple copies of a packet propagate down a tree which has switches as internal vertices and destinations nodes as leaf vertices. Two methods have been proposed for tree-based multicast in irregular networks <ref> [14] </ref>. In this paper, we use the method that uses a single multidestination worm with a bit-string encoded header to perform multicast [14, 15] as a representative of the tree-based multicasting method. <p> Two methods have been proposed for tree-based multicast in irregular networks [14]. In this paper, we use the method that uses a single multidestination worm with a bit-string encoded header to perform multicast <ref> [14, 15] </ref> as a representative of the tree-based multicasting method. The basic idea is to encode the multidestination worm header using an N -bit string where N is the number of nodes in the system. <p> After traveling adaptively to a least common ancestor switch using links in the up direction, a multicast packet is forwarded to those down-ward output ports whose reachability string has one or more `1' bits in the same position (s) as in the packet header <ref> [14] </ref>. using bit-string encoding for a sample multicast. Figure 4 (a) shows the BFS graph of a sample irregular network. Let us assume that there is at least one destination node connected to each of the switches that are highlighted, and that the source node is connected to switch 10.
Reference: [15] <author> C. B. Stunkel, R. Sivaram, and D. K. Panda. </author> <title> Implementing Multidestination Worms in Switch-Based Parallel Systems: Architectural Alternatives and their Impact. </title> <booktitle> In ISCA-24, </booktitle> <pages> pages 5061, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: These schemes can be classified into two main categories. The first category of schemes is referred to as switch-based multicasting schemes. These schemes use enhancements at the routers/switches of the network to allow an incoming packet to be forwarded to multiple output ports of the router/switch <ref> [15] </ref>. Such a method allows messages (christened multidestination messages) to be communicated to multiple destinations incurring a single software overhead for sending the message. There are two subclasses of switch-based multicasting schemes: tree-based [14] and path-based [4]. <p> There are two subclasses of switch-based multicasting schemes: tree-based [14] and path-based [4]. In the best tree-based multicasting scheme, multicast can be performed in a single phase using one multi-destination worm from the source node to all the destinations <ref> [14, 15] </ref>. The path-based multicasting schemes typically require multiple multidestination worms to perform multicast 1 to arbitrary destination sets. These worms are transmitted in multiple phases with the destinations in a phase acting as secondary sources in succeeding phases of the multicast [4]. <p> Two methods have been proposed for tree-based multicast in irregular networks [14]. In this paper, we use the method that uses a single multidestination worm with a bit-string encoded header to perform multicast <ref> [14, 15] </ref> as a representative of the tree-based multicasting method. The basic idea is to encode the multidestination worm header using an N -bit string where N is the number of nodes in the system. <p> We use traffic consisting of multiple concurrent multicasts for our second type of experiments. We apply an increasing load consisting of multicast traffic alone and examine the load at which the network saturates with each of the three multicasting schemes under the influence of the various parameters. As in <ref> [15] </ref>, we use effective applied load as a measure of our stimulus. For a multicast of degree m and a load of B, the effective applied load is mB. 4.2 Single Multicast Performance We now present our results for the effect of single multi-casts on the three different multicasting schemes.
Reference: [16] <author> K. Verstoep, K. Langendoen, and H. Bal. </author> <title> Efficient Reliable Multicast on Myrinet. </title> <booktitle> In ICPP, </booktitle> <pages> pages III:156165, </pages> <month> Aug </month> <year> 1996. </year> <month> 8 </month>
Reference-contexts: The NI-based schemes use enhancements at the network interface so that multicast messages are forwarded to the next destination as soon as they are received at the network interface of an intermediate destination (and the message has begun to be transferred to the memory of the local host) <ref> [16] </ref>. This hides the significant software overhead for receiving a message at an intermediate destination host, and eliminates the overhead at the host for sending the message to other destinations in the succeeding phases of the multicast. <p> Smart NI support can reduce this overhead for multicast, especially for multi-packet messages. Current lean messaging layers allow modification of part of the software running on the NI processor. This part of the software can be modified to allow it to identify a multicast packet <ref> [5, 16] </ref>. If the next outgoing packet in the send queue of the source node is a multicast packet, the NI processor forwards replicas of the packet to the nodes adjacent to the root of the multicast tree. <p> Figure 3 (b) shows such forwarding with smart network interface support. An implementation of such a smart network interface has been described in <ref> [16] </ref>. sage by intermediate node using (a) conventional NI support, and (b) smart NI support. In this paper, we use the FPFS (First-Packet-First-Served) implementation of the smart network interface support [5]. In this implementation, the NI forwards the message on a per-packet basis.
References-found: 16

