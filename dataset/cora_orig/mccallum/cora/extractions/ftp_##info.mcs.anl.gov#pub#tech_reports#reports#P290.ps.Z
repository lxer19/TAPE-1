URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/P290.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts92.htm
Root-URL: http://www.mcs.anl.gov
Title: Information Hiding in Parallel Programs  
Author: Ian Foster 
Keyword: information hiding; parallel programming; program composition; reuse; software cell; template; virtual topology  
Address: Argonne, IL 60439, USA  
Affiliation: Mathematics and Computer Science Division Argonne National Laboratory  
Abstract: A fundamental principle in program design is to isolate difficult or changeable design decisions. Application of this principle to parallel programs requires identification of decisions that are difficult or subject to change, and the development of techniques for hiding these decisions. We experiment with three complex applications, and identify mapping, communication, and scheduling as areas in which decisions are particularly problematic. We develop computational abstractions that hide such decisions, and show that these abstractions can be used to develop elegant solutions to programming problems. In particular, they allow us to encode common structures, such as transforms, reductions, and meshes, as software cells and templates that can reused in different applications. An important characteristic of these structures is that they do not incorporate mapping, communication, or scheduling decisions: these aspects of the design are specified separately, when composing existing structures to form applications. This separation of concerns allows the same cells and templates to be reused in different contexts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agha, G., </author> <title> Actors, </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: These port elements can be used to establish connections to other cells. P [0] P <ref> [1] </ref> P [2] P [3] For brevity, we shall sometimes use the following more compact representation of a cell. <p> ()-1 : `op`(I [i],O [i],S [(i+1)%nodes ()],S [i]) @ node (i) - The process structure created by this procedure can be drawn as follows, with the solid lines indicating the port connections to the outside world and the dotted lines representing internal streams. op op op op O [0] O <ref> [1] </ref> O [2] O [3] I OROR The following procedures implement simple input and output cells. <p> These themes are particularly visible in CSP [19], functional programming [21, 18], concurrent logic programming [10, 16], object-oriented programming <ref> [1] </ref>, and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse.
Reference: [2] <author> Borkar, S., et al., </author> <title> iWarp: An integrated solution to high-speed parallel computing, </title> <booktitle> Proc. Supercomputing Conf., </booktitle> <pages> 330-339, </pages> <year> 1988. </year> <month> 25 </month>
Reference-contexts: These port elements can be used to establish connections to other cells. P [0] P [1] P <ref> [2] </ref> P [3] For brevity, we shall sometimes use the following more compact representation of a cell. <p> `op`(I [i],O [i],S [(i+1)%nodes ()],S [i]) @ node (i) - The process structure created by this procedure can be drawn as follows, with the solid lines indicating the port connections to the outside world and the dotted lines representing internal streams. op op op op O [0] O [1] O <ref> [2] </ref> O [3] I OROR The following procedures implement simple input and output cells. The procedure load reads values from a file and sends them to successive elements of the port array P; the procedure store writes to a file values received on successive elements of port array Q. <p> For example, a software cell is not restricted to two dimensions and need not be mapped to contiguous processors; software cells and wires can overlap. Concepts similar to our software cells and ports have been proposed by several researchers, notably the iWARP group <ref> [2] </ref>, Griswold et al. [17], and Browne et al. [4]. The focus of iWARP is the generation of efficient programs for a systolic processor. Hence, the forms of programs that can be specified is limited: the contiguous submesh is the only topology supported and the number of channels is limited.
Reference: [3] <author> Brinch Hansen, P., </author> <title> Joyce | a programming language for distributed systems, Softw. </title> <editor> P. and E., </editor> <volume> 17, </volume> <pages> 29-50, </pages> <year> 1987. </year>
Reference-contexts: These port elements can be used to establish connections to other cells. P [0] P [1] P [2] P <ref> [3] </ref> For brevity, we shall sometimes use the following more compact representation of a cell. <p> [i],S [(i+1)%nodes ()],S [i]) @ node (i) - The process structure created by this procedure can be drawn as follows, with the solid lines indicating the port connections to the outside world and the dotted lines representing internal streams. op op op op O [0] O [1] O [2] O <ref> [3] </ref> I OROR The following procedures implement simple input and output cells. The procedure load reads values from a file and sends them to successive elements of the port array P; the procedure store writes to a file values received on successive elements of port array Q. <p> However, for a variety of reasons, they do not support the same forms of composition and reuse. CSP's processes and channels cannot be created dynamically or communicated in messages. Some of these restrictions can be removed <ref> [3] </ref>, but the overall model is static rather than dynamic. We have not emphasized the dynamic aspect of our approach in this paper, but in practice we frequently generate or change the configuration of software cells during program execution.
Reference: [4] <author> Browne, J., Werth, J., and Lee, T., </author> <title> Intersection of parallel structuring and reuse of software components, </title> <booktitle> Proc. Intl Conf. on Parallel Processing, </booktitle> <address> Penn. </address> <publisher> State Press, </publisher> <year> 1989. </year>
Reference-contexts: Concepts similar to our software cells and ports have been proposed by several researchers, notably the iWARP group [2], Griswold et al. [17], and Browne et al. <ref> [4] </ref>. The focus of iWARP is the generation of efficient programs for a systolic processor. Hence, the forms of programs that can be specified is limited: the contiguous submesh is the only topology supported and the number of channels is limited.
Reference: [5] <author> Browning, G., Hack, J., and Swarztrauber, P., </author> <title> A comparison of three numerical methods for solving differential equations on the sphere, </title> <journal> Mon. Wea. Rev., </journal> <volume> 117 (5), </volume> <year> 1989. </year>
Reference-contexts: Space does not permit more than a cursory description of the methods themselves; the interested reader is referred to the excellent comparative article by Browning, Hack, and Swarztrauber <ref> [5] </ref>. All three algorithms have been implemented and extensively evaluated on parallel computers, including the 528-processor, 20-Gflops Intel DELTA supercomputer [9, 12, 27]. 2.1 Spectral Transform Algorithm The spectral transform method is popular because of its spectral accuracy and its avoidance of the pole problem.
Reference: [6] <author> Chandy, C., and Taylor, S., </author> <title> An Introduction to Parallel Programming, </title> <editor> Jones and Bartlett, </editor> <year> 1991. </year>
Reference-contexts: Run-time support required by the abstractions can be developed on an ad-hoc basis for each application, integrated into message-passing tools, or encapsulated in programming language constructs. We prefer the third approach, and have developed programming language support for the abstractions for both Fortran and the concurrent language PCN <ref> [6, 14] </ref>. Here, we work with PCN, which is supported by a public-domain compiler developed at Argonne National Laboratory and Caltech [15]. 1 The rest of the paper is as follows. In Section 2, we present the three atmospheric modeling algorithms used in programming experiments. <p> The language constructs required to support the abstractions are not complex and can in principle be defined for any language. For example, we have defined appropriate extensions for both Fortran and the high-level concurrent language Program Composition Notation (PCN) <ref> [6, 14] </ref>. We choose to work with PCN here, as this already provides elegant representations of virtual channels and lightweight processes and can be extended straightforwardly to support virtual topologies and port arrays.
Reference: [7] <author> Chandy, K. M., and Misra, J. </author> <title> Parallel Program Design, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: These themes are particularly visible in CSP [19], functional programming [21, 18], concurrent logic programming [10, 16], object-oriented programming [1], and Unity <ref> [7] </ref>. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse. CSP's processes and channels cannot be created dynamically or communicated in messages.
Reference: [8] <author> Chien, A., and Dally, W., </author> <title> Concurrent Aggregates, </title> <booktitle> Proc. ACM Symp. on Principles and Practice of Parallel Programming, ACM, </booktitle> <year> 1990, </year> <pages> 187-196. </pages>
Reference-contexts: However, the important concepts of mapping function and software cells are absent from these proposals. Chien and Dally's Concurrent Aggregates (CA) language allows the definition of homogeneous collections of objects called aggregates; messages addressed to an aggregate are routed to one of its members <ref> [8] </ref>. As in our proposal, concurrent structures can be defined and composed with other structures to build concurrent programs. However, issues associated with spatial organization of such structures are not addressed.
Reference: [9] <author> Chern, I., and Foster, I., </author> <title> Design and parallel implementation of two methods for solving PDEs on the sphere, </title> <booktitle> Proc. Conf. on Parallel Computational Fluid Dynamics, </booktitle> <address> Stuttgart, Germany, </address> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1991. </year>
Reference-contexts: Space does not permit more than a cursory description of the methods themselves; the interested reader is referred to the excellent comparative article by Browning, Hack, and Swarztrauber [5]. All three algorithms have been implemented and extensively evaluated on parallel computers, including the 528-processor, 20-Gflops Intel DELTA supercomputer <ref> [9, 12, 27] </ref>. 2.1 Spectral Transform Algorithm The spectral transform method is popular because of its spectral accuracy and its avoidance of the pole problem. <p> At each point, we connect by geodesic curves the centroids of the neighboring triangles to produce the hexagons or pentagons that serve as the control area elements for numerical integration <ref> [9] </ref>. For convenience in implementation, each triangle is joined with one of its neighbors to form a rhombus; each of these 10 rhombi then contains an N fi N mesh. <p> The use of hexagonal and pentagonal control elements means that computation at each point requires data from either five or six neighboring points. For simplicity in exposition, we shall assume a five-point stencil in subsequent discussion. However, the extension to the mixed six/seven-point stencil is straightforward <ref> [9] </ref>. We obtain a parallel algorithm by decomposing each nonpolar rhombus into a number 4 (say C 2 ) of subrhombi. This gives a total of 10C 2 + 2 subdomains: 10C 2 meshes con-taining (N=C) 2 points and two individual points (the polar rhombi). <p> We have observed that on modern multicomputers such as the 528-node Intel Touchstone DELTA, performance is not particularly sensitive to the mapping employed <ref> [9] </ref>, as high-performance communication reduces the importance of locality.
Reference: [10] <author> Clark, K., and Gregory, S., </author> <title> A relational language for parallel programming, </title> <booktitle> Proc. 1981 ACM Conf. on Functional Programming Languages and Computer Architectures, </booktitle> <year> 1981, </year> <pages> 171-178. </pages>
Reference-contexts: These themes are particularly visible in CSP [19], functional programming [21, 18], concurrent logic programming <ref> [10, 16] </ref>, object-oriented programming [1], and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse.
Reference: [11] <author> Dally, W. J., et al., </author> <title> The J-Machine: A fine-grain concurrent computer, Information Processing 89, </title> <editor> G. X. Ritter (ed.), </editor> <publisher> Elsevier Science Publishers B.V., North Holland, IFIP, </publisher> <year> 1989. </year>
Reference-contexts: We now examine how virtual topologies, virtual channels, lightweight processes, and port arrays can be used to develop parallel programs. Although some multicomputers and operating systems incorporate certain of these abstractions as primitive mechanisms <ref> [25, 11, 28] </ref>, it will in general be necessary to provide compile-time or run-time support. There is much to be gained from standardizing this support so that it can be reused in many applications. It is also desirable to define interfaces that encourage or enforce correct usage.
Reference: [12] <author> Foster, I., Gropp, W., and Stevens, R., </author> <title> The parallel scalability of the spectral transform method, </title> <journal> Mon. Wea. Rev., </journal> <month> March </month> <year> 1992. </year>
Reference-contexts: Space does not permit more than a cursory description of the methods themselves; the interested reader is referred to the excellent comparative article by Browning, Hack, and Swarztrauber [5]. All three algorithms have been implemented and extensively evaluated on parallel computers, including the 528-processor, 20-Gflops Intel DELTA supercomputer <ref> [9, 12, 27] </ref>. 2.1 Spectral Transform Algorithm The spectral transform method is popular because of its spectral accuracy and its avoidance of the pole problem. <p> We obtain a parallel algorithm by decomposing the latitude/longitude mesh in two dimensions to obtain equal-sized submeshes. Other data structures are also decomposed appropriately. Parallel FFTs must be performed between submeshes containing the same latitude, and parallel summations between submeshes containing the same longitude <ref> [12, 27] </ref>. In addition, parallel reductions over the entire mesh are required to produce diagnostic quantities. The subdomains produced by decomposition can be mapped to the nodes of a parallel computer in several ways. <p> The second mapping clusters nodes involved in the same FFT, while the third mapping clusters nodes involved in the same summation. The optimal mapping depends on machine architecture, problem size, and other factors <ref> [12] </ref>. 3 0 1 2 3 8 9 10 11 0 1 4 5 8 9 12 13 0 1 2 3 4 5 6 7 0 4 1 5 2 6 3 7 FFT (1) (3) 2.2 Control Volume/Icosahedral Mesh Algorithm The icosahedral method is an explicit grid-point method and
Reference: [13] <author> Foster, I., Kesselman, C., and Taylor, S., </author> <title> Concurrency: Simple concepts and powerful tools, </title> <journal> The Computer Journal, </journal> <volume> 33(6) </volume> <pages> 501-507, </pages> <year> 1990. </year>
Reference-contexts: In this respect, the work complements and extends previous work <ref> [13] </ref>, in which virtual channels and lightweight processes were used to decouple mapping, communication, and scheduling decisions, but cells and templates were not supported. Run-time support required by the abstractions can be developed on an ad-hoc basis for each application, integrated into message-passing tools, or encapsulated in programming language constructs.
Reference: [14] <author> Foster, I., Olson, R., and Tuecke, S., </author> <title> Productive parallel programming: The PCN approach, Scientific Programming, </title> <type> 1(1), </type> <note> 1992 (in press). </note>
Reference-contexts: Run-time support required by the abstractions can be developed on an ad-hoc basis for each application, integrated into message-passing tools, or encapsulated in programming language constructs. We prefer the third approach, and have developed programming language support for the abstractions for both Fortran and the concurrent language PCN <ref> [6, 14] </ref>. Here, we work with PCN, which is supported by a public-domain compiler developed at Argonne National Laboratory and Caltech [15]. 1 The rest of the paper is as follows. In Section 2, we present the three atmospheric modeling algorithms used in programming experiments. <p> The language constructs required to support the abstractions are not complex and can in principle be defined for any language. For example, we have defined appropriate extensions for both Fortran and the high-level concurrent language Program Composition Notation (PCN) <ref> [6, 14] </ref>. We choose to work with PCN here, as this already provides elegant representations of virtual channels and lightweight processes and can be extended straightforwardly to support virtual topologies and port arrays.
Reference: [15] <author> Foster, I., and Taylor, S., </author> <title> A compiler approach to scalable concurrent program design, </title> <type> Technical Report, </type> <institution> Argonne National Laboratory, </institution> <year> 1992. </year>
Reference-contexts: We prefer the third approach, and have developed programming language support for the abstractions for both Fortran and the concurrent language PCN [6, 14]. Here, we work with PCN, which is supported by a public-domain compiler developed at Argonne National Laboratory and Caltech <ref> [15] </ref>. 1 The rest of the paper is as follows. In Section 2, we present the three atmospheric modeling algorithms used in programming experiments. In Sections 3 and 4, we analyze design problems in these algorithms and introduce the computational abstractions that we use to overcome these problems.
Reference: [16] <author> Gregory, S., </author> <title> Parallel Logic Programming in PARLOG, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: These themes are particularly visible in CSP [19], functional programming [21, 18], concurrent logic programming <ref> [10, 16] </ref>, object-oriented programming [1], and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse.
Reference: [17] <author> Griswold, W., Harrison, G., Notkin, D., and Snyder, L., </author> <title> Port ensembles: A communication abstraction for nonshared memory parallel programming, </title> <booktitle> Proc. Intl Conf. on Parallel Processing, </booktitle> <address> Penn. </address> <publisher> State Press, </publisher> <year> 1990. </year>
Reference-contexts: For example, a software cell is not restricted to two dimensions and need not be mapped to contiguous processors; software cells and wires can overlap. Concepts similar to our software cells and ports have been proposed by several researchers, notably the iWARP group [2], Griswold et al. <ref> [17] </ref>, and Browne et al. [4]. The focus of iWARP is the generation of efficient programs for a systolic processor. Hence, the forms of programs that can be specified is limited: the contiguous submesh is the only topology supported and the number of channels is limited.
Reference: [18] <author> Henderson, P., </author> <title> Functional Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year> <month> 26 </month>
Reference-contexts: These themes are particularly visible in CSP [19], functional programming <ref> [21, 18] </ref>, concurrent logic programming [10, 16], object-oriented programming [1], and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse.
Reference: [19] <author> Hoare, C., </author> <title> Communicating sequential processes, </title> <journal> CACM, </journal> <volume> 21(8), </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: These themes are particularly visible in CSP <ref> [19] </ref>, functional programming [21, 18], concurrent logic programming [10, 16], object-oriented programming [1], and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper.
Reference: [20] <author> Hudak, P., </author> <title> Para-functional programming, </title> <booktitle> IEEE Computer, </booktitle> <pages> 60-70, </pages> <month> Aug </month> <year> 1986. </year>
Reference-contexts: Browne et al. propose a compositional calculus for specifying interconnections between software chips. The integration of this calculus into a programming notation is not discussed, and the notion of virtual topology is absent. The use of virtual topologies to abstract mapping decisions was first proposed by Martin [22]. Hudak <ref> [20] </ref> and Taylor [26], among others, have used similar ideas to specify mapping decisions in declarative programming systems. In Hudak's scheme, arbitrary integer functions can be used to specify both relative and absolute locations. Taylor uses them to specify relative locations in an infinite computing surface.
Reference: [21] <author> Kahn, G., </author> <title> The semantics of a simple language for parallel programming, </title> <booktitle> Proc. IFIP Congress '74, </booktitle> <publisher> North Holland, </publisher> <year> 1974. </year>
Reference-contexts: These themes are particularly visible in CSP [19], functional programming <ref> [21, 18] </ref>, concurrent logic programming [10, 16], object-oriented programming [1], and Unity [7]. Most of these systems are based on lightweight process and message-passing ideas similar to those explored in this paper. However, for a variety of reasons, they do not support the same forms of composition and reuse.
Reference: [22] <author> Martin, A., </author> <title> The torus: An exercise in constructing a processing surface, </title> <booktitle> Proc. Conf. on VLSI, Caltech, </booktitle> <pages> 52-57, </pages> <month> Jan. </month> <year> 1979. </year>
Reference-contexts: Browne et al. propose a compositional calculus for specifying interconnections between software chips. The integration of this calculus into a programming notation is not discussed, and the notion of virtual topology is absent. The use of virtual topologies to abstract mapping decisions was first proposed by Martin <ref> [22] </ref>. Hudak [20] and Taylor [26], among others, have used similar ideas to specify mapping decisions in declarative programming systems. In Hudak's scheme, arbitrary integer functions can be used to specify both relative and absolute locations. Taylor uses them to specify relative locations in an infinite computing surface.
Reference: [23] <author> Mead, C., and Conway, L., </author> <title> Introduction to VLSI Systems, </title> <publisher> Addison Wesley, </publisher> <year> 1980. </year>
Reference-contexts: In concurrent object-oriented programming, the concept of a channel is absent, making it difficult to specify deterministic computations. There are clearly similarities between our ideas and fundamental concepts of VLSI design <ref> [23] </ref>. In particular, the notions of cell and port are used in an analogous manner, 23 to control complexity in large circuits. However, it is important not to be misled by the obvious analogies. Software is more flexible than hardware and admits more general and elegant solutions to many problems.
Reference: [24] <author> Parnas, D., </author> <title> On the criteria to be used in decomposing systems into modules, </title> <journal> CACM 15(2), </journal> <pages> 1053-1058, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction A fundamental principle in program design is to isolate difficult or changeable design decisions, so that interfaces between program components are simple and unlikely to change <ref> [24] </ref>. Application of this principle has been found to reduce design complexity, facilitate reuse of components, and decrease the cost of modifications. In sequential programming, good programmers routinely hide decisions concerned with data structures, storage management, and hardware-dependent features.
Reference: [25] <author> Seitz, C. L., </author> <title> Multicomputers, Developments in Concurrency and Communication, C.A.R. </title> <editor> Hoare (ed.), </editor> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: We now examine how virtual topologies, virtual channels, lightweight processes, and port arrays can be used to develop parallel programs. Although some multicomputers and operating systems incorporate certain of these abstractions as primitive mechanisms <ref> [25, 11, 28] </ref>, it will in general be necessary to provide compile-time or run-time support. There is much to be gained from standardizing this support so that it can be reused in many applications. It is also desirable to define interfaces that encourage or enforce correct usage.
Reference: [26] <author> Taylor, S., </author> <title> Parallel Logic Programming Techniques, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The integration of this calculus into a programming notation is not discussed, and the notion of virtual topology is absent. The use of virtual topologies to abstract mapping decisions was first proposed by Martin [22]. Hudak [20] and Taylor <ref> [26] </ref>, among others, have used similar ideas to specify mapping decisions in declarative programming systems. In Hudak's scheme, arbitrary integer functions can be used to specify both relative and absolute locations. Taylor uses them to specify relative locations in an infinite computing surface.
Reference: [27] <author> Walker, D., Drake, J., and Worley, P., </author> <title> Parallelizing the spectral transform method | Part II, </title> <type> Tech. Rep. </type> <institution> ORNL/TM-11855, Oak Ridge National Laboratory, Oak Ridge, Tenn., </institution> <year> 1991. </year> <note> (Available from DOE Office of Scientific and Technical Information.) </note>
Reference-contexts: Space does not permit more than a cursory description of the methods themselves; the interested reader is referred to the excellent comparative article by Browning, Hack, and Swarztrauber [5]. All three algorithms have been implemented and extensively evaluated on parallel computers, including the 528-processor, 20-Gflops Intel DELTA supercomputer <ref> [9, 12, 27] </ref>. 2.1 Spectral Transform Algorithm The spectral transform method is popular because of its spectral accuracy and its avoidance of the pole problem. <p> We obtain a parallel algorithm by decomposing the latitude/longitude mesh in two dimensions to obtain equal-sized submeshes. Other data structures are also decomposed appropriately. Parallel FFTs must be performed between submeshes containing the same latitude, and parallel summations between submeshes containing the same longitude <ref> [12, 27] </ref>. In addition, parallel reductions over the entire mesh are required to produce diagnostic quantities. The subdomains produced by decomposition can be mapped to the nodes of a parallel computer in several ways.
Reference: [28] <author> Young, M., et al., </author> <title> The duality of memory and communication in Mach, </title> <booktitle> Proc. 11th Symp. on Operating System Principles, ACM, </booktitle> <pages> 63-76, </pages> <year> 1987. </year>
Reference-contexts: We now examine how virtual topologies, virtual channels, lightweight processes, and port arrays can be used to develop parallel programs. Although some multicomputers and operating systems incorporate certain of these abstractions as primitive mechanisms <ref> [25, 11, 28] </ref>, it will in general be necessary to provide compile-time or run-time support. There is much to be gained from standardizing this support so that it can be reused in many applications. It is also desirable to define interfaces that encourage or enforce correct usage.
References-found: 28

