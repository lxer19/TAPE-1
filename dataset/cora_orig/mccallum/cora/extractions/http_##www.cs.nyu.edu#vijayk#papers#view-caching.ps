URL: http://www.cs.nyu.edu/vijayk/papers/view-caching.ps
Refering-URL: http://www.cs.nyu.edu/vijayk/papers.html
Root-URL: http://www.cs.nyu.edu
Title: View Caching: Efficient Software Shared Memory for Dynamic Computations  
Author: Vijay Karamcheti and Andrew A. Chien 
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Software distributed shared memory (DSM) techniques, while effective on applications with coarse-grained sharing, yield poor performance for the fine-grained sharing encountered in applications increasingly relying on sophisticated adaptive and hierarchical algorithms. Such applications exhibit irregular communication patterns unsynchronized with computation, incurring large overheads for synchronous (request-reply) DSM protocols that require responsive processing of coherence messages. We describe a new DSM framework, View Caching, that addresses this problem by utilizing application knowledge of data access semantics to enable the construction of low-overhead, asynchronous coherence protocols. Experiments on the Cray T3D show that view caching enables efficient execution of fine-grained irregular applications, reducing both coherence overheads and idle time to improve performance by up to 35% over a weakly-consistent DSM implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. N. Bershad, M. J. Zekauskas, and W. A. Sawdon. </author> <title> The Midway distributed shared memory system. </title> <booktitle> In Proceedings of COMPCON, </booktitle> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: However, the fine-grained and dynamic nature of compu tation limits the effectiveness of existing DSM implementations. The former rules out relatively high-overhead DSM schemes, while the latter produces unpredictable communication unsynchronized with computation, leading to arbitrary delays in coherence message processing. Current DSM systems <ref> [14, 1, 16, 12] </ref> rely on weak consistency models to reduce coherence traffic, but still retain the synchronous (request-reply) nature of hardware cache-coherence protocols and require responsive processing of coherence messages for performance. Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. <p> The language semantics permit the use of a weaker consistency model object consistency. Object consistency, a variant of entry consistency <ref> [1] </ref>, guarantees that updates made to a shared object on one processor are visible on another at the time of method entry. <p> Together, they result in arbitrary unresponsiveness to coherence requests, either because processors are busy computing or due to contention from several coherence requests. While several DSM solutions have been proposed, few efficiently support fine-grained sharing in a dynamic context. Systems such as TreadMarks [14], Midway <ref> [1] </ref>, SAM [16], and CRL [12] rely on weak consistency models for performance. However, such systems all use request-reply protocols derived from hardware cache coherence protocols, requiring prompt servicing of coherence requests (similar to dedicated hardware cache controllers).
Reference: [2] <author> B. </author> <title> Buchberger. Grobner basis: an algorithmic method in polynomial ideal theory. In Multidimensional Systems The ory. </title> <address> D. </address> <publisher> Reidel Publishing Company, </publisher> <year> 1985. </year>
Reference-contexts: Examples of using application knowledge to customize coherence protocols. to coherence protocols. Comparing put/get and messaging implementations quantifies the incremental performance benefits of low-overhead communication primitives. 4.1 Grobner Grobner basis <ref> [2] </ref> calculation is a fundamental tool for symbolic algebra. Our algorithm, previously implemented by Chakrabarti [4], repeatedly augments the basis by evaluating polynomial pairs (to isolate irreducible terms) formed from the existing basis members.
Reference: [3] <author> J. Carter, J. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the Sympo sium on Operating Systems Principles, </booktitle> <year> 1991. </year>
Reference-contexts: Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. Other DSM techniques [8, 15] which optimize synchronous protocols by predicting object access patterns are less effective given the dynamic context. Recent systems <ref> [3, 11] </ref> which allow application customization of coherence protocols provide mechanisms for improving performance, but offer little insight into how to build protocols for tolerating coherence processing delays arising from unresponsive processors. <p> These solutions eliminate coherence operations from the critical path and replace synchronous protocols with asynchronous ones. However, such optimizations are less effective in our dynamic context where predictive information about future object accesses is hard to obtain. More promising are systems such as Munin <ref> [3] </ref> and Tempest [11] which allow application-specific customization of coherence protocols. Munin allows custom coherence actions for shared regions by selecting from among a set of predefined coherence protocols that reflect common application sharing scenarios. <p> View caching differs from other DSM systems supporting protocol customization in several key aspects. Unlike Munin <ref> [3] </ref>, view caching associates custom protocols with views (methods), allowing different accesses of a shared region to be subject to different coherence protocols. As we shall see in x4, treating each view as an independent coherence unit provides additional opportunities for optimization.
Reference: [4] <author> S. Chakrabarti and K. Yelick. </author> <title> Implementing an irregular application on a distributed memory multiprocessor. </title> <booktitle> In Pro ceedings of the Fourth Symposium on Principles and Prac tices of Parallel Programming, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Examples of using application knowledge to customize coherence protocols. to coherence protocols. Comparing put/get and messaging implementations quantifies the incremental performance benefits of low-overhead communication primitives. 4.1 Grobner Grobner basis [2] calculation is a fundamental tool for symbolic algebra. Our algorithm, previously implemented by Chakrabarti <ref> [4] </ref>, repeatedly augments the basis by evaluating polynomial pairs (to isolate irreducible terms) formed from the existing basis members. Polynomial pair evaluation, expressed as a dynamic thread in ICC++, is priority scheduled and requires access to the basis as well as the basis polynomials (shown in Figure 1). <p> The second view accesses polynomials that are known not to change after creation. The corresponding custom protocol completes access-grant entirely on the requester, does not require access-revoke, and implements data-transfer using one-sided communication. VC-M achieves a speedup of 7.75x which is comparable to the performance achieved by Chakrabarti <ref> [4] </ref> using explicit data replication. The execution time breakdowns (shown normalized with respect to the ideal speedup) provide an explanation for performance improvement. View caching reduces both coherence overhead (up to 10%) as well as processor idle time (up to 20%).
Reference: [5] <author> H. Cheong and A. V. Veidenbaum. </author> <title> Compiler-directed cache management in multiprocessors. </title> <journal> IEEE Computer, </journal> <volume> 23(6):39 48, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: The unresponsiveness described above degrades the performance of such systems by increasing the time processors idle awaiting completion of remote coherence actions. Some DSM systems <ref> [8, 15, 5] </ref> predict access requests and eagerly create an object copy on the requesting proces sor. These solutions eliminate coherence operations from the critical path and replace synchronous protocols with asynchronous ones.
Reference: [6] <author> A. Chien, V. Karamcheti, and J. Plevyak. </author> <title> The Concert systemcompiler and runtime support for efficient fine grained concurrent object-oriented programs. </title> <type> Tech. Rep. </type> <institution> UIUCDCS-R-93-1815, University of Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: coherence protocol optimizations based on the high-level access semantics of user-defined datatypes. 4 View caching performance We compare performance of view caching with an object-consistent DSM for two irregular ICC++ [7] applications Grobner and Radiosity. 1 All experiments were performed on the Cray T3D and use the Illinois Concert System <ref> [6] </ref> which consists of an optimizing compiler and a high-performance runtime. Programmer annotations guide selection of view caching protocols. We consider four alternative DSM implementations: 1. Object-consistent DSM (messaging) (OC-M): proto cols use a messaging interface to the hardware [13]. 2.
Reference: [7] <author> A. A. Chien, U. S. Reddy, J. Plevyak, and J. Dolby. </author> <title> ICC++ a C++ dialect for high-performance parallel computation. </title> <booktitle> In Proceedings of the 2nd International Symposium on Object Technologies for Advanced Software, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Such computations are becoming important due to the emphasis on sophisticated adaptive algorithms and irregular pointer-based data structures which significantly reduce sequential work by focusing computational effort where necessary. These computations are frequently expressed using a high-level programming approach (exemplified by concurrent object-oriented <ref> [7, 18] </ref> and multithreaded [9] systems) as a dynamic collection of light-weight threads operating in a shared object space. The dynamic nature precludes object placement to minimize communication, so efficiency demands effective runtime caching of remote object accesses. <p> as follows: x2 discusses limitations of existing DSM approaches to motivate the view caching framework described in x3. x4 presents view caching performance, and we conclude in x5. 2 Background and related work We focus on efficiently supporting fine-grained sharing in irregular computations expressed using a concurrent object-oriented language ICC++ <ref> [7] </ref>. The programming model supports dynamic thread creation in a shared object space (represented by method invocations against concurrent objects), facilitating the natural expression of a variety of synchronization and communication structures. The language semantics permit the use of a weaker consistency model object consistency. <p> Finally, although our customization procedure resembles Munin's, it permits a larger variety of coherence protocol optimizations based on the high-level access semantics of user-defined datatypes. 4 View caching performance We compare performance of view caching with an object-consistent DSM for two irregular ICC++ <ref> [7] </ref> applications Grobner and Radiosity. 1 All experiments were performed on the Cray T3D and use the Illinois Concert System [6] which consists of an optimizing compiler and a high-performance runtime. Programmer annotations guide selection of view caching protocols. We consider four alternative DSM implementations: 1.
Reference: [8] <author> A. L. Cox and R. J. Fowler. </author> <title> Adaptive cache coherency for detecting migratory shared data. </title> <booktitle> In Proceedings of the Inter national Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. Other DSM techniques <ref> [8, 15] </ref> which optimize synchronous protocols by predicting object access patterns are less effective given the dynamic context. <p> The unresponsiveness described above degrades the performance of such systems by increasing the time processors idle awaiting completion of remote coherence actions. Some DSM systems <ref> [8, 15, 5] </ref> predict access requests and eagerly create an object copy on the requesting proces sor. These solutions eliminate coherence operations from the critical path and replace synchronous protocols with asynchronous ones.
Reference: [9] <author> I. Foster, C. Kesselman, and S. Tuecke. </author> <title> The Nexus approach to integrating multithreading and communication. </title> <journal> J. Parallel and Distributed Computing, </journal> <year> 1996. </year>
Reference-contexts: Such computations are becoming important due to the emphasis on sophisticated adaptive algorithms and irregular pointer-based data structures which significantly reduce sequential work by focusing computational effort where necessary. These computations are frequently expressed using a high-level programming approach (exemplified by concurrent object-oriented [7, 18] and multithreaded <ref> [9] </ref> systems) as a dynamic collection of light-weight threads operating in a shared object space. The dynamic nature precludes object placement to minimize communication, so efficiency demands effective runtime caching of remote object accesses. However, the fine-grained and dynamic nature of compu tation limits the effectiveness of existing DSM implementations.
Reference: [10] <author> P. Hanrahan, D. Salzman, and L. Aupperle. </author> <title> A rapid hierar chical radiosity algorithm. </title> <booktitle> Computer Graphics (Proc Sig graph), </booktitle> <address> 25(4):197206, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: In contrast, OC-P still requires coherence requests to be processed in software. 4.2 Radiosity Radiosity computes the global illumination in a scene by expressing the radiosity of an elemental surface patch as a weighted linear function of radiosities of all other patches. Our algorithm, due to Hanrahan <ref> [10] </ref>, computes light transport between potentially visible pairs of patches, hierarchically subdividing a patch as needed to ensure accuracy.
Reference: [11] <author> M. D. Hill, J. R. Larus, and D. A. Wood. </author> <title> Tempest: A substrate for portable parallel programs. </title> <booktitle> In Proceedings of COMPCON, </booktitle> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. Other DSM techniques [8, 15] which optimize synchronous protocols by predicting object access patterns are less effective given the dynamic context. Recent systems <ref> [3, 11] </ref> which allow application customization of coherence protocols provide mechanisms for improving performance, but offer little insight into how to build protocols for tolerating coherence processing delays arising from unresponsive processors. <p> These solutions eliminate coherence operations from the critical path and replace synchronous protocols with asynchronous ones. However, such optimizations are less effective in our dynamic context where predictive information about future object accesses is hard to obtain. More promising are systems such as Munin [3] and Tempest <ref> [11] </ref> which allow application-specific customization of coherence protocols. Munin allows custom coherence actions for shared regions by selecting from among a set of predefined coherence protocols that reflect common application sharing scenarios. <p> Unlike Munin [3], view caching associates custom protocols with views (methods), allowing different accesses of a shared region to be subject to different coherence protocols. As we shall see in x4, treating each view as an independent coherence unit provides additional opportunities for optimization. Unlike Tempest <ref> [11] </ref> which only provides mechanisms, our approach makes the case for a specific kind of customization reducing synchronization requirements of coherence protocols as being important for high performance DSM in the context of dynamic computations.
Reference: [12] <author> K. L. Johnson, M. F. Kaashoek, and D. A. Wallach. </author> <title> CRL: High-performance all-software distributed shared memory. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: However, the fine-grained and dynamic nature of compu tation limits the effectiveness of existing DSM implementations. The former rules out relatively high-overhead DSM schemes, while the latter produces unpredictable communication unsynchronized with computation, leading to arbitrary delays in coherence message processing. Current DSM systems <ref> [14, 1, 16, 12] </ref> rely on weak consistency models to reduce coherence traffic, but still retain the synchronous (request-reply) nature of hardware cache-coherence protocols and require responsive processing of coherence messages for performance. Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. <p> While several DSM solutions have been proposed, few efficiently support fine-grained sharing in a dynamic context. Systems such as TreadMarks [14], Midway [1], SAM [16], and CRL <ref> [12] </ref> rely on weak consistency models for performance. However, such systems all use request-reply protocols derived from hardware cache coherence protocols, requiring prompt servicing of coherence requests (similar to dedicated hardware cache controllers).
Reference: [13] <author> V. Karamcheti and A. A. Chien. </author> <title> A comparison of archi tectural support for messaging on the TMC CM-5 and the Cray T3D. </title> <booktitle> In Proceedings of the International Symposium on Computer Architecture, </booktitle> <year> 1995. </year>
Reference-contexts: Coherence protocols are built by assembling customized implementations of these components; application knowledge about data access semantics drives this customization, focusing particularly on decreasing message traffic and required synchronization. Reducing synchronization enables use of one-sided messages that can be efficiently supported in software (see <ref> [13] </ref>), or directly in hardware using the put/get support available in several current-day parallel machines. To keep customization manageable, our framework only permits selection from among a predefined set of component implementations by specifying values for a series of parameters. <p> Programmer annotations guide selection of view caching protocols. We consider four alternative DSM implementations: 1. Object-consistent DSM (messaging) (OC-M): proto cols use a messaging interface to the hardware <ref> [13] </ref>. 2. Object-consistent DSM (put/get) (OC-P): protocols utilize T3D's remote memory access capabilities. 3. View caching (messaging) (VC-M). 4. View caching (put/get) (VC-P).
Reference: [14] <author> P. Keleher, A. L. Cox, S. Dwarkadas, and W. Zwaenopol. Treadmarks: </author> <title> Distributed shared memory on standard work stations and operating systems. </title> <booktitle> In Proceedings of the 1994 Winter Usenix Conference, </booktitle> <pages> pages 115132, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: However, the fine-grained and dynamic nature of compu tation limits the effectiveness of existing DSM implementations. The former rules out relatively high-overhead DSM schemes, while the latter produces unpredictable communication unsynchronized with computation, leading to arbitrary delays in coherence message processing. Current DSM systems <ref> [14, 1, 16, 12] </ref> rely on weak consistency models to reduce coherence traffic, but still retain the synchronous (request-reply) nature of hardware cache-coherence protocols and require responsive processing of coherence messages for performance. Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. <p> Together, they result in arbitrary unresponsiveness to coherence requests, either because processors are busy computing or due to contention from several coherence requests. While several DSM solutions have been proposed, few efficiently support fine-grained sharing in a dynamic context. Systems such as TreadMarks <ref> [14] </ref>, Midway [1], SAM [16], and CRL [12] rely on weak consistency models for performance. However, such systems all use request-reply protocols derived from hardware cache coherence protocols, requiring prompt servicing of coherence requests (similar to dedicated hardware cache controllers).
Reference: [15] <author> T. Mowry and A. Gupta. </author> <title> Tolerating latency through software controlled prefetching in shared-memory multiprocessors. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 12:87106, </volume> <year> 1991. </year>
Reference-contexts: Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. Other DSM techniques <ref> [8, 15] </ref> which optimize synchronous protocols by predicting object access patterns are less effective given the dynamic context. <p> The unresponsiveness described above degrades the performance of such systems by increasing the time processors idle awaiting completion of remote coherence actions. Some DSM systems <ref> [8, 15, 5] </ref> predict access requests and eagerly create an object copy on the requesting proces sor. These solutions eliminate coherence operations from the critical path and replace synchronous protocols with asynchronous ones.
Reference: [16] <author> D. J. Scales and M. S. Lam. </author> <title> The design and evaluation of a shared object system for distributed memory machines. </title> <booktitle> In First Symposium on Operating Systems Design and Imple mentation, </booktitle> <year> 1994. </year>
Reference-contexts: However, the fine-grained and dynamic nature of compu tation limits the effectiveness of existing DSM implementations. The former rules out relatively high-overhead DSM schemes, while the latter produces unpredictable communication unsynchronized with computation, leading to arbitrary delays in coherence message processing. Current DSM systems <ref> [14, 1, 16, 12] </ref> rely on weak consistency models to reduce coherence traffic, but still retain the synchronous (request-reply) nature of hardware cache-coherence protocols and require responsive processing of coherence messages for performance. Poor responsiveness degrades performance by increasing the time a processor idles awaiting completion of a coherence operation. <p> Together, they result in arbitrary unresponsiveness to coherence requests, either because processors are busy computing or due to contention from several coherence requests. While several DSM solutions have been proposed, few efficiently support fine-grained sharing in a dynamic context. Systems such as TreadMarks [14], Midway [1], SAM <ref> [16] </ref>, and CRL [12] rely on weak consistency models for performance. However, such systems all use request-reply protocols derived from hardware cache coherence protocols, requiring prompt servicing of coherence requests (similar to dedicated hardware cache controllers).
Reference: [17] <author> J. P. Singh, A. Gupta, and M. Levoy. </author> <title> Parallel visualiza tion algorithms: Performance and architectural implications. </title> <journal> IEEE Computer, </journal> <volume> 27(7):4556, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: To ensure the desired consistency requirement, access-revoke is requester-initiated with each processor invalidating any cached copies on iteration completion. DSM which achieves a speedup of 30x on 64 T3D nodes, VC-M achieves a 34x speedup which compares favorably with speedups reported elsewhere on a cache-coherent shared memory machine <ref> [17] </ref>. As with Grobner, view caching reduces both coherence overhead (up to 10%) and processor idle time (up to 25%) the latter resulting from the reduced synchronization of custom protocols.
Reference: [18] <author> A. Yonezawa, E. Shibayama, T. Takada, and Y. Honda. </author> <title> Object-oriented concurrent programming modelling and programming in an object-oriented concurrent language ABCL/1. In Object-Oriented Concurrent Programming. </title> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Such computations are becoming important due to the emphasis on sophisticated adaptive algorithms and irregular pointer-based data structures which significantly reduce sequential work by focusing computational effort where necessary. These computations are frequently expressed using a high-level programming approach (exemplified by concurrent object-oriented <ref> [7, 18] </ref> and multithreaded [9] systems) as a dynamic collection of light-weight threads operating in a shared object space. The dynamic nature precludes object placement to minimize communication, so efficiency demands effective runtime caching of remote object accesses.
References-found: 18

