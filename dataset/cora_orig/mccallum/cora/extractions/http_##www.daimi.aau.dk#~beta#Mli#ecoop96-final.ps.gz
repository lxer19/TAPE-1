URL: http://www.daimi.aau.dk/~beta/Mli/ecoop96-final.ps.gz
Refering-URL: http://www.daimi.aau.dk/~beta/Mli/mli.html
Root-URL: http://www.daimi.aau.dk
Email: Email: fsbrandt,jlknudseng@daimi.aau.dk  
Title: Generalising the BETA Type System  
Author: Soren Brandt and Jorgen Lindskov Knudsen 
Address: DK-8000 Aarhus C, Denmark  
Affiliation: Department of Computer Science University of Aarhus  
Abstract: The type system of object-oriented programming languages should enable the description of models that originate from object-oriented analysis and design. In this paper, the BETA type system is generalised, resulting in direct language support for a number of new modelling aspects. The increased expressive power is obtained from a synergy between general block structure and the generalised type hierarchy, and not from syntactic additions to the language. The type hierarchy described in this paper is a superset of the class hierarchy. In order to regain an orthogonal and internally consistent language, we investigate the impact of the new type hierarchy on other parts of the language. The resulting increase in expressive power serves to further narrow the gap between statically and dynamically typed languages, adding among other things more general generics, immutable references, and attributes with types not known until runtime. Keywords: language design, type systems, object-oriented modelling, constraints, BETA. 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen 95] <author> O. Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In Proceedings of the Ninth Eu-ropean Conference on Object-Oriented Programming (ECOOP'95), </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference: [Agesen et al. 89] <author> O. Agesen, S. Frolund, and M. Olsen. </author> <title> Persistent and Shared Objects in BETA. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: #); aPersonName: ^Person.name; Clearly, aPersonName can only refer to text objects, but the type system now also expresses and enforces that the text referred is the name of a person. ut 6 Generalised Dynamic Pattern References Dynamic pattern references were originally introduced in BETA to support patterns as first-class values <ref> [Agesen et al. 89] </ref>, e.g., allowing patterns as method parameters. In practice, dynamic pattern references are used in several ways: As function and method pointers. As dynamic class references. As qualification references, allowing explicit runtime type checks.
Reference: [Black et al. 87] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1), </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: Interpreted as a type, the class name C is a predicate that evaluates to true on the set of subclasses of C. Other languages, such as Sather [Omohundro 93] and Emerald <ref> [Black et al. 87] </ref>, separate the type and class hierarchies, but still interpret types as predicates on classes: The predicate evaluates to true for classes that conform to the type. <p> Hence, the pattern and its attributes are simultaneously specialised | they are covariant. For an interesting discussion on covariance, see [Shang 95]. 3 Usually, static typing of hierarchical type systems is ensured by enforcing con-travariant or nonvariant relationships between super/sub-types in a type hierarchy <ref> [Black et al. 87, Omohundro 93] </ref>. referred to by o. To handle this problem, the compiler inserts a runtime type check. In summary, type checking in BETA is based on qualified (typed) attribute declarations.
Reference: [Brandt & Schmidt 96] <author> S. Brandt and R. W. Schmidt. </author> <title> The Design of a Meta-Level Architecture for the BETA Language. </title> <editor> In C. Zimmermann, editor, </editor> <booktitle> Advances in Object-Oriented Metalevel Architectures and Reflection. </booktitle> <publisher> CRC Press Inc, </publisher> <address> Boca Raton, Florida, </address> <year> 1996. </year>
Reference-contexts: We then investigate the impact this generalisation has on other parts of the language. The result is a large increase in expressive power. The type system described in this paper originates from the development of MetaBETA <ref> [Brandt & Schmidt 96] </ref>, a reflective extension of BETA, featuring a dynamic meta-level interface accessible to programs at runtime. The challenge of adding a dynamic meta-level interface to a statically typed language without circumventing the type system lead to the generalisation of the BETA type system described in this paper.
Reference: [Chambers & Ungar 90] <author> C. Chambers and D. Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference: [Dahl et al. 84] <author> O. Dahl, B. Myrhaug, and K. Nygaard. </author> <title> Simula 67 Common Base Language. </title> <type> Pub. 725, </type> <institution> Norwegian Computing Center, Oslo, </institution> <year> 1984. </year>
Reference-contexts: Simula <ref> [Dahl et al. 84] </ref> originally introduced this property, inspired by the general block structure in the Algol languages. However, class nesting in Simula is more restricted than in BETA. This section describes aspects of the BETA type system needed for the purposes of this paper.
Reference: [Madsen & Moller-Pedersen 89] <author> O. L. Madsen and B. Moller-Pedersen. </author> <title> Virtual Classes A Powerful Mechanism in Object-Oriented Programming. </title> <booktitle> In Proceedings of the Fourth Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'89), volume 24 of Sigplan Notices, </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: is known, and can be used to disambiguate the type of pp: aGrammar: @Grammar; aCodeDisplay: @CodeDisplay (# PrettyPrinter:: aGrammar.PrettyPrinter #); ut We may also make good use of partial pattern qualifications in expressing generics: In BETA, the type parameter of a generic class is expressed by a nested virtual class <ref> [Madsen & Moller-Pedersen 89] </ref>. Example 5.
Reference: [Madsen et al. 93a] <author> O. Madsen, B.Magnusson, and B. Pedersen. </author> <title> Strong typing of Object-Oriented Languages Revisited. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: However, class nesting in Simula is more restricted than in BETA. This section describes aspects of the BETA type system needed for the purposes of this paper. Other aspects are described in <ref> [Madsen et al. 93a] </ref>. 2.1 Terminology BETA is a block structured language allowing general pattern nesting: Objects are instances of patterns and have attributes that are references to either other objects or patterns. These references may be either dynamic of static.
Reference: [Madsen et al. 93b] <author> O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison Wes-ley, </publisher> <address> Reading, MA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: A common understanding of types in object-oriented languages is as predicates on classes. For example, in BETA <ref> [Madsen et al. 93b] </ref>, C++ [Stroustrup 93], and Eiffel [Meyer 92], a type is the name of a class C. Interpreted as a type, the class name C is a predicate that evaluates to true on the set of subclasses of C.
Reference: [Meyer 92] <author> B. Meyer. </author> <title> Eiffel, The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: A common understanding of types in object-oriented languages is as predicates on classes. For example, in BETA [Madsen et al. 93b], C++ [Stroustrup 93], and Eiffel <ref> [Meyer 92] </ref>, a type is the name of a class C. Interpreted as a type, the class name C is a predicate that evaluates to true on the set of subclasses of C.
Reference: [Omohundro 93] <author> S. Omohundro. </author> <title> The Sather Programming Language. </title> <journal> Doctor Dobb's Journal, </journal> <pages> pages 42 - 48, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Interpreted as a type, the class name C is a predicate that evaluates to true on the set of subclasses of C. Other languages, such as Sather <ref> [Omohundro 93] </ref> and Emerald [Black et al. 87], separate the type and class hierarchies, but still interpret types as predicates on classes: The predicate evaluates to true for classes that conform to the type. <p> Hence, the pattern and its attributes are simultaneously specialised | they are covariant. For an interesting discussion on covariance, see [Shang 95]. 3 Usually, static typing of hierarchical type systems is ensured by enforcing con-travariant or nonvariant relationships between super/sub-types in a type hierarchy <ref> [Black et al. 87, Omohundro 93] </ref>. referred to by o. To handle this problem, the compiler inserts a runtime type check. In summary, type checking in BETA is based on qualified (typed) attribute declarations.
Reference: [Oxhoj et al. 92] <author> N. Oxhoj, J. Palsberg, and M. I. Schwartzbach. </author> <title> Making type inference practical. </title> <booktitle> In Proceedings of the Sixth European Conference on Object-Oriented Programming (ECOOP'92), </booktitle> <address> Utrecht, The Netherlands, </address> <month> June </month> <year> 1992. </year>
Reference: [Plevyak & Chien 95] <author> J. B. Plevyak and A. A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In Proceedings of the Ninth Conference on Object-Oriented Programming Systems, Languages and Applications (OOP--SLA'94), </booktitle> <address> Portland, OR, </address> <month> October </month> <year> 1995. </year>
Reference: [Shang 95] <author> D. L. Shang. </author> <title> Covariant Deep Subtyping Reconsidered. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(5):21 - 28, </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: Hence, the pattern and its attributes are simultaneously specialised | they are covariant. For an interesting discussion on covariance, see <ref> [Shang 95] </ref>. 3 Usually, static typing of hierarchical type systems is ensured by enforcing con-travariant or nonvariant relationships between super/sub-types in a type hierarchy [Black et al. 87, Omohundro 93]. referred to by o. To handle this problem, the compiler inserts a runtime type check.
Reference: [Stroustrup 93] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: A common understanding of types in object-oriented languages is as predicates on classes. For example, in BETA [Madsen et al. 93b], C++ <ref> [Stroustrup 93] </ref>, and Eiffel [Meyer 92], a type is the name of a class C. Interpreted as a type, the class name C is a predicate that evaluates to true on the set of subclasses of C.
References-found: 15

