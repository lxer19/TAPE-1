URL: http://www.eecs.umich.edu/~avigupta/papers/thesis.ps
Refering-URL: http://www.eecs.umich.edu/~avigupta/phd.html
Root-URL: http://www.eecs.umich.edu
Title: INTEGER-PROGRAMMING-BASED LAYOUT SYNTHESIS OF TWO-DIMENSIONAL CMOS CELLS  
Author: by Avaneendra Gupta Professor Ronald J. Lomax Professor Trevor N. Mudge Professor Romesh S. Saigal Shishpal S. Rawat 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Science and Engineering) in The  Doctoral Committee: Professor John P. Hayes, Chairman  Professor Karem A. Sakallah  
Date: 1997  
Affiliation: University of Michigan  (Intel Corp.)  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. W. Adams and P. Loustaunau, </author> <title> An Introduction to Grbner Bases, </title> <publisher> Providence, R.I.: American Mathematical Society, </publisher> <year> 1994. </year>
Reference-contexts: This leads to the following reduced sum-of-products expression for V. V= (X and Y and not T) or (X and B and not T) or (Y and not B and T) (3.5) For the example in Fig. 3.3d, netAboveRow <ref> [1, out] </ref> = 1, netBelowRow [1, out] = 0, topRowNet [1, out] = 0, bottomRowNet [1, out] = 1. Thus, according to Eq. (3.5), verticalNetInRow [1, out] = 1. <p> This leads to the following reduced sum-of-products expression for V. V= (X and Y and not T) or (X and B and not T) or (Y and not B and T) (3.5) For the example in Fig. 3.3d, netAboveRow <ref> [1, out] </ref> = 1, netBelowRow [1, out] = 0, topRowNet [1, out] = 0, bottomRowNet [1, out] = 1. Thus, according to Eq. (3.5), verticalNetInRow [1, out] = 1. <p> This leads to the following reduced sum-of-products expression for V. V= (X and Y and not T) or (X and B and not T) or (Y and not B and T) (3.5) For the example in Fig. 3.3d, netAboveRow <ref> [1, out] </ref> = 1, netBelowRow [1, out] = 0, topRowNet [1, out] = 0, bottomRowNet [1, out] = 1. Thus, according to Eq. (3.5), verticalNetInRow [1, out] = 1. <p> V= (X and Y and not T) or (X and B and not T) or (Y and not B and T) (3.5) For the example in Fig. 3.3d, netAboveRow <ref> [1, out] </ref> = 1, netBelowRow [1, out] = 0, topRowNet [1, out] = 0, bottomRowNet [1, out] = 1. Thus, according to Eq. (3.5), verticalNetInRow [1, out] = 1. The variable netAboveRow [r, n], defined below, determines whether a net n is present in rows above a given row r if n is present in an y row y that is placed abo ve r. <p> and not T) or (X and B and not T) or (Y and not B and T) (3.5) For the example in Fig. 3.3d, netAboveRow <ref> [1, out] </ref> = 1, netBelowRow [1, out] = 0, topRowNet [1, out] = 0, bottomRowNet [1, out] = 1. Thus, according to Eq. (3.5), verticalNetInRow [1, out] = 1. The variable netAboveRow [r, n], defined below, determines whether a net n is present in rows above a given row r if n is present in an y row y that is placed abo ve r. <p> We illustrate the foregoing ILP model using the adder circuit of Fig. minimize W cell subject to Pair inclusion: 1 = ( pairCover [c 1 , k] . X <ref> [c 1 , 1] </ref> + pairCover [c 1 , k] . X [c 1 , 2] ) + ... + ( pairCover [c 92 , k] . X [c 92 , 1] + pairCover [c 92 , k] . <p> X [c 1 , 1] + pairCover [c 1 , k] . X [c 1 , 2] ) + ... + ( pairCover [c 92 , k] . X <ref> [c 92 , 1] </ref> + pairCover [c 92 , k] . <p> X [c 1 , 2] ) + ... + ( pairCover [c 92 , k] . X [c 92 , 1] + pairCover [c 92 , k] . X [c 92 , 2] ) " k -p 1 , ..., p 14 - Chain inclusion: 1 X <ref> [i, 1] </ref> + X [i, 2] " i -c 1 , ..., c 92 - Row occupancy: 1 X [c 1 , j] + X [c 2 , j] + ... + X [c 92 , j] j = 1, 2 Objective linearization: S 2 i .W cell [i] ( X <p> n] = (netAboveRow [j, n] and netBelowRow [j, n] and not topRowNet [j, n]) or (netAboveRow [j, n] and bottomRowNet [j, n] and not topRowNet [j, n]) or (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow <ref> [1, n] </ref> = topRowNet [2, n] or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . <p> topRowNet [j, n]) or (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow <ref> [1, n] </ref> = topRowNet [2, n] or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . X [c 1 , j]) or ... or (topChainNets [c 92 , j, n] . <p> (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow <ref> [1, n] </ref> = topRowNet [2, n] or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . X [c 1 , j]) or ... or (topChainNets [c 92 , j, n] . <p> Further, we force slots be filled in left-justified order, that is, in each row r, the slot s should be occupied before the slot s + 1. Rows 1 numRows 1 2 maxSlots Slots nogap <ref> [1, 1] </ref> nogap [maxSlots1, 1] nogap [1, r] nogap [maxSlots1, r] nogap [s, 1] nogap [s, r] s s + 1 81 These constraints do not eliminate an y optimal placements and are introduced only for ILP modeling purposes to reduce the number of placements that must be explored and, in <p> Further, we force slots be filled in left-justified order, that is, in each row r, the slot s should be occupied before the slot s + 1. Rows 1 numRows 1 2 maxSlots Slots nogap [1, 1] nogap <ref> [maxSlots1, 1] </ref> nogap [1, r] nogap [maxSlots1, r] nogap [s, 1] nogap [s, r] s s + 1 81 These constraints do not eliminate an y optimal placements and are introduced only for ILP modeling purposes to reduce the number of placements that must be explored and, in turn, the run <p> Further, we force slots be filled in left-justified order, that is, in each row r, the slot s should be occupied before the slot s + 1. Rows 1 numRows 1 2 maxSlots Slots nogap [1, 1] nogap [maxSlots1, 1] nogap <ref> [1, r] </ref> nogap [maxSlots1, r] nogap [s, 1] nogap [s, r] s s + 1 81 These constraints do not eliminate an y optimal placements and are introduced only for ILP modeling purposes to reduce the number of placements that must be explored and, in turn, the run time. <p> Further, we force slots be filled in left-justified order, that is, in each row r, the slot s should be occupied before the slot s + 1. Rows 1 numRows 1 2 maxSlots Slots nogap [1, 1] nogap [maxSlots1, 1] nogap [1, r] nogap [maxSlots1, r] nogap <ref> [s, 1] </ref> nogap [s, r] s s + 1 81 These constraints do not eliminate an y optimal placements and are introduced only for ILP modeling purposes to reduce the number of placements that must be explored and, in turn, the run time. <p> Hence, since each placement has the same width and height, no optimal solution is excluded by forcing the two pairs to occupy the first two slots. S X <ref> [p, 1, r] </ref> = 1 " r rows (3.29) p pairs S X [p, s 1, r] S X [p, s, r] " r rows, (3.30) p pairs p pairs s slots 3. <p> Hence, merged [p i , p j ] (3.32) = or (Xor [p i , o i ] and Xor [p j , o j ]: " o i , o j orients such that share [p i , o i , p j , o j ]) = Xor <ref> [p i , 1] </ref> and (or (Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ])) or Xor [p i , 2] and (or (Xor [p j , o j ]: " o j orients such that <p> [p j , o j ]: " o i , o j orients such that share [p i , o i , p j , o j ]) = Xor [p i , 1] and (or (Xor [p j , o j ]: " o j orients such that share <ref> [p i , 1, p j , o j ] </ref>)) or Xor [p i , 2] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ])) or Xor [p i , 3] and (or (Xor <p> All possible pairwise diffusion abutments represented by the array share are shown in Fig. 3.8b. Figure 3.8c lists the logical diffusion sharing constraints for nogap <ref> [1, 1] </ref> for a single row placement (s = r = 1). The ILP-based technique CLIP presented above can be easily modified to accommodate other design objectives and constraints. <p> This heuristic first selects a branching variable that has the maximum coefficient in the objective function. If all variables in the objective 84 s 2 1 b 5 p 3 p 5 p 1 6 nogap <ref> [1, 1] </ref> share [p i , o i , p j , o j ] Pair p i Orient o i Pair p j Orient o j p 1 3 2 p 2 p 6 p 7 2 4 p 2 3 p 1 p 6 2 p 3 1 p <p> 7 2 4 p 2 3 p 1 p 6 2 p 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap <ref> [1, 1] </ref> = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 <p> 2 3 p 1 p 6 2 p 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X <ref> [p 1 , 1, 1] </ref> and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) <p> 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and <p> 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] <p> 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 <p> 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X <ref> [p 7 , 2, 1] </ref> and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 <p> 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X <ref> [p 2 , 1, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) <p> 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] <p> 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 <p> 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , <p> 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, <p> 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 <p> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X <ref> [p 4 , 2, 1] </ref> and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) <p> or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] <p> ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 <p> 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , <p> 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X <ref> [p 5 , 2, 1] </ref> and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, <p> 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 <p> and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) <p> or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and <p> ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X <ref> [p 2 , 2, 1] </ref> and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] <p> 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 <p> 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X <ref> [p 5 , 2, 1] </ref> and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p <p> 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X <ref> [p 7 , 2, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p <p> 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p 7 ] = merged [p 2 , p <p> Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor <ref> [p 7 , 1] </ref> and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. <p> 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor <ref> [p 1 , 1] </ref> (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. The JW-rule tries to reduce the search tree by selecting a v ariable that fixes a maximal number of the remaining un-fixed variables. <p> The objective function can be restated as follows: W cell = 2 m 1 W cell [m 1] + 2 m 2 W cell [m 2] + . . . + 2 W cell <ref> [1] </ref> + W cell [0] This linear expression contains very few variablesfewer than 5 in all circuits tested. <p> We can further simplify (4.6) using a dynamic programming approach where the value of span [n, c, r] is computed from that of the previous column, span [n, c 1, r]. For the first column c = 1, span <ref> [n, 1, r] </ref> = 1 if n exists in column c as well as in some column to the right of c. Thus, for c = 1, span [n, 1, r] = net [n, 1, r] and z. <p> For the first column c = 1, span <ref> [n, 1, r] </ref> = 1 if n exists in column c as well as in some column to the right of c. Thus, for c = 1, span [n, 1, r] = net [n, 1, r] and z. <p> For the first column c = 1, span <ref> [n, 1, r] </ref> = 1 if n exists in column c as well as in some column to the right of c. Thus, for c = 1, span [n, 1, r] = net [n, 1, r] and z. <p> Here, Nsrc, Ndrn, Psrc, and Pdrn, described in Table 3.5, are input parameters specified by the circuits netlist. net [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly <p> the circuits netlist. net [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net <p> net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) or Nsrc [p, n] and (Xor [p, 2] or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c <p> slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor <ref> [p, 1] </ref> or Xor [p, 3]) or Nsrc [p, n] and (Xor [p, 2] or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent of the orientation of the pair placed in the corresponding slot (c <p> For example, consider the net a in columns 1 and 3. Since columns 1, 2, and 3 need a track to connect net a, span <ref> [a, 1, r] </ref> = span [a, 2, r] = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. <p> Since net u appears on both columns 1 and 3, the constraints for span will correctly compute span <ref> [u, 1, r] </ref> = span [u, 2, r] = span [u, 3, r] = 1, which represents the routing internal to the and-stack. Next, we consider a three-pair stack sho wn in Fig. 5.3 c. <p> Thus, columns 1, 2, and 3 denote the nets - x, u-, -v, g 2 , u-, and - w, v-, respectively. This representation is accurate because it correctly computes span <ref> [u, 1, r] </ref> = span [u, 2, r] = span [u, 3, r] = 1, and span [v, 1, r] = span [v, 2, r] = span [v, 3, r] = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N <p> Thus, columns 1, 2, and 3 denote the nets - x, u-, -v, g 2 , u-, and - w, v-, respectively. This representation is accurate because it correctly computes span [u, 1, r] = span [u, 2, r] = span [u, 3, r] = 1, and span <ref> [v, 1, r] </ref> = span [v, 2, r] = span [v, 3, r] = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N pairs or more, pair-WA I can overestimate the track density. <p> S S X <ref> [c, 1, r, o] </ref> = 1 " r rows (6.12) c chains o orients S S X [c, s 1, r, o] S S X [c, s, r, o] " r rows, (6.13) c chains o orients c chains o orients s slots 3. <p> Thus, net [n, col, r] is given by the following equation, where the summation is over all chains c. 2 net [n, col, r] = S ( Nsrc [c, n] (X <ref> [c, s r, 1] </ref> + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X [c, s, r, 4]) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + <p> the summation is over all chains c. 2 net [n, col, r] = S ( Nsrc [c, n] (X [c, s r, 1] + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X [c, s, r, 4]) + Psrc [c, n] (X <ref> [c, s, r, 1] </ref> + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col = 3, 6, 9, ... (the right columns of chains) for which s = col <p> F or example, net n 4 in Fig. 6.5a spans columns 1 and 2 in the 3-column representation. Hence, we must set span <ref> [n, 1, r] </ref> = span [n, 2, r] = 1. <p> Further, if the difference in the number of legs is 1, then we set S Xor <ref> [p, o, 1] </ref> = 0 (over all o orients) for the centered position x = 1. The cost function for 2-D cell width minimization is to minimize the cell width W cell given by Eq. (3.1). <p> and Xor [p j , o j , x j ] (7.4) : " o i , o j orients and x i , x j -1,2,3- such that share [p i , o i , x i , p j , o j , x j ]) = Xor <ref> [p i , 1, 1] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 1, p j , o j , x j ])) or Xor [p i , 1, 2] and (or (Xor [p <p> o j , x j ]) = Xor [p i , 1, 1] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 1, p j , o j , x j ])) or Xor <ref> [p i , 1, 2] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 2, p j , o j , x j ])) or Xor [p i , 1, 3] and (or (Xor [p <p> o j , x j ])) or Xor [p i , 1, 2] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 2, p j , o j , x j ])) or Xor <ref> [p i , 1, 3] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 3, p j , o j , x j ])) or Xor [p i , 2, 1] and (or (Xor [p <p> o j , x j ])) or Xor [p i , 1, 3] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 3, p j , o j , x j ])) or Xor <ref> [p i , 2, 1] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 2, 1, p j , o j , x j ])) ... or Xor [p i , 4, 3] and (or (Xor <p> x j ]: " o j and x j such that share [p i , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor <ref> [p j , 1, 1] </ref> or Xor [p j , 1, 2] or Xor [p j , 1, 3] or Xor [p j , 2, 1] or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> x j such that share [p i , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor <ref> [p j , 1, 2] </ref> or Xor [p j , 1, 3] or Xor [p j , 2, 1] or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor [p j , 1, 2] or Xor <ref> [p j , 1, 3] </ref> or Xor [p j , 2, 1] or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor [p j , 1, 2] or Xor [p j , 1, 3] or Xor <ref> [p j , 2, 1] </ref> or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> For an odd number of le gs (Fig. 7.6a), we notice that net s spans the columns c = 1 and 2. Since s is represented both on the left and the center terminals, the constraints for span will correctly compute span <ref> [s, 1, r] </ref> = span [s, 2, r] = 1. Similarly, net d spans columns c = 2 and 3. Again, since d is represented on both the center and the right terminals, pair-WHF will accurately determine span [d, 2, r] = span [d, 3, r] = 1. <p> In the case of an e ven number of legs (Fig. 7.6b), source net s spans all three columns. Since s is represented on both the left and right terminals, pair-WHF will compute span <ref> [s, 1, r] </ref> = span [s, 2, r] = span [s, 3, r] = 1. <p> o] = 1; subject to pair_row1-p in pairs, r in rows: Xrow [p, r] = sum -s in 1..maxSlots- X [p, s, r]; 184 subject to pair_row2-p in pairs: sum -r in rows Xrow [p, r] = 1; # SLOT-OCCUPANCY subject to slot1-r in rows: sum -p in pairs X <ref> [p, 1, r] </ref> = 1; subject to slot2-s in 2..maxSlots, r in rows: sum -p in pairs X [p, s, r] &lt;= sum -p in pairs X [p, s1, r]; # DIFFUSION SHARING subject to gaps in 1..(maxSlots1), r in rows, p1 in pairs, p2 in pairs: mergeable [p1, p2]-: 3 <p> 2..numRows1, n in relevantNets-: # models V2 for r &gt; 1 2 verticalNetInRow [r,n] &gt;= 2 netAboveRow [r, n] + 2 (1 topRowNet [r, n]) + (netBelowRow [r, n] + bottomRowNet [r, n]) 4; subject to V1_1-n in relevantNets: numRows &gt; 1-: # models V2 for r = 1 verticalNetInRow <ref> [1, n] </ref> &gt;= netAboveRow [1, n] + bottomRowNet [1, n] topRowNet [1, n] 1; 185 subject to V2-r in 2..numRows, n in relevantNets-: verticalNetInRow [r, n] &gt;= netBelowRow [r, n] + topRowNet [r, n] bottomRowNet [r, n] 1; The data section of the AMPL model is now described. <p> # models V2 for r &gt; 1 2 verticalNetInRow [r,n] &gt;= 2 netAboveRow [r, n] + 2 (1 topRowNet [r, n]) + (netBelowRow [r, n] + bottomRowNet [r, n]) 4; subject to V1_1-n in relevantNets: numRows &gt; 1-: # models V2 for r = 1 verticalNetInRow <ref> [1, n] </ref> &gt;= netAboveRow [1, n] + bottomRowNet [1, n] topRowNet [1, n] 1; 185 subject to V2-r in 2..numRows, n in relevantNets-: verticalNetInRow [r, n] &gt;= netBelowRow [r, n] + topRowNet [r, n] bottomRowNet [r, n] 1; The data section of the AMPL model is now described. <p> r &gt; 1 2 verticalNetInRow [r,n] &gt;= 2 netAboveRow [r, n] + 2 (1 topRowNet [r, n]) + (netBelowRow [r, n] + bottomRowNet [r, n]) 4; subject to V1_1-n in relevantNets: numRows &gt; 1-: # models V2 for r = 1 verticalNetInRow <ref> [1, n] </ref> &gt;= netAboveRow [1, n] + bottomRowNet [1, n] topRowNet [1, n] 1; 185 subject to V2-r in 2..numRows, n in relevantNets-: verticalNetInRow [r, n] &gt;= netBelowRow [r, n] + topRowNet [r, n] bottomRowNet [r, n] 1; The data section of the AMPL model is now described. <p> 2 verticalNetInRow [r,n] &gt;= 2 netAboveRow [r, n] + 2 (1 topRowNet [r, n]) + (netBelowRow [r, n] + bottomRowNet [r, n]) 4; subject to V1_1-n in relevantNets: numRows &gt; 1-: # models V2 for r = 1 verticalNetInRow <ref> [1, n] </ref> &gt;= netAboveRow [1, n] + bottomRowNet [1, n] topRowNet [1, n] 1; 185 subject to V2-r in 2..numRows, n in relevantNets-: verticalNetInRow [r, n] &gt;= netBelowRow [r, n] + topRowNet [r, n] bottomRowNet [r, n] 1; The data section of the AMPL model is now described. <p> data section shown below is for a two-row layout of the full-adder circuit of [5] in Fig. 1.12a. data; param numPairs := 14; param numNets := 19; param numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets <ref> [1] </ref> := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := <p> PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets <ref> [1] </ref> := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] :=
Reference: [2] <author> E. Auer, W. Schiele, and G. Sigl, </author> <title> A New Linear Placement Algorithm for Cell Generation, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 486-489, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: We illustrate the foregoing ILP model using the adder circuit of Fig. minimize W cell subject to Pair inclusion: 1 = ( pairCover [c 1 , k] . X [c 1 , 1] + pairCover [c 1 , k] . X <ref> [c 1 , 2] </ref> ) + ... + ( pairCover [c 92 , k] . X [c 92 , 1] + pairCover [c 92 , k] . <p> X [c 1 , 1] + pairCover [c 1 , k] . X [c 1 , 2] ) + ... + ( pairCover [c 92 , k] . X [c 92 , 1] + pairCover [c 92 , k] . X <ref> [c 92 , 2] </ref> ) " k -p 1 , ..., p 14 - Chain inclusion: 1 X [i, 1] + X [i, 2] " i -c 1 , ..., c 92 - Row occupancy: 1 X [c 1 , j] + X [c 2 , j] + ... + X <p> X [c 92 , 1] + pairCover [c 92 , k] . X [c 92 , 2] ) " k -p 1 , ..., p 14 - Chain inclusion: 1 X [i, 1] + X <ref> [i, 2] </ref> " i -c 1 , ..., c 92 - Row occupancy: 1 X [c 1 , j] + X [c 2 , j] + ... + X [c 92 , j] j = 1, 2 Objective linearization: S 2 i .W cell [i] ( X [c 1 , j] <p> n] and netBelowRow [j, n] and not topRowNet [j, n]) or (netAboveRow [j, n] and bottomRowNet [j, n] and not topRowNet [j, n]) or (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow [1, n] = topRowNet <ref> [2, n] </ref> or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . <p> n] and not topRowNet [j, n]) or (netAboveRow [j, n] and bottomRowNet [j, n] and not topRowNet [j, n]) or (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow [1, n] = topRowNet <ref> [2, n] </ref> or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . <p> [j, n] and not topRowNet [j, n]) or (netBelowRow [j, n] and not bottomRowNet [j, n] and topRowNet [j, n]) " n -n 1 , ..., n 17 - netAboveRow [1, n] = topRowNet <ref> [2, n] </ref> or bottomRowNet [2, n] " n -n 1 , ..., n 17 - netBelowRow [2, n] = topRowNet [1, n] or bottomRowNet [1, n] " n -n 1 , ..., n 17 - topRowNet [j, n] = topChainNets [c 1 , j, n] . X [c 1 , j]) or ... or (topChainNets [c 92 , j, n] . <p> orients such that share [p i , o i , p j , o j ]) = Xor [p i , 1] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ])) or Xor <ref> [p i , 2] </ref> and (or (Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ])) or Xor [p i , 3] and (or (Xor [p j , o j ]: " o j orients such that <p> , 1] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 1, p j , o j ])) or Xor [p i , 2] and (or (Xor [p j , o j ]: " o j orients such that share <ref> [p i , 2, p j , o j ] </ref>)) or Xor [p i , 3] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ])) or Xor [p i , 4] and (or (Xor <p> 3 1 p 4 3 p 4 2 p 2 p 6 4 p 5 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and <p> 1 p 6 3 p 6 3 2 p 1 p 4 p 5 2 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] <p> 4 p 7 3 p 1 1 nogap [1, 1] = X [p 1 , 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 <p> 1, 1] and ( (X [p 2 , 2, 1] and merged [p 1 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X <ref> [p 7 , 2, 1] </ref> and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 <p> 1] and merged [p 1 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] <p> 1] and merged [p 1 , p 6 ]) or (X [p 7 , 2, 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 <p> 1] and merged [p 1 , p 7 ]) ) or X [p 2 , 1, 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , <p> 1] and ( (X [p 1 , 2, 1] and merged [p 2 , p 1 ]) or (X [p 4 , 2, 1] and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, <p> 1] and merged [p 2 , p 1 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 <p> and merged [p 2 , p 4 ]) or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X <ref> [p 4 , 2, 1] </ref> and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) <p> or (X [p 6 , 2, 1] and merged [p 2 , p 6 ]) ) or X [p 3 , 2, 1] and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X <ref> [p 2 , 2, 1] </ref> and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] <p> ) or X <ref> [p 3 , 2, 1] </ref> and ( (X [p 4 , 2, 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 <p> 1] and merged [p 3 , p 4 ]) ) or X [p 4 , 2, 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , <p> 1] and ( (X [p 2 , 2, 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X <ref> [p 5 , 2, 1] </ref> and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, <p> 1] and merged [p 4 , p 2 ]) or (X [p 3 , 2, 1] and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 <p> and merged [p 4 , p 3 ]) or (X <ref> [p 6 , 2, 1] </ref> and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) <p> or (X [p 6 , 2, 1] and merged [p 4 , p 6 ]) ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and <p> ) or X [p 5 , 2, 1] and ( (X [p 6 , 2, 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X <ref> [p 2 , 2, 1] </ref> and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] <p> 1] and merged [p 5 , p 6 ]) ) or X [p 6 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X <ref> [p 4 , 2, 1] </ref> and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 <p> 2, 1] and ( (X [p 1 , 2, 1] and merged [p 6 , p 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X <ref> [p 5 , 2, 1] </ref> and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p <p> 1 ]) or (X [p 2 , 2, 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X <ref> [p 7 , 2, 1] </ref> and ( (X [p 1 , 2, 1] and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p <p> 1] and merged [p 6 , p 2 ]) or (X [p 4 , 2, 1] and merged [p 6 , p 4 ]) or (X [p 5 , 2, 1] and merged [p 6 , p 5 ]) ) or X [p 7 , 2, 1] and ( (X <ref> [p 1 , 2, 1] </ref> and merged [p 7 , p 1 ]) ) merged [p 1 , p 2 ] = merged [p 1 , p 4 ] = merged [p 1 , p 6 ] = merged [p 1 , p 7 ] = merged [p 2 , p <p> 6 ] = merged [p 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor <ref> [p 2 , 2] </ref> Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 <p> merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 <p> , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor <ref> [p 1 , 2] </ref> Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 <p> ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 <p> [p 1 , 3] and Xor <ref> [p 2 , 2] </ref> Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p <p> [p 1 , 3] and Xor <ref> [p 6 , 2] </ref> Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 <p> [p 2 , 3] and Xor <ref> [p 1 , 2] </ref> Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted <p> [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor <ref> [p 4 , 2] </ref> Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. <p> Psrc, and Pdrn, described in Table 3.5, are input parameters specified by the circuits netlist. net [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) or Ndrn [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, <p> [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) or Ndrn [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X <p> right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor [p, 3]) or Nsrc [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent <p> 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor [p, 3]) or Nsrc [p, n] and (Xor <ref> [p, 2] </ref> or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent of the orientation of the pair placed in the corresponding slot (c + 1) / 3, <p> For example, consider the net a in columns 1 and 3. Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span <ref> [a, 2, r] </ref> = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. <p> Since net u appears on both columns 1 and 3, the constraints for span will correctly compute span [u, 1, r] = span <ref> [u, 2, r] </ref> = span [u, 3, r] = 1, which represents the routing internal to the and-stack. Next, we consider a three-pair stack sho wn in Fig. 5.3 c. <p> Thus, columns 1, 2, and 3 denote the nets - x, u-, -v, g 2 , u-, and - w, v-, respectively. This representation is accurate because it correctly computes span [u, 1, r] = span <ref> [u, 2, r] </ref> = span [u, 3, r] = 1, and span [v, 1, r] = span [v, 2, r] = span [v, 3, r] = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N pairs or more, pair-WA I <p> This representation is accurate because it correctly computes span [u, 1, r] = span [u, 2, r] = span [u, 3, r] = 1, and span [v, 1, r] = span <ref> [v, 2, r] </ref> = span [v, 3, r] = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N pairs or more, pair-WA I can overestimate the track density. For example, consider the four-pair stack of Fig. 5.3 d. <p> F or example, in the case of three-pair stacks, we must ensure that if net g 3 is present in some terminal to the left of the stack, then span <ref> [g 3 , 2, r] </ref> = 1, that is, g 3 spans the center column of the stack. <p> 3: span [g 3 , c, r] = span [g 3 , c 1, r] and (pair with gate g 1 placed in slot s in orientation that g 1 is on its right-most gate) Similarly, for the gate net g 1 , we introduce a constraint that sets span <ref> [g 1 , 2, r] </ref> = 1 if g 1 also appears on a transistor placed to the right of the stack. 5.5 Experimental Results We now compare the and-stack clustering approach presented in this chapter with the original non-clustering techniques of the previous two chapters. Chain-W model. <p> If a net n, such as n 2 in Fig. 6.5, appears multiple times in the middle column (col = 2) of chain c, then CSpan <ref> [c, n, 2, o] </ref> = 1 for all orientations o of chain c. In order to determine the track density , each chain of the selected chain co vers must be placed in a unique slot and orientation in the 2-D plane. <p> Thus, net [n, col, r] is given by the following equation, where the summation is over all chains c. 2 net [n, col, r] = S ( Nsrc [c, n] (X [c, s r, 1] + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X <ref> [c, s, r, 2] </ref> + X [c, s, r, 4]) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col <p> c. 2 net [n, col, r] = S ( Nsrc [c, n] (X [c, s r, 1] + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X <ref> [c, s, r, 2] </ref> + X [c, s, r, 4]) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col = 3, 6, 9, ... (the right columns of chains) for which s = col / 3. <p> F or example, net n 4 in Fig. 6.5a spans columns 1 and 2 in the 3-column representation. Hence, we must set span [n, 1, r] = span <ref> [n, 2, r] </ref> = 1. <p> If the P and N transistors of pair p have the same leg count, we set S Xor <ref> [p, o, 2] </ref> = S Xor [p, o, 3] = 0 (over all o orients) for the left (x = 2) and right-justified positions (x = 3). <p> o j , x j ]) = Xor [p i , 1, 1] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 1, p j , o j , x j ])) or Xor <ref> [p i , 1, 2] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 2, p j , o j , x j ])) or Xor [p i , 1, 3] and (or (Xor [p <p> o j , x j ])) or Xor [p i , 1, 3] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 3, p j , o j , x j ])) or Xor <ref> [p i , 2, 1] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 2, 1, p j , o j , x j ])) ... or Xor [p i , 4, 3] and (or (Xor <p> x j such that share [p i , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor <ref> [p j , 1, 2] </ref> or Xor [p j , 1, 3] or Xor [p j , 2, 1] or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor [p j , 1, 2] or Xor [p j , 1, 3] or Xor <ref> [p j , 2, 1] </ref> or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> If this difference is either zero or more than one. then only the centered position must be consideredno additional variables are required. However, for a difference in leg count of one, both the left and right-justified positions must be considered, which requires the variables Xor <ref> [p, o, 2] </ref> and Xor [p, o, 3], and increases the total number of v ariables for pair p by four (one for e very orientation o orients). As is evident from Table 7.1, the run times with transistor folding equal those without folding in most cases. <p> For an odd number of le gs (Fig. 7.6a), we notice that net s spans the columns c = 1 and 2. Since s is represented both on the left and the center terminals, the constraints for span will correctly compute span [s, 1, r] = span <ref> [s, 2, r] </ref> = 1. Similarly, net d spans columns c = 2 and 3. Again, since d is represented on both the center and the right terminals, pair-WHF will accurately determine span [d, 2, r] = span [d, 3, r] = 1. <p> Similarly, net d spans columns c = 2 and 3. Again, since d is represented on both the center and the right terminals, pair-WHF will accurately determine span <ref> [d, 2, r] </ref> = span [d, 3, r] = 1. Finally, since gate net g spans the center column only, we introduce an additional constraint that forces span [g, 2, r] = 1 for all odd-legged transistors. <p> Again, since d is represented on both the center and the right terminals, pair-WHF will accurately determine span [d, 2, r] = span [d, 3, r] = 1. Finally, since gate net g spans the center column only, we introduce an additional constraint that forces span <ref> [g, 2, r] </ref> = 1 for all odd-legged transistors. In the case of an e ven number of legs (Fig. 7.6b), source net s spans all three columns. <p> In the case of an e ven number of legs (Fig. 7.6b), source net s spans all three columns. Since s is represented on both the left and right terminals, pair-WHF will compute span [s, 1, r] = span <ref> [s, 2, r] </ref> = span [s, 3, r] = 1. <p> Hence, we introduce a new constraint that forces span <ref> [d, 2, r] </ref> = 1 for all even-legged transistors with four or more legs. Finally, the gate net g also spans only the center column and we introduce a new constraint that forces span [g, 2, r] = 1 for all even-legged transistors. <p> Hence, we introduce a new constraint that forces span [d, 2, r] = 1 for all even-legged transistors with four or more legs. Finally, the gate net g also spans only the center column and we introduce a new constraint that forces span <ref> [g, 2, r] </ref> = 1 for all even-legged transistors. In summary, the pair-WHF model has the follo wing new constraints for span [n, c, r] in addition to those in the pair-WH model: Force span [g, 2, r] = 1 in the center column for the gate net g of both <p> also spans only the center column and we introduce a new constraint that forces span <ref> [g, 2, r] </ref> = 1 for all even-legged transistors. In summary, the pair-WHF model has the follo wing new constraints for span [n, c, r] in addition to those in the pair-WH model: Force span [g, 2, r] = 1 in the center column for the gate net g of both odd and even-legged transistors. <p> For even-legged transistors with four or more legs, force span <ref> [d, 2, r] </ref> = 1 in the center column for drain net d when the transistor is placed unipped, or span [s, 2, r] = 1 for source net s when the transistor is ipped. The resulting pair-WHF model exactly computes the track density in each P/N channel. <p> For even-legged transistors with four or more legs, force span [d, 2, r] = 1 in the center column for drain net d when the transistor is placed unipped, or span <ref> [s, 2, r] </ref> = 1 for source net s when the transistor is ipped. The resulting pair-WHF model exactly computes the track density in each P/N channel. Hence, under the same assumptions on cell layout style and height modeling described in Chapter 4, pair-WHF determines the cell height exactly. <p> two-row layout of the full-adder circuit of [5] in Fig. 1.12a. data; param numPairs := 14; param numNets := 19; param numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets <ref> [2] </ref> := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := <p> PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets <ref> [2] </ref> := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] :=
Reference: [3] <author> E. Balas and J. B. Mazzola, </author> <title> Nonlinear 0-1 Programming: I. Linearization Techniques, </title> <booktitle> Mathematical Programming 30, </booktitle> <pages> pp. 1-21, </pages> <year> 1984. </year>
Reference-contexts: function over three binary variables x, y, and z, where the logical sum and product are denoted by or and and, respectively. w = (x and y) or (x and z) or (y and z) = majority (x, y, z) Several systematic techniques have been proposed for linearizing such constraints <ref> [3, 98, 113] </ref>. However, most of these techniques either introduce a lar ge number of intermediate binary variables or result in a lar ge number of additional constraints, f actors which adversely affect the 60 problems complexity. <p> o j orients such that share [p i , 1, p j , o j ])) or Xor [p i , 2] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ])) or Xor <ref> [p i , 3] </ref> and (or (Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ])) or Xor [p i , 4] and (or (Xor [p j , o j ]: " o j orients such that <p> , 2] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 2, p j , o j ])) or Xor [p i , 3] and (or (Xor [p j , o j ]: " o j orients such that share <ref> [p i , 3, p j , o j ] </ref>)) or Xor [p i , 4] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 4, p j , o j ])) 82 Finally, we must ensure that a pair can <p> = merged [p 5 , p 6 ] = merged [p 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor <ref> [p 1 , 3] </ref> and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p <p> 6 , p 1 ] = merged [p 6 , p 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor <ref> [p 1 , 3] </ref> and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p <p> 2 ] = merged [p 6 , p 4 ] = merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor <ref> [p 2 , 3] </ref> and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p <p> merged [p 6 , p 5 ] = merged [p 7 , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor <ref> [p 2 , 3] </ref> and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p <p> , p 1 ] = Xor [p 1 , 3] and Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor <ref> [p 4 , 3] </ref> and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p <p> Xor [p 2 , 2] Xor [p 1 , 3] and Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor <ref> [p 4 , 3] </ref> and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor <p> Xor [p 6 , 2] Xor [p 2 , 3] and Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor <ref> [p 6 , 3] </ref> and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the <p> Xor [p 1 , 2] Xor [p 2 , 3] and Xor [p 6 , 2] Xor [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor <ref> [p 6 , 3] </ref> and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. <p> [p 4 , 3] and Xor [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor <ref> [p 1 , 3] </ref> + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. <p> [p 2 , 2] Xor [p 4 , 3] and Xor [p 6 , 2] Xor [p 6 , 3] and Xor [p 1 , 2] Xor [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor <ref> [p 7 , 3] </ref> and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic [67]. <p> Here, Nsrc, Ndrn, Psrc, and Pdrn, described in Table 3.5, are input parameters specified by the circuits netlist. net [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that <p> / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) or Ndrn [p, n] and (Xor [p, 2] or Xor [p, 4]) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs <p> is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) or Nsrc [p, n] and (Xor [p, 2] or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, <p> / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor <ref> [p, 3] </ref>) or Nsrc [p, n] and (Xor [p, 2] or Xor [p, 4]) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent of the orientation of the pair placed in the corresponding slot (c + 1) / 3, and is given by: 104 net [n, c, <p> For example, consider the net a in columns 1 and 3. Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span [a, 2, r] = span <ref> [a, 3, r] </ref> = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. <p> Since net u appears on both columns 1 and 3, the constraints for span will correctly compute span [u, 1, r] = span [u, 2, r] = span <ref> [u, 3, r] </ref> = 1, which represents the routing internal to the and-stack. Next, we consider a three-pair stack sho wn in Fig. 5.3 c. It has its N transistors connected in series (nets y and z being internal to the stack), and its P transistors connected in parallel. <p> Thus, columns 1, 2, and 3 denote the nets - x, u-, -v, g 2 , u-, and - w, v-, respectively. This representation is accurate because it correctly computes span [u, 1, r] = span [u, 2, r] = span <ref> [u, 3, r] </ref> = 1, and span [v, 1, r] = span [v, 2, r] = span [v, 3, r] = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N pairs or more, pair-WA I can overestimate the track density. <p> This representation is accurate because it correctly computes span [u, 1, r] = span [u, 2, r] = span [u, 3, r] = 1, and span [v, 1, r] = span [v, 2, r] = span <ref> [v, 3, r] </ref> = 1 (which are routes internal to the stack, as shown in Fig. 5.3c). 119 However, for stacks with four P/N pairs or more, pair-WA I can overestimate the track density. For example, consider the four-pair stack of Fig. 5.3 d. <p> Thus, net [n, col, r] is given by the following equation, where the summation is over all chains c. 2 net [n, col, r] = S ( Nsrc [c, n] (X [c, s r, 1] + X <ref> [c, s, r, 3] </ref>) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X [c, s, r, 4]) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) <p> Nsrc [c, n] (X [c, s r, 1] + X <ref> [c, s, r, 3] </ref>) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X [c, s, r, 4]) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col = 3, 6, 9, ... (the right columns of chains) for which s = col / 3. <p> If the P and N transistors of pair p have the same leg count, we set S Xor [p, o, 2] = S Xor <ref> [p, o, 3] </ref> = 0 (over all o orients) for the left (x = 2) and right-justified positions (x = 3). <p> o j , x j ])) or Xor [p i , 1, 2] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 2, p j , o j , x j ])) or Xor <ref> [p i , 1, 3] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 1, 3, p j , o j , x j ])) or Xor [p i , 2, 1] and (or (Xor [p <p> j , x j ])) or Xor [p i , 2, 1] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 2, 1, p j , o j , x j ])) ... or Xor <ref> [p i , 4, 3] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the <p> , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the form Xor [p i , o i , x i ] and (Xor [p j , 1, 1] or Xor [p j , 1, 2] or Xor <ref> [p j , 1, 3] </ref> or Xor [p j , 2, 1] or ...) for every pair p i and p j of P/N pairs, and for every orientation o i of p i . <p> However, for a difference in leg count of one, both the left and right-justified positions must be considered, which requires the variables Xor [p, o, 2] and Xor <ref> [p, o, 3] </ref>, and increases the total number of v ariables for pair p by four (one for e very orientation o orients). As is evident from Table 7.1, the run times with transistor folding equal those without folding in most cases. <p> Similarly, net d spans columns c = 2 and 3. Again, since d is represented on both the center and the right terminals, pair-WHF will accurately determine span [d, 2, r] = span <ref> [d, 3, r] </ref> = 1. Finally, since gate net g spans the center column only, we introduce an additional constraint that forces span [g, 2, r] = 1 for all odd-legged transistors. <p> In the case of an e ven number of legs (Fig. 7.6b), source net s spans all three columns. Since s is represented on both the left and right terminals, pair-WHF will compute span [s, 1, r] = span [s, 2, r] = span <ref> [s, 3, r] </ref> = 1. <p> [5] in Fig. 1.12a. data; param numPairs := 14; param numNets := 19; param numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets <ref> [3] </ref> := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := <p> PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets <ref> [3] </ref> := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] :=
Reference: [4] <author> E. Balas and J. B. Mazzola, </author> <title> Nonlinear 0-1 Programming: II. Dominance Relations and Algorithms, </title> <booktitle> Mathematical Programming 30, </booktitle> <pages> pp. 22-45, </pages> <year> 1984. </year>
Reference-contexts: o j orients such that share [p i , 2, p j , o j ])) or Xor [p i , 3] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ])) or Xor <ref> [p i , 4] </ref> and (or (Xor [p j , o j ]: " o j orients such that share [p i , 4, p j , o j ])) 82 Finally, we must ensure that a pair can share diffusions with at most one pair placed to its immediate left <p> , 3] and (or (Xor [p j , o j ]: " o j orients such that share [p i , 3, p j , o j ])) or Xor [p i , 4] and (or (Xor [p j , o j ]: " o j orients such that share <ref> [p i , 4, p j , o j ] </ref>)) 82 Finally, we must ensure that a pair can share diffusions with at most one pair placed to its immediate left or right sides. <p> Net presence: If c represents a diffusion terminal (c = 1, 3, 4, 6, ...), net [n, c, r] depends both on the choice and orientation of the pair placed in the slot corresponding to c. For example, for c = 4, net <ref> [n, 4, r] </ref> = 1 if there is a pair p placed in slot s = 2, and its orientation causes its diffusion terminal on net n to appear on its left side. <p> in Table 3.5, are input parameters specified by the circuits netlist. net [n, c, r] X [p, (c + 2) / 3, r] " p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) or Ndrn [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with <p> p pairs (4.11) and ( Nsrc [p, n] and (Xor [p, 1] or Xor [p, 3]) or Ndrn [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Psrc [p, n] and (Xor [p, 1] or Xor [p, 2]) or Pdrn [p, n] and (Xor [p, 3] or Xor [p, 4])) The value of net [n, c, r] is similarly defined for columns that represent the right dif fusions (c = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn <p> = 3, 6, 9, ...), with the corresponding slot being c / 3: net [n, c, r] X [p, c / 3, r] " p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor [p, 3]) or Nsrc [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent of the orientation of <p> p pairs (4.12) and ( Ndrn [p, n] and (Xor [p, 1] or Xor [p, 3]) or Nsrc [p, n] and (Xor [p, 2] or Xor <ref> [p, 4] </ref>) or Pdrn [p, n] and (Xor [p, 1] or Xor [p, 2]) or Psrc [p, n] and (Xor [p, 3] or Xor [p, 4])) However, if c is a g ate terminal (c = 2, 5, 8, ...), then net [n, c, r] is independent of the orientation of the pair placed in the corresponding slot (c + 1) / 3, and is given by: 104 net [n, c, r] = S if <p> Since columns 1, 2, and 3 need a track to connect net a, span [a, 1, r] = span [a, 2, r] = span [a, 3, r] = 1. Also, since columns 3 and 4 are connected by diffusion sharing, we set span <ref> [a, 4, r] </ref> = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span [b, 9, r] = span [b, 10, r] = 0. <p> col, r] is given by the following equation, where the summation is over all chains c. 2 net [n, col, r] = S ( Nsrc [c, n] (X [c, s r, 1] + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X <ref> [c, s, r, 4] </ref>) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col = 3, 6, 9, ... (the <p> r, 1] + X [c, s, r, 3]) (6.16) + Ndrn [c, n] (X [c, s, r, 2] + X <ref> [c, s, r, 4] </ref>) + Psrc [c, n] (X [c, s, r, 1] + X [c, s, r, 2]) + Pdrn [c, n] (X [c, s, r, 3] + X [c, s, r, 4]) ) Net [n, col, r] can be similarly defined for col = 3, 6, 9, ... (the right columns of chains) for which s = col / 3. <p> j , x j ])) or Xor [p i , 2, 1] and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 2, 1, p j , o j , x j ])) ... or Xor <ref> [p i , 4, 3] </ref> and (or (Xor [p j , o j , x j ]: " o j and x j such that share [p i , 4, 3, p j , o j , x j ])) This is a sum-of-products e xpression with product terms of the <p> := 14; param numNets := 19; param numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets <ref> [4] </ref> := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := <p> PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets <ref> [4] </ref>: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] :=
Reference: [5] <author> D. G. Baltus and J. Allen, </author> <title> SOLO: A Generator of Efficient Layouts From Optimized MOS Circuit Schematics, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 445-452, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: This layout uses the same two chains as the 1-D layout of Fig. 1.11a. The 2-D style forms the focus of this thesis. 18 We illustrate the advantages of the 2-D style o ver the 1-D style using a CMOS full adder whose transistor-level schematic <ref> [5] </ref> is shown in Fig. 1.12a. This circuit has 28 transistors grouped into 14 P/N pairs. <p> By enumerating all hamiltonian paths in the graph using a branch-and-bound algorithm, the best linear arrangement of pairs is found with respect to an area-minimizing cost function. The heuristic approach of Baltus and Allen called SOLO <ref> [5] </ref>, applies to all types of complex CMOS structures. It first partitions the circuit into strongly connected subcircuits. Each subcircuit is laid out using the method of Uehara and v anCleemput. <p> Although this approach is v ersatile in that it can handle arbitrary circuits and cell shapes, it does not guarantee optimal layouts. The SOLO method of Baltus and Allen <ref> [5] </ref> can generate layouts to conform to a specified aspect ratio, that is, the ratio of the cell s width to its height. <p> For the cell width minimization problem, only chains containing distinct P/N pairs are considered. Cct. no. Circuit No. of transistors No. of nets 1 No. of chains 2 1 2-input parity circuit (Xor) <ref> [5] </ref> 10 7 16 2 Non-series-parallel bridge circuit [121] 10 10 20 3 2-level implementation of z = (a' . (e + f)' + d)' [82] 12 12 22 4 2-to-1 multiplexer 14 10 28 5 Series-parallel circuit for z = (a.b + (c+d) . (e+f) + g.h)' [108] 6 2-level <p> majority function z = a.b + b.c + a.c 7 Series-parallel circuit for z = (a.b.c + d.e.f + (g + h).(i + j))' 8 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l))' [82] 9 8-input NAND circuit 24 20 78 10 Full adder <ref> [5] </ref> 28 17 92 11 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l).(m + n).(o + p))' [82] 12 4-bit parity stage (implements 5-bit parity circuit) [52] 40 25 214 Table 3.6: Representative CMOS circuits used for experimentation 87 1. <p> of P/N rows 1 2 3 4 5 2-level implementation of the majority function z = a.b + b.c + a.c 10 5 (5+0+0) (2+1+1) (3+1+0) (2+1+1) (2+0+2) 4 (1+0+3) (2+1+1) 8 Series-parallel circuit for (i+j).(k+l))' [82] 13 9 (6+1+2) (4+0+1) (4+0+1) (4+0+1) (2+0+3) 5 (2+0+3) (2+0+3) 10 Full adder <ref> [5] </ref> 16 8 (8+0+0) (5+0+0) (5+0+0) (4+0+1) (3+0+1) 5 (3+0+1) (3+1+0) Table 3.8: Contribution of individual P/N rows to the optimum cell width W cell 90 3.6 Summary We have presented a no vel technique CLIP based on inte ger-linear programming to optimally solve the problem of generating minimum-width cells in <p> This term can be further simplified by re-defining it in terms of the X [p, s, r] (instead of the net [n, c 2 , r]) variables. For example, for c = 3, we have: or -net [n, c 2 , r]: c 2 c + 2- = net <ref> [n, 5, r] </ref> + net [n, 6, r] + or -net [n, c 2 , r]: c 2 7 p pairs; n in p s = c/3 + 2, ... maxSlots This simplification reduces run times because the X variables represent the fundamental decisions in our model determining a v alid <p> No. of clusts. Ave. clust. size No. of rows Lower bound W cell 1 W cell Run time (secs.) pair-W hier-W pair-W hier-W 1 8-input NAND [96] 1 3 5 7 4 14 5 3 7 4 3 58 272 0.05 0.1 2 Full adder 2 <ref> [5] </ref> 1 3 5 8 5 16 5 5 8 7 13 226 9,773 0.02 0.05 3 multiplexer with enable [52] 1 3 5 12 5 22 * * 12 9 447 * * 0.1 0.5 4 4-bit parity stage (5-bit parity circuit) [52] 40 8 5 2 4 23 7 <p> Circuit No. of trans. No. of gates Ave. clust. size No. of covers No. of rows W cell 1 H cell 2 Run time (secs) 3 Max. chain size Max. chain size Orig. 4 3 Orig. 4 3 Full adder <ref> [5] </ref> 1 3 16 7 6 12 6 11 6 11 0.2 0.3 2 1 18 6 4-to-1 multiplexer [52] 1 3 22 9 9 12 8 12 8 12 110 4 33 6 1900 15 4-bit parity stage (5-bit parity circuit) [52] 1 3 23 11 6 16 10 18 <p> For a given circuit, it specifies the values of the parameters defined in the AMPL model section. The data section shown below is for a two-row layout of the full-adder circuit of <ref> [5] </ref> in Fig. 1.12a. data; param numPairs := 14; param numNets := 19; param numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] <p> numRows := 2; set pairs := 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets <ref> [5] </ref> := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := <p> PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets <ref> [5] </ref> := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := <p> := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of <ref> [5] </ref> sho wn in Fig. 1.12 a. It also compares the nonhierarchical layouts with the hierarchical ones generated using HCLIP. For these layouts, transistor placements were obtained using CLIP or HCLIP while the routing w as completed manually.
Reference: [6] <author> P. Barth, </author> <title> A Davis-Putnam Based Enumeration Algorithm for Linear Pseudo-Boolean Optimization, </title> <type> Technical report MIP-I-95-2-003, </type> <institution> Max-Planck-Institut Fuer Informatik, </institution> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The ILP formulations of the cell layout problem are solved using two solver programs: OSL [66], a commercial general 28 purpose ILP solver from IBM Corp., and OPBDP <ref> [6] </ref>, a specialized solv er for 0-1 ILP problems. The solution to each ILP problem assigns 0 or 1 v alues to the binary v ariables which, in turn, translate to a valid cell layout that has a minimum value of the cost (objective) function under the modeled constraints. <p> An LPB optimization problem requires finding an assignment of 0-1 values to the boolean variables that optimizes a LPB objecti ve function while satisfying a system of LPB inequalities. Recently, new logic-based methods have been developed for solving LPB optimization problems <ref> [6, 7, 8, 60] </ref>. These are based on the observ ation that the problem of locating a feasible solution to a system of LPB constraints is a generalization of the well-known problem of verifying the satisfiability of a boolean function in conjuncti ve normal form (CNF-SAT) [7]. <p> One such technique due to Barth is OPBDP (Optimizing with Pseudo-Boolean Davis-Putnam ) <ref> [6] </ref>, an enumerative algorithm based on a Da vis-Putnam-style search procedure, and modified to handle LPB constraints instead of CNF formulas. The classical Davis-Putnam (DP) procedure [30] solves the satisfiability problem (SAT) for a set S of classical clauses by e xploring a search tree depth-first. <p> This can be attributed to the nature of our model: most of its constraints are originally logical (boolean) in nature, and are made linear to be included in an ILP formulation. The linearization process converts these boolean constraints to pseudo-boolean inequalities <ref> [6] </ref>, that is, linear inequalities over boolean variables with integer coefficients. Since the solution method of OPBDP is specially designed to solv e a set of pseudo-boolean inequalities using SAT-based algorithms, it is significantly more efficient on our problem than LP-based solv ers such as OSL. <p> Hence, span [b, 9, r] = span [b, 10, r] = 0. Now consider net c in columns 6 and 7 of the P and N dif fusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. Hence, span <ref> [c, 6, r] </ref> = span [c, 7, r] = 1. <p> For example, for c = 3, we have: or -net [n, c 2 , r]: c 2 c + 2- = net [n, 5, r] + net <ref> [n, 6, r] </ref> + or -net [n, c 2 , r]: c 2 7 p pairs; n in p s = c/3 + 2, ... maxSlots This simplification reduces run times because the X variables represent the fundamental decisions in our model determining a v alid 2-D placement. <p> 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets <ref> [6] </ref> := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := <p> PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets <ref> [6] </ref> := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] :=
Reference: [7] <author> P. Barth, </author> <title> Logic-based 0-1 Constraint Programming, </title> <publisher> Kluwer, </publisher> <address> Boston, MA, </address> <year> 1995. </year>
Reference-contexts: A binary or zero-one (0-1) ILP problem is one in which all the v ariables are restricted to 0 or 1. If a 0-1 ILP problem has all integer coefficients, it is called pseudo-boolean <ref> [7] </ref>. An ILP problem in which e very integer variable is bounded can be transformed to a 0-1 ILP problem (Theorem 1.1 of [98]). <p> An LPB optimization problem requires finding an assignment of 0-1 values to the boolean variables that optimizes a LPB objecti ve function while satisfying a system of LPB inequalities. Recently, new logic-based methods have been developed for solving LPB optimization problems <ref> [6, 7, 8, 60] </ref>. These are based on the observ ation that the problem of locating a feasible solution to a system of LPB constraints is a generalization of the well-known problem of verifying the satisfiability of a boolean function in conjuncti ve normal form (CNF-SAT) [7]. <p> These are based on the observ ation that the problem of locating a feasible solution to a system of LPB constraints is a generalization of the well-known problem of verifying the satisfiability of a boolean function in conjuncti ve normal form (CNF-SAT) <ref> [7] </ref>. One such technique due to Barth is OPBDP (Optimizing with Pseudo-Boolean Davis-Putnam ) [6], an enumerative algorithm based on a Da vis-Putnam-style search procedure, and modified to handle LPB constraints instead of CNF formulas. <p> However, it introduces three new binary variables for every verticalNetInRow [r, n] variable. Thus, a total of 3 numRows numNets extra variables are required. 2. Linearization II: We now describe an alternative linearization of (3.5) using a procedure proposed by Barth <ref> [7] </ref>. This method does not require any new variables and yields a linear model that takes less time to solve. We begin by replacing (3.5) by two equivalent inequalities: V + X.Y.T + X.B.T + Y.B.T 0 (3.11) We will first linearize (3.11). <p> Y.B) + T.( V + X.Y + X.B) 0. (3.13) With a naive lower bound of 1 for both terms of (3.13) (obtained by taking the sum of all negative coefficients in each term), we obtain the follo wing two pseudo-boolean inequalities that are equivalent to (3.11) (Theorem 9.2.2 in <ref> [7] </ref>): T V + Y.B 0 (3.14) We then split the first inequality (3.14) on Y to obtain Y.(T V + B) + Y.(T V) 0. (3.16) In order to obtain a lower bound for the first term in (3.16), we use Barths approach and introduce the additional constraints T V <p> Now consider net c in columns 6 and 7 of the P and N dif fusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. Hence, span [c, 6, r] = span <ref> [c, 7, r] </ref> = 1. Further, we assume that if a net, such as d, appears on the same (P or N) dif fusion of two P/N pairs separated by a g ap, it is connected using metal1 to a void long diffusion wires, and hence requires a horizontal track. <p> 9, 10, 11, 12, 13, 14; set PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets <ref> [7] </ref> := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := <p> PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets <ref> [7] </ref> := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] :=
Reference: [8] <author> P. Barth and A. Bockmayr, </author> <title> Solving 0-1 Problems in CLP (PB), </title> <booktitle> Proc. 9th Conf. on Artificial Intelligence for Applications, </booktitle> <pages> pp. 263-269, </pages> <year> 1993. </year>
Reference-contexts: An LPB optimization problem requires finding an assignment of 0-1 values to the boolean variables that optimizes a LPB objecti ve function while satisfying a system of LPB inequalities. Recently, new logic-based methods have been developed for solving LPB optimization problems <ref> [6, 7, 8, 60] </ref>. These are based on the observ ation that the problem of locating a feasible solution to a system of LPB constraints is a generalization of the well-known problem of verifying the satisfiability of a boolean function in conjuncti ve normal form (CNF-SAT) [7]. <p> PpairNets [1] := PWR 10 7; set PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets <ref> [8] </ref> := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := <p> NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets <ref> [8] </ref> := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP
Reference: [9] <author> B. Basaran and R. Rutenbar, </author> <title> Efficient Area Minimization for Dynamic CMOS Circuits, </title> <booktitle> Proc. IEEE Custom Integrated Circuits Conf., </booktitle> <pages> pp. 505-508, </pages> <year> 1996. </year>
Reference-contexts: Linear-time algorithms for dynamic circuit layout ha ve been proposed by Leng auer and Muller [75] and by McMullen and Otten [86]. While both guarantee a minimum-width layout with circuit reordering, only [75] addresses height minimization using heuristics. Basaran and Rutenbar <ref> [9] </ref> present an area-minimization algorithm that first determines the minimum cell width via euler chain formation, and then uses simulated annealing to f ind a transistor ordering that has the minimum width and requires the fe west routing tracks. <p> Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span <ref> [b, 9, r] </ref> = span [b, 10, r] = 0. Now consider net c in columns 6 and 7 of the P and N dif fusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. <p> Layout techniques for dynamic cells, such as the 1-D methods of <ref> [9, 75] </ref>, focus on the layout of the N transistor netw ork only. Therefore, although the 1-D width and height minimization problems for dynamic cells are also NP-hard [19], they are much simpler than those for static cells which must simultaneously consider pairs of P and N transistors. <p> PpairNets [2] := PWR 10 4; set PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets <ref> [9] </ref> := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := <p> NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets <ref> [9] </ref> := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of
Reference: [10] <author> B. Basaran and R. Rutenbar, </author> <title> An O(n) Algorithm for Transistor Stacking with performance Constraints, </title> <booktitle> Physical Design Workshop, </booktitle> <pages> pp. 262-267, </pages> <year> 1996. </year>
Reference-contexts: Also, since columns 3 and 4 are connected by diffusion sharing, we set span [a, 4, r] = 1. However, net b appears only in columns 9 and 10, which are connected via diffusion sharing. Hence, span [b, 9, r] = span <ref> [b, 10, r] </ref> = 0. Now consider net c in columns 6 and 7 of the P and N dif fusion terminals of pairs p 2 and p 3 , respectively. These columns are separated by a diffusion gap. <p> PpairNets [3] := PWR 1 8; set PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets <ref> [10] </ref> := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := <p> NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets <ref> [10] </ref> := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of
Reference: [11] <author> B. Basaran, R. A. Rutenbar, and L. R. Carley, </author> <title> Latchup-Aware Placement and Parasitic-Bounded Routing of Custom Analog Cells, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 415-421, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Performance-directed synthesis techniques for electrically sensiti ve analog circuits ha ve been proposed to address problems such as crosstalk, latch-up, and parasitic capacitance <ref> [11, 24] </ref>. In the CMOS domain, however, cell synthesis techniques ha ve largely ignored performance considerations, perhaps because the CMOS cells are small enough that these problems are ne gligible. <p> PpairNets [4] := 14 1 10; set PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets <ref> [11] </ref> := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = <p> NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets <ref> [11] </ref> := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of [5] sho wn in Fig. 1.12 a.
Reference: [12] <author> T. M. Burks and K. A. Sakallah, </author> <title> Min-Max Linear Programming, </title> <type> Technical Report CSE-TR-166-93, </type> <institution> CSE Division, University of Michigan, </institution> <address> Ann Arbor, MI, </address> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction [111], timing-dri ven datapath layout [69], FPGA technology mapping [23], analog circuit synthesis [81], high-le vel synthesis [46], and timing analysis <ref> [12] </ref>. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity. In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization. <p> Further, we assume that if a net, such as d, appears on the same (P or N) dif fusion of two P/N pairs separated by a g ap, it is connected using metal1 to a void long diffusion wires, and hence requires a horizontal track. Thus, span <ref> [d, 12, r] </ref> = span [d, 13, r] = 1. <p> PpairNets [5] := PWR 2 15; set PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets <ref> [12] </ref> := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := <p> NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets <ref> [12] </ref> := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of [5] sho wn in Fig. 1.12 a.
Reference: [13] <author> Cadence Design Systems, Inc., </author> <title> Virtuoso Layout Synthesizer Tutorial and Reference, </title> <type> 1992-94. 191 </type>
Reference-contexts: A compacted 1-D layout of this circuit is shown in Fig. 1.12b; its 2-D layouts in two and three rows, respectively, are shown in Figs. 1.12 c and d. These layouts were generated using Virtuoso <ref> [13] </ref>, a cell synthesis tool from Cadence. The y use only a single metal layer for intra-cell routing, while the power and ground buses are routed in a second metal layer. The linear arrangement of transistors in the 1-D style allows only limited control over the cell dimensions. <p> Experimental results are presented to evaluate the speed of the two solvers and assess the effect of the number of rows on 2-D cell width. Layouts produced with our technique are found to be about 15% smaller than those produced by Virtuoso <ref> [13] </ref>, a commercial cell synthesis tool. The chain-W model does not contain information on the e xact position and orientation of each transistor in the cell; these parameters must be e xplicitly considered for cell height minimization. <p> For example, Poiriers [93] greedy transistor placement method can handle constraints on the number of diffusion rows or the shape of the cell boundary . A few layout tools such as Virtuoso <ref> [13] </ref> provide support for 2-D cell synthesis. <p> OPBDP times for pair-W were obtained using version 1.1 with the -h103 heuristic modified as described in Section 3.5. Cct. No. of pairs No. of rows 2-D cell width W cell Solution time of ILP solver (secs) 1 chain-W pair-W CLIP Virtuoso <ref> [13] </ref> OSL 2 OPBDP 3 OPBDP 4 1 5 2 4 5 3 4 4 4 0.3 102 4,826 0.03 0.9 0.01 0.05 0.12 1 3 5 5 4 6 5 5 15 328 0.01 0.4 2.3 0.09 0.19 3 6 2 4 7 3 2 4 5 1.3 41 2,194 <p> We therefore further modify OPBDPs -h103 heuristic to Cct. No. of pairs No. of rows 2-D cell width W cell Solution time of ILP solver (secs) chain-W pair-W CLIP Virtuoso <ref> [13] </ref> OSL OPBDP OPBDP 10 2 4 16 5 5 9 8 6 * * 150 3,072 73 4 9,561 1 3 18 8 19 10 34 * 52 1,368 79 2,446 12 20 1 23 24 * 4,454 * Table 3.7 (continued) 89 first select an unassigned Xrow [p, r] <p> Hence, run times with pair-W can be more accurately predicted as the circuit size increases. The optimal cell widths obtained by CLIP are significantly smaller than those produced by the commercial tool Virtuoso <ref> [13] </ref>, although Virtuosos run times are much less (a fe w seconds in all cases). <p> Thus, span [d, 12, r] = span <ref> [d, 13, r] </ref> = 1. <p> This, in turn, reduces the horizontal overlap of nets in each row and hence, the P/N channel density. 109 Also, CLIP layouts are significantly smaller than those obtained by the Cadence tool Virtuoso <ref> [13] </ref>. On the a verage, the cell widths and heights obtained with CLIP are 15% and 25% smaller, respectively, than the corresponding Virtuoso designs. <p> PpairNets [6] := 14 2 10; set PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets <ref> [13] </ref> := 9 3 7; set PpairNets [14] := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := <p> NpairNets [6] := 16 2 GND; set NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets <ref> [13] </ref> := 6 3 13; set NpairNets [14] := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of [5] sho wn in Fig. 1.12 a. It also compares the nonhierarchical layouts with the hierarchical ones generated using HCLIP.
Reference: [14] <author> B. S. Carlson, </author> <title> Transistor Chaining and Transistor Reordering in the Design of CMOS Complex Gates, </title> <type> Ph.D. Dissertation, </type> <institution> Syracuse University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> PpairNets [7] := 7 2 6; set PpairNets [8] := 8 2 9; set PpairNets [9] := 7 3 6; set PpairNets [10] := PWR 6 5; set PpairNets [11] := 15 1 14; set PpairNets [12] := PWR 3 14; set PpairNets [13] := 9 3 7; set PpairNets <ref> [14] </ref> := 7 1 6; set NpairNets [1] := 13 10 GND; set NpairNets [2] := 4 10 GND; set NpairNets [3] := 6 1 13; set NpairNets [4]: = 16 1 10; set NpairNets [5] := 10 2 17; set NpairNets [6] := 16 2 GND; set NpairNets [7] := <p> NpairNets [7] := 12 2 GND; set NpairNets [8] := 6 2 13; set NpairNets [9] := 11 3 6; set NpairNets [10] := 5 6 GND; set NpairNets [11] := 10 1 17; set NpairNets [12] := 17 3 GND; set NpairNets [13] := 6 3 13; set NpairNets <ref> [14] </ref> := 11 1 12; 186 APPENDIX B CLIP LAYOUTS This appendix presents geometrical representations of CLIP layouts for the full-adder circuit of [5] sho wn in Fig. 1.12 a. It also compares the nonhierarchical layouts with the hierarchical ones generated using HCLIP.
Reference: [15] <author> B. S. Carlson, C. Y. Roger Chen, and D. S. Meliksetian, </author> <title> Transistor Chaining in CMOS Leaf Cells of Planar Topology, </title> <booktitle> Proc. 6th Great Lakes Symp. on VLSI, </booktitle> <pages> pp. 194-199, </pages> <year> 1996. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> This composition process guides the concatenation of subgraph co vers to ultimately yield a minimumsized trail cover. For practical circuits of height four or less, the w orst-case execution time of P-TrailTrace is a few minutes. 41 Carlson et al. <ref> [15, 16] </ref> propose a linear time heuristic algorithm for transistor chaining in non-series-parallel circuits that produces the optimal solution for 82% of the circuits tested.
Reference: [16] <author> B. S. Carlson, C. Y. Roger Chen, and D. S. Meliksetian, </author> <title> Dual Eulerian Properties of Plane Multigraphs, </title> <journal> SIAM Journal of Discrete Mathematics, </journal> <volume> vol. 8, no. 1, </volume> <pages> pp. 33-50, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Such a pair is referred to as a dual trail. Since a dual trail represents a dual chain, a dual trail cover represents a dual chain cover that corresponds to a valid layout. A dual trail that contains all edges of the graph is called a dual-euler trail <ref> [16] </ref> and corresponds to a layout with no diffusion gaps. In summary, the 1-D cell width minimization problem for the CMOS cells of interest reduces to finding a dual trail co ver of minimum size. <p> Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> This composition process guides the concatenation of subgraph co vers to ultimately yield a minimumsized trail cover. For practical circuits of height four or less, the w orst-case execution time of P-TrailTrace is a few minutes. 41 Carlson et al. <ref> [15, 16] </ref> propose a linear time heuristic algorithm for transistor chaining in non-series-parallel circuits that produces the optimal solution for 82% of the circuits tested.
Reference: [17] <author> B. S. Carlson, C. Y. Roger Chen, and U. Singh, </author> <title> Optimal Cell Generation for Dual Independent Layout Styles, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 2, </volume> <pages> pp. 208-224, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: One-dimensional layout. The widely used one-dimensional (1-D) style [14, 20, 58, 62, 83, 92, 108] is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. While other 1-D styles ha ve been proposed <ref> [17, 65, 118] </ref> for certain specif ic application domains, the style of Fig. 1.11 a, which is assumed throughout this w ork, is most popular since it P-diffusion N-diffusion Diffusion gap P/N Fig. 1.10c NMOS PMOS P/N row #2 (b) Diffusion Chain #1 Chain #2 b a b c a c
Reference: [18] <author> B. S. Carlson and C. Y. Roger Chen, </author> <title> An Efficient Algorithm for the Identification of Dual Eulerian Graphs and its Application to Cell Layout, </title> <booktitle> Proc. IEEE International Symp. on Circuits and Systems, </booktitle> <volume> vol. 5, </volume> <pages> pp. 2248-2251, </pages> <year> 1992. </year>
Reference: [19] <author> S. Chakravarty, Xin He, and S. S. Ravi, </author> <title> Minimum area layout of series-parallel transistor networks is NP-hard, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 10, no. 6, </volume> <pages> pp. 770-782, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Computational complexity. Even for the restricted domain of series-parallel CMOS circuits, the problem of finding a 1-D layout of minimum height that also minimizes the cell width is NP-hard <ref> [19] </ref>. The cell layout problem can only be further complicated when one considers the more general 2-D style, less restricted circuit structures, or secondary area and performance optimization objectives. <p> Layout techniques for dynamic cells, such as the 1-D methods of [9, 75], focus on the layout of the N transistor netw ork only. Therefore, although the 1-D width and height minimization problems for dynamic cells are also NP-hard <ref> [19] </ref>, they are much simpler than those for static cells which must simultaneously consider pairs of P and N transistors.
Reference: [20] <author> C. C. Chen and S. L. Chow, </author> <title> The Layout Synthesizer: An Automatic Netlist-to-Layout System, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 232-238, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> If the number of chains is less than f ive, an exhaustive approach is used; else a min-cut placement algorithm iterati vely partitions the chain set into subsets with f ive or fewer chains; exhaustive enumeration is then applied to the individual subsets. Layout Synthesizer <ref> [20] </ref> aims at simultaneously maximizing dif fusion sharing and minimizing routing density. P/N pairs are formed based on common gate signals and other criteria. <p> Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques have generally ignored vertical constraints <ref> [20, 57, 82] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c. <p> Circuit No. trans. No. nets. No. rows W cell OPBDP run time (secs.) P/N folding limits P/N folding limits None 10 / 5 5 / 5 5 / 3 None 10 / 5 5 / 5 5 / 3 D-latch <ref> [20] </ref> 1 10 12 21 21 0.4 10 1 5 3 4 4 8 8 1 1 2 3 None 10 / 10 10 / 5 5 / 5 None 10 / 10 10 / 5 5 / 5 Series-parallel cct. z = (a.b.c + (g + h).(i + j)) 1
Reference: [21] <author> H. Chen and S. M. Kang, </author> <title> Performance Driven Cell Generator for Dynamic CMOS Circuits, </title> <booktitle> Proc. IEEE International Symp. on Circuits and Systems, </booktitle> <pages> pp. 1883-1886, </pages> <year> 1989. </year>
Reference-contexts: The latter is better since the parasitics induced by the layout can be accurately estimated and transistor resizing performed on-the-f ly as required. However, such dynamic folding is a comple x problem and has been only partially addressed for 1-D layout by a few heuristic methods <ref> [21, 109] </ref>. An indirect objective sometimes used for cell height reduction is to minimize the total wire length. This, in turn, can also enhance performance, especially for large 1-D cells that tend to have long wires running across the length of the cell.
Reference: [22] <author> C.Y. R. Chen and C. Y. Hou, </author> <title> A New Layout Optimization Methodology for CMOS Complex Gates, </title> <booktitle> Proc. IEEE International Conf. on CAD, </booktitle> <pages> pp. 368-371, </pages> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Run times are significantly reduced by using a theoretical lo wer bound on the size of the chain set to eliminate portions of the search tree that cannot lead to optimal solutions Other heuristic algorithms have been proposed for cell-width minimization. The method of Chen and Hou <ref> [22] </ref> aims at finding a minimum-width layout for any circuit ordering. It reorders the graph to reduce the number of vertices with odd degree, but is not applicable to circuits whose graphs all have even-degree vertices for all reorderings.
Reference: [23] <author> A. Chowdhary and J. P. Hayes, </author> <title> Technology Mapping for Field-Programmable Gate Arrays Using Integer Programming, </title> <booktitle> Proc. IEEE International Conf. on CAD, </booktitle> <pages> pp. 346-352, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: While ILP and related mathematical programming techniques ha ve been ignored for cell synthesis due to their percei ved computational complexity, recent research has successfully applied ILP-based methods to other CAD problems <ref> [23, 69, 81, 111] </ref>. The ILP approach used in this thesis has several advantages over existing heuristic methods: It guarantees optimal 2-D cell layouts and has optimal 1-D layout as a special case. <p> ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction [111], timing-dri ven datapath layout [69], FPGA technology mapping <ref> [23] </ref>, analog circuit synthesis [81], high-le vel synthesis [46], and timing analysis [12]. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity. In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization.
Reference: [24] <author> U. Choudhury and A. Sangiovanni-Vincentelli, </author> <title> Automatic Generation of Parasitic Constraints for Performance-Constrained Physical Design of Analog Circuits, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 2, </volume> <pages> pp. 208-224, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Performance-directed synthesis techniques for electrically sensiti ve analog circuits ha ve been proposed to address problems such as crosstalk, latch-up, and parasitic capacitance <ref> [11, 24] </ref>. In the CMOS domain, however, cell synthesis techniques ha ve largely ignored performance considerations, perhaps because the CMOS cells are small enough that these problems are ne gligible.
Reference: [25] <author> P. Codognet and D. Diaz, </author> <title> Boolean Constraint Solving Using CLP(FD), </title> <booktitle> International Logic Programming Symp., </booktitle> <address> Vancouver, British Columbia, Canada, </address> <publisher> MIT Press 1993. </publisher>
Reference: [26] <author> J. Cong, D. F. Wong, and C. L. Liu, </author> <title> A New Approach to Three or Four-layer Channel Routing, </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> vol. 7, </volume> <pages> pp. 1094-1104, </pages> <month> Oct. </month> <year> 1988. </year>
Reference: [27] <institution> CPLEX Optimization, Inc., CPLEX Documentation, </institution> <year> 1990. </year>
Reference-contexts: Then, the ILP problem is solved using algorithms that solve the related group problem. Branch-and-bound enumeration. Most commercial tools for solving ILP (or MILP) problems use the branch-and-bound implicit enumeration technique. Examples are the Optimization Subroutine Library (OSL) [66], CPLEX <ref> [27] </ref>, and LINDO [76]. A search tree is used to implicitly enumerate all possible solutions. Ev ery node in the tree represents a relax ed LP problem in which the inte grality constraints on a subset of the inte ger variables are removed or relaxed. <p> Since the solution method of OPBDP is specially designed to solv e a set of pseudo-boolean inequalities using SAT-based algorithms, it is significantly more efficient on our problem than LP-based solv ers such as OSL. We have also experimented with another LP-based solver CPLEX <ref> [27] </ref>; its run times were found to be similar to those of OSL. Thus, the cell layout optimization problem appears to be better suited to the SA T-based solution technique used in OPBDP than to the LP technique of OSL or CPLEX.
Reference: [28] <author> G. B. Dantzig, </author> <title> Linear Programming and Extensions, </title> <publisher> Princeton Univ. Press, </publisher> <address> Princeton, NJ, </address> <year> 1963. </year>
Reference-contexts: Linear programming. Most traditional ILP solv ers such as OSL, CPLEX, and LINDO use linear programming methods to solv e the relaxed LP problem at each node in the search tree. Common techniques for solving LP problems are the Simple x algorithm introduced in 1947 by Dantzig <ref> [28] </ref>, and the interior point algorithm due to Karmarkar [68]. Both emplo y geometric methods to traverse the convex feasible region delimited by the linear constraints.
Reference: [29] <author> G. B. Dantzig, </author> <title> On the significance of Solving Linear Programming Problems with Some Integer Variables, </title> <journal> Econometrica, </journal> <volume> vol. 28, </volume> <pages> pp. 30-44, </pages> <year> 1961. </year> <month> 192 </month>
Reference: [30] <author> M. Davis and H. Putnam, </author> <title> A Computing Procedure for Quantification Theory, </title> <journal> Journal of the ACM, </journal> <volume> vol. 7, </volume> <pages> pp. 201-205, </pages> <year> 1960. </year>
Reference-contexts: One such technique due to Barth is OPBDP (Optimizing with Pseudo-Boolean Davis-Putnam ) [6], an enumerative algorithm based on a Da vis-Putnam-style search procedure, and modified to handle LPB constraints instead of CNF formulas. The classical Davis-Putnam (DP) procedure <ref> [30] </ref> solves the satisfiability problem (SAT) for a set S of classical clauses by e xploring a search tree depth-first. Each node of the tree represents a subproblem of the original SA T problem with a fe w 56 boolean variables fixed to 0 or 1.
Reference: [31] <author> T. E. Dillinger, </author> <title> VLSI Engineering, </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1988. </year>
Reference-contexts: If this trend continues, Intel processors should contain between 50 and 100 million transistors by the turn of the century and should execute 2 billion instructions per second <ref> [31, 87] </ref>. An integrated circuit or IC refers to a large number of electronic components (transistors) and their interconnections that are placed in a single chip of semiconductor material [50]. ICs of the above complexity would not have been possible without the aid of computer programs. <p> The choice of a particular IC design style depends on several engineering tradeoffs that must be made based on the nature and comple xity of the product, design objectives, design team expertise, and the mark et competition. Figure 1.5 <ref> [31] </ref> illustrates some of these trade-offs for full- and semi-custom design methods. Semi-custom. Two of the most popular semi-custom design styles are g ate arrays and standard cells. A gate array [31], shown in Fig. 1.6a, consists of a two-dimensional array of cells separated by horizontal and vertical routing channels. <p> Figure 1.5 <ref> [31] </ref> illustrates some of these trade-offs for full- and semi-custom design methods. Semi-custom. Two of the most popular semi-custom design styles are g ate arrays and standard cells. A gate array [31], shown in Fig. 1.6a, consists of a two-dimensional array of cells separated by horizontal and vertical routing channels. As illustrated in Fig. 1.6b, each cell consists of a prefabricated, but unconnected, group of transistors.
Reference: [32] <author> A. Domic, et al., CLEO: </author> <title> A CMOS Layout Generator, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 340-343, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: d f out h G 2 G 4 G 5 1 3 1 2 4 3 1 2 3 4 3 G 1 G 2 G 3 G 4 G 5 (b) (d) 2 4 KEY 49 Another heuristic method for multiple-cell layout has been proposed by Domic et al. <ref> [32] </ref>. Their method CLEO first determines the exact order of each cell in the array using a recursive min-cut method.
Reference: [33] <author> M. Edahiro and T. Yoshimura, </author> <title> New Placement and Global Routing Algorithms for Standard Cell Layouts, </title> <booktitle> Proc. 27th Design Automation Conf., </booktitle> <pages> pp. 642-645, </pages> <year> 1990. </year>
Reference-contexts: Tani et al. demonstrate that their technique produces layouts that are up to 30% smaller in area than the best previous results <ref> [33] </ref>. However, since their approach is tar geted for quick layout synthesis of large CMOS cells with hundreds of transistors, it does not guarantee optimality for smaller cells, which are the focus of our work. The single-cell hierarchical synthesis problem is a generalized version of the multiple-cell problem.
Reference: [34] <author> R. Fourer, D. M. Gay, and B. W. Kernighan, AMPL: </author> <title> A Modeling Language for Mathematical Programming, </title> <publisher> Duxbury Press/Wadsworth Publishing, </publisher> <address> Belmont, CA, </address> <year> 1993. </year>
Reference-contexts: We present experimental results obtained with the heuristic that performs best, and analyze the reasons for its superior performance. Modeling language. There are several high-level languages, such as AMPL (A Mathematical Programming Language) <ref> [34] </ref> and GAMS (Generic Algebraic Modeling System) [36], to describe mathematical programs. These languages allo w the model to be described in a parameterized form, that is, independently of the input data used for a specific instance of the model. <p> have proven our hypothesis that exact algorithmic techniques are practical for 2-D cell layout, and can yield significantly better results than heuristic methods. 181 APPENDIX A AMPL MODEL FOR 2-D WIDTH MINIMIZATION This section presents a comprehensive example of a 0-1 ILP formulation implemented in AMPL (A Mathematical Programming Language) <ref> [34] </ref>. As noted in Section 2.6, AMPL separates a mathematical program into tw o sectionsthe model section that describes the functional description of the relationships between problem data, and the data section that consists of the problem data itself.
Reference: [35] <author> D. Gajski and R. H. Kuhn, </author> <title> New VLSI Tools, </title> <journal> IEEE Computer, </journal> <volume> vol. 16, no. 12, </volume> <pages> pp. 11-14, </pages> <month> Dec. </month> <year> 1983. </year>
Reference: [36] <author> GAMS Development Corporation, </author> <title> GAMS: A Users Guide, </title> <publisher> Boyd and Fraser Publishing, </publisher> <address> Boston, Mass., </address> <year> 1993. </year>
Reference-contexts: We present experimental results obtained with the heuristic that performs best, and analyze the reasons for its superior performance. Modeling language. There are several high-level languages, such as AMPL (A Mathematical Programming Language) [34] and GAMS (Generic Algebraic Modeling System) <ref> [36] </ref>, to describe mathematical programs. These languages allo w the model to be described in a parameterized form, that is, independently of the input data used for a specific instance of the model.
Reference: [37] <author> T. Gao and C. L. Liu, </author> <title> Minimum Crosstalk Channel Routing, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 15, no. 5, </volume> <pages> pp. 465-474, </pages> <month> May </month> <year> 1996. </year>
Reference: [38] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Since this optimization problem, lik e others in physical design tasks such as f loorplanning, placement, and routing, has been pro ven to be NP-hard <ref> [38] </ref>, any exact algorithm will, in the worst case, take an exponential amount of time to run. Therefore, because of the e xcessive computational cost of e xact optimization, CAD tool designers have generally avoided optimal algorithms in f avor of faster but less exact heuristic or ad-hoc methods.
Reference: [39] <author> R. Gomory, </author> <title> An Algorithm for Integer Solutions to Linear Programs, </title> <booktitle> in Recent Advances in Mathematical Programming, </booktitle> <editor> edited by R. L. Graves, </editor> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1963. </year>
Reference-contexts: These constraints are appended to the original constraint set and eventually produce a linear program whose optimal solution has integral values for the integer variables <ref> [39] </ref>. Enumerative techniques: These enumerate, either explicitly or implicitly, all possible solutions to the ILP problem. The optimal solution then is a feasible solution that minimizes (or maximizes) the objective function. <p> The efficiency of enumerative techniques depends on the bounding algorithm used to show that certain integer points cannot yield better solutions. Constructive algorithms: These construct the optimal solution by systematically adjusting values of integer variables until a feasible integer solution is found. One such method is Gomorys group-theoretic technique <ref> [39] </ref>. By relaxing the non-negativity constraints on certain variables, an ILP problem can be represented as a minimization problem on a group. Then, the ILP problem is solved using algorithms that solve the related group problem. Branch-and-bound enumeration.
Reference: [40] <author> D. Granot, F. Granot, and W. Vaessen, </author> <title> An Accelerated Covering Relaxation Algorithm for Solving 0-1 Positive Polynomial Programs, </title> <journal> Mathematical Programming, </journal> <volume> vol. 22, </volume> <pages> pp. 350-357, </pages> <year> 1982. </year>
Reference: [41] <author> B. Guan and C. Sechen, </author> <title> An Area Minimizing Layout Generator for Random Logic Blocks, </title> <booktitle> Proc. IEEE Custom Integrated Circuits Conf., </booktitle> <pages> pp. 457-460, </pages> <month> May </month> <year> 1995. </year>
Reference: [42] <author> A. Gupta, S-C. The, and J. P. Hayes, XPRESS: </author> <title> A Cell Layout Generator with Integrated Transistor Folding, </title> <booktitle> Proc. European Design & Test Conf., </booktitle> <pages> pp. 393-400, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: When a design migrates from one technology to another , cell synthesis can be used for f ast and efficient generation of layouts in the ne w technology. For example, if large transistors have to be folded <ref> [42] </ref> to conform to the ne w technology rules, cell layouts can be synthesized using dif ferent folding limits and the best layout chosen based on design constraints such as cell width and/or height. <p> This can result in non-uniform transistor heights. To make transistor heights uniform, a lar ge transistor can be folded into se veral smaller transistors called legs connected in parallel <ref> [42, 55, 80] </ref>. However, since folding increases the total number of transistors, it complicates the task of diffusion sharing, and can increase both the cell width and the number of routing tracks. <p> Folding should therefore be considered during the process of determining dif fusion sharing, transistor orientations, and their relative ordering. During his work at Intel Corporation prior to joining the Uni versity of Michigan, the author designed and implemented a heuristic cell synthesis tool XPRESS <ref> [42] </ref>, which generates 1-D layouts for comple x CMOS netw orks with individually-sized transistors and no special restrictions on the network structure. XPRESS integrates folding into the algorithms that maximize diffusion sharing and also reduce the cell height. <p> Although the problem of transistor chain generation has been solv ed using various algorithms <ref> [42, 62, 82, 114] </ref>, a technique that is applicable to the entire class of complex dual CMOS networks in required. We use the exact chain generation algorithm proposed by Gupta et al. for the XPRESS cell synthesis tool [42]. <p> We use the exact chain generation algorithm proposed by Gupta et al. for the XPRESS cell synthesis tool <ref> [42] </ref>. The resulting ILP model will be referred to as chain-W to indicate that it is based on transistor chains and addresses cell width minimization only. the circuit is preprocessed to generate an e xhaustive list of its transistor chains. <p> The height of the cell then depends only on the number of horizontal routing tracks. Ho wever, many practical designs have nonuniform transistor sizes since each transistor is indi vidually sized to meet the circuits performance requirements. For such circuits, transistor folding techniques <ref> [42] </ref>, described earlier in Section 2.4, are usually employed to make transistor heights uniform. Without transistor folding, the cost function for cell height deri ved in this chapter must be modif ied to consider transistor heights in addition to the horizontal routing tracks. <p> The chain generation algorithm of <ref> [42] </ref> is based on pairwise diffusion sharing. <p> The input circuit is first partitioned into clusters, typically logic gates, using known methods <ref> [42, 96] </ref>. Next, the set of all min-coversthe smallest set of transistor chains that covers a circuitis generated for each cluster . <p> F or this work, min-covers were generated using the e xact algorithms described in <ref> [42] </ref> for the XPRESS cell synthesis tool. The combined set of such min-co vers for each cluster forms the input to the ILP layout model. <p> The circuits are typical designs from various sources, and range in size from 20 to 100 transistors. Where feasible, we also present the optimal cell width obtained with the original non-hierarchical model pair-W, or with XPRESS <ref> [42] </ref> (for 1-D placement only). When the optimum 2-D widths are not kno wn, Table 6.3 presents a lower bound for W cell , which ignores the ef fects of inter-row connectivity in Eq. (6.3) on the cell width. <p> Lower bounds on W cell are based only on the number of P/N pairs and the number of diffusion gaps in an optimal 1 D placement; the effect of inter-row connections is ignored. Optimal 1-D cell widths were obtained using the non hierarchical model or XPRESS <ref> [42] </ref>. 2. A indicates that the number of chains is less than the number of P/N rows j, so no j-row placement is possible. No. Circuit No. of trans. No. of clusts. <p> Experimental results. The results presented here were obtained using the e xperimental procedure described below: 1. For each cluster G, generate a list covers of all min-covers, that is, chain covers that yield a minimum-width 1-D layout of G. These covers are generated using the XPRESS cell synthesis tool <ref> [42] </ref>. 2. Solve the hier-WH model for the circuit using the set covers to obtain a layout that has the least height among all layouts with minimum width. 3. Let the longest chain among all min-covers of the circuit have l P/N pairs. <p> It fixes the number of legs for each transistor, and then aims at determining their position and orientation so that cell area objecti ve is minimized. For 1-D layout, this problem has been addressed by Gupta et al. in their XPRESS <ref> [42] </ref> tool and by Malavasi and Pandini [80]. (b) after folding with transistors in place; (c) after re-orienting and re-positioning transistors 1 2 3 2 7 1 2 7 1 2 3 2 4 5 4 6 5 8 Folding Flip P 1 Move N 2 to right (a) (b) N <p> This technique, which is implemented as the XPRESS cell synthesis tool <ref> [42] </ref>, addresses problem 3 for 1-D layout of complex CMOS networks. XPRESS folds transistors prior to synthesis and then explores diffusion sharing between the folded transistors to reduce the number of dif fusion gaps and simultaneously reduce the cell height.
Reference: [43] <author> A. Gupta and J. P. Hayes, </author> <title> Width Minimization of Two-Dimensional CMOS Cells Using Integer Programming, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 660-667, </pages> <month> Nov. </month> <year> 1996. </year>
Reference: [44] <author> A. Gupta and J. P. Hayes, </author> <title> A Hierarchical Technique for Minimum-Width Layout of Two-Dimensional CMOS Cells, </title> <booktitle> Proc. International Conf. on VLSI Design, </booktitle> <pages> pp. 15-20, </pages> <month> Jan. </month> <year> 1997. </year>
Reference: [45] <author> A. Gupta and J. P. Hayes, CLIP: </author> <title> An Optimizing Layout Generator for Two-Dimensional CMOS Cells, </title> <booktitle> Proc. 34th Design Automation Conf., </booktitle> <year> 1997, </year> <note> to appear. </note>
Reference: [46] <author> L. Hafer and A. Parker, </author> <title> A Formal Method for the Specification, Analysis, and Design of Register-Transfer Digital Logic, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 2, </volume> <pages> pp. 4-18, </pages> <month> Jan. </month> <year> 1983. </year> <month> 193 </month>
Reference-contexts: ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction [111], timing-dri ven datapath layout [69], FPGA technology mapping [23], analog circuit synthesis [81], high-le vel synthesis <ref> [46] </ref>, and timing analysis [12]. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity. In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization.
Reference: [47] <author> P. Hansen, B. Jaumard, and V. Mathon, </author> <title> Constrained Nonlinear 0-1 Programming, </title> <journal> ORSA Journal of Computing, </journal> <volume> vol. 5, no. 2, </volume> <pages> pp. 97-119, </pages> <month> Spring </month> <year> 1993. </year>
Reference: [48] <author> F. Harary, </author> <title> Graph Theory, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: The method of Uehara and VanCleemput [108] models a static dual CMOS circuit, such as that in Fig. 2.1 a (taken from [108]), by a pair of dual two-terminal series-parallel multigraphs (TTSPMs) <ref> [48] </ref>: an NMOS graph M and its geometric dual PMOS graph M d . These graphs are shown in Fig. 2.1b. Each edge e i in these graphs corresponds to a transistor.
Reference: [49] <author> M. A. Harrison, </author> <title> Introduction to Switching and Automata Theory, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: Non-series-parallel circuits. Sometimes logic functions can be implemented with non-series-parallel (non-SP) structures that use f ar fewer transistors and hence, much less area, than an y series-parallel implementation. Of the optimal netw ork implementations of all four v ariable switching functions, 51% are kno wn to have non-SP structures <ref> [49] </ref>. Maziasz and Hayes [82] present an example in which the SP circuit requires 42 transistors, while the non-SP v ersion requires only 16; the former has a 1-D layout that is 2.3 times lar ger in area than the latter.
Reference: [50] <author> J. P. Hayes, </author> <title> Introduction to Digital Logic Design, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1993. </year>
Reference-contexts: An integrated circuit or IC refers to a large number of electronic components (transistors) and their interconnections that are placed in a single chip of semiconductor material <ref> [50] </ref>. ICs of the above complexity would not have been possible without the aid of computer programs. Computer-aided design, or CAD, is the process of using computer programs in the design of VLSI chips.
Reference: [51] <author> H. Heeb and W. Fichtner, GRAPES: </author> <title> a module generator based on planarity, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 428-431, </pages> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>.
Reference: [52] <author> D. V. Heinbuch, </author> <title> CMOS3 Cell Library, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: Standard cells usually 9 have a fixed height and fixed I/O pin locations. Examples of standard cells include basic logic structures such as inverters, NANDs, NORs, and multiplexers. An example of a cell library may be found in <ref> [52] </ref>. A datapath bit-cell is either a single one-bit slice, or a portion of such a slice, of an arithmetic logic unit, adder, multiplier, shifter, register file, or similar functional component of an IC. <p> e.f.g.h + (i + j).(k + l))' [82] 9 8-input NAND circuit 24 20 78 10 Full adder [5] 28 17 92 11 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l).(m + n).(o + p))' [82] 12 4-bit parity stage (implements 5-bit parity circuit) <ref> [52] </ref> 40 25 214 Table 3.6: Representative CMOS circuits used for experimentation 87 1. The OPBDP data was obtained on the HP 9000/735 workstation which is approximately 50% faster than the IBM RS/6000 used for the OSL experiments. 2. <p> Run time (secs.) pair-W hier-W pair-W hier-W 1 8-input NAND [96] 1 3 5 7 4 14 5 3 7 4 3 58 272 0.05 0.1 2 Full adder 2 [5] 1 3 5 8 5 16 5 5 8 7 13 226 9,773 0.02 0.05 3 multiplexer with enable <ref> [52] </ref> 1 3 5 12 5 22 * * 12 9 447 * * 0.1 0.5 4 4-bit parity stage (5-bit parity circuit) [52] 40 8 5 2 4 23 7 4 * * 23 8 5 * * 5 10 21 2-to-4 decoder [52] 1 3 5 13 6 * <p> 272 0.05 0.1 2 Full adder 2 [5] 1 3 5 8 5 16 5 5 8 7 13 226 9,773 0.02 0.05 3 multiplexer with enable <ref> [52] </ref> 1 3 5 12 5 22 * * 12 9 447 * * 0.1 0.5 4 4-bit parity stage (5-bit parity circuit) [52] 40 8 5 2 4 23 7 4 * * 23 8 5 * * 5 10 21 2-to-4 decoder [52] 1 3 5 13 6 * * * 14 7 * * * 0.03 0.08 6 2-bit adder 56 8 7 1 3 5 16 8 * * * <p> 0.02 0.05 3 multiplexer with enable <ref> [52] </ref> 1 3 5 12 5 22 * * 12 9 447 * * 0.1 0.5 4 4-bit parity stage (5-bit parity circuit) [52] 40 8 5 2 4 23 7 4 * * 23 8 5 * * 5 10 21 2-to-4 decoder [52] 1 3 5 13 6 * * * 14 7 * * * 0.03 0.08 6 2-bit adder 56 8 7 1 3 5 16 8 * * * 16 8 * * * 3.3 2 7 multiplexer with enable [52] 1 3 5 23 11 * * * 23 <p> 8 5 * * 5 10 21 2-to-4 decoder <ref> [52] </ref> 1 3 5 13 6 * * * 14 7 * * * 0.03 0.08 6 2-bit adder 56 8 7 1 3 5 16 8 * * * 16 8 * * * 3.3 2 7 multiplexer with enable [52] 1 3 5 23 11 * * * 23 13 * * * 8 172 8 3-bit carry look-ahead circuit [52] 76 13 5.9 2 4 52 17 10 * * 52 17 11 * * 0.05 280 3270 3-to-8 decoder [52] 1 3 5 29 14 * * * <p> * * 0.03 0.08 6 2-bit adder 56 8 7 1 3 5 16 8 * * * 16 8 * * * 3.3 2 7 multiplexer with enable <ref> [52] </ref> 1 3 5 23 11 * * * 23 13 * * * 8 172 8 3-bit carry look-ahead circuit [52] 76 13 5.9 2 4 52 17 10 * * 52 17 11 * * 0.05 280 3270 3-to-8 decoder [52] 1 3 5 29 14 * * * 29 14 * * * 1 15 Table 6.3: Comparison of non-hierarchical and hierarchical 2-D cell layouts 140 circuits as small <p> * * 3.3 2 7 multiplexer with enable <ref> [52] </ref> 1 3 5 23 11 * * * 23 13 * * * 8 172 8 3-bit carry look-ahead circuit [52] 76 13 5.9 2 4 52 17 10 * * 52 17 11 * * 0.05 280 3270 3-to-8 decoder [52] 1 3 5 29 14 * * * 29 14 * * * 1 15 Table 6.3: Comparison of non-hierarchical and hierarchical 2-D cell layouts 140 circuits as small as the full adder can be obtained by nonhierarchical methods or by partitioning them into more number of smaller-sized clusters. <p> size No. of covers No. of rows W cell 1 H cell 2 Run time (secs) 3 Max. chain size Max. chain size Orig. 4 3 Orig. 4 3 Full adder [5] 1 3 16 7 6 12 6 11 6 11 0.2 0.3 2 1 18 6 4-to-1 multiplexer <ref> [52] </ref> 1 3 22 9 9 12 8 12 8 12 110 4 33 6 1900 15 4-bit parity stage (5-bit parity circuit) [52] 1 3 23 11 6 16 10 18 0.1 0.2 15 7 2-to-4 decoder [52] 1 3 27 9 5 13 10 13 17 57 987 285 <p> Orig. 4 3 Orig. 4 3 Full adder [5] 1 3 16 7 6 12 6 11 6 11 0.2 0.3 2 1 18 6 4-to-1 multiplexer <ref> [52] </ref> 1 3 22 9 9 12 8 12 8 12 110 4 33 6 1900 15 4-bit parity stage (5-bit parity circuit) [52] 1 3 23 11 6 16 10 18 0.1 0.2 15 7 2-to-4 decoder [52] 1 3 27 9 5 13 10 13 17 57 987 285 2-bit full adder 4 [52] 1 3 33 11 6 25 6 * 6 * 60 7 576 * 395 * Table 6.6: <p> 6 11 6 11 0.2 0.3 2 1 18 6 4-to-1 multiplexer <ref> [52] </ref> 1 3 22 9 9 12 8 12 8 12 110 4 33 6 1900 15 4-bit parity stage (5-bit parity circuit) [52] 1 3 23 11 6 16 10 18 0.1 0.2 15 7 2-to-4 decoder [52] 1 3 27 9 5 13 10 13 17 57 987 285 2-bit full adder 4 [52] 1 3 33 11 6 25 6 * 6 * 60 7 576 * 395 * Table 6.6: Cell heights and run times obtained with the hierarchical hier-WH model 154 For the original <p> 9 12 8 12 8 12 110 4 33 6 1900 15 4-bit parity stage (5-bit parity circuit) <ref> [52] </ref> 1 3 23 11 6 16 10 18 0.1 0.2 15 7 2-to-4 decoder [52] 1 3 27 9 5 13 10 13 17 57 987 285 2-bit full adder 4 [52] 1 3 33 11 6 25 6 * 6 * 60 7 576 * 395 * Table 6.6: Cell heights and run times obtained with the hierarchical hier-WH model 154 For the original set of covers, OPBDPs run times are in seconds for circuits with up to 40 transistors, and <p> These layouts in one, two, and three P/N rows were generated by enforcing different folding limits on the P and N transistors. (Note that the full adder of [62] has a dif ferent circuit implementation than the corresponding circuit of <ref> [52] </ref> in Table 3.6.) As in previous chapters, the run times were obtained with the OPBDP 0-1 ILP solver. OPBDPs -h103 heuristic was used for layout in a single P/N row; for two or more rows, OPBDPs -h101 heuristic proved to have the shortest run times.
Reference: [53] <author> T. W. Her, T-C Wang, and D. F. Wong, </author> <title> Performance-Driven Channel Pin Assignment Algorithms, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, </volume> <pages> pp. 849-857, </pages> <month> July </month> <year> 1995. </year>
Reference: [54] <author> T. W. Her and D. F. Wong, </author> <title> On Over-the-Cell Channel Routing with Cell Orientation Consideration, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, </volume> <pages> pp. 766-771, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: This has traditionally been referred to as the channel routing problem [95]. A variant of this problem occurs in o ver-the-cell (OTC) routing <ref> [54] </ref> where, gi ven a row of cells with pin terminals located at their top and bottom edges, the goal is to determine the set of nets that can be routed entirely over the cells, subject to constraints on the number of a vailable routing tracks. <p> their top and bottom boundaries, as well as the number of tracks a vailable for routing over the cell; the goal then is to select as many nonintersecting net se gments as possible to be routed o ver the cells so that the track densities in the channels is minimized <ref> [54, 61, 89, 117] </ref>. Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions [61], and minimization of net lengths along with the channel density [89]. <p> Some v ariants of OTC routing include simultaneous selection of an orientation of each cell <ref> [54] </ref>, permutation of terminal positions [61], and minimization of net lengths along with the channel density [89]. Since the pair-WH model combines channel density computation with the 2-D placement and orientation of pairs, it can be easily adapted to solve the above OTC routing problems as well. Summary.
Reference: [55] <author> T. W. Her, and D. F. Wong, </author> <title> Cell Area Minimization by Transistor Folding, </title> <booktitle> Proc. European Design Automation Conf., </booktitle> <pages> pp. 172-177, </pages> <year> 1993. </year>
Reference-contexts: This can result in non-uniform transistor heights. To make transistor heights uniform, a lar ge transistor can be folded into se veral smaller transistors called legs connected in parallel <ref> [42, 55, 80] </ref>. However, since folding increases the total number of transistors, it complicates the task of diffusion sharing, and can increase both the cell width and the number of routing tracks. <p> While GENAC [92] calculates the number of transistor legs based on a cost function that approximates cell area, LiB [62] and THEDA.P [65] fold transistors when the 44 height of a P/N pair e xceeds a specified limit on cell height. Her and W ong <ref> [55] </ref> propose a polynomial-time algorithm which, given a linear transistor order , determines a folding that minimizes cell height. Since all the abo ve techniques perform folding after the determination of chains or the linear order, they can restrict the amount of folding and yield suboptimal sharing. <p> Problem 2 also pre-specifies a transistor placement, but determines the number of legs for each transistor during the solution phase. The technique of Her and W ong <ref> [55] </ref> addresses this problem. It uses an e xact linear-time dynamic programming algorithm to e xplore all possible foldings and both orientations for each transistor, and selects a folding and orientation that reduces 158 the number of diffusion gaps as well as the channel height in a 1-D placement.
Reference: [56] <author> T.W. Her, D.F. Wong, and T.H. Freeman, </author> <title> Optimal Orientations of Transistor Chains, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 524-527, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: These chains are placed in a linear f ashion so as to reduce the channel density . Her et al. <ref> [56] </ref> describe an algorithm that, gi ven a fixed transistor order, flips chains and subchains to minimize 40 the channel density.
Reference: [57] <author> D.D. Hill, Sc2: </author> <title> A Hybrid Automatic Layout System, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 172-174, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> Ho wever, the generality of this method leads to inef ficiencies in the quality of the f inal layout. As Maziasz and Hayes [82] demonstrate for an exclusive-or circuit, their exact technique produces a 1-D layout that is 80% smaller than that produced by SOLO. Techniques proposed by Hill <ref> [57] </ref>, W imer et al. [114], and Shiraishi et al. [101] also handle arbitrary CMOS netw orks. The method of Wimer et al. forms an e xhaustive list of chains, and then selects the smallest chain co ver that reduces the cell height based on routing density . <p> Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques have generally ignored vertical constraints <ref> [20, 57, 82] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c.
Reference: [58] <author> D. D. Hill and B. Preas, </author> <title> Benchmarks for Cell Synthesis, </title> <booktitle> Proc. 27th Design Automation Conf., </booktitle> <pages> pp. 317-320, </pages> <year> 1990. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c.
Reference: [59] <author> D. A. Hodges and H. G. Jackson, </author> <title> Analysis and Design of Digital Integrated Circuits, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: The layout of an IC affects not only its area but also its performance, yield, and reliability. The performance of an IC is often measured by tw o intrinsic parametersthe propag ation and switching delayswhich control the maximum operating frequenc y of the circuit <ref> [59] </ref>. Propagation delay is defined as the time tak en by a signal to propag ate from the circuits input to its output. Switching delay measures the time taken for a signal to switch its state from logical 0 to logical 1 (rise time), or vice versa (fall time).
Reference: [60] <author> J. N. Hooker, </author> <title> Logic-based Methods for Optimization, </title> <journal> ORSA CSTS Newsletter, </journal> <volume> vol. 15(2), </volume> <pages> pp. 4-11, </pages> <year> 1994. </year>
Reference-contexts: An LPB optimization problem requires finding an assignment of 0-1 values to the boolean variables that optimizes a LPB objecti ve function while satisfying a system of LPB inequalities. Recently, new logic-based methods have been developed for solving LPB optimization problems <ref> [6, 7, 8, 60] </ref>. These are based on the observ ation that the problem of locating a feasible solution to a system of LPB constraints is a generalization of the well-known problem of verifying the satisfiability of a boolean function in conjuncti ve normal form (CNF-SAT) [7].
Reference: [61] <author> C. Y. Hou and C. Y. R. Chen, </author> <title> A Pin Permutation Algorithm for Improving Over-the-Cell Channel Routing, </title> <booktitle> Proc. 29th Design Automation Conf., </booktitle> <pages> pp. 594-599, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: their top and bottom boundaries, as well as the number of tracks a vailable for routing over the cell; the goal then is to select as many nonintersecting net se gments as possible to be routed o ver the cells so that the track densities in the channels is minimized <ref> [54, 61, 89, 117] </ref>. Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions [61], and minimization of net lengths along with the channel density [89]. <p> Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions <ref> [61] </ref>, and minimization of net lengths along with the channel density [89]. Since the pair-WH model combines channel density computation with the 2-D placement and orientation of pairs, it can be easily adapted to solve the above OTC routing problems as well. Summary.
Reference: [62] <author> Y-C Hsieh, C-Y Hwang, Y-L Lin, and Y-C Hsu, </author> <title> LiB: A CMOS Cell Compiler, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 10, </volume> <pages> pp. 994-1005, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> Although GENAC seems to have exponential time complexity, it has been shown to be fast for small practical cells. LiB <ref> [62] </ref> performs clustering to identify strongly connected groups of transistors, forms pairs within each cluster, and represents diffusion sharing as a bipartite graph. <p> However, only a few proposed techniques support folding. While GENAC [92] calculates the number of transistor legs based on a cost function that approximates cell area, LiB <ref> [62] </ref> and THEDA.P [65] fold transistors when the 44 height of a P/N pair e xceeds a specified limit on cell height. Her and W ong [55] propose a polynomial-time algorithm which, given a linear transistor order , determines a folding that minimizes cell height. <p> Although the problem of transistor chain generation has been solv ed using various algorithms <ref> [42, 62, 82, 114] </ref>, a technique that is applicable to the entire class of complex dual CMOS networks in required. We use the exact chain generation algorithm proposed by Gupta et al. for the XPRESS cell synthesis tool [42]. <p> For example, diffusion sharing between transistors belonging to different clusters depends on transistor placement within each cluster . Hence, hierarchical layout techniques, such as those proposed in <ref> [62, 82, 92, 114] </ref> for 1-D cell arrays, that generate intra and inter-cluster layouts in two sequential stages can yield layouts that are arbitrarily far from optimal. <p> Her and Wong also extend their technique to heuristically address 2-D layout for problem 2. Other heuristic techniques for this problem are included in the GENAC [92], LiB <ref> [62] </ref>, and THEDA.P [65] 1-D cell synthesis tools. While GENAC calculates the number of transistor le gs based on a cost function that approximates cell area, LiB and THEDA.P fold transistors when the height of a pair e xceeds the specified cell height. <p> These layouts in one, two, and three P/N rows were generated by enforcing different folding limits on the P and N transistors. (Note that the full adder of <ref> [62] </ref> has a dif ferent circuit implementation than the corresponding circuit of [52] in Table 3.6.) As in previous chapters, the run times were obtained with the OPBDP 0-1 ILP solver. <p> cct. z = (a.b.c + (g + h).(i + j)) 1 11 17 20 26 0.1 95 0.3 1 3 5 7 8 10 7 41 68 96 None 10 / 5 10 / 4 8 / 2 None 10 / 5 10 / 4 8 / 2 4-to-1 multiplexer <ref> [62] </ref> 1 14 17 24 38 50 7 137 2,261 3 5 6 8 12 31 13 41 36 None 20 / 5 10 / 5 5 / 5 None 20 / 5 10 / 5 5 / 5 8-input NAND 24 20 2 7 10 13 22 6 35 172 <p> 5 5 / 5 None 20 / 5 10 / 5 5 / 5 8-input NAND 24 20 2 7 10 13 22 6 35 172 13 None 10 / 4 8 / 3 5 / 2 None 10 / 4 8 / 3 5 / 2 Full adder 1 <ref> [62] </ref> 1 16 17 * * 12 2 * * 3 6 7 12 12 90 290 1,857 3,137 Table 7.1: Minimum width layouts and run times obtained for the pair-WF model with various folding limits on the P and N transistors 166 T R = max - S span [n, <p> No. nets. No. rows OPBDP run times (secs.) 1 P/N folding limits None 20 / 5 10 / 5 5 / 5 8-input NAND 24 17 2 6 4 35 2 172 0.2 13 5 None 10 / 4 8 / 3 5 / 2 Full adder <ref> [62] </ref> 1 12 4 2 0.5 * 871 * 2,300 3 90 1 290 1 1,857 25 3,137 32 None 10 / 10 5 / 5 4 / 4 Series-parallel cct. z = (a.b.c.d + l)(m + n)(o + p)) 1 48 2 * 280 * 1,735 6 1 3 *
Reference: [63] <author> L-H Hsu, J-Y Hwang, T. Y. Ho, and C. H. Tsai, </author> <title> A Linear Time Algorithm to Recognize the Double Euler Trail for Series-Parallel Networks, </title> <booktitle> Proc. 2nd International Symp. on Algorithms, </booktitle> <pages> pp. 316-325, </pages> <month> Dec </month> <year> 1991. </year> <month> 194 </month>
Reference-contexts: SP-circuit; for t &gt; 1, N is a SP-circuit if it consists of series (parallel) connections of sub-networks N 1 , N 2 , ..., N k where each of N 1 , N 2 , ..., N k is itself a SP-network consisting of subnetworks connected in parallel (series) <ref> [63] </ref>. Further , if the pullup and pulldown subcircuits are such that for e very transistor in series (parallel) in one subcircuit, there exists a transistor with the same gate signal in parallel (series) in the other subcircuit, then the circuit is said to be a geometric dual. <p> Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques [15, 16, 22, 64, 72, 73, 78, 82, 84, 88]. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time <ref> [63, 82, 88] </ref>. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Subgraphs in this modif ied graph are then rearranged so that the number of real and pseudo edges that occur in sequence is maximized. The resulting dual-euler trail (which can be found in linear time <ref> [63] </ref>) corresponds to a 1-D layout in which the pseudo-edges represent dif fusion gaps. However, this heuristic does not guarantee a minimum-width layout.
Reference: [64] <author> C-Y Hwang, Y-C Hsieh, Y-L Lin and Y-C Hsu, </author> <title> A Fast Transistor-Chaining Algorithm for CMOS Cell Layout, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 9, </volume> <pages> pp. 781-786, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> wever, optimal only when some ordering of the graph has a dual-euler trail. a a c S S N b c S cb M 1 M 1 M 1 M 3 M 3 a 38 A fast and optimal method for general CMOS circuits proposed by Hw ang et al. <ref> [64] </ref> guarantees a minimum number of chains. After forming P/N pairs, it models pairwise dif fusion sharing as a bipartite graph. A depth-first search algorithm is used to search for a maximum set of edges in the graph that corresponds to a maximum number of dif fusion abutments. <p> Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> An exhaustive branch-and-bound search on the graph determines a minimal number of chains that yield an optimal cell width <ref> [64] </ref>. A linear arrangement of the selected chains is then determined so as to reduce the interconnections between chains and, in turn, the cell height.
Reference: [65] <author> C-Y Hwang, Y-C Hsieh, Y-L Lin, and Y-C Hsu, </author> <title> An Efficient Layout Style for Two-metal CMOS Leaf Cells and its Automatic Synthesis, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 3, </volume> <pages> pp. 410-424, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: One-dimensional layout. The widely used one-dimensional (1-D) style [14, 20, 58, 62, 83, 92, 108] is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. While other 1-D styles ha ve been proposed <ref> [17, 65, 118] </ref> for certain specif ic application domains, the style of Fig. 1.11 a, which is assumed throughout this w ork, is most popular since it P-diffusion N-diffusion Diffusion gap P/N Fig. 1.10c NMOS PMOS P/N row #2 (b) Diffusion Chain #1 Chain #2 b a b c a c <p> However, only a few proposed techniques support folding. While GENAC [92] calculates the number of transistor legs based on a cost function that approximates cell area, LiB [62] and THEDA.P <ref> [65] </ref> fold transistors when the 44 height of a P/N pair e xceeds a specified limit on cell height. Her and W ong [55] propose a polynomial-time algorithm which, given a linear transistor order , determines a folding that minimizes cell height. <p> Her and Wong also extend their technique to heuristically address 2-D layout for problem 2. Other heuristic techniques for this problem are included in the GENAC [92], LiB [62], and THEDA.P <ref> [65] </ref> 1-D cell synthesis tools. While GENAC calculates the number of transistor le gs based on a cost function that approximates cell area, LiB and THEDA.P fold transistors when the height of a pair e xceeds the specified cell height.
Reference: [66] <author> IBM Corporation, </author> <title> Optimization Subroutine Library, </title> <year> 1990. </year>
Reference-contexts: In all our models, v ariables are restricted to tak e 0 or 1 binary values only; such models are referred to as 0-1 or binary ILP models. The ILP formulations of the cell layout problem are solved using two solver programs: OSL <ref> [66] </ref>, a commercial general 28 purpose ILP solver from IBM Corp., and OPBDP [6], a specialized solv er for 0-1 ILP problems. <p> Then, the ILP problem is solved using algorithms that solve the related group problem. Branch-and-bound enumeration. Most commercial tools for solving ILP (or MILP) problems use the branch-and-bound implicit enumeration technique. Examples are the Optimization Subroutine Library (OSL) <ref> [66] </ref>, CPLEX [27], and LINDO [76]. A search tree is used to implicitly enumerate all possible solutions. Ev ery node in the tree represents a relax ed LP problem in which the inte grality constraints on a subset of the inte ger variables are removed or relaxed.
Reference: [67] <author> R. G. Jeroslow and J. Wang, </author> <title> Solving Propositional Satisfiability Problems, </title> <journal> Annals of Mathematics and AI, </journal> <volume> vol. 1, </volume> <pages> pp. 167-187, </pages> <year> 1990. </year>
Reference-contexts: [p 6 , 3] and Xor [p 4 , 2] Xor [p 7 , 1] and Xor [p 1 , 3] + Xor [p 7 , 3] and Xor [p 1 , 1] (c) 85 function have been fixed, the heuristic def aults to the adapted twosided Jeroslow-Wang (JW) heuristic <ref> [67] </ref>. The JW-rule tries to reduce the search tree by selecting a v ariable that fixes a maximal number of the remaining un-fixed variables. To explain the superior performance of the -h103 heuristic, we reexamine the objective function that computes the cell width W cell .
Reference: [68] <author> N. Karmarkar, </author> <title> A New Polynomial Time Algorithm for Linear Programming, </title> <journal> Combinatorica, </journal> <volume> vol. 4, </volume> <pages> pp. 373-395, </pages> <year> 1984. </year>
Reference-contexts: Common techniques for solving LP problems are the Simple x algorithm introduced in 1947 by Dantzig [28], and the interior point algorithm due to Karmarkar <ref> [68] </ref>. Both emplo y geometric methods to traverse the convex feasible region delimited by the linear constraints. The Simple x method, which jumps from one boundary point to an adjacent one, has e xponential worst-case time complexity but has been observ ed to perform e xceedingly well in practice. <p> In contrast, interior-point methods, which start from an interior point and con verge towards an optimal boundary point, have polynomial time complexity and have been shown to be substantially f aster than the Simplex method for several large problems <ref> [68, 123] </ref>. Pseudo-boolean optimization. A linear pseudo-boolean optimization (LPB) problem is a special case of a general ILP problem in which all v ariables are restricted to boolean (0 or 1) values and all coefficients are integers.
Reference: [69] <author> J. Kim and S. M. Kang, </author> <title> A Timing-driven Data Path Layout Synthesis with Integer Programming, </title> <booktitle> Proc. IEEE International Conf. on CAD, </booktitle> <pages> pp. 716-719, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: While ILP and related mathematical programming techniques ha ve been ignored for cell synthesis due to their percei ved computational complexity, recent research has successfully applied ILP-based methods to other CAD problems <ref> [23, 69, 81, 111] </ref>. The ILP approach used in this thesis has several advantages over existing heuristic methods: It guarantees optimal 2-D cell layouts and has optimal 1-D layout as a special case. <p> ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction [111], timing-dri ven datapath layout <ref> [69] </ref>, FPGA technology mapping [23], analog circuit synthesis [81], high-le vel synthesis [46], and timing analysis [12]. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity.
Reference: [70] <author> J. Kim, </author> <title> Exploiting Domain Knowledge in IC Cell Layout, </title> <journal> IEEE Design & Test, </journal> <volume> vol. 18, </volume> <pages> pp. 52-65, </pages> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: Two-dimensional cell layout has also been addressed by se veral heuristic, rule-based systems such as Wolfs Dumbo [116], Kims Talib <ref> [70] </ref>, and TOPOLOGIZER by Kollaritsch [71].
Reference: [71] <author> P. Kollaritsch, TOPOLOGIZER: </author> <title> An Expert System Translator of Transistor Connectivity to Symbolic Cell Layout, </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> vol. SC-3, </volume> <pages> pp. 79-804, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Two-dimensional cell layout has also been addressed by se veral heuristic, rule-based systems such as Wolfs Dumbo [116], Kims Talib [70], and TOPOLOGIZER by Kollaritsch <ref> [71] </ref>.
Reference: [72] <author> Y-J Kwon and C-M Kyung, </author> <title> A Fast Heuristic for Optimal CMOS Functional Cell Layout Generation, </title> <booktitle> Proc. International Symp. on Circuits and Systems, </booktitle> <pages> pp. 2423-2426, </pages> <year> 1988. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> It reorders the graph to reduce the number of vertices with odd degree, but is not applicable to circuits whose graphs all have even-degree vertices for all reorderings. The algorithm of Kw on and Kyung <ref> [72] </ref> aims at finding a nearly minimum number of euler paths from the path representation formula of the circuits logic function. Although their method has a time comple xity of O (n 3 ), it does not consider all permutations of the subpaths and hence does not guarantee optimality.
Reference: [73] <author> M. Lefebvre and C. Chan, </author> <title> Optimal Ordering of Gate Signals in CMOS Complex Gates, </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <pages> pp. </pages> <address> 17.5.1-17.5.4, </address> <year> 1989. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques.
Reference: [74] <author> M. Lefebvre, C. Chan, and G. Martin, </author> <title> Transistor Placement and Interconnect Algorithms for Leaf Cell Synthesis, </title> <booktitle> Proc. IEEE European Design Automation Conf., </booktitle> <pages> pp. 119-123, </pages> <year> 1990. </year>
Reference-contexts: Despite its exponential worst-case time complexity, HR-TrailTrace has been shown to have run times of a few minutes for 98% of dual series-parallel circuits of practical size. The heuristic method of Lefeb vre and Chan <ref> [74] </ref> is applicable to SP circuits only; it guarantees minimum cell width, b ut makes no claim to minimize cell height. Madsen s method [78] guarantees minimum widths only if an euler trail exists; height is not minimized even for this special case.
Reference: [75] <author> T. Lengauer and R. Muller, </author> <title> Linear Algorithms for Optimizing the Layout of Dynamic CMOS Cells, </title> <journal> IEEE Trans. on Circuits and Systems, </journal> <volume> vol. 35, </volume> <pages> pp. 279-285, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Therefore, cell layout reduces to laying out the NMOS subcircuit only. Linear-time algorithms for dynamic circuit layout ha ve been proposed by Leng auer and Muller <ref> [75] </ref> and by McMullen and Otten [86]. While both guarantee a minimum-width layout with circuit reordering, only [75] addresses height minimization using heuristics. <p> Therefore, cell layout reduces to laying out the NMOS subcircuit only. Linear-time algorithms for dynamic circuit layout ha ve been proposed by Leng auer and Muller <ref> [75] </ref> and by McMullen and Otten [86]. While both guarantee a minimum-width layout with circuit reordering, only [75] addresses height minimization using heuristics. Basaran and Rutenbar [9] present an area-minimization algorithm that first determines the minimum cell width via euler chain formation, and then uses simulated annealing to f ind a transistor ordering that has the minimum width and requires the fe west routing tracks. <p> Layout techniques for dynamic cells, such as the 1-D methods of <ref> [9, 75] </ref>, focus on the layout of the N transistor netw ork only. Therefore, although the 1-D width and height minimization problems for dynamic cells are also NP-hard [19], they are much simpler than those for static cells which must simultaneously consider pairs of P and N transistors.
Reference: [76] <institution> Lindo Systems, Inc., LINDO Systems Optimization Products, </institution> <note> WWW page http:// www.nsl.win.net/~lindo. </note>
Reference-contexts: Then, the ILP problem is solved using algorithms that solve the related group problem. Branch-and-bound enumeration. Most commercial tools for solving ILP (or MILP) problems use the branch-and-bound implicit enumeration technique. Examples are the Optimization Subroutine Library (OSL) [66], CPLEX [27], and LINDO <ref> [76] </ref>. A search tree is used to implicitly enumerate all possible solutions. Ev ery node in the tree represents a relax ed LP problem in which the inte grality constraints on a subset of the inte ger variables are removed or relaxed.
Reference: [77] <author> A. D. Lopez and H. S. </author> <title> Law, A Dense Gate Matrix Layout Method for MOS VLSI, </title> <journal> IEEE Trans. on Electron Devices, </journal> <volume> vol. ED-27, </volume> <pages> pp. 1671-1675, </pages> <month> Aug. </month> <year> 1980. </year>
Reference-contexts: Ho wever, PLAs cannot handle non-SOP expressions and often have long wires which lead to area wastage and poor timing performance. The gate matrix method, first proposed in <ref> [77] </ref>, emplo ys a grid of intersecting wires.
Reference: [78] <author> J. Madsen, </author> <title> A New Approach to Optimal Cell Synthesis, </title> <booktitle> Proc. IEEE International Conf. on Computer Design, </booktitle> <pages> pp. 336-339, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> The heuristic method of Lefeb vre and Chan [74] is applicable to SP circuits only; it guarantees minimum cell width, b ut makes no claim to minimize cell height. Madsen s method <ref> [78] </ref> guarantees minimum widths only if an euler trail exists; height is not minimized even for this special case. Yet another linear-time heuristic has been proposed by Mailhot and DeMicheli [79].
Reference: [79] <author> F. Mailhot and G. DeMicheli, </author> <title> Automatic Layout and Optimization of Static CMOS Cells, </title> <booktitle> Proc. IEEE International Conf. on Computer Design, </booktitle> <pages> pp. 180-185, </pages> <month> Nov. </month> <year> 1988. </year> <month> 195 </month>
Reference-contexts: Madsen s method [78] guarantees minimum widths only if an euler trail exists; height is not minimized even for this special case. Yet another linear-time heuristic has been proposed by Mailhot and DeMicheli <ref> [79] </ref>.
Reference: [80] <author> E. Malavasi and D. Pandini, </author> <title> Optimum CMOS Stack Generation with Analog Constraints, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, </volume> <pages> pp. 107-122, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: This can result in non-uniform transistor heights. To make transistor heights uniform, a lar ge transistor can be folded into se veral smaller transistors called legs connected in parallel <ref> [42, 55, 80] </ref>. However, since folding increases the total number of transistors, it complicates the task of diffusion sharing, and can increase both the cell width and the number of routing tracks. <p> This further suggests that in the presence of nonuniform transistor sizes and folding, the 2-D layout may yield better area by reducing cell width due to transistor placement in multiple P/N rows. Recently, in independent w ork, Malavasi and P andini <ref> [80] </ref> proposed a cell layout technique for analog circuits which, like XPRESS, folds large transistors prior to chain generation. However, their method splits the circuit into subcircuits based on analog criteria, and applies the chain generation algorithm on each subcircuit. <p> It fixes the number of legs for each transistor, and then aims at determining their position and orientation so that cell area objecti ve is minimized. For 1-D layout, this problem has been addressed by Gupta et al. in their XPRESS [42] tool and by Malavasi and Pandini <ref> [80] </ref>. (b) after folding with transistors in place; (c) after re-orienting and re-positioning transistors 1 2 3 2 7 1 2 7 1 2 3 2 4 5 4 6 5 8 Folding Flip P 1 Move N 2 to right (a) (b) N 1 N 2 N 3 P 1 <p> Layouts produced by XPRESS have been shown to be equal or superior to those produced by other techniques. They also demonstrate the value of folding in reducing overall cell area and controlling cell aspect ratios. In independent w ork on analog circuits, Mala vasi and Pandini <ref> [80] </ref> proposed a technique that also folds transistors prior to chain generation. Ho wever, their method forms chains separately for the P and N sub-circuits, which can sacrifice optimality. Finally, problem 4 is the most general in that it allows both the placement and the folding to be dynamic.
Reference: [81] <author> P. Maulik, L. C. Carley, and R. A. Rutenbar, </author> <title> Integer Programming Based Topology Selection of Cell-Level Analog Circuits, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, </volume> <pages> pp. 401-412, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: While ILP and related mathematical programming techniques ha ve been ignored for cell synthesis due to their percei ved computational complexity, recent research has successfully applied ILP-based methods to other CAD problems <ref> [23, 69, 81, 111] </ref>. The ILP approach used in this thesis has several advantages over existing heuristic methods: It guarantees optimal 2-D cell layouts and has optimal 1-D layout as a special case. <p> ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction [111], timing-dri ven datapath layout [69], FPGA technology mapping [23], analog circuit synthesis <ref> [81] </ref>, high-le vel synthesis [46], and timing analysis [12]. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity. In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization. <p> optimum cell heights obtained with the pair-WH model and the corresponding OPBDP run times; these heights are also compared to those obtained by the commercial tool Virtuoso. 4.2 Cell Layout Assumptions Assuming uniform transistor sizes, the height of a cell is determined by the cell s horizontal routing (track) density <ref> [81] </ref>, that is, the number of horizontal tracks needed to connect electrically equivalent transistor terminals and complete the cells interconnections.
Reference: [82] <author> R. L. Maziasz and J. P. Hayes, </author> <title> Layout Minimization of CMOS Cells, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: A functional cell, also referred to as a complex gate, is a nonhierarchical transistor-level implementation of a basic logic unit <ref> [82] </ref>. <p> For example, the positions of tw o transistors connected in series can be interchanged without changing circuits function. Such reordering changes both the dif fusionsharing possibilities and the interconnect structure and can often lead to layouts with smaller widths and heights <ref> [82] </ref>. has a layout that requires a dif fusion gap and three horizontal routing tracks. <p> For 1-D layouts, transistor reordering has been shown to reduce cell widths by over 20% <ref> [82] </ref>. Of course, many IC designs require that the positions of transistors and their individual sizes be fixed in order to achieve a desired speed and to dri ve a required load capacitance. In such cases, transistor reordering is not permissible. Performance considerations. <p> We define an exact method to be an algorithmic step-by-step procedure that guarantees an optimal solution for an y given instance of the problem in f inite time. A heuristic method, on the other hand, does not al ways lead to an optimal solution <ref> [82] </ref>. Although heuristics often have much shorter run times than e xact algorithms, the quality of their solutions can be arbitrarily far from the optimum. <p> Although heuristics often have much shorter run times than e xact algorithms, the quality of their solutions can be arbitrarily far from the optimum. For 1-D cell width and height minimization, Maziasz and Hayes <ref> [82, 83] </ref> ha ve developed exact algorithms that, despite their w orst-case exponential time complexity, are computationally feasible for practical circuits of height four or less, where the height of a circuit is def ined by the number of transistors between the po wer (or ground) and output nodes. <p> The thesis is based on a premise similar to that of Maziasz and Hayes <ref> [82, 83] </ref>: exact algorithms can be computationally feasible for the relati vely restricted domain of functional cell layout generation and can generate layouts that are f ar superior to those produced by heuristic methods. <p> Hence, the feasibility of an algorithm depends not just on its time comple xity but also on the size of the problems to which it is applied <ref> [82] </ref>. While [82, 83] focus on the 1-D style only , this thesis addresses the more general (and more complex) problem of 2-D synthesis. In contrast to the 1-D case, the 2-D cell layout problem has been studied very little, despite its wide applicability and advantages. <p> Hence, the feasibility of an algorithm depends not just on its time comple xity but also on the size of the problems to which it is applied [82]. While <ref> [82, 83] </ref> focus on the 1-D style only , this thesis addresses the more general (and more complex) problem of 2-D synthesis. In contrast to the 1-D case, the 2-D cell layout problem has been studied very little, despite its wide applicability and advantages. <p> It def ines the circuit graph model initially proposed by Uehara and v anCleemput [108] and reviews the exact graph-theoretical 1-D layout technique based on this model de veloped by Maziasz and Hayes <ref> [82] </ref>. Chapter 2 also discusses the ILP optimization technique, along with modeling issues and methods for solving linear, general integer, and 0-1 programming problems. 29 Chapter 3 addresses the 2-D cell width minimization problem and develops an exact, ILP-based technique to solve it. <p> Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques [15, 16, 22, 64, 72, 73, 78, 82, 84, 88]. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time <ref> [63, 82, 88] </ref>. We first describe the heuristic method of [108] and then re view the exact techniques. <p> The resulting dual-euler trail (which can be found in linear time [63]) corresponds to a 1-D layout in which the pseudo-edges represent dif fusion gaps. However, this heuristic does not guarantee a minimum-width layout. Maziasz and Hayes <ref> [82, 84] </ref> generalize the approach of Uehara and v anCleemput using a new class of graph-based algebras that characterizes the cell layout problem and forms the basis for exact, nonexhaustive area minimization algorithms. <p> For a given chain cover of the circuit, cell height depends on the relative linear ordering of the chains in the co ver, as well as on their orientation. Maziasz and Hayes e xtend their R-TrailTrace algorithm to HR-TrailTrace <ref> [82, 83] </ref> which optimally solv es cell height minimization over all circuit reorderings. Unlik e R-TrailTrace, it retains all trail co vers that can lead to a minimum cell height, and also considers all permutations and orientations of the trails of a co ver. <p> Ho wever, the generality of this method leads to inef ficiencies in the quality of the f inal layout. As Maziasz and Hayes <ref> [82] </ref> demonstrate for an exclusive-or circuit, their exact technique produces a 1-D layout that is 80% smaller than that produced by SOLO. Techniques proposed by Hill [57], W imer et al. [114], and Shiraishi et al. [101] also handle arbitrary CMOS netw orks. <p> Of the optimal netw ork implementations of all four v ariable switching functions, 51% are kno wn to have non-SP structures [49]. Maziasz and Hayes <ref> [82] </ref> present an example in which the SP circuit requires 42 transistors, while the non-SP v ersion requires only 16; the former has a 1-D layout that is 2.3 times lar ger in area than the latter. <p> An example is found in the composition tree shown in Fig. 2.1 c. Hierarchy of this kind does not e xist in non-SP circuits. Moreover, in contrast to SP graphs, relatively little is known about non-SP graphs. Maziasz and Hayes <ref> [82, 84] </ref> e xtend their dual trail co vering theory to construct an algorithm called P-TrailTrace that produces minimum-width layouts in practical time for non-series-parallel dual circuits. <p> Maziasz and Hayes generalize their HR-TrailTrace algorithm to HRM-TrailTrace for 1-D layout of multiple cells <ref> [82] </ref>. It is an exact algorithm for both width and height minimization of cell arrays. For SP circuits with height four or less, it computes optimal layouts in linear time, but for a fixed predetermined linear ordering of the cells. <p> Wimer et al. [114] also extend their single-cell layout method to multiple cells. Like <ref> [82] </ref>, they assume that the location of each cell in the array is f ixed. <p> Then, each subcircuit is clustered into smaller strongly-connected cells, whose layouts are generated using an extension of the 1-D technique of Maziasz and Hayes <ref> [82] </ref>. F or each subcircuit, its constituent cells are arranged in a linear order using a min-cut placement algorithm that minimizes a cost function based on the weighted sum of the total wire length and the width and height of the layout. <p> Moreover, a transistor chain of P transistors e xists if and only if the corresponding dual N transistors also form a chain; such matching chains are called dual chains, or in graph-theoretical terms, dual trails <ref> [82] </ref>. Henceforth, we will refer to a dual chain as simply a chain. A chain is represented by the sequence of g ate inputs of its constituent P/N pairs. Therefore, the tw o chains placed in the bottom and top P/N row of Fig. 3.1 are babc and acc, respectively. <p> Assuming a virtual grid in which each transistor and diffusion gap has unit width, W cell for a 1-D layout is defined by the following equation <ref> [82] </ref>: W cell = number of transistor pairs + number of chains 1 = p + c 1 (3.3) As we see later, the width W r of row r in the 2-D layout style can be expressed as W r = p r + c r 1 + v r <p> Applying the TrailTrace algorithm <ref> [82] </ref> to T yields the trail cover TC 1 = -C 1 = abgh, C 2 = cd, C 3 = iklj, C 4 = efmn-. <p> Although the problem of transistor chain generation has been solv ed using various algorithms <ref> [42, 62, 82, 114] </ref>, a technique that is applicable to the entire class of complex dual CMOS networks in required. We use the exact chain generation algorithm proposed by Gupta et al. for the XPRESS cell synthesis tool [42]. <p> Cct. no. Circuit No. of transistors No. of nets 1 No. of chains 2 1 2-input parity circuit (Xor) [5] 10 7 16 2 Non-series-parallel bridge circuit [121] 10 10 20 3 2-level implementation of z = (a' . (e + f)' + d)' <ref> [82] </ref> 12 12 22 4 2-to-1 multiplexer 14 10 28 5 Series-parallel circuit for z = (a.b + (c+d) . (e+f) + g.h)' [108] 6 2-level implementation of the majority function z = a.b + b.c + a.c 7 Series-parallel circuit for z = (a.b.c + d.e.f + (g + h).(i <p> (c+d) . (e+f) + g.h)' [108] 6 2-level implementation of the majority function z = a.b + b.c + a.c 7 Series-parallel circuit for z = (a.b.c + d.e.f + (g + h).(i + j))' 8 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l))' <ref> [82] </ref> 9 8-input NAND circuit 24 20 78 10 Full adder [5] 28 17 92 11 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l).(m + n).(o + p))' [82] 12 4-bit parity stage (implements 5-bit parity circuit) [52] 40 25 214 Table 3.6: Representative CMOS <p> j))' 8 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l))' <ref> [82] </ref> 9 8-input NAND circuit 24 20 78 10 Full adder [5] 28 17 92 11 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l).(m + n).(o + p))' [82] 12 4-bit parity stage (implements 5-bit parity circuit) [52] 40 25 214 Table 3.6: Representative CMOS circuits used for experimentation 87 1. The OPBDP data was obtained on the HP 9000/735 workstation which is approximately 50% faster than the IBM RS/6000 used for the OSL experiments. 2. <p> Circuit No. of pairs No. of nets No. of P/N rows 1 2 3 4 5 2-level implementation of the majority function z = a.b + b.c + a.c 10 5 (5+0+0) (2+1+1) (3+1+0) (2+1+1) (2+0+2) 4 (1+0+3) (2+1+1) 8 Series-parallel circuit for (i+j).(k+l))' <ref> [82] </ref> 13 9 (6+1+2) (4+0+1) (4+0+1) (4+0+1) (2+0+3) 5 (2+0+3) (2+0+3) 10 Full adder [5] 16 8 (8+0+0) (5+0+0) (5+0+0) (4+0+1) (3+0+1) 5 (3+0+1) (3+1+0) Table 3.8: Contribution of individual P/N rows to the optimum cell width W cell 90 3.6 Summary We have presented a no vel technique CLIP based <p> Hence, the routing model described here for cell layout can be applied to channel, OTC, and related routing problems as well. While channel routing algorithms must consider both horizontal and vertical constraints to compute T R , cell synthesis techniques have generally ignored vertical constraints <ref> [20, 57, 82] </ref>. The fundamental problem is to determine whether a net n requires a track in a column c. <p> For example, diffusion sharing between transistors belonging to different clusters depends on transistor placement within each cluster . Hence, hierarchical layout techniques, such as those proposed in <ref> [62, 82, 92, 114] </ref> for 1-D cell arrays, that generate intra and inter-cluster layouts in two sequential stages can yield layouts that are arbitrarily far from optimal.
Reference: [83] <author> R. L. Maziasz and J. P. Hayes, </author> <title> Exact Width and Height Minimization of CMOS Cells, </title> <booktitle> Proc. 28th Design Automation Conf., </booktitle> <pages> pp. 487-493, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> Although heuristics often have much shorter run times than e xact algorithms, the quality of their solutions can be arbitrarily far from the optimum. For 1-D cell width and height minimization, Maziasz and Hayes <ref> [82, 83] </ref> ha ve developed exact algorithms that, despite their w orst-case exponential time complexity, are computationally feasible for practical circuits of height four or less, where the height of a circuit is def ined by the number of transistors between the po wer (or ground) and output nodes. <p> The thesis is based on a premise similar to that of Maziasz and Hayes <ref> [82, 83] </ref>: exact algorithms can be computationally feasible for the relati vely restricted domain of functional cell layout generation and can generate layouts that are f ar superior to those produced by heuristic methods. <p> Hence, the feasibility of an algorithm depends not just on its time comple xity but also on the size of the problems to which it is applied [82]. While <ref> [82, 83] </ref> focus on the 1-D style only , this thesis addresses the more general (and more complex) problem of 2-D synthesis. In contrast to the 1-D case, the 2-D cell layout problem has been studied very little, despite its wide applicability and advantages. <p> For a given chain cover of the circuit, cell height depends on the relative linear ordering of the chains in the co ver, as well as on their orientation. Maziasz and Hayes e xtend their R-TrailTrace algorithm to HR-TrailTrace <ref> [82, 83] </ref> which optimally solv es cell height minimization over all circuit reorderings. Unlik e R-TrailTrace, it retains all trail co vers that can lead to a minimum cell height, and also considers all permutations and orientations of the trails of a co ver.
Reference: [84] <author> R. L. Maziasz and J. P. Hayes, </author> <title> Layout Optimization of Static CMOS Functional Cells, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 9, </volume> <pages> pp. 708-719, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> The resulting dual-euler trail (which can be found in linear time [63]) corresponds to a 1-D layout in which the pseudo-edges represent dif fusion gaps. However, this heuristic does not guarantee a minimum-width layout. Maziasz and Hayes <ref> [82, 84] </ref> generalize the approach of Uehara and v anCleemput using a new class of graph-based algebras that characterizes the cell layout problem and forms the basis for exact, nonexhaustive area minimization algorithms. <p> An example is found in the composition tree shown in Fig. 2.1 c. Hierarchy of this kind does not e xist in non-SP circuits. Moreover, in contrast to SP graphs, relatively little is known about non-SP graphs. Maziasz and Hayes <ref> [82, 84] </ref> e xtend their dual trail co vering theory to construct an algorithm called P-TrailTrace that produces minimum-width layouts in practical time for non-series-parallel dual circuits.
Reference: [85] <author> R. L. Maziasz and J. P. Hayes, </author> <title> Layout Optimization of CMOS Functional Cells, </title> <booktitle> Proc. 24th Design Automation Conf., </booktitle> <pages> pp. 544-551, </pages> <year> 1987. </year>
Reference: [86] <author> C. T. McMullen and R. H. J. M. Otten, </author> <title> Layout Compilation of Linear Transistor Arrays, </title> <booktitle> Proc. IEEE International Symp. on Circuits and Systems, </booktitle> <pages> pp. 5-7, </pages> <year> 1985. </year>
Reference-contexts: Therefore, cell layout reduces to laying out the NMOS subcircuit only. Linear-time algorithms for dynamic circuit layout ha ve been proposed by Leng auer and Muller [75] and by McMullen and Otten <ref> [86] </ref>. While both guarantee a minimum-width layout with circuit reordering, only [75] addresses height minimization using heuristics.
Reference: [87] <author> G. Moore, </author> <title> VLSI: Some Fundamental Challenges, </title> <journal> IEEE Spectrum, </journal> <volume> vol. 16, no. 4, </volume> <pages> pp. 30-37, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: If this trend continued, he reasoned, computing power would rise exponentially over relatively brief periods of time. Now known as Moores Law <ref> [87] </ref>, and illustrated graphically in Fig. 1.1, this trend has remained remarkably accurate o ver the past 25 years. <p> If this trend continues, Intel processors should contain between 50 and 100 million transistors by the turn of the century and should execute 2 billion instructions per second <ref> [31, 87] </ref>. An integrated circuit or IC refers to a large number of electronic components (transistors) and their interconnections that are placed in a single chip of semiconductor material [50]. ICs of the above complexity would not have been possible without the aid of computer programs.
Reference: [88] <author> R. Nair, A. Bruss, and J. Reif, </author> <title> Linear time algorithms for optimal CMOS layout, VLSI Algorithms and Architecture: </title> <booktitle> Proc. International Workshop on Parallel Computing and VLSI, Amalfi, Italy, </booktitle> <pages> pp. 327-338, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques <ref> [15, 16, 22, 64, 72, 73, 78, 82, 84, 88] </ref>. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Since the seminal work of Uehera and vanCleemput [108], the dual TTSPM model has been used in numerous cell layout optimization techniques [15, 16, 22, 64, 72, 73, 78, 82, 84, 88]. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time <ref> [63, 82, 88] </ref>. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Although R-TrailTrace has an exponential worst-case time complexity, its run times are quite small for practical circuits of height four or less. Another exact algorithm for 1-D width minimization of dual series-parallel circuits w as proposed by Nair et al. <ref> [88] </ref>. Their graph-based method reduces the sets of dual trails found in TTSPMs to 18 representative graphs based on the number of distinct trails in the graph and their endpoints.
Reference: [89] <author> S. Natarajan, N. Sherwani, N. D. Holmes, and M. Sarrafzadeh, </author> <title> Over-the-Cell Channel Routing for High Performance Circuits, </title> <booktitle> Proc. 29th Design Automation Conf., </booktitle> <pages> pp. 600-603, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: their top and bottom boundaries, as well as the number of tracks a vailable for routing over the cell; the goal then is to select as many nonintersecting net se gments as possible to be routed o ver the cells so that the track densities in the channels is minimized <ref> [54, 61, 89, 117] </ref>. Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions [61], and minimization of net lengths along with the channel density [89]. <p> Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions [61], and minimization of net lengths along with the channel density <ref> [89] </ref>. Since the pair-WH model combines channel density computation with the 2-D placement and orientation of pairs, it can be easily adapted to solve the above OTC routing problems as well. Summary.
Reference: [90] <author> G. L. Nemhauser and L. A. Wolsey, </author> <title> Integer and Combinatorial Optimization, </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization. The general mixed integer-linear programming (MILP) problem, of which an ILP problem is a special case, is stated below in matrix notation <ref> [90, 98] </ref>. Its goal is to minimize (or maximize) a linear objective function on a set of inte ger and/or real variables while satisfying a system of linear inequality constraints.
Reference: [91] <author> T. Ng and S. L. Johnson, </author> <title> Generation of Layouts from MOS Circuit Schematics: A Graph Theoretic Approach, </title> <booktitle> Proc. 22nd Design Automation Conf., </booktitle> <pages> pp. 39-45, </pages> <year> 1985. </year>
Reference-contexts: Ho wever, this gain in area is offset by long design times. Full-custom. Full-custom designs can use either unstructured or structured approaches to layout. Unstructured methods do not impose any restriction on the placement of transistors or the interconnect pattern. An example is the planar embedding method of <ref> [91] </ref> which does not place transistors on a grid, and whose only objecti ve is to minimize the number of layer changes in the (a+bc) GND PWR PMOSNMOS Pads Cells Horizontal channels Vertical channels a c Pads Standard cells Routing channels Vertical channel 13 cells routing.
Reference: [92] <author> C.L. Ong, J.T. Li, and C.Y. Lo, GENAC: </author> <title> An Automatic Cell Synthesis Tool, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 239-244, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> GENAC <ref> [92] </ref> heuristically pairs P and N transistors, partitions the pairs into equivalence classes based on diffusion sharing, and applies the 39 * branch-and-bound algorithm to each class to determine a minimal number of transistor chains that also reduce the routing channel density . <p> However, only a few proposed techniques support folding. While GENAC <ref> [92] </ref> calculates the number of transistor legs based on a cost function that approximates cell area, LiB [62] and THEDA.P [65] fold transistors when the 44 height of a P/N pair e xceeds a specified limit on cell height. <p> For example, diffusion sharing between transistors belonging to different clusters depends on transistor placement within each cluster . Hence, hierarchical layout techniques, such as those proposed in <ref> [62, 82, 92, 114] </ref> for 1-D cell arrays, that generate intra and inter-cluster layouts in two sequential stages can yield layouts that are arbitrarily far from optimal. <p> Her and Wong also extend their technique to heuristically address 2-D layout for problem 2. Other heuristic techniques for this problem are included in the GENAC <ref> [92] </ref>, LiB [62], and THEDA.P [65] 1-D cell synthesis tools. While GENAC calculates the number of transistor le gs based on a cost function that approximates cell area, LiB and THEDA.P fold transistors when the height of a pair e xceeds the specified cell height.
Reference: [93] <author> C.J. Poirier, Excellerator: </author> <title> Custom CMOS Leaf Cell Layout Generator, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 8, </volume> <pages> pp. 744-755, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Both these covers produce 1-D layouts of minimum width for this circuit. Ho wever, the first cover corresponds to a narro wer 2-D layout (Fig. 2.4 a) than the latter (Fig. 2.4b). Thus, chain covers that produce optimal 1-D layouts do not necessarily guarantee optimal 2-D layouts. Poirier <ref> [93] </ref> proposes a transistor placement method called Excellerator that can handle constraints on the number of dif fusion rows or the shape of the cell boundary . <p> W r of row r in the 2-D layout style can be expressed as W r = p r + c r 1 + v r , where v r accounts for the inter-row connections. 65 As noted earlier, cell layout in the 2-D style has received little research attention <ref> [93, 105, 121] </ref>. For example, Poiriers [93] greedy transistor placement method can handle constraints on the number of diffusion rows or the shape of the cell boundary . A few layout tools such as Virtuoso [13] provide support for 2-D cell synthesis. <p> For example, Poiriers <ref> [93] </ref> greedy transistor placement method can handle constraints on the number of diffusion rows or the shape of the cell boundary . A few layout tools such as Virtuoso [13] provide support for 2-D cell synthesis.
Reference: [94] <author> B. Preas and M. Lorenzetti, </author> <title> Physical Design Automation of VLSI Systems, </title> <publisher> Benjamin/ Cummings, </publisher> <address> Menlo Park, Calif., </address> <year> 1988. </year>
Reference: [95] <author> R. L. Rivest and C. M. Fiduccia, </author> <title> A Greedy Channel Router, </title> <booktitle> Proc. 19th Design Automation Conf., </booktitle> <pages> pp. 120-125, </pages> <month> June </month> <year> 1991. </year> <month> 196 </month>
Reference-contexts: Thus, to compute T R , we must determine, for each column c in region R, the number of nets that must be routed horizontally through it. This has traditionally been referred to as the channel routing problem <ref> [95] </ref>. <p> Other measures of cell performance can be similarly incorporated into CLIP. 179 Routing problems. Our pair-WH and hier-WH models that combine 2-D placement with track density computation can be adapted to other routing problems such as channel routing, o ver-the-cell routing, and net assignment. The general channel routing problem <ref> [95, 97, 120] </ref>, an instance of which is sho wn in Fig. 8.3, has fixed terminals on both sides of a rectangular channel.
Reference: [96] <author> T. Sadakane, H. Nakao, and M. Terai, </author> <title> A New Hierarchical Algorithm for Transistor Placement in CMOS Macro Cell Design, </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <pages> pp. 461-464, </pages> <year> 1995. </year>
Reference-contexts: While neither approach can guarantee an optimal solution, the latter approach has been seen to yield significantly better results than heuristic algorithms for several problems. Examples of partitioning approaches to functional cell layout include hierarchical layout synthesis and circuit pre-processing. Hierarchical methods such as that of <ref> [96] </ref> partition the circuit into subcircuits or clusters, which are then placed either as a single cell or an array of cells. <p> It then generates several layouts for each cell, and finally uses simulated annealing to select the best layout and orientation for each cell so as to increase dif fusion sharing at cell boundaries and reduce the total wiring length. The heuristic method of Sadakane et al. <ref> [96] </ref> addresses only the 1-D array width-minimization problem but explores different linear orderings of cluster layouts. <p> It is also consistent with manual designs and yields efficient layouts since it places transistors of the same cluster close together <ref> [96] </ref>, thereby increasing diffusion sharing and reducing wire lengths. implementation from [96] of an 8-input N AND function. This circuit has twenty-four transistors that are clustered into five logic gates (Figs. 6.1a,b). One, two, and three-row layouts generated using HCLIP are shown in Figs. 6.1c,d,e. <p> It is also consistent with manual designs and yields efficient layouts since it places transistors of the same cluster close together <ref> [96] </ref>, thereby increasing diffusion sharing and reducing wire lengths. implementation from [96] of an 8-input N AND function. This circuit has twenty-four transistors that are clustered into five logic gates (Figs. 6.1a,b). One, two, and three-row layouts generated using HCLIP are shown in Figs. 6.1c,d,e. As discussed later, HCLIP produces minimum-width 2-D layouts for one through f ive P/N rows. <p> Hence, hierarchical layout techniques, such as those proposed in [62, 82, 92, 114] for 1-D cell arrays, that generate intra and inter-cluster layouts in two sequential stages can yield layouts that are arbitrarily far from optimal. Another approach proposed by Sadakane et al. <ref> [96] </ref> first generates the set of all minimum-width 1-D placements for each cluster , and then simultaneously selects of a layout for each cluster and a placement of the clusters so that the o verall 1-D width is reduced. <p> The input circuit is first partitioned into clusters, typically logic gates, using known methods <ref> [42, 96] </ref>. Next, the set of all min-coversthe smallest set of transistor chains that covers a circuitis generated for each cluster . <p> As these results indicate, HCLIP yields optimal 1-D cell widths in all cases with run times that are in seconds. These run times are se veral orders of magnitude better than those of the 1-D hierarchical technique of Sadakane et al. <ref> [96] </ref>. Moreo ver, unlike [96], HCLIP guarantees a layout of minimum width for a gi ven set of covers, and solves the 2-D problem as well. F or circuit 1 (8-input NAND), we obtain optimal layouts in one through f ive rows. <p> As these results indicate, HCLIP yields optimal 1-D cell widths in all cases with run times that are in seconds. These run times are se veral orders of magnitude better than those of the 1-D hierarchical technique of Sadakane et al. <ref> [96] </ref>. Moreo ver, unlike [96], HCLIP guarantees a layout of minimum width for a gi ven set of covers, and solves the 2-D problem as well. F or circuit 1 (8-input NAND), we obtain optimal layouts in one through f ive rows. <p> No. Circuit No. of trans. No. of clusts. Ave. clust. size No. of rows Lower bound W cell 1 W cell Run time (secs.) pair-W hier-W pair-W hier-W 1 8-input NAND <ref> [96] </ref> 1 3 5 7 4 14 5 3 7 4 3 58 272 0.05 0.1 2 Full adder 2 [5] 1 3 5 8 5 16 5 5 8 7 13 226 9,773 0.02 0.05 3 multiplexer with enable [52] 1 3 5 12 5 22 * * 12 9
Reference: [97] <author> S. M. Sait and H. Youssef, </author> <title> VLSI Physical Design Automation: Theory and Practice, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Other measures of cell performance can be similarly incorporated into CLIP. 179 Routing problems. Our pair-WH and hier-WH models that combine 2-D placement with track density computation can be adapted to other routing problems such as channel routing, o ver-the-cell routing, and net assignment. The general channel routing problem <ref> [95, 97, 120] </ref>, an instance of which is sho wn in Fig. 8.3, has fixed terminals on both sides of a rectangular channel.
Reference: [98] <author> H. M. Salkin, </author> <title> Integer Programming, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1975. </year>
Reference-contexts: In this section, we review integer-linear programming and its solution strategies; we also examine problem modeling methods including linearization. The general mixed integer-linear programming (MILP) problem, of which an ILP problem is a special case, is stated below in matrix notation <ref> [90, 98] </ref>. Its goal is to minimize (or maximize) a linear objective function on a set of inte ger and/or real variables while satisfying a system of linear inequality constraints. <p> If a 0-1 ILP problem has all integer coefficients, it is called pseudo-boolean [7]. An ILP problem in which e very integer variable is bounded can be transformed to a 0-1 ILP problem (Theorem 1.1 of <ref> [98] </ref>). A solution to an MILP problem of the above type is an assignment of values to the x and y variables; it is said to be feasible if it satisfies all the constraints. <p> ILP problems fall in the category of NP-complete problems and are usually orders of magnitude more difficult to solve than LP problems. 51 Techniques for solving ILP problems can be divided into three classes <ref> [98, 123] </ref>: Cutting-plane methods: These deduce new constraints that must be satisfied by every integer solution. These constraints are appended to the original constraint set and eventually produce a linear program whose optimal solution has integral values for the integer variables [39]. <p> The leaf nodes satisfy all inte grality constraints and hence represent feasible solutions to the original ILP problem. The flowchart in Fig. 2.9 summarizes a typical branch-and-bound algorithm for solving MILP problems <ref> [98, 123] </ref>; here, a minimization objective is assumed. At the outset, we set the best known integer solution value z * to an arbitrarily lar ge value (infinity); the list L which stores sub-problems is emptied. <p> function over three binary variables x, y, and z, where the logical sum and product are denoted by or and and, respectively. w = (x and y) or (x and z) or (y and z) = majority (x, y, z) Several systematic techniques have been proposed for linearizing such constraints <ref> [3, 98, 113] </ref>. However, most of these techniques either introduce a lar ge number of intermediate binary variables or result in a lar ge number of additional constraints, f actors which adversely affect the 60 problems complexity.
Reference: [99] <author> S. S. Sapatnekar and W. Chuang, </author> <title> Power vs. Delay in Gate Sizing: Conicting Objectives?, </title> <booktitle> Proc. IEEE International Conf. on CAD, </booktitle> <pages> pp. 463-466, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: In such cases, transistor reordering is not permissible. Performance considerations. It is well kno wn that the performance of a cell, in terms of its speed and power consumption, depends mainly on the sizes of its transistors <ref> [99, 104] </ref>. <p> The transistors of practical circuits are often indi vidually sized to improve performance criteria such as rise and fall delays <ref> [99, 102] </ref>. This can result in non-uniform transistor heights. To make transistor heights uniform, a lar ge transistor can be folded into se veral smaller transistors called legs connected in parallel [42, 55, 80]. <p> NMOS netw orks only, TOPOLOGIZER generates layouts for CMOS circuits using a rule-driven iterative improvement strategy to generate transistor placements in multiple rows with a desired aspect ratio. 2.4 Transistor Folding Transistors in practical circuits are often indi vidually sized to optimize performance criteria such as rise and fall delays <ref> [99, 102] </ref>. Non-uniformity in transistor sizes can lead to wasted area. Hence, for better area utilization, lar ge transistors may have to be broken during layout into several smaller transistors. <p> show how CLIP can be extended to integrate folding into our 2-D cell synthesis techniques. 7.1 Introduction As discussed in Section 2.4, in practical cell synthesis, the size of each transistor is often determined individually to meet the circuits performance goals such as specif ic rise and f all delays <ref> [99, 102] </ref>. The size of a transistor is def ined as the width of its P or N channel, and is illustrated in the cross-sectional view of Fig. 2.5a.
Reference: [100] <author> C. Sechen, </author> <title> VLSI Placement and Global Routing Using Simulated Annealing, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Empirical studies ha ve shown that different cell placements can affect the routing significantly enough to vary the IC area by a f actor of three or more <ref> [100] </ref>. And since the production costs of an IC are kno wn to increase exponentially with area, reduction of IC area generally forms the primary objective in layout design. The layout of an IC affects not only its area but also its performance, yield, and reliability.
Reference: [101] <author> Y. Shiraishi et al., </author> <title> A High Packing Density Module Generator for CMOS Logic Cells, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 439-444, </pages> <year> 1988. </year>
Reference-contexts: As Maziasz and Hayes [82] demonstrate for an exclusive-or circuit, their exact technique produces a 1-D layout that is 80% smaller than that produced by SOLO. Techniques proposed by Hill [57], W imer et al. [114], and Shiraishi et al. <ref> [101] </ref> also handle arbitrary CMOS netw orks. The method of Wimer et al. forms an e xhaustive list of chains, and then selects the smallest chain co ver that reduces the cell height based on routing density .
Reference: [102] <author> J-M. Shyu, A. Sangiovanni-Vincentelli, J. P. Fishburn, and A. E. Dunlop, </author> <title> Optimization-based Transistor Sizing, </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> vol. 23, no. 2, </volume> <pages> pp. 400-409, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: The transistors of practical circuits are often indi vidually sized to improve performance criteria such as rise and fall delays <ref> [99, 102] </ref>. This can result in non-uniform transistor heights. To make transistor heights uniform, a lar ge transistor can be folded into se veral smaller transistors called legs connected in parallel [42, 55, 80]. <p> NMOS netw orks only, TOPOLOGIZER generates layouts for CMOS circuits using a rule-driven iterative improvement strategy to generate transistor placements in multiple rows with a desired aspect ratio. 2.4 Transistor Folding Transistors in practical circuits are often indi vidually sized to optimize performance criteria such as rise and fall delays <ref> [99, 102] </ref>. Non-uniformity in transistor sizes can lead to wasted area. Hence, for better area utilization, lar ge transistors may have to be broken during layout into several smaller transistors. <p> show how CLIP can be extended to integrate folding into our 2-D cell synthesis techniques. 7.1 Introduction As discussed in Section 2.4, in practical cell synthesis, the size of each transistor is often determined individually to meet the circuits performance goals such as specif ic rise and f all delays <ref> [99, 102] </ref>. The size of a transistor is def ined as the width of its P or N channel, and is illustrated in the cross-sectional view of Fig. 2.5a.
Reference: [103] <author> K. F. Smith, </author> <title> Design of Regular Arrays using CMOS in PPL, </title> <booktitle> Proc. International Conf. on CAD, </booktitle> <pages> pp. 158-161, </pages> <year> 1983. </year>
Reference-contexts: Structured methods, which have been widely studied and used, place transistors at fixed grid locations. Some e xamples of structured methods are programmable logic arrays, gate matrix circuits, and functional cells. A programmable logic array (PLA) <ref> [103] </ref> implements a two-level sum-of-products (SOP) expression for a multiple-output combinational logic function. It consists of an AND plane that implements the product terms and an OR plane that implements the sum of products.
Reference: [104] <author> C. Svensson and J. Yuan, </author> <title> Ultra High-Speed CMOS Design, </title> <booktitle> Proc. International Conf. on Very Large Scale Integration, </booktitle> <volume> vol. A-42, </volume> <pages> pp. 273-282, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: In such cases, transistor reordering is not permissible. Performance considerations. It is well kno wn that the performance of a cell, in terms of its speed and power consumption, depends mainly on the sizes of its transistors <ref> [99, 104] </ref>.
Reference: [105] <author> K. Tani, K. Izumi, M. Kashimura, T. Matsuda, and T. Fujii, </author> <title> Two-Dimensional Layout Synthesis for Large-Scale CMOS Circuits, </title> <booktitle> Proc. IEEE International Conf. on CAD, </booktitle> <pages> pp. 490-493, </pages> <year> 1991. </year>
Reference-contexts: Simulated annealing is used to e xplore diffusion sharing between transistors on the boundaries of the cell layouts. In the 2-D realm, a hierarchical technique for layout of 2-D cell arrays has been proposed by Tani et al. <ref> [105] </ref>, which decouples the layout phases for intra- and inter cluster layout. First, a min-cut-based global placement algorithm di vides the circuit into subcircuits, each of which is assigned to a single ro w so as to reduce the inter row connections. <p> W r of row r in the 2-D layout style can be expressed as W r = p r + c r 1 + v r , where v r accounts for the inter-row connections. 65 As noted earlier, cell layout in the 2-D style has received little research attention <ref> [93, 105, 121] </ref>. For example, Poiriers [93] greedy transistor placement method can handle constraints on the number of diffusion rows or the shape of the cell boundary . A few layout tools such as Virtuoso [13] provide support for 2-D cell synthesis. <p> Simulated annealing is used to explore diffusion sharing between transistors on the boundaries of the cluster layouts. In the 2-D realm, a two-phase hierarchical technique for layout of 2-D cell arrays has been proposed by Tani et al. <ref> [105] </ref>. It first divides the circuit into sub-circuits using a mincut-based partitioning algorithm; a global placement algorithm then assigns each sub-circuit to a single row.
Reference: [106] <author> K. M. Thompson, </author> <title> Intel and the Myths of Test, </title> <booktitle> Proc. Intl Test Conf., </booktitle> <publisher> IEEE CS Press, Los Alamitos, Calif., 1995 (keynote address). </publisher>
Reference-contexts: Similarly, vias, which are used when a wire changes from one physical layer to another, and the diffusion area on signal nodes introduce impedance which also slows signal propagation. Table 1.1 shows the effect of increase in chip area on the costs of the Intel Pentium microprocessor <ref> [106] </ref>. Just a 1% increase in the die size of a Pentium chip increases the annual manufacturing costs by $63.5 million; a 15% increase in size costs an additional $961 million. Simultaneously, an increase in die size decreases the yield or the number of chips that are produced.
Reference: [107] <author> Y. Tsujihashi, H. Matsumoto, H. Nishimaki, A. Miyanishi, H. Nakao, O. Kitada, S. Iwade, S. Kayano, and M. Sakao, </author> <title> A High-Density Data-Path Generator with Stretchable Cells, </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> vol. 29, no. 1, </volume> <pages> pp. 2-8, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The cell topology in this case depends on the datapath layout style emplo yedthe routing of power, ground, signal, and control lines, over-the-cell routing, number of metal layers available for intra-cell routing, etc. <ref> [107] </ref>. Random logic cells, which compose the control part of a circuit, are often larger, irregular cells that vary widely in both comple xity and type. Although the y usually occupy little chip area, their layout is time-consuming.
Reference: [108] <author> T. Uehara and W.M. VanCleemput, </author> <title> Optimal Layout of CMOS Functional Arrays, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-30, </volume> <pages> pp. 305-312, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: circuit, and its (b) hierarchical and (c) functional cell implementations (a) b c c a b c N 2 N 4 N 6 P 4 P 3 N 7 a b b c a c out X Z Y 16 style was first formalized by Uehara and vanCleemput in 1978 <ref> [108] </ref> for dual static series-parallel CMOS circuit structures. Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style [14, 20, 58, 62, 83, 92, 108] is illustrated in Fig. 1.11a. <p> Functional cell layouts can be further classified into two categories, one-dimensional two-dimensional, which we examine next. One-dimensional layout. The widely used one-dimensional (1-D) style <ref> [14, 20, 58, 62, 83, 92, 108] </ref> is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. <p> 1-D cell depends on the number of P/N pairs p placed in the single P/N row and the number of diffusion gaps g between them, that is, W cell = p + g. (1.1) A slightly different equation W cell = p + g + 1 is gi ven in <ref> [108] </ref>, which includes tw o half-width gaps between the diffusion and the left and right cell boundaries. The number of dif fusion gaps depends on the number of transistor chains c and is given by g = c 1. <p> Organization. This dissertation is or ganized as follows. Chapter 2 presents a summary and evaluation of prior w ork in 1-D and 2-D functional cell layout synthesis. It def ines the circuit graph model initially proposed by Uehara and v anCleemput <ref> [108] </ref> and reviews the exact graph-theoretical 1-D layout technique based on this model de veloped by Maziasz and Hayes [82]. <p> new ILP-based optimization technique CLIP is described along with tw o different solution methods based on implicit enumeration, one that uses linear programming and another that uses pseudo-boolean satisfiability. 2.1 Circuit Graph Model The first general technique for 1-D cell-width minimization w as proposed in 1978 by Uehara and VanCleemput <ref> [108] </ref>. They model the transistor circuit as an undirected graph, and formulate cell width minimization as a graph-optimization problem. Their heuristic method is applicable to the class of geometrically dual series-parallel static CMOS circuits. <p> The method of Uehara and VanCleemput <ref> [108] </ref> models a static dual CMOS circuit, such as that in Fig. 2.1 a (taken from [108]), by a pair of dual two-terminal series-parallel multigraphs (TTSPMs) [48]: an NMOS graph M and its geometric dual PMOS graph M d . These graphs are shown in Fig. 2.1b. <p> The method of Uehara and VanCleemput <ref> [108] </ref> models a static dual CMOS circuit, such as that in Fig. 2.1 a (taken from [108]), by a pair of dual two-terminal series-parallel multigraphs (TTSPMs) [48]: an NMOS graph M and its geometric dual PMOS graph M d . These graphs are shown in Fig. 2.1b. Each edge e i in these graphs corresponds to a transistor. <p> Each dual-euler trail corresponds to a linear ordering of P/N pairs and each added edge represents a diffusion gap. Since the seminal work of Uehera and vanCleemput <ref> [108] </ref>, the dual TTSPM model has been used in numerous cell layout optimization techniques [15, 16, 22, 64, 72, 73, 78, 82, 84, 88]. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] <p> <ref> [108] </ref>, the dual TTSPM model has been used in numerous cell layout optimization techniques [15, 16, 22, 64, 72, 73, 78, 82, 84, 88]. 35 The problem of recognizing dual-euler trails in TTSPMs has been solved exactly in linear time [63, 82, 88]. We first describe the heuristic method of [108] and then re view the exact techniques. <p> Because exhaustive enumeration is required to find a minimum-sized dual trail cover in a dual graph representation, Uehera and vanCleemput <ref> [108] </ref> propose a heuristic method. Their heuristic is based on the theorem that if the number of inputs to e very AND/OR element is odd, then the graph model has a dual-euler path. <p> circuit (Xor) [5] 10 7 16 2 Non-series-parallel bridge circuit [121] 10 10 20 3 2-level implementation of z = (a' . (e + f)' + d)' [82] 12 12 22 4 2-to-1 multiplexer 14 10 28 5 Series-parallel circuit for z = (a.b + (c+d) . (e+f) + g.h)' <ref> [108] </ref> 6 2-level implementation of the majority function z = a.b + b.c + a.c 7 Series-parallel circuit for z = (a.b.c + d.e.f + (g + h).(i + j))' 8 Series-parallel circuit for z = (a.b.c.d + e.f.g.h + (i + j).(k + l))' [82] 9 8-input NAND circuit 24 <p> It is well-known that for a 1-D layout of a dual series-parallel circuit, and-stacks with odd numbers of transistors in series (or in parallel) will appear together in an y optimal solution <ref> [108] </ref> because the odd number of edges in a graph representation of the circuit can be collapsed to a single edge without af fecting optimality. However, for and-stacks with an e ven number of transistors in series, forcing their transistors to be contiguous can lead to sub-optimal layouts.
Reference: [109] <author> A. J. Velasco, X. Marin, R. P. Llopis, and J. Carrabina, </author> <title> Combined Pairing and Chaining Algorithm for CMOS Layout Generation, </title> <booktitle> Proc. European Design & Test Conf., </booktitle> <pages> pp. 609-612, </pages> <year> 1996. </year>
Reference-contexts: The latter is better since the parasitics induced by the layout can be accurately estimated and transistor resizing performed on-the-f ly as required. However, such dynamic folding is a comple x problem and has been only partially addressed for 1-D layout by a few heuristic methods <ref> [21, 109] </ref>. An indirect objective sometimes used for cell height reduction is to minimize the total wire length. This, in turn, can also enhance performance, especially for large 1-D cells that tend to have long wires running across the length of the cell.
Reference: [110] <author> T-C Wang, D. F. Wong, Y. Sun, and C. K. Wong, </author> <title> Optimal Net Assignment, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, </volume> <pages> pp. 265-269, </pages> <month> Feb. </month> <year> 1995. </year> <month> 197 </month>
Reference: [111] <author> H. Watanabe, </author> <title> IC Layout Generation and Compaction using Mathematical Optimization, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, University of Rochester, </institution> <year> 1984. </year>
Reference-contexts: While ILP and related mathematical programming techniques ha ve been ignored for cell synthesis due to their percei ved computational complexity, recent research has successfully applied ILP-based methods to other CAD problems <ref> [23, 69, 81, 111] </ref>. The ILP approach used in this thesis has several advantages over existing heuristic methods: It guarantees optimal 2-D cell layouts and has optimal 1-D layout as a special case. <p> ILP and related mathematical programming techniques ha ve successfully been applied to se veral CAD problems. These include layout compaction <ref> [111] </ref>, timing-dri ven datapath layout [69], FPGA technology mapping [23], analog circuit synthesis [81], high-le vel synthesis [46], and timing analysis [12]. Such applications demonstrate that, for certain problem domains, ILP-based techniques are practical, despite their apparent computational comple xity.
Reference: [112] <author> N. H. E. Weste and K. Eshraghian, </author> <title> Principles of CMOS VLSI Design: A Systems Perspective, 2nd ed., </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1993. </year>
Reference-contexts: The logic level uses primitive components called gates, such as NAND and NOR gates. The circuit level implements each logic gate using a particular IC family, such as the Complementary Metal Oxide Semiconductor (CMOS) family <ref> [112] </ref>, all of which have the transistor as their fundamental component. The layout level defines the geometric shapes of the ph ysical devices and wires, as well as the ph ysical material (layer) that will be used for each geometric shape in the IC s fabrication. <p> This, in turn, can require a new fabrication facility to maintain production levels. The layout area also directly af fects the yield of the f abrication process defined as the percentage of fault-free chips produced on a silicon w afer. This relation is often characterized by Seeds model <ref> [112] </ref> Y = , where Y is the yield, A is the chip area, and D is the defect density. Thus, the yield decreases rapidly with an increase in chip area, thereby raising production costs; this fact is also confirmed by Table 1.1. <p> Dynamic CMOS cells. Dynamic and domino cells, which are being used more frequently in modern designs for area and performance-ef ficient realizations, differ from static CMOS cells in 177 that they have a single pull-up P transistor instead of an entire P network. The dynamic cell <ref> [112] </ref> shown in Fig. 8.2 a has its logic function implemented by an N netw ork whose output is pre-charged to PWR by a P transistor P 1 and conditionally discharged by an N transistor N 1 connected to GND.
Reference: [113] <author> H. P. Williams, </author> <title> Model Building in Mathematical Programming, 2nd ed., </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: T o meet these objectives, we have chosen mathematical programming <ref> [113, 123] </ref> as the core e xact optimization technique. Specifically, our 2-D layout optimization algorithms are based on integer-linear programming (ILP), which is a general method to optimize a linear cost function while satisfying a system of linear inequalities o ver integer variables. <p> A sample data file for the circuit of Fig. 2.1a is shown in Fig. 2.13. Model formulation. It is well established that the formulation of an ILP problem can greatly affect its solution time <ref> [113, 123] </ref>. Some representative techniques for controlling the formulation are: adding redundant constraints, v ariable and constraint ordering, bounding the objecti ve function value, and linearizing the non-linear constraints. Most ILP solvers scan constraints from top to bottom, and variables from left to right. <p> function over three binary variables x, y, and z, where the logical sum and product are denoted by or and and, respectively. w = (x and y) or (x and z) or (y and z) = majority (x, y, z) Several systematic techniques have been proposed for linearizing such constraints <ref> [3, 98, 113] </ref>. However, most of these techniques either introduce a lar ge number of intermediate binary variables or result in a lar ge number of additional constraints, f actors which adversely affect the 60 problems complexity. <p> In these linearizations, a v ariable x can be substituted for its logical inverse not x by replacing x by 1 x in the linear inequalities. Table 3.3 gives a systematic procedure for linearizing an y nonlinear logical constraint without any loss of optimality <ref> [113] </ref>. Since an y boolean expression can be reduced to a sum-of-products form, we consider a general sum-of-products expression z = (x 1 and y 1 and ...) or (x 2 and y 2 and ...) or ... or (x k and y k and ...).
Reference: [114] <author> S. Wimer, R.Y. Pinter, and J.A. Feldman, </author> <title> Optimal Chaining of CMOS Transistors in a Functional Cell, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 6, </volume> <pages> pp. 795-801, </pages> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> As Maziasz and Hayes [82] demonstrate for an exclusive-or circuit, their exact technique produces a 1-D layout that is 80% smaller than that produced by SOLO. Techniques proposed by Hill [57], W imer et al. <ref> [114] </ref>, and Shiraishi et al. [101] also handle arbitrary CMOS netw orks. The method of Wimer et al. forms an e xhaustive list of chains, and then selects the smallest chain co ver that reduces the cell height based on routing density . <p> Thus, for the circuit of Fig. 2.8 a, HRM-TrailTrace yields the layout of Fig. 2.8 c for the linear order G 1 -G 2 -G 3 -G 4 -G 5 , but does not generate the minimum-height layout of Fig. 2.8d. Wimer et al. <ref> [114] </ref> also extend their single-cell layout method to multiple cells. Like [82], they assume that the location of each cell in the array is f ixed. <p> Although the problem of transistor chain generation has been solv ed using various algorithms <ref> [42, 62, 82, 114] </ref>, a technique that is applicable to the entire class of complex dual CMOS networks in required. We use the exact chain generation algorithm proposed by Gupta et al. for the XPRESS cell synthesis tool [42]. <p> For example, diffusion sharing between transistors belonging to different clusters depends on transistor placement within each cluster . Hence, hierarchical layout techniques, such as those proposed in <ref> [62, 82, 92, 114] </ref> for 1-D cell arrays, that generate intra and inter-cluster layouts in two sequential stages can yield layouts that are arbitrarily far from optimal.
Reference: [115] <author> O. Wing, </author> <title> Gate Matrix Layout, </title> <booktitle> Proc. IEEE International Symp. on Circuits and Systems, </booktitle> <pages> pp. 199-202, </pages> <year> 1985. </year>
Reference-contexts: Figure 1.9 illustrates the gate matrix method for the majority function circuit of Fig. 1.2. Area minimizing techniques for a gate matrix aim at ordering the gate columns so that the rows can be shared and therefore their number can be minimized <ref> [115] </ref>. However, gate matrix methods waste considerable area since all columns all widely and equally spaced to allo w for contacts and interconnects. Moreo ver, they tend to have long polysilicon g ate connections which degrades circuit performance. Functional cells.
Reference: [116] <author> W. Wolf, Dumbo, </author> <title> A Schematic-to-Layout Compiler, </title> <booktitle> Proc. 3rd Caltech Conf. on Very Large Scale Integration, </booktitle> <pages> pp. 379-393, </pages> <year> 1983. </year>
Reference-contexts: A 4-bit full-adder with carry bypass circuity, laid out in a 2-D style so as to have a 1:1 aspect ratio is reported to have 20% smaller area than a 1-D layout. Two-dimensional cell layout has also been addressed by se veral heuristic, rule-based systems such as Wolfs Dumbo <ref> [116] </ref>, Kims Talib [70], and TOPOLOGIZER by Kollaritsch [71].
Reference: [117] <author> B. Wu, N. A. Sherwani, N. D. Holmes, and M. Sarrafzadeh, </author> <title> Over-the-Cell Routers for New Cell Model, </title> <booktitle> Proc. 29th Design Automation Conf., </booktitle> <pages> pp. 604-607, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: their top and bottom boundaries, as well as the number of tracks a vailable for routing over the cell; the goal then is to select as many nonintersecting net se gments as possible to be routed o ver the cells so that the track densities in the channels is minimized <ref> [54, 61, 89, 117] </ref>. Some v ariants of OTC routing include simultaneous selection of an orientation of each cell [54], permutation of terminal positions [61], and minimization of net lengths along with the channel density [89].
Reference: [118] <author> Q. Wu, C. Y. R. Chen, and B. S. Carlson, </author> <title> LILA: Layout Generation for Iterative Logic Arrays, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 14, no. 11, </volume> <pages> pp. 1359-1369, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: One-dimensional layout. The widely used one-dimensional (1-D) style [14, 20, 58, 62, 83, 92, 108] is illustrated in Fig. 1.11a. This is a 1-D functional-cell layout for the majority circuit of Fig. 1.10c. While other 1-D styles ha ve been proposed <ref> [17, 65, 118] </ref> for certain specif ic application domains, the style of Fig. 1.11 a, which is assumed throughout this w ork, is most popular since it P-diffusion N-diffusion Diffusion gap P/N Fig. 1.10c NMOS PMOS P/N row #2 (b) Diffusion Chain #1 Chain #2 b a b c a c
Reference: [119] <author> R. Bar-Yehuda, R. Y. Pinter, and S. Wimer, </author> <title> Depth-first Search and Dynamic Programming Algorithms for Efficient CMOS Cell Generation, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 8, no. 7, </volume> <pages> pp. 737-743, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Most techniques that handle planar circuits (that is, circuits whose corresponding graphs can be drawn on a 2-D plane with their edges intersecting only at vertices) or arbitrarily structured networks with unequal numbers of P and N transistors, in volve heuristics at some stage of the synthesis process <ref> [20, 51, 57, 62, 64, 92, 114, 119] </ref>. <p> Finally, a linear-time heuristic is used to select a dual chain cover of minimum size. An exact branch-and-bound algorithm for cell width minimization has been proposed by Bar-Yehuda et al. <ref> [119] </ref> and has e xponential worst-case time complexity.
Reference: [120] <author> T. Yoshimura and E. S. Kuh, </author> <title> Efficient Algorithms for Channel Routing, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 1, </volume> <pages> pp. 25-35, </pages> <year> 1982. </year>
Reference-contexts: Other measures of cell performance can be similarly incorporated into CLIP. 179 Routing problems. Our pair-WH and hier-WH models that combine 2-D placement with track density computation can be adapted to other routing problems such as channel routing, o ver-the-cell routing, and net assignment. The general channel routing problem <ref> [95, 97, 120] </ref>, an instance of which is sho wn in Fig. 8.3, has fixed terminals on both sides of a rectangular channel.
Reference: [121] <author> H. Zhang and K. Asada, </author> <title> An Improved Algorithm of Transistors Pairing for Compact Layout of Non-Series-Parallel CMOS Networks, </title> <booktitle> Proc. Custom Integrated Circuits Conf., </booktitle> <pages> pp. </pages> <address> 17.2.1-17.2.4, </address> <year> 1993. </year>
Reference-contexts: An exact branch-and-bound algorithm for cell width minimization has been proposed by Bar-Yehuda et al. [119] and has e xponential worst-case time complexity. Zhang and Asada propose a method to form P/N pairs in non-series-parallel circuits <ref> [121] </ref>, and a heuristic algorithm that first minimizes the cell width by finding the minimum number of chains, and then reduces the cell height as measured by the number of routing tracks [122]. 2.3 Two-dimensional Cell Synthesis The two-dimensional cell layout style illustrated in Fig. 1.11 b introduces yet another degree <p> heuristic method lie in its generality and its ability to handle all types of CMOS networks and 2-D layouts. a b c b c e d (a) Layout using the cover -abc, de- (b) Layout using the cover -a, bced Cell width = 4 Cell width = 5 43 In <ref> [121, 122] </ref>, Zhang and Asada allude to an e xtension of their heuristic cell width and height minimization method that produces layouts with a specified aspect ratio. <p> W r of row r in the 2-D layout style can be expressed as W r = p r + c r 1 + v r , where v r accounts for the inter-row connections. 65 As noted earlier, cell layout in the 2-D style has received little research attention <ref> [93, 105, 121] </ref>. For example, Poiriers [93] greedy transistor placement method can handle constraints on the number of diffusion rows or the shape of the cell boundary . A few layout tools such as Virtuoso [13] provide support for 2-D cell synthesis. <p> For the cell width minimization problem, only chains containing distinct P/N pairs are considered. Cct. no. Circuit No. of transistors No. of nets 1 No. of chains 2 1 2-input parity circuit (Xor) [5] 10 7 16 2 Non-series-parallel bridge circuit <ref> [121] </ref> 10 10 20 3 2-level implementation of z = (a' . (e + f)' + d)' [82] 12 12 22 4 2-to-1 multiplexer 14 10 28 5 Series-parallel circuit for z = (a.b + (c+d) . (e+f) + g.h)' [108] 6 2-level implementation of the majority function z = a.b <p> Our results demonstrate that HCLIP yields area-efficient layouts, and in many cases, layouts with globally minimum-widths. We motivate HCLIP using the circuit in Fig. 6.3 a which consists of a non-series-parallel bridge circuit taken from <ref> [121] </ref> with an in verted output. The goal is to place its transistors in a single P/N row. The bridge circuit has several min-covers, each with two chains, while the inverter has a single cover -f- for its P/N pair.
Reference: [122] <author> H. Zhang and K. Asada, </author> <title> A General and Efficient Mask Pattern Generator for Non-Series-Parallel CMOS Transistor Network, </title> <journal> IFIP Trans. A-Computer Science and Technology, </journal> <volume> vol. 22, </volume> <pages> pp. 323-333, </pages> <year> 1993. </year>
Reference-contexts: Zhang and Asada propose a method to form P/N pairs in non-series-parallel circuits [121], and a heuristic algorithm that first minimizes the cell width by finding the minimum number of chains, and then reduces the cell height as measured by the number of routing tracks <ref> [122] </ref>. 2.3 Two-dimensional Cell Synthesis The two-dimensional cell layout style illustrated in Fig. 1.11 b introduces yet another degree of complexitymultiple P/N rows instead of a single ro winto the already complex cell layout problem. <p> heuristic method lie in its generality and its ability to handle all types of CMOS networks and 2-D layouts. a b c b c e d (a) Layout using the cover -abc, de- (b) Layout using the cover -a, bced Cell width = 4 Cell width = 5 43 In <ref> [121, 122] </ref>, Zhang and Asada allude to an e xtension of their heuristic cell width and height minimization method that produces layouts with a specified aspect ratio.
Reference: [123] <author> S. Zionts, </author> <title> Linear and Integer Programming, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1974. </year>
Reference-contexts: T o meet these objectives, we have chosen mathematical programming <ref> [113, 123] </ref> as the core e xact optimization technique. Specifically, our 2-D layout optimization algorithms are based on integer-linear programming (ILP), which is a general method to optimize a linear cost function while satisfying a system of linear inequalities o ver integer variables. <p> ILP problems fall in the category of NP-complete problems and are usually orders of magnitude more difficult to solve than LP problems. 51 Techniques for solving ILP problems can be divided into three classes <ref> [98, 123] </ref>: Cutting-plane methods: These deduce new constraints that must be satisfied by every integer solution. These constraints are appended to the original constraint set and eventually produce a linear program whose optimal solution has integral values for the integer variables [39]. <p> The leaf nodes satisfy all inte grality constraints and hence represent feasible solutions to the original ILP problem. The flowchart in Fig. 2.9 summarizes a typical branch-and-bound algorithm for solving MILP problems <ref> [98, 123] </ref>; here, a minimization objective is assumed. At the outset, we set the best known integer solution value z * to an arbitrarily lar ge value (infinity); the list L which stores sub-problems is emptied. <p> In contrast, interior-point methods, which start from an interior point and con verge towards an optimal boundary point, have polynomial time complexity and have been shown to be substantially f aster than the Simplex method for several large problems <ref> [68, 123] </ref>. Pseudo-boolean optimization. A linear pseudo-boolean optimization (LPB) problem is a special case of a general ILP problem in which all v ariables are restricted to boolean (0 or 1) values and all coefficients are integers. <p> A sample data file for the circuit of Fig. 2.1a is shown in Fig. 2.13. Model formulation. It is well established that the formulation of an ILP problem can greatly affect its solution time <ref> [113, 123] </ref>. Some representative techniques for controlling the formulation are: adding redundant constraints, v ariable and constraint ordering, bounding the objecti ve function value, and linearizing the non-linear constraints. Most ILP solvers scan constraints from top to bottom, and variables from left to right.
References-found: 123

