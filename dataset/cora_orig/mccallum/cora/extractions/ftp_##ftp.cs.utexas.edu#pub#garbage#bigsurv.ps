URL: ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps
Refering-URL: http://www.cs.utexas.edu/users/oops/papers.html
Root-URL: 
Title: Uniprocessor Garbage Collection Techniques  
Author: Paul R. Wilson 
Note: [Submitted to ACM Computing Surveys]  Contents  
Abstract: We survey basic garbage collection algorithms, and variations such as incremental and generational collection; we then discuss low-level implementation considerations and the relationships between storage management systems, languages, and compilers. Throughout, we attempt to present a unified view based on abstract traversal strategies, addressing issues of conservatism, opportunism, and immediacy of reclamation; we also point out a variety of implementation details that are likely to have a significant impact on performance. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: The techniques described in this survey appear to be sufficient to provide good performance in most relatively conventional uniprocessor systems, but continual advances in other areas introduce new problems for garbage collector design. Persistent object stores <ref> [ABC + 83, DSZ90, AM92] </ref> allow large interrelated data structures to be saved indefinitely without writing them to files and re-reading them when they are needed again; by automatically preserving pointer-linked data structures, they relieve the programmer of tedious and error-prone coding of input/output routines.
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> In Proceedings of the 1988 SIGPLAN Conference on Programming Language Design and Implementation [PLD88], </booktitle> <pages> pages 11-20. </pages>
Reference-contexts: In effect, this implements a "snapshot-at-beginning" collection, using a read barrier rather than 24 a write barrier. Appel, Ellis, and Li's concurrent incremental collector <ref> [AEL88] </ref> uses virtual memory primitives to implement a pagewise black-only read barrier. <p> an object header on that card, and skip forward object by object until it finds the headers of the objects on the card to be scanned. (This is a refinement of the crossing maps used by Appel Ellis and Li to support pagewise scanning in their incremental copy ing collector <ref> [AEL88] </ref>). In Wilson's scheme, the bit corresponding to a card is left set if the card contains a pointer into a younger generation. Such cards must be scanned again at the next garbage collection, even if they are not stored into again.
Reference: [AM92] <editor> Antonio Albano and Ron Morrison, editors. </editor> <booktitle> Fifth International Workshop on Persistent Object Systems, </booktitle> <address> San Miniato, Italy, Septem-ber 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The techniques described in this survey appear to be sufficient to provide good performance in most relatively conventional uniprocessor systems, but continual advances in other areas introduce new problems for garbage collector design. Persistent object stores <ref> [ABC + 83, DSZ90, AM92] </ref> allow large interrelated data structures to be saved indefinitely without writing them to files and re-reading them when they are needed again; by automatically preserving pointer-linked data structures, they relieve the programmer of tedious and error-prone coding of input/output routines.
Reference: [AMR92] <author> Saleh E. Abdullahi, Eliot E. Miranda, and Graem A. Ringwood. </author> <title> Distributed garbage collection. </title> <booktitle> In Bekkers and Cohen [BC92], </booktitle> <pages> pages 43-81. </pages>
Reference-contexts: Parallel collectors also raise issues of coordination of different parts of the garbage collection process, and of finding sufficient parallelism, despite potential bottlenecks due to the topologies of the data structures being traversed. Distributed systems pose still more problems <ref> [AMR92] </ref>; the limitations on parallelism are particularly severe when the collection process must proceed across multiple networked computers, and communication costs are high.
Reference: [And86] <author> David L. Andre. </author> <title> Paging in Lisp programs. </title> <type> Master's thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <year> 1986. </year>
Reference-contexts: Andre <ref> [And86] </ref>. <p> than actually copying the data within a large object, the pages holding the data could simply be mapped out of the old range of virtual addresses and into the new range [Wit91]. 43 Llames added dynamic grouping to Moon's Ephemeral Garbage Collector, which uses the static grouping techniques described in <ref> [And86] </ref>. More recently, microkernel operating systems have offered the ability to modify virtual memory policies without actually modifying the kernel. The kernel calls user-specified routines to control the paging of a process, rather than hard-coding the entire paging policy into the kernel itself.
Reference: [AP87] <author> S. Abraham and J. Patel. </author> <title> Parallel garbage collection on a virtual memory system. </title> <editor> In E. Chiricozzi and A. D'Amato, editors, </editor> <booktitle> International Conference on Parallel Processing and Applications, </booktitle> <pages> pages 243-246, </pages> <address> L'Aquila, Italy, September 1987. </address> <publisher> Elsevier North-Holland. </publisher>
Reference-contexts: That is, the graph of reach able objects is fixed at the moment garbage collection starts, even though the actual traversal proceeds incrementally. The first snapshot-at-beginning algorithm was apparently that of Abrahamson and Patel, which used virtual memory copy-on-write techniques <ref> [AP87] </ref>, but the same general effect can be achieved straightforwardly (and fairly efficiently) with a simple software write barrier. Perhaps the simplest and best-known snapshot collection algorithm is Yuasa's [Yua90b].
Reference: [App87] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: It is widely believed that garbage collection is quite expensive relative to explicit heap management, but several studies have shown that garbage collection is sometimes cheaper <ref> [App87] </ref> than explicit deallocation, and is usually competitive with it [Zor93]. <p> This ensures that each live object is transported exactly once, and that all pointers to the object are updated to refer to the new copy. 2.4.2 Efficiency of Copying Collection. A copying garbage collector can be made arbitrarily efficient if sufficient memory is available <ref> [Lar77, App87] </ref>. The work done at each collection is proportional to the amount of live data at the time of garbage collection. <p> Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management <ref> [App87, Zor93] </ref>. Generational techniques reduce the basic costs and disruptiveness of collection by exploiting the empirically-observed tendency of objects to die young. Incremental techniques may even make garbage collection relatively attractive for hard real-time systems.
Reference: [App89a] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: having immediate values within a word|even short integers are represented as objects with headers. 45 If strictly static typing is used, even the headers can be omitted|once a pointer field is found, and the type of the pointer is known, the type of the object it points to is obvious <ref> [App89a, Gol91] </ref>.
Reference: [App89b] <author> Andrew W. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: This might be a linked list, or a pre-allocated array that has successive locations stored into, much like pushing items on a linear-array stack. Appel's very simple (500 lines of C code) generational collector for Standard ML of New Jersey <ref> [App89b] </ref> uses such a list, which is simply scanned at each collection, with good performance for typical ML programs. Simple store lists have a disadvantage for many language implementations, however, in that they implement bags (multisets) of stored-into locations, not sets.
Reference: [App91] <author> Andrew W. Appel. </author> <title> Garbage collection. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, </booktitle> <pages> pages 89-100. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: : : : : : : : : : : : : : : 57 7.3 Multiple Differently-Managed Heaps : : 57 8 Overall Cost of Garbage Collection 58 9 Conclusions and Areas for Research 58 1 Automatic Storage Reclama tion Garbage collection is the automatic reclamation of computer storage <ref> [Knu69, Coh81, App91] </ref>. While in many systems programmers must explicitly reclaim heap memory 1 at some point in the program, by using a "free" or "dispose" statement; garbage collected systems free the programmer from this burden.
Reference: [Bak78] <author> Henry G. Baker, Jr. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: On the other hand, it appears to be simpler and faster in practice; it also makes it slightly easier to prove he correctness of the algorithm, because there is an obvious guarantee of forward progress. 3.4 Baker's Read Barrier Algorithms The best-known real-time garbage collector is Baker's incremental copying scheme <ref> [Bak78] </ref>. It is an adaptation of the simple copy collection scheme described in Sect. 2.4, and uses a read barrier for coordination with the mutator. <p> for ensuring that free memory is not exhausted before collection is finished is to use an allocation clock|for each unit of allocation, a corresponding unit of collection work is done, and the latter unit is large enough to ensure that the traversal is completed before the free space is exhausted <ref> [Bak78] </ref>. The simplest form of this is to key collection work directly to allocation|each time an object is allocated, a proportional amount of garbage collection work is done.
Reference: [Bak90] <author> Henry G. Baker, Jr. </author> <title> Unify and conquer: (garbage, updating, aliasing : : : ) in functional languages. </title> <booktitle> In Conference Record of the 1990 ACM Symposium on LISP and Functional Programming [LFP90], </booktitle> <pages> pages 218-226. </pages>
Reference-contexts: Several researchers have investigated compiler optimizations related to heap-allocated structures, both to detect potential aliasing and to allow heap objects to be stack allocated when it is possible to infer that they become garbage at a particular point in a program <ref> [Sch75a, Sch75b, Hud86, JM81, RM88, LH88, HPR89, CWZ90, Bak90] </ref>. [Cha87] discusses interactions between conventional optimizations and garbage collection, and when garbage collection-oriented optimizations are safe.
Reference: [Bak91a] <author> Henry G. Baker, Jr. </author> <title> Cache-conscious copying collection. In OOPSLA '91 Workshop on Garbage Collection in Object-Oriented Systems [OOP91]. </title> <note> Position paper. </note>
Reference-contexts: Because of the high spatial locality and low temporal locality, it may be desirable to limit the memory used by a tracing traversal, to avoid needlessly displacing the contents of memory by large amounts 40 Carl Hauser, personal communication 1991. 48 of data that are only briefly touched during tracing <ref> [Wil90, Bak91a] </ref>.
Reference: [Bak91b] <author> Henry G. Baker, Jr. </author> <title> The Treadmill: Real-time garbage collection without motion sickness. In OOPSLA '91 Workshop on Garbage Collection in Object-Oriented Systems [OOP91]. </title> <note> Position paper. Also appears as SIGPLAN Notices 27(3) 66-70, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: As we will explain in Sect. 2.7, paging costs may make the use of a larger heap area impractical if there is not a correspondingly large amount of RAM.) 2.5 Non-Copying Implicit Collection Recently, Wang [Wan89] and Baker <ref> [Bak91b] </ref> have (independently) proposed a new kind of non-copying collector with some of the efficiency advantages of a copying scheme. Their insight is that in a copying collector, the "spaces" of the collector are really just a particular implementation of sets. <p> It is an adaptation of the simple copy collection scheme described in Sect. 2.4, and uses a read barrier for coordination with the mutator. More recently, Baker has proposed a non-copying version of this algorithm, which shares many properties with the copying version <ref> [Bak91b] </ref>. 3.4.1 Incremental Copying Baker's original copying algorithm was an adaptation of the Cheney algorithm. For the most part, the copying of data proceeds in the Cheney (breadth-first) fashion, by advancing the scan pointer through the unscanned area of tospace and moving any referred-to objects from fromspace. <p> By avoiding the actual moving of objects and updating of pointers, the scheme puts fewer restrictions on other aspects of language implementation <ref> [Bak91b, WJ93] </ref>. 19 This non-copying scheme preserves the essential efficiency advantage of copy collection, by reclaiming space implicitly. (As described in Sect. 2.5, unreached objects in the white set can be reclaimed in constant time by appending the remainder of that list to the free list.) The real-time version of this
Reference: [Bak93a] <author> Henry G. Baker. </author> <title> Infant mortality and generational garbage collection. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(4) </volume> <pages> 55-57, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Longer-lived objects are collected less often, on the assumption that the minority objects which live for a significant period are likely to live a while longer still. This simple idea is widespread, but it is not obvious that it is true in any strong sense <ref> [Hay91, Bak93a] </ref>; it is also unclear that it must be true to make generational collection worthwhile in practice. Consider a system in which this property does not hold|i.e., the probability that an object will die at a particular moment is not correlated with its age.
Reference: [Bak93b] <author> Henry G. Baker, Jr. </author> <title> Safe and leakproof resource management using Ada83 limited types. </title> <type> Unpublished, </type> <year> 1993. </year>
Reference-contexts: It is desirable to optimize away most of these increments and decrements that cancel each other out. 2.1.3 Deferred Reference Counting. Much of this cost can be optimized away by special treatment of local variables <ref> [DB76, Bak93b] </ref>. Rather than always adjusting reference counts and reclaiming objects whose counts become zero, references from the local variables are not included in this bookkeeping most of the time. Usually, reference counts are only adjusted to reflect pointers from one heap object to another. <p> Another problem is that not all operators can be overloaded in this way. C++ provides most, but not all, of the extensibility necessary to integrate garbage collection into the language gracefully. (It is apparently easier in Ada <ref> [Bak93b] </ref>, because the overloading system is more powerful and the builtin pointer types have fewer subtleties which must be emulated.) Yet another limitation is that it is impossible to re-define operations on built-in classes, making it difficult to enhance the existing parts of the language|only user-defined types can be garbage collected
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, Califor-nia, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: A major point in favor of in-place collectors is the ability to make them conservative with respect to data values that may or may not be pointers. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the 15 (possible) pointer to it doesn't need to be changed. <p> Conservative pointer finding can be combined with other techniques to cope with language implementations that are only partly cooperative. For example, Barlett's and Detlefs' "mostly-copying" collectors use headers to decode fields of objects in the heap, but rely on conservative techniques to find pointers from the activation stack <ref> [Bar88, Det91] </ref>. This supports copying techniques that relocate and compact most (but not all) objects.
Reference: [Bar89] <author> Joel F. Bartlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical Note TN-12, </type> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: The "Stratified Garbage Collector" for Austin Kyoto Common Lisp (an enhancement of Kyoto Common Lisp) uses such a scheme to avoid the overhead of a write barrier. 33 Bartlett has used a similar technique in a collector designed to work with off-the-shelf compilers which do not emit write barrier instructions <ref> [Bar89] </ref>. 4.4.1 Indirection Tables The original generational collectors for Lisp Machines [LH83] used specialized hardware and/or microcode to speed up the checks for pointers into younger generations, and the pointers that were found were in-directed (by a microcoded routine) through an entry table.
Reference: [BBDT84] <author> G. Bozman, W. Buco, T. P. Daly, and W. H. Tetzlaff. </author> <title> Analysis of free storage algorithms| revisited. </title> <journal> IBM Systems Journal, </journal> <volume> 23(1) </volume> <pages> 44-64, </pages> <year> 1984. </year>
Reference-contexts: An intermediate strategy is to use a single data structure, but use a tree or similar structure sorted by the sizes (and/or addresses) of the free spaces [Ste83] to reduce search times. Most of these systems and several hybrids (e.g., <ref> [BBDT84, OA85, WW88, GZ93] </ref>) are already described in the literature on memory management, and we will not describe them here. An exception to this is bitmapped memory management, which has been used in several garbage collectors, but is not usually discussed in the literature.
Reference: [BC79] <author> Daniel G. Bobrow and Douglas W. Clark. </author> <title> Compact encodings of list structure. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(2) </volume> <pages> 266-286, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: One of these is a fine-grained mechanism called cdr coding, which is specific to list cells such as Lisp cons cells <ref> [Han69, BC79, LH86] </ref>. The other is compressed paging, a more general-purpose mechanism that operates on virtual memory pages [Wil91, Dou93, WB94]. Both mechanisms are invisible at the language level. Cdr-coding was used in many early Lisp systems, when random-access memory was very expensive.
Reference: [BC91] <author> Hans-Juergen Boehm and David Chase. </author> <title> A proposal for garbage-collector-safe compilation. </title> <journal> The Journal of C Language Translation, </journal> <volume> 4(2) </volume> <pages> 126-141, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the compiler's code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, BC91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access <p> To avoid this problem, garbage collector designers have proposed a set of constraints that compilers can preserve to ensure that garbage collection is possible; these constraints do not require major changes to existing compilers <ref> [Boe91, BC91] </ref>. Similarly, programming guidelines have been proposed to ensure that programmers in C++ avoid constructions that make correct garbage collection impossible [ED93]; by programming in a very slightly restricted subset of C++, it is possible to ensure that a cooperative compiler can support correct garbage collection.
Reference: [BC92] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> International Workshop on Memory Manage 60 ment, number 637 in Lecture Notes in Com--puter Science, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: focus is on garbage collection for procedural and object-oriented languages, but much of the information here will serve as background for understanding garbage collection of other kinds of systems, such as functional or logic programming languages. (For further reading on various advanced topics in garbage collection, the papers collected in <ref> [BC92] </ref> are a good starting point. 3 ) 1.1 Motivation Garbage collection is necessary for fully modular programming, to avoid introducing unnecessary inter-module dependencies.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the 1991 SIGPLAN Conference on Programming Language Design and Implementation [PLD91], </booktitle> <pages> pages 157-164. </pages>
Reference-contexts: A major point in favor of in-place collectors is the ability to make them conservative with respect to data values that may or may not be pointers. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the 15 (possible) pointer to it doesn't need to be changed. <p> We will discuss this in more detail in Sect. 3.8.2. Careful attention should be paid to write barrier implementation. Boehm, Demers and Shenker's <ref> [BDS91, Boe91] </ref> incremental update algorithm uses virtual memory dirty bits as a coarse pagewise write barrier. <p> Alternatively, virtual memory protection facilities can be used to simulate dirty bits, by write-protecting pages so that writes to them can be detected by the hardware and invoke a trap handler <ref> [BDS91] </ref>; this technique is used in the Xerox Portable Common Runtime garbage collector. <p> The bitmap is updated when objects are allocated or reclaimed. The bitmap can be scanned to construct a free list (as in <ref> [BDS91] </ref>) or it can be searched at allocation time in a manner analogous to the search of a free list in a sequential fit algorithm. 6.6 Compact Representations of Heap Data Representations of heap data are often optimized for speed, rather than for space.
Reference: [Bla83] <author> Ricki Blau. </author> <title> Paging on an object-oriented personal computer for Smalltalk. </title> <booktitle> In Proceedings of the ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Minneapolis, Minnesota, </address> <month> August </month> <year> 1983. </year> <note> Also available as Technical Report UCB/CSD 83/125, </note> <institution> University of California at Berkeley, Computer Science Division (EECS), </institution> <month> August </month> <year> 1983. </year>
Reference-contexts: during the tracing phase, keeping the most active data in fast memory. 41 5.4 Clustering of Longer-Lived Ob jects Several studies have addressed copying collection's indirect effect on locality|i.e., the effect of reorganizing the data which are subsequently accessed by the running program. 5.4.1 Static Grouping Stamos [Sta82, Sta84] Blau <ref> [Bla83] </ref> studied the effects of using different copying traversal algorithms to reorganize long-lived system data and code in Smalltalk systems.
Reference: [Bob80] <author> Daniel G. Bobrow. </author> <title> Managing reentrant structures using reference counts. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(3) </volume> <pages> 269-273, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: One cost is that when a pointer is created or destroyed, its referent's count must be adjusted. If a variable's value is changed from one pointer to another, two objects' counts must be 8 <ref> [Bob80] </ref> describes modifications to reference counting to allow it to handle some special cases of cyclic structures, but this restricts the programmer to certain stereotyped patterns. 7 adjusted|one object's reference count must be incre-mented, the other's decremented and then checked to see if it has reached zero.
Reference: [Boe91] <author> Hans-Juergen Boehm. </author> <title> Hardware and operating system support for conservative garbage collection. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <pages> pages 61-67, </pages> <address> Palo Alto, California, </address> <month> October </month> <year> 1991. </year> <note> IEEE Press. </note>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the compiler's code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, BC91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access <p> We will discuss this in more detail in Sect. 3.8.2. Careful attention should be paid to write barrier implementation. Boehm, Demers and Shenker's <ref> [BDS91, Boe91] </ref> incremental update algorithm uses virtual memory dirty bits as a coarse pagewise write barrier. <p> To avoid this problem, garbage collector designers have proposed a set of constraints that compilers can preserve to ensure that garbage collection is possible; these constraints do not require major changes to existing compilers <ref> [Boe91, BC91] </ref>. Similarly, programming guidelines have been proposed to ensure that programmers in C++ avoid constructions that make correct garbage collection impossible [ED93]; by programming in a very slightly restricted subset of C++, it is possible to ensure that a cooperative compiler can support correct garbage collection.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation [PLD93], </booktitle> <pages> pages 197-206. </pages>
Reference-contexts: The extent of these problems is not well understood, but they may be less serious than is widely believed <ref> [Hay91, BZ93, Boe93] </ref>. 5.2 Locality of Allocation and Short lived objects As noted above, the pattern of allocation often has the most important effect on locality in a simple collector. <p> Surprisingly, these techniques are effective enough that most C programs can be garbage collected fairly efficiently, with little or no modification <ref> [Boe93] </ref>. This simplifies the garbage collection of programs written without garbage collection in mind, and programs written in multiple languages, some of which are uncooperative [WDH89]. (Making such a collector generational requires special techniques, due to the lack of compiler cooperation in implementing a write barrier to detect intergenera-tional pointers.
Reference: [Bro84] <author> Rodney A. Brooks. </author> <title> Trading data space for reduced time and code space in real-time collection on stock hardware. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on LISP and Functional Programming [LFP84], </booktitle> <pages> pages 108-113. </pages>
Reference-contexts: Brooks has proposed a variation on Baker's scheme, where objects are always referred to via an indirection field embedded in the object itself <ref> [Bro84] </ref>. If an object is valid, its indirection field points to itself. If it's an obsolete version in fromspace, its indirection pointer points to the new version. <p> The choice of a read- or write-barrier (and strategy for ensuring correctness) is mostly independent of the choice of a tracing and reclamation mechanism. For example, Brooks' copying collector <ref> [Bro84] </ref> (which we mentioned in Sect 3.4.1) is actually an incremental update write barrier algorithm, even though Brooks describes it as an optimization of Baker's scheme. 23 Similarly, Dawson's copying scheme (proposed in [Daw82]) is cast as a variant of Baker's, but it is actually an incremental update scheme, and objects
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: necessary, except the types of the root set variables. (This will be discussed in Sect 6.1.) Despite this, headers are often used for statically-typed languages, because it simplifies implementations at little cost. (Conventional (explicit) heap management systems often use object headers for similar reasons.) (Garbage collectors using conservative pointer finding <ref> [BW88] </ref> are usable with little or no cooperation from the compiler|not even the types of named variables|but we will defer discussion of these collectors until Sect 6.2.) 1.4 Overview of the Paper The remainder of this paper will discuss basic and advanced topics in garbage collection. <p> A major point in favor of in-place collectors is the ability to make them conservative with respect to data values that may or may not be pointers. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the 15 (possible) pointer to it doesn't need to be changed. <p> those that are only of interest to the collector and allocator. 6.2 Conservative Pointer Finding An extreme case of catering to other aspects of a language implementation is conservative pointer-finding, which is a strategy for coping with compilers that don't offer any support for runtime type identification or garbage collection <ref> [BW88] </ref>. 47 In such a system, the collector treats anything that might be a pointer as a pointer|e.g., any properly-aligned bit pattern that could be the address of an object in the heap.
Reference: [BZ93] <author> David A. Barrett and Bejamin G. Zorn. </author> <title> Using lifetime predictors to improve memory allocation performance. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation [PLD93], </booktitle> <pages> pages 187-196. </pages>
Reference-contexts: The extent of these problems is not well understood, but they may be less serious than is widely believed <ref> [Hay91, BZ93, Boe93] </ref>. 5.2 Locality of Allocation and Short lived objects As noted above, the pattern of allocation often has the most important effect on locality in a simple collector.
Reference: [CDG + 89] <author> Luca Cardelli, James Donahue, Lucille Glass-man, Mick Jordan, Bill Kalso, and Greg Nel-son. </author> <note> Modula-3 report (revised). Research Report 52, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: In some languages, such as Modula-3 <ref> [CDG + 89] </ref> and an extended version of C++ [ED93], a garbage collected heap coexists with an explicitly-managed heap. This supports garbage collection, while allowing programmers to explicitly control deallocation of some objects for maximum performance or predictability.
Reference: [CG77] <author> Douglas W. Clark and C. Cordell Green. </author> <title> An empirical study of list structure in LISP. </title> <journal> Communications of the ACM, </journal> <volume> 20(2) </volume> <pages> 78-87, </pages> <month> February </month> <year> 1977. </year>
Reference-contexts: In addition, the garbage spaces are simply "squeezed out," without disturbing the original ordering of objects in memory. This can ameliorate locality problems, because the allocation ordering is usually more similar to subsequent access orderings than an arbitrary ordering imposed by a copying garbage collector <ref> [CG77, Cla79] </ref>. While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects [CN83].
Reference: [Cha87] <author> David Chase. </author> <title> Garbage Collection and Other Optimizations. </title> <type> PhD thesis, </type> <institution> Rice University, Houston, Texas, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Several researchers have investigated compiler optimizations related to heap-allocated structures, both to detect potential aliasing and to allow heap objects to be stack allocated when it is possible to infer that they become garbage at a particular point in a program [Sch75a, Sch75b, Hud86, JM81, RM88, LH88, HPR89, CWZ90, Bak90]. <ref> [Cha87] </ref> discusses interactions between conventional optimizations and garbage collection, and when garbage collection-oriented optimizations are safe.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for an Object-Oriented Programming Language. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: This comes at an increase in scanning costs, because the byte array is eight times larger than a bit array, but for most systems the decrease in write-barrier cost is well worth it <ref> [Cha92, DMH92] </ref>. <p> Simulating these characteristics in software is extremely expensive.) The alternative is to sacrifice bits from the exponent part of the hardware-supported format, and restrict the range of numbers that can be represented. This introduces several instructions extra overhead in converting between the hardware-supported format and the tagged format <ref> [Wil90, Cha92] </ref>. Using arrays with typed fields introduce irregularities into dynamically-typed systems (e.g., most arrays can hold any kind of data, but some can't), but this strategy is easy to implement efficiently, and is frequently used in Lisp systems.
Reference: [Che70] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: A very common kind of copying garbage collector is the semispace collector [FY69] using the Cheney algorithm for the copying traversal <ref> [Che70] </ref>. We will use this collector as a reference model for much of this paper. 12 In this scheme, the space devoted to the heap is subdivided into two contiguous semispaces. During normal program execution, only one of these semi-spaces is in use, as shown in Fig. 3. <p> Once the copying is completed, the tospace semispace is made the "current" semispace, and program execution is resumed. Thus the roles of the two spaces are reversed each time the garbage collector is invoked. (See Fig. 4.) Perhaps the simplest form of copying traversal is the Cheney algorithm <ref> [Che70] </ref>. The immediately-reachable objects form the initial queue of objects for a breadth-first traversal. A "scan" pointer is advanced through the first object, location by location.
Reference: [CHO88] <author> Will Clinger, Anne Hartheimer, and Erik Ost. </author> <title> Implementation strategies for continuations. </title> <booktitle> In Conference Record of the 1988 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 124-131, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This is borne out by simulation studies of Standard ML of New Jersey [DTM93] on high-performance processors. It suggests that activation information and binding environments should be allocated on a stack using compile time analysis [KKR + 86] or in a software stack cache <ref> [CHO88, WM89, Kel93] </ref>. (Software stack caches can be used in languages like ML and Scheme, where binding environments may be captured by first-class procedures and/or activation chains may be captured with first-class continuations.
Reference: [Cla79] <author> Douglas W. Clark. </author> <title> Measurements of dynamic list structure use in Lisp. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(1) </volume> <pages> 51-59, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: In addition, the garbage spaces are simply "squeezed out," without disturbing the original ordering of objects in memory. This can ameliorate locality problems, because the allocation ordering is usually more similar to subsequent access orderings than an arbitrary ordering imposed by a copying garbage collector <ref> [CG77, Cla79] </ref>. While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects [CN83].
Reference: [CN83] <author> Jacques Cohen and Alexandru Nicolau. </author> <title> Comparison of compacting algorithms for garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 532-553, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects <ref> [CN83] </ref>. One pass computes the new locations that objects will be moved to; subsequent passes must update pointers to refer to objects' new locations, and actually move the objects. These algorithms may be therefore be significantly slower than mark-sweep if a large percentage of data survives to be compacted. <p> for live objects, and the other scans upward from the bottom, looking for holes to put them in. (Many variations of this algorithm are possible, to deal with multiple areas holding different-sized objects, and to avoid intermingling objects from widely-dispersed areas.) For a more complete treatment of compacting algorithms, see <ref> [CN83] </ref>. 2.4 Copying Garbage Collection Like mark-compact (but unlike mark-sweep), copying garbage collection does not really "collect" garbage.
Reference: [Coh81] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: : : : : : : : : : : : : : : 57 7.3 Multiple Differently-Managed Heaps : : 57 8 Overall Cost of Garbage Collection 58 9 Conclusions and Areas for Research 58 1 Automatic Storage Reclama tion Garbage collection is the automatic reclamation of computer storage <ref> [Knu69, Coh81, App91] </ref>. While in many systems programmers must explicitly reclaim heap memory 1 at some point in the program, by using a "free" or "dispose" statement; garbage collected systems free the programmer from this burden. <p> This paper surveys basic and advanced techniques in uniprocessor garbage collectors, especially those developed in the last decade. (For a more thorough treatment of older techniques, see <ref> [Knu69, Coh81] </ref>.) While it does not cover parallel or distributed collection, it presents a unified taxonomy of incremental techniques, which lays the groundwork for understanding parallel and distributed collection. <p> Traditionally, as with reference counting, these reclaimed objects are linked onto one or more free lists so that they are accessible to the allocation routines. 10 More detailed descriptions of traversal and marking algo rithms can be found in [Knu69] and <ref> [Coh81] </ref>. There are three major problems with traditional mark-sweep garbage collectors. First, it is difficult to handle objects of varying sizes without fragmentation of the available memory.
Reference: [Col60] <author> George E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Communications of the ACM, </journal> <volume> 2(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: There are several varieties of tracing collection: mark-sweep, mark-compact, copying, and non-copying implicit reclamation. 7 Because each garbage detection scheme has a major influence on reclamation and on reuse techniques, we will introduce reclamation methods as we go. 2.1 Reference Counting In a reference counting system <ref> [Col60] </ref>, each object has an associated count of the references (pointers) to it. Each time a reference to the object is created, e.g., when a pointer is copied from one place to another by an assignment, the pointed-to object's count is incremented.
Reference: [Cou88] <author> Robert Courts. </author> <title> Improving locality of reference in a garbage-collecting memory management system. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1128-1138, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Lisp machine garbage collectors <ref> [Moo84, Cou88] </ref> avoid this problem by using only a single space per generation. Rather than copying objects from one semispace to the other until they are advanced, garbage collection of a generation advances all objects into the next generation. <p> This scheme is impractical in its original form (because the sheer volume of garbage would swamp the write bandwidth of typical disks if memory were not reclaimed [Ung84]), but the same basic idea has been incorporated into the garbage collector of the Texas Instruments Explorer Lisp machines <ref> [Cou88, Joh91] </ref>. This collector avoids performing exhaustive background scavenging until toward the end of the garbage collection cycle, to enhance the odds that objects will be reached first by the mutator, and copied in a locality-enhancing order.
Reference: [CU89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing compiler technology for Self, a dynamically-typed object-oriented language. </title> <booktitle> In Proceedings of SIGPLAN '89, </booktitle> <pages> pages 146-160, </pages> <year> 1989. </year>
Reference-contexts: Compilers may perform dataflow analysis which may allow the omission of a write barrier for more non-pointer assignment operations. In the future, advanced type-flow analysis such as that used in the Self compiler <ref> [CU89, CU91] </ref> may provide greater opportunities for read and write barrier optimizations.
Reference: [CU91] <author> Craig Chambers and David Ungar. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In Paepcke [Pae91], </booktitle> <pages> pages 1-15. </pages>
Reference-contexts: Compilers may perform dataflow analysis which may allow the omission of a write barrier for more non-pointer assignment operations. In the future, advanced type-flow analysis such as that used in the Self compiler <ref> [CU89, CU91] </ref> may provide greater opportunities for read and write barrier optimizations.
Reference: [CWB86] <author> Patrick J. Caudill and Allen Wirfs-Brock. </author> <title> A third-generation Smalltalk-80 implementation. </title> <booktitle> In Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '86) Proceedings, </booktitle> <pages> pages 119-130. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1986. </year> <month> 61 </month>
Reference-contexts: Further, real high-performance systems often use hybrid techniques to adjust tradeoffs for different categories of objects. Many high-performance copy collectors use a separate large object area <ref> [CWB86, UJ88] </ref>, to avoid copying large objects from space to space. The large objects are kept "off to the side" and usually managed in-place by some variety of marking traversal and free list technique. <p> to scale|the younger generation is typically several times smaller than the older one.) The number of generations may be greater than two, with each successive generation holding older objects and being collected considerably less often. (Tektronix 4406 Smalltalk is such a generational system, using semispaces for each of eight generations <ref> [CWB86] </ref>.) In order for this scheme to work, it must be possible to collect the younger generation (s) without collecting the older one (s). Since liveness of data is a global property, however, old-memory data must be taken into account. <p> It is common for copying collectors to manage large objects differently, storing them in a special large object area and avoiding actually copying them <ref> [CWB86] </ref>.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Ken--neth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the 1990 SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> White Plains, New York, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Several researchers have investigated compiler optimizations related to heap-allocated structures, both to detect potential aliasing and to allow heap objects to be stack allocated when it is possible to infer that they become garbage at a particular point in a program <ref> [Sch75a, Sch75b, Hud86, JM81, RM88, LH88, HPR89, CWZ90, Bak90] </ref>. [Cha87] discusses interactions between conventional optimizations and garbage collection, and when garbage collection-oriented optimizations are safe.
Reference: [Daw82] <author> Jeffrey L. Dawson. </author> <title> Improved effectiveness from a real-time LISP garbage collector. </title> <booktitle> In Conference Record of the 1982 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 159-167, </pages> <address> Pittsburgh, Pennsylva-nia, </address> <month> August </month> <year> 1982. </year> <note> ACM Press. </note>
Reference-contexts: For example, Brooks' copying collector [Bro84] (which we mentioned in Sect 3.4.1) is actually an incremental update write barrier algorithm, even though Brooks describes it as an optimization of Baker's scheme. 23 Similarly, Dawson's copying scheme (proposed in <ref> [Daw82] </ref>) is cast as a variant of Baker's, but it is actually an incremental update scheme, and objects are allocated in fromspace, i.e., white, as in Dijkstra's collector. The choice of a read- or write-barrier scheme is likely to be made on the basis of the available hardware.
Reference: [DB76] <author> L. Peter Deutsch and Daniel G. Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: It is desirable to optimize away most of these increments and decrements that cancel each other out. 2.1.3 Deferred Reference Counting. Much of this cost can be optimized away by special treatment of local variables <ref> [DB76, Bak93b] </ref>. Rather than always adjusting reference counts and reclaiming objects whose counts become zero, references from the local variables are not included in this bookkeeping most of the time. Usually, reference counts are only adjusted to reflect pointers from one heap object to another. <p> The interval between these phases is generally chosen to be short enough that garbage is reclaimed often and quickly, yet still long enough that the cost of periodically updating counts (for stack references) is not high. This deferred reference counting <ref> [DB76] </ref> avoids adjusting reference counts for most short-lived pointers from the stack, and greatly reduces the overhead of reference counting. When pointers from one heap object to another are created or destroyed, however, the reference counts must still be adjusted.
Reference: [Del92] <author> V. Delacour. </author> <title> Allocation regions and implementation contracts. </title> <booktitle> In Bekkers and Cohen [BC92], </booktitle> <pages> pages 426-439. </pages>
Reference-contexts: This supports garbage collection, while allowing programmers to explicitly control deallocation of some objects for maximum performance or predictability. Issues in the design of such multiple-heap systems are discussed in <ref> [Del92] </ref> and [ED93]. In other systems, such as large persistent or distributed shared memories, it may also be desirable to have multiple heaps with different policies for distribution (e.g., shared vs. unshared), access privileges, and resource management [Mos89, Del92]. <p> Issues in the design of such multiple-heap systems are discussed in [Del92] and [ED93]. In other systems, such as large persistent or distributed shared memories, it may also be desirable to have multiple heaps with different policies for distribution (e.g., shared vs. unshared), access privileges, and resource management <ref> [Mos89, Del92] </ref>.
Reference: [DeT90] <author> John DeTreville. </author> <title> Experience with concurrent garbage collectors for Modula-2+. </title> <type> Technical Report 64, </type> <institution> Digital Equipment Corporation Systems Research Center, Palo Alto, Cal-ifornia, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: As we will explain below, other techniques are usually more efficient and reliable. Still, reference counting has its advantages. The immediacy of reclamation can have advantages for overall memory usage and for locality of reference <ref> [DeT90] </ref>; a reference counting system may perform with little degradation when almost all of the heap space is occupied by live objects, while other collectors rely on trading more space for higher efficiency. 9 It can also be useful for finalization, that is, performing "clean-up" actions (like closing files) when objects <p> In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>. <p> Most objects in the generation (s) being collected will be touched exactly once, because most objects are pointed to by exactly one other object <ref> [Rov85, DeT90] </ref>|typical data structures do not contain a large number of cycles, and many cycles are small enough to have little impact on traversal locality. Given this, the main characteristic of the traversal is to exhaustively touch all live data, but for the most part very briefly.
Reference: [Det91] <author> David L. Detlefs. </author> <title> Concurrent, Atomic Garbage Collection. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> November </month> <year> 1991. </year> <note> Technical report CMU-CS-90-177. </note>
Reference-contexts: Conservative pointer finding can be combined with other techniques to cope with language implementations that are only partly cooperative. For example, Barlett's and Detlefs' "mostly-copying" collectors use headers to decode fields of objects in the heap, but rely on conservative techniques to find pointers from the activation stack <ref> [Bar88, Det91] </ref>. This supports copying techniques that relocate and compact most (but not all) objects. <p> In large persistent or distributed systems, data integrity is particularly important; garbage collection strategies must be coordinated with checkpointing and recovery, both for efficiency and to ensure that the collector itself does not fail <ref> [Kol90, Det91, ONG93] </ref>. As high-performance graphics and sound capabilities become more widely available and economical, computers are likely to be used in more graphical and interactive ways. Multimedia and virtual reality applications will require garbage collection techniques that do not impose large delays, making incremental techniques increasingly desirable.
Reference: [Det92] <author> David L. Detlefs. </author> <title> Garbage collection and run-time typing as a C++ library. </title> <booktitle> In USENIX C++ Conference [USE92]. </booktitle>
Reference-contexts: Still another limitation is that garbage collection is difficult to implement efficiently within the language, because it is impossible to tell the compiler how to compile for certain important special cases <ref> [Det92, Ede92] </ref> For example, in C++ or Ada, there is no way to specialize an operation for objects that are known at compile time not to be allocated in the heap. 49 49 In C++ terminology, operators can only be specialized on Recent work in reflective systems has explored languages with
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: The difficulty with incremental tracing is that while the collector is tracing out the graph of reachable data structures, the graph may change|the running program may mutate the graph while the collector "isn't looking." For this reason, discussions of incremental collectors typically refer to the running program as the mutator <ref> [DLM + 78] </ref>. (From the garbage collector's point of view, the actual application is merely a coroutine or concurrent process with an unfortunate tendency to modify data structures that the collector is attempting to traverse.) An incremental scheme must have some way of keeping track of the changes to the graph <p> we have in the details of the traversal algorithm. (In parallel and distributed garbage collection, a relaxed consistency model also allows more parallelism and/or less synchronization, but that is beyond the scope of this survey.) 3.2 Tricolor Marking The abstraction of tricolor marking is helpful in understanding incremental garbage collection <ref> [DLM + 78] </ref>. Garbage collection algorithms can be described as a process of traversing the graph of reachable objects and coloring them. The objects subject to garbage collection are conceptually colored white, and by the end of collection, those that will be retained must be colored black. <p> Conceptually, the black object (or part of it) is reverted to gray when the mutator "undoes" the collector's traversal [Ste75]. (Alternatively, the pointed-to object may be grayed immediately <ref> [DLM + 78] </ref>.) This ensures that the traversal is updated in the face of mutator changes. Read barriers and write barriers are conceptually synchronization operations|before the mutator can perform certain operations, it must activate the garbage collector to perform some action. <p> Unfortunately, incremental update algorithms have generally been cast in terms of parallel systems, rather than as incremental schemes for serial processing; perhaps due to this, they have been largely overlooked by implementors targeting uniprocessors. 15 Perhaps the best known of these algorithms is due to Dijkstra et al. <ref> [DLM + 78] </ref>. (This is similar to the scheme developed by Steele [Ste75], but simpler because it does not deal with compaction.) Rather than retaining everything that's in a snapshot of the graph at the beginning of garbage collection, it heuristically (and somewhat conservatively) attempts to retain the objects that are <p> garbage collection process, particularly when trying to make a hierarchical generational or distributed version of a snapshot algorithm, where multiple garbage collections of different scopes proceed concurrently [WJ93]. 15 Another probable reason is that the early papers on concurrent garbage collection addressed different concerns than those facing most language implementors. <ref> [DLM + 78] </ref> stressed elegance of correctness proofs at the expense of efficiency, and readers may have missed the fact that trivial changes to the algorithm would make it vastly more practical. [Ste75] presented a complex algorithm with an optional incremental compaction phase; many readers doubtless failed to recognize that the <p> In the incremental update scheme of Dijkstra et al. <ref> [DLM + 78] </ref>, objects are optimistically assumed to be unreachable when they're allocated. In terms of tricolor marking, objects are allocated white, rather than black. At some point, the stack must be traversed and the objects that are reachable at that time are marked and therefore preserved. <p> Steele proposes a heuristic that allocates some objects white and other objects black, attempting to reclaim the short-live objects quickly while avoiding traversal of most other objects [Ste75]. 16 The algorithm of <ref> [DLM + 78] </ref> actually uses a somewhat more conservative technique, as we will explain shortly. 21 The effectiveness of this heuristic is unproven, and it appears to be difficult to implement efficiently on standard hardware. Dijkstra's incremental update algorithm [DLM + 78] (which apparently predates Steele's slightly) actually preserves the tricolor <p> avoiding traversal of most other objects [Ste75]. 16 The algorithm of <ref> [DLM + 78] </ref> actually uses a somewhat more conservative technique, as we will explain shortly. 21 The effectiveness of this heuristic is unproven, and it appears to be difficult to implement efficiently on standard hardware. Dijkstra's incremental update algorithm [DLM + 78] (which apparently predates Steele's slightly) actually preserves the tricolor invariant by blackening the pointed-to white object, rather than reverting the stored-into black object to gray. Intuitively, this pushes the gray wavefront outward to preserve the tricolor invariant, rather than pushing it back.
Reference: [DMH92] <author> Amer Diwan, Eliot Moss, and Richard Hud-son. </author> <title> Compiler support for garbage collection in a statically-typed language. </title> <booktitle> In Proceedings of the 1992 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, Califor-nia, June 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the compiler's code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, BC91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access <p> This comes at an increase in scanning costs, because the byte array is eight times larger than a bit array, but for most systems the decrease in write-barrier cost is well worth it <ref> [Cha92, DMH92] </ref>. <p> The space requirements for this additional information (which essentially annotates the executable code) may not be negligible, however, and it may be desirable in some cases to change the compiler's code generation strategy slightly <ref> [DMH92] </ref>. 6.4.3 Optimization of Garbage Collection It self While garbage collectors can be constrained by their relationship to the compiler and its optimizations, it is also possible for the compiler to assist in making the garbage collector efficient.
Reference: [Dou93] <author> Fred Douglis. </author> <title> The compression cache: Using on-line compression to extend physical memory. </title> <booktitle> In Proceedings of 1993 Winter USENIX Conference, </booktitle> <pages> pages 519-529, </pages> <address> San Diego, Cali-fornia, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: One of these is a fine-grained mechanism called cdr coding, which is specific to list cells such as Lisp cons cells [Han69, BC79, LH86]. The other is compressed paging, a more general-purpose mechanism that operates on virtual memory pages <ref> [Wil91, Dou93, WB94] </ref>. Both mechanisms are invisible at the language level. Cdr-coding was used in many early Lisp systems, when random-access memory was very expensive. Unfortunately, it tended to be rather expensive in CPU time, because the changeable representations of list complicate basic list operations.
Reference: [DSZ90] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors. </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice (Proceedings of the Fourth International Workshop on Persistent Object Systems), </booktitle> <address> Martha's Vineyard, Massachusetts, </address> <month> September </month> <year> 1990. </year> <note> Mor-gan Kaufman. </note>
Reference-contexts: The techniques described in this survey appear to be sufficient to provide good performance in most relatively conventional uniprocessor systems, but continual advances in other areas introduce new problems for garbage collector design. Persistent object stores <ref> [ABC + 83, DSZ90, AM92] </ref> allow large interrelated data structures to be saved indefinitely without writing them to files and re-reading them when they are needed again; by automatically preserving pointer-linked data structures, they relieve the programmer of tedious and error-prone coding of input/output routines.
Reference: [DTM93] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory subsystem performance of programs with intensive heap allocation. </title> <note> Submitted for publication, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: based on combinator reduction [KLS92], and showed that some conventional cache designs can achieve this effect. 39 Tarditi and Diwan show that the same effect can be achieved in a more conventional language implementation using generational garbage collection, and demonstrate the value of a cache-to-memory interface supporting high write rates <ref> [DTM93] </ref>. <p> This is borne out by simulation studies of Standard ML of New Jersey <ref> [DTM93] </ref> on high-performance processors.
Reference: [DWH + 90] <author> Alan Demers, Mark Weiser, Barry Hayes, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Fran-cisco, California, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: Generational non-copying collectors are slightly harder to construct, but they do exist and are quite practical <ref> [DWH + 90, WJ93] </ref>.) Finally, the temporal distribution of a simple tracing collector's work is also troublesome in an interactive programming environment; it can be very disruptive to a user's work to suddenly have the system become unresponsive and spend several seconds garbage collecting, as is common in such systems. <p> The choice of copying or marking collection is essentially orthogonal to the issue of generational collection, however <ref> [DWH + 90] </ref>.) 4.1 Multiple Subheaps with Varying Collection Frequencies Consider a generational garbage collector based on the semispace organization: memory is divided into areas that will hold objects of different approximate ages, or generations; each generation's memory is further divided into semispaces. <p> Virtual memory dirty bits or access-protection traps can be used to detect which pages are written to, so that they can be scanned at collection time to detect pointers into younger generations <ref> [DWH + 90] </ref>.) Conservative pointer finding imposes additional constraints on the garbage collector.
Reference: [ED93] <author> John R. Ellis and David L. Detlefs. </author> <title> Safe, efficient garbage collection for C++. </title> <type> Technical Report 102, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: Similarly, programming guidelines have been proposed to ensure that programmers in C++ avoid constructions that make correct garbage collection impossible <ref> [ED93] </ref>; by programming in a very slightly restricted subset of C++, it is possible to ensure that a cooperative compiler can support correct garbage collection. <p> In some languages, such as Modula-3 [CDG + 89] and an extended version of C++ <ref> [ED93] </ref>, a garbage collected heap coexists with an explicitly-managed heap. This supports garbage collection, while allowing programmers to explicitly control deallocation of some objects for maximum performance or predictability. Issues in the design of such multiple-heap systems are discussed in [Del92] and [ED93]. <p> + 89] and an extended version of C++ <ref> [ED93] </ref>, a garbage collected heap coexists with an explicitly-managed heap. This supports garbage collection, while allowing programmers to explicitly control deallocation of some objects for maximum performance or predictability. Issues in the design of such multiple-heap systems are discussed in [Del92] and [ED93]. In other systems, such as large persistent or distributed shared memories, it may also be desirable to have multiple heaps with different policies for distribution (e.g., shared vs. unshared), access privileges, and resource management [Mos89, Del92].
Reference: [Ede92] <author> Daniel Ross Edelson. </author> <title> Smart pointers: They're smart, but they're not pointers. </title> <booktitle> In USENIX C++ Conference [USE92], </booktitle> <pages> pages 1-19. </pages> <note> Technical Report UCSC-CRL-92-27, </note> <institution> University of California at Santa Cruz, Baskin Center for Computer Engineering and Information Sciences, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Unfortunately, these user-defined pointer types can't be used in exactly the same ways as built-in pointer types, for several reasons <ref> [Ede92] </ref>. One reason is that there is no way to define all of the automatic coercions that the compiler performs automatically for built-in types. Another problem is that not all operators can be overloaded in this way. <p> Still another limitation is that garbage collection is difficult to implement efficiently within the language, because it is impossible to tell the compiler how to compile for certain important special cases <ref> [Det92, Ede92] </ref> For example, in C++ or Ada, there is no way to specialize an operation for objects that are known at compile time not to be allocated in the heap. 49 49 In C++ terminology, operators can only be specialized on Recent work in reflective systems has explored languages with
Reference: [EV91] <author> Steven Engelstad and Jim Vandendorp. </author> <title> Automatic storage management for systems with real time constraints. In OOPSLA '91 Workshop on Garbage Collection in Object-Oriented Systems [OOP91]. </title> <note> Position paper. </note>
Reference-contexts: For fully general real-time garbage collection, with reasonable worst-case memory usage, it appears that fine-grained copying collection is required [Nil88]. As mentioned above, copying collection can be quite expensive in the worst case, even if Lisp-machine style hardware support is available to speed up the read barrier <ref> [EV91, Wit91] </ref>.
Reference: [FY69] <author> Robert R. Fenichel and Jerome C. </author> <note> Yochelson. </note>
Reference-contexts: The term scavenging is applied to the copying traversal, because it consists of picking out the worthwhile objects amid the garbage, and taking them away. 2.4.1 A Simple Copying Collector: "Stop and-Copy" Using Semispaces. A very common kind of copying garbage collector is the semispace collector <ref> [FY69] </ref> using the Cheney algorithm for the copying traversal [Che70]. We will use this collector as a reference model for much of this paper. 12 In this scheme, the space devoted to the heap is subdivided into two contiguous semispaces.
References-found: 61

