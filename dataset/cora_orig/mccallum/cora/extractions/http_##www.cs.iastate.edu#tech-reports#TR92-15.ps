URL: http://www.cs.iastate.edu/tech-reports/TR92-15.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Hardware-Assisted General-Purpose Garbage Collection for Hard Real-Time Systems  
Author: TR - Kelvin D. Nilsen and William J. Schmidt 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: Oct. 31, 1992  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> R. E. Griswold and M. T. Griswold, </author> <title> The Icon Programming Language, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: Slices are useful in implementing the built-in string and stream data types of languages like Icon <ref> [1] </ref> and Conicon [2, 3]. They might also be used to represent the catenation of multimedia audiovisual clips into complete audiovisual programs, and to implement shared code segments in a dynamic object-oriented programming environment. Once allocated, a slice object is considered to be read-only.
Reference: 2. <author> K. Nilsen, </author> <title> A Stream Data Type That Supports Goal-Directed Pattern Matching on Unbounded Sequences of Values, </title> <journal> J. Computer Lang. </journal> <volume> 1 5, </volume> <month> 1 (Jan </month> <year> 1990), </year> <pages> 41-54. </pages>
Reference-contexts: Slices are useful in implementing the built-in string and stream data types of languages like Icon [1] and Conicon <ref> [2, 3] </ref>. They might also be used to represent the catenation of multimedia audiovisual clips into complete audiovisual programs, and to implement shared code segments in a dynamic object-oriented programming environment. Once allocated, a slice object is considered to be read-only.
Reference: 3. <author> K. Nilsen, </author> <title> High-Level Goal-Directed Concurrent Processing in Icon, </title> <journal> SoftwarePractice & Experience 20, </journal> <month> 12 (Dec </month> <year> 1990), </year> <pages> 1273-1290. </pages>
Reference-contexts: Slices are useful in implementing the built-in string and stream data types of languages like Icon [1] and Conicon <ref> [2, 3] </ref>. They might also be used to represent the catenation of multimedia audiovisual clips into complete audiovisual programs, and to implement shared code segments in a dynamic object-oriented programming environment. Once allocated, a slice object is considered to be read-only.
Reference: 4. <author> H. G. Baker Jr., </author> <title> ``List Processing in Real Time on a Serial Computer'', </title> <journal> Comm. ACM 21, </journal> <month> 4 (Apr. </month> <year> 1978), </year> <pages> 280-293. </pages>
Reference-contexts: After allocating a slice object, the mutator initializes the descriptor tags of the referenced slice region by invoking the primitive operations described in 4. 3. The Algorithm The hardware-assisted garbage collection system implements a derivative of B aker's real-time garbage collection algorithm for lists <ref> [4] </ref>. The custom 2 This semantics is designed mainly to provide efficient support for machine register induction variables and derived pointers (including possibly the machine's instruction and stack pointers) to slice regions. <p> These two 7 In this section, italic K represents the value of the K register discussed in other sections of this paper. expressions can be combined to yield the following bound on total live memory: M K + 2 As has been discussed in other papers <ref> [4, 5] </ref>, selecting a large value for K improves storage utilization at the cost of slower allocation rates.
Reference: 5. <author> K. Nilsen, </author> <title> ``Garbage Collection of Strings and Linked Data Structures in Real Time'', </title> <journal> Soft-warePractice & Experience 18, </journal> <month> 7 (July </month> <year> 1988), </year> <pages> 613-640. </pages>
Reference-contexts: Every action taken by the garbage collector decrements ScanBalance by a small amount. Traditionally, every word relocated out of from-space must be both copied and scanned, and the ScanBalance costs of copying and scanning one word are each one <ref> [5] </ref>. In other words, ScanBalance is decremented by one each time a word is copied into to-space, and by one again when the word is scanned. Throughout this paper, a ScanBalance point represents a unit increment or decrement of the ScanBalance register. <p> These two 7 In this section, italic K represents the value of the K register discussed in other sections of this paper. expressions can be combined to yield the following bound on total live memory: M K + 2 As has been discussed in other papers <ref> [4, 5] </ref>, selecting a large value for K improves storage utilization at the cost of slower allocation rates.
Reference: 6. <author> K. Nilsen and W. J. Schmidt, </author> <title> Cost-Effective Object-Space Management for Hardware-Assisted Real-Time Garbage Collection, </title> <journal> ACM Letters on Pro g. Lang. and Systems, </journal> <note> submitted. </note>
Reference-contexts: References to memory between CopyDest and CopyEnd are redirected to the address computed by adding CopySrc to the difference between the requested memory address and CopyDest. Whenever references to memory between CopyEnd and Reser ved are recognized, a special hardware circuit called the Object Space Manager (OSM) <ref> [6] </ref> looks up the location of the uncopied object's header. For objects on the copy queue, the word following the title points to the object waiting to be copied out of from-space. <p> Other than memory, the Object Space Manager (OSM) <ref> [6] </ref> is the most costly of the components in the garbage-collected memory module. Under typical system configurations, one OSM chip is required for ev ery sixteen DRAM chips 4 , with the VLSI complexity of each OSM chip roughly equivalent to the complexity of the DRAM chips it accompanies. <p> The mprocessor oversees garbage collection by dividing 4 The ratio of one OSM chip to sixteen DRAM chips assumes that OSM chips are fabricated with roughly the same transistor density as DRAM chips, and that all objects are aligned on four-word boundaries <ref> [6] </ref>. the job into a large number of small straightforward activities and individually assigning each of these activities to the arbiter. The arbiter works on assignments from the mprocessor as a background activity, giving highest priority to servicing of BIU requests.
Reference: 7. <author> J. Hennessy and D. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Additional performance improvement is available if the CPU fetches multiple-word cache blocks, in which case the first three memory cycles described above are required only for the first word of the block 5 . Furthermore, traditional memory interleaving or special DRAM addressing modes <ref> [7] </ref> would allow the work associated with the fourth cycle to be reduced, and pipelined operation of the OSM would allow reduction of the work associated with the fifth 5 This assumes that all objects are aligned on cache-block boundaries. memory cycle. Clearly, there are many design alternatives to consider. <p> For each word initialized, ScanBalance is decremented by 2K/(K+ 2). Because of their sequential access patterns, many of the primitive operations described above would benefit greatly from traditional memory interleaving, or from more recent innovations such as nibble-mode and static-column DRAM configurations <ref> [7] </ref>. Note that the state registers described in 3 reside within the arbiter. This is required in order to service CPU requests with minimal delays. The microprocessor keeps a duplicate copy of Relocated which it updates following each copyBlock, copy-ScanBlock, and incRelocated requests. <p> Because of the high costs of fabricating hardware prototypes, all of the performance analysis and system tuning is currently done through software simulations. A software prototype of the hardware-assisted garbage-collected memory module has been integrated into the dlxsim generic RISC simulator described in reference <ref> [7] </ref>. dlxsim provides a detailed accounting of the total number of machine cycles stalled during execution of a program, along with itemized breakdowns of the reasons for stalls. dlxsim is distributed with dlxcc, a version of the GNU C compiler targeted to the dlx architecture.
Reference: 8. <author> K. Nilsen, </author> <title> Memory Cycle Accountings for Hardware-Assisted Real-Time Garbage Collection, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. 91-21, </type> <institution> Iowa State Univ., </institution> <year> 1991. </year>
Reference-contexts: The table below summarizes the worst-case time required to implement each of the -11 services provided to the mutator by the arbiter. A more detailed description of the work performed during each memory cycle is provided in reference <ref> [8] </ref>. The times are reported here in terms of memory cycles. Also of interest is an accounting in terms of higher-frequency machine cycles. However, the more detailed accounting depends on deciding between many difficult implementation tradeoffs that have not yet been fully explored.
Reference: 9. <author> J. R. Ellis, K. Li and A. W. Appel, </author> <title> ``Real-time Concurrent Collection on Stock Multiprocessors'', </title> <booktitle> ACM SIGPLAN Notices Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Empirical research findings presented by Ellis, Li, and Appel suggest that the need to wait for increments of garbage collection to complete prior to allocating new memory is very rare, even if the garbage collector is allocating memory for multiple processors on a shared bus <ref> [9, 10] </ref>. If the allocator determines that a ip is necessary, it returns the value 0 in response to the allocation request. Upon receipt of this special return code, the application tends all of its descriptors and then reissues the allocation request. <p> In contrast, Icon is traditionally garbage collected, and the data types supported by our general-purpose garbage collection system closely match Icon's implementation needs. These two language implementations represent different ends of the language spectrum that might be served by this hardware-assisted garbage collection system. System Performance In reference <ref> [9] </ref>, Ellis, Li, and Appel describe what is, in their words, ``the first copying garbage-collection algorithm that is efficient, real-time, concurrent, [and] runs on stock commercial uniprocessors and multiprocessors.'' Their system uses traditional virtual memory paging hardware to detect references to regions of to-space that require redirection or tending.
Reference: 10. <author> A. W. Appel, </author> <title> Allocation Without Locking, </title> <journal> Soft-warePractice & Experience 19, </journal> <month> 7 (July </month> <year> 1989), </year> <pages> 703-705. </pages>
Reference-contexts: Empirical research findings presented by Ellis, Li, and Appel suggest that the need to wait for increments of garbage collection to complete prior to allocating new memory is very rare, even if the garbage collector is allocating memory for multiple processors on a shared bus <ref> [9, 10] </ref>. If the allocator determines that a ip is necessary, it returns the value 0 in response to the allocation request. Upon receipt of this special return code, the application tends all of its descriptors and then reissues the allocation request. <p> Whether fairness is actually a problem depends on the number of processors attempting to allocate memory, and the workload of each. For best system throughput, kernel intervention and locking strategies associated with allocation should be avoided <ref> [10] </ref>. If typical workloads are such that process starvation is extremely rare, then simply allowing each process to repeatedly reissue denied allocation requests probably yields the best overall performance.
Reference: 11. <author> Motorola, MC88200: </author> <title> Cache/Memory Management Unit User's Manual, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: The third alternative combines the advantages of the first two, but some existing cache controllers <ref> [11] </ref> require more time to invalidate an address range than to invalidate the whole cache. Other cache controllers do not ev en support partial invalidation [12].
Reference: 12. <author> S. A. Przybylski, </author> <title> Cache and Memory Hierarchy Design: A Performance-Directed Approach, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The third alternative combines the advantages of the first two, but some existing cache controllers [11] require more time to invalidate an address range than to invalidate the whole cache. Other cache controllers do not ev en support partial invalidation <ref> [12] </ref>. To best evaluate the tradeoffs between these alternative mechanisms, it is necessary to better understand the frequency of ips and the duration of garbage collection within each ip. Some interesting analysis of the effects of context switching on cache performance in traditional architectures has already been published [13].
Reference: 13. <author> J. C. Mogul and A. Borg, </author> <title> The Effect of Context Switches on Cache Performance, </title> <booktitle> Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Santa Clara, CA, </address> <year> 1991, </year> <pages> 75-84. </pages>
Reference-contexts: To best evaluate the tradeoffs between these alternative mechanisms, it is necessary to better understand the frequency of ips and the duration of garbage collection within each ip. Some interesting analysis of the effects of context switching on cache performance in traditional architectures has already been published <ref> [13] </ref>. Though it is difficult to extrapolate the published results to this particular architecture without a more complete characterization of typical -15 workloads within this architecture's environment, it is clear from the published reports that completely invalidating the cache at each ip would measurably impact system performance.
Reference: 14. <author> K. B. Kenny and K. Lin, </author> <title> A measurement-based performance analyzer for real-time programs, </title> <institution> University of Illinois at Urbana-Champaign Report UIUCDCS-R-90-1606, </institution> <year> 1990. </year>
Reference-contexts: Alternatively, a statistical profile of the memory cycles required to earn each ScanBal-ance point might encourage more empirical or probabilistic characterizations of a system's real-time behavior, as described in reference <ref> [14] </ref>. Similar approaches are typically required whenever memory caches contribute to the performance of real-time systems [15, 16].
Reference: 15. <author> D. B. Kirk, </author> <title> Process Dependent Static Partitioning for Real-Time Systems, </title> <booktitle> Proceedings of the 1988 IEEE Real-Time Systems Symposium, </booktitle> <year> 1988, </year> <pages> 181-190. </pages>
Reference-contexts: Alternatively, a statistical profile of the memory cycles required to earn each ScanBal-ance point might encourage more empirical or probabilistic characterizations of a system's real-time behavior, as described in reference [14]. Similar approaches are typically required whenever memory caches contribute to the performance of real-time systems <ref> [15, 16] </ref>. In any case, if garbage collection is nearly always ahead of allocation or if K's value is very large, then there may not be any need to improve the precision of ScanBalance accounting.
Reference: 16. <author> C. Chi and P. Gopinath, </author> <title> Cache Design for Embedded Real-Time Systems, </title> <institution> Philips -23 Research Laboratories Tech. Rep.-89-042, </institution> <year> 1989. </year>
Reference-contexts: Alternatively, a statistical profile of the memory cycles required to earn each ScanBal-ance point might encourage more empirical or probabilistic characterizations of a system's real-time behavior, as described in reference [14]. Similar approaches are typically required whenever memory caches contribute to the performance of real-time systems <ref> [15, 16] </ref>. In any case, if garbage collection is nearly always ahead of allocation or if K's value is very large, then there may not be any need to improve the precision of ScanBalance accounting.
Reference: 17. <author> R. E. Griswold and M. T. Griswold, </author> <title> The Implementation of the Icon Programming Language, </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: Add arbiter primitives to force a ip either conditionally or unconditionally. The conditional ip would likely depend on how much additional memory can be allocated before the next ip is required, similar to predictive need requests used in the implementation of Icon <ref> [17] </ref>. Making the System More Robust The prototype implementation of the garbage collector makes no attempt to enforce compliance with the garbage collection protocol. For example, there is nothing to prevent the mutator from overwriting object headers, or from modifying the fields within a slice object.
Reference: 18. <author> J. S. Miller, Multischeme: </author> <title> A Parallel Processing System Based on MIT Scheme, MIT/LCS/Tech. Rep.-402, </title> <type> Ph.D. Thesis, </type> <year> 1987. </year>
Reference-contexts: For example, if a third redundant disk were to mirror to-space during garbage collection, the entire persistent memory data structure could be copied from this disk to tape as soon as garbage collection completes. Weak Pointers In reference <ref> [18] </ref>, James Miller describes the notion of weak pointers, which are characterized by the following: 1. If only weak pointers reference a heap-allocated object, the object is garbage. When the referenced object is garbage collected, each of the weak pointers to the object is overwritten with zero. 2. <p> applications for which weak pointers are very useful include support for symbolic debugging, automatic garbage collection of idle processes (processes whose results cannot possibly result in either direct or indirect I/O), automatic closing of files that that are no longer being used, and implementation of MIT Scheme's population data type <ref> [18] </ref>. Within the framework of the hardware-assisted garbage collection system described in this paper, support for weak pointers could be added as follows: 1. Create a new primitive data type called Weak-Pointer. Remember that each title describes both the type and the size of the object. <p> Additional primitives might be provided to allow the mutator to participate in the postpro-cessing of WeakPointer objects. For example, the garbage collector might interrupt the muta-tor each time it overwrites a weak pointer field with zero. Similar functionality is described in reference <ref> [18] </ref>. 7. Conclusions and Discussion Originally, the primary motivation for this research was to investigate the potential of using general-purpose garbage collection in applications with hard real-time constraints.
Reference: 19. <author> L. Cardelli, </author> <title> Compiling a Functional Language, </title> <booktitle> ACM Symposium on LISP and Functional Programming, </booktitle> <year> 1984, </year> <pages> 208-217. </pages>
Reference-contexts: Actually, since the workload used in profiling the system required more garbage collection than is typical of ML programs, they suggest that a single processor would likely be able to effectively support up to 10 concurrent processors under normal work-loads. These measurements were based on an ML <ref> [19] </ref> implementation running the Boyer benchmark [20] on a DEC Firey multiprocessor. The worst-case costs of our custom hardware garbage collector's primitive operations are much lower than the average costs of the Ellis-Li-Appel system.
Reference: 20. <author> R. Gabriel, </author> <title> Performance and Evaluation of Lisp Systems, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: These measurements were based on an ML [19] implementation running the Boyer benchmark <ref> [20] </ref> on a DEC Firey multiprocessor. The worst-case costs of our custom hardware garbage collector's primitive operations are much lower than the average costs of the Ellis-Li-Appel system.
Reference: 21. <author> A. W. Appel and K. Li, </author> <title> Virtual Memory Primitives for User Programs, </title> <booktitle> Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Santa Clara, CA, </address> <year> 1991, </year> <pages> 96-107. </pages>
Reference-contexts: The worst-case costs of our custom hardware garbage collector's primitive operations are much lower than the average costs of the Ellis-Li-Appel system. However, our algorithm incurs frequent, but fairly inexpensive, memory stalls during garbage collection in comparison to occasional expensive page faults in the Ellis-Li-Appel system <ref> [21] </ref>, Whether the benefits of hardwired circuitry and dedicated independent data paths to to- and from-space are sufficient to justify their hardware costs remains to be measured. Note that, besides improving garbage collection performance, our garbage collection arbiter offers the potential of greatly reducing bus traffic in a multiprocessor environment.
Reference: 22. <author> S. M. Stapleton, </author> <title> Real-time Garbage Collection for General-Purpose Languages, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. 90-13, </type> <institution> Master's T hesis, Iowa State Univ., </institution> <year> 1990. </year>
Reference-contexts: This simplified garbage collection system could add high-performance real-time garbage collection capabilities to typical mass-marketed personal computers and workstations for much lower complexity costs than are typical of multiprocessor cache-coherent bus protocols. 8. Acknowledgements Many of the ideas presented in this paper were first explored by Sue Mayer Stapleton <ref> [22] </ref> and Tajin-der Singh [23] as part of their Master's Degree Research at Iowa State University. S ingh designed and analyzed the circuitry for an early predecessor of the garbage collection arbiter.
Reference: 23. <author> T. P. Singh, </author> <title> Hardware Design of a Real-Time Copying Garbage Collection System, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. 90-21, </type> <institution> Master's T hesis, Iowa State Univ., </institution> <year> 1990. </year> <month> -24 </month>
Reference-contexts: Acknowledgements Many of the ideas presented in this paper were first explored by Sue Mayer Stapleton [22] and Tajin-der Singh <ref> [23] </ref> as part of their Master's Degree Research at Iowa State University. S ingh designed and analyzed the circuitry for an early predecessor of the garbage collection arbiter.
References-found: 23

