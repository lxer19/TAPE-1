URL: http://www.cs.washington.edu/research/lis/papers/postscript/chou-codes97.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/CB97a.html
Root-URL: http://www.cs.washington.edu
Abstract: Retargetability of embedded system descriptions not only enables better exploration of the design space and evaluation of cost/performance tradeoffs but also enhances design maintainability and adaptivity to new technologies. Unfortunately, the traditional boundary between runtime support and user-code encourages use of ad hoc architecturespecific features that lack the structure to permit automatic code synthesis for the satisfaction of timing constraints. This work proposes a specification style for control-dominated embedded systems that can be easily retargeted via automatic synthesis of the software architecture and run-time support. Unlike previous work, userspecified modes are an integral part of the runtime system and isolate architecturespecific details while scoping timing constraints to enable more efficient scheduling. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada95] <author> The Ada 9X Design Team, </author> <title> Ada 95 Rationale: The Language/The Standard Libraries, </title> <note> published by In-termetrics, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: Ada 95 Software Architecture Synthesis for Retargetable Real-Time Embedded Systems* Pai Chou and Gaetano Borriello Department of Computer Science and Engineering, Box 352350 University of Washington, Seattle, WA 98195-2350 USA -chou,gaetano-@cs.washington.edu * This work was supported by DARPA DAAH04-94-G-0272 host language such as C++ to express computation. Ada 95 <ref> [Ada95] </ref> provides a rich set of concurrent and real-time constructs so that it would serve well as both the host and the specification language. However, all of these languages rely on external run-time support for architecture specific facilities and for real-time. Many designers use real-time kernels for embedded designs.
Reference: [BG91] <author> G. Berry, G. Gonthier, </author> <title> The ESTEREL synchronous programming language: design, semantics, </title> <booktitle> implementation, Science of Computer Programming , Vol. </booktitle> <volume> 19, </volume> <pages> no.2, pp. 87-152. </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Retargetability is complicated by the fact that the behavior of many embedded systems, especially the reactive ones, can be quite complex and are intimately tied to architecturespecific elements and timing. Current solutions have not adequately addressed the retargetability of real-time reactive behaviors. To capture complex reactive behavior, Esterel <ref> [BG91] </ref> and StateCharts [HLN+] rely on synchronous semantics to enable composition of parallel processes or state machines. An important assumption is that the required work in each time step can be done fast enough that schedulability is not a concern.
Reference: [CB94] <author> P. Chou, G. Borriello, </author> <title> Software Scheduling in the CoSynthesis of Reactive Real-Time Systems, </title> <booktitle> in Proc. DAC, </booktitle> <month> June </month> <year> 1994. </year> <pages> pp. 1-4. </pages>
Reference-contexts: The event manager code is generated by customizing a template with the scheduling calls for the device drivers. The constraint graphs built during event manager synthesis are annotated with the execution times and input to the static scheduler <ref> [CB94] </ref>. The corresponding runtime engine is generated by linking the schedule tables with a small set of target specific primitives extracted from the library. 6 Example We have written several examples of reactive real-time systems in the proposed style.
Reference: [COB92] <author> P. Chou, R. Ortega, G. Borriello, </author> <booktitle> Synthesis of the Hardware/Software Interface in Microcontroller-Based Systems, in Proc. ICCAD , 1992, </booktitle> <pages> pp. 488-495. </pages>
Reference: [COB95] <author> P. Chou, R. Ortega, G. Borriello, </author> <title> Interface Co-Synthesis Techniques for Embedded Systems, </title> <booktitle> in Proc. </booktitle> <address> ICCAD, </address> <year> 1995. </year> <pages> pp. 280-287. </pages>
Reference: [CTGC] <author> M. Cornero, F. Thoen, G. Goossens, and F. Curatelli, </author> <title> Software Synthesis for Real-Time Information Processing Systems, </title> <editor> in P. Marwedel and G. Goossens (ed.), </editor> <title> Code Generation for Embedded Processors , Kluwer Academic Publishers, </title> <booktitle> 1995, </booktitle> <pages> pp. 260-296. </pages>
Reference-contexts: Schedulability can be enhanced by performing dependency analysis and apply code motion when the system is overcon-strained by code-based constraints [GH95]. Frame Scheduling handles more general types of constraints verifies that constraints can be met even in the presence of interrupts <ref> [CTGC] </ref>. Though not yet mature enough for real-time, Java represents a new approach to retargetability through its virtual machine and standardized runtime API. Java was originally invented for embedded applications, and it has several attractive features, including built-in support for multithreading, synchronization, limited timing control, and exception handling.
Reference: [CWB94] <author> P. Chou, E.A. Walkup, G. Borriello, </author> <title> Scheduling issues in the CoSynthesis of Reactive Real-Time Systems, </title> <booktitle> IEEE Micro, </booktitle> <month> August </month> <year> 1994. </year> <pages> pp. 37-47. </pages>
Reference-contexts: A specified separation between two events from the environment is not a constraint, but a promise, though it is possible to derive constraints such as polling rates from promises. Our model considers three types of timing constraints: sequencing, rate, and response time <ref> [CWB94] </ref>. Sequencing is between two different events generated by the system, rate is the separation between successive occurrences of an event, and response time is between an input and a system event. The modes scope the timing constraints.
Reference: [GF96] <author> D. Gaudreau, P. Freedman, </author> <title> Temporal Analysis and Object-Oriented Real-Time Software Development: a Case Study with ROOM/ObjectTime, </title> <booktitle> in Proc. 1996 IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1996. </year> <pages> pp. 110-118. </pages>
Reference-contexts: The semantics of the handlers is run-to-completion, that is, once a handler starts executing, it cannot be suspended and contextswitched out, though it may be preempted briefly for system interrupts. <ref> [GF96] </ref> We call a specification purely reactive if it is invoked only to respond to events, and each response can complete before the next event needs to be handled.
Reference: [GH95] <author> R. Gerber, S. Hong, </author> <title> Compiling Real-Time Program with Timing Constraint Refinement and Structural Code Motion, </title> <journal> IEEE Trans. on SW Engineering , vol.21, </journal> <volume> no.5, </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: To overcome the limitations of process-based scheduling, schedulers that focus on observable events have been proposed. Schedulability can be enhanced by performing dependency analysis and apply code motion when the system is overcon-strained by code-based constraints <ref> [GH95] </ref>. Frame Scheduling handles more general types of constraints verifies that constraints can be met even in the presence of interrupts [CTGC]. Though not yet mature enough for real-time, Java represents a new approach to retargetability through its virtual machine and standardized runtime API.
Reference: [HLN+] <author> D. Harel et al, STATEMATE: </author> <title> a working environment for the development of complex reactive systems, </title> <journal> IEEE Trans. on SW Engineering, vol.16, </journal> <volume> no.4, </volume> <pages> pp. 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Current solutions have not adequately addressed the retargetability of real-time reactive behaviors. To capture complex reactive behavior, Esterel [BG91] and StateCharts <ref> [HLN+] </ref> rely on synchronous semantics to enable composition of parallel processes or state machines. An important assumption is that the required work in each time step can be done fast enough that schedulability is not a concern.
Reference: [Nils96] <author> K. Nilsen, </author> <title> Issues in the Design and Implementation of Real-Time Java, document, </title> <journal> &lt;http://www.new-monics.com/webroot/technologies/java/RTJI.ps&gt;, </journal> <note> Revised July 19, </note> <year> 1996. </year>
Reference-contexts: This is because if context switching happens between computing the relative delay and the delay call, then the delay amount will be too long. Both JavaTime [You96] and Real-Time Java <ref> [Nils96] </ref> take the process-based approach to solving the delay problem. Jav-aTime requires periodic tasks to define rate constraints and supply a timeout handler. It is built on existing mechanisms and is platform independent. Real-Time Java proposes sporadic and spontaneous in addition to cyclic (periodic) tasks. It assumes platform-specific support.
Reference: [VLD96] <author> S. Vercauteren, B.Lin, H. De Man, </author> <title> A Strategy for Real-Time Kernel Support in ApplicationSpecific HW/SW Embedded Architectures, </title> <booktitle> in Proc. DAC , 1996. </booktitle>
Reference-contexts: If the designers want to exploit different ways of connecting to devices, then they must rewrite the drivers manually for each specific configuration. It is a tedious, error prone task, and can easily conflict with assumptions made by the kernel, such as preemption. Parameterized kernels <ref> [VLD96] </ref> attempt to enhance retar-getability by dividing the kernel into separate scheduling and communication layers. The communication layer abstracts the architecture specific I/O facilities. The drivers for standard protocols are written once per ISA and stored in the library.
Reference: [You96] <author> J. Young, JavaTime, &lt;http://www-cad.eecs.berke-ley.edu/~jimy/java/index.html&gt;, </author> <month> August </month> <year> 1996. </year>
Reference-contexts: This is because if context switching happens between computing the relative delay and the delay call, then the delay amount will be too long. Both JavaTime <ref> [You96] </ref> and Real-Time Java [Nils96] take the process-based approach to solving the delay problem. Jav-aTime requires periodic tasks to define rate constraints and supply a timeout handler. It is built on existing mechanisms and is platform independent. Real-Time Java proposes sporadic and spontaneous in addition to cyclic (periodic) tasks.
References-found: 13

