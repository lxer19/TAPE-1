URL: http://www.eecis.udel.edu/~graham/Papers/beyond_mp.ps.Z
Refering-URL: http://www.eecis.udel.edu/~graham/Papers/
Root-URL: http://www.cis.udel.edu
Title: Beyond Multiprocessing Multithreading the SunOS Kernel  
Author: J. R. Eykholt, S. R. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, D. Williams SunSoft, Inc. 
Abstract: Preparing the SunOS/SVR4 kernel for today's challenges: symmetric multiprocessing, multi-threaded applications, real-time, and multimedia, led to the incorporation of several innovative techniques. In particular, the kernel was re-structured around threads. Threads are used for most asynchronous processing, including interrupts. The resulting kernel is fully preemptible and capable of real-time response. The combination provides a robust base for highly concurrent, responsive operation. 
Abstract-found: 1
Intro-found: 1
Reference: [Bach 1986] <author> Maurice J. Bach, </author> <title> The Design of the UNIX Operating System, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: The restructured kernel uses a primitive spin lock protected by raised priority to implement this. This is one of a few bounded sections of code where interrupts are locked out. Traditional UNIX kernel implementations [Leffler 1989] <ref> [Bach 1986] </ref> also protect the dispatcher by locking out interrupts, usually all interrupts. The restructured kernel has a modifiable level (the ``thread level'') above which interrupts are no longer handled as threads and are treated more like non-portable ``firmware'' (e.g., simulating DMA via programmed I/O).
Reference: [Hamilton 1988] <author> Graham Hamilton and Daniel S. Conde, </author> <title> An Experimental Symmetric Multiprocessor Ultrix Kernel, </title> <booktitle> USENIX, Winter 1988, Summer '92 USENIX - June 8-June 12, </booktitle> <address> 1992 - San Antonio, TX 7 Multithreading the SunOS Kernel J.R. Eykholt, ... Dallas, Texas. </address>
Reference-contexts: This is essentially the approach used by sleep () in the traditional kernel. The turnstile approach is favored for more predictable real-time behavior, since they are never shared by other locks, as hashed sleep queues sometimes are. Interrupts as Threads Many implementations <ref> [Hamilton 1988] </ref> [Peacock 1992] have a variety of synchronization primitives that have similar semantics (e.g., mutual exclusion) yet explicitly sleep or spin for blocking.
Reference: [Kleiman 1992] <author> S. Kleiman, J. Voll, J. Eykholt, A. Shivalingiah, D. Williams, M. Smith, S. Barton, and G. Skinner, </author> <title> Symmetric Multiprocessing in Solaris 2.0, </title> <booktitle> COMPCON Spring 1992, </booktitle> <address> p181, San Francisco, California. </address>
Reference-contexts: The resulting SunOS 5.0 kernel, the central operating system component of Solaris 2.0, is fully preemptible, has real-time scheduling, symmetrically supports multiprocessors, and supports user-level multithreading. Several of the locking strategies used in this kernel were described in <ref> [Kleiman 1992] </ref>. In this paper we'll describe some of the implementation features that make this kernel unique. Overview of the Kernel Architecture A kernel thread is the fundamental entity that is scheduled and dispatched onto one of the CPUs of the system. <p> Every piece of shared data is protected by a synchronization object. Some aspects of locking in the virtual memory, file system, STREAMS, and device drivers have already been discussed in <ref> [Kleiman 1992] </ref>. Here we'll elaborate a bit on device driver issues, as they are closely related to interrupt threads. Non-MT Driver Support Some drivers haven't been modified to protect themselves against concurrency in a multithreaded environment. These drivers are called MT-unsafe, because they don't provide their own locking.
Reference: [Khanna 1992] <author> Sandeep Khanna, Michael Sebr ee, John Zolnowsky, </author> <title> Realtime Scheduling in SunOS 5.0, </title> <booktitle> USENIX, Winter 1992, </booktitle> <address> San Francisco, </address> <month> Cali-fornia. </month> <title> This describes the real-time features and considerations in this kernel. </title>
Reference-contexts: On multiprocessor systems, these threads of control must be capable of running concurrently on different processors. [Powell 1991] described the user visible thread architecture. We also wanted the kernel to be capable of bounded dispatch latency for real-time threads <ref> [Khanna 1992] </ref>. Real-time response requires absolute control over scheduling, requiring preemption at almost any point in the kernel, and elimination of unbounded priority inversions wherever possible. The kernel itself is a very complex multi-threaded program. <p> Kernel threads use synchronization primitives that support protocols for preventing priority inversion, so a thread's priority is determined by which activities it is impeding by holding locks as well as by the service it is performing <ref> [Khanna 1992] </ref>. SunOS uses kernel threads to provide asynchronous kernel activity, such as asynchronous writes to disk, servicing STREAMS queues, and callouts. This removes various diversions in the idle loop and trap code and replaces them with independently scheduled threads. <p> In addition, user code run by an underlying kernel thread of sufficient priority (e.g., real-time threads) will execute even though other lower priority kernel threads wait for execution resources. Further details can be found in <ref> [Khanna 1992] </ref>. System Threads System threads can be created for short or long-term activities. They are scheduled like any other thread, but usually belong to the system scheduling class. <p> Some of the synchronization primitives are strictly bracketing (e.g., the thread that locks a mutex must be the thread that unlocks it) and a single owner can be determined (i.e., mutexes and writer locks). In these cases, the synchronization primitives support the priority inheritance protocol, as described in <ref> [Khanna 1992] </ref>. Some synchronization primitives are intended for situations where they may block for long or indeterminate periods. Variants of some of the primitives are provided (e.g., cv_wait_sig () and sema_p_sig ()) that allow blocking to be interrupted by a reception of a signal. <p> Instead, two bytes in the synchronization object are used to find a turnstile structure containing the sleep queue header and priority inheritance information <ref> [Khanna 1992] </ref>. Turnstiles are preallocated such that there are always more turnstiles than the number of threads active. One alternative method would be to select the sleep queue from an array using a hash function on the address of the synchronization object. <p> We feel it helped during early implementation debugging, and probably reduced the amount of time spent debugging deadlocks. A similar tool is described in [Korty 1989]. Deadlock Detection A side-benefit of the priority inheritance mechanism <ref> [Khanna 1992] </ref>, is that deadlocks caused by hierarchy violations are usually detected at run time as well.
Reference: [Korty 1989] <author> Joe Korty, Sema: </author> <title> a Lint-Like Tool for Analyzing Semaphore Usage in a Multithreaded Unix Kernel, USENIX Winter 1989, San Diego, California. This describes a tool for doing static lock hierarchy analysis. </title>
Reference-contexts: This lint-like tool, called locknest, reads C source code, constructs call graphs and reports on locking cycles. We feel it helped during early implementation debugging, and probably reduced the amount of time spent debugging deadlocks. A similar tool is described in <ref> [Korty 1989] </ref>. Deadlock Detection A side-benefit of the priority inheritance mechanism [Khanna 1992], is that deadlocks caused by hierarchy violations are usually detected at run time as well.
Reference: [Leffler 1989] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, John S. Quarter-man, </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: The restructured kernel uses a primitive spin lock protected by raised priority to implement this. This is one of a few bounded sections of code where interrupts are locked out. Traditional UNIX kernel implementations <ref> [Leffler 1989] </ref> [Bach 1986] also protect the dispatcher by locking out interrupts, usually all interrupts. The restructured kernel has a modifiable level (the ``thread level'') above which interrupts are no longer handled as threads and are treated more like non-portable ``firmware'' (e.g., simulating DMA via programmed I/O).
Reference: [Barnett 1992] <author> David Barnett, </author> <title> Kernel Threads and their Performance Benefits, Real Time, </title> <journal> Vol. </journal> <volume> 4, No. 1, </volume> <booktitle> Lynx Real-Time Systems, </booktitle> <publisher> Inc., </publisher> <address> Los Gatos, CA., </address> <year> 1992. </year>
Reference-contexts: An alternative approach to this is to use bounded first-level interrupt handlers to capture device state and then wake up an interrupt thread that is waiting to do the remainder of the servicing <ref> [Barnett 1992] </ref>. This approach has the disadvantages of requiring device drivers to be restructured and of always requiring a full context switch to the second level thread. The approach used in SunOS 5.0 allows full thread behavior without restructured drivers and with very little additional cost in the no-contention case.
Reference: [Peacock 1992] <author> J. Kent Peacock, Sunil Saxena, Dean Thomas, Fred Yang and Wilfred Yu, </author> <title> Experiences from Multithreading System V Release 4, Symposium on Experiences with Distributed & Multiprocessor Systems (SEDMS) III, </title> <address> March 1992, Newport Beach, California. </address>
Reference-contexts: This is essentially the approach used by sleep () in the traditional kernel. The turnstile approach is favored for more predictable real-time behavior, since they are never shared by other locks, as hashed sleep queues sometimes are. Interrupts as Threads Many implementations [Hamilton 1988] <ref> [Peacock 1992] </ref> have a variety of synchronization primitives that have similar semantics (e.g., mutual exclusion) yet explicitly sleep or spin for blocking.
Reference: [Powell 1991] <author> M.L. Powell, S.R. Kleiman, S. Bar-ton, D. Shah, D. Stein, M. Weeks, </author> <title> SunOS Multi-thread Architecture, </title> <booktitle> USENIX Winter 1991, </booktitle> <address> Dallas, Texas. </address> <note> This describes the architecture for user-level multi-threading. </note>
Reference-contexts: These threads must be capable of executing system calls and handling page faults independently. On multiprocessor systems, these threads of control must be capable of running concurrently on different processors. <ref> [Powell 1991] </ref> described the user visible thread architecture. We also wanted the kernel to be capable of bounded dispatch latency for real-time threads [Khanna 1992]. Real-time response requires absolute control over scheduling, requiring preemption at almost any point in the kernel, and elimination of unbounded priority inversions wherever possible. <p> LWPs use it to allocate the LWP structure and kernel stack in a swappable region. Synchronization Architecture The kernel implements the same synchronization objects for internal use as are provided by the user-level libraries for use in multithreaded application programs <ref> [Powell 1991] </ref>. These are mutual exclusion locks (mutexes), condition variables, semaphores, and multiple readers, single writer (readers/writer) locks.

References-found: 9

