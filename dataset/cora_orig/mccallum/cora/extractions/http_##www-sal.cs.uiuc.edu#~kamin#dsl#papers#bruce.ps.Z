URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/papers/bruce.ps.Z
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/index.html
Root-URL: http://www.cs.uiuc.edu
Email: dib@dra.hmg.gb  
Title: What makes a good domain-specific language? apostle, and its approach to parallel discrete event simulation  
Author: David Bruce 
Keyword: Key words: programming languages, parallel discrete event simulation, program analysis and optimization.  
Address: St Andrews Road, Malvern, WORCS WR14 3PS, UK  
Affiliation: Defence Evaluation and Research Agency  
Abstract: General-purpose programming languages are a Good Thing, but domain-specific languages can be better. Such languages provide a natural vocabulary for concepts that are fundamental to the problem domain, whilst with general-purpose languages one is reduced to idiom: idiom, moreover, that is of its very nature alien to the host language | not to mention uncheckable. In addition, domain knowledge often inspires a range of optimizations that would not otherwise suggest themselves, let alone be practical. Domain-specific languages necessarily differ from general-purpose languages in their purpose, and therefore design, but we claim that the underlying principles can and should be the same. There need be no contradiction here: one is merely enriching the conceptual basis upon which the language is grown. The principled introduction of new concepts may have profound | and sometimes unanticipated! | consequences, however, so language designers (and implementors) must be prepared to follow these to their natural conclusion. We illustrate these ideas more concretely by reference to apostle, a language for (parallel) discrete event simulation. Here the new concepts are time and concurrency, but apostle's real power comes from the orthogonality of their introduction. The use of these and other features are easily checked in a precise yet general manner by means of an `effect' system, which also serves to determine the applicability of optimizations, both general-purpose and domain-specific. 
Abstract-found: 1
Intro-found: 1
Reference: [Andler 79] <author> Sten Andler, </author> <title> "Predicate Path Expressions: A High-Level Synchronization Mechanism", </title> <institution> Carnegie-Mellon University Department of Computer Science Ph.D. </institution> <type> thesis, </type> <note> August 1979; published as report CMU-CS-79-134. Much of this material also appears in the paper "Predicate Path Expressions", </note> <editor> pp. </editor> <booktitle> 226-236 in Proc. 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Antonio, Texas, </address> <month> 29-31 January </month> <year> 1979. </year>
Reference-contexts: To that end, apostle provides declarative concurrency control, in the form of predicate path expressions (PPEs), augmented with some ordering rules (ORs). PPEs <ref> [Andler 79] </ref> specify what kind of activities an object may participate in next. Of course, there may be several activities that are permitted (a PPE need not completely determine an object's behaviour), and in that case the ORs are used to further restrict those possibilities.
Reference: [Baker 92] <author> Henry G. Baker, </author> <title> "NREVERSAL of Fortune | The Thermodynamics of Garbage Collection", pp. </title> <booktitle> 507-524 in Proc. International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <note> 17-19 September 1992; proceedings published by Springer-Verlag as Lecture Notes in Computer Science, Vol. 637, </note> <editor> Y. Bekkers and J. </editor> <title> Cohen (editors). </title>
Reference-contexts: The difficulty with these methods comes in arranging that potentially erroneous computations can always be undone 4 . Whilst one could adopt an intrinsically reversible computational model, such as that of <ref> [Baker 92] </ref>, the more common approach is to save the state of an object from time to time (usually before processing each event). Then rollback reduces to restoring the saved object state and recursively rolling back any events generated by the erroneous events.
Reference: [Blanchard&Lake 95] <author> T. D. Blanchard and T. W. </author> <title> Lake, "Distributed Simulation with Locality", pp. </title> <booktitle> 195-198 in Proc. 9 th Workshop on Parallel and Distributed Simulation, </booktitle> <address> Lake Placid, New York, </address> <note> 14-16 June 1995; proceedings published as Simulation Digest, Vol. 25, No. 1, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: creation in conservative methods; essentially, the creator of an object must also take the new object's actions into account in its own lookahead. [Blanchard et al. 94] presented a method that (locally) accelerates time advance when the lookahead substantially underestimates inter-event intervals, and can therefore tolerate diminishing and zero lookahead. <ref> [Blanchard&Lake 95, private communication] </ref> have shown how lookahead can be (automatically) deduced in the MOSS language.
Reference: [Blanchard et al. 94] <author> T. D. Blanchard, T. W. Lake and S. J. Turner, </author> <title> "Cooperative Acceleration: robust conservative distributed discrete event simulation", pp. </title> <booktitle> 58-64 in Proc. 8 th Workshop on Parallel and Distributed Simulation, Edinburgh, Scotland, 6-8 July 1994; proceedings published as Simulation Digest, </booktitle> <volume> Vol. 24, No. 1, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: In the last few years, however, researchers have developed techniques that allow some of these restrictions to be relaxed. [Jha&Bagrodia 93] and others have addressed dynamic object creation in conservative methods; essentially, the creator of an object must also take the new object's actions into account in its own lookahead. <ref> [Blanchard et al. 94] </ref> presented a method that (locally) accelerates time advance when the lookahead substantially underestimates inter-event intervals, and can therefore tolerate diminishing and zero lookahead. [Blanchard&Lake 95, private communication] have shown how lookahead can be (automatically) deduced in the MOSS language.
Reference: [Booth&Bruce 97] <author> C. J. M. Booth and D. I. Bruce, </author> <title> "Stack-free process-oriented simulation", </title> <booktitle> submitted to 11 th Workshop on Parallel and Distributed Simulation, Burg Lockenhaus, </booktitle> <address> Austria, </address> <month> 10-13 June </month> <year> 1997. </year>
Reference-contexts: From this semantics and our experience with the prototype system, we now knew what the key issues were, and thus decided to implement apostle directly rather than in terms of an off-the-shelf simulator. This implementation process is still in progress, but we briefly mention our results to date <ref> [Booth&Bruce 97] </ref> and plans for future work. Our first step was to implement a sequential interpreter based directly upon the semantics. Denotational interpreters like this are relatively straightforward, even when written in C++ where one must mimic -functions and continuations using objects. <p> Moreover, by design the new system should be better suited to parallel execution | it has less mutable state, and in particular the context switching needed for the process interaction world view now incurs no PDES-related overheads. Indeed, <ref> [Booth&Bruce 97] </ref> show that a one-processor `almost-parallel' version is only 10% slower than a sequential version, which compares very favourably with the 50-60% slowdown exhibited by the old system.
Reference: [Bruce 95] <author> David Bruce, </author> <title> "The treatment of state in optimistic systems", pp. </title> <booktitle> 40-49 in Proc. 9 th Workshop on Parallel and Distributed Simulation, </booktitle> <address> Lake Placid, New York, </address> <note> 14-16 June 1995; proceedings published as Simulation Digest, Vol. 25, No. 1, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: Fortunately, several techniques for `automatic' support for (incremental) state saving have been developed in recent years; see, for example, <ref> [Bruce 95, West&Panesar 96] </ref>. <p> does not suffer any context switches, then there can be no opportunity to roll its thread back and it therefore need not be subject to state saving. (Depending on the scheduling policy, it may be safe to extend this to variables whose scopes that do not elapse time; i.e., events.) <ref> [Bruce 95] </ref> discusses these and other state saving optimizations in more detail. As for language definitions, the use of effects for detecting optimizations leads to increased generality. Here the general case is provided as the default, but the common special case is easily identified and implemented efficiently when it occurs.
Reference: [Buhr 95] <author> Peter A. Buhr, </author> <title> "Are Safe Concurrency Libraries Possible?" (technical correspondence), </title> <journal> pp. 117-120 in Communications of the ACM, </journal> <volume> Vol. 38, No. 2, </volume> <month> February </month> <year> 1995. </year> <title> [CACI 91] "MODSIM II Reference Manual", </title> <institution> CACI Products Company (La Jolla, California), </institution> <year> 1991. </year>
Reference-contexts: The objects can therefore, in principle at least, be managed concurrently, just as in any other concurrent object-oriented system. 1 Support for concurrency and access to the underlying parallel or distributed architecture are usually provided by means of libraries; as noted by <ref> [Buhr 95] </ref>, these are themselves subject to the kinds of problems discussed here. 2 Continuous simulation can be characterized as the (numerical) integration of (often coupled) differential equations, and is now widely used many scientific disciplines. Typically, the entire system is advanced in steps as the integration progresses.
Reference: [Chandy&Misra 79] <author> K. Mani Chandy and Jayadev Misra, </author> <title> "Distributed Simulation: A Case Study in Design and Verification of Distributed Programs", </title> <journal> pp. 440-452 in IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-5, No. 5, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: Techniques for determining this include sending additional null-messages indicating that no `real' event messages will be sent over a time interval <ref> [Chandy&Misra 79] </ref>, or periodically allowing the system to deadlock and then starting it up again [Chandy&Misra 81]. Most conservative protocols are variations on one of these basic approaches. Until recently, conservative methods such as these have imposed substantial restrictions on PDES applications.
Reference: [Chandy&Misra 81] <author> K. M. Chandy and J. Misra, </author> <title> "Asynchronous Distributed Simulation via a Sequence of Parallel Computations", </title> <journal> pp. 198-206 in Communications of the ACM, </journal> <volume> Vol. 24, No. 11, </volume> <month> April </month> <year> 1981. </year>
Reference-contexts: Techniques for determining this include sending additional null-messages indicating that no `real' event messages will be sent over a time interval [Chandy&Misra 79], or periodically allowing the system to deadlock and then starting it up again <ref> [Chandy&Misra 81] </ref>. Most conservative protocols are variations on one of these basic approaches. Until recently, conservative methods such as these have imposed substantial restrictions on PDES applications.
Reference: [Fujimoto 90] <author> Richard M. Fujimoto, </author> <title> "Parallel Discrete Event Simulation", </title> <journal> pp. 30-53 in Communications of the ACM, </journal> <volume> Vol. 33, No. 10, </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Parallel discrete event simulation (PDES) <ref> [Fujimoto 90, Fujimoto 93] </ref> presents a unique challenge. It is not difficult to find simulations requiring hours, if not days, to perform, and these applications often contain considerable amounts of parallelism. <p> Much progress has been made over the past two decades, with researchers developing a range of ingenious and sophisticated protocols for ensuring that events are processed in a causally consistent order <ref> [Fujimoto 90] </ref>. <p> A DES system's inherent distribution at least gives a little flexibility, in that it clearly suffices to process events in increasing time order for each object (rather than globally), but the basic problem remains. <ref> [Fujimoto 90, Fujimoto 93] </ref> survey PDES research more comprehensively than is possible or appropriate here.
Reference: [Fujimoto 93] <author> Richard M. Fujimoto, </author> <title> "Parallel Discrete Event Simulation: Will the Field Survive?", </title> <journal> pp. 213-230 in ORSA Journal on Computing, </journal> <volume> Vol. 5, No. 3, </volume> <month> Summer </month> <year> 1993. </year> <title> Five commentaries by leading researchers, followed by a final rejoinder by Fujimoto, </title> <note> appear in pp. 231-248 of the same issue. </note>
Reference-contexts: 1 Introduction Parallel discrete event simulation (PDES) <ref> [Fujimoto 90, Fujimoto 93] </ref> presents a unique challenge. It is not difficult to find simulations requiring hours, if not days, to perform, and these applications often contain considerable amounts of parallelism. <p> A DES system's inherent distribution at least gives a little flexibility, in that it clearly suffices to process events in increasing time order for each object (rather than globally), but the basic problem remains. <ref> [Fujimoto 90, Fujimoto 93] </ref> survey PDES research more comprehensively than is possible or appropriate here.
Reference: [Gafni 88] <author> Anat Gafni, </author> <title> "Rollback mechanisms for optimistic distributed simulation systems", pp. </title> <booktitle> 61-67 in Proc. Distributed Simulation 1988, </booktitle> <address> San Diego, California, </address> <month> 3-5 Feburary </month> <year> 1988. </year>
Reference-contexts: So it may be that the recomputed event will be unaffected by a given rollback, in which case there is no point in undoing its work. Alternatively, an event may need to be recomputed, but will still generate the same events. This motivates the introduction of lazy cancellation <ref> [Gafni 88] </ref>. Normally (in aggressive cancellation), when an event is rolled back then any events it scheduled are also rolled back. In lazy cancellation, these consequential events are not immediately rolled back.
Reference: [Gunter 94] <author> Michial A. Gunter, </author> <title> "Understanding Supercritical Speedup", pp. </title> <booktitle> 81-87 in Proc. 8 th Workshop on Parallel and Distributed Simulation, Edinburgh, Scotland, 6-8 July 1994; proceedings published as Simulation Digest, </booktitle> <volume> Vol. 24, No. 1, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: While it is unlikely that an entire simulation could run supercritically, overall performance can be enhanced even if small regions occasionally do. Where do effects come into this? <ref> [Gunter 94] </ref> identifies the source of supercritical speedup as resulting from intra-object concurrency manifesting itself as independence of event executions, and thus gives conditions under which lazy cancellation is to be preferred over aggressive cancellation (and vice versa).
Reference: [Hoare et al. 95] <author> Peter Hoare, I. J. Relf, C. J. M. Booth, M. J. Kirton and K. R. Milner, </author> <title> "The Application of High Performance Parallel Computing to Military Simulation", pp. </title> <booktitle> 115-119 in Proc. Military, Government and Aerospace Simulation Conference, </booktitle> <address> Phoenix, Arizona, </address> <month> 9-13 April </month> <year> 1995. </year>
Reference-contexts: In particular, we show how its support for the process interaction world view (rather than the `simpler' event scheduling world view) (both described in section 4.1) can simplify model construction and enhance modularity. Our example is based loosely on a detailed logistics model (e.g., <ref> [Hoare et al. 95] </ref>). We consider a typical component of such models: a truck, which simply carries goods from place to place. A.1 Preliminaries We assume that some type Place describes various places of interest, such as depots and waiting areas.
Reference: [Jefferson 85] <author> David R. Jefferson, </author> <title> "Virtual Time", </title> <journal> pp. 404-425 in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 3, </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: It remains to be seen whether these recent advances will lead to a resurgence of interest in conservative methods, or indeed whether they are of practical (as well as theoretical) interest. 3.2 Optimistic methods Optimistic methods, such as those of <ref> [Jefferson 85] </ref> and [Steinman 92], instead allow objects to process events that (locally) appear to occur next, without having to establish for certain that no earlier event exists | or could be generated | elsewhere in the system. <p> Implementations of three different synchronization protocols were available: the (sequential) event list algorithm outlined above, for comparison purposes; Time Warp <ref> [Jefferson 85] </ref>; and Breathing Time Buckets (BTB) [Steinman 92]. The BTB simulators ran on either an 8-processor Sun SparcServer 1000 shared memory machine or a 22-processor Meiko CS-2 distributed memory machine, and were one of our day-to-day research tools.
Reference: [Jefferson&Reiher 91] <author> David Jefferson and Peter Reiher, </author> <title> "Supercritical Speedup", pp. </title> <booktitle> 159-168 in Proc. 24 th Annual Simulation Symposium, </booktitle> <address> New Orleans, Louisiana, </address> <booktitle> 1-5 April 1991; proceedings published as Simulation Digest, </booktitle> <volume> Vol. 21, No. 3, </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: Moreover, lazy cancellation actually enables supercritical speedup <ref> [Jefferson&Reiher 91] </ref>! Because some work could be started as the result of some lucky optimistic computation that was done before it was known to be correct, this can in fact occur earlier even than if the simulation were run `ideally' (but not optimistically) on an infinite number of processors, as that
Reference: [Jha&Bagrodia 93] <author> Vikas Jha and Rajive L. Bagrodia, </author> <title> "Transparent Implementation of Conservative Algorithms in Parallel Simulation Languages", pp. </title> <booktitle> 677-686 in Proc. 1993 Winter Simulation Conference, </booktitle> <address> Los Angeles, California, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: It also provides useful information for improving simulation performance, but is model-specific and often difficult to identify, hindering model development. In the last few years, however, researchers have developed techniques that allow some of these restrictions to be relaxed. <ref> [Jha&Bagrodia 93] </ref> and others have addressed dynamic object creation in conservative methods; essentially, the creator of an object must also take the new object's actions into account in its own lookahead. [Blanchard et al. 94] presented a method that (locally) accelerates time advance when the lookahead substantially underestimates inter-event intervals, and
Reference: [Jouvelot&Gifford 89] <author> Pierre Jouvelot and David K. Gifford, </author> <title> "Reasoning about Continuations with Control Effects", pp. </title> <booktitle> 218-226 in Proc. ACM SIGPLAN Conference on Programming Language, Design and Implementation, Portland, Oregon, 21-23 June 1989; proceedings published as ACM SIGPLAN Notices, </booktitle> <volume> Vol. 24, No. 7, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: programmers can statically constrain the effect of an expression, they can effectively specify which variables they intend to use in a manner that is appropriate for stack allocation, and have their actual use checked against that. 9.2.2 Ditto, for control state Exactly the same can be done for control state <ref> [Jouvelot&Gifford 89] </ref>.
Reference: [Lieberman 86] <author> Henry Lieberman, </author> <title> "Using Prototypical Objects to Implement Shared Behaviour in Object-Oriented Systems", pp. </title> <booktitle> 214-223 in Proc. 1 st Conference on Object-Oriented Programming: Systems, Languages, and Applications, Portland, Oregon, 29 September-2 October 1986; proceedings published as ACM SIGPLAN Notices, </booktitle> <volume> Vol. 21, No. 11, </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: By including such expressions in methods, `generators' can be defined that offer much of the functionality of classes but more flexibility | for example, `virtual constructors' are easily implemented. The absence of classes does not mean that there is no inheritance; delegation based inheritance <ref> [Lieberman 86] </ref> is used instead.
Reference: [Liskov&Shrira 88] <author> Barbara Liskov and Liuba Shrira, </author> <title> "Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems", pp. </title> <booktitle> 260-267 in Proc. SIGPLAN'88 Conference on Programming Language Design and Implementation, Atlanta, Georgia, 22-24 June 1988; proceedings published as ACM SIGPLAN Notices, </booktitle> <volume> Vol. 23, No. 7, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: simulation language, not least because in the system being simulated many things are likely to be happening at the same time. `Threads' were mentioned above, so where do they come from? The "async E" construct creates a new thread to run the expression E asynchronously and immediately returns a promise <ref> [Liskov&Shrira 88] </ref>.
Reference: [Lucassen 87] <author> John M. Lucassen, </author> <title> "Types and Effects: Towards the Integration of Functional and Imperative Programming", </title> <institution> Massachusetts Institute of Technology Laboratory for Computer Science Ph.D. </institution> <type> thesis, </type> <note> August 1987; published as report MIT/LCS/TR-408. </note>
Reference-contexts: Not only does this prevent a range of common programming mistakes, but the need for run-time checking is removed leading potentially to better performance. However, apostle's static checking goes further, in that each expression is also annotated with effect information. Effects <ref> [Lucassen 87] </ref> are an approximation of the expression's dynamic behaviour; examples include the access or modification of a reference cell, and the passage of simulation time. <p> The restriction in the previous paragraph was essentially of this form. Programmers are entirely used to this kind of restriction. Effects <ref> [Lucassen 87, Lucassen&Gifford 88] </ref> serve a similar role, but describe the properties of computations themselves rather than those of the values they compute 12 . So the restrictions here are of the form "any computation you like, as long as its behaviour is of the right form". <p> Not only that, effects often allow the restriction to be less severe than it might be if imposed in some other way. We consider a number of examples, both general-purpose and domain-specific. 11 Though too many people understand it in too many different ways! 12 Like <ref> [Lucassen 87, Lucassen&Gifford 88] </ref>, we use a collecting model/interpretation of effects. This is in contrast to [Nielson&Nielson 93], whose behaviours are modelled as a process algebra so that the order matters. 8.1 Absence of effects It is sometimes important to know that an expression does not have a certain effect. <p> For example, a local variable may be declared, updated each time around a loop, and its final contents returned as the expression's value. In certain cases <ref> [Lucassen 87, Lucassen&Gifford 88] </ref>, it is safe to mask such effects | that is, to erase them from the expression's effect | reflecting their lack of impact on the rest of the system. <p> to check the correctness of the handler itself. 9 Optimizations The same framework of type and effects can be applied equally effectively to help determine the applicability of optimizations, both general-purpose and domain-specific. 9.1 Mutual independence of expressions One of the more basic effect-based analyses concerns the independence of expressions. <ref> [Lucassen 87, Lucassen&Gifford 88] </ref> showed how to determine whether the effects of two expressions interfere in the sense that their relative evaluation order mattered. Essentially, if one Writes where the other Reads, then they could interfere, whilst if each Reads but neither Writes they cannot interfere. <p> Many languages therefore distinguish between the two, allowing heap allocated `pointers' to be returned from scopes (including function invocations) but not stack allocated `variables'. This is an example of a structural | or at best type-based | restriction. Using effects we can be more precise. <ref> [Lucassen 87] </ref> shows that the conditions under which effects can be masked (x8.1.1) are sufficient to allow safe stack allocation.
Reference: [Lucassen&Gifford 88] <author> John M. Lucassen and David K. Gifford, </author> <title> "Polymorphic Effect Systems", pp. </title> <booktitle> 47-57 in Proc. 15 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: The restriction in the previous paragraph was essentially of this form. Programmers are entirely used to this kind of restriction. Effects <ref> [Lucassen 87, Lucassen&Gifford 88] </ref> serve a similar role, but describe the properties of computations themselves rather than those of the values they compute 12 . So the restrictions here are of the form "any computation you like, as long as its behaviour is of the right form". <p> Not only that, effects often allow the restriction to be less severe than it might be if imposed in some other way. We consider a number of examples, both general-purpose and domain-specific. 11 Though too many people understand it in too many different ways! 12 Like <ref> [Lucassen 87, Lucassen&Gifford 88] </ref>, we use a collecting model/interpretation of effects. This is in contrast to [Nielson&Nielson 93], whose behaviours are modelled as a process algebra so that the order matters. 8.1 Absence of effects It is sometimes important to know that an expression does not have a certain effect. <p> For example, a local variable may be declared, updated each time around a loop, and its final contents returned as the expression's value. In certain cases <ref> [Lucassen 87, Lucassen&Gifford 88] </ref>, it is safe to mask such effects | that is, to erase them from the expression's effect | reflecting their lack of impact on the rest of the system. <p> to check the correctness of the handler itself. 9 Optimizations The same framework of type and effects can be applied equally effectively to help determine the applicability of optimizations, both general-purpose and domain-specific. 9.1 Mutual independence of expressions One of the more basic effect-based analyses concerns the independence of expressions. <ref> [Lucassen 87, Lucassen&Gifford 88] </ref> showed how to determine whether the effects of two expressions interfere in the sense that their relative evaluation order mattered. Essentially, if one Writes where the other Reads, then they could interfere, whilst if each Reads but neither Writes they cannot interfere.
Reference: [Misra 86] <author> Jayadev Misra, </author> <title> "Distributed Discrete-Event Simulation", </title> <journal> pp. 39-65 in ACM Computing Surveys, </journal> <volume> Vol. 18, No. 1, </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: In summary, though, there are two basic approaches to parallelizing DES, differing in how objects cope with not knowing what events they may receive in the future. 3.1 Conservative methods Conservative methods <ref> [Misra 86, Nicol 96] </ref> wait if necessary until they can be sure which event must be processed next.
Reference: [Nance 93] <author> Richard E. Nance, </author> <title> "A History of Discrete Event Simulation Programming Languages", </title> <booktitle> in 2 nd ACM SIGPLAN History of Programming Languages Conference, </booktitle> <address> Cambridge, Mas-sachusetts, </address> <month> 20-23 April </month> <year> 1993: </year> <pages> pp. </pages> <booktitle> 149-175 in preprints, published as ACM SIGPLAN Notices, </booktitle> <volume> Vol. 28, No. 3, </volume> <editor> March 1993; proceedings also published as Thomas Bergin and Richard Gibson (editors), </editor> <booktitle> "History of Programming Languages II", </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: However, it was soon realized that a dedicated language for simulation could provide better modelling support than could general-purpose languages <ref> [Nance 93] </ref>. <p> However, for larger or more complex simulations, or when a process interaction world view is required, simulation-oriented languages provide the solution of choice. There have been a vast array of simulation languages (see <ref> [Nance 93] </ref> for a historical survey) but several stand out. GPSS is perhaps the oldest and still widely used, whilst Simula is famous for introducing object-oriented ideas and support for concurrency.
Reference: [Nicol 96] <author> David M. Nicol, </author> <title> "Principles of Conservative Parallel Simulation", pp. </title> <booktitle> 128-135 in Proc. 1996 Winter Simulation Conference, </booktitle> <address> Coronado, California, </address> <month> 8-11 December </month> <year> 1996. </year>
Reference-contexts: In summary, though, there are two basic approaches to parallelizing DES, differing in how objects cope with not knowing what events they may receive in the future. 3.1 Conservative methods Conservative methods <ref> [Misra 86, Nicol 96] </ref> wait if necessary until they can be sure which event must be processed next. <p> As a consequence, dynamic creation of objects is rarely permitted. In fact, this is merely a special case of the complexities of lookahead. Lookahead <ref> [Nicol 96] </ref> is essentially a guarantee about the (lack of) future behaviour of an object, and is required for correctness by most conservative protocols. It also provides useful information for improving simulation performance, but is model-specific and often difficult to identify, hindering model development.
Reference: [Nielson&Nielson 93] <author> Flemming Nielson and Hanne Riis Nielson, </author> <title> "From CML to Process Algebras", pp. </title> <booktitle> 493-508 in Proc. 4 th International Conference on Concurrency Theory, </booktitle> <address> Hildesheim, Ger-many, </address> <note> 23-26 August 1993; proceedings published by Springer-Verlag as Lecture Notes in Computer Science, Vol. 715, </note> <author> E. </author> <title> Best (editor). </title>
Reference-contexts: We consider a number of examples, both general-purpose and domain-specific. 11 Though too many people understand it in too many different ways! 12 Like [Lucassen 87, Lucassen&Gifford 88], we use a collecting model/interpretation of effects. This is in contrast to <ref> [Nielson&Nielson 93] </ref>, whose behaviours are modelled as a process algebra so that the order matters. 8.1 Absence of effects It is sometimes important to know that an expression does not have a certain effect.
Reference: [Reed 83] <author> David P. Reed, </author> <title> "Implementing Atomic Actions on Decentralized Data", </title> <journal> pp. 3-23 in ACM Transactions on Computer Systems, </journal> <volume> Vol. 1, No. 1, </volume> <month> February </month> <year> 1983. </year>
Reference: [Rich&Michelsen 91] <author> David O. Rich and Randy E. Michelsen, </author> <title> "An Assessment of the Mod-Sim/TWOS Parallel Simulation Environment", pp. </title> <booktitle> 509-518 in Proc. 1991 Winter Simulation Conference, </booktitle> <address> Pheonix, Arizona, </address> <month> 8-11 December </month> <year> 1991. </year>
Reference-contexts: For example, that one is prohibited from multiplying a record by a function is usually considered a good thing, rather than a breach of computational liberties. Moreover, as we shall show, this kind of semantic restriction can be applied much more precisely than can those based on syntax. 10 <ref> [Rich&Michelsen 91] </ref> similarly reported a number of "mismatches" when implementing a PDES language (in their case, ModSim) on top of an existing parallel simulator. In apostle, the few restrictions that we do find necessary are mostly expressed using its type and effect system.
Reference: [Steinman 92] <author> Jeff S. Steinman, "SPEEDES: </author> <title> A Multiple-Synchronization Environment for Parallel Discrete-Event Simulation", </title> <journal> pp. 251-286 in International Journal of Computer Simulation, </journal> <volume> Vol. 2, No. 3, </volume> <year> 1992. </year>
Reference-contexts: It remains to be seen whether these recent advances will lead to a resurgence of interest in conservative methods, or indeed whether they are of practical (as well as theoretical) interest. 3.2 Optimistic methods Optimistic methods, such as those of [Jefferson 85] and <ref> [Steinman 92] </ref>, instead allow objects to process events that (locally) appear to occur next, without having to establish for certain that no earlier event exists | or could be generated | elsewhere in the system. <p> Implementations of three different synchronization protocols were available: the (sequential) event list algorithm outlined above, for comparison purposes; Time Warp [Jefferson 85]; and Breathing Time Buckets (BTB) <ref> [Steinman 92] </ref>. The BTB simulators ran on either an 8-processor Sun SparcServer 1000 shared memory machine or a 22-processor Meiko CS-2 distributed memory machine, and were one of our day-to-day research tools.
Reference: [West&Panesar 96] <author> Darrin West and Kiran Panesar, </author> <title> "Automatic Incremental State Saving", pp. </title> <booktitle> 78-85 in Proc. 10 th Workshop on Parallel and Distributed Simulation, </booktitle> <address> Philadelphia, Pennsylva-nia, </address> <month> 22-24 May </month> <year> 1996. </year>
Reference-contexts: Fortunately, several techniques for `automatic' support for (incremental) state saving have been developed in recent years; see, for example, <ref> [Bruce 95, West&Panesar 96] </ref>.

References-found: 30

