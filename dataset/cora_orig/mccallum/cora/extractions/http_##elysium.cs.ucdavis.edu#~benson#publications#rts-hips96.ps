URL: http://elysium.cs.ucdavis.edu/~benson/publications/rts-hips96.ps
Refering-URL: http://elysium.cs.ucdavis.edu/~benson/publications/publications.html
Root-URL: http://www.cs.ucdavis.edu
Email: fbenson,olsson,pandeyg@cs.ucdavis.edu  
Title: On the Decomposition of Run-Time Support for Concurrent Programming Languages  
Author: Gregory D. Benson Ronald A. Olsson Raju Pandey tel:()- fax:()- 
Address: Davis, CA 95616  
Affiliation: Department of Computer Science University of California  
Abstract: Run-time support (RTS) is critical to the efficient and proper execution of programs written in languages that have high-level mechanisms for concurrency. Unfortunately, the design and development of an RTS system is largely an ad hoc process that leads to tightly coupled, monolithic implementations that depend on a single low-level interface or API. This results in RTS systems that cannot easily be adapted to changes in either the language semantics or the underlying low-level interface. Unlike other parts of a language implementation, such as parsing and code generation, there are no practical tools or techniques to aid in the generation of RTS systems. In this paper, we propose a new way, based on decomposition, to structure RTS systems for concurrent programming languages. We briefly examine the RTS structure and implementation for the SR concurrent programming language. Based on this analysis and our experience with porting the SR RTS to the Mach microkernel, we propose a new framework for RTS construction. Although the motivation for decomposition is based on our experience with SR's RTS, run-time support for other languages including those that provide distributed shared memory (DSM) can also be decomposed and will benefit in similar ways. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta et al. </author> <title> A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Our work is motivated by our experience in porting the RTS for the SR concurrent programming language [3, 2] to run on the Mach microkernel <ref> [1] </ref>. By developing a Mach-based RTS for SR we have identified several shortcomings of how RTS systems are designed and built. <p> The remainder of this paper uses the RTS for the SR concurrent programming language [3, 2] as a motivating example. Section 3 describes the SR language and the standard RTS implementation, as well as a new implementation of the RTS that runs on the Mach microkernel <ref> [1] </ref>. Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 [25], Ada95 [4], and Java [31]. 3 3.
Reference: [2] <author> G. R. Andrews and R. A. Olsson. </author> <title> The SR Programming Language: Concurrency in Practice. </title> <publisher> The Benjamin/Cummings Publishing Co., </publisher> <address> Redwood City, California, </address> <year> 1993. </year>
Reference-contexts: While it may not be possible to attain the same level of portability as the virtual machine approach, our approach attempts to maximize RTS component reuse. Our work is motivated by our experience in porting the RTS for the SR concurrent programming language <ref> [3, 2] </ref> to run on the Mach microkernel [1]. By developing a Mach-based RTS for SR we have identified several shortcomings of how RTS systems are designed and built. <p> The fixed nature of standard interfaces or virtual machines does not accommodate the evolutionary and possibly radical changes in operating system architectures. Furthermore, this approach does not accommodate change at the language level. The remainder of this paper uses the RTS for the SR concurrent programming language <ref> [3, 2] </ref> as a motivating example. Section 3 describes the SR language and the standard RTS implementation, as well as a new implementation of the RTS that runs on the Mach microkernel [1]. <p> Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 [25], Ada95 [4], and Java [31]. 3 3. Example: The SR RTS SR <ref> [3, 2] </ref> is a concurrent programming language that provides mechanisms for specifying parallelism, communication, and synchronization. The SR RTS provides semantic and library support. Semantic support is required for SR's more complex mechanisms and abstractions, including processes (threads), operations (communication ports), resources (dynamic modules), and virtual machines (address spaces).
Reference: [3] <author> G. R. Andrews, R. A. Olsson, M. Coffin, I. Elshoff, K. Nilsen, T. Purdin, and G. Townsend. </author> <title> An overview of the SR language and implementation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1):5186, </volume> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: While it may not be possible to attain the same level of portability as the virtual machine approach, our approach attempts to maximize RTS component reuse. Our work is motivated by our experience in porting the RTS for the SR concurrent programming language <ref> [3, 2] </ref> to run on the Mach microkernel [1]. By developing a Mach-based RTS for SR we have identified several shortcomings of how RTS systems are designed and built. <p> The fixed nature of standard interfaces or virtual machines does not accommodate the evolutionary and possibly radical changes in operating system architectures. Furthermore, this approach does not accommodate change at the language level. The remainder of this paper uses the RTS for the SR concurrent programming language <ref> [3, 2] </ref> as a motivating example. Section 3 describes the SR language and the standard RTS implementation, as well as a new implementation of the RTS that runs on the Mach microkernel [1]. <p> Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 [25], Ada95 [4], and Java [31]. 3 3. Example: The SR RTS SR <ref> [3, 2] </ref> is a concurrent programming language that provides mechanisms for specifying parallelism, communication, and synchronization. The SR RTS provides semantic and library support. Semantic support is required for SR's more complex mechanisms and abstractions, including processes (threads), operations (communication ports), resources (dynamic modules), and virtual machines (address spaces).
Reference: [4] <author> J. Barnes. </author> <title> Programming in Ada 95. </title> <publisher> Addison-Wesley, </publisher> <address> Wok-ingham, England, </address> <year> 1996. </year>
Reference-contexts: Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 [25], Ada95 <ref> [4] </ref>, and Java [31]. 3 3. Example: The SR RTS SR [3, 2] is a concurrent programming language that provides mechanisms for specifying parallelism, communication, and synchronization. The SR RTS provides semantic and library support.
Reference: [5] <author> G. Benson and R. Olsson. </author> <title> The Design of Microkernel Support for the SR Concurrent Programming Language, chapter 17, pages 227240. Languages, Compilers, and Run-Time Systems for Scalable Computers. </title> <publisher> Kluwer Academic Publishing, </publisher> <address> Boston, MA, </address> <year> 1996. </year> <editor> B. K. Szymanski and B. </editor> <title> Sinharoy (editors). </title>
Reference-contexts: In addition, the SR RTS employs the standard C library to implement many library functions. The dependency on the UNIX process model, the C libraries, and sockets make the current SR implementation highly dependent on the standard UNIX interfaces. 3.1. SRMach In a project called SRMach <ref> [6, 5] </ref>, we are investigating the various issues involved in supporting SR on the Mach4 microkernel from the University of Utah [11]. The original SR RTS implements facilities such as threads, communication, and synchronization. However, these facilities are tightly integrated.
Reference: [6] <author> G. D. Benson. </author> <title> Microkernel support for distributed programming languages: Issues in design and implementation. </title> <type> Technical Report CSE-95-3, </type> <institution> University of California, Davis, Department of Computer Science, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: In addition, the SR RTS employs the standard C library to implement many library functions. The dependency on the UNIX process model, the C libraries, and sockets make the current SR implementation highly dependent on the standard UNIX interfaces. 3.1. SRMach In a project called SRMach <ref> [6, 5] </ref>, we are investigating the various issues involved in supporting SR on the Mach4 microkernel from the University of Utah [11]. The original SR RTS implements facilities such as threads, communication, and synchronization. However, these facilities are tightly integrated.
Reference: [7] <author> B. N. Bershad et al. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating System Principles, </booktitle> <month> Decem-ber </month> <year> 1995. </year>
Reference-contexts: A trend in operating system research indicates that operating systems are becoming more flexible and extensible. For example, both SPIN <ref> [7] </ref> and the Exokernel [13] support application extensions to the kernel, allowing applications to have tight control over resource usage. Extensible operating systems pose many interesting opportunities to the implementation of concurrent programming languages. By employing kernel extensions, an RTS can directly define mechanisms such as synchronization and communication. <p> If possible, the RTS should not re-implement 2 functionality that is already provided by the operating sys-tem. Unfortunately, it is rare that operating systems interfaces are well matched to the needs of an RTS [29, 30]. Application adaptable kernels <ref> [7, 13, 11] </ref> will help improve this situation by allowing RTS systems to extend the kernel to better support language semantics and to maximize end-to-end performance between RTS systems executing on different machines. In general, concurrent programming languages require support for three basic mechanisms: threads, synchronization, and communication.
Reference: [8] <author> R. Bhoedjang et al. Panda: </author> <title> A portable platform to support parallel programming languages. </title> <booktitle> In Symposium on Experience with Distributed and Multiprocessor Systems IV, </booktitle> <pages> pages 213226, </pages> <address> San Diego, California, </address> <month> September </month> <year> 1993. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: An RTS virtual machine is simply a layer between the generated code and the kernel primitives. Both of these approaches assume that standard interfaces or virtual machine can be implemented efficiently using kernel abstractions. The Panda system <ref> [8] </ref> is a portable platform for supporting parallel programming languages. The platform consists of two layers: the system layer and the Panda layer. The system layer interfaces with the operating system kernel primitives; this level is kernel dependent. The Panda layer provides a virtual machine for supporting run-time support systems.
Reference: [9] <author> D. Cann. </author> <title> The optimizing SISAL compiler: Version 12.0. </title> <type> Technical Report UCRL-JC-110080, </type> <institution> Lawrence Livermore National Laboratory, </institution> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Based on a decomposed SR RTS, we can further research the concept of component replacement, both static and dynamic. To further develop our ideas, we intended to investigate the run-time support for other concurrent programming languages such as C-YESC++ [26, 27] and Sisal <ref> [24, 9] </ref>. A future goal is to provide a library of components that can be used by many different concurrent programming languages. To facilitate component design and development, 7 we are also investigating the possibility of an RTS work-bench. 8.
Reference: [10] <institution> DEC Systems Research Center. </institution> <note> SRC Modula-3, 1995. http://www.research.digital.com/SRC/ modula-3/html/home.html. </note>
Reference-contexts: In addition, these language implementations are examples of the virtual machine approach described in Section 2.5. Our descriptions are not intended to be complete; they only point out the aspects of each RTS that are most relevant to this paper. 4.1. Modula-3 In the DEC SRC implementation <ref> [10] </ref> of Modula-3 [25], the RTS handles garbage collection, exceptions, and threads. The SRC Modula-3 compiler generates native machine code using the GCC backend. Most of the Modula-3 RTS is written in Modula-3, except for certain low-level interfaces such as threads and input/output.
Reference: [11] <institution> Department of Computer Science, University of Utah. The Flux Operating System Project, </institution> <year> 1995. </year> <note> http://www.cs.utah.edu/projects/flux/. </note>
Reference-contexts: If possible, the RTS should not re-implement 2 functionality that is already provided by the operating sys-tem. Unfortunately, it is rare that operating systems interfaces are well matched to the needs of an RTS [29, 30]. Application adaptable kernels <ref> [7, 13, 11] </ref> will help improve this situation by allowing RTS systems to extend the kernel to better support language semantics and to maximize end-to-end performance between RTS systems executing on different machines. In general, concurrent programming languages require support for three basic mechanisms: threads, synchronization, and communication. <p> SRMach In a project called SRMach [6, 5], we are investigating the various issues involved in supporting SR on the Mach4 microkernel from the University of Utah <ref> [11] </ref>. The original SR RTS implements facilities such as threads, communication, and synchronization. However, these facilities are tightly integrated. To effectively utilize the Mach primitives, we are decoupling these components so that we can re-implement them in terms of the Mach abstractions.
Reference: [12] <author> R. P. Draves et al. </author> <title> MIG the mach interface generator. </title> <type> Unpublished Manuscript, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsurgh, PA, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: SR calls to procs can be implemented in the same way with the help of MIG <ref> [12, 23] </ref> (The Mach Interface Generator), which implements RPC with message passing on ports (a send and reply port are used). Using Mach ports eliminates the need to implement invocation queues in the RTS. All invocations will be sent from one process to another through a Mach port. 3.2.
Reference: [13] <author> D. R. Engler, M. F. Kaashoek, and J. O. Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: A trend in operating system research indicates that operating systems are becoming more flexible and extensible. For example, both SPIN [7] and the Exokernel <ref> [13] </ref> support application extensions to the kernel, allowing applications to have tight control over resource usage. Extensible operating systems pose many interesting opportunities to the implementation of concurrent programming languages. By employing kernel extensions, an RTS can directly define mechanisms such as synchronization and communication. <p> If possible, the RTS should not re-implement 2 functionality that is already provided by the operating sys-tem. Unfortunately, it is rare that operating systems interfaces are well matched to the needs of an RTS [29, 30]. Application adaptable kernels <ref> [7, 13, 11] </ref> will help improve this situation by allowing RTS systems to extend the kernel to better support language semantics and to maximize end-to-end performance between RTS systems executing on different machines. In general, concurrent programming languages require support for three basic mechanisms: threads, synchronization, and communication.
Reference: [14] <author> D. R. Engler and T. A. Proebsting. </author> <title> DCG: An efficient, re-targettable dynamic code generation system. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 263272, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Likewise, an RTS might choose between different communication interfaces depending on the process distribution of an executing program (e.g., execution on a shared memory multiprocessor, on a network of workstations, or both). To maximize the performance of run-time adaptability, dynamic code generation techniques such as <ref> [14] </ref> can be employed by an RTS. 6.2. RTS Extensibility General purpose high-level languages will ultimately be used in many different settings. It will not be adequate to have a single RTS that is used for every application and every environment.
Reference: [15] <author> M. P. I. Forum. </author> <title> MPI: A message-passing interface standard. </title> <institution> Technical Report Computer Science Department Technical Report CS-94-230, University of Tennessee, Knoxville, TN, </institution> <month> May 5 </month> <year> 1994. </year>
Reference-contexts: There are efforts to standardize the interfaces to low-level concurrency mechanisms. For example, Pthreads [19] is a POSIX standard for manipulating synchronizing threads, while MPI <ref> [15] </ref> is a standard for communication. However, these standards are not directly supported in operating system kernels (and perhaps they should not be), therefore they suffer from the same efficiency problems associated with the virtual machine approach.
Reference: [16] <author> I. Foster and K. M. Chandy. Fotran M: </author> <title> A Language for Modular Parallel Programming. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 25(1), </volume> <year> 1995. </year>
Reference-contexts: Nexus [17] is distributed thread library which provides a virtual machine layer similar to Panda. Nexus was designed and implemented at Argonne National Laboratory for implementation of back-ends for concurrent programming languages. It has been used for implementing the CC++ and Fortran-M <ref> [16] </ref> programming languages. It provides support for creating threads on a processor, for specifying synchronization among the threads of a node, and for communication among threads through the active-message paradigm. In the active message paradigm, it is possible to directly invoke a function on a remote node.
Reference: [17] <author> I. Foster, C. Kesselman, R. Olson, and S. Tuecke. </author> <title> Nexus: An Interoperability Layer for Parallel and Distributed Computer Systems. </title> <type> Technical Report Version 1.3, </type> <institution> Argonne National Laboratories, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The Panda layer provides a virtual machine for supporting run-time support systems. The virtual machine supports threads, remote procedure call (RPC), and totally-ordered group communication. Panda targets run-time support systems that provide shared data or shared objects. Nexus <ref> [17] </ref> is distributed thread library which provides a virtual machine layer similar to Panda. Nexus was designed and implemented at Argonne National Laboratory for implementation of back-ends for concurrent programming languages. It has been used for implementing the CC++ and Fortran-M [16] programming languages.
Reference: [18] <author> R. W. Gray, V. P. Heuring, S. P. Levi, A. M. Sloane, and W. M. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> In Communications of the ACM, </journal> <volume> volume 35, </volume> <pages> pages 121131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: As such, the RTS should be amenable to this sort of change. 6.3. Implementation Tools The requirements for RTS systems set out above are ambitious, and are unlikely to be achieved without some support tools. Whereas language translator construction can employ tools like Lex, Yacc, or Eli <ref> [18] </ref>, language run-time support construction, unfortunately, has no comparable tools available. Some research has addressed the automatic generation of run-time environments [20, 21], but the resulting RTS systems are for prototype use only, are not tuned for high performance, and do not target any particular operating system interfaces.
Reference: [19] <institution> Institute for Electrical and Electronic Engineers. POSIX P1003.1c, Threads Extension for Portable Operating Systems, </institution> <year> 1995. </year>
Reference-contexts: However, the virtual machine approach can lead to efficiency problems because some of the exported interfaces may be extremely difficult to implement on a particular operating system. There are efforts to standardize the interfaces to low-level concurrency mechanisms. For example, Pthreads <ref> [19] </ref> is a POSIX standard for manipulating synchronizing threads, while MPI [15] is a standard for communication. However, these standards are not directly supported in operating system kernels (and perhaps they should not be), therefore they suffer from the same efficiency problems associated with the virtual machine approach.
Reference: [20] <author> G. E. Kaiser. </author> <title> Generation of run-time environments. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 5157, </pages> <address> Palo Alto, </address> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(7):5157, </volume> <month> July </month> <year> 1986. </year>
Reference-contexts: Whereas language translator construction can employ tools like Lex, Yacc, or Eli [18], language run-time support construction, unfortunately, has no comparable tools available. Some research has addressed the automatic generation of run-time environments <ref> [20, 21] </ref>, but the resulting RTS systems are for prototype use only, are not tuned for high performance, and do not target any particular operating system interfaces. In light of the requirements given above, we suggest further research into two general RTS implementation tools.
Reference: [21] <author> G. E. Kaiser and S. M. Kaplan. </author> <title> Rapid prototyping of concurrent programming languages. </title> <booktitle> In IEEE 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 250 255, </pages> <year> 1988. </year>
Reference-contexts: Whereas language translator construction can employ tools like Lex, Yacc, or Eli [18], language run-time support construction, unfortunately, has no comparable tools available. Some research has addressed the automatic generation of run-time environments <ref> [20, 21] </ref>, but the resulting RTS systems are for prototype use only, are not tuned for high performance, and do not target any particular operating system interfaces. In light of the requirements given above, we suggest further research into two general RTS implementation tools.
Reference: [22] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Using this approach, an RTS can be tuned for a particular operating system and architecture. The result will be extremely efficient, but platform dependent RTS systems. This design methodology is similar to Liedtke's microkernel design philosophy <ref> [22] </ref>, which defines a microkernel as almost entirely machine dependent. We hope to reduce the portability problem by classifying RTS components as operating system dependent, ar 5 chitecture dependent, or platform independent. In addition, each component will be either orthogonal, and nonorthog-onal.
Reference: [23] <author> K. Loepere, </author> <title> editor. Mach 3 Server Writer's Guide. Open Software Foundation Mach 3. </title> <institution> Open Software Foundation and Carnegie Mellon University, </institution> <address> 2.2 edition, </address> <month> July </month> <year> 1992. </year> <month> 8 </month>
Reference-contexts: SR calls to procs can be implemented in the same way with the help of MIG <ref> [12, 23] </ref> (The Mach Interface Generator), which implements RPC with message passing on ports (a send and reply port are used). Using Mach ports eliminates the need to implement invocation queues in the RTS. All invocations will be sent from one process to another through a Mach port. 3.2.
Reference: [24] <author> J. R. McGraw et al. </author> <title> SISAL: Streams and iteration in a single assignment languagelanguage reference manual version 1.2. </title> <type> Technical Report M-146, </type> <institution> Lawrence Livermore National Laboratory, </institution> <year> 1985. </year>
Reference-contexts: Based on a decomposed SR RTS, we can further research the concept of component replacement, both static and dynamic. To further develop our ideas, we intended to investigate the run-time support for other concurrent programming languages such as C-YESC++ [26, 27] and Sisal <ref> [24, 9] </ref>. A future goal is to provide a library of components that can be used by many different concurrent programming languages. To facilitate component design and development, 7 we are also investigating the possibility of an RTS work-bench. 8.
Reference: [25] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 <ref> [25] </ref>, Ada95 [4], and Java [31]. 3 3. Example: The SR RTS SR [3, 2] is a concurrent programming language that provides mechanisms for specifying parallelism, communication, and synchronization. The SR RTS provides semantic and library support. <p> Our descriptions are not intended to be complete; they only point out the aspects of each RTS that are most relevant to this paper. 4.1. Modula-3 In the DEC SRC implementation [10] of Modula-3 <ref> [25] </ref>, the RTS handles garbage collection, exceptions, and threads. The SRC Modula-3 compiler generates native machine code using the GCC backend. Most of the Modula-3 RTS is written in Modula-3, except for certain low-level interfaces such as threads and input/output.
Reference: [26] <author> R. Pandey and J. C. Browne. </author> <title> A compositional approach to concurrent object-oriented programming. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Based on a decomposed SR RTS, we can further research the concept of component replacement, both static and dynamic. To further develop our ideas, we intended to investigate the run-time support for other concurrent programming languages such as C-YESC++ <ref> [26, 27] </ref> and Sisal [24, 9]. A future goal is to provide a library of components that can be used by many different concurrent programming languages. To facilitate component design and development, 7 we are also investigating the possibility of an RTS work-bench. 8.
Reference: [27] <author> R. Pandey and J. C. Browne. CYES-C++: </author> <title> A concurrent extension of C++ by compositional mechanisms. </title> <booktitle> In Workshop on Object-based Concurrent Systems, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Based on a decomposed SR RTS, we can further research the concept of component replacement, both static and dynamic. To further develop our ideas, we intended to investigate the run-time support for other concurrent programming languages such as C-YESC++ <ref> [26, 27] </ref> and Sisal [24, 9]. A future goal is to provide a library of components that can be used by many different concurrent programming languages. To facilitate component design and development, 7 we are also investigating the possibility of an RTS work-bench. 8.
Reference: [28] <author> E. Schonberg and B. Banner. </author> <title> The GNAT project: A GNU-Ada 9X compiler. </title> <booktitle> In TriAda Conference, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: On Windows/NT and Windows 95 2 , the RTS uses Win32 kernel threads and input/output. 2 Windows/NT and Windows 95 are registered trademarks of Microsoft Corporation. 4.2. Ada95 In the GNU NYU implementation of Ada 95 (GNAT) <ref> [28] </ref>, the run-time support (GNARL) handles Ada's task mechanisms including task creation, rendezvous, and termination. Similar to SRC Modula-3, GNAT uses the GCC backend to generate native machine code. In addition, most of the GNAT run-time support is written in Ada.
Reference: [29] <author> M. L. Scott. </author> <title> The interface between distributed operating system and high-level programming language. </title> <booktitle> In Proceedings of the 1986 International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: If possible, the RTS should not re-implement 2 functionality that is already provided by the operating sys-tem. Unfortunately, it is rare that operating systems interfaces are well matched to the needs of an RTS <ref> [29, 30] </ref>. Application adaptable kernels [7, 13, 11] will help improve this situation by allowing RTS systems to extend the kernel to better support language semantics and to maximize end-to-end performance between RTS systems executing on different machines.
Reference: [30] <author> M. L. Scott. </author> <title> Language support for loosely coupled distributed programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1):88103, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: If possible, the RTS should not re-implement 2 functionality that is already provided by the operating sys-tem. Unfortunately, it is rare that operating systems interfaces are well matched to the needs of an RTS <ref> [29, 30] </ref>. Application adaptable kernels [7, 13, 11] will help improve this situation by allowing RTS systems to extend the kernel to better support language semantics and to maximize end-to-end performance between RTS systems executing on different machines.
Reference: [31] <author> Sun Microsystems, Inc. </author> <title> Java: Programming for the Internet, </title> <note> 1995. http://www.javasoft.com/. 9 </note>
Reference-contexts: Although the focus is on SR and its RTS, we believe that the RTS systems for other language implementations will also benefit from our work. Section 4 briefly describes the basic implementation strategy for Modula-3 [25], Ada95 [4], and Java <ref> [31] </ref>. 3 3. Example: The SR RTS SR [3, 2] is a concurrent programming language that provides mechanisms for specifying parallelism, communication, and synchronization. The SR RTS provides semantic and library support. <p> GNARLI (GNU Ada Run-time Library Interface) is the interface between the object code and the RTS. GNULLI (GNU Low Level Interface) is the interface between the RTS and the underlying operating system. GNULLI relies on Pthreads for multithreading. 4.3. Java The Java <ref> [31] </ref> programming language was designed for architecturally neutral applications that are distributed through a network. To accomplish this, the Java compiler translates source code into an intermediate bytecode representation. Consequently, a Java bytecode interpreter (virtual machine) is needed to execute Java programs.
References-found: 31

