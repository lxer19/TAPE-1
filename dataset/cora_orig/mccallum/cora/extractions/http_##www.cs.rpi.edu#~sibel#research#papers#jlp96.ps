URL: http://www.cs.rpi.edu/~sibel/research/papers/jlp96.ps
Refering-URL: http://www.cs.rpi.edu/~sibel/research/papers/jlp96.html
Root-URL: http://www.cs.rpi.edu
Email: fsibel; vsg@cs.umd.edu  
Title: Amalgamating Knowledge Bases, II: Algorithms, Data Structures, and Query Processing  
Author: Sibel Adali and V.S. Subrahmanian 
Address: College Park, Maryland 20742.  
Affiliation: Department of Computer Science Institute for Advanced Computer Studies Institute for Systems Research University of Maryland  
Abstract: Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. In the first part of this series of papers, we presented a uniform declarative framework, based on annotated logics, for amalgamating multiple knowledge bases when these knowledge bases (possibly) contain inconsistencies, uncertainties, and non-monotonic modes of negation. We showed that annotated logics may be used, with some modifications, to mediate between different knowledge bases. The multiple knowledge bases are amalgamated by embedding the individual knowledge bases into a lattice. In this paper, we briefly describe an SLD-resolution based proof procedure that is sound and complete w.r.t. our declarative semantics. We will then develop an OLDT-resolution based query processing procedure, MULTI OLDT, that satisfies two important properties: (1) efficient reuse of previous computations is achieved by maintaining a table we describe the structure of this table and show that table operations can be efficiently executed, and (2) approximate, interruptable query answering is achieved, i.e. it is possible to obtain an "intermediate, approximate" answer from the QPP by interrupting it at any point in time during its execution. The design of the MULTI OLDT procedure will include the development of run-time algorithms to incrementally and efficiently update the table. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adali and V.S. Subrahmanian. </author> <title> (1993) Amalgamating knowledge bases, ii: Algorithms, data structures and query processing, </title> <type> Technical Report CS-TR-3124, </type> <institution> Computer Science Department, University </institution>
Reference-contexts: The GAP framework assumes that we have a set T of truth values that forms a complete lattice under an ordering . For instance, (T ; ) may be any one of the following: (1) Fuzzy Values: We can take T = <ref> [0; 1] </ref> the set of real numbers between 0 and 1 (inclusive) and to be the usual ordering on reals. (2) Time: We can take T to be the set TIME = 2 R + where R + is the set of non-negative real numbers, 2 R + is the power-set <p> So can sets of time points like the set f1; 3; 7g which refers to the time points 1,3 and 7; furthermore, f1; 7gf1; 3; 7g since f1; 7g f1; 3; 7g. (3) Fuzzy Values + Time: We could take T = <ref> [0; 1] </ref>fiTIME and take to be the ordering: [u 1 ; T 1 ][u 2 ; T 2 ] iff u 1 u 2 and T 1 T 2 . Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are <p> Fuzzy Values + Time: We could take T = <ref> [0; 1] </ref>fiTIME and take to be the ordering: [u 1 ; T 1 ][u 2 ; T 2 ] iff u 1 u 2 and T 1 T 2 . Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic [8, 17] uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> For instance, if T = <ref> [0; 1] </ref> and +; fl are annotation function symbols interpreted as "lus" and "times", respectively, and V is an annotation variable, then (V + 1) fl 0:5 is an annotation term. <p> If A is an atom (in the usual sense of logic), and is an annotation, then A : is an annotated atom. For example, when considering T = <ref> [0; 1] </ref>, the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : <p> For example, when considering T = <ref> [0; 1] </ref>, the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : [0:4; f1; 3; 7g] says that at each of the time points 1; 3; 7, there is at least a 40% certainty that the robot is at xy-coordinates (3; 5). <p> Intuitively, if T = <ref> [0; 1] </ref>, then the assignment of 0:7 to atom A means that according to interpretation I, A is true with certainty 70% or more. Interpretation I satisfies a ground annotated atom A : iff I (A). <p> If A : is an atom over lattice T , V is a DNAME-variable, and D f1; : : :; n; mg, then A : [D; ] and A : [V; ] are called amalgamated atoms. Intuitively, if T = <ref> [0; 1] </ref>, the amalgamated atom at robot (3; 4) : [f1; 2; 3g; 0:8] says that according to the (joint) information of databases 1; 2 and 3, the degree of certainty that the robot is at location (3; 4) is 80% or more . <p> An amalgamated clause is a statement of the form: A 0 : [D 0 ; 0 ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : :& A n : [D n ; n ] where A 0 : [D 0 ; 0 ]; : : : ; A n : [D n ; n ] are amalgamated atoms. <p> Mediatory Database: Suppose DB 1 ; : : :; DB n are GAPs. A mediatory database 2 M is a set of amalgamated clauses such that every ground instance of a clause in M is of the form: A 0 : [fmg; ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : :& A n : [D n ; n ] where, for all 1 i n, D i f1; : : :; n; mg. <p> First, each clause C in DB i of the form A 0 : 0 A 1 : 1 & : : : & A n : n is replaced by the amalgamated clause, AT (C): A 0 : [fig; 0 ] A 1 : <ref> [fig; 1 ] </ref> & : : : & A n : [fig; n ]: We use AT (DB i ) to denote the set fAT (C)jC 2 DB i g. <p> Definition 3 Given a clause C of the form: A 0 : [D 0 ; 0 ] A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D n ; n ] the regular representation of C, denoted by C fl , is the expression: A 0 : [D 0 ; * 0 ] A 1 : [D 1 ; * 1 ]& : : : &A <p> Definition 6 A query Q is a statement of the form: A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D m ; m ] where all the free variables of the query are assumed to be universally quantified 3 . <p> The negation of the above query is the statement (9)(A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D m ; m ]). The following result follows immediately from the definitions and is given without proof. Proposition 1 Suppose I is an A-interpretation. 1. I satisfies a ground clause C iff I S-satisfies C fl . 2. <p> Definition 9 [31] Suppose Q is an amalgamated knowledge base. We may associate with Q, an operator, A Q , that maps A-interpretations to A-interpretations as follows. A Q (I)(A)(D) = tf j A : [D; ] B 1 : <ref> [D 1 ; 1 ] </ref>& : : : &B n : [D n ; n ]& not (B n+1 : [D n+1 ; n+1 ])& : : :&not (B n+m : [D n+m ; n+m ])g is a ground instance of a clause in Q and for all 1 i n, <p> The only difference is that now, substitutions may assign terms to annotation variables, and these terms must range over the appropriate truth value lattice. Application of substitutions to annotated atoms may then be defined in the obvious way. For instance, when the truth value domain is the unit interval <ref> [0; 1] </ref>, the substitution oe = fX = a; Y = f (Z; a); U = 0:25g when applied to the annotated atom p (X; Y; X) : [f1g; U+1 2 ] yields the annotated atom p (a; f (Z; a); a) : [f1g; 0:25+1 2 ]; at this stage, we <p> Definition 11 A MULTI OLDT table is a set of annotated atoms of the form A : [D; ]. We now describe how the MULTI OLDT-table gets updated when a new atom is inserted. If the atoms A : <ref> [D 1 ; 1 ] </ref> and A : [D 2 ; 2 ] are true in the amalgamated knowledge base, then the merged atom A : [D 1 [ D 2 ; t ( 1 ; 2 )] must also be true. <p> We will first define these steps, and then explain how these steps are used when a new atom is inserted into a MULTI OLDT-table. 5.2.1 The Revision Step Definition 12 (Revision Step) Suppose is a MULTI OLDT-table, and A 1 : <ref> [D 1 ; 1 ] </ref> is an annotated atom. <p> The revision R of the atom A 1 : <ref> [D 1 ; 1 ] </ref> with table is given as follows: * R 0 = fA 1 : [D 1 ; 1 ]g. 1 oe : [D 1 ; t ( 0 1 : [D 1 ; 0 1 ] 2 R i is unifiable with A 2 : [D 2 <p> The revision R of the atom A 1 : <ref> [D 1 ; 1 ] </ref> with table is given as follows: * R 0 = fA 1 : [D 1 ; 1 ]g. 1 oe : [D 1 ; t ( 0 1 : [D 1 ; 0 1 ] 2 R i is unifiable with A 2 : [D 2 ; 2 ] 2 [i+1] via mgu oe and D 2 D 1 g. * R=R card (D <p> Then, the merge of R with is the set M = fA 2 : [D 2 ; t ( 1 oe; 2 oe)] j A 1 : <ref> [D 1 ; 1 ] </ref> 2 R is unifiable with A 2 : [D 2 ; 2 ] 2 via mgu oe and D 1 ae D 2 g. <p> The reason for this is the following: consider the ordering on M defined as follows: A 1 : <ref> [D 1 ; 1 ] </ref> A 2 : [D 2 ; 2 ] iff A 2 : [D 2 ; 2 ] j= A 1 : [D 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 <p> The reason for this is the following: consider the ordering on M defined as follows: A 1 : <ref> [D 1 ; 1 ] </ref> A 2 : [D 2 ; 2 ] iff A 2 : [D 2 ; 2 ] j= A 1 : [D 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : <p> ; 1 ] A 2 : [D 2 ; 2 ] iff A 2 : [D 2 ; 2 ] j= A 1 : <ref> [D 1 ; 1 ] </ref>. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. <p> ; 2 ] j= A 1 : <ref> [D 1 ; 1 ] </ref>. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. <p> relation on M defined as: A 1 : <ref> [D 1 ; 1 ] </ref> A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; <p> The relation can now be extended to the equivalence classes generated by as follows: <ref> [A 1 : [D 1 ; 1 ] </ref>] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. <p> A 1 : <ref> [D 1 ; 1 ] </ref> A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. <p> 2 : [D 2 ; 2 ] A 1 : <ref> [D 1 ; 1 ] </ref>. The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. The simplification step corresponds to finding the ? -maximal equivalence classes and then picking exactly one member from each of these ? -maximal equivalence classes. <p> The simplification step corresponds to finding the ? -maximal equivalence classes and then picking exactly one member from each of these ? -maximal equivalence classes. The step of computing whether A 1 : <ref> [D 1 ; 1 ] </ref> A 2 : [D 2 ; 2 ] is a linear time operation as it only involves checking whether there exists a substitution oe such that: (1) A 2 oe = A 1 , and (2) D 2 D 2 20 and (3) 1 oe 2 <p> Definition 15 (Table Insertion) Suppose is a MULTI OLDT-table, and A 1 : <ref> [D 1 ; 1 ] </ref> is an annotated atom. The result of inserting A 1 : [D 1 ; 1 ] into is a new table 0 constructed as follows: 1. Set M to fA 1 : [D 1 ; 1 ]g. 2. <p> Definition 15 (Table Insertion) Suppose is a MULTI OLDT-table, and A 1 : <ref> [D 1 ; 1 ] </ref> is an annotated atom. The result of inserting A 1 : [D 1 ; 1 ] into is a new table 0 constructed as follows: 1. Set M to fA 1 : [D 1 ; 1 ]g. 2. <p> Definition 15 (Table Insertion) Suppose is a MULTI OLDT-table, and A 1 : <ref> [D 1 ; 1 ] </ref> is an annotated atom. The result of inserting A 1 : [D 1 ; 1 ] into is a new table 0 constructed as follows: 1. Set M to fA 1 : [D 1 ; 1 ]g. 2. <p> Find the simplified version 0 of , set the final table to 0 . That is, the insertion of A 1 : <ref> [D 1 ; 1 ] </ref> into the table is a two step process (after initialization): in the first step, the atoms in the table are compared and merged with the new atom in a continuous loop. In the second step, the redundant atoms are removed. <p> Consider MULTI OLDT-tables that satisfy the following two conditions at all times: * (Complete information) Whenever there are two atoms A 1 : <ref> [D 1 ; 1 ] </ref> and A 2 : [D 2 ; 2 ] in the table that are unifiable via mgu oe and such that D 1 D 2 then there must be an atom in that subsumes the atom A 2 oe : [D 2 ; t ( 1 <p> Given that the table satisfies the above conditions, the insertion routine for inserting the atom A 1 : <ref> [D 1 ; 1 ] </ref> into the table can be modified as follows: 24 1. Set R to the simplified version of the revision of A 1 : [D 1 ; 1 ] with . 2. Set to [ R. 3. <p> Given that the table satisfies the above conditions, the insertion routine for inserting the atom A 1 : <ref> [D 1 ; 1 ] </ref> into the table can be modified as follows: 24 1. Set R to the simplified version of the revision of A 1 : [D 1 ; 1 ] with . 2. Set to [ R. 3. <p> The running-time of the simplification step can be further reduced if special data structures are used to store the atoms in the MULTI OLDT-table. One such arrangement is that atoms having the same D-terms are arranged according to a secondary key. In other words, if A 1 : <ref> [D; 1 ] </ref> subsumes A 2 : [D; 2 ] then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all <p> One such arrangement is that atoms having the same D-terms are arranged according to a secondary key. In other words, if A 1 : <ref> [D; 1 ] </ref> subsumes A 2 : [D; 2 ] then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by A 1 : [D; 1 ]. <p> In other words, if A 1 : <ref> [D; 1 ] </ref> subsumes A 2 : [D; 2 ] then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by A 1 : [D; 1 ]. <p> A 1 : <ref> [D; 1 ] </ref> comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by A 1 : [D; 1 ]. <p> Then: 1. If Q ? n and 1 ; : : : ; n is a dynamic MULTI OLDT computation associated with Q, and if A : [D; ] is in n , then P j= A : [D; ]. 2. Suppose C = (A 1 : <ref> [D 1 ; 1 ] </ref> & : : :& A k : [D k ; k ]). <p> Q m+1 is obtained in one of two ways: 1. The first possibility is that Q m+1 is the S-resolvent of an atom A 1 : <ref> [D 1 ; 1 ] </ref> 2 n and Q j (j n) on an atom A 2 : [D 2 ; 2 s ] via mgu . In this case, no atoms are added to the table as a result of the resolution. <p> If the body of the clause C is non-empty, then no atoms are added to the table. Otherwise, suppose C = A 1 : <ref> [D 1 ; 1 ] </ref> . Then this atom is added to the table. Clearly P j= A 1 : [D 1 ; 1 ]. <p> If the body of the clause C is non-empty, then no atoms are added to the table. Otherwise, suppose C = A 1 : <ref> [D 1 ; 1 ] </ref> . Then this atom is added to the table. Clearly P j= A 1 : [D 1 ; 1 ]. Now, the propagation step starts. 3. (Soundness of propagation) Suppose A : [D; s ] is an atom in Q k (k m) and suppose its twin is the atom A t : [D t ; t ]. <p> The children of this atom are A i : [D i ; T * i ](1 i m) and A : [D; s " * t ] for some mgu . Clearly, A t : [D t ; t ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : :& A m : [D m ; m ] is an instance of a clause C in P , hence P j= C. <p> These structures will be referred to as TABLE and QUERY, respectively. The technical report version of this paper <ref> [1] </ref> contains a detailed description of these data structures, as well as pseudo-code to manipulate these data structures. All these data structures and algorithms have been implemented by Kullman [20] (with minor modifications). <p> The reader who is interested in details of the algorithms manipulating the QUERY and TABLE data structures may read the technical report for the required pseudo-code <ref> [1] </ref>. They implement the algorithms described in Section 5.2 using the TABLE and QUERY data structures described above. The pseudo-code has also been implemented by Kullman in Germany [20]. 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems [40, 16, 37]. <p> Dubois, Lang and Prade [12], also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source. The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. <p> The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in [34, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [31].
Reference: [2] <author> C. Baral, S. Kraus and J. Minker. </author> <title> (1991) Combining Multiple Knowledge Bases, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 3, 2, </volume> <pages> pps 200-220. </pages>
Reference-contexts: Intuitively, if T = [0; 1], the amalgamated atom at robot (3; 4) : <ref> [f1; 2; 3g; 0:8] </ref> says that according to the (joint) information of databases 1; 2 and 3, the degree of certainty that the robot is at location (3; 4) is 80% or more . <p> As a preview, we give a small example. Example 4 Consider the databases DB 1 ; DB 2 and DB 3 in the static robot example, and suppose we ask the query: can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref>: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : [f1; 2; 3g; T * V ] . <p> databases DB 1 ; DB 2 and DB 3 in the static robot example, and suppose we ask the query: can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref>: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : [f1; 2; 3g; T * V ] . Let us see what happens. 1. <p> the query: can lif t (r1; b) : [f1; 2; 3g; V ]: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : <ref> [f1; 2; 3g; T * V ] </ref> . Let us see what happens. 1. <p> Let us see what happens. 1. Resolving this query with the (regular representation of the) first rule in DB 2 yields, as resolvent, Q fl can lif t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> _ weight (b; W ) : [f2g; T * t] _ W 50 : 2. <p> t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> _ weight (b; W ) : [f2g; T * t] _ W 50 : 2. Resolving this query with the (regular representation of the) second fact in DB 2 yields can lif t (r1; b) : [f1; 2; 3g; (T * V ) " * t] _ weight (b; 19) : [f2g; (T * t) " * t] _ 19 50 : As (T * t) " * t = ;, the atom weight (b; 19) : [(T * t) " * t] can be eliminated from <p> As (T * t) " * t = ;, the atom weight (b; 19) : [(T * t) " * t] can be eliminated from the resolvent, and the evaluable atom 19 50 may also be so eliminated, thus leaving us with the resolvent can lif t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> : Note that at this stage, we are in a position to conclude that V must be at least t for the following reasons: 13 * All atoms in the body of the first rule in DB 2 have been resolved <p> Definition 11 A MULTI OLDT table is a set of annotated atoms of the form A : [D; ]. We now describe how the MULTI OLDT-table gets updated when a new atom is inserted. If the atoms A : [D 1 ; 1 ] and A : <ref> [D 2 ; 2 ] </ref> are true in the amalgamated knowledge base, then the merged atom A : [D 1 [ D 2 ; t ( 1 ; 2 )] must also be true. Suppose the first atom is already in the table and the second is just being inserted. <p> : [D 1 ; 1 ] with table is given as follows: * R 0 = fA 1 : [D 1 ; 1 ]g. 1 oe : [D 1 ; t ( 0 1 : [D 1 ; 0 1 ] 2 R i is unifiable with A 2 : <ref> [D 2 ; 2 ] </ref> 2 [i+1] via mgu oe and D 2 D 1 g. * R=R card (D 1 ) . <p> Then, the merge of R with is the set M = fA 2 : [D 2 ; t ( 1 oe; 2 oe)] j A 1 : [D 1 ; 1 ] 2 R is unifiable with A 2 : <ref> [D 2 ; 2 ] </ref> 2 via mgu oe and D 1 ae D 2 g. <p> The basic intuition (in the case when annotation variables are ground) behind merging is the following: when inserting an atom A 1 : [D 1 ; ] 2 R into the MULTI OLDT-table , we examine all atoms A 2 : <ref> [D 2 ; 2 ] </ref> 2 such that D 1 ae D 2 and such that A 1 and A 2 are unifiable via mgu oe the insertion of A 1 : [D 1 ; ] may cause the truth value of A 2 : [D 2 ; 2 ] to <p> all atoms A 2 : <ref> [D 2 ; 2 ] </ref> 2 such that D 1 ae D 2 and such that A 1 and A 2 are unifiable via mgu oe the insertion of A 1 : [D 1 ; ] may cause the truth value of A 2 : [D 2 ; 2 ] to "increase" from 2 to t ( 1 ; 2 ). The above definition uses this intuition to define merging when annotation variables may be non-ground. The following example shows how merging behaves on an example. <p> Let R be given by R = fp (U; b) : [f1; 2g; f ]; p (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2g; &gt;]g: Since f1; 2g ae f1; 2; 3g, only the atoms p (a; Y ) : <ref> [f1; 2; 3g; f ] </ref> and p (f (Y ); Y ) : [f1; 2; 3g; t] in will be considered for merging. <p> b) : [f1; 2g; f ]; p (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2g; &gt;]g: Since f1; 2g ae f1; 2; 3g, only the atoms p (a; Y ) : [f1; 2; 3g; f ] and p (f (Y ); Y ) : <ref> [f1; 2; 3g; t] </ref> in will be considered for merging. <p> The merge of R and is the set M = fp (a; b) : <ref> [f1; 2; 3g; &gt;] </ref>; p (f (b); b) : [f1; 2; 3g; &gt;]g: 19 Complexity of Merging: Suppose is a MULTI OLDT-table and [i] = fA : [D; ] j A : [D; ] 2 & card (D) = ig. Suppose there are n deductive databases in the amalgamated system. <p> The merge of R and is the set M = fp (a; b) : <ref> [f1; 2; 3g; &gt;] </ref>; p (f (b); b) : [f1; 2; 3g; &gt;]g: 19 Complexity of Merging: Suppose is a MULTI OLDT-table and [i] = fA : [D; ] j A : [D; ] 2 & card (D) = ig. Suppose there are n deductive databases in the amalgamated system. <p> of these sets is the set fl given below: fl = f p (X; c) : [f1g; t]; p (f (Y ); Y ) : [f2g; f ]; p (a; Y ) : [f2g; t]; p (U; b) : [f1; 2g; f ]; p (f (Y ); Y ) : <ref> [f1; 2; 3g; t] </ref>; p (a; b) : [f1; 2; 3g; &gt;]; p (f (b); b) : [f1; 2; 3g; &gt;]g Then, the simplified version 0 of the table ? is given as: 0 = ? fp (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2; <p> below: fl = f p (X; c) : [f1g; t]; p (f (Y ); Y ) : [f2g; f ]; p (a; Y ) : [f2g; t]; p (U; b) : [f1; 2g; f ]; p (f (Y ); Y ) : [f1; 2; 3g; t]; p (a; b) : <ref> [f1; 2; 3g; &gt;] </ref>; p (f (b); b) : [f1; 2; 3g; &gt;]g Then, the simplified version 0 of the table ? is given as: 0 = ? fp (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2; 3g; &gt;]g: Complexity of Simplification: In the worst <p> t]; p (f (Y ); Y ) : [f2g; f ]; p (a; Y ) : [f2g; t]; p (U; b) : [f1; 2g; f ]; p (f (Y ); Y ) : [f1; 2; 3g; t]; p (a; b) : <ref> [f1; 2; 3g; &gt;] </ref>; p (f (b); b) : [f1; 2; 3g; &gt;]g Then, the simplified version 0 of the table ? is given as: 0 = ? fp (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2; 3g; &gt;]g: Complexity of Simplification: In the worst case, the simplified version of a set M of <p> : [f1; 2; 3g; t]; p (a; b) : <ref> [f1; 2; 3g; &gt;] </ref>; p (f (b); b) : [f1; 2; 3g; &gt;]g Then, the simplified version 0 of the table ? is given as: 0 = ? fp (f (b); b) : [f1; 2g; f ]; p (a; b) : [f1; 2; 3g; &gt;]g: Complexity of Simplification: In the worst case, the simplified version of a set M of atoms may be computed in O (card (M) 2 l). <p> The reason for this is the following: consider the ordering on M defined as follows: A 1 : [D 1 ; 1 ] A 2 : <ref> [D 2 ; 2 ] </ref> iff A 2 : [D 2 ; 2 ] j= A 1 : [D 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 <p> The reason for this is the following: consider the ordering on M defined as follows: A 1 : [D 1 ; 1 ] A 2 : <ref> [D 2 ; 2 ] </ref> iff A 2 : [D 2 ; 2 ] j= A 1 : [D 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] iff A 1 <p> ; 2 ] iff A 2 : <ref> [D 2 ; 2 ] </ref> j= A 1 : [D 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. <p> 1 ; 1 ]. is a reflexive and transitive ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : <ref> [D 2 ; 2 ] </ref> iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. <p> ordering on M and hence, induces an equivalence relation on M defined as: A 1 : [D 1 ; 1 ] A 2 : <ref> [D 2 ; 2 ] </ref> iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ] and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; <p> The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? <ref> [A 2 : [D 2 ; 2 ] </ref> iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. <p> 2 : <ref> [D 2 ; 2 ] </ref> and A 2 : [D 2 ; 2 ] A 1 : [D 1 ; 1 ]. The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : [D 2 ; 2 ] iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. <p> The relation can now be extended to the equivalence classes generated by as follows: [A 1 : [D 1 ; 1 ]] ? [A 2 : <ref> [D 2 ; 2 ] </ref> iff A 1 : [D 1 ; 1 ] A 2 : [D 2 ; 2 ]. ? is a partial ordering on equivalence classes. The simplification step corresponds to finding the ? -maximal equivalence classes and then picking exactly one member from each of these ? -maximal equivalence classes. <p> The simplification step corresponds to finding the ? -maximal equivalence classes and then picking exactly one member from each of these ? -maximal equivalence classes. The step of computing whether A 1 : [D 1 ; 1 ] A 2 : <ref> [D 2 ; 2 ] </ref> is a linear time operation as it only involves checking whether there exists a substitution oe such that: (1) A 2 oe = A 1 , and (2) D 2 D 2 20 and (3) 1 oe 2 oe. <p> at time points 3 and 4 according to databases 1 and 2 jointly." Now, suppose the table in this example contains the atoms: = fp : [f1g; ft 1 ; t 3 g]; p : [f2g; ft 1 ; t 2 g]; p : [f3g; ft 7 g]; p : <ref> [f1; 2; 3g; ft 6 g] </ref>; p : [f1; 2; 3; 4g; ft 4 ; t 5 g]g: and the atom p : [f1; 2g; ft 3 g] is being inserted into . The following operations take place: * Step 1. <p> databases 1 and 2 jointly." Now, suppose the table in this example contains the atoms: = fp : [f1g; ft 1 ; t 3 g]; p : [f2g; ft 1 ; t 2 g]; p : [f3g; ft 7 g]; p : [f1; 2; 3g; ft 6 g]; p : <ref> [f1; 2; 3; 4g; ft 4 ; t 5 g] </ref>g: and the atom p : [f1; 2g; ft 3 g] is being inserted into . The following operations take place: * Step 1. M is set to fp : [f1; 2g; ft 3 g]g: * Step 2 (a-b). <p> The table before simplification contains the atoms = f p : [f1g; ft 1 ; t 3 g]; p : [f2g; ft 1 ; t 2 g]; p : [f3g; ft 7 g]; p : <ref> [f1; 2; 3g; ft 6 g] </ref>; p : [f1; 2; 3g; ft 1 ; t 2 ; t 3 ; t 6 ; t 7 g]; p : [f1; 2; 3; 4g; ft 1 ; t 2 ; t 3 ; t 5 ; t 6 ; t 7 g]g: This <p> Consider MULTI OLDT-tables that satisfy the following two conditions at all times: * (Complete information) Whenever there are two atoms A 1 : [D 1 ; 1 ] and A 2 : <ref> [D 2 ; 2 ] </ref> in the table that are unifiable via mgu oe and such that D 1 D 2 then there must be an atom in that subsumes the atom A 2 oe : [D 2 ; t ( 1 oe; 2 oe)]. * (No redundant information) At all <p> Example 7 can be stored in the order shown below. = f p (X; c) : [f1g; t]; p (f (Y ); Y ) : [f2g; f ]; p (a; Y ) : [f2g; t]; However storing it in the order = f p (f (Y ); Y ) : <ref> [f1; 2; 3g; t] </ref>; p (f (Y ); Y ) : [f2g; f ]; p (a; Y ) : [f2g; t]; is not permitted. <p> One such arrangement is that atoms having the same D-terms are arranged according to a secondary key. In other words, if A 1 : [D; 1 ] subsumes A 2 : <ref> [D; 2 ] </ref> then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by <p> One such arrangement is that atoms having the same D-terms are arranged according to a secondary key. In other words, if A 1 : [D; 1 ] subsumes A 2 : <ref> [D; 2 ] </ref> then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by A 1 : [D; 1 ]. <p> if A 1 : [D; 1 ] subsumes A 2 : <ref> [D; 2 ] </ref> then A 1 : [D; 1 ] comes before A 2 : [D; 2 ] in the table. Moreover, A 1 : [D; 1 ] contains links that can be traversed to reach A 2 : [D; 2 ] and all the other atoms that are subsumed by A 1 : [D; 1 ]. <p> In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [2, 3] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in [31], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we have shown in [31], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [3] <author> C. Baral, S. Kraus, J. Minker and V.S. Subrahmanian. </author> <title> (1992) Combining Knowledge Bases Consisting of First Order Theories, </title> <journal> Computational Intelligence, </journal> <volume> 8, 1, </volume> <pages> pps 45-71. </pages>
Reference-contexts: 1], the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : <ref> [0:4; f1; 3; 7g] </ref> says that at each of the time points 1; 3; 7, there is at least a 40% certainty that the robot is at xy-coordinates (3; 5). <p> databases 1 and 2 jointly." Now, suppose the table in this example contains the atoms: = fp : [f1g; ft 1 ; t 3 g]; p : [f2g; ft 1 ; t 2 g]; p : [f3g; ft 7 g]; p : [f1; 2; 3g; ft 6 g]; p : <ref> [f1; 2; 3; 4g; ft 4 ; t 5 g] </ref>g: and the atom p : [f1; 2g; ft 3 g] is being inserted into . The following operations take place: * Step 1. M is set to fp : [f1; 2g; ft 3 g]g: * Step 2 (a-b). <p> In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [2, 3] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in [31], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we have shown in [31], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [4] <author> C. Baral and V.S. Subrahmanian. </author> <title> (1991) Dualities between Alternative Semantics for Logic Programming and Nonmonotonic Reasoning, </title> <booktitle> Proc. 1991 Intl. Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <address> MIT Press. </address> <note> Full version in: Journal of Automated Reasoning, 10, pps 339-420, </note> <year> 1993. </year>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in <ref> [34, 4] </ref>, to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [31]. Our work builds upon work by Lu, Murray and Rosenthal [23] who have independently developed a framework for query processing in GAPs.
Reference: [5] <author> F. Bancilhon, D. Maier, Y. Sagiv and J. Ullman. </author> <title> (1986) Magic Sets and Other Strange Ways to Implement Logic Programs, </title> <booktitle> Proc. 5th Symp. on Principles of Database Systems, </booktitle> <address> pps 1-15. </address>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [29, 28] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 27] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [6] <author> C. Beeri and R. Ramakrishnan. </author> <title> (1987) On the Power of Magic, </title> <booktitle> Proc. 6th Symp. on Principles of Database Systems, </booktitle> <address> pps 269-283. </address>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [29, 28] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 27] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [7] <author> N. D. Belnap, JR. </author> <title> (1977) A Useful Four Valued Logic, </title> <booktitle> Modern Uses of Many Valued Logic, </booktitle> <pages> pp 8-37, </pages> <editor> eds. G. Epstein, J. M. Dunn., </editor> <address> MacGraw Hill. </address> <month> 37 </month>
Reference-contexts: In particular, t and f are not comparable relative to this ordering. <ref> [7, 8, 17] </ref> show how this FOUR-valued logic may be used to reason about databases containing inconsistencies. This is only a small sample of what T could be.
Reference: [8] <author> H. A. Blair and V.S. Subrahmanian. </author> <title> (1987) Paraconsistent Logic Programming, </title> <journal> Theoretical Computer Science, </journal> <volume> 68, </volume> <pages> pp 35-54. </pages> <note> Preliminary version in: LNCS 287, Dec. 1987, Springer. </note>
Reference-contexts: Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic <ref> [8, 17] </ref> uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> In particular, t and f are not comparable relative to this ordering. <ref> [7, 8, 17] </ref> show how this FOUR-valued logic may be used to reason about databases containing inconsistencies. This is only a small sample of what T could be.
Reference: [9] <author> W. Chen and D.S. Warren. </author> <title> (1992) A Goal-Oriented Approach to Computing Well-Founded Semantics, </title> <booktitle> Proc. 1992 Intl. Conf. on Logic Programming (ed. K.R. Apt), </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [33] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki [29, 28] and Warren and his colleagues <ref> [9, 10] </ref>. Furthermore, it is known that OLDT and magic set computations [5, 6, 27] are essentially equivalent, though they differ in many (relatively minor) details. <p> Warren <ref> [9, 10] </ref>). When a single database with neither uncertainty nor time is considered, the structure of the OLDT-table can be relatively simple. However, when multiple database operations, uncertainty estimates (that are constantly being revised), and temporal reasoning are being performed simultaneously, the management of the OLDT-table becomes a significant issue. <p> However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. Finally, our development of MULTI OLDT-resolution is new. Warren and his co-workers <ref> [10, 9] </ref> have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [10] <author> S. Dietrich. </author> <title> (1986) Extension Tables: Memo Relations in Logic Programming, </title> <booktitle> Proc. 1987 IEEE Symp. on Logic Programming, </booktitle> <address> pps 264-272. </address>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [33] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki [29, 28] and Warren and his colleagues <ref> [9, 10] </ref>. Furthermore, it is known that OLDT and magic set computations [5, 6, 27] are essentially equivalent, though they differ in many (relatively minor) details. <p> Warren <ref> [9, 10] </ref>). When a single database with neither uncertainty nor time is considered, the structure of the OLDT-table can be relatively simple. However, when multiple database operations, uncertainty estimates (that are constantly being revised), and temporal reasoning are being performed simultaneously, the management of the OLDT-table becomes a significant issue. <p> However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. Finally, our development of MULTI OLDT-resolution is new. Warren and his co-workers <ref> [10, 9] </ref> have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [11] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Towards Possibilistic Logic Programming, </title> <booktitle> Proc. 1991 Intl. Conf. on Logic Programming, </booktitle> <editor> ed. K. Furukawa, </editor> <address> pps 581-595, </address> <publisher> MIT Press. </publisher>
Reference: [12] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1992) Dealing with Multi-Source Information in Possibilistic Logic, </title> <booktitle> Proc. 10th European Conf. on Artificial Intelligence, </booktitle> <publisher> Wiley. </publisher>
Reference-contexts: Dubois, Lang and Prade <ref> [12] </ref>, also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source.
Reference: [13] <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> (1983) On the Semantics of Updates in Databases, </title> <booktitle> Proc. ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> pps 352-365. </address>
Reference-contexts: Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [14] <author> R. Fagin, G. Kuper, J. Ullman, and M. Vardi. </author> <title> (1986) Updating Logical Databases, </title> <booktitle> In Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18, </pages> <year> 1986. </year>
Reference-contexts: Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [15] <author> M. C. </author> <title> Fitting. (1991) Well-Founded Semantics, Generalized, </title> <booktitle> Proc. 1991 Intl. Logic Programming Symposium, </booktitle> <address> pps 71-83, </address> <publisher> MIT Press. </publisher>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In <ref> [15] </ref>, Fitting generalizes results in [34, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [31].
Reference: [16] <author> J. Grant, W. Litwin, N. Roussopoulos and T. Sellis. </author> <title> (1991) An Algebra and Calculus for Relational Multidatabase Systems, </title> <booktitle> Proc. First International Workshop on Interoperability in Multi-database Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 118-124. </publisher>
Reference-contexts: They implement the algorithms described in Section 5.2 using the TABLE and QUERY data structures described above. The pseudo-code has also been implemented by Kullman in Germany [20]. 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [40, 16, 37] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. The work of Grant et. al. <ref> [16] </ref> is an exception: the authors develop a calculus and an algebra for integrating information from multiple databases. This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multidatabases is critically needed.
Reference: [17] <author> M. Kifer and E. Lozinskii. </author> <title> (1989) RI: A Logic for Reasoning with Inconsistency, </title> <booktitle> 4-th Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 253-262. </pages> <note> Full version to appear in: Journal of Automated Reasoning. </note>
Reference-contexts: Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic <ref> [8, 17] </ref> uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> In particular, t and f are not comparable relative to this ordering. <ref> [7, 8, 17] </ref> show how this FOUR-valued logic may be used to reason about databases containing inconsistencies. This is only a small sample of what T could be. <p> Later in this section, we will define a resolution-based strategy that uses regular representations of amalgamated clauses instead of the amalgamated clauses themselves. The advantage is that the expensive reductant rule of inference introduced by Kifer and Lozinskii <ref> [17] </ref> and later studied by Kifer and Subrahmanian [18] can be eliminated by using regular representations.
Reference: [18] <author> M. Kifer and V.S. Subrahmanian. </author> <title> (1989) Theory of Generalized Annotated Logic Programming and its Applications, </title> <journal> Journal of Logic Programming, </journal> <volume> 12, 4, </volume> <pages> pps 335-368, </pages> <year> 1992. </year> <title> Preliminary version in: </title> <booktitle> Proc. 1989 North American Conf. on Logic Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: DAAL-03-92-G-0225 and by the Air Force Office of Scientific Research under Grant Nr. F49620-93-1-0065, and by ARPA Order Nr. A716 administered by Rome Labs under contract F30602-93-C-0241. NOTE TO REFEREES: Appendix A contains material that can be removed from the paper after acceptance. 1 paradigm of Kifer and Subrahmanian <ref> [18] </ref> may be used to express mediators. <p> results with relevant work by other researchers in Section 6. 2 2 Preliminaries In this section, we give a quick overview of GAPs and the amalgamation theory developed in the first of this series of papers [31]. 2.1 Overview of GAPs (Generalized Annotated Programs) The GAP framework syntax proposed in <ref> [18] </ref> is an extension of the logic programming. It has been proposed as a framework within which inconsistencies, temporal information and probabilistic logic can be handled in a uniform way. <p> In other words, 1 As done by Kifer and Subrahmanian <ref> [18] </ref>, we will assume that all annotation function symbols can be interpreted in only one fixed way. 3 annotation functions can occur in the heads of clauses, but not in the clause bodies. <p> These examples will be used throughout the paper to illustrate various intuitions as they arise in the paper. We will assume that the reader is familiar with generalized annotated programs (GAPs) as defined in <ref> [18] </ref>. 3.1 Robot Example Consider two mobile robots, r1 and r2, that are operating in a common workspace. Each of these two robots has access to three databases; one of these databases represents information about the locations of objects in the workspace (cf. <p> Later in this section, we will define a resolution-based strategy that uses regular representations of amalgamated clauses instead of the amalgamated clauses themselves. The advantage is that the expensive reductant rule of inference introduced by Kifer and Lozinskii [17] and later studied by Kifer and Subrahmanian <ref> [18] </ref> can be eliminated by using regular representations. <p> The fixpoint reachability property is critical for completeness because otherwise, we need to take recourse to infinitary proofs. It is well-known <ref> [18] </ref> that even in the case of GAPs, the fixpoint reachability property is critically necessary for obtaining completeness results. The proof of the following result is contained in Appendix A. <p> This is not true in the [33] framework. 17 5.2 MULTI OLDT Table Kifer and Subrahmanian <ref> [18] </ref> have defined how substitutions (in the ordinary sense, cf. Lloyd [22]) may be extended to apply to annotated atoms. The only difference is that now, substitutions may assign terms to annotation variables, and these terms must range over the appropriate truth value lattice.
Reference: [19] <author> D. E. Knuth. </author> <booktitle> (1973) The Art of Computer Programming, </booktitle> <volume> Vol. 1. </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Ad-dison Wesley. </publisher>
Reference: [20] <author> P. Kullman. </author> <type> (1994) Master's Thesis, </type> <institution> Univ. of Karlsruhe, Germany. </institution>
Reference-contexts: These structures will be referred to as TABLE and QUERY, respectively. The technical report version of this paper [1] contains a detailed description of these data structures, as well as pseudo-code to manipulate these data structures. All these data structures and algorithms have been implemented by Kullman <ref> [20] </ref> (with minor modifications). There are a couple of differences between the mathematical model of dynamic MULTI OLDT-computations and the real data structures used to implement them. In the implementation, QUERY is just a list of atoms. <p> They implement the algorithms described in Section 5.2 using the TABLE and QUERY data structures described above. The pseudo-code has also been implemented by Kullman in Germany <ref> [20] </ref>. 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems [40, 16, 37]. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases.
Reference: [21] <author> S. Leach and J. Lu. </author> <title> (1994) Computing Annotated Logic Programs, </title> <booktitle> Proceedings of the 11th International Conference on Logic Programming (ed. </booktitle> <editor> P. Van Hentenryck), </editor> <publisher> MIT Press, </publisher> <address> pps 257-271. </address>
Reference-contexts: This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. It is similar to work by Lu, Murray and Rosenthal [23] who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu <ref> [21] </ref>, the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. <p> We have given a detailed comparison of our declarative framework with Fitting's in [31]. Our work builds upon work by Lu, Murray and Rosenthal [23] who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu <ref> [21] </ref>, the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well.
Reference: [22] <author> J.W. Lloyd. </author> <booktitle> (1987) Foundations of Logic Programming, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Then, there is an S-refutation of ( Q) fl from P . 2 The above completeness theorem specifies the existence of refutations of queries that are consequences of P . In this paper, we do not deal with computation rules <ref> [22] </ref>. The use of different fair computation rules in implementing a search strategy for resolution has been studied by many authors such as Vielle [35]. <p> This is not true in the [33] framework. 17 5.2 MULTI OLDT Table Kifer and Subrahmanian [18] have defined how substitutions (in the ordinary sense, cf. Lloyd <ref> [22] </ref>) may be extended to apply to annotated atoms. The only difference is that now, substitutions may assign terms to annotation variables, and these terms must range over the appropriate truth value lattice. Application of substitutions to annotated atoms may then be defined in the obvious way.
Reference: [23] <author> J. Lu, N. Murray and E. Rosenthal. </author> <title> (1993) Signed Formulas and Annotated Logics, draft manuscript. Preliminary version in: </title> <booktitle> Proceedings of the International Symposium on Multiple-Valued Logic, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993, </year> <pages> 48-53. 38 </pages>
Reference-contexts: This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. It is similar to work by Lu, Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal <p> This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. It is similar to work by Lu, Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. <p> Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. The work described here is intended as a stepping stone for the development of a more sophisticated procedure, called MULTI OLDT, that will be described in Section 5. <p> In [15], Fitting generalizes results in [34, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [31]. Our work builds upon work by Lu, Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal <p> We have given a detailed comparison of our declarative framework with Fitting's in [31]. Our work builds upon work by Lu, Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. <p> Murray and Rosenthal <ref> [23] </ref> who have independently developed a framework for query processing in GAPs. As stated by Leach and Lu [21], the work of [23] applies to not just the Horn-clause fragment of annotated logic (which is the case in our work), but to the full blown logic. However, [23] does not deal with annotation variables and annotation functions our results apply to those cases as well. Finally, our development of MULTI OLDT-resolution is new. Warren and his co-workers [10, 9] have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation). <p> Acknowledgements. We have benefited from conversations with Mike Kifer, Jim Lu and Terry Swift. We are particularly grateful to Jim Lu for helping us determine the differences between S-resolution and work in <ref> [23] </ref>.
Reference: [24] <author> J. Lu, A. Nerode and V.S. Subrahmanian. </author> <title> (1993) Hybrid Knowledge Bases, </title> <journal> IEEE Trans. on Knowledge and Data Enginering. </journal> <note> Submitted May 1993, revised Jan. </note> <year> 1994. </year>
Reference: [25] <author> A. Martelli and U. Montanari. </author> <title> (1982) An Efficient Unification Algorithm, </title> <journal> ACM Trans. on Prog. Lang. and Systems, </journal> <volume> 4, 2, </volume> <pages> pps 258-282. </pages>
Reference-contexts: As unification is a well-known linear time problem (cf. Martelli and Montanari <ref> [25] </ref>), it follows immediately that l is linear in the number of symbols in the atoms. It is easy to see that card (R i+1 ) card (R i ) + card ( [i+1] ).
Reference: [26] <author> N. J. Nilsson. </author> <booktitle> (1980) Principles of Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <pages> pp 76-84. </pages>
Reference-contexts: As each path can, by the above lemma, be "truncated" at a finite level, this means that this tree is finite. Hence, there exists a search procedure that searches this space (the well-known A ? algorithm <ref> [26] </ref> can be used) with guaranteed termination. 5.4 Implementation of MULTI OLDT Resolution 5.4.1 Overview Two different data structures are needed for the implementation of dynamic MULTI OLDT-computations; a table and a list of queries. These structures will be referred to as TABLE and QUERY, respectively.
Reference: [27] <author> R. Ramakrishnan. </author> <title> (1991) Magic Templates: A Spellbinding Approach to Logic Programs, </title> <journal> J. of Logic Programming, </journal> <volume> 11, </volume> <pages> pps 189-216. </pages>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [29, 28] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 27] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [28] <author> H. Seki and H. Itoh. </author> <title> (1989) A Query Evaluation Method for Stratified Programs under the Extended CWA, </title> <booktitle> Proc. 5th Intl. Conf./Symp. on Logic Programming (eds. </booktitle> <editor> K. Bowen and R. Kowalski), </editor> <address> pps 195-211. </address>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [33] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki <ref> [29, 28] </ref> and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations [5, 6, 27] are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [29] <author> H. Seki. </author> <title> (1989) On the Power of Alexander Templates, </title> <booktitle> Proc. 8th ACM Symp. on Principles of Database Systems, </booktitle> <address> pps 150-159. </address>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [33] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki <ref> [29, 28] </ref> and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations [5, 6, 27] are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [30] <author> J. Shoenfield. </author> <title> (1967) Mathematical Logic, </title> <publisher> Addison Wesley. </publisher>
Reference-contexts: Interpretation I satisfies a ground annotated atom A : iff I (A). The notion of satisfaction of formulas containing other connectives, such as &; _; and quantifiers 8; 9 is the usual one <ref> [30] </ref>.
Reference: [31] <author> V.S. Subrahmanian. </author> <title> (1994) Amalgamating Knowledge Bases, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 19, 2, </volume> <pages> pps 291-331. </pages>
Reference-contexts: We compare our results with relevant work by other researchers in Section 6. 2 2 Preliminaries In this section, we give a quick overview of GAPs and the amalgamation theory developed in the first of this series of papers <ref> [31] </ref>. 2.1 Overview of GAPs (Generalized Annotated Programs) The GAP framework syntax proposed in [18] is an extension of the logic programming. It has been proposed as a framework within which inconsistencies, temporal information and probabilistic logic can be handled in a uniform way. <p> In this section, we recall, from <ref> [31] </ref>, how the theory of GAPs may be successfully applied to define a new lattice of truth values that forms the basis for a "mediatory" or "supervisory database." To do so, we first define the DNAME lattice; this is the power set, 2 f1;:::;n;mg . <p> the databases in set D i , 1 i n, (jointly) imply that the truth value of A i is at least i , then the mediator will conclude that the truth value of A 0 is at least ." This mode of expressing mediatory information is very rich in <ref> [31] </ref>, it 2 When the databases being integrated are geographically dispersed across a network, it is common to distribute the mediator so that bottlenecks (e.g. due to network problems) do not have a devastating effect. <p> The amalgam of local databases DB 1 ; DB 2 ; DB 3 with the mediatory database M , is found as defined in <ref> [31] </ref>. To do this, D-term annotation in all the clauses in database DB i are set to fig and these modified clauses are added to the amalgam. <p> replacing the annotation terms by their up-sets. 9 Example 1 (Robot Example Revisited) Consider the following rule from DB 2 of the Static Robot example. can lif t (r1; X) : t weight (X; W ) : t & W &lt; 50: The amalgamated form of this, as defined in <ref> [31] </ref>, is can lif t (r1; X) : [f2g; t] weight (X; W ) : [f2g; t] & W &lt; 50: The regular representation of this is: can lif t (r1; X) : [f2g; * t] weight (X; W ) : [f2g; * t] & W &lt; 50: and since * <p> Then, I S-satisfies the S-resolvent of C fl and Q fl k . 2 The following definition from <ref> [31] </ref> is needed for proving the Completeness results for amalgamated knowledge bases. Given an amalgamated knowledge base Q, it is possible to associate with Q, an operator A Q that maps A-interpretations to A-interpretations. Definition 9 [31] Suppose Q is an amalgamated knowledge base. <p> S-resolvent of C fl and Q fl k . 2 The following definition from <ref> [31] </ref> is needed for proving the Completeness results for amalgamated knowledge bases. Given an amalgamated knowledge base Q, it is possible to associate with Q, an operator A Q that maps A-interpretations to A-interpretations. Definition 9 [31] Suppose Q is an amalgamated knowledge base. We may associate with Q, an operator, A Q , that maps A-interpretations to A-interpretations as follows. <p> n+m : [D n+m ; n+m ])g is a ground instance of a clause in Q and for all 1 i n, i I (B i )(D i ) and for all (n + 1) j (n + m), j 6 I (B j )(D j ). 0 0 Subrahmanian <ref> [31] </ref> proved that A Q is monotonic. Hence, A Q has a least fixpoint which is identical to A Q " j for some ordinal j. <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in <ref> [31] </ref>, our framework can express maximal consistency as well. [2, 3] do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework <p> However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in [34, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in <ref> [31] </ref>. Our work builds upon work by Lu, Murray and Rosenthal [23] who have independently developed a framework for query processing in GAPs. <p> In the first of this series of papers <ref> [31] </ref>, it has been shown that certain forms of annotated logic provide a simple language within which mediators can be expressed. In particular, it was shown that 36 the semantics of "local" databases can be viewed as embeddings within the semantics of amalgamated databases. In [31], we did not develop an <p> of this series of papers <ref> [31] </ref>, it has been shown that certain forms of annotated logic provide a simple language within which mediators can be expressed. In particular, it was shown that 36 the semantics of "local" databases can be viewed as embeddings within the semantics of amalgamated databases. In [31], we did not develop an operational theory for query processing in amalgamated KBs. In this paper, we have provided a framework for implementing such a query processing paradigm.
Reference: [32] <author> V.S. Subrahmanian, S. Adali, R. Emery, A. Rajput, T.J. Rogers, and R. Ross. </author> <year> (1994) </year> <month> HERMES: </month>
Reference-contexts: The work being described here is being implemented as part of system called HERMES (Heterogeneous Reasoning and Mediator System) that allows not only for the integration of multiple databases, but also multiple data structures, software packages, and reasoning paradigms <ref> [32] </ref>. Acknowledgements. We have benefited from conversations with Mike Kifer, Jim Lu and Terry Swift. We are particularly grateful to Jim Lu for helping us determine the differences between S-resolution and work in [23].
References-found: 32

