URL: http://www.cs.washington.edu/research/jair/volume5/quinlan96b.ps
Refering-URL: http://www.cs.washington.edu/research/jair/abstracts/quinlan96b.html
Root-URL: 
Email: quinlan@cs.su.oz.au  
Title: Learning First-Order Definitions of Functions  
Author: J. R. Quinlan 
Address: Sydney Sydney 2006 Australia  
Affiliation: Basser Department of Computer Science University of  
Note: Journal of Artificial Intelligence Research 5 (1996) 139-161 Submitted 4/96; published 10/96  
Abstract: First-order learning involves finding a clause-form definition of a relation from examples of the relation and relevant background information. In this paper, a particular first-order learning system is modified to customize it for finding definitions of functional relations. This restriction leads to faster learning times and, in some cases, to definitions that have higher predictive accuracy. Other first-order learning systems might benefit from similar specialization.
Abstract-found: 1
Intro-found: 1
Reference: <author> Bell, S., & Weber, S. </author> <year> (1993). </year> <title> On the close logical relationship between foil and the frameworks of Helft and Plotkin. </title> <booktitle> In Proceedings Third International Workshop on Inductive Logic Programming, Bled, Slovenia, </booktitle> <pages> pp. 127-147. </pages>
Reference: <author> Bergadano, F., & Gunetti, D. </author> <year> (1993). </year> <title> An interactive system to learn functional logic programs. </title> <booktitle> In Proceedings Thirteenth International Joint Conference on Artificial Intelligence, </booktitle> <address> Chambery, France, </address> <pages> pp. 1044-1049. </pages> <address> San Francisco: </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: A clause is grown by repeated specialization, starting with the most general clause 2. Prominent exceptions include focl (Pazzani and Kibler, 1992), filp <ref> (Bergadano and Gunetti, 1993) </ref>, and Foidl (Mooney and Califf, 1995), that allow background relations to be defined extensionally, and Progol (Muggleton, 1995), in which information about all relations can be in non-ground form. 142 Learning First-Order Definitions of Functions head and adding literals to the body until the clause does not
Reference: <author> Bratko, I. </author> <year> (1990). </year> <booktitle> Prolog Programming for Artificial Intelligence (2nd edition). </booktitle> <address> Wokingham, UK: </address> <note> Addison-Wesley. </note> <author> 159 Quinlan Cameron-Jones, R. M., & Quinlan, J. R. </author> <year> (1994). </year> <title> Efficient top-down induction of logic programs. </title> <journal> SIGART, </journal> <volume> 5, </volume> <pages> 33-42. </pages>
Reference-contexts: This is essentially the Datalog language specified by Ullman (1988), except that there is no requirement that all variables in a negated literal appear also in the head or in another unnegated literal; foil interprets not using negation as failure <ref> (Bratko, 1990) </ref>. 3.1 Broad-brush overview As outlined in Figure 1, foil uses the separate-and-conquer method, iteratively learning a clause and removing the tuples in the target relation R covered by the clause until none remain. A clause is grown by repeated specialization, starting with the most general clause 2. <p> 22.4 10.9 last element 3 39 81 0.0 0.0 340 1024 0.5 0.3 reverse 10 40 1560 2.6 0.3 341 115,940 195.9 9.0 left shift 12 39 1561 0.5 0.3 340 115,940 26.6 6.8 translate 14 40 3120 817.9 1.1 341 115,940 495.9 28.0 Table 1: Results on tasks from <ref> (Bratko, 1990) </ref>. * foil is applicable to more learning tasks that ffoil, which is limited to learning definitions of functional relations. * The implementation of ffoil is more complex than that of foil.
Reference: <author> De Raedt, L. (Ed.). </author> <year> (1996). </year> <booktitle> Advances in Inductive Logic Programming. </booktitle> <address> Amsterdam: </address> <publisher> IOS Press. </publisher>
Reference: <author> Dolsak, B., & Muggleton, S. </author> <year> (1992). </year> <title> The application of inductive logic programming to finite element mesh design. </title> <editor> In Muggleton, S. (Ed.), </editor> <booktitle> Inductive Logic Programming, </booktitle> <pages> pp. 453-472. </pages> <address> London: </address> <publisher> Academic Press. </publisher>
Reference: <author> Karalic, A. </author> <year> (1995). </year> <title> First Order Regression. </title> <type> Ph.D. thesis, </type> <institution> Faculty of Electrical Engineering and Computer Science, University of Ljubljana, Slovenia. </institution>
Reference-contexts: Table 5 also shows published results on the mesh task for three other relational learning systems. The numbers of edges for which mfoil and Golem predict the correct number of intervals are taken from (Lavrac and Dzeroski, 1994). These are both general relational learning systems like foil, but fors <ref> (Karalic, 1995) </ref>, like ffoil, is specialized for learning functional relations of this kind.
Reference: <author> Langley, P., & Simon, H. A. </author> <year> (1995). </year> <title> Applications of machine learning and rule induction. </title> <journal> Communications of the ACM, </journal> <volume> 38 (11), </volume> <pages> 55-64. </pages>
Reference: <author> Lavrac, N., & Dzeroski, S. </author> <year> (1994). </year> <title> Inductive Logic Programming. </title> <publisher> London: Ellis Horwood. </publisher>
Reference-contexts: Table 5 also shows published results on the mesh task for three other relational learning systems. The numbers of edges for which mfoil and Golem predict the correct number of intervals are taken from <ref> (Lavrac and Dzeroski, 1994) </ref>. These are both general relational learning systems like foil, but fors (Karalic, 1995), like ffoil, is specialized for learning functional relations of this kind.
Reference: <author> Ling, C. X. </author> <year> (1994). </year> <title> Learning the past tense of english verbs: the symbolic pattern associator versus connectionist models. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 1, </volume> <pages> 209-229. </pages>
Reference-contexts: The single background relation split (A,B,C) shows all ways in which word A can be split into two non-empty substrings B and C. Following the experiment reported in <ref> (Ling, 1994) </ref>, a corpus of 1391 verbs is used to generate ten randomly-selected learning tasks, each containing 500 verbs from which a definition is learned and 500 different verbs used to test the definition.
Reference: <editor> Michie, D., Spiegelhalter, D. J., & Taylor, C. C. (Eds.). </editor> <year> (1994). </year> <title> Machine Learning, Neural and Statistical Classification. </title> <address> Hertfordshire, UK: </address> <publisher> Ellis Horwood. </publisher>
Reference: <author> Mooney, R. J., & Califf, M. E. </author> <year> (1995). </year> <title> Induction of first-order decision lists: results on learning the past tense of english verbs. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 3, </volume> <pages> 1-24. </pages>
Reference-contexts: A clause is grown by repeated specialization, starting with the most general clause 2. Prominent exceptions include focl (Pazzani and Kibler, 1992), filp (Bergadano and Gunetti, 1993), and Foidl <ref> (Mooney and Califf, 1995) </ref>, that allow background relations to be defined extensionally, and Progol (Muggleton, 1995), in which information about all relations can be in non-ground form. 142 Learning First-Order Definitions of Functions head and adding literals to the body until the clause does not cover any tuples known not to
Reference: <author> Muggleton, S. (Ed.). </author> <year> (1992). </year> <title> Inductive Logic Programming. </title> <publisher> London: Academic Press. </publisher>
Reference-contexts: A quite different justification for adding a literal is to introduce new variables that may be needed in the final clause. Determinate literals are based on an idea introduced 144 Learning First-Order Definitions of Functions by Golem <ref> (Muggleton and Feng, 1992) </ref>. A determinate literal is one that introduces new variables so that the new partial clause has exactly one binding for each binding in the current clause, and at most one binding for each binding. <p> In practical applications with numerous background relations, the number of possible literals L that could be added at each step grows exponentially with the number of variables in the partial clause. foil employs some further heuristics to limit this space, such as Golem's bound on the depth of a variable <ref> (Muggleton and Feng, 1992) </ref>. More importantly, some regions of the literal space can be pruned without examination because they can be shown to contain neither determinate literals, nor literals with higher gain than the best gainful literal found so far. * More complete search. <p> In common with other ILP systems such as Golem <ref> (Muggleton and Feng, 1992) </ref>, the latter are used to detect when a partial clause is still too general. These can be specified to foil directly or, more commonly, are derived under the closed world assumption that, with respect to the vocabulary, all tuples in R have been given.
Reference: <author> Muggleton, S. </author> <year> (1995). </year> <title> Inverse entailment and progol. </title> <journal> New Generation Computing, </journal> <volume> 13, </volume> <pages> 245-286. </pages>
Reference-contexts: A clause is grown by repeated specialization, starting with the most general clause 2. Prominent exceptions include focl (Pazzani and Kibler, 1992), filp (Bergadano and Gunetti, 1993), and Foidl (Mooney and Califf, 1995), that allow background relations to be defined extensionally, and Progol <ref> (Muggleton, 1995) </ref>, in which information about all relations can be in non-ground form. 142 Learning First-Order Definitions of Functions head and adding literals to the body until the clause does not cover any tuples known not to belong to R. <p> Like ffoil and foil, both Golem (Muggleton and 152 Learning First-Order Definitions of Functions Task foil ffoil Ackermann's function 12.3 0.2 greatest common divisor 237.5 1.2 Table 4: Times (sec) for arithmetic functions. Feng, 1992) and Progol (release 4.1) <ref> (Muggleton, 1995) </ref> are implemented in C, so that timing comparisons are meaningful. Furthermore, both systems include quicksort among their demonstration learning tasks, so it is reasonable to assume that the parameters that control these systems have been set to appropriate values. <p> It is interesting to speculate that a similar improvement might well be obtainable by customizing other general first-order systems such as Progol <ref> (Muggleton, 1995) </ref> for learning functional relations. Results from the quicksort experiments suggest that ffoil scales better than general first-order systems when learning functional relations, and those from the past tense and mesh design experiments demonstrate its effectiveness in noisy domains. Nevertheless, it is hoped to improve ffoil in several ways.
Reference: <author> Muggleton, S., & Feng, C. </author> <year> (1992). </year> <title> Efficient induction of logic programs. </title> <editor> In Muggleton, S. (Ed.), </editor> <booktitle> Inductive Logic Programming, </booktitle> <pages> pp. 281-298. </pages> <address> London: </address> <publisher> Academic Press. </publisher>
Reference-contexts: A quite different justification for adding a literal is to introduce new variables that may be needed in the final clause. Determinate literals are based on an idea introduced 144 Learning First-Order Definitions of Functions by Golem <ref> (Muggleton and Feng, 1992) </ref>. A determinate literal is one that introduces new variables so that the new partial clause has exactly one binding for each binding in the current clause, and at most one binding for each binding. <p> In practical applications with numerous background relations, the number of possible literals L that could be added at each step grows exponentially with the number of variables in the partial clause. foil employs some further heuristics to limit this space, such as Golem's bound on the depth of a variable <ref> (Muggleton and Feng, 1992) </ref>. More importantly, some regions of the literal space can be pruned without examination because they can be shown to contain neither determinate literals, nor literals with higher gain than the best gainful literal found so far. * More complete search. <p> In common with other ILP systems such as Golem <ref> (Muggleton and Feng, 1992) </ref>, the latter are used to detect when a partial clause is still too general. These can be specified to foil directly or, more commonly, are derived under the closed world assumption that, with respect to the vocabulary, all tuples in R have been given.
Reference: <author> Muggleton, S., King, R. D., & Sternberg, M. J. </author> <year> (1992). </year> <title> Protein secondary structure prediction using logic-based machine learning. </title> <journal> Protein Engineering, </journal> <volume> 5, </volume> <pages> 646-657. </pages>
Reference-contexts: A quite different justification for adding a literal is to introduce new variables that may be needed in the final clause. Determinate literals are based on an idea introduced 144 Learning First-Order Definitions of Functions by Golem <ref> (Muggleton and Feng, 1992) </ref>. A determinate literal is one that introduces new variables so that the new partial clause has exactly one binding for each binding in the current clause, and at most one binding for each binding. <p> In practical applications with numerous background relations, the number of possible literals L that could be added at each step grows exponentially with the number of variables in the partial clause. foil employs some further heuristics to limit this space, such as Golem's bound on the depth of a variable <ref> (Muggleton and Feng, 1992) </ref>. More importantly, some regions of the literal space can be pruned without examination because they can be shown to contain neither determinate literals, nor literals with higher gain than the best gainful literal found so far. * More complete search. <p> In common with other ILP systems such as Golem <ref> (Muggleton and Feng, 1992) </ref>, the latter are used to detect when a partial clause is still too general. These can be specified to foil directly or, more commonly, are derived under the closed world assumption that, with respect to the vocabulary, all tuples in R have been given.
Reference: <author> Pazzani, M. J., & Kibler, D. </author> <year> (1992). </year> <title> The utility of knowledge in inductive learning. </title> <journal> Machine Learning, </journal> <volume> 9, </volume> <pages> 57-94. </pages>
Reference-contexts: A clause is grown by repeated specialization, starting with the most general clause 2. Prominent exceptions include focl <ref> (Pazzani and Kibler, 1992) </ref>, filp (Bergadano and Gunetti, 1993), and Foidl (Mooney and Califf, 1995), that allow background relations to be defined extensionally, and Progol (Muggleton, 1995), in which information about all relations can be in non-ground form. 142 Learning First-Order Definitions of Functions head and adding literals to the body <p> Related Research Mooney and Califf's (1995) recent system Foidl has had a strong influence on the development of ffoil. Three features that together distinguish Foidl from earlier systems like foil are: * Following the example of focl <ref> (Pazzani and Kibler, 1992) </ref>, background relations are defined intensionally by programs rather than extensionally as tuple sets.
Reference: <author> Quinlan, J. R. </author> <year> (1990). </year> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5, </volume> <pages> 239-266. </pages>
Reference-contexts: This relational learning task is described in more detail in the following section. Several algorithms for relational learning have been developed recently, and Section 3 introduces one such system called foil <ref> (Quinlan, 1990) </ref>. While foil can be used with relations of any kind, one particularly common use of relations is to represent functions. Changes to foil that in effect customize it for learning functional relations are outlined in Section 4.
Reference: <author> Quinlan, J. R. </author> <year> (1991). </year> <title> Determinate literals in inductive logic programming. </title> <booktitle> In Proceedings Twelfth International Joint Conference on Artificial Intelligence, </booktitle> <address> Sydney, </address> <pages> pp. 746-750. </pages> <address> San Francisco: </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The four learning systems are evaluated using four sets of training examples, obtained by varying the maximum length S of the lists and the size A of the alphabet of non-repeating elements that can appear in the lists, as in <ref> (Quinlan, 1991) </ref>. Denoting each set by a pair [S,A], the four datasets are [3,3], [3,4], [4,4], and [4,5]. The total numbers of possible bindings for these tasks, 256, 1681, 4225, and 42,436 respectively, span two orders of magnitude.
Reference: <author> Quinlan, J. R. </author> <year> (1994). </year> <title> Past tenses of verbs and first-order learning. </title> <booktitle> In Proceedings AI'94 Seventh Australian Joint Conference on Artificial Intelligence, </booktitle> <address> Armidale, Australia, </address> <pages> pp. </pages> <month> 13-20. </month> <title> Singapore: World Scientific. 160 Learning First-Order Definitions of Functions Quinlan, </title> <editor> J. R., & Cameron-Jones, R. M. </editor> <year> (1993). </year> <title> Foil: a midterm report. </title> <booktitle> In Proceedings Eu-ropean Conference on Machine Learning, Vienna, </booktitle> <pages> pp. 3-20. </pages> <address> Berlin: </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> Quinlan, J. R., & Cameron-Jones, R. M. </author> <year> (1995). </year> <title> Induction of logic programs: foil and related systems. </title> <journal> New Generation Computing, </journal> <volume> 13, </volume> <pages> 287-312. </pages>
Reference: <author> Rouveirol, C. </author> <year> (1994). </year> <title> Flattening and saturation: two representation changes for generalization. </title> <journal> Machine Learning, </journal> <volume> 14, </volume> <pages> 219-232. </pages>
Reference: <author> Srinivasan, A., Muggleton, S. H., Sternberg, M. J. E., & King, R. D. </author> <year> (1996). </year> <title> Theories for mutagenicity: a study in first-order and feature-based induction. </title> <journal> Artificial Intelligence, </journal> <volume> 84, </volume> <pages> 277-299. </pages>
Reference: <author> Ullman, J. D. </author> <year> (1988). </year> <title> Principles of Database and Knowledge-Base Systems. </title> <address> Rockville, MD: </address> <publisher> Computer Science Press. </publisher>
Reference: <author> Webb, G. I., & Brkic, N. </author> <year> (1993). </year> <title> Learning decision lists by prepending inferred rules. </title> <booktitle> In Proceedings Australian Workshop on Machine Learning and Hybrid Systems, </booktitle> <address> Melbourne, Australia, </address> <pages> pp. 6-10. </pages>
Reference: <author> Zelle, J. M., & Mooney, R. J. </author> <year> (1993). </year> <title> Combining foil and ebg to speed-up logic programs. </title> <booktitle> In Proceedings Thirteenth International Joint Conference on Artificial Intelligence, </booktitle> <address> Chambery, France, </address> <pages> pp. 1106-1111. </pages> <address> San Francisco: </address> <publisher> Morgan Kaufmann. </publisher> <pages> 161 </pages>
Reference-contexts: Instead, it may be necessary to describe learning input by relations, where a relation is just a set of tuples of constants, and to represent what is learned in a first-order language. Four examples of practical learning tasks of this kind are: * Speeding up logic programs <ref> (Zelle and Mooney, 1993) </ref>. The idea here is to learn a guard for each nondeterministic clause that inhibits its execution unless it will lead to a solution. Input to the learner consists of a Prolog program and one or more execution traces.
References-found: 25

