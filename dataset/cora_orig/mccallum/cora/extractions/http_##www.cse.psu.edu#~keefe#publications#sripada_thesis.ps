URL: http://www.cse.psu.edu/~keefe/publications/sripada_thesis.ps
Refering-URL: http://www.cse.psu.edu/~keefe/star-dbs.html
Root-URL: http://www.cse.psu.edu
Title: THE DESIGN OF A MULTIVERSION DATABASE FILE MANAGER FOR MULTILEVEL SECURE SYSTEMS  
Degree: A Thesis in Computer Science and Engineering by Ram Prasad Sripada c 1997 Ram Prasad Sripada Submitted in Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: August 1997  
Affiliation: The Pennsylvania State University The Graduate School Department of Computer Science and Engineering  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young, </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference. USENIX, </booktitle> <year> 1986. </year>
Reference-contexts: It also supports the retrieval of log records for the purpose of recovery. DTOS [15] is an experimental prototype operating system developed at Secure Computing Corporation consistent with the B3 level of assurance [7]. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel <ref> [1] </ref> [10] and provides policy-based control over all Mach services [14]. The Security Enhanced Lites server provides a UNIX operating system environment and enforces the security decisions made in the Security Server. The file system is extended to attach security policy relevant labels to all files in the system.
Reference: [2] <author> D. E. Bell and L. J. LaPadula, </author> <title> Secure computer systems: Unified exposition and multics interpretations. </title> <type> Technical Report MTR-2997, </type> <institution> Mitre Corp., </institution> <month> March </month> <year> 1976. </year>
Reference-contexts: The mandatory security policy allows information to flow from a subject s 1 to another subject s 2 only if the classification level of s 2 dominates the classification level of s 1 . The Bell and LaPadula model <ref> [2] </ref> is a concrete method of enforcing the more abstract policy.
Reference: [3] <author> P.A. Bernstein, V.Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA 1987. </address>
Reference-contexts: This reduces complexity and allows easier adoption of multiversioned databases. This in-memory structure is further analyzed later in Section 3.2.3. A brief outline for storing only timestamp information in a memory resident table is suggested in Bernstein et al. <ref> [3] </ref>. 3.2.1 Organization of the Version Table A hash table is used for storing the version information. Hashing is done in such a way that all tuples lying in the same page would have their information stored in the same hash chain.
Reference: [4] <author> Paul Bober, and Michael Carey, </author> <title> On Mixing Queries and Transactions via Multi-version Locking. </title> <booktitle> In Proceedings of the Eigth IEEE Data Engineering Conference, </booktitle> <year> 1992. </year>
Reference-contexts: Version Chain The purpose of retaining earlier versions is to make them available for queries. However, they are retained not for the sake of satisfying temporal queries but for con-currency purpose. This type of versioning is also called transient versioning <ref> [4] </ref>. Queries are allowed to view a prior version. When a query (with timestamp ts (T )) wishes to access a data item, it is provided with the most recent version with write timestamp less than or equal to ts (T ). <p> So, instead of just one disk I/O for retrieving a version, chaining versions can lead to additional disk I/O. Instead it is suggested in <ref> [4] </ref> that part of the version pool reside in the data page itself. This is referred to as on-page caching. In that case there would be a higher chance that the appropriate version for the query lies in the same page as the 10 primary version. <p> In contrast, the write all policy appends all of the versions in a page's cache to the version pool at once. We adopt the write-one policy in our work. On-page caching was shown to improve throughput of transactions <ref> [4] </ref>. Simulations performed as part of that work suggests that caching leads to smaller version pool files. More importantly, larger cache size allows queries to complete faster. This is to be expected as larger cache sizes allow more versions to be found in the data page itself. <p> In another case, a data page could be updated frequently. But due to limited size of cache, versions have to be pushed to version pool even if space is available on the data page. Thus, dynamic on-page cache is desirable. Experimental results presented in <ref> [4] </ref> indicate that queries execute faster with bigger cache sizes. After a certain cache size, it was noticed that accesses to version pool file were rare. So, by making the on-page cache dynamic it is possible to increase cache size provided space exists on the page. <p> Defining the obsolete timestamp, hence, now depends on the size of the version table. However, due to lack of enough information (refer to section 2.4) in a secure data 27 base to exactly determine the obsolete timestamp ( See <ref> [4] </ref> on how it can be determined exactly) some heuristic scheme must be used to determine the obsolete timestamp.
Reference: [5] <author> Paul Bober, and Michael Carey, </author> <title> Indexing Alternatives for Multiversion Locking. </title> <type> Technical Report # 1184, </type> <institution> University of Wisconsin - Madison, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: This saves expensive disk I/O. 11 2.3 Indexing Alternatives Even with on-page caching it is possible that a query has to perform several I/O operations before actually reading the appropriate version. To mitigate this Bober <ref> [5] </ref> et al. considered alternatives for managing version location information. For example, a version directory stored in the same page as the primary version can hold all the information about the location and timestamp values for rest of the versions. <p> Bober <ref> [5] </ref> focused on the need to modify the page layout to optimize for the case of version management. We attempt to show that better performance might still be possible with the use of standard designs. We feel that modifiability should be a important design issue.
Reference: [6] <author> A. Chan, S. Fox, W. Lin, A. Nori, and D. Ries, </author> <title> The Implementation of an Integrated Concurrency Control and recovery Scheme. </title> <booktitle> In Proceedings 1982 ACM SIGMOD Conference, </booktitle> <year> 1982. </year>
Reference-contexts: Early work related to mul-tiversioning was done in the Prime system in early 1980's [8]. The methods proposed soon found applications in commercial products <ref> [6] </ref>. Versions are created by update transactions. The update operation results in the creation of a new version of the tuple containing the update. However, the previous tuple is also retained. <p> In the following sections issues related to storage, retrieval and collection of these versions are discussed. 2.2 On-page Caching We assume that all primary versions are stored in the main database and the rest of the versions are stored in a separate file called version pool file as proposed in <ref> [6] </ref>. As shown in Figure 2.1, the location of a secondary version is found in the version prior to it in the version chain. In this design, a query has to first retrieve the primary version to find out where the secondary version resides and then retrieve the secondary version.
Reference: [7] <institution> Department of Defense Computer Security Center, Department of Defense Trusted Computer Systems Evaluation Criteria, </institution> <month> December </month> <year> 1985. </year> <month> 49 </month>
Reference-contexts: A DBMS consists of a collection of hardware and software modules that support operations on the database. Because databases consist of data of varying degrees of sensitivity, it is important that all accesses to the database be performed without jeopardizing the sensitivity of the information. Multilevel security (MLS) policies <ref> [7] </ref> are often adopted to control access to secure database systems [18]. Database systems enforcing MLS policies are referred to as MLS DBMS. In the next section, multilevel security is presented briefly. Then, the architecture of the star-DBS prototype is presented and the role of the file manager is explained. <p> It also supports the retrieval of log records for the purpose of recovery. DTOS [15] is an experimental prototype operating system developed at Secure Computing Corporation consistent with the B3 level of assurance <ref> [7] </ref>. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [1] [10] and provides policy-based control over all Mach services [14]. The Security Enhanced Lites server provides a UNIX operating system environment and enforces the security decisions made in the Security Server.
Reference: [8] <author> D. DuBourdieu, </author> <title> Implementation of Distributed Transaction. </title> <booktitle> In Proceedings of 6th Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <year> 1982. </year>
Reference-contexts: Finally, Chapter 5 presents conclusions and suggests future work. 7 Chapter 2 Multiversion Databases 2.1 Introduction The initial motivation for development of multiversion databases was to reduce data contention between queries and update transactions. Early work related to mul-tiversioning was done in the Prime system in early 1980's <ref> [8] </ref>. The methods proposed soon found applications in commercial products [6]. Versions are created by update transactions. The update operation results in the creation of a new version of the tuple containing the update. However, the previous tuple is also retained.
Reference: [9] <author> J. Goguen and J. Meseguer, </author> <title> Security policies and security models. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy ,IEEE, </booktitle> <month> April </month> <year> 1982, </year> <pages> pages 11-20. </pages>
Reference-contexts: With repeated trials to acquire this lock at some preset intervals the transactions can communicate. The bandwidth of any such channels must be determined and limited depending upon the degree of assurance required by the system. The principle of noninterference <ref> [9] </ref> imposes the constraint that system outputs visible to dominated subjects should not depend on the presence or actions of non-dominated subjects. In other words, at any given level in the security poset, the nature and amount of activity at other levels in the poset should be transparent (imperceptible). <p> TS-3. ts (T i ) &gt; ts (T j ) for all T i and T j such that level (T j ) level (T i ) and T i started after T j . 4. TS-4. Timestamp generation satisfies the MLS property <ref> [9] </ref> . 3.3.1 The Concurrency Control Protocol Below the concurrency control protocol is presented. First, the rules guiding access to versions are shown. 1. T: Search k = w.
Reference: [10] <author> David Golub, Randall Dean, Alessandro Forin, and Richard Rashid, </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the Summer 1990 USENIX Conference. USENIX, </booktitle> <year> 1990. </year>
Reference-contexts: It also supports the retrieval of log records for the purpose of recovery. DTOS [15] is an experimental prototype operating system developed at Secure Computing Corporation consistent with the B3 level of assurance [7]. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [1] <ref> [10] </ref> and provides policy-based control over all Mach services [14]. The Security Enhanced Lites server provides a UNIX operating system environment and enforces the security decisions made in the Security Server. The file system is extended to attach security policy relevant labels to all files in the system.
Reference: [11] <author> Jim Gray and Andreas Reuter, </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA 1993. </address>
Reference-contexts: This value can be averaged over time also. Then X can be set to some predetermined percentage of that time. Based on threshold values for Growth Rate, different values can be assigned. 29 3.3 Concurrency Control The protocol outlined below is based on the key-range locking scheme [16], <ref> [11] </ref>, and multiversion timestamp based schedulers [19], [13]. However, no explicit locking is attempted here. Transactions performing an operation on the database verify that they can proceed further without violating the integrity of the database. These operations are search, insert and delete. This action is referred to as verification. <p> Unless otherwise stated, assume k i is the maximum key value that satisfies the condition k i w. Traversal along the B + -tree both across the different B + -tree levels and in the same level is done using latch-coupling <ref> [11] </ref>. Also, when traversing across the same B + -tree level pages 31 are pinned in the same order, that is, from left to right. This prevents deadlocks while traversing the same level. Transactions with ts (T ) &lt; OT S are aborted immediately. <p> Set dts (V ) = ts (T ) in the version table. 3.3.2 Proof of View-serializability In this section we present the proof that the protocol outlined above can prevent the phantom problem. Phantoms are usually prevented in a B + -tree using range-locking schemes <ref> [11] </ref>. Adopting range-lock based concurrency schemes in multiversion timestamp ordered schedules present unique challenges. In our protocol instead of acquiring a lock on a range the timestamp on the range is updated. Also, the issue of security complicates the issues further as queries reading down cannot update the timestamp values.
Reference: [12] <author> Weigang Huang, </author> <title> B + -tree Index Management on Multilevel Secure Multiversion Database System, M.S. </title> <type> Thesis, </type> <institution> Dept. of Computer Science and Eng., The Pennsyl-vania State University, </institution> <month> January </month> <year> 1995. </year>
Reference: [13] <author> T. F. Keefe and W. T. Tsai, </author> <title> A Multiversion Transaction Scheduler for Centralized Multilevel Secure Database Systems. </title> <type> Technical Report TR-93-116, </type> <institution> Department of Computer Science and Engineering, The Pennsylvania State University, </institution> <month> January, </month> <year> 1993. </year>
Reference-contexts: Within the same level, transactions can interfere without violating security. This forms the basis for adoption of multiversioned databases in our system. However, complex protocols are necessary for integrating multiversion databases with multilevel security. For issues related to timestamp generation refer to <ref> [13] </ref>. Concurrency control with emphasis on security is also discussed there. <p> Issues related to the storage of versions is addressed first. Here, dynamic on-page caching, hot spots, and page-layout are discussed. Retrieval of versions is addressed next. A comprehensive outline of the proposed in-memory structure is presented. Finally, a concurrency protocol extended from <ref> [13] </ref> to handle phantoms is presented in detail. 3.1 Storage of Versions As a general principle, reduced storage overhead for both the main database file and the version pool file is desirable. However the issue is closely tied to several implementation details. Techniques like on-page caching help in this regard. <p> Then X can be set to some predetermined percentage of that time. Based on threshold values for Growth Rate, different values can be assigned. 29 3.3 Concurrency Control The protocol outlined below is based on the key-range locking scheme [16], [11], and multiversion timestamp based schedulers [19], <ref> [13] </ref>. However, no explicit locking is attempted here. Transactions performing an operation on the database verify that they can proceed further without violating the integrity of the database. These operations are search, insert and delete. This action is referred to as verification. <p> Also, a mechanism is associated with each range to delay a transaction if some other transaction is already active in that range. Below are the properties followed by the timestamp generator <ref> [13] </ref>. 1. TS-1. ts (T ) 6= ts (T 0 ) for T 6= T 0 and ts (T ) &gt; 0 for all transactions T and T'. 30 2. <p> But this contradicts that ts (T 0 ) ts (A). By the argument above we have shown that p = q. Thus the full schedules provided by the protocol restricted to search, insert and delete operations are view-serializable. 2 The above proof together with the proof in <ref> [13] </ref> shows that the scheduler prevents the phantom problem. Implementation of range based concurrency control schemes fits well with a B + -tree implementation as the tuples are already sorted by key value. 35 Chapter 4 Implementation In this Chapter the interface provided by the file manager is described.
Reference: [14] <author> Spencer E. Minear, </author> <title> Providing Policy Control Over Object Operations in a Mach Based System. </title> <booktitle> In USENIX, </booktitle> <pages> pages 1-15. </pages> <institution> Secure Computing Corporation, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: DTOS [15] is an experimental prototype operating system developed at Secure Computing Corporation consistent with the B3 level of assurance [7]. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [1] [10] and provides policy-based control over all Mach services <ref> [14] </ref>. The Security Enhanced Lites server provides a UNIX operating system environment and enforces the security decisions made in the Security Server. The file system is extended to attach security policy relevant labels to all files in the system.
Reference: [15] <author> Spencer E.Minear, </author> <title> DTOS Kernel and Security Server Software Design Document. Secure Computing Corporation Software Design Document, </title> <month> January </month> <year> 1996. </year> <month> 50 </month>
Reference-contexts: The log manager (LGM) writes uninterpreted undo/redo records to the log on behalf of RMs, writes commit and abort records generated by the TM and controls the flushing of log records to disk. It also supports the retrieval of log records for the purpose of recovery. DTOS <ref> [15] </ref> is an experimental prototype operating system developed at Secure Computing Corporation consistent with the B3 level of assurance [7]. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [1] [10] and provides policy-based control over all Mach services [14].
Reference: [16] <author> C. Mohan, ARIES/KVL: </author> <title> A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990, </year> <pages> pp 392-405. </pages>
Reference-contexts: This value can be averaged over time also. Then X can be set to some predetermined percentage of that time. Based on threshold values for Growth Rate, different values can be assigned. 29 3.3 Concurrency Control The protocol outlined below is based on the key-range locking scheme <ref> [16] </ref>, [11], and multiversion timestamp based schedulers [19], [13]. However, no explicit locking is attempted here. Transactions performing an operation on the database verify that they can proceed further without violating the integrity of the database. These operations are search, insert and delete. This action is referred to as verification.
Reference: [17] <author> T. Nakamura and T. </author> <title> Mizoguchi An Analysis of Storage Utilization Factor in Block Split Data Structuring Scheme. </title> <booktitle> In Proceedings of 4th International Conference on Very Large Database Systems, </booktitle> <year> 1978, </year> <pages> pp 489 - 495. </pages>
Reference-contexts: This is also desirable as seen from above. Within the context of on-page caching a B + -tree is more suitable than a heap file. In a B + -tree, the expected case is a partially full page. Studies <ref> [17] </ref> cite average 16 utilization to be between 60 -70% . This being the case, the remaining space can be used to hold the on-page cache. 3.1.1.1 Cache Replacement In fixed size on-page cache schemes versions are pushed to the version pool file once the cache is full.
Reference: [18] <author> LouAnna Notargiacomo, </author> <title> Architectures for MLS database Management Systems, Information Security, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1987. </year>
Reference-contexts: Because databases consist of data of varying degrees of sensitivity, it is important that all accesses to the database be performed without jeopardizing the sensitivity of the information. Multilevel security (MLS) policies [7] are often adopted to control access to secure database systems <ref> [18] </ref>. Database systems enforcing MLS policies are referred to as MLS DBMS. In the next section, multilevel security is presented briefly. Then, the architecture of the star-DBS prototype is presented and the role of the file manager is explained.
Reference: [19] <author> Christos Papadimitriou, </author> <title> The Theory of Database Concurrency Control. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD 1986 </address>
Reference-contexts: Then X can be set to some predetermined percentage of that time. Based on threshold values for Growth Rate, different values can be assigned. 29 3.3 Concurrency Control The protocol outlined below is based on the key-range locking scheme [16], [11], and multiversion timestamp based schedulers <ref> [19] </ref>, [13]. However, no explicit locking is attempted here. Transactions performing an operation on the database verify that they can proceed further without violating the integrity of the database. These operations are search, insert and delete. This action is referred to as verification.
Reference: [20] <author> Vikram Pesati, </author> <title> The Design and Implementation of Multilevel Secure Log Manager, M.S. </title> <type> Paper, </type> <institution> Dept. of Computer Science and Eng., The Pennsylvania State University, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: The RM makes pin/unpin requests to the buffer manager (BM). It also 5 coordinates logging with page flushes to ensure recoverability. Each RM is multithreaded allowing it to service multiple clients concurrently. The log manager <ref> [20] </ref> is a trusted component. It provides logging related functions to all security levels. The log manager (LGM) writes uninterpreted undo/redo records to the log on behalf of RMs, writes commit and abort records generated by the TM and controls the flushing of log records to disk.
Reference: [21] <author> A. Raghavan, T. K. Rengarajan, </author> <title> Database Availability for Transaction Processing. </title> <note> In Digital Technical Journal 3(1), </note> <month> Winter </month> <year> 1991. </year>
Reference: [22] <author> D. P. Reed and R. K. </author> <title> Kanodia Synchronization with Eventcounts and Sequencers. </title> <journal> In Communications to ACM Vol. </journal> <volume> 22 No. 2, </volume> <month> February </month> <year> 1979, </year> <pages> pp 115-123. </pages>
Reference-contexts: So, access to this table must be synchronized. Transactions at higher level are forbidden to write anything to this table by the MAC policy. So, they would act as readers, and the transaction at the same level would act as writers. Implementation of this synchronization was done using event-counts <ref> [22] </ref>. Also, for higher level transactions to be able to access this table the memory corresponding to this table has to be shared. Whenever a new RM logs in at a particular level it would ask the TBM for all levels that are active below it. <p> The Version Table 37 table is accessed by non-dominated security levels a secure reader-writers solution is implemented using eventcounts <ref> [22] </ref>. Transactions at the same level can conflict with each other and for synchronizing accesses to the table a mutex lock is associated with each index. 4.2 Interface An outline of the interface and the functions performed is listed below.
Reference: [23] <author> Qinhua Wang, </author> <title> Multilevel Relational Model for Multilevel Secure Database Management System, M.S. </title> <type> Thesis, </type> <institution> Dept. of Computer Science and Eng., The Pennsylvania State University, </institution> <month> August </month> <year> 1997. </year> <month> 51 </month>
Reference-contexts: All functions except push version () return the status after execution. All possible exit statuses are enumerated. push version () returns the tuple id where the tuple was pushed in the version pool file. This interface was developed along with Qinhua Wang who implemented the query-processor <ref> [23] </ref>. 40 4.3 Experimental Results The file manager was implemented on DTOS operating system running on a Pentium processor and consists of approximately 5000 lines written in C. Experiments have been conducted on the prototype to evaluate the advantages of this design.
Reference: [24] <author> A. C. Warner and T. F. Keefe, </author> <title> Version Pool Management in a Multilevel Secure Multiversion Transaction Manager. </title> <booktitle> In Proceedings of IEEE Symposium on Research in Security and Privacy, </booktitle> <address> Oakland, CA, </address> <month> May </month> <year> 1995, </year> <pages> pp 169-182. </pages>
Reference-contexts: Since, it is not possible to exactly determine this value each level maintains an estimate of the obsolete 13 timestamp. Transactions have to check that their timestamp value is higher than the obsolete timestamp. Otherwise they would have to be aborted. Collection of versions under MLS is detailed in <ref> [24] </ref>. 14 Chapter 3 Design This chapter examines the design issues involved in the development of the file manager. Issues related to the storage of versions is addressed first. Here, dynamic on-page caching, hot spots, and page-layout are discussed. Retrieval of versions is addressed next.
References-found: 24

