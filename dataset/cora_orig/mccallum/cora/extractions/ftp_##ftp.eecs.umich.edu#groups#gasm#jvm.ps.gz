URL: ftp://ftp.eecs.umich.edu/groups/gasm/jvm.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: boerger@di.unipi.it  wolfram@informatik.uni-ulm.de  
Phone: 2  
Title: Defining the Java Virtual Machine as Platform for Provably Correct Java Compilation  
Author: Egon Borger and Wolfram Schulte 
Address: I-56125 Pisa, Italy  D-89069 Ulm, Germany  
Affiliation: 1 Universita di Pisa, Dipartimento di Informatica,  Universitat Ulm, Fakultat fur Informatik,  
Abstract: We provide concise abstract code for running the Java Virtual Machine (JVM) to execute compiled Java programs, and define a general compilation scheme of Java programs to JVM code. These definitions, together with the definition of an abstract interpreter of Java programs given in our previous work [3], allow us to prove that any compiler that satisfies the conditions stated in this paper compiles Java code correctly. In addition we have validated our JVM and compiler specification through experimentation. The modularity of our definitions for Java, the JVM and the compilation scheme exhibit orthogonal language, machine and compiler components, which fit together and provide the basis for a stepwise and provably correct design-for-reuse. As a by-product we provide a challenging realistic case study for mechanical verification of a compiler correctness proof. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> E. Borger and W. Schulte. </author> <title> Defining the Java Virtual Machine as platform for provably correct Java compilation. </title> <type> Technical report, </type> <institution> Universitat Ulm, Fakultat fur Informatik. Ulm, Germany, </institution> <year> 1998. </year>
Reference-contexts: These features are the object of further refinements of the JVM model presented here. For proof details, the instruction refinement, an extensive bibliography and the discussion of related work we refer the interested reader to an extended version of this paper <ref> [1] </ref>. 2 JVM I and the Compilation of Java I Programs For the specification of Java, the JVM and the proof machinery, we use Abstract State Machines (ASMs). ASM specifications have a simple mathematical foundation [5], which justifies their intuitive understanding as "pseudo code" over abstract data. <p> It allows us to restrict our attention to a small set of JVM instructions (or better instruction classes) without losing the generality of our model with respect to the JVM specification [6]. The extended version of this paper <ref> [1] </ref> shows how to refine these parameterized instruction to JVM's real ones. 2.2 Compilation of Java I Programs to JVM I Code This section defines the compiling function from Java I to JVM I code. More efficient compilation schemes can be introduced but we leave optimizations for further refinement steps. <p> In particular it allowed us to prove the correctness of a general scheme for compiling Java programs into JVM code. Additionally, we have validated our work by a successful implementation in the functional programming language Haskell. The extended version of this paper <ref> [1] </ref> includes the proof details, the instruction refinement, an extensive bibliography and the discussion of related work. In an accompanying study [2] we refine the present JVM model to a defensive JVM, where we also isolate the bytecode verifier and the resolution component (including dynamic loading) of the JVM.
Reference: 2. <author> E. Borger and W. Schulte. </author> <title> A modular design for the Java VM architecture. </title> <editor> In E. Borger, editor, </editor> <title> Architecture Design and Validation Methods. </title> <note> Springer LNCS, to appear, </note> <year> 1998. </year>
Reference-contexts: Additionally, we have validated our work by a successful implementation in the functional programming language Haskell. The extended version of this paper [1] includes the proof details, the instruction refinement, an extensive bibliography and the discussion of related work. In an accompanying study <ref> [2] </ref> we refine the present JVM model to a defensive JVM, where we also isolate the bytecode verifier and the resolution component (including dynamic loading) of the JVM. This JVM can be used to execute compiled Java code as well as any bytecode that is loaded from the net. Acknowledgment.
Reference: 3. <author> E. Borger and W. Schulte. </author> <title> A programmer friendly modular definition of the semantics of Java. </title> <editor> In J. Alves-Foss, editor, </editor> <title> Formal Syntax and Semantics of Java(tm), </title> <note> Springer LNCS, to appear. </note> <year> 1998. </year>
Reference-contexts: 1 Introduction Every justification showing that a proposed compiler behaves well is relative to a definition of the semantics of source and target language. In our previous work <ref> [3] </ref> we have developed a platform independent, rigorous yet easily manageable definition for an interpreter of Java programs, which captures the intuitive understanding Java programmers have of the semantics of their code. <p> Every compiler that satisfies the conditions listed in this paper compiles Java programs correctly into JVM code. We split the JVM and the compilation function into an incremental sequence of four machines and functions|whose structure corresponds to the conservative extension relation among the modular components we exhibited for Java <ref> [3] </ref>| and define the JVM at two levels of abstraction: a ground model with an abstract class file and abstract instructions, and a refined model where the abstract ? This paper is presented to the 23rd International Symposium on Mathematical Foundations of Computer Science, Brno, Czech Republic, August 24-28, 1998, Springer <p> We discuss here only the single threaded JVM, although our approach could easily include also multiple threads (see our multi-agent Java model with threads in <ref> [3] </ref>). We skip those language constructs which can be reduced by standard program transformation techniques to the core constructs dealt with explicitly in our Java models. We still do not consider Java packages, compilation units, visibility of names, strings, arrays, input/output, loading, linking and garbage collection. <p> We define the basic JVM, called JVM I , which is used as the target for compiling Java's statements and expressions over primitive types. We prove that JVM I executes the compilation of Java I programs correctly. The following grammars recall the syntax of Java I <ref> [3] </ref> and introduce the corresponding instruction set JVM I : Exp ::= Lit j Exp Bop Exp j Var = Exp Stm ::= ; j Lab : Stm j break Lab; j continue Lab; j if (Exp) Stm else Stm j while (Exp) Stm j f Stm fl g Instr ::=
Reference: 4. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java(tm) Language Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: class is resolved , if resolution for this class is in progress or done. res : Class ! ResolvedState ResolvedState ::= Unresolved j Resolved j InProgress resolved (state) = state 2 fInProgress; Resolvedg The JVM specification [6] uses symbolic references, namely field and method specifications, to support binary compatibility, cf. <ref> [4] </ref>. As a consequence, the calculation of field offsets and of method offsets is implementation dependent. <p> A class is resolved, when it is first referenced. Before a class is resolved, its superclass is resolved (if any). Interfaces are not resolved at this time, although this is not specified in Java's language reference manual <ref> [4] </ref>. On the level of the JVM resolution leads to three rules. First, resolutions starts, i.e. the class method &lt;clinit&gt; is implicitely called, when the class referred to in a get, put- or invokestatic instruction is not resolved. <p> The function dlookup returns the first (super) class for the given method specification, which implements this method. The expression compatible (myType; tarType) returns true if myType is assignment compatible with tarType <ref> [4] </ref>. Note that at the JVM level, there is no special lookup function for constructors. <p> The definitions of class initialization for Java O in <ref> [4] </ref> and resolution for JVM O in [6] do not match because instanceof and class cast expressions in Java do not call the initialization of classes. In opposite, the JVM effect is to execute the initialization of the related class if it is not initialized yet.
Reference: 5. <author> Y. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: ASM specifications have a simple mathematical foundation <ref> [5] </ref>, which justifies their intuitive understanding as "pseudo code" over abstract data. We define the basic JVM, called JVM I , which is used as the target for compiling Java's statements and expressions over primitive types. We prove that JVM I executes the compilation of Java I programs correctly.
Reference: 6. <author> T. Lindholm and F. Yellin. </author> <title> The Java(tm) Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year> <month> 18 </month>
Reference-contexts: In this paper we provide a mathematical (read: rigorous and platform independent) yet practical model of an interpreter for the Java Virtual Machine, which formalizes the concepts presented in the JVM specification <ref> [6] </ref>, as far as they are needed for the compilation of Java programs. We also extract from the JVM specification the definition of a scheme for the compilation of Java to JVM code and prove its correctness. Main Theorem. <p> The abstract nature of the JVM I instructions is reflected in their parameterization by types and operators. It allows us to restrict our attention to a small set of JVM instructions (or better instruction classes) without losing the generality of our model with respect to the JVM specification <ref> [6] </ref>. The extended version of this paper [1] shows how to refine these parameterized instruction to JVM's real ones. 2.2 Compilation of Java I Programs to JVM I Code This section defines the compiling function from Java I to JVM I code. <p> For a general, high-level definition of a provably correct compilation scheme from Java to JVM Code, we can abstract from many data structure specifics of the particular JVM class format. This format is called class file in the JVM specification <ref> [6] </ref>. <p> We introduce a dynamic function res, which records the current resolution state. A class is resolved , if resolution for this class is in progress or done. res : Class ! ResolvedState ResolvedState ::= Unresolved j Resolved j InProgress resolved (state) = state 2 fInProgress; Resolvedg The JVM specification <ref> [6] </ref> uses symbolic references, namely field and method specifications, to support binary compatibility, cf. [4]. As a consequence, the calculation of field offsets and of method offsets is implementation dependent. <p> However, instance fields and instance methods|in opposite to class fields and class methods|are not static but dynamic. So we extend the universe MemberKind as follows: MemberKind ::= : : : j Dynamic The JVM specification <ref> [6] </ref> fixes the class file. However, the specification does not explain how instances are stored or instance methods are accessed. So we extend the signature of JVM C in JVM O in the same way as the signature of Java C is extended in Java O . <p> The definitions of class initialization for Java O in [4] and resolution for JVM O in <ref> [6] </ref> do not match because instanceof and class cast expressions in Java do not call the initialization of classes. In opposite, the JVM effect is to execute the initialization of the related class if it is not initialized yet. <p> Our definition captures faithfully the corresponding explanations of the Java Virtual Machine specification <ref> [6] </ref> and provides a practical basis for the mathematical analysis and comparison of different implementations of the machine. In particular it allowed us to prove the correctness of a general scheme for compiling Java programs into JVM code.
References-found: 6

