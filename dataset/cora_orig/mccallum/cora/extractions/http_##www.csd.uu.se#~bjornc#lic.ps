URL: http://www.csd.uu.se/~bjornc/lic.ps
Refering-URL: http://www.csd.uu.se/~bjornc/
Root-URL: 
Email: email: bjornc@csd.uu.se  
Title: An Approximation Theory for Constraint Logic Programs  
Author: Bjorn Carlson 
Date: November 18, 1991  
Address: Box 520 S-751 20 Uppsala Sweden  
Affiliation: Uppsala University Computing Science Department  
Abstract-found: 0
Intro-found: 1
Reference: [At89] <author> At-Khaci H., Boyer R., Lincoln P., Nasr R. </author> <year> (1989), </year> <title> "Efficient Implementation of Lattice Operations", </title> <journal> ACM Transactions of Programming Languages and Systems, 11:1:115-147 </journal>
Reference-contexts: The use of programming with approximations is a programming technique which is a forceful programming technique with application areas ranging from such disparate areas such as numerical methods [AS85], expert and knowledge-based systems [Bar89], and object-oriented programming <ref> [At89] </ref>. We believe that constraint logic programming can be of great use in these computation areas through the interpretation of constraint programs as programs computing approximations. 4.2 Conclusions We have shown how to interpret constraint logic programs as programs computing approximations.
Reference: [AS85] <author> Abelson H., Sussman G.J. </author> <year> (1985), </year> <title> "Structure and Interpretation of Computer Programs", </title> <publisher> MIT Press </publisher>
Reference-contexts: The use of programming with approximations is a programming technique which is a forceful programming technique with application areas ranging from such disparate areas such as numerical methods <ref> [AS85] </ref>, expert and knowledge-based systems [Bar89], and object-oriented programming [At89]. We believe that constraint logic programming can be of great use in these computation areas through the interpretation of constraint programs as programs computing approximations. 4.2 Conclusions We have shown how to interpret constraint logic programs as programs computing approximations.
Reference: [AE83] <author> Andreka H., van Emden M. H., Nemeti I., Tiuryn J. </author> <year> (1983), </year> <title> "Infinite-Term Semantics for Logic Programs", </title> <type> draft </type>
Reference-contexts: This corollary indicates the precision of the interpretation with respect to what is computed infinitely. For example, the topological interpretation <ref> [AE83, Llo87] </ref> lacks the same precision as our approach. This is because that interpretation is not, as our interpretation is, constructed from finite approximations. Instead their interpretation includes some infinite "garbage". Proposition 6. <p> CONCLUSIONS & RELATED WORK 21 Also infinite computations are difficult to denote by the sets of ground atoms interpretation. The sets of ground atoms can be completed into a topological space containing limit points <ref> [AE83, Nai84, Llo87, EN85] </ref>, which model the result of an infinite computation. The problem with such an interpretation is that it does not reflect how the infinite terms are constructed during computation. Furthermore it is difficult to denote the programs precisely. The denotation contains "garbage" atoms.
Reference: [Bar89] <editor> Barr A., Cohen P.R., Feigenbaum E.A. </editor> <booktitle> (1989), "The Handbook of Artificial Intelligence, vol IV", </booktitle> <publisher> Addison Wesley </publisher>
Reference-contexts: The use of programming with approximations is a programming technique which is a forceful programming technique with application areas ranging from such disparate areas such as numerical methods [AS85], expert and knowledge-based systems <ref> [Bar89] </ref>, and object-oriented programming [At89]. We believe that constraint logic programming can be of great use in these computation areas through the interpretation of constraint programs as programs computing approximations. 4.2 Conclusions We have shown how to interpret constraint logic programs as programs computing approximations.
Reference: [Cla78] <author> Clark K.L. </author> <year> (1978), </year> <title> "Negation as Failure", Plenum Press, Logic and Data Bases, </title> <editor> Gallaire H. and Minker J. </editor> <publisher> (eds.) </publisher>
Reference-contexts: CONSTRAINTS AS APPROXIMATIONS 13 - Corollary. Let P fl be the logical completion of a constraint program P <ref> [Cla78] </ref>. Suppose c 2 i (f k P (?)), c [ d is satisfiable in C, and that the constructed derivation from f d; p i g is a refutation, i.e. G k is the empty goal, with answer constraint d 0 . <p> Contradiction. - Corollary. Let P fl be the logical completion of a constraint program P <ref> [Cla78] </ref>. By the completeness of finite failure [JL88, Mah87], if P fl j= :(9)fc^ p i g in C then there is a k such that if d 2 i (f l P (?)) and l &gt; k then c [ d is not satisfiable in C. <p> Let P fl be the logical completion of a constraint program P <ref> [Cla78] </ref>, c i be constraints and G consist of the predicates fp 1 ; . . . ; p k g.
Reference: [Col82] <author> Colmerauer A. </author> <year> (1982), </year> <title> "Prolog and Infinite Trees", </title> <publisher> Academic Press, Logic Programming, </publisher> <editor> Clark K.L. and Tarnlund S. A. </editor> <publisher> (eds.) </publisher>
Reference-contexts: We now define the class of programs we will consider. Note that we will not include any negated atoms, even though in a specific constraint language we may have predicates intuitively denoting negative information, e.g. 6= in Prolog-II <ref> [Col82] </ref>. Definition 7. Let C be a constraint system.
Reference: [Col84] <author> Colmerauer A. </author> <year> (1984), </year> <title> "Equations and Inequations on Finite and Infinite Trees", ICOT, </title> <booktitle> Proceedings of the International Conference on Fifth Generation Computer Systems </booktitle>
Reference-contexts: EXAMPLES 18 3.2 Constraints over rational trees We define the constraint structure R for rational trees and give two example programs and their denotation over R. We are following Colmerauers seminal work on this subject <ref> [Col84] </ref>. Definition 16. A node u of depth n 0 is a sequence of n positive integers i 1 ; . . . ; i n ending with a functional symbol f , as u = i 1 :i 2 : . . . i n :f .
Reference: [Col90] <author> Colmerauer A. </author> <year> (1990), </year> <title> "Prolog-III", </title> <journal> CACM, </journal> <month> July </month> <year> 1990 </year>
Reference-contexts: Nothing in the theory assumes any structure depending properties of the underlying constraint system. In this way we can apply the theory to a variety of constraint logic programming languages, including (pure) Prolog, Prolog-II, Prolog-III <ref> [Col90] </ref>, CLP (&lt;) and such. The semantics include interpretations of infinite computations. We also argue why we believe the notion of approximations to be of interest in constraint logic programming. 4.3 Future Work There are different ways to go from here.
Reference: [DM88] <author> Debray S.K, Mishra P. </author> <year> (1988), </year> <title> "Denotational and operational semantics for Prolog", </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 61-91 </pages>
Reference-contexts: This is a model theoretical semantics which goes hand in hand with the logical semantics, and thus it does not fit our purposes. The traditional way of denoting a programming language is through deno-tational semantics [Sto77]. A denotational semantics of Prolog has been constructed <ref> [DM88] </ref> but this kind of denotation usually get stuck into far too many implementation details, which distract us from the purpose of giving a simple mathematical explanation of the computational behaviour of constraint logic programs. The use of non-Herbrand models of logic programs is not a new idea [LM88].
Reference: [FM90] <author> Filippenko I., Morris F.L. </author> <year> (1990), </year> <title> "Domains for Logic Programm-ming", </title> <type> draft </type>
Reference-contexts: Furthermore it is difficult to denote the programs precisely. The denotation contains "garbage" atoms. This anomaly has been recognised by others [Gol88] but domain theory was not used which brought some problems with downward continuity of denotation operators. Domain theory has been used before to interpret logic programs <ref> [FM90] </ref>, but here another notion of approximations is used and a very complicated technical machinery is necessary. Also infinite computations and constraint programs are not construed.
Reference: [Gol88] <author> Golson William G. </author> <year> (1988), </year> <title> "Toward a Declarative Semantics for Infinite Objects in Logic Programming", </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 151-164 27 BIBLIOGRAPHY 28 </pages>
Reference-contexts: The problem with such an interpretation is that it does not reflect how the infinite terms are constructed during computation. Furthermore it is difficult to denote the programs precisely. The denotation contains "garbage" atoms. This anomaly has been recognised by others <ref> [Gol88] </ref> but domain theory was not used which brought some problems with downward continuity of denotation operators. Domain theory has been used before to interpret logic programs [FM90], but here another notion of approximations is used and a very complicated technical machinery is necessary.
Reference: [JL88] <author> Jaffar J., Lassez J-L., Lassez C. </author> <year> (1988), </year> <title> "Constraint Logic Programming: A Tutorial", </title> <publisher> IEEE </publisher>
Reference-contexts: This is a semantics that is concerned with the computational behavior of constraint programs. We do not consider the algebraic semantics CHAPTER 1. INTRODUCTION 4 of the programs. This has already been done elsewhere <ref> [JL88] </ref>. Instead we identify a program with the set of constraints that can be computed (in finite or infinite time) by it, and consider a partial ordering of constraints. We use domain theory as the underlying mathematical framework for the semantics. <p> We relate failure, success and infinite success to [[P ]]. Also we relate, through known results concerning soundness and completeness <ref> [JL88, Mah87] </ref>, the logical semantics to our computational semantics. In the following we consider a instead of a# throughout the text. This causes no problem since if D = P , where P is a cusl, then D C ~ = P (D C isomorphic to P ) [SGL91]. <p> Suppose c 2 i (f k P (?)), c [ d is satisfiable in C, and that the constructed derivation from f d; p i g is a refutation, i.e. G k is the empty goal, with answer constraint d 0 . Then, by the soundness of successful derivations <ref> [JL88, Mah87] </ref>, P fl j= d 0 ! (9)fd ^ p i g in C. Through a simple induction over k it follows P fl j= d 0 ! (9)fc ^ p i g in C. <p> Contradiction. - Corollary. Let P fl be the logical completion of a constraint program P [Cla78]. By the completeness of finite failure <ref> [JL88, Mah87] </ref>, if P fl j= :(9)fc^ p i g in C then there is a k such that if d 2 i (f l P (?)) and l &gt; k then c [ d is not satisfiable in C. <p> f;g; f;g; ffx = f (x 1 )ggi; hffx 1 = x; x 2 = xgg; f;g; ffx = f (x 1 )gg; ffx = f 2 (x 2 )ggi; . . .g: 3.3 Constraints over reals We define the constraint structure over the reals &lt;, used in CLP (&lt;) <ref> [JL88] </ref>. Definition 19. Let F = f+; fl; 0; 1g, its signature, V ar as usual, the set f=; &gt;g. <p> Also infinite computations and constraint programs are not construed. The extension of logic programming to constraint logic programming has been given a formal treatment <ref> [JL88, JL85] </ref>, and the algebraic semantics of logic programs was introduced. This is a model theoretical semantics which goes hand in hand with the logical semantics, and thus it does not fit our purposes. The traditional way of denoting a programming language is through deno-tational semantics [Sto77].
Reference: [JL85] <author> Jaffar J., Lassez J-L., Maher M.J. </author> <year> (1985), </year> <title> "A Logic Programming Language Scheme", Prentice Hall, Logic Programming: Relations, Functions and Equations, </title> <editor> DeGroot D. and Lindstrom G. </editor> <publisher> (eds) </publisher>
Reference-contexts: Also infinite computations and constraint programs are not construed. The extension of logic programming to constraint logic programming has been given a formal treatment <ref> [JL88, JL85] </ref>, and the algebraic semantics of logic programs was introduced. This is a model theoretical semantics which goes hand in hand with the logical semantics, and thus it does not fit our purposes. The traditional way of denoting a programming language is through deno-tational semantics [Sto77].
Reference: [LM88] <author> Levi G., Mancarella P. </author> <year> (1988), </year> <title> "The Unfolding Semantics of Logic Programs", </title> <institution> Universita di Pisa, </institution> <type> Technical Report 13/88 </type>
Reference-contexts: The use of non-Herbrand models of logic programs is not a new idea <ref> [LM88] </ref>. Unfolding semantics is a semantics which is closer to the operational semantics of the programs. In this setting one does not emphasize the approximative nature of logic programming nor the infinite computations done by logic programs.
Reference: [Llo87] <author> Lloyd J.W. </author> <year> (1987), </year> <title> "Foundations of Logic Programming", </title> <publisher> Springer Verlag, Second Edition </publisher>
Reference-contexts: What will be done now is to give a denotation of a program P through the help of a fixed point operator. We follow the, by now standard, way of denoting programs, i.e. giving the semantics of a program as the least fixed point of a continuous function <ref> [Llo87, EK76] </ref>. See appendix A for a short presentation of the domain theory used in this paper. Our initiative to the semantics is the observation that constraints can be considered as approximations. <p> This corollary indicates the precision of the interpretation with respect to what is computed infinitely. For example, the topological interpretation <ref> [AE83, Llo87] </ref> lacks the same precision as our approach. This is because that interpretation is not, as our interpretation is, constructed from finite approximations. Instead their interpretation includes some infinite "garbage". Proposition 6. <p> We wish to add another view: the domain theoretical. Since much work has been done on the semantics of logic programs we will review some of the relevant ideas. Logic programming is based on SLD-resolution <ref> [Llo87] </ref>, which is a refinement of basic resolution [Rob65]. Hence logic programs are sets of clauses and we can denote the programs by their logical meaning as clauses. By this we could be satisfied. <p> The logical denotation of logic programs has been reformulated through least models and fixed points [EK76], and this interpretation is considered the intended semantics of logic programs in most circumstances <ref> [Llo87] </ref>. The interpretation of logic programs is done by sets of ground atoms [Llo87, EK76]. In these ground models it is awkward though (and difficult) to fully characterize the computational behaviour of variables and other partial terms which exists in logic programs. 20 CHAPTER 4. <p> The logical denotation of logic programs has been reformulated through least models and fixed points [EK76], and this interpretation is considered the intended semantics of logic programs in most circumstances [Llo87]. The interpretation of logic programs is done by sets of ground atoms <ref> [Llo87, EK76] </ref>. In these ground models it is awkward though (and difficult) to fully characterize the computational behaviour of variables and other partial terms which exists in logic programs. 20 CHAPTER 4. <p> CONCLUSIONS & RELATED WORK 21 Also infinite computations are difficult to denote by the sets of ground atoms interpretation. The sets of ground atoms can be completed into a topological space containing limit points <ref> [AE83, Nai84, Llo87, EN85] </ref>, which model the result of an infinite computation. The problem with such an interpretation is that it does not reflect how the infinite terms are constructed during computation. Furthermore it is difficult to denote the programs precisely. The denotation contains "garbage" atoms.
Reference: [Mah87] <author> Maher M.J. </author> <year> (1987), </year> <title> "Logic Semantics for a Class of Committed-Choice Programs", MIT Press, </title> <booktitle> Proc. 4th Int. Conf. on Logic Programming </booktitle>
Reference-contexts: We relate failure, success and infinite success to [[P ]]. Also we relate, through known results concerning soundness and completeness <ref> [JL88, Mah87] </ref>, the logical semantics to our computational semantics. In the following we consider a instead of a# throughout the text. This causes no problem since if D = P , where P is a cusl, then D C ~ = P (D C isomorphic to P ) [SGL91]. <p> Suppose c 2 i (f k P (?)), c [ d is satisfiable in C, and that the constructed derivation from f d; p i g is a refutation, i.e. G k is the empty goal, with answer constraint d 0 . Then, by the soundness of successful derivations <ref> [JL88, Mah87] </ref>, P fl j= d 0 ! (9)fd ^ p i g in C. Through a simple induction over k it follows P fl j= d 0 ! (9)fc ^ p i g in C. <p> Contradiction. - Corollary. Let P fl be the logical completion of a constraint program P [Cla78]. By the completeness of finite failure <ref> [JL88, Mah87] </ref>, if P fl j= :(9)fc^ p i g in C then there is a k such that if d 2 i (f l P (?)) and l &gt; k then c [ d is not satisfiable in C. <p> Let P fl be the logical completion of a constraint program P [Cla78], c i be constraints and G consist of the predicates fp 1 ; . . . ; p k g. Then, by the above proposition and the strong completeness of successful derivations <ref> [Mah87] </ref>, if P fl j= c ! G in C and c is satisfiable in C then G has suc cessful derivations with final constraints c 1 ; . . . ; c n such that, for all m 2 ! and i 2 k, i (f m P (?)) v <p> In this setting one does not emphasize the approximative nature of logic programming nor the infinite computations done by logic programs. The use of constraints in a parallel environment has its roots in work on committed-choice languages <ref> [Mah87, SR90, Sar90a] </ref>. By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages [Mah87], and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming [SR90, Sar90a]. <p> The use of constraints in a parallel environment has its roots in work on committed-choice languages [Mah87, SR90, Sar90a]. By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages <ref> [Mah87] </ref>, and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming [SR90, Sar90a]. We feel that our approximation semantics further adds semantical strength and applicability to this programming CHAPTER 4.
Reference: [Nai84] <author> Nait Abdallah M.A. </author> <year> (1984), </year> <title> "On the Interpretation of Infinite Computations in Logic Programs", </title> <publisher> Springer Verlag, Lecture Notes in Computer Science 172 </publisher>
Reference-contexts: CONCLUSIONS & RELATED WORK 21 Also infinite computations are difficult to denote by the sets of ground atoms interpretation. The sets of ground atoms can be completed into a topological space containing limit points <ref> [AE83, Nai84, Llo87, EN85] </ref>, which model the result of an infinite computation. The problem with such an interpretation is that it does not reflect how the infinite terms are constructed during computation. Furthermore it is difficult to denote the programs precisely. The denotation contains "garbage" atoms.
Reference: [Plo76] <author> Plotkin G. </author> <year> (1976), </year> <title> "A Powerdomain construction", </title> <journal> SIAM Journal of Computing, </journal> <volume> 5(3) </volume> <pages> 452-487 </pages>
Reference-contexts: Otherwise the derivation is infinite. Since we want to interpret constraint logic programs we have to cope with nondeterminism. We treat nondeterminism by using a kind of powerdomains <ref> [Plo76, Smy78, SGL91] </ref>. Instead of constructing these powerdomains directly we define a certain cusl and use its completion by ideals as the powerdomain in case. We will then interpret a constraint program as a set of constraints that can be computed (generated) by the program.
Reference: [Rob65] <author> Robinson J.A. </author> <year> (1965), </year> <title> "A Machine-Oriented Logic Based on the Resolution Principle", </title> <journal> J. ACM, 12:1:23-41 </journal>
Reference-contexts: We wish to add another view: the domain theoretical. Since much work has been done on the semantics of logic programs we will review some of the relevant ideas. Logic programming is based on SLD-resolution [Llo87], which is a refinement of basic resolution <ref> [Rob65] </ref>. Hence logic programs are sets of clauses and we can denote the programs by their logical meaning as clauses. By this we could be satisfied. But after all we compute with logic programs, and the computational nature of logic programs is not really captured by a logical semantics.
Reference: [SR90] <author> Saraswat V.A., Rinard M. </author> <year> (1990), </year> <title> "Concurrent Constraint Programming", </title> <journal> ACM, </journal> <note> Extended Abstract </note>
Reference-contexts: In this setting one does not emphasize the approximative nature of logic programming nor the infinite computations done by logic programs. The use of constraints in a parallel environment has its roots in work on committed-choice languages <ref> [Mah87, SR90, Sar90a] </ref>. By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages [Mah87], and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming [SR90, Sar90a]. <p> By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages [Mah87], and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming <ref> [SR90, Sar90a] </ref>. We feel that our approximation semantics further adds semantical strength and applicability to this programming CHAPTER 4. CONCLUSIONS & RELATED WORK 22 paradigm by giving a semantics of constraint logic programs that is close to the intended semantics of concurrent constraint programs [Sar90a, Sar90b].
Reference: [Sar90a] <author> Saraswat V.A. </author> <year> (1990), </year> <title> "Concurrent Constraint Programming", </title> <institution> Carnegie-Mellon University, </institution> <type> PhD Thesis CMU-CSD-89-108 </type>
Reference-contexts: In this setting one does not emphasize the approximative nature of logic programming nor the infinite computations done by logic programs. The use of constraints in a parallel environment has its roots in work on committed-choice languages <ref> [Mah87, SR90, Sar90a] </ref>. By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages [Mah87], and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming [SR90, Sar90a]. <p> By using constraint programming languages one can give elegant and theoretically appealing semantics to classes of committed-choice languages [Mah87], and also extract a preferred subclass of the class of constraint logic languages, for use in parallel programming <ref> [SR90, Sar90a] </ref>. We feel that our approximation semantics further adds semantical strength and applicability to this programming CHAPTER 4. CONCLUSIONS & RELATED WORK 22 paradigm by giving a semantics of constraint logic programs that is close to the intended semantics of concurrent constraint programs [Sar90a, Sar90b]. <p> We feel that our approximation semantics further adds semantical strength and applicability to this programming CHAPTER 4. CONCLUSIONS & RELATED WORK 22 paradigm by giving a semantics of constraint logic programs that is close to the intended semantics of concurrent constraint programs <ref> [Sar90a, Sar90b] </ref>. The use of programming with approximations is a programming technique which is a forceful programming technique with application areas ranging from such disparate areas such as numerical methods [AS85], expert and knowledge-based systems [Bar89], and object-oriented programming [At89].
Reference: [Sar90b] <author> Saraswat V.A. </author> <year> (1990), </year> <title> "The Paradigm of Concurrent Constraint Programming", </title> <type> ICLP 90, Tutorial </type>
Reference-contexts: We feel that our approximation semantics further adds semantical strength and applicability to this programming CHAPTER 4. CONCLUSIONS & RELATED WORK 22 paradigm by giving a semantics of constraint logic programs that is close to the intended semantics of concurrent constraint programs <ref> [Sar90a, Sar90b] </ref>. The use of programming with approximations is a programming technique which is a forceful programming technique with application areas ranging from such disparate areas such as numerical methods [AS85], expert and knowledge-based systems [Bar89], and object-oriented programming [At89].
Reference: [Sco81] <author> Scott D. </author> <year> (1981), </year> <title> "Lectures on a mathematical theory of computation", </title> <institution> Oxford University Computing Laboratory, </institution> <type> Technical Monograph PRG-19 </type>
Reference-contexts: Keywords are domains, consistent upper semi-lattices, monotone and continuous functions, fixed points and least upper bounds. Domain theory is by now a well-defined and rich mathematical theory, and it includes much more mathematics than is used in here <ref> [Sco81, Sco82, Smy78, SGL91] </ref>. Domains are partial orders with certain properties which make them suitable for modelling computatable functions and predicates. For example they contain limits of directed chains which make interpretations of fixed points of functions possible. <p> Domains are a particular kind of cpo:s which are well suited to use as spaces for computable functions. f (x) = tff (a) : a 2 approx (x)g <ref> [SGL91, Sco81, Sco82] </ref> . APPENDIX A. PRELIMINARIES 26 Definition 27. <p> Proposition 8. Let P be a cusl and let P = fI P : I an idealg. Then P = hP ; ; ;i is a domain under set inclusion. Furthermore, the set of compact elements P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. <p> P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. Thus the elements in the cusl P are isomorphic to the compact elements in the completion of P . For example suppose we have the cusl N = hN; ; 0i. <p> Suppose D is a domain and f : P ! D is monotone. Then there is a unique continuous function f : P ! D, defined as f (I) = tff (a): a 2 Ig, such that f = i ffi f <ref> [SGL91, Sco81, Sco82] </ref>. Corollary. Let f : P ! P be monotone, and i: P ! P be the canonical embedding. Then trivially f ffi i is monotone, and thus f (I) = [fi (f (a)): a 2 Ig is continuous.
Reference: [Sco82] <author> Scott D. </author> <year> (1982), </year> <title> "Domains for denotational semantics", </title> <publisher> Springer Verlag, Lecture Notes in Computer Science 140 </publisher>
Reference-contexts: Keywords are domains, consistent upper semi-lattices, monotone and continuous functions, fixed points and least upper bounds. Domain theory is by now a well-defined and rich mathematical theory, and it includes much more mathematics than is used in here <ref> [Sco81, Sco82, Smy78, SGL91] </ref>. Domains are partial orders with certain properties which make them suitable for modelling computatable functions and predicates. For example they contain limits of directed chains which make interpretations of fixed points of functions possible. <p> Domains are a particular kind of cpo:s which are well suited to use as spaces for computable functions. f (x) = tff (a) : a 2 approx (x)g <ref> [SGL91, Sco81, Sco82] </ref> . APPENDIX A. PRELIMINARIES 26 Definition 27. <p> Proposition 8. Let P be a cusl and let P = fI P : I an idealg. Then P = hP ; ; ;i is a domain under set inclusion. Furthermore, the set of compact elements P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. <p> P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. Thus the elements in the cusl P are isomorphic to the compact elements in the completion of P . For example suppose we have the cusl N = hN; ; 0i. <p> Suppose D is a domain and f : P ! D is monotone. Then there is a unique continuous function f : P ! D, defined as f (I) = tff (a): a 2 Ig, such that f = i ffi f <ref> [SGL91, Sco81, Sco82] </ref>. Corollary. Let f : P ! P be monotone, and i: P ! P be the canonical embedding. Then trivially f ffi i is monotone, and thus f (I) = [fi (f (a)): a 2 Ig is continuous.
Reference: [Sha89] <author> Shapiro E. </author> <year> (1989), </year> <title> "Embedding Linda and Other Joys of Concurrent Logic Programming", </title> <institution> Weizmann Institute of Science, </institution> <address> CS89-07 BIBLIOGRAPHY 29 </address>
Reference: [Smy78] <author> Smyth M.B. </author> <year> (1978), </year> <title> "Powerdomains", </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16 </volume> <pages> 23-36 </pages>
Reference-contexts: Otherwise the derivation is infinite. Since we want to interpret constraint logic programs we have to cope with nondeterminism. We treat nondeterminism by using a kind of powerdomains <ref> [Plo76, Smy78, SGL91] </ref>. Instead of constructing these powerdomains directly we define a certain cusl and use its completion by ideals as the powerdomain in case. We will then interpret a constraint program as a set of constraints that can be computed (generated) by the program. <p> Keywords are domains, consistent upper semi-lattices, monotone and continuous functions, fixed points and least upper bounds. Domain theory is by now a well-defined and rich mathematical theory, and it includes much more mathematics than is used in here <ref> [Sco81, Sco82, Smy78, SGL91] </ref>. Domains are partial orders with certain properties which make them suitable for modelling computatable functions and predicates. For example they contain limits of directed chains which make interpretations of fixed points of functions possible.
Reference: [SGL91] <author> Stoltenberg-Hansen V., Griffor E., Lindstrom I., </author> <title> "Mathematical theory of domains", </title> <type> manuscript </type>
Reference-contexts: Otherwise the derivation is infinite. Since we want to interpret constraint logic programs we have to cope with nondeterminism. We treat nondeterminism by using a kind of powerdomains <ref> [Plo76, Smy78, SGL91] </ref>. Instead of constructing these powerdomains directly we define a certain cusl and use its completion by ideals as the powerdomain in case. We will then interpret a constraint program as a set of constraints that can be computed (generated) by the program. <p> Thus c; c 0 are consistent in A. Hence c t c 0 2 . Since c t c 0 v A d it follows that v S 0 . - Corollary. D is a cusl and D which is D completed with ideals is a domain <ref> [SGL91] </ref> (appendix A). <p> In the following we consider a instead of a# throughout the text. This causes no problem since if D = P , where P is a cusl, then D C ~ = P (D C isomorphic to P ) <ref> [SGL91] </ref>. Also we do not always distinguish the variable x from a tuple of variables. Again we try to keep the number of details down. The following proposition shows intuitively that if a constraint c is in the denotation then c as a goal does not fail. Proposition 5. <p> Keywords are domains, consistent upper semi-lattices, monotone and continuous functions, fixed points and least upper bounds. Domain theory is by now a well-defined and rich mathematical theory, and it includes much more mathematics than is used in here <ref> [Sco81, Sco82, Smy78, SGL91] </ref>. Domains are partial orders with certain properties which make them suitable for modelling computatable functions and predicates. For example they contain limits of directed chains which make interpretations of fixed points of functions possible. <p> Domains are a particular kind of cpo:s which are well suited to use as spaces for computable functions. f (x) = tff (a) : a 2 approx (x)g <ref> [SGL91, Sco81, Sco82] </ref> . APPENDIX A. PRELIMINARIES 26 Definition 27. <p> Proposition 8. Let P be a cusl and let P = fI P : I an idealg. Then P = hP ; ; ;i is a domain under set inclusion. Furthermore, the set of compact elements P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. <p> P C = fa# : a 2 P g <ref> [SGL91, Sco81, Sco82] </ref>. We say that P is the completion of P by ideals. To complete a cusl with ideals is the operation of completing a partially ordered, consistently complete structure with its limit elements. This follows from the representation theorem [SGL91, Sco81, Sco82]. Thus the elements in the cusl P are isomorphic to the compact elements in the completion of P . For example suppose we have the cusl N = hN; ; 0i. <p> Suppose D is a domain and f : P ! D is monotone. Then there is a unique continuous function f : P ! D, defined as f (I) = tff (a): a 2 Ig, such that f = i ffi f <ref> [SGL91, Sco81, Sco82] </ref>. Corollary. Let f : P ! P be monotone, and i: P ! P be the canonical embedding. Then trivially f ffi i is monotone, and thus f (I) = [fi (f (a)): a 2 Ig is continuous.
Reference: [Sto77] <author> Stoy Joseph E. </author> <year> (1977), </year> <title> "Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory", </title> <publisher> MIT Press [EK76] van Emden M.H, </publisher> <editor> Kowalski R. </editor> <year> (1976), </year> <title> "The semantics of predicate logic as a programming language", </title> <editor> J. ACM, 23:4:733-742 [EN85] van Emden M.H, </editor> <address> Nait Abdallah M.A. </address> <year> (1985), </year> <title> "Top-Down Semantics of Fair Computations of Logic Programs", </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 67-75 </pages>
Reference-contexts: This is a model theoretical semantics which goes hand in hand with the logical semantics, and thus it does not fit our purposes. The traditional way of denoting a programming language is through deno-tational semantics <ref> [Sto77] </ref>. A denotational semantics of Prolog has been constructed [DM88] but this kind of denotation usually get stuck into far too many implementation details, which distract us from the purpose of giving a simple mathematical explanation of the computational behaviour of constraint logic programs.
References-found: 28

