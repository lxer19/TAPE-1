URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-45.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-45.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [Barnes 80] <author> J. G. P. Barnes, </author> <title> An Overview of Ada, </title> <journal> in Software Practice and Experience, </journal> <volume> vol. 10, </volume> <pages> pp. 851-887, </pages> <year> 1980. </year>
Reference-contexts: CaseWare [Cagan 92] stores the information about how to build a particular type of object on the object type definition itself, and places the build context information on objects. But the compositions of configurations are still described by separate collections called assemblies. In Ada <ref> [Barnes 80] </ref>, since packages and subprograms are units of source code as well as units for compilation, the gap between handling system building and managing source code is smaller than in other languages.
Reference: [Berliner] <author> Brian Berliner, CVS II: </author> <title> Parallelizing Software Development, </title> <publisher> Prisma, Inc., </publisher> <address> 5465 Mark Dabling Blvd, Colorado Springs, CO 80918. </address>
Reference-contexts: The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [Rochkind 75] and RCS [Tichy 85] handle the versions of files only. CVS <ref> [Berliner] </ref> enhances RCS by letting programmers handle versions of directories. DSEE [Leblang 84] allows version selection in terms of threads that refers to files or other threads.
Reference: [Boudier 88] <author> Gerard Boudier, Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> An Overview of PCTE and PCTE+, </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> (Peter Henderson, </editor> <publisher> ed.), </publisher> <pages> pp. 248-257, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engi 10 neering Notes, </booktitle> <volume> Vol 13, No 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol 24, No 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism [Zdonik 86]. PCTE+ <ref> [Boudier 88] </ref> supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [Katz 90]. Several other systems also aim to free programmers from the management of derived objects. Cedar [Teitel-man 84] and DSEE [Leblang 84] use source oriented system models.
Reference: [Buxton 80] <author> John N. Buxton and larry E. Druffel, </author> <title> Requirements for An Ada Programming Support Environment: Rationale for STONEMAN, </title> <booktitle> in Proceedings of COMPSAC 80, </booktitle> <pages> pp. 66-72, </pages> <year> 1980. </year>
Reference-contexts: The Model In current environments, configuration management is handled with tools that run on top of data repositories. For example, traditional UNIX programming environments manage configuration with tools like MAKE [Feldman 79] and RCS [Tichy 85] that operate on files and directories. STONEMAN <ref> [Buxton 80] </ref> envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. In the ECMA [ECMA] Toaster Model, low-level configuration management is supported by a database, but higher level activities are still carried out by separate tools. Edit...
Reference: [Cagan 92] <author> Martin R. Cagan, </author> <title> Software Configuration Management Redefined, </title> <publisher> CaseWare, Inc., </publisher> <address> 108 Pacifica, Irvine, CA 92718, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: VESTA hides the management of derived objects by passing them as the results of building functions. Most existing configuration management systems use separate document to describe the system building process. CaseWare <ref> [Cagan 92] </ref> stores the information about how to build a particular type of object on the object type definition itself, and places the build context information on objects. But the compositions of configurations are still described by separate collections called assemblies.
Reference: [ECMA] <author> ECMA, </author> <title> A Reference Model for Frameworks of Software Engineering Environments (Version 2). ECMA Report Number TR/55 (Version 2), </title> <type> NIST Report Number SP 500-201, </type> <month> December </month> <year> 1991. </year>
Reference-contexts: For example, traditional UNIX programming environments manage configuration with tools like MAKE [Feldman 79] and RCS [Tichy 85] that operate on files and directories. STONEMAN [Buxton 80] envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. In the ECMA <ref> [ECMA] </ref> Toaster Model, low-level configuration management is supported by a database, but higher level activities are still carried out by separate tools. Edit...
Reference: [Estublier 85] <author> Jacky Estublier, </author> <title> A Configuration Manager: The Adele data base of programs, </title> <booktitle> in Workshop on software engineering environments for programming-in-the-large, </booktitle> <month> June </month> <year> 1985 </year>
Reference-contexts: Revise A A D A D D Y Y Modify A and Y Freeze A C (a) (b) C C X X X A D D Y Y 6 Like DSEE [Leblang 84], SHAPE [Mahler 88], and Adele <ref> [Estublier 85] </ref>, we use version selection rules to make the selection of versions more exible. But since versions are selected by the uses links in our framework, we associate these rules with uses links instead of putting them in a separate description. <p> Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [Mor-gan 88] presented one of such mechanisms. Gandalf [Habermann 86] uses a module concept where a set of versions implement a single interface. Adele <ref> [Estublier 85] </ref> extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph. Compared with our framework, Adele is more exible to handle variants of versions, but it is also more complicated.
Reference: [Feldman 79] <author> Stuart I. Feldman, </author> <title> Make - a Program for Maintaining Computer Programs, </title> <journal> in Software - Practice & Experience, </journal> <volume> 9(4), </volume> <pages> pp. 255-265, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: The Model In current environments, configuration management is handled with tools that run on top of data repositories. For example, traditional UNIX programming environments manage configuration with tools like MAKE <ref> [Feldman 79] </ref> and RCS [Tichy 85] that operate on files and directories. STONEMAN [Buxton 80] envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. <p> A graphical user interface can easily be built, since software units and their links map naturally to icons and edges. Operations of a software unit can also be represented as items in a pop-up menu. 7. Related Work MAKE <ref> [Feldman 79] </ref> is the most commonly used system building tool, but it has rather weak support for the modulization of makefiles. There is no formal channel of communication between makefiles.
Reference: [Gallo 86] <author> Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> The Object Management System of PCTE as a Software Engineering Database Management System, </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> (Peter Henderson, </editor> <publisher> ed.), </publisher> <pages> pp. 12-15, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Basically, a freeze operation should reduce the space occupied by a software unit. A revise operation should make modifiable copies of its data attributes. Our model to handle composite objects is similar to that of PCTE <ref> [Gallo 86] </ref>[Boudier 88]. But there are two major differences. First, while all the attributes of a stable object in PCTE are immutable, a fixed software unit in our framework may modify its attributes internally. For example, it may delete its derived objects and compress its source objects to save space.
Reference: [Habermann 86] <author> A. Nico Habermann and David Not-kin, </author> <title> Gandalf: Software Development Environments, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol 12, No 12, pp.1117-1127, </volume> <month> Decem-ber </month> <year> 1986. </year>
Reference-contexts: However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [Mor-gan 88] presented one of such mechanisms. Gandalf <ref> [Habermann 86] </ref> uses a module concept where a set of versions implement a single interface. Adele [Estublier 85] extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph.
Reference: [Katz 90] <author> Randay H. Katz, </author> <title> Toward a Unified Framework for Version Modeling in Engineering Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol 22, No 4, </volume> <pages> pp. 375-408, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Zdonik describes an object-oriented database system that includes a built-in version control mechanism [Zdonik 86]. PCTE+ [Boudier 88] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework <ref> [Katz 90] </ref>. Several other systems also aim to free programmers from the management of derived objects. Cedar [Teitel-man 84] and DSEE [Leblang 84] use source oriented system models. Derived objects are not directly managed by programmers, but programmers still have to address them indirectly by some functions.
Reference: [Lamb 91] <author> Charles Lamb, Gordon Landis, Jack Oren-stein, and Dan Weinred, </author> <title> The ObjectStore Database System, </title> <journal> in Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <pages> pp. 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: It is basically an object-oriented database. Currently we are using an object-oriented database system User Object File System Layer Interface Says Obj Ver Build Sys Obj Ver Build Sys Obj Ver Build X1 Y1 C D work area A work area B Library X Library Y Layer called ObjectStore <ref> [Lamb 91] </ref> to implement this layer. ObjectStore is basically an extension of the C++ language that supports persistent objects. It allows multiple clients to work on the same database simultaneously in a distributed environment, and it supports transaction facilities to serialize the operations on objects.
Reference: [Leblang 84] <author> David B. Leblang and Robert P. Chase, Jr., </author> <title> Computer-Aided Software Engineering in a Distributed Workstation Environment, </title> <journal> in SIG-PLAN Notices, </journal> <volume> vol. 19, No. 5, </volume> <pages> pp. 104-113, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Revise A A D A D D Y Y Modify A and Y Freeze A C (a) (b) C C X X X A D D Y Y 6 Like DSEE <ref> [Leblang 84] </ref>, SHAPE [Mahler 88], and Adele [Estublier 85], we use version selection rules to make the selection of versions more exible. But since versions are selected by the uses links in our framework, we associate these rules with uses links instead of putting them in a separate description. <p> Our framework also enables us to reduce the interference between programmers, and increase the sharing of software artifacts more naturally. Our scenario for cooperative programming follows the general strategy of DSEE <ref> [Leblang 84] </ref> and SHAPE [Mahler 88]. Programmers should use the older but more stable versions of code from their colleagues, and work on the newer but experimental versions of their own code. <p> The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [Rochkind 75] and RCS [Tichy 85] handle the versions of files only. CVS [Berliner] enhances RCS by letting programmers handle versions of directories. DSEE <ref> [Leblang 84] </ref> allows version selection in terms of threads that refers to files or other threads. Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). <p> PCTE+ [Boudier 88] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [Katz 90]. Several other systems also aim to free programmers from the management of derived objects. Cedar [Teitel-man 84] and DSEE <ref> [Leblang 84] </ref> use source oriented system models. Derived objects are not directly managed by programmers, but programmers still have to address them indirectly by some functions. VESTA hides the management of derived objects by passing them as the results of building functions.
Reference: [Levin 93] <author> Roy Levin and Paul R. McJones, </author> <title> The Vesta Approach to Precise Configuration of Large Software Systems, </title> <note> DEC System Research Center Research Report No. 105, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: There is no formal channel of communication between makefiles. If we want to use multiple makefiles in a large project, then the passing of arguments has to rely on implicit protocols. The lack of formal arguments also makes the reuse of make-files more difficult. The VESTA configuration management system <ref> [Levin 93] </ref> aims to solve these problems by the modulization and parameterization of system models. It uses a functional language to describe system models, and emphasizes the modulization and parameterization of system models.
Reference: [Lieberman 86] <author> Henry Lieberman, </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object Oriented Languages, </title> <booktitle> in ACM OOPSLA 86, </booktitle> <pages> pp. 214-223, </pages> <month> September, </month> <year> 1986. </year>
Reference-contexts: For example, some software units used in a C program may contain YACC code instead of plain C code, and some software units may be library functions that do not have implementation parts. We use the delegation model <ref> [Lieberman 86] </ref>[Ungar 87][Stein 87] [Orlando 89] instead of the more conventional class/ inheritance model to describe the sharing of behavior between software units. Delegation can simulate the class/inheritance mechanism while supporting the sharing of attributes between individual objects.
Reference: [Mahler 88] <author> Axel Mahler and Andreas Lampen, </author> <title> An Integrated Toolset for Engineering Software Configurations, </title> <booktitle> in Proceedings of the ACM SIGSOFT/ SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> (Peter Henderson, </editor> <publisher> ed.), </publisher> <pages> pp. 191-200, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol 13, No 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol 24, No 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Revise A A D A D D Y Y Modify A and Y Freeze A C (a) (b) C C X X X A D D Y Y 6 Like DSEE [Leblang 84], SHAPE <ref> [Mahler 88] </ref>, and Adele [Estublier 85], we use version selection rules to make the selection of versions more exible. But since versions are selected by the uses links in our framework, we associate these rules with uses links instead of putting them in a separate description. <p> Our framework also enables us to reduce the interference between programmers, and increase the sharing of software artifacts more naturally. Our scenario for cooperative programming follows the general strategy of DSEE [Leblang 84] and SHAPE <ref> [Mahler 88] </ref>. Programmers should use the older but more stable versions of code from their colleagues, and work on the newer but experimental versions of their own code. But instead of dealing with files, our framework allows a programmer to choose and use modules generated by other programmers. programming.
Reference: [Morgan 88] <author> Thomas M. Morgan, </author> <title> Configuration Management and Version Control in the Rational Programming Environment, </title> <booktitle> in Ada in Industry - Proceedings of the Ada-Europe International Conference, </booktitle> <pages> pp. 17-28, </pages> <month> June, </month> <year> 1988. </year>
Reference: [Orlando 89] <author> Lynn Andrea Stein, Henry Lieberman, and David Ungar, </author> <title> A Shared View of Sharing: </title> <booktitle> The Treaty of Orlando, In Concepts, Applications and Databases, </booktitle> <pages> pp. 31-48, </pages> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: For example, some software units used in a C program may contain YACC code instead of plain C code, and some software units may be library functions that do not have implementation parts. We use the delegation model [Lieberman 86][Ungar 87][Stein 87] <ref> [Orlando 89] </ref> instead of the more conventional class/ inheritance model to describe the sharing of behavior between software units. Delegation can simulate the class/inheritance mechanism while supporting the sharing of attributes between individual objects.
Reference: [Osterweil 87] <author> Leon Osterweil, </author> <title> Software Process are Software Too, </title> <booktitle> in Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pp. 2-13, </pages> <address> Monterey CA, </address> <month> March-April </month> <year> 1987. </year>
Reference-contexts: Our approach applies the principles of modulization and encapsulation in configuration management. It is well known that modulization and encapsulation is very useful in managing source programs. Similarly, they can help us greatly in handling configuration management. As pointed out by Osterweil <ref> [Osterweil 87] </ref>, software processes can be considered as special programs that are enacted by both human and computers. The data used by these special programs are software artifacts like source code, derived objects, system models, documentation, version history files, etc.
Reference: [Rochkind 75] <author> Marc J. Rochkind, </author> <title> The Source Code Control System, </title> <journal> in IEEE Transactions on Software Engineering, pp. </journal> <volume> 364-370, Vol 1 No 4, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: In our environment, a new version internally uses its predecessor version as its prototype, and stores only the attributes that are modified on the new version. Delegation, in this respect, is similar to version control systems like RCS [Tichy 85] and SCCS <ref> [Rochkind 75] </ref>, where only the deltas between versions are stored. But using delegation has an additional benefit - versions can be accessed directly without check-in and check-out operations. Internally, attributes are shared between versions. <p> Our framework shares the same goals with VESTA in system building, but uses an object-oriented approach instead of a functional approach. The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS <ref> [Rochkind 75] </ref> and RCS [Tichy 85] handle the versions of files only. CVS [Berliner] enhances RCS by letting programmers handle versions of directories. DSEE [Leblang 84] allows version selection in terms of threads that refers to files or other threads.
Reference: [Rumbaugh 88] <author> James Rumbaugh, </author> <title> Controlling Propagation of Operations using Attributes on Relations, </title> <booktitle> ACM OOPSLA 88 Proceedings, </booktitle> <pages> pp. 285-296, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Adele [Estublier 85] extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph. Compared with our framework, Adele is more exible to handle variants of versions, but it is also more complicated. Rumbaugh <ref> [Rumbaugh 88] </ref> proposed a framework to control the propagation of operations between objects. The propagation policy is based on attributes associated with relations. Our framework also relies on the propagation of operations to handle composite objects.
Reference: [Stein 87] <author> Lynn Andrea Stein, </author> <title> Delegation is Inheritance, </title> <booktitle> in ACM OOPSLA 87, </booktitle> <pages> pp. 138-146, </pages> <month> October </month> <year> 1987. </year>
Reference: [Teitelman 84] <author> Warren Teitelman, </author> <title> A tour through Cedar, </title> <booktitle> in IEEE Software, </booktitle> <pages> pp. 44-73, </pages> <month> Apr </month> <year> 1984. </year>
Reference: [Simmonds 89] <author> Ian Simmonds, </author> <title> Configuration Management in the PACT Software Engineering Environment, </title> <booktitle> in Proceedings of the 2nd International Workshop on Software Configuration Management, </booktitle> <editor> (Peter H. Feiler, </editor> <publisher> ed.), </publisher> <pages> pp. 118-121, </pages> <month> October, </month> <year> 1989. </year>
Reference: [Tichy 85] <author> Walter F. Tichy, </author> <title> RCS - A System for Version Control, </title> <journal> in Software Practice & Experience, </journal> <volume> Vol. 15, No. 7, </volume> <pages> pp. 637-654, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The Model In current environments, configuration management is handled with tools that run on top of data repositories. For example, traditional UNIX programming environments manage configuration with tools like MAKE [Feldman 79] and RCS <ref> [Tichy 85] </ref> that operate on files and directories. STONEMAN [Buxton 80] envisioned configuration management in an Ada Programming Support Environment (APSE) as tools running on top of a database. <p> In our environment, a new version internally uses its predecessor version as its prototype, and stores only the attributes that are modified on the new version. Delegation, in this respect, is similar to version control systems like RCS <ref> [Tichy 85] </ref> and SCCS [Rochkind 75], where only the deltas between versions are stored. But using delegation has an additional benefit - versions can be accessed directly without check-in and check-out operations. Internally, attributes are shared between versions. <p> Our framework shares the same goals with VESTA in system building, but uses an object-oriented approach instead of a functional approach. The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [Rochkind 75] and RCS <ref> [Tichy 85] </ref> handle the versions of files only. CVS [Berliner] enhances RCS by letting programmers handle versions of directories. DSEE [Leblang 84] allows version selection in terms of threads that refers to files or other threads.
Reference: [Ungar 87] <author> David Ungar and Randall B. Smith, </author> <title> Self: The Power of Simplicity, </title> <booktitle> in ACM OOPSLA 87, </booktitle> <month> October </month> <year> 1987. </year>
Reference: [Zdonik 86] <author> Stanley B. Zdonik, </author> <title> Version Management in an Object-Oriented database, in Advanced Programming Environments, </title> <editor> (R. Conradi, T. M. Did-riksen, and D. H. Wanvik, </editor> <publisher> ed.), </publisher> <pages> pp. 405-422, </pages> <year> 1986. </year>
Reference-contexts: Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism <ref> [Zdonik 86] </ref>. PCTE+ [Boudier 88] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [Katz 90]. Several other systems also aim to free programmers from the management of derived objects.
References-found: 27

