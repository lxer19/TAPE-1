URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/papers_and_books/Nestmann_Pierce.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Title: Decoding Choice Encodings  
Author: Uwe Nestmann Benjamin C. Pierce 
Date: April 1996  
Abstract: We study two encodings of the asynchronous -calculus with input-guarded choice into its choice-free fragment. One encoding is divergence-free, but reones the atomic commitment of choice into gradual commitment. The other preserves atomicity, but introduces divergence. The divergent encoding is fully abstract with respect to weak bisimulation, but the more natural divergence-free encoding is not. Instead, we show that it is fully abstract with respect to coupled simulation, a slightly coarser but still coinductively deoned equivalence that does not require bisimilarity of internal branching decisions. The correctness proofs for the two choice encodings exploit the properties of decodings from translations to source terms. 
Abstract-found: 1
Intro-found: 1
Reference: [ACS96] <author> Roberto M. Amadio, Ilaria Castellani, and Davide Sangiorgi. </author> <title> On Bisimulations for the Asynchronous -Calculus. </title> <type> Technical Report CNRS/INRIA Sophia-Antipolis, </type> <note> submitted for publication, </note> <month> March </month> <year> 1996. </year>
Reference-contexts: Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point <ref> [San95d, ACS96] </ref>. We use standard notation for the restriction (x) P of name x to process P , for parallel composition P 1 jP 2 , input y (x):P of a name x from channel y for use in P , and output yhzi of name z on channel y. <p> The choice operator is onite and all the branches of a choice must be guarded by input preoxes (in <ref> [ACS96] </ref>, there are also o -guards). 2.1 Syntax Let N be a countable set of names. Let the booleans B be ft; f g with B " N = ; and values V be N [ B. <p> In contrast, Sangiorgi suggested that we keep to the standard labelled semantic rules, but instead incorporate the asynchronous style of input-experiments into the deonition of simulation such that inputs of processes have to be simulated only indirectly by observing the processes' output behavior in the context of arbitrary messages <ref> [San95d, ACS96] </ref>. In this paper, we follow the latter approach. <p> Lemma 2.3.2 is a congruence on S. Proof: Weak asynchronous bisimulation has been shown to be preserved by name-instan-tiation on P without conditionals <ref> [ACS96] </ref> (see also [Hon92] for the corresponding result, apart from choice, in the -calculus). Since we only allow input-guarded choice (there are no o -guards) we also have the congruence of for our choice operator. <p> Nevertheless, the further development in this paper does not depend on this decision. Note also that early and late bisimulation coincide in our setting <ref> [ACS96] </ref>. 22 waiting for values to be consumed and resent. Processes with such receive-and-resend behavior are (weak asynchronous) bisimilar to 0 and are also called identity receptors [HT92]. In fact, a stronger property holds: Lemma 6.2.2 Let B 6= ;. <p> We think that equivalence notions along this line deserve further investigation. Axiomatizations of both weak asynchronous bisimulation and asynchronous coupled simulation are not yet known. Alternative formulations of the deonitions of asynchronous bisimulation (see <ref> [ACS96] </ref>, also for an axiomatization in the strong case) might prove conve nient for onding modal characterizations and also, in general, for establishing bisimulations. Endomorphic encodings into a language fragment, like the ones which we investigated in this paper, are easier to deal with than encodings between dioeerent languages.
Reference: [AH92] <author> S. Arun-Kumar and Matthew Hennessy. </author> <title> An EOEciency Preorder for Processes. </title> <journal> Acta Informatica, </journal> <note> 29:737760, 1992. Previously published as Computer Science Report 90:05, </note> <institution> University of Sussex. </institution>
Reference-contexts: Furthermore, due to the associativity law for composition, we omit brackets in multiple parallel composition and use onite parallel composition Q with the usual meaning. EOEciency Often, weakly bisimilar processes dioeer only in the number of internal steps. The expansion preorder <ref> [AH92] </ref> takes this into account by stating that one process engages in at least as many internal actions as another. Thus, its deonition pays more attention to internal steps.
Reference: [ALT95] <author> Roberto Amadio, Lone Leth, and Bent Thomsen. </author> <title> From a Concurrent -Calculus to the -Calculus. </title> <editor> In Horst Reichel, editor, </editor> <booktitle> Proceedings of 10th International Conference on Fundamentals of Computation Theory (FCT '95, Dresden, Germany), volume 965 of Lecture Notes in Computer Science, </booktitle> <pages> pages 106115. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <note> Full version as Technical Report ECRC-95-18. </note>
Reference-contexts: Promptness also leads to `nice' proof obligations since it requires case analysis over single computation steps. However, non-prompt encodings, which allow administrative (or book-keeping) steps preceding a committing step, unfortunately, do not satisfy I. Sometimes, as in <ref> [Ama94, ALT95] </ref>, they are well behaved in that pre-administrative steps can be captured by a con AEuent and strongly normalizing reduction relation. Then, the encoding is optimized to per form itself the initial administrative overhead by mapping source terms onto administrative normal forms, such that I holds. <p> However, in this setting principal steps could always be chosen as the initial steps. Committing steps have also been recognized by distinguishing real and administrative steps in the non-prompt encoding of Facile [Ama94] and the concurrent -calculus <ref> [ALT95] </ref> into the -calculus. In both settings, however, pre-administrative steps were normalizable, allowing for an optimized prompt encoding, which is not the case in the choice encodings. <p> Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [Ama93] <author> Roberto Amadio. </author> <title> On the Reduction of CHOCS Bisimulation to -Calculus Bisimula tion. </title> <booktitle> In Best [Bes93], </booktitle> <pages> pages 112126. </pages> <note> Extended version as Rapport de Recherche 1786, INRIA-Lorraine, </note> <year> 1993. </year>
Reference-contexts: Encodings of languages into fragments of themselves have been proposed or investi gated by several authors, e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi <ref> [San93, Tho93, Ama93] </ref>, the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be
Reference: [Ama94] <author> Roberto Amadio. </author> <title> Translating Core Facile. </title> <type> Technical Report ECRC-94-3, </type> <institution> European Computer-Industry Research Centre, Mnchen, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Promptness also leads to `nice' proof obligations since it requires case analysis over single computation steps. However, non-prompt encodings, which allow administrative (or book-keeping) steps preceding a committing step, unfortunately, do not satisfy I. Sometimes, as in <ref> [Ama94, ALT95] </ref>, they are well behaved in that pre-administrative steps can be captured by a con AEuent and strongly normalizing reduction relation. Then, the encoding is optimized to per form itself the initial administrative overhead by mapping source terms onto administrative normal forms, such that I holds. <p> However, in this setting principal steps could always be chosen as the initial steps. Committing steps have also been recognized by distinguishing real and administrative steps in the non-prompt encoding of Facile <ref> [Ama94] </ref> and the concurrent -calculus [ALT95] into the -calculus. In both settings, however, pre-administrative steps were normalizable, allowing for an optimized prompt encoding, which is not the case in the choice encodings. <p> The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile <ref> [Ama94] </ref>, Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Bes93] <editor> Eike Best, editor. </editor> <booktitle> Fourth International Conference on Concurrency Theory (CONCUR '93), volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference: [BG95] <author> Nadia Busi and Roberto Gorrieri. </author> <title> Distributed ConAEicts in Communicating Systems. </title> <editor> In Paolo Ciancarini, Oscar Nierstrasz, and Akinori Yonezawa, editors, </editor> <booktitle> Object-Based Models and Languages for Concurrent Systems (Bologna, </booktitle> <address> Italy, </address> <month> July </month> <year> 1994), </year> <booktitle> volume 924 of Lecture Notes in Computer Science, </booktitle> <pages> pages 4965. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <note> Also as University of Bologna Technical Report UBLCS-94-8. </note>
Reference-contexts: More practically, it provides correctness arguments supporting the design of high-level concurrent languages on top of process calculi. Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication <ref> [Mit86, PS92, Kna93, BG95] </ref>. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. <p> Our encodings dioeer in that they address the implementation of channel-based choice in the context of an underlying medium supplying asynchronous message-passing; they are thus more closely related to the work of Mitchell [Mit86], Knabe [Kna93], and Busi and Gorrieri <ref> [BG95] </ref>. In [Mit86], a divergent choice encoding in the rather restricted setting of Static CCS was proved correct with respect to an adapted (`weak-must') testing equivalence that accepts divergent implementations (o ! jP ) of P as valid, but that lacks a powerful (e.g. coinductive) proof technique. <p> The emphasis was more on the question of deadlock-freedom; a proof was sketched in [Kna93]. However, the semantics and implementation of this and other choice operators have been studied by using the chemical abstract machine framework for the semantics of Facile [LT95]. In the CCS-setting of <ref> [BG95] </ref>, choice is replaced by a lower-level notion of conAEict that is based on a set of conAEict names (and contrasting conames) together with corresponding preox and restriction operators. <p> In fact, the choice encodings of the current paper follow the same idea of a posteriori choice as in <ref> [BG95] </ref>; yet, we go a step further. In our case, concurrent branches in a choice may start their activity by consuming matching messages from the environment that afterwards might have to be given back.
Reference: [Bou92] <author> Grard Boudol. </author> <title> Asynchrony and the -calculus (note). </title> <institution> Rapport de Recherche 1702, INRIA Sophia-Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication [Mit86, PS92, Kna93, BG95]. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus <ref> [HT91, Bou92] </ref> enriched with several layers of encoded syntactic sugar. The ab stract machine of Pict does not provide instructions for selective communication; instead, choice is provided as a library module by a straightforward encoding. <p> This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics <ref> [Bou92] </ref>; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences [Ode95a, FG96]. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> We use here a version which is close to the core language of Pict [PT95, PT96], but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus <ref> [HT91, Bou92] </ref>. Replication is restricted to input processes and evaluated lazily [HY93, MP95]. <p> fragments of themselves have been proposed or investi gated by several authors, e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi [San93, Tho93, Ama93], the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus <ref> [Bou92] </ref>, several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be inter preted as a fragment of the -calculus), and the translation of the choice-free synchronous -calculus into trios [Par95].
Reference: [But94] <author> Karl-Heinz Buth. </author> <title> Simulation of SOS Deonitions with Term Rewriting Systems. </title> <booktitle> In Sannella [San94b], </booktitle> <pages> pages 150164. </pages>
Reference-contexts: The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems <ref> [OR94, But94] </ref>, addressing both semantics and implementation issues. Future work The observation that the completeness simulation C and the soundness simulation S are faithful and strict, respectively, and both progressing, suggests the study of enhancements of coupled simulation equivalence.
Reference: [FG96] <author> Cdric Fournet and Georges Gonthier. </author> <title> The ReAEexive Chemical Abstract Machine and the Join-Calculus. </title> <booktitle> In POPL '96 [POP96], </booktitle> <pages> pages 372385. </pages>
Reference-contexts: This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences <ref> [Ode95a, FG96] </ref>. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> Consequently, instead of abandoning input-experiments completely, asynchronous observation captures input-experiments indirectly by performing output-experiments in the context of arbitrary messages. These considerations have also led to the development of output-only barbed congruence <ref> [Ode95a, FG96] </ref> based on reduction semantics [HY93]. <p> within process calculi [San93, Tho93, Ama93], the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus <ref> [FG96] </ref> (which may be inter preted as a fragment of the -calculus), and the translation of the choice-free synchronous -calculus into trios [Par95]. Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. <p> Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus <ref> [FG96] </ref>, of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from <p> Furthermore, a correctness result will have to take into account that translations may only behave well in contexts that respect the protocol which is expected for the free names of the translation. Techniques like iorewallsj <ref> [FG96] </ref> might be necessary to protect translations from hostile contexts. Acknowledgements We are indebted to David N. Turner for the original asynchronous choice encodings in Pict, on which our encoding C [[ ]] is based. Ole Jensen helped us with clarifying intuitions on the nature of coupled simulation.
Reference: [Gam91] <author> Anders Gammelgaard. </author> <title> Constructing simulations chunk by chunk. </title> <type> Internal Report DAIMI IR-106, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> December </month> <year> 1991. </year> <title> Part of the authors' PhD Thesis Simulation Techniques, </title> <note> available as Report DAIMI PB-379. </note>
Reference-contexts: Note that every faithful simulation is progressing by deonition with upper bound 0. With a progressing simulation, every inonite sequence may be simulated by subse quently simulating suOEciently long onite subsequences non-trivially, i.e. such that they cause progress. This resembles the chunk-by-chunk idea of simulation in <ref> [Gam91] </ref>. Lemma 2.3.8 Progressing simulations preserve divergence. Proof: Let S be a progressing simulation and (P; Q) 2 S. <p> conAEicts via internal communication. 36 The idea of committing steps, i.e. those target steps which directly correspond to a source-level computation step, is comparable to the notion of principal transition that has been developed for proving the correctness of a compiler from an Occam-like programming language into an assembler language <ref> [Gam91] </ref>. However, in this setting principal steps could always be chosen as the initial steps. Committing steps have also been recognized by distinguishing real and administrative steps in the non-prompt encoding of Facile [Ama94] and the concurrent -calculus [ALT95] into the -calculus. <p> The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam <ref> [Gam91] </ref>, Facile [Ama94], Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Gla93] <author> Rob van Glabbeek. </author> <title> The Linear Time Branching Time Spectrum II: The semantics of sequential systems with silent moves (Extended Abstract). </title> <booktitle> In Best [Bes93], </booktitle> <pages> pages 6681. </pages>
Reference-contexts: This style induces a relation which is an equivalence only for convergent pro cesses, and it has been proven to be strictly weaker than bisimulation and strictly stronger than testing equivalence [PS92]. In this paper, we use a generalization for divergent pro cesses, as suggested in <ref> [Gla93, PS94] </ref>, where coupling requires the ability of a simulating process to evolve into a simulated process by internal action.
Reference: [Gla94] <author> David Gladstein. </author> <title> Compiler Correctness for Concurrent Languages. </title> <type> PhD thesis, </type> <institution> North eastern University, </institution> <month> December </month> <year> 1994. </year> <month> 49 </month>
Reference-contexts: The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang <ref> [Gla94] </ref>, and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Hon92] <author> Kohei Honda. </author> <title> Two Bisimilarities in -Calculus. </title> <type> CS report 92-002, </type> <institution> Keio University, </institution> <year> 1992. </year> <note> Revised on March 31, </note> <year> 1993. </year>
Reference-contexts: Supported by the British Science and Engineering Research Council. 1 We study choice encodings in the -calculus with asynchronous messages (or equiv alently, with non-blocking output preox). This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics <ref> [HT91, HT92, Hon92] </ref>; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences [Ode95a, FG96]. <p> Two dioeerent formulations of asynchronous bisimulation have been proposed. Honda and Tokoro <ref> [HT91, HT92, Hon92] </ref> introduced a modioed input rule in order to model asynchronous input-experiments explicitly: P yhzi ! P j yhzi This rule allows for any system at any time to accept an arbitrary message without the necessity of containing a matching receptor consuming it. <p> Lemma 2.3.2 is a congruence on S. Proof: Weak asynchronous bisimulation has been shown to be preserved by name-instan-tiation on P without conditionals [ACS96] (see also <ref> [Hon92] </ref> for the corresponding result, apart from choice, in the -calculus). Since we only allow input-guarded choice (there are no o -guards) we also have the congruence of for our choice operator.
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An Object Calculus for Asynchronous Communication. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 133147. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication [Mit86, PS92, Kna93, BG95]. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus <ref> [HT91, Bou92] </ref> enriched with several layers of encoded syntactic sugar. The ab stract machine of Pict does not provide instructions for selective communication; instead, choice is provided as a library module by a straightforward encoding. <p> Supported by the British Science and Engineering Research Council. 1 We study choice encodings in the -calculus with asynchronous messages (or equiv alently, with non-blocking output preox). This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics <ref> [HT91, HT92, Hon92] </ref>; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences [Ode95a, FG96]. <p> We use here a version which is close to the core language of Pict [PT95, PT96], but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus <ref> [HT91, Bou92] </ref>. Replication is restricted to input processes and evaluated lazily [HY93, MP95]. <p> Two dioeerent formulations of asynchronous bisimulation have been proposed. Honda and Tokoro <ref> [HT91, HT92, Hon92] </ref> introduced a modioed input rule in order to model asynchronous input-experiments explicitly: P yhzi ! P j yhzi This rule allows for any system at any time to accept an arbitrary message without the necessity of containing a matching receptor consuming it.
Reference: [HT92] <author> Kohei Honda and Mario Tokoro. </author> <title> On Asynchronous Communication Semantics. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Object-Based Concurrent Computing 1991, volume 612 of Lecture Notes in Computer Science, </booktitle> <pages> pages 2151. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: Supported by the British Science and Engineering Research Council. 1 We study choice encodings in the -calculus with asynchronous messages (or equiv alently, with non-blocking output preox). This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics <ref> [HT91, HT92, Hon92] </ref>; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences [Ode95a, FG96]. <p> Two dioeerent formulations of asynchronous bisimulation have been proposed. Honda and Tokoro <ref> [HT91, HT92, Hon92] </ref> introduced a modioed input rule in order to model asynchronous input-experiments explicitly: P yhzi ! P j yhzi This rule allows for any system at any time to accept an arbitrary message without the necessity of containing a matching receptor consuming it. <p> Note also that early and late bisimulation coincide in our setting [ACS96]. 22 waiting for values to be consumed and resent. Processes with such receive-and-resend behavior are (weak asynchronous) bisimilar to 0 and are also called identity receptors <ref> [HT92] </ref>. In fact, a stronger property holds: Lemma 6.2.2 Let B 6= ;.
Reference: [HY93] <author> Kohei Honda and Nobuko Yoshida. </author> <title> On Reduction-Based Process Semantics. </title> <editor> In R. K. Shyamasundar, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 373387. </pages> <publisher> Springer, </publisher> <year> 1993. </year> <note> Full version published in Theoretical Computer Science 152(2):437486, </note> <year> 1995. </year>
Reference-contexts: This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics <ref> [HY93] </ref>, concurrent combinators [HY94a, HY94b], and output-only barbed congruences [Ode95a, FG96]. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> We use here a version which is close to the core language of Pict [PT95, PT96], but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. Replication is restricted to input processes and evaluated lazily <ref> [HY93, MP95] </ref>. Furthermore, merely for notational convenience, it is equipped with a conditional form based on special boolean names, reminiscent of the v -calculus [Wal94], but not allowing for more complex boolean expressions; the condi tional can be seen as a very restricted form of matching. <p> Consequently, instead of abandoning input-experiments completely, asynchronous observation captures input-experiments indirectly by performing output-experiments in the context of arbitrary messages. These considerations have also led to the development of output-only barbed congruence [Ode95a, FG96] based on reduction semantics <ref> [HY93] </ref>. There is an analogy between asynchronous observers and internet users that communicate with each other via email: assuming that email is the only way to exchange information, a user can not see that his email has been read unless his communication partner has sent ooe some response. <p> In reduction semantics <ref> [MS92, HY93] </ref>, a structural congruence relation is adopted a priori in order to allow for simplioed presentations of the operational rules. In this paper, we use the structural laws (j) listed in Table 2 only in order to simplify the presentation of some derivation sequences of transitions. <p> This not always the case, as even for the tuple en coding into monadic -calculus channels are used dioeerently in source and target. Barbed bisimulation, which was invented to provide a uniform deonitional scheme of term equiva lence based on reduction semantics <ref> [MS92, HY93] </ref>, could be especially useful with respect to encodings between dioeerent calculi, since it rests on more laxer notions of observation. Also, a barbed deonition of coupled simulation, based on reduction semantics, might allow to prove results for encodings which are not fully abstract up to weak bisimulation.
Reference: [HY94a] <author> Kohei Honda and Nobuko Yoshida. </author> <booktitle> Combinatory Representation of Mobile Processes. In 21st Annual Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 348360. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators <ref> [HY94a, HY94b] </ref>, and output-only barbed congruences [Ode95a, FG96]. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> Thereby, we could use a correctness notion that is stronger than the usual full abstraction, which here comes up as a simple corollary. The strength of our correctness result may be compared with the notion of representability in <ref> [HY94a, HY94b] </ref>, where it was left as an open problem whether some form of summation could be behaviorally represented by con current combinators.
Reference: [HY94b] <author> Kohei Honda and Nobuko Yoshida. </author> <title> Replication in Concurrent Combinators. </title> <editor> In M. Hagiya and J. C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 786805. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators <ref> [HY94a, HY94b] </ref>, and output-only barbed congruences [Ode95a, FG96]. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> Thereby, we could use a correctness notion that is stronger than the usual full abstraction, which here comes up as a simple corollary. The strength of our correctness result may be compared with the notion of representability in <ref> [HY94a, HY94b] </ref>, where it was left as an open problem whether some form of summation could be behaviorally represented by con current combinators.
Reference: [Jon93] <author> Clioe Jones. </author> <title> A Pi-Calculus Semantics for an Object-Based Design Notation. </title> <booktitle> In Best [Bes93], </booktitle> <pages> pages 158172. </pages>
Reference-contexts: include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Kna93] <author> Frederick Knabe. </author> <title> A Distributed Protocol for Channel-Based Communication with Choice. </title> <journal> Computers and Artiocial Intelligence, </journal> <volume> 12(5):475490, </volume> <year> 1993. </year>
Reference-contexts: More practically, it provides correctness arguments supporting the design of high-level concurrent languages on top of process calculi. Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication <ref> [Mit86, PS92, Kna93, BG95] </ref>. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. <p> Our encodings dioeer in that they address the implementation of channel-based choice in the context of an underlying medium supplying asynchronous message-passing; they are thus more closely related to the work of Mitchell [Mit86], Knabe <ref> [Kna93] </ref>, and Busi and Gorrieri [BG95]. <p> Since the original deonition of stably coupled simulation equivalence has been shown to imply testing equivalence, we argue that our correctness result for the C-encoding is powerful, even though it is strictly more permissive than weak bisimulation. The distributed implementation of mixed guarded channel-based choice of <ref> [Kna93] </ref> has not been investigated concerning its functional correctness. The emphasis was more on the question of deadlock-freedom; a proof was sketched in [Kna93]. <p> The distributed implementation of mixed guarded channel-based choice of <ref> [Kna93] </ref> has not been investigated concerning its functional correctness. The emphasis was more on the question of deadlock-freedom; a proof was sketched in [Kna93]. However, the semantics and implementation of this and other choice operators have been studied by using the chemical abstract machine framework for the semantics of Facile [LT95]. <p> Finally, we are interested in more sophisticated divergence-free choice encodings as they are used in the Pict language, especially with respect to eOEciency and garbage collection issues. Further variants might address events [Rep92] or mixed guarded choice <ref> [Kna93] </ref>. All of these encodings have in common that they require channel manager processes in order to run more complicated protocols. Therefore, we cannot expect to be able to compare source terms and target terms directly.
Reference: [Lav93] <author> Carolina Lavatelli. </author> <title> Non-determinisitc lazy -calculus vs. -calculus. </title> <type> Technical Report LIENS-93-15, </type> <institution> Ecole Normale Suprieure, Paris, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [Li83] <author> Wei Li. </author> <title> An Operational Approach to Semantics and Translation for Concurrent Pro gramming Languages. </title> <type> PhD thesis, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> January </month> <year> 1983. </year> <note> Report CST-20-83. </note>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS <ref> [Li83, Mil87] </ref>, between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan
Reference: [Li94] <author> B. Li. </author> <title> A -calculus speciocation of Prolog. </title> <booktitle> In Sannella [San94b], </booktitle> <pages> pages 379393. </pages>
Reference-contexts: and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus <ref> [Ros92, Li94] </ref>, and from concurrent constraint languages into the -calculus [Smo94, VP96]. The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96].
Reference: [LT95] <author> Lone Leth and Bent Thomsen. </author> <title> Some facile chemistry. </title> <journal> Formal Aspects of Computing, </journal> <note> 7(3):314328, 1995. A Previous Version appeared as ECRC-Report ECRC-92-14. </note>
Reference-contexts: The emphasis was more on the question of deadlock-freedom; a proof was sketched in [Kna93]. However, the semantics and implementation of this and other choice operators have been studied by using the chemical abstract machine framework for the semantics of Facile <ref> [LT95] </ref>. In the CCS-setting of [BG95], choice is replaced by a lower-level notion of conAEict that is based on a set of conAEict names (and contrasting conames) together with corresponding preox and restriction operators.
Reference: [Mil87] <author> Mark Millington. </author> <title> Theories of Translation Correctness for Concurrent Porgramming Languages. </title> <type> PhD thesis, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> August </month> <year> 1987. </year> <note> Report CST-46-87. </note>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS <ref> [Li83, Mil87] </ref>, between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Bisimulation deones equivalence as mutual simulation of single computation steps resulting in equivalent system states. According to the standard literature on (ground) bisimulations, e.g. <ref> [Mil89, MPW89] </ref>, a simulation is a relation S on agents such that (P; Q) 2 S implies, for arbitrary label : 4 E-INP: y (x):P yhzi ! P f z = x g yhzi ! P f z = x g j ! y (x):P P y j (x):P j yhzi <p> P Q, rests on the construction of some bisimulation B which contains the pair (P; Q). Up-to techniques have been introduced in order to improve the bisimulation proof technique by relaxing the proof obligations and thereby reducing the size of the witness relation B <ref> [Mil89, San95b] </ref>. <p> Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs <ref> [Mil89, Mil91, Wal91b, Ode95a] </ref>, from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as Processes. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> Seventeenth Colloquium on Automata, Languages and Programming (ICALP) (Warwick, England), volume 443 50 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167180. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <note> Previous version as Rapport de Recherche 1154, INRIA Sophia-Antipolis, 1990. Final version published in Mathematical Structures in Computer Science 2(2):119141, </note> <year> 1992. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> University of Edinburgh, </institution> <month> October </month> <year> 1991. </year> <title> Published in Logic and Algebra of Speciocation, </title> <booktitle> Proceedings of International NATO Summer School 1991, </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Encodings of languages into fragments of themselves have been proposed or investi gated by several authors, e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi [San93, Tho93, Ama93], the transla tion of polyadic into monadic -calculus <ref> [Mil91] </ref>, the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be inter preted as a fragment of the -calculus), and the translation <p> Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs <ref> [Mil89, Mil91, Wal91b, Ode95a] </ref>, from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96]. <p> Sangiorgi, Peter Sewell, and the rest of the Edin burgh/Cambridge Pi Club and the Dienstagsclub at Erlangen joined us in many productive discussions. 38 A Appendix A.1 Choice encoding without primitive booleans We use polyadic -calculus, here, and instead of booleans we use a standard protocol for encoding their behavior <ref> [Mil91, Pie96] </ref> adapted to the needs of the example.
Reference: [Mit86] <author> Kevin Mitchell. </author> <title> Implementations of Process Synchronisation and their Analysis. </title> <type> PhD thesis, </type> <institution> LFCS, University of Edinburgh, </institution> <month> July </month> <year> 1986. </year>
Reference-contexts: More practically, it provides correctness arguments supporting the design of high-level concurrent languages on top of process calculi. Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication <ref> [Mit86, PS92, Kna93, BG95] </ref>. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. <p> Our encodings dioeer in that they address the implementation of channel-based choice in the context of an underlying medium supplying asynchronous message-passing; they are thus more closely related to the work of Mitchell <ref> [Mit86] </ref>, Knabe [Kna93], and Busi and Gorrieri [BG95]. In [Mit86], a divergent choice encoding in the rather restricted setting of Static CCS was proved correct with respect to an adapted (`weak-must') testing equivalence that accepts divergent implementations (o ! jP ) of P as valid, but that lacks a powerful (e.g. <p> Our encodings dioeer in that they address the implementation of channel-based choice in the context of an underlying medium supplying asynchronous message-passing; they are thus more closely related to the work of Mitchell <ref> [Mit86] </ref>, Knabe [Kna93], and Busi and Gorrieri [BG95]. In [Mit86], a divergent choice encoding in the rather restricted setting of Static CCS was proved correct with respect to an adapted (`weak-must') testing equivalence that accepts divergent implementations (o ! jP ) of P as valid, but that lacks a powerful (e.g. coinductive) proof technique.
Reference: [MP95] <author> Ugo Montanari and Marco Pistore. </author> <title> Concurrent Semantics for the -calculus. </title> <editor> In Steve Brookes, Michael Main, Austin Melton, and Michael Mislove, editors, </editor> <booktitle> Proceedings of the Eleventh Annual Conference on Mathematical Foundations of Programming Semantics, </booktitle> <institution> (Tulane University, </institution> <address> New Orleans, LA, March 29 April 1, </address> <year> 1995), </year> <booktitle> volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elesevier Science Publishers, </publisher> <year> 1995. </year>
Reference-contexts: We use here a version which is close to the core language of Pict [PT95, PT96], but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. Replication is restricted to input processes and evaluated lazily <ref> [HY93, MP95] </ref>. Furthermore, merely for notational convenience, it is equipped with a conditional form based on special boolean names, reminiscent of the v -calculus [Wal94], but not allowing for more complex boolean expressions; the condi tional can be seen as a very restricted form of matching.
Reference: [MPW89] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A Calculus of Mobile Processes, Part I/II. </title> <type> Technical Report ECS-LFCS-89-85/86, </type> <institution> Laboratory for Foundations of Com puter Science, University of Edinburgh, </institution> <month> June </month> <year> 1989. </year> <note> Published in Information and Com putation 100:177, </note> <year> 1992. </year>
Reference-contexts: Finally, we ooeer some concluding remarks and sketch related and future work (Section 7). 2 Technical preliminaries Many variants of the -calculus <ref> [MPW89] </ref> have appeared in the recent process algebra liter ature. We use here a version which is close to the core language of Pict [PT95, PT96], but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. <p> Bisimulation deones equivalence as mutual simulation of single computation steps resulting in equivalent system states. According to the standard literature on (ground) bisimulations, e.g. <ref> [Mil89, MPW89] </ref>, a simulation is a relation S on agents such that (P; Q) 2 S implies, for arbitrary label : 4 E-INP: y (x):P yhzi ! P f z = x g yhzi ! P f z = x g j ! y (x):P P y j (x):P j yhzi <p> Bisimulation in name-passing calculi is not a congruence by itself. The main obstacle is that it is not preserved by name-instantiation in the presence of matching and summa tion <ref> [MPW89] </ref>.
Reference: [MS92] <author> Robin Milner and Davide Sangiorgi. </author> <title> Barbed bisimulation. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Nine teenth Colloquium on Automata, Languages and Programming (ICALP) (Wien, Aus tria), volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 685695. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: In reduction semantics <ref> [MS92, HY93] </ref>, a structural congruence relation is adopted a priori in order to allow for simplioed presentations of the operational rules. In this paper, we use the structural laws (j) listed in Table 2 only in order to simplify the presentation of some derivation sequences of transitions. <p> This not always the case, as even for the tuple en coding into monadic -calculus channels are used dioeerently in source and target. Barbed bisimulation, which was invented to provide a uniform deonitional scheme of term equiva lence based on reduction semantics <ref> [MS92, HY93] </ref>, could be especially useful with respect to encodings between dioeerent calculi, since it rests on more laxer notions of observation. Also, a barbed deonition of coupled simulation, based on reduction semantics, might allow to prove results for encodings which are not fully abstract up to weak bisimulation.
Reference: [Nie96] <author> Joachim Niehren. </author> <title> Functional Computation as Concurrent Computation. </title> <note> In POPL '96 [POP96]. </note>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [Ode95a] <author> Martin Odersky. </author> <title> Applying : Towards a Basis for Concurrent Imperative Programming. </title> <editor> In Uday S. Reddy, editor, </editor> <booktitle> Second ACM SIGPLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 95108. </pages> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign (San Francisco, California), </institution> <note> January 22 1995. Available as Techni cal Report UIUCDCS-R-95-1900 or via http://vesuvius.cs.uiuc.edu:8080/sipl/- index.html. </note>
Reference-contexts: This setting has received increasing attention in recent years. In the -calculus, asynchrony was treated using a non-standard labelled semantics [HT91, HT92, Hon92]; the mini -calculus used a chemical semantics [Bou92]; it has also been investigated using reduction semantics [HY93], concurrent combinators [HY94a, HY94b], and output-only barbed congruences <ref> [Ode95a, FG96] </ref>. Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point [San95d, ACS96]. <p> Consequently, instead of abandoning input-experiments completely, asynchronous observation captures input-experiments indirectly by performing output-experiments in the context of arbitrary messages. These considerations have also led to the development of output-only barbed congruence <ref> [Ode95a, FG96] </ref> based on reduction semantics [HY93]. <p> Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs <ref> [Mil89, Mil91, Wal91b, Ode95a] </ref>, from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Ode95b] <author> Martin Odersky. </author> <title> Polarized Name Passing. </title> <booktitle> In Proceedings of 15th Conference on Foun dations of Software Technology and Theoretical Computer Science (Bangalore, </booktitle> <address> India, </address> <month> December 1820, </month> <year> 1995), </year> <booktitle> volume 1026 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [OR94] <author> Vincent van Oostrom and Femke van Raamsdonk. </author> <title> Comparing Combinatory Reduction Systems and Higher-Order Rewrite Systems. </title> <editor> In J. Heering, K. Meinke, B. Mller, and T. Nipkow, editors, </editor> <title> Higher-Order Algebra, Logic and Term Rewriting 1993, </title> <booktitle> volume 816 of Lecture Notes in Computer Science, </booktitle> <pages> pages 276304. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems <ref> [OR94, But94] </ref>, addressing both semantics and implementation issues. Future work The observation that the completeness simulation C and the soundness simulation S are faithful and strict, respectively, and both progressing, suggests the study of enhancements of coupled simulation equivalence.
Reference: [Par95] <author> Joachim Parrow. </author> <title> Trios in Concert. </title> <type> (Draft), </type> <month> July </month> <year> 1995. </year>
Reference-contexts: within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be inter preted as a fragment of the -calculus), and the translation of the choice-free synchronous -calculus into trios <ref> [Par95] </ref>. Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity.
Reference: [Pie96] <author> Benjamin C. Pierce. </author> <title> Programming in the Pi-Calculus: An Experiment in Programming Language Design. Distributed with the Pict implementation, </title> <booktitle> 1996. 51 [POP96] 23rd Annual Symposium on Principles of Programming Languages (POPL) (St. </booktitle> <address> Peters burg Beach, Florida). </address> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year>
Reference-contexts: Sangiorgi, Peter Sewell, and the rest of the Edin burgh/Cambridge Pi Club and the Dienstagsclub at Erlangen joined us in many productive discussions. 38 A Appendix A.1 Choice encoding without primitive booleans We use polyadic -calculus, here, and instead of booleans we use a standard protocol for encoding their behavior <ref> [Mil91, Pie96] </ref> adapted to the needs of the example.
Reference: [Pri78] <author> Lutz Priese. </author> <title> On the Concept of Simulation in Asynchronous, Concurrent Systems. </title> <booktitle> In Progress in Cybernetics and Systems Research, volume VII, </booktitle> <pages> pages 8592. </pages> <institution> Hemisphere Dubl. Corp., </institution> <year> 1978. </year> <booktitle> Proceedings of EMCSR (1978, </booktitle> <address> Linz, Austria). </address>
Reference-contexts: A weak simulation S has this property if P * implies Q * for all (P; Q) 2 S. Intuitively, when required to weakly simulate an inonite o -sequence, S must progress inonitely often. Let us introduce some further notation (inspired by <ref> [Pri78] </ref>) to make precise what this means. Let ! n denote a o -sequence of length n and o o ! n for n &gt; 0 denote a non-trivial, but arbitrarily long onite sequence of o -steps.
Reference: [PS92] <author> Joachim Parrow and Peter Sjdin. </author> <title> Multiway Synchronization Verioed with Coupled Sim ulation. </title> <editor> In Rance Cleaveland, editor, </editor> <booktitle> Third International Conference on Concurrency Theory (CONCUR '92, </booktitle> <address> Stony Brook, NY), </address> <booktitle> volume 630 of Lecture Notes in Computer Science, </booktitle> <pages> pages 518533. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: More practically, it provides correctness arguments supporting the design of high-level concurrent languages on top of process calculi. Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication <ref> [Mit86, PS92, Kna93, BG95] </ref>. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict [PT95, PT96], an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. <p> In order to deal with partially committed states, we instead characterize the correctness of the encoding as a pair of opposite simulations which are coupled by requiring that less committed (i.e. simulating) processes can always internally evolve into more committed (i.e. simulated) processes <ref> [PS92] </ref>. For comparison, we also study another encoding that introduces an alternate path in each branch of a choice that allows it to iback outj and return to its initial state after it has been given the lock. <p> As an appropriate mathematical tool to handle situations as the above CCS-example, Parrow and Sjdin developed the notion of coupled simulation <ref> [PS92] </ref>: two contrary simu lations are no longer required to coincide, but only to be coupled in a certain way. Several candidates have been presented for what it means to be coupled. No coupling at all would lead to the notion of trace equivalence. <p> This style induces a relation which is an equivalence only for convergent pro cesses, and it has been proven to be strictly weaker than bisimulation and strictly stronger than testing equivalence <ref> [PS92] </ref>. In this paper, we use a generalization for divergent pro cesses, as suggested in [Gla93, PS94], where coupling requires the ability of a simulating process to evolve into a simulated process by internal action. <p> If T is not partial, then S 0 and S 00 coincide. 35 Related work The C-encoding represents a striking example where weak bisimulation is too strong a criterion to compare process systems. It is similar to the multiway synchronization example of <ref> [PS92] </ref>. The latter led to the deonition of coupled simulation in order to deal with gradual commitments, which do also appear in the C-encoding.
Reference: [PS94] <author> Joachim Parrow and Peter Sjdin. </author> <title> The Complete Axiomatization of cs-Congruence. </title> <editor> In P. Enjalbert, E. W. Mayr, and K. W. Wagner, editors, </editor> <booktitle> STACS '94, volume 775 of Lecture Notes in Computer Science, </booktitle> <pages> pages 557568. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: This style induces a relation which is an equivalence only for convergent pro cesses, and it has been proven to be strictly weaker than bisimulation and strictly stronger than testing equivalence [PS92]. In this paper, we use a generalization for divergent pro cesses, as suggested in <ref> [Gla93, PS94] </ref>, where coupling requires the ability of a simulating process to evolve into a simulated process by internal action.
Reference: [PT95] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent Objects in a Process Calculus. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Program ming (TPPP, Sendai, Japan, 1994), volume 907 of Lecture Notes in Computer Science, </booktitle> <pages> pages 187215. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication [Mit86, PS92, Kna93, BG95]. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict <ref> [PT95, PT96] </ref>, an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. The ab stract machine of Pict does not provide instructions for selective communication; instead, choice is provided as a library module by a straightforward encoding. <p> Finally, we ooeer some concluding remarks and sketch related and future work (Section 7). 2 Technical preliminaries Many variants of the -calculus [MPW89] have appeared in the recent process algebra liter ature. We use here a version which is close to the core language of Pict <ref> [PT95, PT96] </ref>, but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. Replication is restricted to input processes and evaluated lazily [HY93, MP95]. <p> include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [PT96] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <note> Technical report in preparation; available electronically, </note> <year> 1996. </year>
Reference-contexts: Furthermore, it is tightly related to the distributed im plementation of synchronization and selective communication [Mit86, PS92, Kna93, BG95]. Our interest in the study of choice encodings originates from the design and implementa tion of the high-level concurrent language Pict <ref> [PT95, PT96] </ref>, an asynchronous choice-free -calculus [HT91, Bou92] enriched with several layers of encoded syntactic sugar. The ab stract machine of Pict does not provide instructions for selective communication; instead, choice is provided as a library module by a straightforward encoding. <p> Finally, we ooeer some concluding remarks and sketch related and future work (Section 7). 2 Technical preliminaries Many variants of the -calculus [MPW89] have appeared in the recent process algebra liter ature. We use here a version which is close to the core language of Pict <ref> [PT95, PT96] </ref>, but slightly simplioed in order to shorten the presentation in this paper. It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. Replication is restricted to input processes and evaluated lazily [HY93, MP95]. <p> The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict <ref> [PT96] </ref>. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Rep92] <author> John Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> June </month> <year> 1992. </year> <type> Technical Report TR 92-1285. </type>
Reference-contexts: Finally, we are interested in more sophisticated divergence-free choice encodings as they are used in the Pict language, especially with respect to eOEciency and garbage collection issues. Further variants might address events <ref> [Rep92] </ref> or mixed guarded choice [Kna93]. All of these encodings have in common that they require channel manager processes in order to run more complicated protocols. Therefore, we cannot expect to be able to compare source terms and target terms directly.
Reference: [Ros92] <author> Brian Ross. </author> <title> A -Calculus Semantics of Logical Variables and Uniocation. </title> <editor> In S. Pu rushothaman and A. Zwarico, editors, </editor> <booktitle> NAPAW '92, Proceedings of the First North American Process Algebra Workshop (Stony Brook, </booktitle> <address> NY), pages 13.113.14. </address> <institution> Johns Hop kins University, Pennsylvania State University, </institution> <year> 1992. </year> <note> Available as PennState Technical Report 92-17. </note>
Reference-contexts: and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus <ref> [Ros92, Li94] </ref>, and from concurrent constraint languages into the -calculus [Smo94, VP96]. The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96].
Reference: [San92] <author> Davide Sangiorgi. </author> <title> The Lazy Lambda Calculus in a Concurrency Scenario. </title> <booktitle> In Seventh Annual Symposium on Logic in Computer Science (LICS) (Santa Cruz, California), </booktitle> <pages> pages 102109. </pages> <publisher> IEEE, Computer Society Press, </publisher> <month> June </month> <year> 1992. </year> <note> Earlier version as Report ECS-LFCS-91-189, University of Edinburgh. Final version published in Information and Computation 111(1):120131, </note> <year> 1994. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [San93] <author> Davide Sangiorgi. </author> <title> From -Calculus to Higher-Order -Calculus and Back. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> TAPSOFT '93, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151166. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Encodings of languages into fragments of themselves have been proposed or investi gated by several authors, e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi <ref> [San93, Tho93, Ama93] </ref>, the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be
Reference: [San94a] <author> Davide Sangiorgi. </author> <title> An Investigation into Functions as Processes. </title> <editor> In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, </editor> <booktitle> Mathematical Foundations of Program ming Semantics 1993, volume 802 of Lecture Notes in Computer Science, </booktitle> <pages> pages 143159. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [San94b] <editor> D. Sannella, editor. </editor> <booktitle> Fifth European Symposion on Programming (ESOP '94), volume 788 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year> <month> 52 </month>
Reference: [San95a] <author> Davide Sangiorgi. </author> <title> Lazy functions and mobile processes. </title> <institution> Rapport de Recherche RR-2515, INRIA Sophia-Antipolis, </institution> <year> 1995. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [San95b] <author> Davide Sangiorgi. </author> <title> On the Bisimulation Proof Method. </title> <editor> In J. Wiedemann and P. Hajek, editors, </editor> <booktitle> Twentienth Mathematical Foundations of Computer Science, volume 969 of Lec ture Notes in Computer Science, </booktitle> <pages> pages 479488. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <note> Available as Edinburgh Technical Report ECS-LFCS-94-299. </note>
Reference-contexts: P Q, rests on the construction of some bisimulation B which contains the pair (P; Q). Up-to techniques have been introduced in order to improve the bisimulation proof technique by relaxing the proof obligations and thereby reducing the size of the witness relation B <ref> [Mil89, San95b] </ref>.
Reference: [San95c] <author> Davide Sangiorgi. </author> <title> -Calculus, Internal Mobility and Agent-Passing Calculi. </title> <institution> Rapport de Recherche RR-2539, INRIA Sophia-Antipolis, </institution> <year> 1995. </year> <note> Extracts of parts of the material contained in this paper can be found in the Proceedings of TAPSOFT'95 and ICALP'95. </note>
Reference-contexts: e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi [San93, Tho93, Ama93], the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility <ref> [San95c] </ref>, the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be inter preted as a fragment of the -calculus), and the translation of the choice-free synchronous -calculus into trios [Par95].
Reference: [San95d] <author> Davide Sangiorgi. </author> <title> Some Thoughts on Asynchrony. Unpublished note, </title> <month> April </month> <year> 1995. </year>
Reference-contexts: Only recently, it has been extended with an input-guarded choice operator, equipped with a standard labelled semantics, and studied with bisimulation from an asynchronous observer's view point <ref> [San95d, ACS96] </ref>. We use standard notation for the restriction (x) P of name x to process P , for parallel composition P 1 jP 2 , input y (x):P of a name x from channel y for use in P , and output yhzi of name z on channel y. <p> In contrast, Sangiorgi suggested that we keep to the standard labelled semantic rules, but instead incorporate the asynchronous style of input-experiments into the deonition of simulation such that inputs of processes have to be simulated only indirectly by observing the processes' output behavior in the context of arbitrary messages <ref> [San95d, ACS96] </ref>. In this paper, we follow the latter approach.
Reference: [Smo94] <author> Gert Smolka. </author> <title> A Foundation for Higher-Order Concurrent Constraint Programming. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Constraints in Computational Logics, volume 845 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5072. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <note> Available as Research Report RR-94-16 from DFKI Kaiserslautern. </note>
Reference-contexts: San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus <ref> [Smo94, VP96] </ref>. The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Tho93] <author> Bent Thomsen. </author> <title> Plain CHOCS. A Second Generation Calculus for Higher Order Pro cesses. </title> <journal> Acta Informatica, </journal> <volume> 30(1):159, </volume> <year> 1993. </year>
Reference-contexts: Encodings of languages into fragments of themselves have been proposed or investi gated by several authors, e.g. by the study of encodings of higher-order-communication into orst-order communication within process calculi <ref> [San93, Tho93, Ama93] </ref>, the transla tion of polyadic into monadic -calculus [Mil91], the implementation of synchronous via asynchronous message-passing within the choice-free (mini) -calculus [Bou92], several en codings within a hierarchy of -calculi with internal mobility [San95c], the encoding of the choice-free asynchronous -calculus into the join-calculus [FG96] (which may be
Reference: [Tho95] <author> Bent Thomsen. </author> <title> A Theory of Higher Order Communicating Systems. Information and Computation, </title> <address> 116(1):3857, </address> <year> 1995. </year>
Reference-contexts: Much more work has been done on the compilation of whole languages into process calculi, exploring both semantics and expressivity. Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi <ref> [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96] </ref>, data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus
Reference: [Vaa90] <author> Frits Vaandrager. </author> <title> Process algebra semantics of POOL. </title> <editor> In Jos Baeten, editor, </editor> <booktitle> Application of Process Algebra, </booktitle> <pages> pages 173236. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year> <note> Earlier version: CWI-Report CS-R8629. </note>
Reference-contexts: include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [VP96] <author> Bjrn Victor and Joachim Parrow. </author> <title> Constraints as processes. </title> <note> submitted for publication, </note> <month> March </month> <year> 1996. </year>
Reference-contexts: San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus <ref> [Smo94, VP96] </ref>. The formalization of compilers for concurrent languages has also motivated the study of encodings, e.g. for Occam [Gam91], Facile [Ama94], Urlang [Gla94], and Pict [PT96]. Further interesting examples report on translations between various notions of rewrite systems [OR94, But94], addressing both semantics and implementation issues.
Reference: [Wal90] <author> David Walker. </author> <title> Bisimulation and Divergence. </title> <journal> Information and Computation, </journal> <note> 85(2):202241, 1990. Extended abstract appeared in LICS' 88: 186192. </note>
Reference-contexts: Weak bisimulation, or observation equivalence, may therefore equate two processes exactly one of which is diverging: it simply ignores the existence of inonite o -sequences. Enhancements of bisimulation have been investigated that take divergence behavior explicitly into account, resulting in preorders among bisimilar pro cesses <ref> [Wal90] </ref>. For our purposes, the simpler property of preserving divergence will suOEce. A weak simulation S has this property if P * implies Q * for all (P; Q) 2 S. Intuitively, when required to weakly simulate an inonite o -sequence, S must progress inonitely often.
Reference: [Wal91a] <author> David Walker. </author> <title> -calculus Semantics of Object-Oriented Programming Languages. </title> <editor> In Takayasu Ito and Albert Meyer, editors, </editor> <booktitle> Theoretical Aspects of Computer Software, vol ume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 532547. </pages> <publisher> Springer, </publisher> <year> 1991. </year> <note> Available as Report ECS-LFCS-90-122, </note> <institution> University of Edinburgh. </institution>
Reference-contexts: include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Wal91b] <author> David Walker. </author> <title> Some Results on the -Calculus. </title> <editor> In A. Yonezawa and T. Ito, editors, </editor> <booktitle> Concurrency: Theory, Languages, and Architecture, volume 491 of Lecture Notes in Computer Science, </booktitle> <pages> pages 2135. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: Examples include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs <ref> [Mil89, Mil91, Wal91b, Ode95a] </ref>, from object-oriented languages into process calculi [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95], from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Wal92] <author> David Walker. </author> <title> Objects in the -calculus. </title> <institution> Research Report CS-RR-217, University of Warwick, </institution> <month> April </month> <year> 1992. </year> <note> Final version published in Information and Computation 116(2):253271, </note> <year> 1995. </year>
Reference-contexts: Thus, S is rather appealing. However, it only states correspondence between sequences of transitions and is therefore, in general, rather hard to prove, since it involves analyzing arbitrarily long transition sequences between [[ S ]] and T (see <ref> [Wal92] </ref> for a successful proof). Finally, note that a proof that source terms and their translations are the same up to some operationally deoned notion of equivalence gives full abstraction up to that equiva lence and operational correspondence for free. <p> include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Wal93] <author> David Walker. </author> <title> Process Calculus and Parallel Object-Oriented Programming Languages. </title> <booktitle> In International Summer Institute on Parallel Architectures, Languages, and Algorithms, </booktitle> <address> 53 Prague, </address> <year> 1993. </year> <note> Available as Research Report CS-RR-242, </note> <institution> Department of Computer Sci ence, University of Warwick. </institution>
Reference-contexts: include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
Reference: [Wal94] <author> David Walker. </author> <title> Algebraic Proofs of Properties of Objects. </title> <note> In Sannella [San94b]. </note>
Reference-contexts: It is an asynchronous, orst-order, monadic -calculus [HT91, Bou92]. Replication is restricted to input processes and evaluated lazily [HY93, MP95]. Furthermore, merely for notational convenience, it is equipped with a conditional form based on special boolean names, reminiscent of the v -calculus <ref> [Wal94] </ref>, but not allowing for more complex boolean expressions; the condi tional can be seen as a very restricted form of matching. <p> include translations be tween the process calculi CSP and CCS [Li83, Mil87], between the join-calculus and the -calculus [FG96], of -calculi into process calculi [Mil90, San92, Lav93, San94a, Tho95, San95a, ALT95, Ode95b, Nie96], data types and other sequential programming constructs [Mil89, Mil91, Wal91b, Ode95a], from object-oriented languages into process calculi <ref> [Vaa90, Wal91a, Wal92, Wal93, Jon93, Wal94, PT95] </ref>, from logic programming lan guages into the -calculus [Ros92, Li94], and from concurrent constraint languages into the -calculus [Smo94, VP96].
References-found: 65

