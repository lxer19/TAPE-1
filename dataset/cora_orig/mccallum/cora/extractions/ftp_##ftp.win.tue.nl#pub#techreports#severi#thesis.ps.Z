URL: ftp://ftp.win.tue.nl/pub/techreports/severi/thesis.ps.Z
Refering-URL: http://www.win.tue.nl/cs/fm/gone/papers_severi.html
Root-URL: http://www.win.tue.nl
Title: Normalisation in Lambda Calculus and its relation to Type Inference Lint, voor een commissie aangewezen
Author: PROEFSCHRIFT ter verkrijging van de graad van doctor aan de van de Rector Magnificus, prof.dr. J.H. van Paula Gabriela Severi 
Address: te Montevideo, Uruguay  
Date: juni 1996 om 16.00 uur  
Note: gezag  
Affiliation: Technische Universiteit Eindhoven, op  geboren  
Pubnum: 18  
Abstract-found: 0
Intro-found: 1
Reference: [ACCL91] <author> M. Abadi, L. Cardelli, P. L. Curien, and J.J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: The substitution is said to be explicit if it is not a meta-operation on terms but part of the formal language with a special constructor bfx := ag and a special rewrite relation fi x 11.5. CONCLUSIONS AND RELATED WORK 169 to define `the substitution behaviour' <ref> [ACCL91] </ref> [KN93] [BG96] [Tas93]. The fi x -reduction and the ffi-reduction are very similar, they both unfold one occurrence of a variable at a time. They differ in the way they perform this unfolding.
Reference: [ACN90] <author> L. Augustsson, T. Coquand, and B. Nordstrom. </author> <title> A short description of another logical framework. </title> <booktitle> In Proceedings of the First Workshop on Logical Frameworks, </booktitle> <pages> pages 39-42, </pages> <year> 1990. </year>
Reference-contexts: Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. The first version of Alf <ref> [ACN90] </ref> is based on Martin-Lof's type theory [NPS90] and the actual version [Mag94] is based on the monomorphic type theory with explicit substitution [Tas93]. 1.2.1 Pure Type Systems In this thesis we work with pure type systems.
Reference: [Acz95] <author> P. Aczel. </author> <title> Schematic consequence. </title> <type> Preprint, </type> <year> 1995. </year>
Reference-contexts: Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately. Abstract formalisations of the notion of logic can be found in [Bar74], [Mes89], [HST89], [Avr92] and <ref> [Acz95] </ref>. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important. <p> This is because we are interested in properties of the typing systems like weak and strong normalisation. We think that it could be possible to define the abstract notion of derivation and relate it with the abstract logics defined in [Avr92] and <ref> [Acz95] </ref>. In that case we should introduce an abstract notion of typing rules and of typing relation generated by these rules. Also we should probably add more structure to the notion of environment. 48 CHAPTER 4.
Reference: [Avr92] <author> A. Avron. </author> <title> Axiomatic Systems, Deduction and Implication. </title> <journal> Journal of Logic Computation, </journal> <volume> 2(1) </volume> <pages> 51-98, </pages> <year> 1992. </year>
Reference-contexts: Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately. Abstract formalisations of the notion of logic can be found in [Bar74], [Mes89], [HST89], <ref> [Avr92] </ref> and [Acz95]. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important. <p> This is because we are interested in properties of the typing systems like weak and strong normalisation. We think that it could be possible to define the abstract notion of derivation and relate it with the abstract logics defined in <ref> [Avr92] </ref> and [Acz95]. In that case we should introduce an abstract notion of typing rules and of typing relation generated by these rules. Also we should probably add more structure to the notion of environment. 48 CHAPTER 4.
Reference: [Bar74] <author> K. J. Barwise. </author> <title> Axioms for abstract model theory. </title> <journal> Annals of Mathematical Logic, </journal> <volume> 7 </volume> <pages> 221-265, </pages> <year> 1974. </year>
Reference-contexts: In [Pol94], this result is stated in an informal way. Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately. Abstract formalisations of the notion of logic can be found in <ref> [Bar74] </ref>, [Mes89], [HST89], [Avr92] and [Acz95]. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important.
Reference: [Bar85] <author> H. Barendregt. </author> <title> The Lambda Calculus. Its syntax and semantics, </title> <booktitle> volume 103 of Studies in logic and the foundations of mathematics. </booktitle> <publisher> North Holland. </publisher> <address> Ams-terdam, </address> <year> 1985. </year>
Reference-contexts: In other words, a development is a fi-rewrite sequence. For example, a development is the rewrite sequence (x:(x x)) ((x:x) y) ! fi ((x:x) y) ((x:x) y) ! fi (y y): An important classical result in the lambda calculus is that all developments are finite (finiteness of developments) <ref> [Bar85] </ref>. To prove that the developments are finite is to prove 1.2. LAMBDA CALCULI WITH TYPES 3 that the fi-reduction, the fi-reduction restricted to the marked redexes, is strongly normal-ising. <p> A common-reduct strategy can be used to check conversion in confluent abstract rewriting systems, if F is a common-reduct strategy, the terms a and b are convertible if and only if F (a; b) 6= ;. The Church-Rosser strategy presented in <ref> [Bar85] </ref> is a particular case of a common-reduct strategy for fi-reduction. The main difference between a common-reduct strategy and a Church-Rosser strategy is that the former depends on two arguments and the latter on one. <p> In earlier work, other topologies associated to a reduction relation have been considered. In all these cases the topology depends on the structure of the terms (see <ref> [Bar85] </ref>, [KKSdV91] and [KKS95]). 36 CHAPTER 3. TOPOLOGY Chapter 4 Abstract Typing Systems 4.1 Introduction In computer science the notions of computation and typing are basic, and play an essential role in the theory and its applications. <p> Instead of looking at the leftmost redex, the new strategies look at the spine redexes. As a consequence, these strategies are non-deterministic. The original proofs of the facts that F bk and F 1 are perpetual proceed by a case analysis <ref> [Bar85] </ref>. In order to prove that a strategy F is perpetual it is proved that F (M ) admits an infinite rewrite sequence if M does so. In order to prove that the strategies G bk and G 1 are perpetual, we use the set SN . <p> In section 7.6 we prove that all superdevelopments are finite. In section 7.7 another proof of finiteness of superdevelopments that makes direct use of the set SN and similar to the one in 7.4. 7.2 Developments We shortly recall some definitions, for a complete formal treatment see <ref> [Bar85] </ref>. A development is a rewrite sequence in which only descendants of redexes that are present in the initial term may be contracted. Usually, fi-developments are defined via a set of underlined -terms and an underlined fi-reduction rule. 65 66 CHAPTER 7. DEVELOPMENTS AND SUPERDEVELOPMENTS Definition 7.2.1. <p> Church and Rosser proved finiteness of developments for the I-calculus with fi-reduction in [CR36]. The first proof for the full -calculus is given by Schroer in [Sch65]. Other proofs have been given in [Hyl73] and <ref> [Bar85] </ref>. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5). There is a short and elegant proof by de Vrijer [Vri85], in which an exact bound for the length of a development is computed. <p> The class of bijective pure type systems does not include any of the systems of the family of AUTOMATH as described on page 216 and 217 in <ref> [Bar85] </ref>. Decidability of type checking for normalising pure type systems whose set of sorts is finite is proved in [BJ93]. In that paper, a type inference algorithm is defined that computes the normal form in all the rules. A discussion on the side-conditions can be found in [Pol96]. <p> Concerning the problem with ff-conversion, we define substitution for the set of pseu-doterms as in [CF58]. Using this definition of substitution the variable convention in <ref> [Bar85] </ref> is not necessary. The typing rules for pure type systems do not allow to type terms unless their nested variables are all different. In the start and the weakening rules a variable is added to the context only if it is -fresh.
Reference: [Bar92] <author> H. Barendregt. </author> <title> Lambda Calculi with Types. </title> <editor> In D. M. Gabbai, S. Abram-sky, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1, </volume> <pages> pages 117-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Berardi [Ber88] (see also [Ber90]) and J. Terlouw [Ter89]. Many systems can be described in this way, for instance the simply and the polymorphic typed lambda calculus, the systems of the AUTOMATH family [NGdV94], the Calculus of Constructions (and all the systems of the -cube <ref> [Bar92] </ref>) and the inconsistent system fl [Gir72]. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. <p> For example, type inference for the simply typed lambda calculus is decidable [Cur69] [Mil78] but for ! (or F !) is undecidable [Urz93b]. An incomplete overview of the decidability of type inference in the systems a la Curry can be found in a table on page 183 in <ref> [Bar92] </ref>. This table can be filled in completely by now: type checking and inference in 2 (or F ) have been proved undecidable in [Wel94] and the inhabitation of " has been proved undecidable in [Urz93a]. <p> M !! fi nf fi (M ). 2. If M ! fi N then nf fi (M) = nf fi (N). So we have that nf fi (M ) is the fi-normal form of M and is unique. The functions e and nf fi are used in <ref> [Bar92] </ref> to prove confluence for fi-reduction. In the following sections, we prove that fi is strongly normalising. 7.3 First Proof of Finiteness of Developments We give a new and short proof of finiteness of developments by considering another inductive definition D of the set of all underlined -terms. <p> They were introduced independently by S. Berardi [Ber88] (see also [Ber90]) and J. Terlouw [Ter89]. Important pure type systems are the systems of the -cube <ref> [Bar92] </ref>. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. This chapter is organised as follows. In section 9.2 we recall the notion of specification and of morphism between specifications. <p> We denote the category whose objects are the specifications and morphisms the ones defined above by Spec. Several examples of morphisms between specifications are given in [Geu93] and <ref> [Bar92] </ref>. Example 9.2.4. An important example of morphism between specifications is the fol lowing one used for the propositions-as-types interpretation. <p> Pseudoterms will be denoted as a; b; c; d; : : : ; A; B; C; : : :. The usual parenthesis conventions for abstraction, application and product will be used (see <ref> [Bar92] </ref>). Definition 9.3.2. The mapping F V : T ! P (V ) is defined as follows. <p> For example, (P RED) and (P ) are pure type systems and (p) is a morphism from (P RED) to (P ). The -cube consists of eight systems <ref> [Bar92] </ref> defined by the same set of sorts and the same set of axioms. They differ in the set of rules R. Definition 9.3.16. Let S 0 = ffl; 2g and A 0 = f (fl; 2)g. <p> For example, an inconsistent pure type system is fl determined by the specification (S; A; R) where S = fflg, A = f (fl; fl)g and R = f (fl; fl)g (see [Gir72] and <ref> [Bar92] </ref>). Properties of Pure Type Systems The advantage of pure type systems is that we can do the metatheory of several type systems at the same time. There are several properties that can be proved for all these systems. 9.3. <p> Let S be a singly sorted specification. Then (S) verifies uniqueness of types. 7. Let S be a logical specification. If (S) is inconsistent then (S) is not normalising. The proofs of these properties can be found in [GN91] and <ref> [Bar92] </ref> except for strength ening that is proved in [BJ93]. Theorem 9.3. (Strong Normalisation) 1. The system C 1 is fi-strongly normalising. 2. The systems of the -cube are fi-strongly normalising. 3. The system (HOL) is fi-strongly normalising. <p> Worse still, proving strong normalisation for particular pure type systems extended with definitions is already a problem. The strong normalisation proofs for particular type systems given in [Coq85], [Luo89], [GN91], <ref> [Bar92] </ref> cannot be extended in any obvious way. In this chapter, we show how strong normalisation of a pure type system extended with definitions follows from strong normalisation of another (larger) pure type system. <p> On the other hand, we do not know any strongly normalising pure type system S for which theorem 11.4.37 cannot be used to prove strong normalisation of ffi (S). In particular, all strongly normalising pure type systems given in <ref> [Bar92] </ref> have a completion that is (C 1 ). 11.5 Conclusions and Related Work In this chapter we have considered definitions as part of the formal language. In our opinion, this extension has been done in a neat and general way (for pure type systems).
Reference: [BBKV76] <author> H. Barendregt, J. Bergstra, J. W. Klop, and H. Volken. </author> <title> Degrees, reductions and representability in the lambda calculus. </title> <type> Technical Report 22, </type> <institution> University of Utrecht, </institution> <year> 1976. </year>
Reference-contexts: In chapter 5, we give new characterisations of the set of weakly and strongly normal-ising -terms. In chapter 6, we define two perpetual strategies G bk and G 1 similar to F bk [BK82] and F 1 <ref> [BBKV76] </ref>. In order to prove that a strategy F is perpetual, we prove that if F (M ) is strongly normalising then so is M and we use one of the characterisations of the set of strongly normalising -terms given before. <p> Our definition of SN first appeared in [RS95] and more or less simultaneously a similar definition appeared in [Loa95]. Chapter 6 Perpetual Strategies 6.1 Introduction In this chapter we define two strategies G bk and G 1 similar to F bk [BK82] and F 1 <ref> [BBKV76] </ref>. These strategies are perpetual, which means that they yield an infinite rewrite sequence whenever possible. We prove that G bk and G 1 are perpetual by using the char-acterisation of the set of strongly normalising terms. As a consequence, we deduce that F bk and F 1 are perpetual. <p> Then F bk (M ) 2 G bk (M). Theorem 6.2.5. F bk is a perpetual strategy. This follows from lemma 6.2.4 and theorem 6.2.3. 6.3 The Strategies F 1 and G 1 We now consider the strategy F 1 that is defined in <ref> [BBKV76] </ref>. This strategy does not check whether the argument of the leftmost redex is strongly normalising or not. Instead, it is checked whether the leftmost redex is an I-redex. If it is, it is contracted. <p> PERPETUAL STRATEGIES 6.5 Conclusions and Related Work In this chapter the strategies G bk and G 1 are defined which are similar to F bk [BK82] and F 1 <ref> [BBKV76] </ref>. Instead of looking at the leftmost redex, the new strategies look at the spine redexes. As a consequence, these strategies are non-deterministic. The original proofs of the facts that F bk and F 1 are perpetual proceed by a case analysis [Bar85].
Reference: [Ber88] <author> S. Berardi. </author> <title> Towards a mathematical analysis of the Coquand-Huet calculus of constructions and Other Systems in Barendregt's Cube. </title> <type> Technical report, </type> <institution> Carnegie Mellon University and Universita di Torino, </institution> <year> 1988. </year>
Reference-contexts: They provide a framework to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. Berardi <ref> [Ber88] </ref> (see also [Ber90]) and J. Terlouw [Ter89]. <p> SIMPLY TYPED LAMBDA CALCULUS Part III Pure Type Systems with Definitions 85 Chapter 9 Pure Type Systems 9.1 Introduction Pure type systems provide a way to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. Berardi <ref> [Ber88] </ref> (see also [Ber90]) and J. Terlouw [Ter89]. Important pure type systems are the systems of the -cube [Bar92]. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. This chapter is organised as follows. <p> The problem of inhabitation in ! and in ! are decidable but in the rest of the systems of the cube is undecidable [Spr95]. For the inconsistent systems, inhabitation is trivial. 9.4 Conclusions and Related Work As we said before, pure type systems were introduced independently by S. Berardi <ref> [Ber88] </ref> and J. Terlouw [Ter89]. In the typing rules for pure type systems, the axiom depends on the set A and the product rule depends on the set R. In other words, we have a family of axioms and product rules depending on A and R.
Reference: [Ber90] <author> S. Berardi. </author> <title> Type Dependency and Constructive Mathematics. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University and Universita di Torino, </institution> <year> 1990. </year>
Reference-contexts: They provide a framework to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. Berardi [Ber88] (see also <ref> [Ber90] </ref>) and J. Terlouw [Ter89]. Many systems can be described in this way, for instance the simply and the polymorphic typed lambda calculus, the systems of the AUTOMATH family [NGdV94], the Calculus of Constructions (and all the systems of the -cube [Bar92]) and the inconsistent system fl [Gir72]. <p> They were introduced independently by S. Berardi [Ber88] (see also <ref> [Ber90] </ref>) and J. Terlouw [Ter89]. Important pure type systems are the systems of the -cube [Bar92]. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. This chapter is organised as follows.
Reference: [BG96] <author> R. Bloo and H. </author> <title> Geuvers. Explicit substitution: On the edge of strong nor-malisation. </title> <type> Technical Report CS-9610, </type> <institution> Eindhoven University of Technology, </institution> <year> 1996. </year> <note> 192 BIBLIOGRAPHY </note>
Reference-contexts: The substitution is said to be explicit if it is not a meta-operation on terms but part of the formal language with a special constructor bfx := ag and a special rewrite relation fi x 11.5. CONCLUSIONS AND RELATED WORK 169 to define `the substitution behaviour' [ACCL91] [KN93] <ref> [BG96] </ref> [Tas93]. The fi x -reduction and the ffi-reduction are very similar, they both unfold one occurrence of a variable at a time. They differ in the way they perform this unfolding.
Reference: [BJ93] <author> B. van Benthem Jutting. </author> <title> Typing in pure type systems. </title> <journal> Information and Computation, </journal> <volume> 105 </volume> <pages> 30-41, </pages> <year> 1993. </year>
Reference-contexts: For systems a la Church, in all known cases the problems of type checking and type inference are equivalent. Moreover decidability of type inference is very closely related to normalisation. Decidability of type inference for normalising pure type systems whose set of sorts is finite is proved in <ref> [BJ93] </ref> and decidability for normalising pure type systems whose specification is recursive and singly sorted (also semi-full) is proved in [Pol96]. Undecidability of type inference for inconsistent impredicative pure type systems is proved in [CH94] generalising the result in [MR86]. <p> Let S be a singly sorted specification. Then (S) verifies uniqueness of types. 7. Let S be a logical specification. If (S) is inconsistent then (S) is not normalising. The proofs of these properties can be found in [GN91] and [Bar92] except for strength ening that is proved in <ref> [BJ93] </ref>. Theorem 9.3. (Strong Normalisation) 1. The system C 1 is fi-strongly normalising. 2. The systems of the -cube are fi-strongly normalising. 3. The system (HOL) is fi-strongly normalising. <p> Suppose that S is singly sorted or semi-full and that the sets S, A and R are recursive. Then type inference and type checking in (S) are decidable. The proof of the first part can be found in <ref> [BJ93] </ref> and the second one in [BJMP93] and [Pol96]. 96 CHAPTER 9. PURE TYPE SYSTEMS Theorem 9.3.20. (Undecidability of Type Inference and Type Checking) Let S = (S; A; R) be a singly sorted, non-dependent and impredicative specification. <p> The class of bijective pure type systems does not include any of the systems of the family of AUTOMATH as described on page 216 and 217 in [Bar85]. Decidability of type checking for normalising pure type systems whose set of sorts is finite is proved in <ref> [BJ93] </ref>. In that paper, a type inference algorithm is defined that computes the normal form in all the rules. A discussion on the side-conditions can be found in [Pol96]. <p> We need to prove it for the case of variables which are not definitions. In order to prove strengthening, we use the corresponding result for pure type systems (see <ref> [BJ93] </ref>). Lemma 11.4.18. Let 0 be a context. If 0 !! fiffi and ` ffi a : A then 0 ` ffi a : A. Proof: By induction on the number of steps in the derivation of ` ffi a : A. <p> S, A and R recursive decidable decidable (S) is fi-normalising S is singly sorted, impredicative and non-dependent ffi (S) is inconsistent undecidable undecidable Table 12.2: Decidability of type inference and type checking In our opinion, the algorithm for normalising pure type systems whose set of sorts is finite defined in <ref> [BJ93] </ref> and the syntax directed sets of rules defined in [BJMP93] and in [Pol93a] can be adapted to include definitions by using the function j j to prove the equivalence between the syntax directed set of rules and the original system. 184 CHAPTER 12.
Reference: [BJMP93] <author> B. van Benthem Jutting, J. McKinna, and R. Pollack. </author> <title> Checking algorithms for pure type systems. </title> <editor> In H. Barendregt and T. Nipkov, editors, </editor> <booktitle> Types for Proofs and Programs, </booktitle> <volume> volume 806, </volume> <year> 1993. </year>
Reference-contexts: Suppose that S is singly sorted or semi-full and that the sets S, A and R are recursive. Then type inference and type checking in (S) are decidable. The proof of the first part can be found in [BJ93] and the second one in <ref> [BJMP93] </ref> and [Pol96]. 96 CHAPTER 9. PURE TYPE SYSTEMS Theorem 9.3.20. (Undecidability of Type Inference and Type Checking) Let S = (S; A; R) be a singly sorted, non-dependent and impredicative specification. If (S) is inconsistent then type inference and type checking in (S) are undecidable. <p> The system obtained by eliminating the non-structural rules should be equivalent to the original one. The proof of the equivalence (soundness and completeness) between the original rules and the corresponding syntax directed ones is problematic for some pure type systems (see <ref> [BJMP93] </ref> and also [Pol93a]). Here we present a syntax directed set of rules for singly sorted pure type systems similar to the one presented in [BJMP93]. As in [BJMP93], we use an auxiliary system to check for the -condition, i.e. the premise that the product (x:A: B) should be well-typed in <p> proof of the equivalence (soundness and completeness) between the original rules and the corresponding syntax directed ones is problematic for some pure type systems (see <ref> [BJMP93] </ref> and also [Pol93a]). Here we present a syntax directed set of rules for singly sorted pure type systems similar to the one presented in [BJMP93]. As in [BJMP93], we use an auxiliary system to check for the -condition, i.e. the premise that the product (x:A: B) should be well-typed in the abstraction rule. <p> equivalence (soundness and completeness) between the original rules and the corresponding syntax directed ones is problematic for some pure type systems (see <ref> [BJMP93] </ref> and also [Pol93a]). Here we present a syntax directed set of rules for singly sorted pure type systems similar to the one presented in [BJMP93]. As in [BJMP93], we use an auxiliary system to check for the -condition, i.e. the premise that the product (x:A: B) should be well-typed in the abstraction rule. The auxiliary system we use to define the syntax directed set of rules is the corresponding pure type system without the -condition. <p> The -condition of sd (S) is not checked in the same system sd (S) but in ! sd (S). The idea is to use an auxiliary system to check for the -condition <ref> [BJMP93] </ref> so that we can prove the `equivalence' between sd (S) and (S). In our case, the auxiliary system is the corresponding pure type system without the -condition. Definition 10.7.6. <p> as follows. check (; a; A) = 8 &gt; &gt; &gt; : true if whnf (type (; A)) = s 2 S, type (; a) 6= ? and F ++ (type (; a); A) 6= ; f alse otherwise We have the following conclusion which has been proved before in <ref> [BJMP93] </ref> and [Pol96] (see theorem 9.3.19). Theorem 10.8.16. (Decidability of Type Inference and Type Checking) Let S = (S; A; R) be singly sorted such that the sets S, A and R are recursive. If (S) is fi-weakly normalising then type inference and type checking in (S) are decidable. <p> Several syntax directed sets of rules for pure type systems are studied in <ref> [BJMP93] </ref>. Our definition of a syntax directed set of rules follows the idea in [BJMP93] of using an auxiliary system to check for the -condition. In that paper, the auxiliary system is much weaker than (S). <p> Several syntax directed sets of rules for pure type systems are studied in <ref> [BJMP93] </ref>. Our definition of a syntax directed set of rules follows the idea in [BJMP93] of using an auxiliary system to check for the -condition. In that paper, the auxiliary system is much weaker than (S). In our case, the auxiliary system is ! (S), which is very close to (S). Moreover, ! (S) preserves some properties of (S) like normalisation. <p> S is singly sorted, impredicative and non-dependent ffi (S) is inconsistent undecidable undecidable Table 12.2: Decidability of type inference and type checking In our opinion, the algorithm for normalising pure type systems whose set of sorts is finite defined in [BJ93] and the syntax directed sets of rules defined in <ref> [BJMP93] </ref> and in [Pol93a] can be adapted to include definitions by using the function j j to prove the equivalence between the syntax directed set of rules and the original system. 184 CHAPTER 12.
Reference: [BK82] <author> J. A. Bergstra and J. W. Klop. </author> <title> Strong normalization and perpetual reductions in the lambda calculus. </title> <journal> Journal of Information Processing and Cybernetics, </journal> <volume> 18 </volume> <pages> 403-417, </pages> <year> 1982. </year>
Reference-contexts: In chapter 5, we give new characterisations of the set of weakly and strongly normal-ising -terms. In chapter 6, we define two perpetual strategies G bk and G 1 similar to F bk <ref> [BK82] </ref> and F 1 [BBKV76]. In order to prove that a strategy F is perpetual, we prove that if F (M ) is strongly normalising then so is M and we use one of the characterisations of the set of strongly normalising -terms given before. <p> Our definition of SN first appeared in [RS95] and more or less simultaneously a similar definition appeared in [Loa95]. Chapter 6 Perpetual Strategies 6.1 Introduction In this chapter we define two strategies G bk and G 1 similar to F bk <ref> [BK82] </ref> and F 1 [BBKV76]. These strategies are perpetual, which means that they yield an infinite rewrite sequence whenever possible. We prove that G bk and G 1 are perpetual by using the char-acterisation of the set of strongly normalising terms. <p> This is done by computing the length of the rewrite sequence to the normal form. 6.2 The Strategies F bk and G bk First we consider the strategy F bk as introduced in <ref> [BK82] </ref>. Definition 6.2.1. Suppose that M 2 fl is not in normal form. Let M = C [(x:P )Q] where (x:P )Q is the leftmost redex of M . <p> In particular, a maximal strategy is perpetual. The converse is not necessarily true, as witnessed by the strategy F bk defined in <ref> [BK82] </ref>. Example 6.4.1. The F bk -rewrite sequence starting at (x:z)(II) has length 1. (x:z)(II) ! fi z However the length of the maximal rewrite sequence is 2. (x:z)(II) ! fi (x:z)I 60 CHAPTER 6. <p> PERPETUAL STRATEGIES 6.5 Conclusions and Related Work In this chapter the strategies G bk and G 1 are defined which are similar to F bk <ref> [BK82] </ref> and F 1 [BBKV76]. Instead of looking at the leftmost redex, the new strategies look at the spine redexes. As a consequence, these strategies are non-deterministic. The original proofs of the facts that F bk and F 1 are perpetual proceed by a case analysis [Bar85].
Reference: [BKKS87] <author> H. P. Barendregt, J. R. Kennaway, J. W. Klop, and M. R. Sleep. </author> <title> Needed reduction and spine strategies for the lambda calculus. </title> <journal> Information and Computation, </journal> <volume> 75 </volume> <pages> 191-231, </pages> <year> 1987. </year>
Reference-contexts: STRONGLY NORMALISING -TERMS The redex in C [(x:M )N ] is called a spine redex if C [ ] 2 O <ref> [BKKS87] </ref>. Definition 5.3.3. <p> Supposing the terms were convertible and one of them normalising then the other term should also be normalising. Here we could apply a normalising strategy to the second term. We first write a function nf that finds the normal form (if it exists) by reducing the spine redexes (see <ref> [BKKS87] </ref>). Definition 10.8.7.
Reference: [Blo97] <author> R. Bloo. </author> <title> In preparation. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1997. </year>
Reference-contexts: Definitions achieve this purpose very well besides having all the good properties. On the other hand, it is not clear how to define a type system for explicit substitutions <ref> [Blo97] </ref> that verifies all the good properties like subject reduction.
Reference: [Bru70] <author> N. G. de Bruijn. </author> <title> The mathematical language of AUTOMATH, its usage and some of its extensions. </title> <booktitle> In Symposium on automatic demonstration, volume 125 of LNCS, </booktitle> <pages> pages 27-61. </pages> <publisher> Springer, </publisher> <year> 1970. </year>
Reference-contexts: Hence the type of a program 1.2. LAMBDA CALCULI WITH TYPES 5 gives a partial specification of the program. Terms are viewed as programs and types as specifications for the programs. Another approach to the notion of type is the so-called propositions-as-types interpretation <ref> [Bru70] </ref> [How80]. A type is viewed as a proposition and a term as its proof. The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. <p> PURE TYPE SYSTEMS The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus [Chu40], 2 is the second order typed lambda calculus [Gir72] and [Rey74], P is AUT-QE and LF <ref> [Bru70] </ref> and [RHP87]. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1.
Reference: [Bru72] <author> N. G. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation. </title> <journal> Indag. Math., </journal> <pages> pages 381-392, </pages> <year> 1972. </year>
Reference-contexts: This term reduces to (x : A: x : B: x) which is not typable. Subject reduction holds if we identify (x:A: x:B: x) with (z:A: x:B: x) A solution to the implementation of ff-conversion appeared in <ref> [Bru72] </ref>. Here, reference numbers to the positions of the abstractions are used instead of name variables. Another solution can be found in [Coq96]. In this case, a semantical argument is used to prove the correctness of the type checking algorithm.
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic. </title> <publisher> North Holland. </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: BV (x) = ; BV (M N ) = BV (M ) [ BV (N ) A variable x is said to occur bound in M if x 2 BV (M ). We define substitution as in <ref> [CF58] </ref>. Definition 5.2.4. <p> In theorem 10.8.16, we have given a new proof of the same result for the singly sorted but not for the semi-full pure type systems. Concerning the problem with ff-conversion, we define substitution for the set of pseu-doterms as in <ref> [CF58] </ref>. Using this definition of substitution the variable convention in [Bar85] is not necessary. The typing rules for pure type systems do not allow to type terms unless their nested variables are all different.
Reference: [CH88] <author> T. Coquand and G. Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions <ref> [CH88] </ref> extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems.
Reference: [CH94] <author> T. Coquand and H. Herbelin. </author> <title> A-translation and looping combinators in pure type systems. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 77-88, </pages> <year> 1994. </year>
Reference-contexts: Undecidability of type inference for inconsistent impredicative pure type systems is proved in <ref> [CH94] </ref> generalising the result in [MR86]. The problem of inhabitation in systems a la Church presents the same complications as for systems a la Curry. For the inconsistent systems, inhabitation is trivial since all the types have at least one inhabitant. <p> PURE TYPE SYSTEMS Theorem 9.3.20. (Undecidability of Type Inference and Type Checking) Let S = (S; A; R) be a singly sorted, non-dependent and impredicative specification. If (S) is inconsistent then type inference and type checking in (S) are undecidable. This is proved in <ref> [CH94] </ref> as a generalisation of the result of [MR86]. The problem of inhabitation in ! and in ! are decidable but in the rest of the systems of the cube is undecidable [Spr95].
Reference: [Chu40] <author> A. Church. </author> <title> A formulation of the simply theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: of finiteness of developments and superdevelop-ments (a generalisation of developments) and of the fact that some strategies are perpetual. 1.2 Lambda Calculi with Types Types were introduced for the first time in the combinatory logic (a variant of the lambda calculus) in [Cur34] and in the lambda calculus itself in <ref> [Chu40] </ref>. Nowadays types are used for many purposes as will be explained later. In order to give a first insight of the notion of type, we give one simple motivation related to set theory. <p> System R ! (fl; fl) P (fl; fl) (fl; 2) ! (fl; fl) (2; 2) P ! (fl; fl) (fl; 2) (2; 2) 94 CHAPTER 9. PURE TYPE SYSTEMS The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus <ref> [Chu40] </ref>, 2 is the second order typed lambda calculus [Gir72] and [Rey74], P is AUT-QE and LF [Bru70] and [RHP87]. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions.
Reference: [Chu41] <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press. Princeton., </publisher> <year> 1941. </year>
Reference-contexts: Finally, we summarise the contents of this thesis. 1.1 Lambda Calculus The lambda calculus is a formal system based on a function notation invented by A. Church <ref> [Chu41] </ref>. It captures the most basic aspects of the manners in which operators are combined to form other operators. We give some motivations for the syntax of the -calculus.
Reference: [Con86] <author> R. L. Constable et al. </author> <title> Implementing mathematics with the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl <ref> [Con86] </ref> and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems.
Reference: [Coq85] <author> T. Coquand. </author> <title> Une Theorie des constructions. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1985. </year>
Reference-contexts: Worse still, proving strong normalisation for particular pure type systems extended with definitions is already a problem. The strong normalisation proofs for particular type systems given in <ref> [Coq85] </ref>, [Luo89], [GN91], [Bar92] cannot be extended in any obvious way. In this chapter, we show how strong normalisation of a pure type system extended with definitions follows from strong normalisation of another (larger) pure type system.
Reference: [Coq91] <author> T. Coquand. </author> <title> An algorithm for testing conversion in type theory. In Logical Frameworks, 1991. BIBLIOGRAPHY 193 </title>
Reference-contexts: The normalising strategies are important for checking conversion but they ensure termination only on the set of weakly normalising elements. The way in which conversion is checked in <ref> [Coq91] </ref> supposes implicitly the existence of a common-reduct strategy. In [Coq91], an algorithm for checking conversion is defined. For that purpose a computable binary relation is defined which is equivalent to the fij-reduction. This relation depending on two arguments can be considered as a common-reduct strategy. <p> The normalising strategies are important for checking conversion but they ensure termination only on the set of weakly normalising elements. The way in which conversion is checked in <ref> [Coq91] </ref> supposes implicitly the existence of a common-reduct strategy. In [Coq91], an algorithm for checking conversion is defined. For that purpose a computable binary relation is defined which is equivalent to the fij-reduction. This relation depending on two arguments can be considered as a common-reduct strategy. <p> Checking fi-conversion. In the application rule we have to check if two types are fi-convertible. It would be sufficient to find a computable common-reduct strategy F : T fi T ! P (T ) and then check if F (a; b) 6= ;. The strategy presented in <ref> [Coq91] </ref> (see also [Mag94]) reduces as less as possible by performing weak head reduction. The idea is to compute the weak head normal forms of 10.8. TYPE INFERENCE 123 the terms and compare their heads.
Reference: [Coq96] <author> T. Coquand. </author> <title> An Algorithm for Type-Checking Dependent Types. </title> <editor> In B. Bjerner, M. Larsson, and B. Nordstrom, editors, </editor> <booktitle> Proceedings of the 7th Nordic Workshop on Programming Theory. </booktitle> <institution> Goteborg University and Chalmers University of Technology, </institution> <year> 1996. </year>
Reference-contexts: Subject reduction holds if we identify (x:A: x:B: x) with (z:A: x:B: x) A solution to the implementation of ff-conversion appeared in [Bru72]. Here, reference numbers to the positions of the abstractions are used instead of name variables. Another solution can be found in <ref> [Coq96] </ref>. In this case, a semantical argument is used to prove the correctness of the type checking algorithm. For pure type systems, the problem of unification does not arise when inferring the type.
Reference: [CP90] <author> T. Coquand and C. Paulin. </author> <title> Inductively Defined Types. </title> <editor> In P. Martin-Lof and G. Mints, editors, </editor> <booktitle> COLOG-88, volume 417 of LNCS, </booktitle> <pages> pages 50-66. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions <ref> [CP90] </ref>. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems.
Reference: [CR36] <author> A. Church and J. B. Rosser. </author> <title> Some properties of conversion. </title> <journal> Transactions of the Americal Society, </journal> <volume> 39 </volume> <pages> 472-482, </pages> <year> 1936. </year>
Reference-contexts: DEVELOPMENTS AND SUPERDEVELOPMENTS 7.8 Conclusions and Related Work The result that all fi-developments are finite is a classical result in -calculus and various proofs already exist. Church and Rosser proved finiteness of developments for the I-calculus with fi-reduction in <ref> [CR36] </ref>. The first proof for the full -calculus is given by Schroer in [Sch65]. Other proofs have been given in [Hyl73] and [Bar85]. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5).
Reference: [Cur34] <author> H. B. Curry. </author> <title> Functionality in combinatory logic. </title> <booktitle> Proc. </booktitle> <institution> nat. Acad. Science USA, </institution> <month> 20 </month> <pages> 584-590, </pages> <year> 1934. </year>
Reference-contexts: In this thesis, we present new proofs of finiteness of developments and superdevelop-ments (a generalisation of developments) and of the fact that some strategies are perpetual. 1.2 Lambda Calculi with Types Types were introduced for the first time in the combinatory logic (a variant of the lambda calculus) in <ref> [Cur34] </ref> and in the lambda calculus itself in [Chu40]. Nowadays types are used for many purposes as will be explained later. In order to give a first insight of the notion of type, we give one simple motivation related to set theory.
Reference: [Cur69] <author> H. B. Curry. </author> <title> Modified based functionality in combinatory logic. </title> <journal> Dialectica, </journal> <volume> 23 </volume> <pages> 83-92, </pages> <year> 1969. </year>
Reference-contexts: Type inference for systems a la Curry is not always decidable, not even for normalis-ing ones. For example, type inference for the simply typed lambda calculus is decidable <ref> [Cur69] </ref> [Mil78] but for ! (or F !) is undecidable [Urz93b]. An incomplete overview of the decidability of type inference in the systems a la Curry can be found in a table on page 183 in [Bar92].
Reference: [Daa80] <author> D. T. van Daalen. </author> <title> The Language Theory of Automath. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1980. </year>
Reference-contexts: Definitions are usually considered in a meta-level and not as part of the language of the lambda calculus. In the systems of the AUTOMATH family [NGdV94] definitions are considered as part of the formal language. The meta-theory of these systems is treated in detail in <ref> [Daa80] </ref>. Howewer, some of the proofs apply only to the particular type system that they consider and do not extend to other type systems. We consider it important to include definitions in the syntax of the lambda calculus and to study the properties that are preserved by the extension. <p> In the systems of the AUTOMATH family [NGdV94] definitions are considered as part of the formal language. The meta-theory of these systems -including strong normalisation is treated in detail in <ref> [Daa80] </ref>. However, the proofs of strong normalisation apply only to the particular type system that they consider and do not extend to other type systems. This chapter is organised as follows. <p> PURE TYPE SYSTEMS WITH DEFINITIONS Definitions vs local fi-reduction. In the systems of the AUTOMATH family, definitions are written as fi-redexes [Ned73] <ref> [Daa80] </ref>. A reduction called local fi-reduction to unfold one occurrence of a variable at a time is introduced in [Ned92]. In some later versions of AUTOMATH, definitions are connected with local fi-reduction.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 207-212. </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: This table can be filled in completely by now: type checking and inference in 2 (or F ) have been proved undecidable in [Wel94] and the inhabitation of " has been proved undecidable in [Urz93a]. Type inference for ML <ref> [DM82] </ref> is decidable because polymorphism can be used only in a weaker form (the universal quantifiers can occur only in the outermost position of a type). For systems a la Church, in all known cases the problems of type checking and type inference are equivalent.
Reference: [Dow91] <author> G. Dowek et al. </author> <title> The Coq proof assistant version 5.6, users guide. </title> <institution> Rapport de Recherche 134, INRIA, </institution> <year> 1991. </year>
Reference-contexts: A type is viewed as a proposition and a term as its proof. The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. Modern systems that also provide computer-assistance for the construction of proofs are Coq <ref> [Dow91] </ref>, Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. <p> A definition mechanism is essential for practical use, and indeed implementations of pure type systems such as Coq <ref> [Dow91] </ref>, Lego [LP92] or Constructor [HA91] do provide such a facility, even though the formal definition of the systems they implement do not. In this chapter, we extend the pure type system to include (non-recursive) definitions. <p> Global and Local Definitions. Our extension provides global and local definitions, i.e. definitions in the context and in the term. Coq <ref> [Dow91] </ref> provides only global definitions. In our opinion, it is important to have local definitions as well as global ones for practical use.
Reference: [FS93] <author> W. Ferrer and P. Severi. </author> <title> Abstract reduction and topology. </title> <type> Technical Report CS-9335, </type> <institution> Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: For the use of these abstract notions in the context of higher order rewriting systems, we refer to [Raa96]. Chapter 3 is based on a paper with Walter Ferrer <ref> [FS93] </ref>. Lambda Calculus In this part, we give some new characterisations of the set of weakly and strongly normal-ising -terms focusing on expansion rather than reduction. These characterisations of the set of strongly normalising -terms permit us to give new and simple proofs of classical results about -calculus.
Reference: [Gal90] <author> J. H. Gallier. </author> <title> On Girard's `candidats de reductibilite'. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, volume 31 of APIC, </booktitle> <pages> pages 123-203. </pages> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1990. </year>
Reference-contexts: Girard [Gir72] introduced the concept of candidate of reducibility to generalise Tait's method to include polymorphism 8.4. CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see <ref> [Gal90] </ref>. The conditions in the definition of candidate of reducibility in [Gir72] were modified in [Tai75] and [Mit86] and a new definition was introduced: a saturated set. The definitions of the set SN and of saturated sets are very similar (see chapter 5).
Reference: [Gan80] <author> R.O. </author> <title> Gandy. An Early Proof of Normalisation by A. </title> <editor> M. Turing. In J. R. Hindley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 453-455. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: The type of the newly created redexes may be more complex and thus it is not possible to apply the induction hypothesis. This seems related to the proof of normalisation for the simply typed lambda calculus by Turing <ref> [Gan80] </ref>. In our opinion, this method, being too simple, will not be easily extensible. It is possible to express the proof of strong normalisation of the simply typed lambda calculus in Peano Arithmetic (PA).
Reference: [Geu93] <author> H. </author> <title> Geuvers. Logics and Type Systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: We denote the category whose objects are the specifications and morphisms the ones defined above by Spec. Several examples of morphisms between specifications are given in <ref> [Geu93] </ref> and [Bar92]. Example 9.2.4. An important example of morphism between specifications is the fol lowing one used for the propositions-as-types interpretation. <p> The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1. The system of higher order logic can be described by the following specification (see <ref> [Geu93] </ref>). S ffl; 2; 4g R f (fl; fl); (2; fl); (2; 2)g There is only one topsort in (HOL) and that is 4. Definition 9.2. The Calculus of Constructions extended with an infinite type hierarchy can be described by the following specification.
Reference: [Ghi94] <author> S. Ghilezan. </author> <title> Applications of typed lambda calculi in the untyped lambda calculus. </title> <editor> In A. Nerode and Yu. V. Matiyasevich, editors, </editor> <booktitle> Logical Foundations of Computer Science: Proceedings of the Third International Symposium, </booktitle> <volume> volume 813, </volume> <pages> pages 129-139. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> 194 BIBLIOGRAPHY </note>
Reference-contexts: A similar proof using strong normalisation of simply typed lambda calculus appears in <ref> [Ghi94] </ref>. In [Mel96] an axiomatic and general proof of finiteness of developments is given. In [Raa93] the proof that the superdevelopments are finite uses the method of mini-malisation. Superdevelopments are related to the so-called `generalised fi-reduction'.
Reference: [Gir72] <author> J. Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: For example, (flff:x:ff: x) is the polymorphic identity. The extension of the simply typed lambda calculus with polymorphism is called polymorphic typed lambda calculs (F or 2 or second order typed lambda calculus) and it was introduced independently by <ref> [Gir72] </ref> and [Rey74]. Implementations of Lambda calculi The -calculus is the foundation of functional programming languages. The -calculus itself could be considered as an abstract programming language. It contains the concept of computation in full generality and strength but in a pure form with a very simple syntax. <p> Terlouw [Ter89]. Many systems can be described in this way, for instance the simply and the polymorphic typed lambda calculus, the systems of the AUTOMATH family [NGdV94], the Calculus of Constructions (and all the systems of the -cube [Bar92]) and the inconsistent system fl <ref> [Gir72] </ref>. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. If A is a type and B (x) is a family of types indexed over A then x:A: B (x) is also a type. <p> In this case, to ensure termination we have to prove that any strategy is normalising, i.e. strong normalisation. Examples of pure type systems that are strongly normalising are the simply typed lambda calculus [Tai67] [Tro73], the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus <ref> [Gir72] </ref>, the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. However the pure type systems that are inconsistent like fl are not weakly normalising [Gir72]. <p> the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus <ref> [Gir72] </ref>, the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. However the pure type systems that are inconsistent like fl are not weakly normalising [Gir72]. We do not know any pure type system that is weakly normalising but not strongly normalising. <p> Tait defined the class of computable terms (or reducible terms). Using Tait's method one can also prove strong normalisation for the simply typed lambda calculus and some of its extensions, like Godel's T [Tro73]. Girard <ref> [Gir72] </ref> introduced the concept of candidate of reducibility to generalise Tait's method to include polymorphism 8.4. CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see [Gal90]. <p> CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see [Gal90]. The conditions in the definition of candidate of reducibility in <ref> [Gir72] </ref> were modified in [Tai75] and [Mit86] and a new definition was introduced: a saturated set. The definitions of the set SN and of saturated sets are very similar (see chapter 5). <p> PURE TYPE SYSTEMS The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus [Chu40], 2 is the second order typed lambda calculus <ref> [Gir72] </ref> and [Rey74], P is AUT-QE and LF [Bru70] and [RHP87]. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1. <p> The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus [Chu40], 2 is the second order typed lambda calculus <ref> [Gir72] </ref> and [Rey74], P is AUT-QE and LF [Bru70] and [RHP87]. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1. The system of higher order logic can be described by the following specification (see [Geu93]). <p> For example, an inconsistent pure type system is fl determined by the specification (S; A; R) where S = fflg, A = f (fl; fl)g and R = f (fl; fl)g (see <ref> [Gir72] </ref> and [Bar92]). Properties of Pure Type Systems The advantage of pure type systems is that we can do the metatheory of several type systems at the same time. There are several properties that can be proved for all these systems. 9.3.
Reference: [GLM92] <author> G. Gonthier, J. Levy, and P. A. Mellies. </author> <title> An abstract standardisation theorem. </title> <booktitle> In Seventh Annual IEEE Symposium on Logic In Computer Science, </booktitle> <pages> pages 72-81. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see [SP94]). Many other criteria came up as generalisations of existing proofs (see [New42], [Klo90], [Oos94] and <ref> [GLM92] </ref>). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2.
Reference: [GLSH92] <author> E. R. Griffor, I. Lindstroem, and V. Stoltenberg-Hansen. </author> <title> Mathematical Theory of Domains. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This topology is sometimes called the Alexandroff topology associated to !. It has been considered especially in the case in which ! is a preorder on A, see <ref> [GLSH92] </ref>. In the case that X = fag we write C (a) instead of C (fag). The closure of a point is the transitive reduction graph of the point and it is a closed set.
Reference: [GN91] <author> H. Geuvers and M. J. Nederhof. </author> <title> A modular proof of strong normalization for the calculus of constructions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 155-189, </pages> <year> 1991. </year>
Reference-contexts: Examples of pure type systems that are strongly normalising are the simply typed lambda calculus [Tai67] [Tro73], the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus [Gir72], the Calculus of Constructions <ref> [GN91] </ref> (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. However the pure type systems that are inconsistent like fl are not weakly normalising [Gir72]. We do not know any pure type system that is weakly normalising but not strongly normalising. <p> Let S be a singly sorted specification. Then (S) verifies uniqueness of types. 7. Let S be a logical specification. If (S) is inconsistent then (S) is not normalising. The proofs of these properties can be found in <ref> [GN91] </ref> and [Bar92] except for strength ening that is proved in [BJ93]. Theorem 9.3. (Strong Normalisation) 1. The system C 1 is fi-strongly normalising. 2. The systems of the -cube are fi-strongly normalising. 3. The system (HOL) is fi-strongly normalising. <p> Worse still, proving strong normalisation for particular pure type systems extended with definitions is already a problem. The strong normalisation proofs for particular type systems given in [Coq85], [Luo89], <ref> [GN91] </ref>, [Bar92] cannot be extended in any obvious way. In this chapter, we show how strong normalisation of a pure type system extended with definitions follows from strong normalisation of another (larger) pure type system.
Reference: [HA91] <author> L. Helmink and R. M. C. Ahn. </author> <title> Goal directed proof construction in type theory. </title> <booktitle> In Procs. of the first Workshop on Logical Frameworks. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor <ref> [HA91] </ref>, Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. <p> A definition mechanism is essential for practical use, and indeed implementations of pure type systems such as Coq [Dow91], Lego [LP92] or Constructor <ref> [HA91] </ref> do provide such a facility, even though the formal definition of the systems they implement do not. In this chapter, we extend the pure type system to include (non-recursive) definitions.
Reference: [HMM86] <author> R. Harper, D. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> LFCS Report Series ECS-LFCS-86-2, </type> <institution> LFCS-University of Edinburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: The first typed programming languages developed to avoid typing errors at compile-time, were ALGOL-60 and PASCAL where variables have to be declared in the programs (typing a la Church). More sophisticated typed languages appeared later, like ML <ref> [HMM86] </ref>, Miranda [Tur85] and Haskell [HW88]. The last mentioned languages are functional programming languages based on fragments of F a la Curry. In this approach, types are introduced in the programming language to ensure correctness of programs.
Reference: [How80] <author> W. A. Howard. </author> <title> The formulae-as-types notion of construction. </title> <editor> In J. R. Hindley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Hence the type of a program 1.2. LAMBDA CALCULI WITH TYPES 5 gives a partial specification of the program. Terms are viewed as programs and types as specifications for the programs. Another approach to the notion of type is the so-called propositions-as-types interpretation [Bru70] <ref> [How80] </ref>. A type is viewed as a proposition and a term as its proof. The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94].
Reference: [HST89] <author> R. Harper, D. Sanella, and A. Tarlecki. </author> <title> Structure and Representation in LF. </title> <booktitle> In IEEE Fourth Annual Symposium On Logic in Computer Science, </booktitle> <pages> pages 226-237, </pages> <year> 1989. </year>
Reference-contexts: In [Pol94], this result is stated in an informal way. Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately. Abstract formalisations of the notion of logic can be found in [Bar74], [Mes89], <ref> [HST89] </ref>, [Avr92] and [Acz95]. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important.
Reference: [HW88] <author> P. Hudak and P.L. Wadler. </author> <title> Report of the functional programming language Haskell. </title> <type> Technical Report YALEU/DCS/RR656, </type> <institution> Yale University, </institution> <year> 1988. </year>
Reference-contexts: The first typed programming languages developed to avoid typing errors at compile-time, were ALGOL-60 and PASCAL where variables have to be declared in the programs (typing a la Church). More sophisticated typed languages appeared later, like ML [HMM86], Miranda [Tur85] and Haskell <ref> [HW88] </ref>. The last mentioned languages are functional programming languages based on fragments of F a la Curry. In this approach, types are introduced in the programming language to ensure correctness of programs. Types are a way of classifying the objects to use them in a correct way.
Reference: [Hyl73] <author> J. M. E. Hyland. </author> <title> A simple proof of the Church-Rosser theorem. </title> <type> Technical report, </type> <institution> Oxford University, </institution> <year> 1973. </year>
Reference-contexts: Church and Rosser proved finiteness of developments for the I-calculus with fi-reduction in [CR36]. The first proof for the full -calculus is given by Schroer in [Sch65]. Other proofs have been given in <ref> [Hyl73] </ref> and [Bar85]. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5). There is a short and elegant proof by de Vrijer [Vri85], in which an exact bound for the length of a development is computed.
Reference: [Kel55] <author> J. Kelley. </author> <title> General Topology. </title> <publisher> Van Nordstram Company, Inc., </publisher> <year> 1955. </year>
Reference-contexts: The rewrite relation is defined as follows: an element a rewrites to b if b is in the closure of the element a. This rewrite relation is reflexive and transitive. We recall the definition and the basic properties of closure operators on a set (see <ref> [Kel55] </ref>). Definition 3.2.1. A map C : P (A) ! P (A) is called a closure operator if it verifies: 1. ; c = ;, 3. X c = (X c ) , c c [ X 2 Definition 3.2.2.
Reference: [KKS95] <author> R. Kennaway, J. W. Klop, and R. Sleep. </author> <title> Infinitary lambda calculus. </title> <type> Technical report, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1995. </year>
Reference-contexts: In earlier work, other topologies associated to a reduction relation have been considered. In all these cases the topology depends on the structure of the terms (see [Bar85], [KKSdV91] and <ref> [KKS95] </ref>). 36 CHAPTER 3. TOPOLOGY Chapter 4 Abstract Typing Systems 4.1 Introduction In computer science the notions of computation and typing are basic, and play an essential role in the theory and its applications.
Reference: [KKSdV91] <author> R. Kennaway, J. W. Klop, R. Sleep, and F. J. de Vries. </author> <title> Transfinite reductions in orthogonal term rewriting systems. </title> <type> Technical report, </type> <institution> Centre for Mathematics and Computer Science Amsterdam, </institution> <year> 1991. </year>
Reference-contexts: In earlier work, other topologies associated to a reduction relation have been considered. In all these cases the topology depends on the structure of the terms (see [Bar85], <ref> [KKSdV91] </ref> and [KKS95]). 36 CHAPTER 3. TOPOLOGY Chapter 4 Abstract Typing Systems 4.1 Introduction In computer science the notions of computation and typing are basic, and play an essential role in the theory and its applications.
Reference: [Klo80] <author> J. W. Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> Rijksuniversiteit Utrecht, </institution> <year> 1980. </year> <note> BIBLIOGRAPHY 195 </note>
Reference-contexts: The abstract notion of rewrite relation was first formalised by Newman (see [New42]) under the name of `move' or indexed 1-complex. They are also called abstract reduction systems in <ref> [Klo80] </ref>. We call them abstract rewriting systems as in [Oos94]. 15 16 CHAPTER 2. ABSTRACT REWRITING SYSTEMS Definition 2.2.1. An abstract rewriting system is a structure (A; !) where A is a set of objects and ! is a subset of A fi A called a rewrite relation (or reduction). <p> Church and Rosser proved finiteness of developments for the I-calculus with fi-reduction in [CR36]. The first proof for the full -calculus is given by Schroer in [Sch65]. Other proofs have been given in [Hyl73] and [Bar85]. In <ref> [Klo80] </ref>, finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5). There is a short and elegant proof by de Vrijer [Vri85], in which an exact bound for the length of a development is computed. <p> Since ffi is strongly normalising, we conclude that all the developments are finite. This is our third proof of finiteness of developments (see chapter 7) and it is similar to the proof of the same result in <ref> [Klo80] </ref> using fi-reduction with memory. The length of a development is always smaller than the length of the corresponding ffi-rewrite sequence. This can also be formalised. The function w () used to prove strong normalisation of ffi computes the length of a maximal ffi-rewrite sequence to the normal form.
Reference: [Klo90] <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <type> Technical Report CS-R9073, </type> <institution> Centre for Mathematics and Computer Science Amsterdam, </institution> <year> 1990. </year>
Reference-contexts: The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see [SP94]). Many other criteria came up as generalisations of existing proofs (see [New42], <ref> [Klo90] </ref>, [Oos94] and [GLM92]). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2. <p> It follows from the fact that the combinatorial reduction system &lt; T ffi ; ! fi &gt; is orthogonal (see <ref> [Klo90] </ref>). Theorem 11.3.12. (Confluence for fi-reduction) Let a; a 1 ; a 2 2 T ffi such that a !! fi a 1 and a !! fi a 2 .
Reference: [KN93] <author> F. Kamareddine and R. </author> <title> Nederpelt. On stepwise explicit substitution. </title> <journal> Inter-nation Journal of Foundation of Computer Science, </journal> <volume> 4(3) </volume> <pages> 197-240, </pages> <year> 1993. </year>
Reference-contexts: The substitution is said to be explicit if it is not a meta-operation on terms but part of the formal language with a special constructor bfx := ag and a special rewrite relation fi x 11.5. CONCLUSIONS AND RELATED WORK 169 to define `the substitution behaviour' [ACCL91] <ref> [KN93] </ref> [BG96] [Tas93]. The fi x -reduction and the ffi-reduction are very similar, they both unfold one occurrence of a variable at a time. They differ in the way they perform this unfolding.
Reference: [KN95] <author> F. Kamareddine and R. </author> <title> Nederpelt. Refining reduction in the lambda calculus. </title> <journal> J. Functional Programming, </journal> <volume> 5(4) </volume> <pages> 637-651, </pages> <year> 1995. </year>
Reference-contexts: In [Mel96] an axiomatic and general proof of finiteness of developments is given. In [Raa93] the proof that the superdevelopments are finite uses the method of mini-malisation. Superdevelopments are related to the so-called `generalised fi-reduction'. The gener-alised fi-reduction first appers in [Ned73] (see also <ref> [KN95] </ref>) as a natural generalisation of the fi-reduction in the item notation. A fi-redex in item notation is a ffi-item (an application) followed by a -item (an abstraction) like if they were a pair () of parentheses.
Reference: [Kri93] <author> J. L. Krivine. </author> <title> Lambda-Calculus, Types and Models. </title> <publisher> Masson, </publisher> <address> France, </address> <year> 1993. </year>
Reference-contexts: For proving that the bound is an exact bound, he makes in fact use of the strategy F 1 . Another proof can be found in [Par90] (see also <ref> [Kri93] </ref>) that uses strong normalisation of the simply typed lambda calculus with intersection types.
Reference: [Lev78] <author> J. J. Levy. </author> <title> Reductions correctes et optimales dans le lambda-calcul. </title> <type> PhD thesis, </type> <institution> Universite de Paris VII, </institution> <year> 1978. </year>
Reference-contexts: Superdevelopments form an extension of the notion of development. In a superdevelopment not only redexes that descend from the initial term may be contracted, but also some redexes that are created during reduction. There are three ways of creating new redexes (see <ref> [Lev78] </ref>): 1. ((x:y:M )N)P ! fi (y:M [x := N ])P 70 CHAPTER 7.
Reference: [Loa95] <author> R. Loader. </author> <title> Normalisation by translation. Note distributed on the `types' mailing list, </title> <year> 1995. </year>
Reference-contexts: Our definition of SN first appeared in [RS95] and more or less simultaneously a similar definition appeared in <ref> [Loa95] </ref>. Chapter 6 Perpetual Strategies 6.1 Introduction In this chapter we define two strategies G bk and G 1 similar to F bk [BK82] and F 1 [BBKV76]. These strategies are perpetual, which means that they yield an infinite rewrite sequence whenever possible.
Reference: [LP92] <author> Z. Luo and R. Pollack. </author> <title> LEGO proof development system: User's manual. </title> <type> Technical Report ECS-LFCS-92-211, </type> <institution> LFCS-University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego <ref> [LP92] </ref>, Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. <p> A definition mechanism is essential for practical use, and indeed implementations of pure type systems such as Coq [Dow91], Lego <ref> [LP92] </ref> or Constructor [HA91] do provide such a facility, even though the formal definition of the systems they implement do not. In this chapter, we extend the pure type system to include (non-recursive) definitions.
Reference: [LSZ96] <author> T. Laan, P. Severi, and J. Zwanenburg. </author> <title> Pure type systems with parameters. </title> <note> Technical Report To appear, </note> <institution> Eindhoven University of Technology, </institution> <year> 1996. </year>
Reference-contexts: It is still an open problem whether extending an arbitrary pure type system with definitions preserves strong normalisation or not. Definitions with parameters. In <ref> [LSZ96] </ref>, we consider definitions with parameters like in the systems of the AUTOMATH family [NGdV94].
Reference: [Luo89] <author> Z. Luo. </author> <title> ECC, the Extended Calculus of Constructions. </title> <booktitle> In The fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 386-395. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: Definition 9.2. The Calculus of Constructions extended with an infinite type hierarchy can be described by the following specification. S IN R f (m; 0; 0) j m 2 INg [ The system C 1 extended with strong -types and cumulativity is the system ECC (see <ref> [Luo89] </ref>). We can see that C 1 is an extension of C and of (HOL) writing fl instead of 0, 2 instead of 1 and 4 instead of 3. Note that there is no topsort in C 1 . Definition 9.3.17. Let S be a logical specification. <p> Theorem 9.3. (Strong Normalisation) 1. The system C 1 is fi-strongly normalising. 2. The systems of the -cube are fi-strongly normalising. 3. The system (HOL) is fi-strongly normalising. Proof: The system ECC is strongly normalising (see <ref> [Luo89] </ref>) and contains C 1 , the systems of the -cube and (HOL). 2 There are pure type systems that are not normalising, e.g. the system fl which is inconsistent (see theorem 9.3.18 part 7). <p> Worse still, proving strong normalisation for particular pure type systems extended with definitions is already a problem. The strong normalisation proofs for particular type systems given in [Coq85], <ref> [Luo89] </ref>, [GN91], [Bar92] cannot be extended in any obvious way. In this chapter, we show how strong normalisation of a pure type system extended with definitions follows from strong normalisation of another (larger) pure type system.
Reference: [Luo90] <author> Z. Luo. </author> <title> An Extended Calculus of Constructions. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1990. </year>
Reference-contexts: Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions <ref> [Luo90] </ref> with inductive types. Constructor is a partly automated proof assistant for pure type systems. <p> pure type systems that are strongly normalising are the simply typed lambda calculus [Tai67] [Tro73], the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus [Gir72], the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions <ref> [Luo90] </ref>. However the pure type systems that are inconsistent like fl are not weakly normalising [Gir72]. We do not know any pure type system that is weakly normalising but not strongly normalising.
Reference: [Mag94] <author> L. Magnusson. </author> <title> The Implementation of Alf-a proof editor based on Martin-Lof 's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology, </institution> <year> 1994. </year>
Reference-contexts: The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH [NGdV94]. Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf <ref> [Mag94] </ref>. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. <p> Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. The first version of Alf [ACN90] is based on Martin-Lof's type theory [NPS90] and the actual version <ref> [Mag94] </ref> is based on the monomorphic type theory with explicit substitution [Tas93]. 1.2.1 Pure Type Systems In this thesis we work with pure type systems. They provide a framework to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. <p> In the application rule we have to check if two types are fi-convertible. It would be sufficient to find a computable common-reduct strategy F : T fi T ! P (T ) and then check if F (a; b) 6= ;. The strategy presented in [Coq91] (see also <ref> [Mag94] </ref>) reduces as less as possible by performing weak head reduction. The idea is to compute the weak head normal forms of 10.8. TYPE INFERENCE 123 the terms and compare their heads. In spite of being efficient, it gives a set of common-reducts only if both terms are normalising.
Reference: [Mel96] <author> P. A. Mellies. </author> <title> Description abstraite de Systemes de Reecriture. </title> <type> PhD thesis, </type> <institution> Universite de Paris VII, </institution> <year> 1996. </year>
Reference-contexts: A similar proof using strong normalisation of simply typed lambda calculus appears in [Ghi94]. In <ref> [Mel96] </ref> an axiomatic and general proof of finiteness of developments is given. In [Raa93] the proof that the superdevelopments are finite uses the method of mini-malisation. Superdevelopments are related to the so-called `generalised fi-reduction'.
Reference: [Mes89] <author> J. Meseguer. </author> <title> Relating models of polymorphism. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 228-241. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: In [Pol94], this result is stated in an informal way. Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately. Abstract formalisations of the notion of logic can be found in [Bar74], <ref> [Mes89] </ref>, [HST89], [Avr92] and [Acz95]. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important. <p> Abstract formalisations of the notion of logic can be found in [Bar74], <ref> [Mes89] </ref>, [HST89], [Avr92] and [Acz95]. These formalisations are aimed to model different aspects of logic. For example, the notion of a proof is modelled in [Mes89] but the rewrite relation between proofs is not considered important. The notion of abstract rewriting systems with typing intends to capture the notions of terms (proofs), types (propositions) and the reduction of terms (the simplification of proofs).
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Type inference for systems a la Curry is not always decidable, not even for normalis-ing ones. For example, type inference for the simply typed lambda calculus is decidable [Cur69] <ref> [Mil78] </ref> but for ! (or F !) is undecidable [Urz93b]. An incomplete overview of the decidability of type inference in the systems a la Curry can be found in a table on page 183 in [Bar92].
Reference: [Mit86] <author> J. C. Mitchell. </author> <title> A type-inference approach to reduction properties and semantics of polymorphic expressions. </title> <booktitle> In Proc. 1986 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 308-319. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see [Gal90]. The conditions in the definition of candidate of reducibility in [Gir72] were modified in [Tai75] and <ref> [Mit86] </ref> and a new definition was introduced: a saturated set. The definitions of the set SN and of saturated sets are very similar (see chapter 5). Our proof differs from the proof by Tait in the fact that in his method an interpretation for types is used.
Reference: [MR86] <author> A. R. Meyer and M. B. Reinhold. </author> <title> `type` is not a type: Preliminary report. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 287-295. </pages> <note> ACM, 1986. 196 BIBLIOGRAPHY </note>
Reference-contexts: Undecidability of type inference for inconsistent impredicative pure type systems is proved in [CH94] generalising the result in <ref> [MR86] </ref>. The problem of inhabitation in systems a la Church presents the same complications as for systems a la Curry. For the inconsistent systems, inhabitation is trivial since all the types have at least one inhabitant. <p> If (S) is inconsistent then type inference and type checking in (S) are undecidable. This is proved in [CH94] as a generalisation of the result of <ref> [MR86] </ref>. The problem of inhabitation in ! and in ! are decidable but in the rest of the systems of the cube is undecidable [Spr95]. For the inconsistent systems, inhabitation is trivial. 9.4 Conclusions and Related Work As we said before, pure type systems were introduced independently by S.
Reference: [Ned73] <author> R. P. </author> <title> Nederpelt. Strong Normalisation in a Typed Lambda-Calculus with Lambda-Structured Typed. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1973. </year>
Reference-contexts: The first proof for the full -calculus is given by Schroer in [Sch65]. Other proofs have been given in [Hyl73] and [Bar85]. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' <ref> [Ned73] </ref> (see also section 11.5). There is a short and elegant proof by de Vrijer [Vri85], in which an exact bound for the length of a development is computed. For proving that the bound is an exact bound, he makes in fact use of the strategy F 1 . <p> In [Mel96] an axiomatic and general proof of finiteness of developments is given. In [Raa93] the proof that the superdevelopments are finite uses the method of mini-malisation. Superdevelopments are related to the so-called `generalised fi-reduction'. The gener-alised fi-reduction first appers in <ref> [Ned73] </ref> (see also [KN95]) as a natural generalisation of the fi-reduction in the item notation. A fi-redex in item notation is a ffi-item (an application) followed by a -item (an abstraction) like if they were a pair () of parentheses. <p> The inclusion of definitions in the formal language and its study have not been considered before except for the systems of the AUTOMATH family [NGdV94]. 168 CHAPTER 11. PURE TYPE SYSTEMS WITH DEFINITIONS Definitions vs local fi-reduction. In the systems of the AUTOMATH family, definitions are written as fi-redexes <ref> [Ned73] </ref> [Daa80]. A reduction called local fi-reduction to unfold one occurrence of a variable at a time is introduced in [Ned92]. In some later versions of AUTOMATH, definitions are connected with local fi-reduction.
Reference: [Ned92] <author> R. P. </author> <title> Nederpelt. The fine-structure of lambda calculus. </title> <institution> Computer science notes CS-9207, TU, </institution> <year> 1992. </year>
Reference-contexts: PURE TYPE SYSTEMS WITH DEFINITIONS Definitions vs local fi-reduction. In the systems of the AUTOMATH family, definitions are written as fi-redexes [Ned73] [Daa80]. A reduction called local fi-reduction to unfold one occurrence of a variable at a time is introduced in <ref> [Ned92] </ref>. In some later versions of AUTOMATH, definitions are connected with local fi-reduction. We prefer, as in the original AUTOMATH systems, to have a special constructor for definition and a reduction for the unfolding of definitions to make a clear distinction between definitions and fi-redexes. Global and Local Definitions.
Reference: [New42] <author> M. H. A. Newman. </author> <title> On theories with a combinatorial definition of `equivalence'. </title> <journal> Annals of Mathematics, </journal> <volume> 43(2) </volume> <pages> 223-243, </pages> <year> 1942. </year>
Reference-contexts: We also give some general criteria to prove confluence, weak and strong normalisation. 2.2 Abstract Rewriting Systems In this section we recall the definition of abstract rewriting system. The abstract notion of rewrite relation was first formalised by Newman (see <ref> [New42] </ref>) under the name of `move' or indexed 1-complex. They are also called abstract reduction systems in [Klo80]. We call them abstract rewriting systems as in [Oos94]. 15 16 CHAPTER 2. ABSTRACT REWRITING SYSTEMS Definition 2.2.1. <p> The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see [SP94]). Many other criteria came up as generalisations of existing proofs (see <ref> [New42] </ref>, [Klo90], [Oos94] and [GLM92]). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2.
Reference: [NGdV94] <editor> R. P. Nederpelt, J. H. Geuvers, and R. C. de Vrijer. </editor> <booktitle> Selected Papers on Automath. Studies in Logic and the Foundation of Mathematics, </booktitle> <volume> volume 133. </volume> <publisher> North Holland Publ. Company, </publisher> <year> 1994. </year>
Reference-contexts: Another approach to the notion of type is the so-called propositions-as-types interpretation [Bru70] [How80]. A type is viewed as a proposition and a term as its proof. The first systems of proof checking (type checking) based on this interpretation of propositions-as-types and proofs-as-terms were the systems of AUTOMATH <ref> [NGdV94] </ref>. Modern systems that also provide computer-assistance for the construction of proofs are Coq [Dow91], Lego [LP92], Constructor [HA91], Nuprl [Con86] and Alf [Mag94]. Coq is based on the calculus of constructions [CH88] extended with inductive definitions [CP90]. <p> They were introduced independently by S. Berardi [Ber88] (see also [Ber90]) and J. Terlouw [Ter89]. Many systems can be described in this way, for instance the simply and the polymorphic typed lambda calculus, the systems of the AUTOMATH family <ref> [NGdV94] </ref>, the Calculus of Constructions (and all the systems of the -cube [Bar92]) and the inconsistent system fl [Gir72]. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. <p> Definitions are usually considered in a meta-level and not as part of the language of the lambda calculus. In the systems of the AUTOMATH family <ref> [NGdV94] </ref> definitions are considered as part of the formal language. The meta-theory of these systems is treated in detail in [Daa80]. Howewer, some of the proofs apply only to the particular type system that they consider and do not extend to other type systems. <p> In this case, to ensure termination we have to prove that any strategy is normalising, i.e. strong normalisation. Examples of pure type systems that are strongly normalising are the simply typed lambda calculus [Tai67] [Tro73], the systems of the AUTOMATH family <ref> [NGdV94] </ref>, the polymorphic typed lambda calculus [Gir72], the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. However the pure type systems that are inconsistent like fl are not weakly normalising [Gir72]. <p> This enables us to prove that for all strongly normalising pure type systems that we know the extensions with definitions are also strongly normalising. In the systems of the AUTOMATH family <ref> [NGdV94] </ref> definitions are considered as part of the formal language. The meta-theory of these systems -including strong normalisation is treated in detail in [Daa80]. However, the proofs of strong normalisation apply only to the particular type system that they consider and do not extend to other type systems. <p> In our opinion, this extension has been done in a neat and general way (for pure type systems). The inclusion of definitions in the formal language and its study have not been considered before except for the systems of the AUTOMATH family <ref> [NGdV94] </ref>. 168 CHAPTER 11. PURE TYPE SYSTEMS WITH DEFINITIONS Definitions vs local fi-reduction. In the systems of the AUTOMATH family, definitions are written as fi-redexes [Ned73] [Daa80]. A reduction called local fi-reduction to unfold one occurrence of a variable at a time is introduced in [Ned92]. <p> It is still an open problem whether extending an arbitrary pure type system with definitions preserves strong normalisation or not. Definitions with parameters. In [LSZ96], we consider definitions with parameters like in the systems of the AUTOMATH family <ref> [NGdV94] </ref>. We write x (y 1 ::B 1 ; : : : ; y n :B n ) = a : A to denote that x is an abbreviation for a and the variables y 1 ; : : : y n may occur free in a. <p> In our opinion, this extension has been done in a neat and general way (for pure type systems). The inclusion of definitions in the formal language and its study have not been considered before except for the systems of the AUTOMATH family <ref> [NGdV94] </ref>, that can be seen as particular pure type systems. 13.3.1 Normalisation The two extension of pure type systems, without the -condition and with definitions have similar properties that are compared in table 13.1. WN is an abbreviation for weak normalisation and SN is an abbreviation for strong normalisation.
Reference: [NPS90] <author> B. Nordstrom, K. Petersson, and J. M. Smith. </author> <title> Programming in Martin-Lof 's Type Theory. An introduction. </title> <publisher> Oxford Science Publications, </publisher> <year> 1990. </year>
Reference-contexts: Lego is a proof assistant for the extended calculus of constructions [Luo90] with inductive types. Constructor is a partly automated proof assistant for pure type systems. The first version of Alf [ACN90] is based on Martin-Lof's type theory <ref> [NPS90] </ref> and the actual version [Mag94] is based on the monomorphic type theory with explicit substitution [Tas93]. 1.2.1 Pure Type Systems In this thesis we work with pure type systems. They provide a framework to describe a large class of type systems a la Church in a uniform way.
Reference: [Oos94] <author> V. van Oostrom. </author> <title> Confluence for Abstract and Higher-Order Rewriting. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: The abstract notion of rewrite relation was first formalised by Newman (see [New42]) under the name of `move' or indexed 1-complex. They are also called abstract reduction systems in [Klo80]. We call them abstract rewriting systems as in <ref> [Oos94] </ref>. 15 16 CHAPTER 2. ABSTRACT REWRITING SYSTEMS Definition 2.2.1. An abstract rewriting system is a structure (A; !) where A is a set of objects and ! is a subset of A fi A called a rewrite relation (or reduction). Definition 2.2.2. <p> The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see [SP94]). Many other criteria came up as generalisations of existing proofs (see [New42], [Klo90], <ref> [Oos94] </ref> and [GLM92]). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2.
Reference: [Par90] <author> M. Parigot. </author> <title> Internal labelling in lambda calculus. </title> <booktitle> In MFCS'90, number 452 in LNCS, </booktitle> <pages> pages 439-445. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: For proving that the bound is an exact bound, he makes in fact use of the strategy F 1 . Another proof can be found in <ref> [Par90] </ref> (see also [Kri93]) that uses strong normalisation of the simply typed lambda calculus with intersection types.
Reference: [Pol93a] <author> E. Poll. </author> <title> A type checker for bijective pure type systems. </title> <institution> Computing Science Note CS-9322, Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: The system obtained by eliminating the non-structural rules should be equivalent to the original one. The proof of the equivalence (soundness and completeness) between the original rules and the corresponding syntax directed ones is problematic for some pure type systems (see [BJMP93] and also <ref> [Pol93a] </ref>). Here we present a syntax directed set of rules for singly sorted pure type systems similar to the one presented in [BJMP93]. <p> In that paper, the auxiliary system is much weaker than (S). In our case, the auxiliary system is ! (S), which is very close to (S). Moreover, ! (S) preserves some properties of (S) like normalisation. In <ref> [Pol93a] </ref> a syntax directed set of rules for bijective pure type systems is presented. The class of bijective pure type systems includes all systems of the -cube and is a proper subclass of the class we study here, the class of singly sorted pure type systems. <p> sorted, impredicative and non-dependent ffi (S) is inconsistent undecidable undecidable Table 12.2: Decidability of type inference and type checking In our opinion, the algorithm for normalising pure type systems whose set of sorts is finite defined in [BJ93] and the syntax directed sets of rules defined in [BJMP93] and in <ref> [Pol93a] </ref> can be adapted to include definitions by using the function j j to prove the equivalence between the syntax directed set of rules and the original system. 184 CHAPTER 12. TYPE INFERENCE FOR DEFINITIONS Chapter 13 Conclusions In this chapter we discuss the results of this thesis.
Reference: [Pol93b] <author> R. Pollack. </author> <title> Closure under Alpha Conversion. </title> <editor> In H. Barendregt and T. Nipkov, editors, </editor> <title> In Types for Proofs and Programs, </title> <publisher> LNCS, </publisher> <pages> pages 313-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The term (x:A: x:B: x) is not typable because the second occurrence of x is not &lt; A : fl; x:A &gt;-fresh. It is necessary to perform ff-conversion to ensure subject reduction. In fact subject reduction holds up to ff-conversion (see <ref> [Pol93b] </ref>). In the context A : fl, the term (y:(A ! A): x:A: y)(x:B: x) is typable in a pure type system. This term reduces to (x : A: x : B: x) which is not typable.
Reference: [Pol94] <author> E. Poll. </author> <title> A Programming Logic Based on Type Theory. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1994. </year>
Reference-contexts: Intuitively, the interpretation of a pure type system with definitions is obtained by computing first the ffi-normal form and then applying the interpretation of the original system without definitions. In <ref> [Pol94] </ref>, this result is stated in an informal way. Since we introduce the general setting of abstract typing systems, we can say formally what an interpretation is and the considered property can be formalised adequately.
Reference: [Pol96] <author> R. Pollack. </author> <title> A Verified Type Checker. </title> <editor> In B. Bjerner, M. Larsson, and B. Nord-strom, editors, </editor> <booktitle> Proceedings of the 7th Nordic Workshop on Programming Theory, 86. </booktitle> <institution> Goteborg University and Chalmers University of Technology, </institution> <year> 1996. </year>
Reference-contexts: Moreover decidability of type inference is very closely related to normalisation. Decidability of type inference for normalising pure type systems whose set of sorts is finite is proved in [BJ93] and decidability for normalising pure type systems whose specification is recursive and singly sorted (also semi-full) is proved in <ref> [Pol96] </ref>. Undecidability of type inference for inconsistent impredicative pure type systems is proved in [CH94] generalising the result in [MR86]. The problem of inhabitation in systems a la Church presents the same complications as for systems a la Curry. <p> Suppose that S is singly sorted or semi-full and that the sets S, A and R are recursive. Then type inference and type checking in (S) are decidable. The proof of the first part can be found in [BJ93] and the second one in [BJMP93] and <ref> [Pol96] </ref>. 96 CHAPTER 9. PURE TYPE SYSTEMS Theorem 9.3.20. (Undecidability of Type Inference and Type Checking) Let S = (S; A; R) be a singly sorted, non-dependent and impredicative specification. If (S) is inconsistent then type inference and type checking in (S) are undecidable. <p> check (; a; A) = 8 &gt; &gt; &gt; : true if whnf (type (; A)) = s 2 S, type (; a) 6= ? and F ++ (type (; a); A) 6= ; f alse otherwise We have the following conclusion which has been proved before in [BJMP93] and <ref> [Pol96] </ref> (see theorem 9.3.19). Theorem 10.8.16. (Decidability of Type Inference and Type Checking) Let S = (S; A; R) be singly sorted such that the sets S, A and R are recursive. If (S) is fi-weakly normalising then type inference and type checking in (S) are decidable. <p> Decidability of type checking for normalising pure type systems whose set of sorts is finite is proved in [BJ93]. In that paper, a type inference algorithm is defined that computes the normal form in all the rules. A discussion on the side-conditions can be found in <ref> [Pol96] </ref>. In this paper, decidability of type inference is proved for normalising pure type systems that are either singly sorted or semi-full under the assumption that the sets forming the specification are recursive.
Reference: [Raa93] <editor> F. van Raamsdonk. Confluence and superdevelopment. In Claude Kirchner, editor, </editor> <booktitle> Rewriting Techniques and Applications, volume 690 of LNCS, </booktitle> <pages> pages 168-182. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The mapping l is a morphism from (fl; ! fi ) into (SN ; ! fi ). Theorem 7.4.5. The rewrite relation fi is strongly normalising. Proof: This follows from lemma 2.6.5 and corollary 7.4.4. 2 Corollary 7.4.6. (Finiteness of Developments) All fi-developments are finite. 7.5 Superdevelopments In <ref> [Raa93] </ref>, superdevelopments were introduced and proved to be finite. Superdevelopments form an extension of the notion of development. In a superdevelopment not only redexes that descend from the initial term may be contracted, but also some redexes that are created during reduction. <p> A similar proof using strong normalisation of simply typed lambda calculus appears in [Ghi94]. In [Mel96] an axiomatic and general proof of finiteness of developments is given. In <ref> [Raa93] </ref> the proof that the superdevelopments are finite uses the method of mini-malisation. Superdevelopments are related to the so-called `generalised fi-reduction'. The gener-alised fi-reduction first appers in [Ned73] (see also [KN95]) as a natural generalisation of the fi-reduction in the item notation. <p> An way of labelling alternative to the one presented in <ref> [Raa93] </ref> (see definition 7.5.5) is to represent the term in item notation and to mark all the ffi and -items that match as if they were parentheses.
Reference: [Raa96] <author> F. van Raamsdonk. </author> <title> Confluence and Normalisation for Higher-Order Rewriting. </title> <type> PhD thesis, </type> <institution> VUA, University of Amsterdam, </institution> <year> 1996. </year>
Reference-contexts: We were both interested in an abstract notion for type systems in order to have a common framework for pure type systems and for higher order rewriting systems. For the use of these abstract notions in the context of higher order rewriting systems, we refer to <ref> [Raa96] </ref>. Chapter 3 is based on a paper with Walter Ferrer [FS93]. Lambda Calculus In this part, we give some new characterisations of the set of weakly and strongly normal-ising -terms focusing on expansion rather than reduction. <p> I = (IN; f (i; i + 1) j i 0g). Diagrammatically, 0 ! 1 ! 2 ! : : : 2.3 Morphisms In this section we introduce the notion of morphism for abstract rewriting systems (see also <ref> [Raa96] </ref>). We think that the concept of morphism is the natural one. It allows us to express several concepts like the notions of rewrite sequence and extension as morphisms. A morphism should preserve the structure. <p> We add this feature to all the abstract structures defined in the previous section. In section 4.5, we introduce a general notion of semantics. 4.2 Abstract Typing Systems In this section, we introduce the notion of abstract typing systems (see also <ref> [Raa96] </ref>) to formalise the notion of typing. As we said before a typing relation is formalised in an abstract way as a binary relation. Definition 4.2.1.
Reference: [Reg94] <author> L. Regnier. </author> <title> Une equivalence sur les lambda-termes. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 281-292, </pages> <year> 1994. </year> <note> BIBLIOGRAPHY 197 </note>
Reference-contexts: Proving G (M) ae SN ) M 2 SN and using the definition of SN make our proofs more perspicuous. The fact that F 1 is a maximal strategy has been proved by Regnier <ref> [Reg94] </ref> using a relation that permits the permutation of redexes. Much more in the spirit of the present work is a paper by Sorensen ([Sor94]), who gives a proof that is very similar to ours. His work was developed independently and simultaneously.
Reference: [RS95] <author> F. van Raamsdonk and P. Severi. </author> <note> On normalisation. Technical Report CS-R9545 and CS-9520, </note> <author> CWI-Amsterdam and TU-Eindhoven, </author> <year> 1995. </year>
Reference-contexts: In chapter 8, we prove strong normalisation for the simply typed lambda calculus. We use again the new characterisation of the strongly normalising -terms. This part is based on a paper with Femke van Raamsdonk <ref> [RS95] </ref>. Pure Type Systems with Definitions In this part, we study the meta-theory of pure type systems with definitions in detail. We also give semi-algorithms of type inference for singly sorted pure type systems with and without definitions. <p> A rewrite sequence oe in (A; ! ff ) is an f -lifting of a rewrite sequence ae if f ffi oe = ae. The notion of lifting for rewrite sequence has been defined in <ref> [RS95] </ref> in the context of indexed abstract rewriting systems. Note that this is the categorical notion of lifting for morphisms. Definition 2.3.6. <p> In the definition of SN , we have an additional clause for abstractions, and in the definition of saturated set it is necessary to add the requirement that the set should be a subset of the set of strongly normalising terms. Our definition of SN first appeared in <ref> [RS95] </ref> and more or less simultaneously a similar definition appeared in [Loa95]. Chapter 6 Perpetual Strategies 6.1 Introduction In this chapter we define two strategies G bk and G 1 similar to F bk [BK82] and F 1 [BBKV76].
Reference: [Rey74] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Programming Symposium: Colloque sur la Programmation, volume 19 of LNCS, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer, </publisher> <year> 1974. </year>
Reference-contexts: For example, (flff:x:ff: x) is the polymorphic identity. The extension of the simply typed lambda calculus with polymorphism is called polymorphic typed lambda calculs (F or 2 or second order typed lambda calculus) and it was introduced independently by [Gir72] and <ref> [Rey74] </ref>. Implementations of Lambda calculi The -calculus is the foundation of functional programming languages. The -calculus itself could be considered as an abstract programming language. It contains the concept of computation in full generality and strength but in a pure form with a very simple syntax. <p> PURE TYPE SYSTEMS The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus [Chu40], 2 is the second order typed lambda calculus [Gir72] and <ref> [Rey74] </ref>, P is AUT-QE and LF [Bru70] and [RHP87]. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1.
Reference: [RHP87] <author> F. Honsell R. Harper and G. Plotkin. </author> <title> A Framework For Defining Logics. </title> <booktitle> In Proc. Second Symposium of Logic in Computer Science, </booktitle> <pages> pages 194-204, </pages> <year> 1987. </year>
Reference-contexts: PURE TYPE SYSTEMS The systems of the -cube correspond to some known systems with some variations: ! is the simply typed lambda calculus [Chu40], 2 is the second order typed lambda calculus [Gir72] and [Rey74], P is AUT-QE and LF [Bru70] and <ref> [RHP87] </ref>. The system ! is POLYREC and ! is F ! [Gir72]. The last element in the table, C, corresponds to the Calculus of Constructions. All the systems in the -cube have only one topsort, namely 2. Definition 9.1.
Reference: [Sch65] <author> D. E. Schroer. </author> <title> The Church-Rosser Theorem. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1965. </year>
Reference-contexts: Church and Rosser proved finiteness of developments for the I-calculus with fi-reduction in [CR36]. The first proof for the full -calculus is given by Schroer in <ref> [Sch65] </ref>. Other proofs have been given in [Hyl73] and [Bar85]. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5).
Reference: [Sev96] <author> P. Severi. </author> <title> Pure type systems without the -condition. </title> <editor> In B. Bjerner, M. Lars-son, and B. Nordstrom, editors, </editor> <booktitle> Proceedings of the 7th Nordic Workshop on Programming Theory, 86. </booktitle> <institution> Goteborg University and Chalmers University of Technology, </institution> <year> 1996. </year>
Reference-contexts: We prove the equivalence between the syntax directed set of rules and the original ones. Finally, we define a function that infers the type in a singly sorted pure type system based on this syntax directed set of rules. This chapter is based on the paper <ref> [Sev96] </ref>. In chapter 11, we study the metatheory for pure type systems extended with definitions. We prove properties like confluence and subject reduction for the combination of the fi and ffi-reduction.
Reference: [Sor94] <author> M. H. Sorensen. </author> <title> Effective longest reductions paths in untyped -calculus. </title> <type> Draft, </type> <institution> Katholieke Universiteit Nijmegen, </institution> <year> 1994. </year>
Reference: [SP93] <author> P. Severi and E. Poll. </author> <title> Pure type systems with definitions. </title> <institution> Computing Science Note CS-9324, Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: Moreover, we prove for certain pure type systems, including the Calculus of Constructions, that strong normalisation is preserved by the extension. This chapter is based on a paper with Erik Poll <ref> [SP93, SP94] </ref>. In chapter 12, we define a function that infers the type of a term in a singly sorted pure type system with definitions. Similarly to pure type systems, we define a set of rules 12 CHAPTER 1.
Reference: [SP94] <author> P. Severi and E. Poll. </author> <title> Pure type systems with definitions. </title> <editor> In A. Nerode and Yu. V. Matiyasevich, editors, </editor> <booktitle> Logical Foundations of Computer Science: Proceedings of the Third International Symposium, </booktitle> <volume> 813, </volume> <pages> pages 316-328. </pages> <address> LFCS'94, St. Petersburg Russia, </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York, </address> <year> 1994. </year>
Reference-contexts: Moreover, we prove for certain pure type systems, including the Calculus of Constructions, that strong normalisation is preserved by the extension. This chapter is based on a paper with Erik Poll <ref> [SP93, SP94] </ref>. In chapter 12, we define a function that infers the type of a term in a singly sorted pure type system with definitions. Similarly to pure type systems, we define a set of rules 12 CHAPTER 1. <p> Also in these chapters we give more examples of common-reduct strategies for fi and fiffi-reduction. The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see <ref> [SP94] </ref>). Many other criteria came up as generalisations of existing proofs (see [New42], [Klo90], [Oos94] and [GLM92]). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2. <p> The criteria to prove confluence, weak and strong normalisation have been obtained generalising the original proofs done for pure type systems with definitions (see <ref> [SP94] </ref>). Many other criteria came up as generalisations of existing proofs (see [New42], [Klo90], [Oos94] and [GLM92]). The proofs of [SP94] are rewritten as applications of the new criteria in chapter 11. Moreover these criteria will also be applied to other particular cases. 26 CHAPTER 2.
Reference: [Spr95] <author> J. Springintveld. </author> <title> Algorithms for Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Philosophy - Utrecht University, </institution> <year> 1995. </year>
Reference-contexts: In the systems of the -cube, inhabitation is decidable only for the simply typed lambda calculus ( ! ) and for !. For the rest of the systems in the -cube inhabitation is undecidable <ref> [Spr95] </ref>. In this thesis, we give solutions for the problem of type inference in pure type systems (also with definitions). We present a type inference procedure (it is not an algorithm, i.e. a program that always terminates) for pure type systems. <p> This is proved in [CH94] as a generalisation of the result of [MR86]. The problem of inhabitation in ! and in ! are decidable but in the rest of the systems of the cube is undecidable <ref> [Spr95] </ref>. For the inconsistent systems, inhabitation is trivial. 9.4 Conclusions and Related Work As we said before, pure type systems were introduced independently by S. Berardi [Ber88] and J. Terlouw [Ter89].
Reference: [Tai67] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type I. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32 </volume> <pages> 198-212, </pages> <year> 1967. </year>
Reference-contexts: In this case, to ensure termination we have to prove that any strategy is normalising, i.e. strong normalisation. Examples of pure type systems that are strongly normalising are the simply typed lambda calculus <ref> [Tai67] </ref> [Tro73], the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus [Gir72], the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. <p> Therefore P Q 2 SN (o ). 2 8.4 Conclusions and Related Work An interesting proof of the normalisation of the simply typed lambda calculus is the one given by Tait in <ref> [Tai67] </ref>. Tait defined the class of computable terms (or reducible terms). Using Tait's method one can also prove strong normalisation for the simply typed lambda calculus and some of its extensions, like Godel's T [Tro73].
Reference: [Tai75] <author> W. W. Tait. </author> <title> A realizability interpretation of the theory of species. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Proceedings of the Logic Colloquim, volume 453 of LNCS, </booktitle> <pages> pages 240-251. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1975. </year>
Reference-contexts: CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see [Gal90]. The conditions in the definition of candidate of reducibility in [Gir72] were modified in <ref> [Tai75] </ref> and [Mit86] and a new definition was introduced: a saturated set. The definitions of the set SN and of saturated sets are very similar (see chapter 5). Our proof differs from the proof by Tait in the fact that in his method an interpretation for types is used.
Reference: [Tas93] <author> A. Tasistro. </author> <title> Formulation of Martin-Lof's Theory of Types with Explicit Substitution. </title> <institution> Computing science note, Chalmers University of Technology and University of Goteborg, </institution> <year> 1993. </year>
Reference-contexts: Constructor is a partly automated proof assistant for pure type systems. The first version of Alf [ACN90] is based on Martin-Lof's type theory [NPS90] and the actual version [Mag94] is based on the monomorphic type theory with explicit substitution <ref> [Tas93] </ref>. 1.2.1 Pure Type Systems In this thesis we work with pure type systems. They provide a framework to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. Berardi [Ber88] (see also [Ber90]) and J. Terlouw [Ter89]. <p> The substitution is said to be explicit if it is not a meta-operation on terms but part of the formal language with a special constructor bfx := ag and a special rewrite relation fi x 11.5. CONCLUSIONS AND RELATED WORK 169 to define `the substitution behaviour' [ACCL91] [KN93] [BG96] <ref> [Tas93] </ref>. The fi x -reduction and the ffi-reduction are very similar, they both unfold one occurrence of a variable at a time. They differ in the way they perform this unfolding.
Reference: [Ter89] <author> J. Terlouw. </author> <title> Een nadere bewijstheoretische analyse van GSTT's. </title> <type> Manuscript, </type> <year> 1989. </year> <note> 198 BIBLIOGRAPHY </note>
Reference-contexts: They provide a framework to describe a large class of type systems a la Church in a uniform way. They were introduced independently by S. Berardi [Ber88] (see also [Ber90]) and J. Terlouw <ref> [Ter89] </ref>. Many systems can be described in this way, for instance the simply and the polymorphic typed lambda calculus, the systems of the AUTOMATH family [NGdV94], the Calculus of Constructions (and all the systems of the -cube [Bar92]) and the inconsistent system fl [Gir72]. <p> They were introduced independently by S. Berardi [Ber88] (see also [Ber90]) and J. Terlouw <ref> [Ter89] </ref>. Important pure type systems are the systems of the -cube [Bar92]. They are called `pure' because there is only one type constructor and only one reduction rule, namely the type constructor and the fi-reduction. This chapter is organised as follows. <p> For the inconsistent systems, inhabitation is trivial. 9.4 Conclusions and Related Work As we said before, pure type systems were introduced independently by S. Berardi [Ber88] and J. Terlouw <ref> [Ter89] </ref>. In the typing rules for pure type systems, the axiom depends on the set A and the product rule depends on the set R. In other words, we have a family of axioms and product rules depending on A and R.
Reference: [Tro73] <author> A. S. Troelstra. </author> <title> Metamathematical Investigations of Intuitionistic Arithmetic and Analysis, </title> <booktitle> volume 344 of LNM. </booktitle> <publisher> Springer, </publisher> <year> 1973. </year>
Reference-contexts: In this case, to ensure termination we have to prove that any strategy is normalising, i.e. strong normalisation. Examples of pure type systems that are strongly normalising are the simply typed lambda calculus [Tai67] <ref> [Tro73] </ref>, the systems of the AUTOMATH family [NGdV94], the polymorphic typed lambda calculus [Gir72], the Calculus of Constructions [GN91] (and all the systems of the -cube) and the `pure' part of the extended calculus of constructions [Luo90]. <p> Tait defined the class of computable terms (or reducible terms). Using Tait's method one can also prove strong normalisation for the simply typed lambda calculus and some of its extensions, like Godel's T <ref> [Tro73] </ref>. Girard [Gir72] introduced the concept of candidate of reducibility to generalise Tait's method to include polymorphism 8.4. CONCLUSIONS AND RELATED WORK 83 (for the systems F to F ! ). For an explanation of the method and applications to prove confluence see [Gal90].
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In IFIP Int'l Conf. Funct. Program. Comput. Arch., volume 201 of LNCS. </booktitle> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: The first typed programming languages developed to avoid typing errors at compile-time, were ALGOL-60 and PASCAL where variables have to be declared in the programs (typing a la Church). More sophisticated typed languages appeared later, like ML [HMM86], Miranda <ref> [Tur85] </ref> and Haskell [HW88]. The last mentioned languages are functional programming languages based on fragments of F a la Curry. In this approach, types are introduced in the programming language to ensure correctness of programs. Types are a way of classifying the objects to use them in a correct way.
Reference: [Urz93a] <author> P. Urzyczyn. </author> <title> The emptiness problem for intersection types. </title> <type> Technical report, </type> <institution> Institute of Informatics University of Warsaw, </institution> <year> 1993. </year>
Reference-contexts: This table can be filled in completely by now: type checking and inference in 2 (or F ) have been proved undecidable in [Wel94] and the inhabitation of " has been proved undecidable in <ref> [Urz93a] </ref>. Type inference for ML [DM82] is decidable because polymorphism can be used only in a weaker form (the universal quantifiers can occur only in the outermost position of a type). For systems a la Church, in all known cases the problems of type checking and type inference are equivalent.
Reference: [Urz93b] <author> P. Urzyczyn. </author> <title> Type Reconstruction in F ! is undecidable. </title> <booktitle> In Int'l Conf. Typed Lambda Calculus and its Applications, volume 664 of LNCS, </booktitle> <pages> pages 418-432. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Type inference for systems a la Curry is not always decidable, not even for normalis-ing ones. For example, type inference for the simply typed lambda calculus is decidable [Cur69] [Mil78] but for ! (or F !) is undecidable <ref> [Urz93b] </ref>. An incomplete overview of the decidability of type inference in the systems a la Curry can be found in a table on page 183 in [Bar92].
Reference: [Vri85] <author> R. de Vrijer. </author> <title> A Direct Proof of the Finiteness of Developments Theorem. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 50, </volume> <year> 1985. </year>
Reference-contexts: Other proofs have been given in [Hyl73] and [Bar85]. In [Klo80], finiteness of developments is proved from strong normalisation for a fi-reduction with `memory' [Ned73] (see also section 11.5). There is a short and elegant proof by de Vrijer <ref> [Vri85] </ref>, in which an exact bound for the length of a development is computed. For proving that the bound is an exact bound, he makes in fact use of the strategy F 1 . <p> The length of a development is always smaller than the length of the corresponding ffi-rewrite sequence. This can also be formalised. The function w () used to prove strong normalisation of ffi computes the length of a maximal ffi-rewrite sequence to the normal form. In <ref> [Vri85] </ref>, a mapping h is defined that computes the length of a maximal development, i.e. the length of a maximal fi-rewrite sequence. The mapping w () composed with is an upper bound for the number of steps in a development.
Reference: [Vri87] <author> R. de Vrijer. </author> <title> Exactly estimating functionals and strong normalization. </title> <journal> In Proceedings of the Koninklijke Nederlandse Akademie van Wetenschappen, </journal> <volume> volume 90, </volume> <pages> pages 479-493, </pages> <year> 1987. </year>
Reference-contexts: On the other hand, in Tait's method one has to prove that [[o ]] ! [[oe]] is a subset of the set of strongly normalising terms. In our proof, the set SN (o ! oe) is a subset of the set of strongly normalising terms by definition. In <ref> [Vri87] </ref> strong normalisation for the simply typed lambda calculus is proved by giving a function that computes the length of the maximal rewrite sequence and by implictly following the strategy F 1 of maximal length.

References-found: 102

