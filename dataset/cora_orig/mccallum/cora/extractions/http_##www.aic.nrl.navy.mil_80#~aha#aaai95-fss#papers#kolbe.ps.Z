URL: http://www.aic.nrl.navy.mil:80/~aha/aaai95-fss/papers/kolbe.ps.Z
Refering-URL: http://www.aic.nrl.navy.mil:80/~aha/aaai95-fss/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fkolbejwaltherg@inferenzsysteme.informatik.th-darmstadt.de  
Title: Adaptation of Proofs for Reuse  
Author: Thomas Kolbe Christoph Walther 
Address: Alexanderstr. 10, D-64283 Darmstadt, Germany.  
Affiliation: Fachbereich Informatik, Technische Hochschule Darmstadt,  
Abstract: 1 Automated theorem provers might be improved if they are enabled to reuse previously computed proofs. Our approach for reuse is based on generalizing computed proofs by replacing function symbols with function variables. This yields a schematic proof which is instantiated subsequently for obtaining proofs of new, similar conjectures. Our reuse method, which requires no human support, demands two steps of proof adaptation, viz. solution of so-called free function variables and patching of completely instantiated proofs. We develop algorithms for solving free function variables and for computing patched proofs and demonstrate their usefulness with several examples. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Bates, J. L., and Constable, R. L. </author> <year> 1985. </year> <title> Proofs as Programs. </title> <journal> ACM Transactions on Programming Languages and Systems 7(1) </journal> <pages> 113-136. </pages>
Reference-contexts: Furthermore proofs can be worked up for planning or synthesis tasks if plans or programs should be extracted form proofs <ref> (Bates & Constable 1985) </ref>. These applications require a specific proof, i.e. it is not enough to know that some proof exists. Reconsider the proof shell P S from Figure 1.
Reference: <author> Brauburger, J. </author> <year> 1994. </year> <title> Plagiator: Design and Implementation of a Learning Prover. </title> <booktitle> Diploma Thesis (in German), TH Darmstadt. </booktitle>
Reference-contexts: Conclusion We have presented adaptation techniques for reusing previously computed proofs of conjectures for proving new, similar conjectures. We developed a heuristically controlled algorithm for solving the free variables of a partially instantiated schematic proof catch. This algorithm is implemented in our prototype of a learning prover, the Plagiator-system <ref> (Brauburger 1994) </ref>, and has proved successful for many examples. Hence we are able to verify conjectures by automatically reusing the proof of similar conjectures. As a side effect useful lemmata are speculated by our method.
Reference: <author> Ellman, T. </author> <year> 1989. </year> <title> Explanation-Based Learning: A Survey of Programs and Perspectives. </title> <journal> ACM Computing Surveys 21(2) </journal> <pages> 163-221. </pages>
Reference-contexts: Our work has similarities with the machine learning methodologies of explanation-based learning <ref> (Ellman 1989) </ref>, analogical reasoning (Hall 1989, Owen 1990), and abstraction (Plaisted 1981, Giunchiglia & Walsh 1992), cf. (Kolbe & Walther 1995d) for a detailed comparison.
Reference: <author> Giunchiglia, F., and Walsh, T. </author> <year> 1992. </year> <title> A Theory of Abstraction. </title> <booktitle> Artificial Intelligence 57 </booktitle> <pages> 323-389. </pages>
Reference: <author> Hall, R. P. </author> <year> 1989. </year> <title> Computational Approaches to Analogical Reasoning: A Comparative Analysis. </title> <booktitle> Artificial Intelligence 39 </booktitle> <pages> 39-120. </pages>
Reference-contexts: Our work has similarities with the machine learning methodologies of explanation-based learning (Ellman 1989), analogical reasoning <ref> (Hall 1989, Owen 1990) </ref>, and abstraction (Plaisted 1981, Giunchiglia & Walsh 1992), cf. (Kolbe & Walther 1995d) for a detailed comparison.
Reference: <author> Huang, X. </author> <year> 1994. </year> <title> PROVERB: A System Explaining Machine-Found Proofs. </title> <booktitle> In Proc. of 16th Annual Conference of the Cognitive Science Society. </booktitle>
Reference-contexts: | An Example Often one is not only interested in the provability of , but also in a specific proof of which can be presented to a human user or which can be processed subsequently, e.g. by translation into natural language to obtain proofs like those found in mathematical textbooks <ref> (Huang 1994) </ref>. Furthermore proofs can be worked up for planning or synthesis tasks if plans or programs should be extracted form proofs (Bates & Constable 1985). These applications require a specific proof, i.e. it is not enough to know that some proof exists.
Reference: <author> Huet, G., and Lang, B. </author> <year> 1978. </year> <title> Proving and Applying Program Transformations Expressed with Second-Order Patterns. </title> <journal> Acta Informatica 11 </journal> <pages> 31-55. </pages>
Reference-contexts: Here we develop an efficient procedure for computing solutions by second-order matching "modulo evaluation". Our algorithm incorporates the underlying axioms by heuristically combining the second-order matching algorithm of <ref> (Huet & Lang 1978) </ref> with the technique of symbolic evaluation, cf. e.g. (Walther 1994). We assume that each function symbol is either a constructor of some data structure or a defined function symbol specified by some axioms, cf. (Walther 1994). <p> Second-order matching is decidable and we can adapt the algorithm from <ref> (Huet & Lang 1978) </ref> for computing a finite set := match (t; P ) of matchers which is consistent, complete, and minimal.
Reference: <author> Kolbe, T., and Walther, C. </author> <year> 1994. </year> <title> Reusing Proofs. </title> <editor> In Cohn, A., ed., </editor> <booktitle> Proceedings of the 11th European Conference on Artificial Intelligence, </booktitle> <address> Amsterdam. </address> <publisher> John Wiley & Sons, Ltd. </publisher> <pages> 80-84. </pages>
Reference-contexts: Since this patching of proofs always succeeds, the proof p of ' is reused for proving . None of these steps necessitates human support. The analysis and generalization of proofs is described in <ref> (Kolbe & Walther 1994) </ref>, and (Kolbe & Walther 1995b) proposes an approach for proof management and retrieval. Here we illustrate the techniques for proof adaptation, viz. the solution of partially instantiated catches (Kolbe & Walther 1995c) and the patching of proofs (Kolbe & Walther 1995a). <p> (len (x); len (u)) len (app (x; u)) plus (len (add (n; x)); len (y)) len (app (add (n; x); y)): Assume that the following proof shell PS is provided which was obtained by analyzing and generalizing the proof of the step formula ' s for the conjecture ', cf. <ref> (Kolbe & Walther 1994) </ref>, where sum denotes summa tion over a linear list and 3 ' := plus (sum (x); sum (y)) sum (app (x; y)): s := 8u F 1 (G 1 (x); G 2 (u)) G 3 (H 1 (x; u)) ! C s := &gt; &lt; (1) G
Reference: <author> Kolbe, T., and Walther, C. </author> <year> 1995a. </year> <title> Patching Proofs for Reuse. </title> <editor> In Lavrac, N., and Wrobel, S., eds., </editor> <booktitle> Proc. European Conf. on Machine Learning, Heraklion, </booktitle> <volume> 303 - 306. </volume> <publisher> Springer LNAI 912. </publisher>
Reference-contexts: Here we illustrate the techniques for proof adaptation, viz. the solution of partially instantiated catches (Kolbe & Walther 1995c) and the patching of proofs <ref> (Kolbe & Walther 1995a) </ref>. Matching modulo Evaluation As the solvability of free function variables is defined w.r.t. a set of axioms, it is undecidable in general whether a solution exists, and in the positive case the solution is not unique. <p> ] := fq 2 Pos (s) j sj q = w i g return [q 1 p 1 ; :::; q 1 p k ; :::; q m p 1 ; :::; q m p k ] else return [ip 1 ; :::; ip k ] fi fi Theorem 2. <ref> (Kolbe & Walther 1995a) </ref> Let t; l; r be schematic terms, p a position in t and t a second-order substitution. <p> The test t (C) 6= t (C 0 ) in patch proof is merely an optimization to avoid redundant steps like replace (t (4)), cf. the proof P . Theorem 3. <ref> (Kolbe & Walther 1995a) </ref> Let P be a proof of the sequent H ! C from the set of hypotheses HY P , i.e. HY P ` P H ! C, where HY P , H and C (and in turn P ) may contain function variables.
Reference: <author> Kolbe, T., and Walther, C. </author> <year> 1995b. </year> <title> Proof Management and Retrieval. </title> <booktitle> In Proceedings of the IJCAI'95 Workshop on Formal Approaches to the Reuse of Plans, Proofs, and Programs, </booktitle> <address> Montreal, Canada. </address>
Reference-contexts: Since this patching of proofs always succeeds, the proof p of ' is reused for proving . None of these steps necessitates human support. The analysis and generalization of proofs is described in (Kolbe & Walther 1994), and <ref> (Kolbe & Walther 1995b) </ref> proposes an approach for proof management and retrieval. Here we illustrate the techniques for proof adaptation, viz. the solution of partially instantiated catches (Kolbe & Walther 1995c) and the patching of proofs (Kolbe & Walther 1995a).
Reference: <author> Kolbe, T., and Walther, C. </author> <year> 1995c. </year> <title> Second-Order Matching modulo Evaluation | A technique for Reusing Proofs. </title> <booktitle> In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJ-CAI'95), </booktitle> <address> Montreal, Canada. </address>
Reference-contexts: None of these steps necessitates human support. The analysis and generalization of proofs is described in (Kolbe & Walther 1994), and (Kolbe & Walther 1995b) proposes an approach for proof management and retrieval. Here we illustrate the techniques for proof adaptation, viz. the solution of partially instantiated catches <ref> (Kolbe & Walther 1995c) </ref> and the patching of proofs (Kolbe & Walther 1995a). Matching modulo Evaluation As the solvability of free function variables is defined w.r.t. a set of axioms, it is undecidable in general whether a solution exists, and in the positive case the solution is not unique. <p> We consider (the solution of) an equation with a high number of function symbols and a low number of function variables as "highly constrained", because both criteria limit the number of possible matchers, cf. <ref> (Kolbe & Walther 1995c) </ref>. The term l is evaluated by applying one or more defining axioms from AX until a term l 0 := eval (l) is obtained. <p> 0 (R) ^ 6= 0 implies 0 6 From the computed set of matchers , choose matcher selects one matcher (if is non-empty) due to the following heuristic: We prefer the "simplest" matcher solving the chosen equation l R, i.e. the number of function symbols introduced by is minimal, cf. <ref> (Kolbe & Walther 1995c) </ref>. <p> We regard the catch as unsolvable then and solve catch fails, although one can think of several alternative heuristically motivated attempts of solving the remaining function variables, cf. <ref> (Kolbe & Walther 1995c) </ref>. <p> For each i 2 f0; :::; 9g, s i denotes the step formula which is computed for the conjecture i . 9 For dealing with the step formulas s 5 ; ::: s 9 we must skolemize the (universally quantified) variable z to a new constants z, cf. <ref> (Kolbe & Walther 1995c) </ref>. (3), the induction hypothesis IH, and (4): F 1 (G 1 (D 1 (n; x)); G 2 (y)) G 3 (H 1 (D 2 (n; x); y)) F 1 (F 2 (n; G 1 (x)); G 2 (y)) G 3 (D 4 (n; H 1 (x; y)))
Reference: <author> Kolbe, T., and Walther, C. </author> <year> 1995d. </year> <title> Patching Proofs for Reuse. </title> <type> Technical Report, </type> <institution> Technische Hochschule Darmstadt. </institution>
Reference-contexts: Our work has similarities with the machine learning methodologies of explanation-based learning (Ellman 1989), analogical reasoning (Hall 1989, Owen 1990), and abstraction (Plaisted 1981, Giunchiglia & Walsh 1992), cf. <ref> (Kolbe & Walther 1995d) </ref> for a detailed comparison.
Reference: <author> Owen, S. </author> <year> 1990. </year> <title> Analogy for Automated Reasoning. </title> <publisher> Academic Press. </publisher>
Reference: <author> Plaisted, D. A. </author> <year> 1981. </year> <title> Theorem Proving with Abstraction. </title> <booktitle> Artificial Intelligence 16 </booktitle> <pages> 47-108. </pages>
Reference-contexts: Our work has similarities with the machine learning methodologies of explanation-based learning (Ellman 1989), analogical reasoning (Hall 1989, Owen 1990), and abstraction <ref> (Plaisted 1981, Giunchiglia & Walsh 1992) </ref>, cf. (Kolbe & Walther 1995d) for a detailed comparison.
Reference: <author> Protzen, M. </author> <year> 1992. </year> <title> Disproving Conjectures. </title> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction, Saratoga Springs, </booktitle> <pages> 340-354. </pages> <publisher> Springer LNAI 607. </publisher>
Reference-contexts: Hence we are interested in an early failure recognition within solve catch. This can be achieved if we try to disprove those equations in C 0 [ X which do not contain function variables by searching for a counterexample, cf. <ref> (Protzen 1992) </ref>. If we can recognize that one of these equations is unprovable, then we do not have to spent any effort in solving the remaining function variables as the reuse must fail in any case.
Reference: <author> Walsh, T. </author> <year> 1994. </year> <title> A Divergence Critic. </title> <booktitle> In Proceedings of the 12th International Conference on Automated Deduction, Nancy, France. </booktitle> <pages> 14-28. </pages> <publisher> Springer LNAI 814. </publisher>
Reference-contexts: Thus e.g. the associa tivity of plus, i.e. 7 , is computed as a proof obligation when proving s 5 by reuse. In a direct proof of the step formula s 5 such a lemma has to be generated explicitly, cf. e.g. <ref> (Walsh 1994) </ref> for examples.
Reference: <author> Walther, C. </author> <year> 1994. </year> <title> Mathematical Induction. </title> <editor> In Gab-bay, D. M.; Hogger, C. J.; and Robinson, J. A., eds., </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> volume 2. </volume> <publisher> Oxford University Press. </publisher> <pages> 127-227. </pages>
Reference-contexts: Introduction Automated theorem provers might be improved if they are enabled to reuse previously computed proofs. We investigate the reuse of proofs within the domain of automated mathematical induction <ref> (Walther 1994) </ref> where similar conjectures often have similar proofs: An induction formula IH ! IC is either a step formula or a base formula in which case IH equals true. Induction formulas are proved by modifying the induction conclusion IC using axioms until the induction hypothesis IH is applicable. <p> Induction formulas are proved by modifying the induction conclusion IC using axioms until the induction hypothesis IH is applicable. Despite this regularity the search problem of deciding when and where to apply which axiom is a main challenge in automated mathematical induction, cf. e.g. <ref> (Walther 1994) </ref>, and this search effort is what can be saved by reuse. Our work has similarities with the machine learning methodologies of explanation-based learning (Ellman 1989), analogical reasoning (Hall 1989, Owen 1990), and abstraction (Plaisted 1981, Giunchiglia & Walsh 1992), cf. (Kolbe & Walther 1995d) for a detailed comparison. <p> Since this patching of proofs always succeeds, the proof p of ' is reused for proving . None of these steps necessitates human support. The analysis and generalization of proofs is described in <ref> (Kolbe & Walther 1994) </ref>, and (Kolbe & Walther 1995b) proposes an approach for proof management and retrieval. Here we illustrate the techniques for proof adaptation, viz. the solution of partially instantiated catches (Kolbe & Walther 1995c) and the patching of proofs (Kolbe & Walther 1995a). <p> Here we develop an efficient procedure for computing solutions by second-order matching "modulo evaluation". Our algorithm incorporates the underlying axioms by heuristically combining the second-order matching algorithm of (Huet & Lang 1978) with the technique of symbolic evaluation, cf. e.g. <ref> (Walther 1994) </ref>. We assume that each function symbol is either a constructor of some data structure or a defined function symbol specified by some axioms, cf. (Walther 1994). <p> incorporates the underlying axioms by heuristically combining the second-order matching algorithm of (Huet & Lang 1978) with the technique of symbolic evaluation, cf. e.g. <ref> (Walther 1994) </ref>. We assume that each function symbol is either a constructor of some data structure or a defined function symbol specified by some axioms, cf. (Walther 1994). For instance the declaration structure empty add (number; list) : list defines a data structure for linear lists of natural numbers with the constructors empty and add. <p> (len (x); len (u)) len (app (x; u)) plus (len (add (n; x)); len (y)) len (app (add (n; x); y)): Assume that the following proof shell PS is provided which was obtained by analyzing and generalizing the proof of the step formula ' s for the conjecture ', cf. <ref> (Kolbe & Walther 1994) </ref>, where sum denotes summa tion over a linear list and 3 ' := plus (sum (x); sum (y)) sum (app (x; y)): s := 8u F 1 (G 1 (x); G 2 (u)) G 3 (H 1 (x; u)) ! C s := &gt; &lt; (1) G <p> We assume that the symbolic evaluator is implemented by a terminating operation eval which computes the normal form of a term such that AX j= l l 0 is satisfied for all terms l and a set AX of axioms, cf. <ref> (Walther 1994) </ref>. Then the second-order matching algorithm match is called for l 0 and R and all computed matchers are collected in a set .
References-found: 17

