URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1996/96-48.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1996.html
Root-URL: http://www.cs.rutgers.edu
Email: (farach@cs.rutgers.edu,  
Phone: 2  
Title: Optimal Suffix Tree Construction with Large Alphabets  
Author: by Martin Farach ; 
Note: Supported by NSF Career Development Award CCR-9501942, NATO Grant CRG 960215, NSF/NIH Grant BIR 94-12594-03-CONF and an Alfred P. Sloan Research Fellowship. DIMACS is a partnership of Rutgers University, Princeton University, AT&T Research, Bellcore, and Bell Laboratories. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Web: http://www.cs.rutgers.edu/~farach).  
Address: Piscataway, NJ 08855, USA.  
Affiliation: Rutgers University  Department of Computer Science, Rutgers University,  
Abstract: DIMACS Technical Report 96-48 October 1996 
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Thus, we have a type of radix sort problem. We need only stably sort the lexicographically sorted leaves of T o , using the key S [2i] for any odd suffix S [2i + 1]. By the correctness of radix sort <ref> [AHU74] </ref>, the even suffixes are correctly sorted. Therefore, we can get the inordering of the leaves of T e in linear time. In our example, we get the ordering [3; 1; 5; 7; 11; 9; 13] for the leaves of T o (See Figure 3.2).
Reference: [CS85] <author> M. T. Chen and J. Seiferas. </author> <title> Efficient and elegant subword tree construction. </title> <editor> In A. Apostolico and Z. Galil, editors, </editor> <booktitle> Combinatorial Algorithms on Words, chapter 12, </booktitle> <pages> pages 97-107. </pages> <institution> NATO ASI Series F: Computer and System Sciences, </institution> <year> 1985. </year>
Reference-contexts: Furthermore, Weiner [Wei73], who introduced this powerful data structure, showed that T S can be constructed in O (n) time for constant size alphabet. This construction and its analysis are nontrivial. Considerable effort has been put into producing simplified linear time suffix tree constructions <ref> [CS85, McC76] </ref>, though all such algorithms have been variants of the original approach of Weiner. The construction of suffix trees remains an active area of research [DK95, Kos94, FM96]. Several open problem remain.
Reference: [DK95] <author> A. Delcher and S. Kosaraju. </author> <title> Large-scale assembly of dna strings and space-efficient construction of suffix trees. </title> <booktitle> Proc. of the 27th Ann. ACM Symp. on Theory of Computing, </booktitle> <year> 1995. </year>
Reference-contexts: This construction and its analysis are nontrivial. Considerable effort has been put into producing simplified linear time suffix tree constructions [CS85, McC76], though all such algorithms have been variants of the original approach of Weiner. The construction of suffix trees remains an active area of research <ref> [DK95, Kos94, FM96] </ref>. Several open problem remain. The most important of these has to do with the size of the alphabet and its effect on the time needed to build suffix trees. <p> If we replace each character by its rank in the sorted list, we get an equivalent integer alphabet in the range [1; n]. In this case, there is no non-trivial lower bound. However, the best upper bound known is the straightforward O (n log n). Note that in <ref> [DK95] </ref>, Delcher and Kosaraju claimed a linear time algorithm for this problem, but this algorithm turned out to have a bug in it, as they noted in [DK96], where they also posed closing the log gap in the complexity of suffix tree construction for the linear alphabet case as an important
Reference: [DK96] <author> A. Delcher and S. Kosaraju. </author> <title> Large-scale assembly of dna strings and space-efficient construction of suffix tesre (correctioes. </title> <booktitle> Proc. of the 28th Ann. ACM Symp. on Theory of Computing, </booktitle> <year> 1996. </year>
Reference-contexts: However, the best upper bound known is the straightforward O (n log n). Note that in [DK95], Delcher and Kosaraju claimed a linear time algorithm for this problem, but this algorithm turned out to have a bug in it, as they noted in <ref> [DK96] </ref>, where they also posed closing the log gap in the complexity of suffix tree construction for the linear alphabet case as an important and difficult open problem.
Reference: [FM96] <author> M. Farach and S. Muthukrishnan. </author> <title> Optimal logarithmic time randomized suffix tree construction. </title> <booktitle> Proc. of 23rd International Colloquium on Automata Languages and Programming, </booktitle> <year> 1996. </year>
Reference-contexts: This construction and its analysis are nontrivial. Considerable effort has been put into producing simplified linear time suffix tree constructions [CS85, McC76], though all such algorithms have been variants of the original approach of Weiner. The construction of suffix trees remains an active area of research <ref> [DK95, Kos94, FM96] </ref>. Several open problem remain. The most important of these has to do with the size of the alphabet and its effect on the time needed to build suffix trees. <p> We must therefore exploit structural properties of suffix trees to perform this step in O (n) time. This step does not rely on sorting, and so it works on odd and even trees over an arbitrary alphabet. While a similar approach was taken in <ref> [FM96] </ref>, the algorithm in that paper relied heavily on randomization and only works for binary alphabets. <p> Then it is a straightforward exercise to reconstruct the tree in linear time. Similarly, suppose we are given the inorder traversal of the leaves of a compacted trie, and the length of the longest common prefix of adjacent leaves. Then we can reconstruct the trie in linear time <ref> [FM96] </ref>. We derive these two pieces of information for the even tree from the odd tree. First, consider the inordering. The inordering of the leaves of a trie is simply the lexicographic ordering of the strings of the trie.
Reference: [HT84] <author> D. Harel and R.E. Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: exploited algorithmically is the following relationship between lcp in S and lca in T S . 8v; w 2 T S ; lcp ((v); (w)) = j (lca (v; w))j: The nice thing about this equality is that least common ancestors can be computed in constant time after linear preprocessing <ref> [HT84] </ref>. Thus arbitrary substring equality can be tested in constant time after a linear preprocessing of a string, as long as the suffix tree can be built in linear time. Outline: As noted above, a suffix tree is the compacted trie of the suffixes of a string. <p> The depth of every node in the d tree is determined in linear time by DFS. The only other step is the computation of least common ancestors, which, as noted above, requires linear processing and constant time queries <ref> [HT84] </ref>.
Reference: [Kos94] <author> S. Kosaraju. </author> <title> Real-time suffix tree construction. </title> <booktitle> Proc. of the 26th Ann. ACM Symp. on Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: This construction and its analysis are nontrivial. Considerable effort has been put into producing simplified linear time suffix tree constructions [CS85, McC76], though all such algorithms have been variants of the original approach of Weiner. The construction of suffix trees remains an active area of research <ref> [DK95, Kos94, FM96] </ref>. Several open problem remain. The most important of these has to do with the size of the alphabet and its effect on the time needed to build suffix trees.
Reference: [McC76] <author> E. M. McCreight. </author> <title> A space-economical suffix tree construction algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 262-272, </pages> <year> 1976. </year>
Reference-contexts: Furthermore, Weiner [Wei73], who introduced this powerful data structure, showed that T S can be constructed in O (n) time for constant size alphabet. This construction and its analysis are nontrivial. Considerable effort has been put into producing simplified linear time suffix tree constructions <ref> [CS85, McC76] </ref>, though all such algorithms have been variants of the original approach of Weiner. The construction of suffix trees remains an active area of research [DK95, Kos94, FM96]. Several open problem remain.
Reference: [Wei73] <author> P. Weiner. </author> <title> Linear pattern matching algorithm. </title> <booktitle> Proc. 14 IEEE Symposium on Switching and Automata Theory, </booktitle> <pages> pages 1-11, </pages> <year> 1973. </year>
Reference-contexts: For many reasons, this is the fundamental data structure in combinatorial pattern matching. It has a compact O (n) space representation which has many elegant uses. Furthermore, Weiner <ref> [Wei73] </ref>, who introduced this powerful data structure, showed that T S can be constructed in O (n) time for constant size alphabet. This construction and its analysis are nontrivial.
References-found: 9

