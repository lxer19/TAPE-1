URL: http://www.cs.ucsd.edu/users/goguen/ps/orlando96.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: Parameterized Programming and Software Architecture  
Author: Joseph A. Goguen 
Address: San Diego  
Affiliation: University of California,  
Abstract: This paper discusses an approach to software architecture based on concepts from parameterized programming, particularly its language of "module expressions." A module expression describes the architecture of a system as an interconnection of component modules, and executing the expression actually builds the system. Language features include: modules parameterized by theories, which declare interfaces; a number of module composition operations; views for binding modules to interfaces; and both vertical and horizontal composition. Modules may involve information hiding, theories may declare semantic restrictions with axioms, and views assert behavioral satisfaction of axioms by a module. Some "laws of software composition" are given, showing how various module composition operations are related. We also show how a variety of architectural styles can be supported, and how this approach can be extended to support evolution and traceability. All this is intended to ease the development of large systems, and in particular, to make reuse more effective in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <type> Technical Report TR-91-22, </type> <institution> Department of Computer Sciences, University of Texas, Austin, </institution> <year> 1991. </year> <month> Revised May </month> <year> 1992. </year>
Reference-contexts: See <ref> [1] </ref> for some related work. The make command "executes" a module expression to actually build a (sub)system, give it a name, and store it in the environment.
Reference: [2] <author> Barry Boehm and William Scherlis. Megapro-gramming. </author> <booktitle> In Proceedings of Software Technology Conference 1992, </booktitle> <pages> pages 63-82, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: clusters, where * specifications are headers for each cluster, and * one or more implementations may be given for each package specification, including source code, and compiled code, * plus (optionally) test cases, performance data, documentation, 2 The term megaprogramming is used for some similar ideas within the ARPA community <ref> [2, 27] </ref>. 3 The module graph is an abstraction of this organization.
Reference: [3] <author> Rod Burstall and Joseph Goguen. </author> <title> Putting theories together to make specifications. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> Proceedings, Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1045-1058. </pages> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1977. </year>
Reference-contexts: In such cases, systems like lileanna seem able to save a great deal of software development time, although significant initial investment may be needed to accumulate information for the library. lileanna has a formal semantics based on category theory, following ideas developed for the Clear specification language <ref> [3, 4] </ref>; more recently, a set theoretic semantics has been given [15]. These semantics are very general, and apply to languages other than Ada and Anna, and indeed, to any implementation-specification language pair that satisfies certain axioms.
Reference: [4] <author> Rod Burstall and Joseph Goguen. </author> <title> The semantics of Clear, a specification language. </title> <editor> In Dines Bjorner, editor, </editor> <booktitle> Proceedings, 1979 Copenhagen Winter School on Abstract Software Specification, </booktitle> <pages> pages 292-332. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <note> LNCS 86. </note>
Reference-contexts: In such cases, systems like lileanna seem able to save a great deal of software development time, although significant initial investment may be needed to accumulate information for the library. lileanna has a formal semantics based on category theory, following ideas developed for the Clear specification language <ref> [3, 4] </ref>; more recently, a set theoretic semantics has been given [15]. These semantics are very general, and apply to languages other than Ada and Anna, and indeed, to any implementation-specification language pair that satisfies certain axioms. <p> Module expressions were first implemented in the OBJ system [16], but using different techniques, because there is no attached code in a separate programming language. The mathematical semantics of module expression evaluation is given by the colimit of a diagram extracted from the module graph <ref> [4] </ref>, or by a simpler set theoretic semantics [15]. lileanna provides a graphical "layout editor" [18] for module expressions, based on notation like that typically used by engineers, i.e., boxes and arrows.
Reference: [5] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architectures. </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <address> I:41-49, </address> <year> 1993. </year>
Reference-contexts: This helps users to edit existing module expressions to define new (sub)systems, or define them from scratch, as they wish. 4.1 Architectural Styles Many different architectural styles <ref> [5] </ref> can be supported by parameterized programming, including different communication styles, such as shared variables, pipelining, message passing, and blackboarding.
Reference: [6] <author> Joseph Goguen. </author> <title> Suggestions for using and organizing libraries in software development. </title> <editor> In Kar-tashev and Kartashev, editors, </editor> <booktitle> Proceedings, First International Conference on Supercomputing Systems, </booktitle> <pages> pages 349-360. </pages> <publisher> IEEE, </publisher> <year> 1985. </year> <note> Also in Supercomputing Systems, </note> <editor> Kartashev and Kartashev, editors, </editor> <publisher> Elsevier, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction This paper presents an approach to software architecture based on concepts from parameterized programming. Parameterized programming <ref> [6, 7] </ref> focuses on design and module composition times, rather than on compile or run times; that is, it addresses the architectural level of software. It supports system generation, software reuse, and controlled evolution, as well as the management of configurations, versions, families, documentation, etc. <p> The properties of an interconnection of modules are related in a straightforward way to those of its components, through the semantics of module expressions. The work reported in this paper is based on ideas developed in 1983, and first reported in <ref> [6] </ref>, which suggested a design for lil, a library interconnection language for Ada; see also [7]. 1.1 What is Architecture? The term "architecture" has been much discussed in recent literature, and there is now a large family of partially overlapping definitions.
Reference: [7] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Biggerstaff and Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper presents an approach to software architecture based on concepts from parameterized programming. Parameterized programming <ref> [6, 7] </ref> focuses on design and module composition times, rather than on compile or run times; that is, it addresses the architectural level of software. It supports system generation, software reuse, and controlled evolution, as well as the management of configurations, versions, families, documentation, etc. <p> The work reported in this paper is based on ideas developed in 1983, and first reported in [6], which suggested a design for lil, a library interconnection language for Ada; see also <ref> [7] </ref>. 1.1 What is Architecture? The term "architecture" has been much discussed in recent literature, and there is now a large family of partially overlapping definitions. <p> Default views are computed using a certain set of default rules that are given in <ref> [7] </ref>, and that capture many of our intuitions about what is "obvious." The following are some instantiations that use default views: STACK [Integer] STACK [LIST [Integer]] STACK [STACK [Float]] . (Default views were first implemented in OBJ3 [16], and are partially implemented in lileanna.) An interface theory can call for more
Reference: [8] <author> Joseph Goguen. Hyperprogramming: </author> <title> A formal approach to software environments. </title> <booktitle> In Proceedings, Symposium on Formal Approaches to Software Environment Technology. Joint System Development Corporation, </booktitle> <address> Tokyo, Japan, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Package specifications are intended to have associated executable code. Theory specifications are not, as discussed in the next subsection. Other software objects that maybe be associated with nodes or edges are also discussed below. Module graphs are based on ideas from what we call hyperprogramming <ref> [8] </ref>.
Reference: [9] <author> Joseph Goguen. </author> <title> Requirements engineering as the reconciliation of social and technical issues. </title> <editor> In Jirotka and Goguen, editors, </editor> <booktitle> Requirements Engineering: Social and Technical Issues, </booktitle> <pages> pages 165-200. </pages> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: Work on capturing domain knowledge has used methods from sociology, particularly ethnomethodology and its disciplines of conversastion and interaction analyses. Further information on this research may be found in <ref> [9, 10, 12] </ref>. We are also developing a system called toor to support tracing dependencies among evolving objects, and in particular, to show how decisions are grounded in prior objects [23]. <p> This approach, called hyper-requirements, builds on parameterized programming and hyperprogrammming, and is intended to support the social context of decisions, as well as their traceability, by linking related objects, based on the broad view of context and requirements suggested in <ref> [9] </ref>. toor supports user-definable relations, to allow differentiating among different links between the same objects.
Reference: [10] <author> Joseph Goguen. </author> <title> Formality and informality in requirements engineering. </title> <booktitle> Proceedings, International Conference on Requirements Engineering, to appear, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The word "evolution" focuses attention on change, which is inevitable and unending in software development. Moreover, since large complex systems are inevitably embedded in complex evolving social contexts, they will necessarily co-evolve with those contexts, in the sense that each will affect the evolu-tion of the other. (See <ref> [10, 12] </ref> for further discussion of evolution and social context.) The ubiquity of change motivates the use of iterative lifecycle processes, and especially prototyping, i.e., quickly building and evaluating a series of prototypes, which are concrete executable models of selected aspects of a system [21]. <p> Work on capturing domain knowledge has used methods from sociology, particularly ethnomethodology and its disciplines of conversastion and interaction analyses. Further information on this research may be found in <ref> [9, 10, 12] </ref>. We are also developing a system called toor to support tracing dependencies among evolving objects, and in particular, to show how decisions are grounded in prior objects [23].
Reference: [11] <author> Joseph Goguen and Rod Burstall. </author> <title> CAT, a system for the structured elaboration of correct programs from structured specifications. </title> <type> Technical Report Report CSL-118, </type> <institution> SRI Computer Science Lab, </institution> <month> Oc-tober </month> <year> 1980. </year>
Reference-contexts: Multiple views are needed to instantiate such modules. 3.2 Vertical Composition Vertical structure describes the use of lower layers (virtual machines), whereas horizontal structure describes a given layer; the distinction between vertical and horizontal structure was named and formalized by Goguen and Burstall <ref> [11] </ref>; this provides direct support for layered architectural styles. Parameterized programming provides parameterization and instanti-ation for both vertical and horizontal structure.
Reference: [12] <author> Joseph Goguen and Luqi. </author> <title> Formal methods and social context in software development. </title> <editor> In Mosses, Nielsen, and Schwartzbach, editors, </editor> <booktitle> Proceedings, TAPSOFT 95, </booktitle> <pages> pages 62-81. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <note> LNCS 915. </note>
Reference-contexts: The word "evolution" focuses attention on change, which is inevitable and unending in software development. Moreover, since large complex systems are inevitably embedded in complex evolving social contexts, they will necessarily co-evolve with those contexts, in the sense that each will affect the evolu-tion of the other. (See <ref> [10, 12] </ref> for further discussion of evolution and social context.) The ubiquity of change motivates the use of iterative lifecycle processes, and especially prototyping, i.e., quickly building and evaluating a series of prototypes, which are concrete executable models of selected aspects of a system [21]. <p> Work on capturing domain knowledge has used methods from sociology, particularly ethnomethodology and its disciplines of conversastion and interaction analyses. Further information on this research may be found in <ref> [9, 10, 12] </ref>. We are also developing a system called toor to support tracing dependencies among evolving objects, and in particular, to show how decisions are grounded in prior objects [23].
Reference: [13] <author> Joseph Goguen and Grant Malcolm. </author> <title> Proof of correctness of object representation. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Hon-our of C.A.R. Hoare, </booktitle> <pages> pages 119-142. </pages> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: how the system is composed from lower level modules; see Section 4) from a theory with axioms giving the properties 4 This means that the axioms need only appear to hold under all possible "experiments" on the module, involving its externally visible operations; sometimes this is also called observational satisfaction <ref> [13] </ref>. to be asserted.
Reference: [14] <author> Joseph Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming, with logical semantics. </title> <editor> In Shriver and Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT, </publisher> <year> 1987. </year>
Reference-contexts: Hyperprogramming and hyperrequirements support reuse, through the generalized notion of relation for linking objects for requirements, design, specification, coding, documentation, etc. toor is built on foops <ref> [14, 24] </ref>, a general object oriented language with specification capabilities.
Reference: [15] <author> Joseph Goguen and Will Tracz. </author> <title> An implementation-oriented semantics for module composition. </title> <note> In preparation. </note>
Reference-contexts: to save a great deal of software development time, although significant initial investment may be needed to accumulate information for the library. lileanna has a formal semantics based on category theory, following ideas developed for the Clear specification language [3, 4]; more recently, a set theoretic semantics has been given <ref> [15] </ref>. These semantics are very general, and apply to languages other than Ada and Anna, and indeed, to any implementation-specification language pair that satisfies certain axioms. The properties of an interconnection of modules are related in a straightforward way to those of its components, through the semantics of module expressions. <p> The mathematical semantics of module expression evaluation is given by the colimit of a diagram extracted from the module graph [4], or by a simpler set theoretic semantics <ref> [15] </ref>. lileanna provides a graphical "layout editor" [18] for module expressions, based on notation like that typically used by engineers, i.e., boxes and arrows. <p> There are many more laws, e.g., for parameterization; see <ref> [15] </ref> for these, as well as for proofs. These laws are used in the implementation of lileanna for simplifying module expressions. 5 Evolution and Traceability A traditional view in software engineering is that evolution only occurs after initial development is complete.
Reference: [16] <author> Joseph Goguen, Timothy Winkler, Jose Mese--guer, Kokichi Futatsugi and Jean-Pierre Jouan-naud. </author> <title> Introducing OBJ. In Goguen and Malcolm, editors, Algebraic Specification with OBJ. </title> <journal> Cam-bridge, </journal> <note> to appear. </note>
Reference-contexts: are computed using a certain set of default rules that are given in [7], and that capture many of our intuitions about what is "obvious." The following are some instantiations that use default views: STACK [Integer] STACK [LIST [Integer]] STACK [STACK [Float]] . (Default views were first implemented in OBJ3 <ref> [16] </ref>, and are partially implemented in lileanna.) An interface theory can call for more than one operation and/or more than one type, and views can express bindings to such interfaces. Generic modules can be parameterized by more than one interface, each defined by its own theory. <p> One also gets the benefit of being able to put the manipulated code through the compiler's backend, including optimization. Module expressions were first implemented in the OBJ system <ref> [16] </ref>, but using different techniques, because there is no attached code in a separate programming language.
Reference: [17] <author> Orlena Gotel. </author> <title> Requirements traceability. </title> <type> Technical report, </type> <institution> Centre for Requirements and Foundations, Oxford University Computing Lab, </institution> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: An initial study <ref> [17] </ref> administered a detailed two-stage questionnaire to software engineers at a large firm, and found that traceability was considered the most important outstanding problem. Further analysis showed that there are actually several different traceability problems, which should be treated in different ways.
Reference: [18] <author> J.T. Higgins. </author> <title> ADAGE layout editor user's manual. </title> <type> Technical Report ADAGE-LOR-94-04, </type> <institution> Loral Federal Systems Owego, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: The mathematical semantics of module expression evaluation is given by the colimit of a diagram extracted from the module graph [4], or by a simpler set theoretic semantics [15]. lileanna provides a graphical "layout editor" <ref> [18] </ref> for module expressions, based on notation like that typically used by engineers, i.e., boxes and arrows.
Reference: [19] <author> Bernd Krieg-Bruckner and David Luckham. anna: </author> <title> Towards a language for annotating Ada programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 15(11) </volume> <pages> 128-138, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: Executing a module expression in the presence of a suitable module graph yields an executable system, constructed by manipulating and linking the implementation modules. The parameterized programming approach to software architecture has been validated by experience with lileanna [25, 26], an MCL using Ada for implementation and Anna <ref> [19, 20] </ref> for specification. lileanna was developed as part of the dssa adage project sponsored by arpa. The implementation was done by Will Tracz of Loral Federal Systems, and has been used for helicoptor navigation software.
Reference: [20] <author> David Luckham. </author> <title> Programming with Specifications: An Introduction to anna, A Language for Annotating Ada Programs. </title> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: Executing a module expression in the presence of a suitable module graph yields an executable system, constructed by manipulating and linking the implementation modules. The parameterized programming approach to software architecture has been validated by experience with lileanna [25, 26], an MCL using Ada for implementation and Anna <ref> [19, 20] </ref> for specification. lileanna was developed as part of the dssa adage project sponsored by arpa. The implementation was done by Will Tracz of Loral Federal Systems, and has been used for helicoptor navigation software.
Reference: [21] <author> Luqi. </author> <title> Software evolution through rapid prototyp-ing. </title> <journal> IEEE Computer, </journal> <volume> 22(5) </volume> <pages> 13-25, </pages> <year> 1989. </year>
Reference-contexts: the evolu-tion of the other. (See [10, 12] for further discussion of evolution and social context.) The ubiquity of change motivates the use of iterative lifecycle processes, and especially prototyping, i.e., quickly building and evaluating a series of prototypes, which are concrete executable models of selected aspects of a system <ref> [21] </ref>. The ability of parameterized programming to describe software architectures, in both the domain and systems senses, can greatly facilitate prototyping. In some cases, all that need be done is edit a module expression.
Reference: [22] <author> Luqi and Joseph Goguen. </author> <title> Formal methods: Problems and promises. </title> <journal> IEEE Software, </journal> <note> to appear, </note> <month> July </month> <year> 1996. </year>
Reference-contexts: A hypergraph model for maintaining evolving dependencies, suitable as a basis for tool development, is given in <ref> [22] </ref>; this structure can be applied to give a model for evolving module graphs. Work on capturing domain knowledge has used methods from sociology, particularly ethnomethodology and its disciplines of conversastion and interaction analyses. Further information on this research may be found in [9, 10, 12].
Reference: [23] <author> Francisco Pinheiro and Joseph Goguen. </author> <title> An object-oriented tool for tracing requirements. </title> <journal> IEEE Software, </journal> <note> to appear, </note> <month> March </month> <year> 1996. </year> <note> Special issue of papers from ICRE '96. </note>
Reference-contexts: Further information on this research may be found in [9, 10, 12]. We are also developing a system called toor to support tracing dependencies among evolving objects, and in particular, to show how decisions are grounded in prior objects <ref> [23] </ref>.
Reference: [24] <author> Adolfo Socorro. </author> <title> Design, Implementation, and Evaluation of a Declarative Object Oriented Language. </title> <type> DPhil thesis, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1994. </year>
Reference-contexts: Hyperprogramming and hyperrequirements support reuse, through the generalized notion of relation for linking objects for requirements, design, specification, coding, documentation, etc. toor is built on foops <ref> [14, 24] </ref>, a general object oriented language with specification capabilities.
Reference: [25] <author> Will Tracz. </author> <title> Parameterized programming in lileanna. </title> <booktitle> In Proceedings, Second International Workshop on Software Reuse, </booktitle> <month> March </month> <year> 1993. </year> <pages> Lucca, </pages> <address> Italy. </address>
Reference-contexts: Executing a module expression in the presence of a suitable module graph yields an executable system, constructed by manipulating and linking the implementation modules. The parameterized programming approach to software architecture has been validated by experience with lileanna <ref> [25, 26] </ref>, an MCL using Ada for implementation and Anna [19, 20] for specification. lileanna was developed as part of the dssa adage project sponsored by arpa. The implementation was done by Will Tracz of Loral Federal Systems, and has been used for helicoptor navigation software.
Reference: [26] <author> Will Tracz, P. Angeline, S. Shafer and Lou Coglianese. </author> <title> Experience using an avionics domain-specific software architecture. </title> <booktitle> In Proceedings, naecon'95, </booktitle> <pages> pages 646-653, </pages> <month> May 22-27 </month> <year> 1995. </year>
Reference-contexts: Executing a module expression in the presence of a suitable module graph yields an executable system, constructed by manipulating and linking the implementation modules. The parameterized programming approach to software architecture has been validated by experience with lileanna <ref> [25, 26] </ref>, an MCL using Ada for implementation and Anna [19, 20] for specification. lileanna was developed as part of the dssa adage project sponsored by arpa. The implementation was done by Will Tracz of Loral Federal Systems, and has been used for helicoptor navigation software.
Reference: [27] <author> Gio Wiederhold, Peter Wegner, and Stefano Ceri. </author> <title> Toward megaprogramming. </title> <journal> Communications of the ACM, </journal> <volume> 35(11) </volume> <pages> 89-99, </pages> <year> 1992. </year>
Reference-contexts: clusters, where * specifications are headers for each cluster, and * one or more implementations may be given for each package specification, including source code, and compiled code, * plus (optionally) test cases, performance data, documentation, 2 The term megaprogramming is used for some similar ideas within the ARPA community <ref> [2, 27] </ref>. 3 The module graph is an abstraction of this organization.
References-found: 27

