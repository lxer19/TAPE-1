URL: http://www.cs.berkeley.edu/~aiken/ftp/pal.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: email: aiken@cs.berkeley.edu  email: williams@almaden.ibm.com  email: wimmers@almaden.ibm.com  
Title: Programming a Language  
Author: Alexander Aiken John H. Williams Edward L. Wimmers 
Address: Berkeley, CA 94720-1776  650 Harry Rd. San Jose, CA 95120  650 Harry Rd. San Jose, CA 95120  
Affiliation: Computer Science Division University of California, Berkeley  IBM Almaden Research Center  IBM Almaden Research Center  
Abstract: We explore a simple approach to incorporating new language features into a functional language. New features are realized simply by redefining the meanings of primitive functions. That is, the programming language is not modified at all; rather, new features are just programmed within the existing language. Surprisingly, in a combinator-based functional language the class of language features that can be expressed this way is very large; a theorem is presented characterizing this class. Examples are given which illustrate how features are implemented using this approach and which describe practical experience with the technique in a compiler for a functional language.
Abstract-found: 1
Intro-found: 1
Reference: [AWW90] <author> A. Aiken, J. H. Williams, and E. L. Wimmers. </author> <title> Program transformation in the presence of errors. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 210-217, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language <ref> [WW88, AWW90] </ref>, to new type systems [Laf88, Wad90b], to mixed imperative/functional languages [Ode91, SRI91]. The common view shared by these proposals is that some change to the basic functional language is required.
Reference: [Bac78] <author> J. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: All of this is done within the context of a pure functional language. Section 6 concludes with a summary and discussion of related work. 2 A Combinator Language FL [BWW + 89] is a combinator-based functional language based on FP <ref> [Bac78] </ref>. FL is higher-order, dynamically typed, and strict. This section presents the syntax and semantics of MiniFL, a subset of the full FL language.
Reference: [BEJ88] <editor> D. Bjtrner, A. P. Ershov, and N. D. Jones, editors. </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: That is, the meaning of EPF where EPF was computed to reduce all expressions in EPF to normal form and thereby improve the performance of EPF: This optimization is very similar in spirit to partial evaluation <ref> [BEJ88] </ref>, but note that there is no program analysis involved. The compiler simply evaluates any expression that is not in normal form. Compile time evaluation of EPF; combined with other optimizations in the FL compiler, was sufficient to make a dramatic difference in performance.
Reference: [BWW + 89] <author> J. Backus, J. H. Williams, E. L. Wimmers, P. Lucas, and A. Aiken. </author> <title> The FL language manual parts 1 and 2. </title> <type> Technical Report RJ 7100 (67163), </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: However, a combinator-based functional language (such as FL <ref> [BWW + 89] </ref>) can have this property, since all functions are built using primitive combinators, each of which can be redefined within the language. <p> Section 5 presents an extended example and discusses practical experience with the technique. All of this is done within the context of a pure functional language. Section 6 concludes with a summary and discussion of related work. 2 A Combinator Language FL <ref> [BWW + 89] </ref> is a combinator-based functional language based on FP [Bac78]. FL is higher-order, dynamically typed, and strict. This section presents the syntax and semantics of MiniFL, a subset of the full FL language.
Reference: [Fel90] <author> M. Felleisen. </author> <title> On the expressive power of programming languages. </title> <booktitle> In Proceedings of the 1990 European Symposium on Programming, </booktitle> <pages> pages 134-151. </pages> <publisher> Springer Verlag Lecture Notes in Computer Science no. </publisher> <address> 432, </address> <year> 1990. </year> <month> 18 </month>
Reference-contexts: The designers of functional languages have tended to opt for simplicity, in the hope that a clean design and the ability to write higher-order functions compensate for the lack of multiple special purpose features [Hug89]. However, functional programs can be much less convenient to modify than imperative programs <ref> [Fel90, Rie91] </ref>. For example, suppose one wished to add a counter to a function written in a functional language. If state|or some similar feature|were available in the language, very little programming would be required.
Reference: [HS86] <author> J. R. Hindley and J. P. Seldin. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: If f is a function name, then in many functional languages lambda abstraction can be used to create a new, parameterized program f:(fffig). To do the same thing in a combinator language, we can perform combinatorial abstraction <ref> [HS86] </ref>. While this is straightforward, it results in a completely restructured program. For example, the program f:(f ffi g) becomes apply ffi cons: hK: ffi; cons: hid; K: gii (assuming g does not depend on 5 f ).
Reference: [Hug89] <author> J. Hughes. </author> <title> Why functional programming matters. </title> <journal> The Computer Journal, </journal> <volume> 32(2) </volume> <pages> 99-107, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The designers of functional languages have tended to opt for simplicity, in the hope that a clean design and the ability to write higher-order functions compensate for the lack of multiple special purpose features <ref> [Hug89] </ref>. However, functional programs can be much less convenient to modify than imperative programs [Fel90, Rie91]. For example, suppose one wished to add a counter to a function written in a functional language. If state|or some similar feature|were available in the language, very little programming would be required.
Reference: [HWA + 88] <author> P. Hudak, P. Wadler, Arvind, B. Boutel, J. Fairbairn, J. Fasel, J. Hughes, T. Johnsson, D. Kieburtz, S. P. Jones, R. Nikhil, M. Reeve, D. Wise, and J. Young. </author> <title> Report on the functional programming language Haskell. </title> <type> Technical Report DCS/RR-666, </type> <institution> Yale University, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems [Laf88, Wad90b] and mixed imperative/functional languages [Ode91, SRI91]. More recently, Wadler has proposed another approach based on monads [Wad90a]. Briefly, Wadler augments the functional language Haskell <ref> [HWA + 88] </ref> with new syntax that specifies a monad in which the text of the program should be interpreted; monads are powerful enough to express many useful features (e.g., state and exceptions).
Reference: [Laf88] <author> Y. Lafont. </author> <title> The linear abstract machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 157-180, </pages> <year> 1988. </year>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language [WW88, AWW90], to new type systems <ref> [Laf88, Wad90b] </ref>, to mixed imperative/functional languages [Ode91, SRI91]. The common view shared by these proposals is that some change to the basic functional language is required. <p> They show how to use lists and abstract data types to realize exceptions in a lazy language. Our work is a natural generalization of these examples. A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems <ref> [Laf88, Wad90b] </ref> and mixed imperative/functional languages [Ode91, SRI91]. More recently, Wadler has proposed another approach based on monads [Wad90a].
Reference: [Ode91] <author> M. Odersky. </author> <title> How to make destructive updates less destructive. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language [WW88, AWW90], to new type systems [Laf88, Wad90b], to mixed imperative/functional languages <ref> [Ode91, SRI91] </ref>. The common view shared by these proposals is that some change to the basic functional language is required. There is a simpler approach: using the power of a functional language to implement desired language features as programs written in the functional language itself. <p> Our work is a natural generalization of these examples. A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems [Laf88, Wad90b] and mixed imperative/functional languages <ref> [Ode91, SRI91] </ref>. More recently, Wadler has proposed another approach based on monads [Wad90a].
Reference: [PJW93] <author> S. L. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: This approach has been used to good effect in a compiler for Haskell <ref> [PJW93] </ref>, where, in fact, the features are programmed directly within Haskell rather than in an exotic syntax. 17 Using environments to implement non-standard semantics is not a new way of structuring soft-ware in FL.
Reference: [Rie91] <author> J. G. Riecke. </author> <title> Fully abstract translations between functional languages. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 245-254, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The designers of functional languages have tended to opt for simplicity, in the hope that a clean design and the ability to write higher-order functions compensate for the lack of multiple special purpose features [Hug89]. However, functional programs can be much less convenient to modify than imperative programs <ref> [Fel90, Rie91] </ref>. For example, suppose one wished to add a counter to a function written in a functional language. If state|or some similar feature|were available in the language, very little programming would be required.
Reference: [Spi90] <author> M. Spivey. </author> <title> A functional theory of exceptions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 25-42, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In the current compiler it is estimated that only about 1% of total compilation time is spent evaluating expressions. 6 Related Work and Conclusions Several researchers have considered the problem of adding features to functional languages. Wadler [Wad85] and Spivey <ref> [Spi90] </ref> are the closest to our approach in spirit. They show how to use lists and abstract data types to realize exceptions in a lazy language. Our work is a natural generalization of these examples.
Reference: [SRI91] <author> V. Swarup, U. S. Reddy, and E. Ireland. </author> <title> Assignments for applicative languages. </title> <booktitle> In Proceedings of the 1991 Symposium on Functional Programming and Computer Architecture, </booktitle> <pages> pages 192-214, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language [WW88, AWW90], to new type systems [Laf88, Wad90b], to mixed imperative/functional languages <ref> [Ode91, SRI91] </ref>. The common view shared by these proposals is that some change to the basic functional language is required. There is a simpler approach: using the power of a functional language to implement desired language features as programs written in the functional language itself. <p> Our work is a natural generalization of these examples. A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems [Laf88, Wad90b] and mixed imperative/functional languages <ref> [Ode91, SRI91] </ref>. More recently, Wadler has proposed another approach based on monads [Wad90a].
Reference: [Wad85] <author> P. Wadler. </author> <title> How to replace failure by a list of successes. </title> <booktitle> In Proceedings of the Second International Conference on Functional Programming Languages and Computer Architecture. Springer Verlag Lecture Notes in Computer Science no. </booktitle> <volume> 201, </volume> <year> 1985. </year>
Reference-contexts: In the current compiler it is estimated that only about 1% of total compilation time is spent evaluating expressions. 6 Related Work and Conclusions Several researchers have considered the problem of adding features to functional languages. Wadler <ref> [Wad85] </ref> and Spivey [Spi90] are the closest to our approach in spirit. They show how to use lists and abstract data types to realize exceptions in a lazy language. Our work is a natural generalization of these examples.
Reference: [Wad90a] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: However, because no state can be associated with a pure function, it would probably be necessary to modify not just the one function, but also every function that depends, directly or indirectly, on that particular function <ref> [Wad90a] </ref>. 1 Recently there have been several proposals to incorporate features of conventional languages in functional languages in a way that preserves clean functional semantics as much as possible. <p> There is a simpler approach: using the power of a functional language to implement desired language features as programs written in the functional language itself. A well developed example of this approach is the monadic style of programming <ref> [Wad90a] </ref>. Using monads as a structuring device for programs, a large class of language features can be implemented within a functional language, including state and continuations, among others. This paper investigates a different, and more general, paradigm for structuring software, based on the ability to redefine functions. <p> A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems [Laf88, Wad90b] and mixed imperative/functional languages [Ode91, SRI91]. More recently, Wadler has proposed another approach based on monads <ref> [Wad90a] </ref>. Briefly, Wadler augments the functional language Haskell [HWA + 88] with new syntax that specifies a monad in which the text of the program should be interpreted; monads are powerful enough to express many useful features (e.g., state and exceptions).
Reference: [Wad90b] <author> P. Wadler. </author> <title> Linear types can change the world! In M. </title> <editor> Broy and C. B. Jones, editors, </editor> <booktitle> Programming Concepts and Methods. </booktitle> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language [WW88, AWW90], to new type systems <ref> [Laf88, Wad90b] </ref>, to mixed imperative/functional languages [Ode91, SRI91]. The common view shared by these proposals is that some change to the basic functional language is required. <p> They show how to use lists and abstract data types to realize exceptions in a lazy language. Our work is a natural generalization of these examples. A number of efforts have focussed on adding state to a functional language in a particular way. These approaches include new type systems <ref> [Laf88, Wad90b] </ref> and mixed imperative/functional languages [Ode91, SRI91]. More recently, Wadler has proposed another approach based on monads [Wad90a].
Reference: [WW88] <author> J. H. Williams and E. L. Wimmers. </author> <title> Sacrificing simplicity for convenience: </title> <booktitle> Where do you draw the line? In Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 169-179, </pages> <month> January </month> <year> 1988. </year> <month> 19 </month>
Reference-contexts: The proposed mechanisms are diverse, ranging from adding special primitive functions to a language <ref> [WW88, AWW90] </ref>, to new type systems [Laf88, Wad90b], to mixed imperative/functional languages [Ode91, SRI91]. The common view shared by these proposals is that some change to the basic functional language is required.
References-found: 18

