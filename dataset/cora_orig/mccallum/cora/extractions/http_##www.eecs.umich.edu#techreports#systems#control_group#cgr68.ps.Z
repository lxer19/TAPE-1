URL: http://www.eecs.umich.edu/techreports/systems/control_group/cgr68.ps.Z
Refering-URL: http://www.eecs.umich.edu/home/techreports/sys91.html
Root-URL: http://www.cs.umich.edu
Title: A Relational Algebraic Approach to the Representation and Analysis of Discrete Event Systems  
Author: Stephane Lafortune and Enke Chen 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: The analysis and control of discrete event systems modeled by finite-state machines require possibly complex manipulations of these finite-state machines. Algorithms that involve such manipulations must be described formally, uniformly, concisely, and must be easy to program. This paper shows that the relational algebra from relational database theory can be employed to achieve these goals. We consider representative operations on finite-state machines that arise in the analysis and control of discrete event systems and show how these operations can be formally specified as algebraic expressions in relational algebra and how they can be implemented as SQL queries on a relational database management system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y.-C. Ho, </author> <title> Guest Editor, "Special issue on dynamics of discrete event systems," </title> <journal> Proc. IEEE, </journal> <volume> vol. 77, no. 1, </volume> <pages> pp. 3-221, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Third, one may wish to design a supervisory controller for the set of interacting finite-state machines such that the global finite-state machine behaves properly. With the recent developments toward a control theory for discrete event systems (cf. <ref> [1] </ref> and [2]), the above three issues of modular composition, analysis, and controller synthesis, are all leading to more and more complex manipulations of finite-state machines. <p> The theta-join of relation R <ref> [ 1 ] </ref> with relation S [ 2 ] is denoted by R 1 fi S := fi (R fi S) ; where fi is a predicate and fi denotes Cartesian product. 6) (Natural) Join: This is a special case of the theta-join which combines two relations on their common attributes. <p> Formally, the join of relation R <ref> [ 1 ] </ref> and S [ 2 ] is defined by R 1 S := 1 [ 2 (R 1 fi S) ; t 2x where fi := (r:A 1 = s:A 1 ) ^ ^ (r:A n = s:A n ) when 1 " 2 = fA 1 ; ;
Reference: [2] <author> C. G. Cassandras and P. J. Ramadge, </author> <title> Guest Editors, "Special section on discrete event systems," </title> <journal> IEEE Control Systems Magazine, </journal> <volume> vol. 10, no. 4, </volume> <pages> pp. 66-112, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Third, one may wish to design a supervisory controller for the set of interacting finite-state machines such that the global finite-state machine behaves properly. With the recent developments toward a control theory for discrete event systems (cf. [1] and <ref> [2] </ref>), the above three issues of modular composition, analysis, and controller synthesis, are all leading to more and more complex manipulations of finite-state machines. <p> The theta-join of relation R [ 1 ] with relation S <ref> [ 2 ] </ref> is denoted by R 1 fi S := fi (R fi S) ; where fi is a predicate and fi denotes Cartesian product. 6) (Natural) Join: This is a special case of the theta-join which combines two relations on their common attributes. <p> Formally, the join of relation R [ 1 ] and S <ref> [ 2 ] </ref> is defined by R 1 S := 1 [ 2 (R 1 fi S) ; t 2x where fi := (r:A 1 = s:A 1 ) ^ ^ (r:A n = s:A n ) when 1 " 2 = fA 1 ; ; A n g.
Reference: [3] <author> P. J. Ramadge and W. M. Wonham, </author> <title> "The control of discrete event systems," </title> <journal> Proc. IEEE, </journal> <volume> vol. 77, no. 1, </volume> <pages> pp. 81-98, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: For instance: * The composition of two finite-state machines can take various forms, such as an asynchronous composition or shu*e (cf. <ref> [3] </ref>), a synchronous composition (cf. [4]), a biased synchronous composition (cf. [5]), or a prioritized synchronous composition (cf. [6]). * The analysis of finite-state machines may be much more involved than a simple reachability analysis, but it may entail verifying if the language generated by a finite-state machine is controllable (or <p> more involved than a simple reachability analysis, but it may entail verifying if the language generated by a finite-state machine is controllable (or observable, or co-observable, or normal, etc.) with respect to the language generated by a second finite-state machine and to a set of uncontrollable (or unobservable) events (cf. <ref> [3] </ref>). * The task of controller synthesis may require the calculation of a finite-state machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf.
Reference: [4] <author> R. Cieslak, C. Desclaux, A. Fawaz, and P. Varaiya, </author> <title> "Supervisory control of discrete-event processes with partial observations," </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> vol. 33, no. 3, </volume> <pages> pp. 249-260, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: For instance: * The composition of two finite-state machines can take various forms, such as an asynchronous composition or shu*e (cf. [3]), a synchronous composition (cf. <ref> [4] </ref>), a biased synchronous composition (cf. [5]), or a prioritized synchronous composition (cf. [6]). * The analysis of finite-state machines may be much more involved than a simple reachability analysis, but it may entail verifying if the language generated by a finite-state machine is controllable (or observable, or co-observable, or normal, <p> Remark 4.1: The meet operation is sometimes mentioned in the literature. It is simply the product operation followed by the trim operation, i.e., M EET (G1; G2) = T RIM [(CSC (G1; G2)]. 2) Synchronous composition: G = SC (G1; G2) This operation is discussed in <ref> [4] </ref>. We first recall its definition. Synchronous Composition: Input: G 1 = (Q 1 ; 1 ; 1 ; q 01 ; Q m1 ) and G 2 = (Q 2 ; 2 ; 2 ; q 02 ; Q m2 ).
Reference: [5] <author> S. Lafortune and E. Chen, </author> <title> "The infimal closed controllable super-language and its application in supervisory control," </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> vol. 35, no. 4, </volume> <pages> pp. 398-405, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: For instance: * The composition of two finite-state machines can take various forms, such as an asynchronous composition or shu*e (cf. [3]), a synchronous composition (cf. [4]), a biased synchronous composition (cf. <ref> [5] </ref>), or a prioritized synchronous composition (cf. [6]). * The analysis of finite-state machines may be much more involved than a simple reachability analysis, but it may entail verifying if the language generated by a finite-state machine is controllable (or observable, or co-observable, or normal, etc.) with respect to the language <p> * The task of controller synthesis may require the calculation of a finite-state machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. <ref> [5] </ref>), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. [10], [11]), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under Grant ECS-9057967. <p> Without loss of generality, we also define the domain of the attributes in the above relations as follows: DOM (F S) = DOM (T S): I N T EGER; DOM (E): CHAR. The following example illustrates the above representation. Example 2.1: Recall the data of Example 4.2 in <ref> [5] </ref>. The discrete event system is described by the FSM G in Figure 1 where the initial state is identified by &gt; while marked states are circled. <p> This process is repeated for each machine and the union of the two intermediate relations is performed. 3) Biased synchronous composition (BSC): G = BSC (G1; G2) BSC is defined in <ref> [5] </ref> where it is shown to play an important role in the computation of the supremal controllable sublanguage of a given language (an operation discussed in Section 5.1). The definition of BSC is as follows. <p> Its computation was later discussed in [7], [22], and <ref> [5] </ref>. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1. <p> Its computation was later discussed in [7], [22], and <ref> [5] </ref>. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1. <p> Its computation was later discussed in [7], [22], and <ref> [5] </ref>. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1. <p> We are also given u for the system (represented by relation U CE). We construct H, a FSM that generates L " . Step 1. Do binary operations (and encode) to get the subgraph rela tion H G (see Theorem 5.1 in <ref> [5] </ref>): H AC [CSC ( ~ G1; ~ G2)]; Step 2. do until T M P 2 = ;: T M P 1 F S [(G T RAN 1 U CE) H T RAN ] 1 H SS ; ffi T S F S (T M P 1)) ; We can <p> In <ref> [5] </ref>, a closed-form expression for L # is presented, and an algorithm for L # in the regular case is also proposed based upon that closed-form expression. Let us first recall that algorithm (see [5], Section 4). ( Since L # = (L) # , marked states are irrelevant to the <p> In <ref> [5] </ref>, a closed-form expression for L # is presented, and an algorithm for L # in the regular case is also proposed based upon that closed-form expression. Let us first recall that algorithm (see [5], Section 4). ( Since L # = (L) # , marked states are irrelevant to the computation of L # .) Step 1. <p> Example In this example, we illustrate the relational algebraic approach of the previous sections by computing the infimal closed controllable su perlanguage of a given language. The system is given as in Example 2.1. We also recall from Example 4.2 in <ref> [5] </ref> that the legal behavior for marked traces is L = ft 1x t 1y t 2x t 2y ; t 2x t 2y t 1x t 1y ; t 1x t 2x t 1y t 2y ; t 2x t 1x t 2y t 1y g L m (G) : <p> The resulting FSM LDN is shown in Figures 9 and 10. Observe that LDN has 11 states and 13 transitions. After renaming of the states, it is the same as the FSM obtained in Example 4.2 in <ref> [5] </ref>. 7. Discussion We have selected a small but representative sample of operations on finite-state machines and shown how these operations can be formally specified in relational algebra and then implemented as SQL queries on a RDBMS. Other operations not discussed here can be treated similarly.
Reference: [6] <author> M. Heymann, </author> <title> "Concurrency and discrete event control," </title> <journal> IEEE Control Systems Magazine, </journal> <volume> vol. 10, no. 4, </volume> <pages> pp. 103-112, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: For instance: * The composition of two finite-state machines can take various forms, such as an asynchronous composition or shu*e (cf. [3]), a synchronous composition (cf. [4]), a biased synchronous composition (cf. [5]), or a prioritized synchronous composition (cf. <ref> [6] </ref>). * The analysis of finite-state machines may be much more involved than a simple reachability analysis, but it may entail verifying if the language generated by a finite-state machine is controllable (or observable, or co-observable, or normal, etc.) with respect to the language generated by a second finite-state machine and
Reference: [7] <author> W. M. Wonham and P. J. Ramadge, </author> <title> "On the supremal controllable sublanguage of a given language," </title> <journal> SIAM J. Control and Optimization, </journal> <volume> vol. 25, no. 3, </volume> <pages> pp. 637-659, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: respect to the language generated by a second finite-state machine and to a set of uncontrollable (or unobservable) events (cf. [3]). * The task of controller synthesis may require the calculation of a finite-state machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. <ref> [7] </ref>), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. [10], [11]), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular <p> 2 1 (q 1 ) " 2 (q 2 ) undefined otherwise where i (q i ) i denotes the active set of G i at state q i , namely i (q i ) is the subset of i for which i (; q i ) is defined (cf. <ref> [7] </ref>, Sect. 6). Let us implement the completely synchronous composition G = G1 fi G2 in relational algebra. Step 1. <p> Its computation was later discussed in <ref> [7] </ref>, [22], and [5]. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1.
Reference: [8] <author> F. Lin and W. M. Wonham, </author> <title> "On observability of discrete-event systems," </title> <journal> Information Sciences, </journal> <volume> vol. 44, </volume> <pages> pp. 173-198, </pages> <year> 1988. </year>
Reference-contexts: uncontrollable (or unobservable) events (cf. [3]). * The task of controller synthesis may require the calculation of a finite-state machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. <ref> [8] </ref>), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. [10], [11]), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under
Reference: [9] <author> S. Lafortune and F. Lin, </author> <title> "On tolerable and desirable behaviors in supervisory control of discrete event systems," Discrete Event Dynamic Systems: </title> <journal> Theory and Applications, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 61-92, </pages> <year> 1991. </year>
Reference-contexts: the calculation of a finite-state machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. <ref> [9] </ref>), supremal nonconflicting sub-languages (cf. [10], [11]), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under Grant ECS-9057967.
Reference: [10] <author> E. Chen and S. Lafortune, </author> <title> "Dealing with blocking in supervisory control of discrete event systems," </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> vol. 36, no. 6, </volume> <pages> pp. 724-735, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: machine that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. <ref> [10] </ref>, [11]), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under Grant ECS-9057967.
Reference: [11] <author> E. Chen and S. Lafortune, </author> <title> "On nonconflicting languages that arise in supervisory control of discrete event systems," </title> <type> Technical Report CGR-55, </type> <institution> College of Engineering Control Group Reports, University of Michigan, </institution> <month> November </month> <year> 1990. </year> <note> To appear in Systems & Control Letters, </note> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: that generates the supremal controllable sublanguage of the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. [10], <ref> [11] </ref>), infimal closed controllable co-observable superlanguages (cf. [12]), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under Grant ECS-9057967.
Reference: [12] <author> K. Rudie and W. M. Wonham, </author> <title> "Think globally, act locally: </title> <booktitle> Decentralized supervisory control," in Proc. 1991 American Control Conf., </booktitle> <address> Boston, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: the language generated by another finite-state machine (cf. [7]), or it may require similar calculations but this time involving supremal normal sublanguages (cf. [8]), infimal closed controllable superlanguages (cf. [5]), minimal controllable and M -closed superlanguages (cf. [9]), supremal nonconflicting sub-languages (cf. [10], [11]), infimal closed controllable co-observable superlanguages (cf. <ref> [12] </ref>), and so forth, depending upon the par ticular supervisory control problem addressed. fl Research supported in part by the National Science Foundation under Grant ECS-9057967. This large variety of algorithms manipulating finite-state machines is likely to grow with the development of discrete event control theory.
Reference: [13] <author> E. F. Codd, </author> <title> "A relational model of data for large shared data banks," </title> <journal> Communications of the ACM, </journal> <volume> vol. 13, no. 6, </volume> <pages> pp. 377-387, </pages> <month> June </month> <year> 1970. </year>
Reference-contexts: The objective of this paper is to show that the relational algebra from relational database theory can be employed to achieve these goals. The relational model of data for large databases was originally proposed by Codd in 1970 <ref> [13] </ref>. The book by Maier [14] presents a detailed account of the theory of relational databases. Since the state-transition table of a finite-state machine is nothing but a relation, the operators of relational algebra can be used to formally specify algorithms that involve the manipulation of finite-state machines.
Reference: [14] <author> D. Maier, </author> <title> The Theory of Relational Databases, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1983. </year>
Reference-contexts: The objective of this paper is to show that the relational algebra from relational database theory can be employed to achieve these goals. The relational model of data for large databases was originally proposed by Codd in 1970 [13]. The book by Maier <ref> [14] </ref> presents a detailed account of the theory of relational databases. Since the state-transition table of a finite-state machine is nothing but a relation, the operators of relational algebra can be used to formally specify algorithms that involve the manipulation of finite-state machines. <p> However, there are some operations that are specifically for relations. The following brief review of these operations is based on [18], <ref> [14] </ref>. FS E TS 1 t 1x 4 3 t 1y 6 5 t 1y 8 3 t 2x 4 1 t 2y 2 7 t 2y 8 TS 1) Selection: This operation selects tuples that satisfy a given predicate.
Reference: [15] <author> T. T. Lee and M.-Y. Lai, </author> <title> "A relational algebraic approach to protocol verification," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 14, no. 2, </volume> <pages> pp. 184-193, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: We argue that these are two other significant advantages of the representation that we propose. Lee and Lai have successfully used a relational algebraic approach in the context of protocol verification <ref> [15] </ref>, where the issue is essentially one of reachability analysis of a finite-state machine. In the present context of discrete event control, the issues are far more involved as we mentioned above. Nevertheless, we shall demonstrate that a similar approach is also appropriate. This paper is organized as follows.
Reference: [16] <author> S. Lafortune and E. Chen, </author> <title> "On relational algebra and discrete event systems," in Book of Abstracts, Optimization Days, </title> <address> Montreal, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: We conclude the paper with an example in Section 6 and a discussion in Section 7. (The idea of using relational algebra in discrete event control theory, upon which the original results in this paper are built, was first presented by the authors at the Optimization Days 1989 <ref> [16] </ref>.) 2.
Reference: [17] <author> K. Rudie, </author> <title> Software for the Control of Discrete Event Systems, </title> <type> Master's thesis, </type> <institution> Dept. of Elec. Eng., Univ. of Toronto, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Relational representation of finite-state machines A finite-state machine (FSM) is a directed graph and various data structures can be used to represent it. (For a discussion on this topic that is relevant to discrete event control, we refer the reader to <ref> [17] </ref>, pp. 55-57.) We will use a representation in terms of relations (or tables). Although relatively unstructured (compared with adjacency or incidence matrices, for example), this representation is quite convenient because it allows for the use of the powerful operators of the relational algebra. <p> There is often a need to transform the pairs into singletons, or vice versa. Transforming the pairs into singletons can be done by renaming. If in addition the transformation is required to be bijective, then the "ENCODE" and "DECODE" operations presented by Rudie in <ref> [17] </ref> can be used. 3. Review of relational algebra and SQL 3.1 Relational algebra The usual set operations, such as union, intersection, difference, and Cartesian product are applicable to relations since relations are sets. However, there are some operations that are specifically for relations. <p> t 1y 6 6 5 5 t 1y 8 8 3 3 t 2x 4 4 1 1 t 2y 2 2 7 7 t 2y 8 8 oped the TCT software (versions in Pascal and Prolog) for small-scale discrete-event control system synthesis on a personal computer (see [22], [23], <ref> [17] </ref>). On the other hand, it should be emphasized that a RDBMS has a "query optimizer" module.
Reference: [18] <author> H. F. Korth and A. Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Review of relational algebra and SQL 3.1 Relational algebra The usual set operations, such as union, intersection, difference, and Cartesian product are applicable to relations since relations are sets. However, there are some operations that are specifically for relations. The following brief review of these operations is based on <ref> [18] </ref>, [14]. FS E TS 1 t 1x 4 3 t 1y 6 5 t 1y 8 3 t 2x 4 1 t 2y 2 7 t 2y 8 TS 1) Selection: This operation selects tuples that satisfy a given predicate. <p> However, as a formal language, it is not sufficiently "user-friendly" to constitute a query language for a database system product. The commercial query language SQL is widely used and is supported by most RDBMSs. The following brief review of the syntax of SQL is adapted from <ref> [18] </ref>.
Reference: [19] <author> C. J. Date, </author> <title> A Guide to the SQL Standard, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: For example, the cardinality of the state space of a FSM can be obtained by using the count operator of SQL: CARD (G) = count (G SS). The reader is referred to <ref> [19] </ref> for a more detailed discussion of SQL. 3.3 Remark on recursion Recursive queries such as transitive closure operations on relations (e.g., "find all states reachable from a given state") cannot be solely expressed in terms of the basic operators of relational algebra.
Reference: [20] <author> Y. Ioannidis and R. Ramakrishnan, </author> <title> "Efficient transitive closure algorithms," </title> <booktitle> in Proc. 14th Int. Conf. on Very Large Data Bases, </booktitle> <pages> pp. 382-394, </pages> <address> Los Angeles, CA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Although straightforward, the semi-naive algorithm is well-suited for simple transitive closure operations as is the case here (cf. <ref> [20] </ref>). 2) Coaccessible operation: G2 = COAC (G1) Step 1. H G1 M S; P G1 M S; Step 2. do until H = ;; H ffi T S F S [ F S (H 1 G1 T RAN )] P ; Step 3.
Reference: [21] <author> P. J. Ramadge and W. M. Wonham, </author> <title> "Supervisory control of a class of discrete event systems," </title> <journal> SIAM J. Control and Optimization, </journal> <volume> vol. 25, no. 1, </volume> <pages> pp. 206-230, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Algorithms for controller synthesis 5.1 The supremal controllable sublanguage L " The supremal controllable sublanguage L " of a given language L, with respect to (w.r.t.) a closed language M L and a set of uncontrollable events u , was first defined in <ref> [21] </ref>. Its computation was later discussed in [7], [22], and [5]. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1. <p> Formally, a controller is a pair S = (R; ') where R = (X; ; ~; x 0 ; X) is a FSM called recognizer and ' : fi X ! f0; 1g is the feedback map (cf. <ref> [21] </ref> for a more detailed discussion). The following important result is proved in [21]. Theorem: Let L be a nonempty sublanguage of L (G). There exists a controller S such that L (S=G) = L iff L is closed and controllable (w.r.t. L (G) and u ). <p> a controller is a pair S = (R; ') where R = (X; ; ~; x 0 ; X) is a FSM called recognizer and ' : fi X ! f0; 1g is the feedback map (cf. <ref> [21] </ref> for a more detailed discussion). The following important result is proved in [21]. Theorem: Let L be a nonempty sublanguage of L (G). There exists a controller S such that L (S=G) = L iff L is closed and controllable (w.r.t. L (G) and u ). An algorithm for obtaining the state feedback map ' is also proposed in [21]. <p> is proved in <ref> [21] </ref>. Theorem: Let L be a nonempty sublanguage of L (G). There exists a controller S such that L (S=G) = L iff L is closed and controllable (w.r.t. L (G) and u ). An algorithm for obtaining the state feedback map ' is also proposed in [21].
Reference: [22] <author> F. Lin and W. M. Wonham, </author> <title> "On the computation of supremal controllable sublanguages," </title> <booktitle> in Proc. 23rd Allerton Conf. on Communication, Control, and Computing, </booktitle> <month> September </month> <year> 1985. </year>
Reference-contexts: Its computation was later discussed in [7], <ref> [22] </ref>, and [5]. In [5], we proposed an algorithm for the computation of L " in the regular case which utilizes a subgraph relation between FSMs. Let us recall that algorithm (cf. [5], Section 5). Let i = 0. Step 1. <p> 3 3 t 1y 6 6 5 5 t 1y 8 8 3 3 t 2x 4 4 1 1 t 2y 2 2 7 7 t 2y 8 8 oped the TCT software (versions in Pascal and Prolog) for small-scale discrete-event control system synthesis on a personal computer (see <ref> [22] </ref>, [23], [17]). On the other hand, it should be emphasized that a RDBMS has a "query optimizer" module.
Reference: [23] <author> W. M. Wonham, </author> <title> "A control theory for discrete event systems," in Advanced Computing Concepts and Techniques in Control Engineering, </title> <editor> M. J. Denham and A. J. Laub, </editor> <booktitle> editors, </booktitle> <pages> pp. 129-169. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <booktitle> Nato ASI Series, </booktitle> <volume> Vol. </volume> <month> F47. </month>
Reference-contexts: 3 t 1y 6 6 5 5 t 1y 8 8 3 3 t 2x 4 4 1 1 t 2y 2 2 7 7 t 2y 8 8 oped the TCT software (versions in Pascal and Prolog) for small-scale discrete-event control system synthesis on a personal computer (see [22], <ref> [23] </ref>, [17]). On the other hand, it should be emphasized that a RDBMS has a "query optimizer" module.
References-found: 23

