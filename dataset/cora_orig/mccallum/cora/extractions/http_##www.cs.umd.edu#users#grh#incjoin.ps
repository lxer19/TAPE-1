URL: http://www.cs.umd.edu/users/grh/incjoin.ps
Refering-URL: http://www.cs.umd.edu/users/grh/
Root-URL: 
Email: grh@cs.umd.edu and hjs@cs.umd.edu  
Title: Incremental Distance Join Algorithms for Spatial Databases  
Author: Gsli R. Hjaltason and Hanan Samet 
Address: College Park, Maryland 20742  
Affiliation: Computer Science Department and Center for Automation Research and Institute for Advanced Computer Studies University of Maryland  
Note: Proceedings of the 1998 ACM SIGMOD Intl. Conference on Management of Data, Seattle, Washington, June 1998, pp. 237-248 1  
Abstract: Two new spatial join operations, distance join and distance semi-join, are introduced where the join output is ordered by the distance between the spatial attribute values of the joined tuples. Incremental algorithms are presented for computing these operations, which can be used in a pipelined fashion, thereby obviating the need to wait for their completion when only a few tuples are needed. The algorithms can be used with a large class of hierarchical spatial data structures and arbitrary spatial data types in any dimensions. In addition, any distance metric may be employed. A performance study using R-trees shows that the incremental algorithms outperform non-incremental approaches by an order of magnitude if only a small part of the result is needed, while the penalty, if any, for the incremental processing is modest if the entire join result is required. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. G. Aref and H. Samet. </author> <title> The spatial filter revisited. </title> <booktitle> Proc. of 6th International Symposium on Spatial Data Handling, </booktitle> <pages> pp. 190-208, </pages> <address> Edinburgh, Scotland, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14].
Reference: [2] <author> F. Bartling and K. Hinrichs. </author> <title> Probabilistic analysis of an algorithm for solving the k-dimensional all-nearest-neighbors problem by projection. </title> <journal> BIT, </journal> <volume> 31(4) </volume> <pages> 558-565, </pages> <year> 1991. </year>
Reference-contexts: Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair [6], and all nearest neighbors <ref> [2, 11, 31] </ref> in a set of objects. While our incremental distance join algorithm may not always be competitive with some of the above algorithms in terms of computational complexity, it may nevertheless be a reasonable alternative given that a spatial data structure has already been built.
Reference: [3] <author> R. J. Bayardo and D. P. Miranker. </author> <title> Processing queries for first few answers. </title> <booktitle> In Proc. of 5th CIKM, </booktitle> <pages> pp. 45-52, </pages> <address> Rockville, MD, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: This enables a query engine to use the algorithms in a pipelined fashion. Furthermore, the algorithms aim to deliver results as soon as possible. Such fast first pipelined join methods have recently become a focus of attention <ref> [3, 33] </ref>. They have become important in enabling the development of more user friendly and interactive interfaces to database systems [16]. Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms.
Reference: [4] <author> L. Becker, K. Hinrichs, and U. Finke. </author> <title> A new algorithm for computing joins with grid files. </title> <booktitle> Proc. of 9th IEEE Int. Conf. on Data Engineering, </booktitle> <pages> pp. 190-197, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed <ref> [4, 14] </ref>. Some of these methods involve special join indexes [14, 24].
Reference: [5] <author> N. Beckmann, H. P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R fl -tree: an efficient and robust access method for points and rectangles. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 322-331, </pages> <address> Atlantic City, NJ, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Bounding rectangles for individual line segments are omitted from (a) in the interest of clarity. We make use of an R-tree variant called the R fl -tree <ref> [5] </ref>. <p> The spatial data structure that we used is an R fl -tree <ref> [5] </ref>. The size of the nodes was 1K, for a maximum fan-out of 50, with 256K of memory used for buffers. The spatial objects were represented directly in the leaves of the R fl -trees. We chose that approach in order to simplify the analysis of the execution time results.
Reference: [6] <author> S. N. Bespamyatnikh. </author> <title> An optimal algorithm for closest pair maintenance. </title> <booktitle> Proc. of 11th Symp. on Computational Geometry, </booktitle> <pages> pp. 152-161, </pages> <address> Vancouver, British Columbia, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair <ref> [6] </ref>, and all nearest neighbors [2, 11, 31] in a set of objects.
Reference: [7] <author> T. Brinkhoff, H. P. Kriegel, R. Schneider, and B. Seeger. </author> <title> Multi-step processing of spatial joins. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 197-208, </pages> <address> Minneapolis, MN, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14].
Reference: [8] <author> T. Brinkhoff, H. P. Kriegel, and B. Seeger. </author> <title> Efficient processing of spatial joins using R-trees. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 237-246, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. <p> An alternative to processing only one of the nodes for node/node pairs is to process both simultaneously (termed Simultaneous in Section 4.1.1). This is more in line with traditional spatial join algorithms <ref> [8, 21] </ref>. In fact, if this is done, then many of the optimization techniques developed for spatial join can be applied [8], such as the usage of plane sweep and the restriction of the search space. <p> This is more in line with traditional spatial join algorithms [8, 21]. In fact, if this is done, then many of the optimization techniques developed for spatial join can be applied <ref> [8] </ref>, such as the usage of plane sweep and the restriction of the search space. <p> Without plane sweep, r1 would have to be checked for intersection with all the entries in n 2 , but with plane sweep we only have to check intersection of r1 with s1 and s2. The plane-sweep algorithm given in <ref> [8] </ref> has to be modified to work for a non-zero maximum distance (recall that [8] focuses on spatial join with the intersection predicate). <p> The plane-sweep algorithm given in <ref> [8] </ref> has to be modified to work for a non-zero maximum distance (recall that [8] focuses on spatial join with the intersection predicate). <p> The software was compiled with a GNU C++ compiler set for maximum optimization (-O3). The distance functions were based on the Euclidean metric. As in other evaluations of spatial algorithms (e.g., <ref> [8, 21] </ref>), we derived our test data from the TIGER/Line File [9]. We used two sets of points from the coverage of the Washington, DC area: Water contains the centroids of water features (37,495 points), and Roads contains the centroids of road features (200,482 points).
Reference: [9] <institution> Bureau of the Census. Tiger/Line precensus files. </institution> <address> Washington, DC, </address> <year> 1989. </year>
Reference-contexts: The software was compiled with a GNU C++ compiler set for maximum optimization (-O3). The distance functions were based on the Euclidean metric. As in other evaluations of spatial algorithms (e.g., [8, 21]), we derived our test data from the TIGER/Line File <ref> [9] </ref>. We used two sets of points from the coverage of the Washington, DC area: Water contains the centroids of water features (37,495 points), and Roads contains the centroids of road features (200,482 points).
Reference: [10] <author> M. J. Carey and D. Kossmann. </author> <title> On saying enough already! in SQL. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 219-230, </pages> <address> Tucson, AZ, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: The distance semi-join is a useful special case of the distance join which for each object in A finds the nearest object in B. Figure 1 defines the distance join and distance semi-join operations using a syntax loosely adapted from SQL-92, including the STOP AFTER clause extension proposed in <ref> [10] </ref>. The WHERE and STOP AFTER clauses, specifying limits on the distance and/or the number of result tuples, are optional. These basic queries could be made more complicated by adding further selection conditions in the WHERE clause. <p> Such fast first pipelined join methods have recently become a focus of attention [3, 33]. They have become important in enabling the development of more user friendly and interactive interfaces to database systems [16]. Recent proposals for extending SQL <ref> [10] </ref> also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair [6], and all nearest neighbors [2, 11, 31] in a set of objects. <p> In many applications, especially involving interactive queries, a fairly low number of pairs are known to be needed. This is aided by query language extensions that enable limiting the number of tuples in the result of queries (e.g., the STOP AFTER clause proposed for the SELECT statement of SQL <ref> [10] </ref>). Given that the algorithm must compute a maximum of K pairs, the algorithm can estimate the maximum distance based on the pairs that have been seen so far.
Reference: [11] <author> K. L. Clarkson. </author> <title> Fast algorithm for the all nearest neighbors problem. </title> <booktitle> Proc. of 24th IEEE Symp. on the Foundations of Computer Science, </booktitle> <pages> pp. 226-232, </pages> <address> Tucson, </address> <month> November </month> <year> 1983. </year>
Reference-contexts: Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair [6], and all nearest neighbors <ref> [2, 11, 31] </ref> in a set of objects. While our incremental distance join algorithm may not always be competitive with some of the above algorithms in terms of computational complexity, it may nevertheless be a reasonable alternative given that a spatial data structure has already been built.
Reference: [12] <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: It is an object hierarchy in the form of a balanced structure inspired by the B + -tree <ref> [12] </ref>. Each R-tree node contains an array of (key, pointer) entries where key is a hyper-rectangle that minimally bounds the data objects in the subtree pointed at by pointer.
Reference: [13] <author> M. L. Fredman, R. Sedgewick, D. D. Sleator, and R. E. Tarjan. </author> <title> The pairing heap: A new form of self-adjusting heap. </title> <journal> Algo-rithmica, </journal> <volume> 1(1) </volume> <pages> 111-129, </pages> <year> 1986. </year>
Reference-contexts: However, an exclusively disk-based scheme for representing the priority queue is not desirable, due to poor performance. In our experiments, we use a simple hybrid memory/disk scheme that stores parts of the priority queue in a memory-based heap structure (we chose the pairing heap structure <ref> [13] </ref>), while the rest is offloaded to disk. If a relatively small number of object pairs is requested, then the vast majority of pairs put on the priority queue will never be needed.
Reference: [14] <author> O. Gunther. </author> <title> Efficient computation of spatial joins. </title> <booktitle> Proc. of 9th IEEE Int. Conf. on Data Engineering, </booktitle> <pages> pp. 50-59, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed <ref> [4, 14] </ref>. Some of these methods involve special join indexes [14, 24]. <p> A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. Some of these methods involve special join indexes <ref> [14, 24] </ref>.
Reference: [15] <author> A. Guttman. R-trees: </author> <title> a dynamic index structure for spatial searching. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 47-57, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: Section 2.3 presents modifications to the basic algorithm to enable it to compute the distance semi-join operation. 2.1 R-trees The R-tree <ref> [15] </ref> (see Figure 2) is one of many proposed spatial data structures. It is an object hierarchy in the form of a balanced structure inspired by the B + -tree [12].
Reference: [16] <author> J. M. Hellerstein, P. J. Haas, and H. Wang. </author> <title> Online aggregation. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 171-182, </pages> <address> Tucson, AZ, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Furthermore, the algorithms aim to deliver results as soon as possible. Such fast first pipelined join methods have recently become a focus of attention [3, 33]. They have become important in enabling the development of more user friendly and interactive interfaces to database systems <ref> [16] </ref>. Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair [6], and all nearest neighbors [2, 11, 31] in a set of objects.
Reference: [17] <author> A. Henrich. </author> <title> A distance-scan algorithm for spatial access structures. </title> <booktitle> Proc. of 2nd ACM Workshop on GIS, </booktitle> <pages> pp. 136-143, </pages> <address> Gaithersburg, MD, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: from the conventional R-tree in employing a more sophisticated insertion and node-splitting algorithms that attempt to minimize a combination of overlap and area increase between minimum bounding rectangles. 2.2 Computing Distance Join Our incremental distance join algorithm may be viewed as simultaneously applying an incremental nearest neighbor algorithm [18] (see <ref> [17] </ref> for the application of a similar approach to the LSD tree) to the two spatial data structures corresponding to the spatial attributes of the joined relations. The algorithm works for any spatial data structure based on a hierarchical decomposition.
Reference: [18] <author> G. R. Hjaltason and H. Samet. </author> <title> Ranking in spatial databases. </title> <booktitle> Advances in Spatial Databases 4th Int. Symp., SSD'95, </booktitle> <pages> pp. 83-95, </pages> <address> Portland, ME, </address> <month> August </month> <year> 1995. </year> <note> (Also Springer-Verlag Lecture Notes in Computer Science 951). </note>
Reference-contexts: It differs from the conventional R-tree in employing a more sophisticated insertion and node-splitting algorithms that attempt to minimize a combination of overlap and area increase between minimum bounding rectangles. 2.2 Computing Distance Join Our incremental distance join algorithm may be viewed as simultaneously applying an incremental nearest neighbor algorithm <ref> [18] </ref> (see [17] for the application of a similar approach to the LSD tree) to the two spatial data structures corresponding to the spatial attributes of the joined relations. The algorithm works for any spatial data structure based on a hierarchical decomposition. <p> Also, in this case, the if statement in line 7 of INCDISTJOIN would not be needed. The connection of the incremental distance join to our incremental nearest neighbor algorithm <ref> [18] </ref> is easy to see from Figure 3, as PROCESSNODE1 and PROCESSNODE2 are essentially the same as the basic loop of the nearest neighbor algorithm.
Reference: [19] <author> E. Hoel and H. Samet. </author> <title> Data-parallel spatial join algorithms. </title> <booktitle> Proc. of 23rd Int. Conf. on Parallel Processing, </booktitle> <pages> pp. 227-234, </pages> <address> St. Charles, IL, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14].
Reference: [20] <author> Y.-W. Huang, N. Jing, and E. A. Rundensteiner. </author> <title> A cost model for estimating the performance of spatial joins using r-trees. </title> <booktitle> Proc. of 9th Int. Conf. on Scientific and Statistical Database Management, </booktitle> <pages> pp. 30-38, </pages> <address> Olympia, WA, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: However, if the population criteria has a low selectivity, then the first option would be superior. More query plans may even exist, employing some other algorithm. To enable a query optimizer to choose between these options requires a cost model for the relevant algorithms (e.g., as developed in <ref> [20] </ref> for the traditional R-tree spatial join). Developing such cost models for the incremental distance join algorithms presented in this paper is a subject for further study. Other issues for further investigation include developing techniques to dynamically partition the priority queue between a memory-based structure and a disk-based one.
Reference: [21] <author> Y.-W. Huang, N. Jing, and E. A. Rundensteiner. </author> <title> Spatial joins using r-trees: breadth-first traversal with global optimizations. </title> <booktitle> Proc. of 23rd VLDB Conf., </booktitle> <pages> pp. 396-405, </pages> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. <p> This could be of advantage if we wanted to compute a large portion of the distance join operation (i.e., generate a very large number of pairs), as it would in certain cases enable the algorithm to better schedule node and object accesses <ref> [21] </ref>. However, given our usage assumptions, much of the work may be wasted, as a breadth-first traversal would require processing all pairs at one level before any pairs with the same distance at the next level are considered. <p> An alternative to processing only one of the nodes for node/node pairs is to process both simultaneously (termed Simultaneous in Section 4.1.1). This is more in line with traditional spatial join algorithms <ref> [8, 21] </ref>. In fact, if this is done, then many of the optimization techniques developed for spatial join can be applied [8], such as the usage of plane sweep and the restriction of the search space. <p> If both nodes in node/node pairs are processed simultaneously, then the incremental distance join algorithm resembles somewhat the spatial join algorithm introduced in <ref> [21] </ref>. The difference is that [21] is breadth-first and is limited to finding intersecting object pairs, although it would be straightforward to generalize it to com Proceedings of the 1998 ACM SIGMOD Intl. <p> If both nodes in node/node pairs are processed simultaneously, then the incremental distance join algorithm resembles somewhat the spatial join algorithm introduced in <ref> [21] </ref>. The difference is that [21] is breadth-first and is limited to finding intersecting object pairs, although it would be straightforward to generalize it to com Proceedings of the 1998 ACM SIGMOD Intl. <p> The software was compiled with a GNU C++ compiler set for maximum optimization (-O3). The distance functions were based on the Euclidean metric. As in other evaluations of spatial algorithms (e.g., <ref> [8, 21] </ref>), we derived our test data from the TIGER/Line File [9]. We used two sets of points from the coverage of the Washington, DC area: Water contains the centroids of water features (37,495 points), and Roads contains the centroids of road features (200,482 points).
Reference: [22] <author> M. Kitsuregawa, L. Harada, and M. Takagi. </author> <title> Join strategies on k-d-tree indexed relations. </title> <booktitle> Proc. of 5th IEEE Int. Conf. on Data Engineering, </booktitle> <pages> pp. 85-93, </pages> <address> Los Angeles, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect <ref> [1, 7, 8, 19, 21, 22] </ref>. A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14].
Reference: [23] <author> D. Lomet and B. Salzberg. </author> <title> A robust multi-attribute search structure. </title> <booktitle> Proc. of the 5th IEEE Int. Conf. on Data Engineering, </booktitle> <pages> pp. 296-304, </pages> <address> Los Angeles, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: This set of assumptions was chosen as it holds for the R-tree. However, the algorithm can be easily adapted to handle most spatial data structures that do not satisfy these assumptions, such as the hB-tree <ref> [23] </ref> (which forms a directed acyclic graph), and quadtrees [26, 27] (where non-point objects may be stored in more than one leaf node).
Reference: [24] <author> D. Rotem. </author> <title> Spatial join indices. </title> <booktitle> Proc. of 7th Int. Conf. on Data Engineering, </booktitle> <pages> pp. 500-509, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect [1, 7, 8, 19, 21, 22]. A generalization of this is within, where the objects are required to lie within some distance of each other <ref> [24, 29] </ref>. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. Some of these methods involve special join indexes [14, 24]. <p> A generalization of this is within, where the objects are required to lie within some distance of each other [24, 29]. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. Some of these methods involve special join indexes <ref> [14, 24] </ref>.
Reference: [25] <author> N. Roussopoulos, S. Kelley, and F. Vincent. </author> <title> Nearest neighbor queries. </title> <booktitle> Proc. of ACM SIGMOD, </booktitle> <pages> pp. 71-79, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: is possible for these types of pairs through the use of a distance metric 3 But see Section 3.2 for a description of a priority queue implementation that puts part of the queue on disk if its size is too large to fit in memory. that has been termed MINMAXDIST <ref> [25] </ref>. The object bounding rectangles are required to minimally bound the objects. The key idea behind the MINMAXDIST metric is that if b is the d-dimensional minimum bounding rectangle of object o, then each of the d 1 dimensional faces 4 of b must touch o at some point. <p> A practical way of computing the value of d mm (p; b) is to first compute the maximum distance from p to a vertex of b, say v max , and then to determine the vertex adjacent to v max (i.e., along an edge) that is closest to p <ref> [25] </ref>. Now, we can define d max (n 1 ; b 2 ) = max p2n 1 d mm (p; b 2 ), and similarly for obr/node pairs. <p> Observe that this approach is analogous to the downward pruning strategy of the nearest neighbor algorithm of <ref> [25] </ref>. A more aggressive strategy can be obtained by using the same insight in a global fashion.
Reference: [26] <author> H. Samet. </author> <title> Applications of spatial data structures: Computer graphics, image processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: This set of assumptions was chosen as it holds for the R-tree. However, the algorithm can be easily adapted to handle most spatial data structures that do not satisfy these assumptions, such as the hB-tree [23] (which forms a directed acyclic graph), and quadtrees <ref> [26, 27] </ref> (where non-point objects may be stored in more than one leaf node). In the remainder of this section, we do not make a distinction between a node and the region that it represents; the meaning should be clear from the context.
Reference: [27] <author> H. Samet. </author> <title> The design and analysis of spatial data structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: This set of assumptions was chosen as it holds for the R-tree. However, the algorithm can be easily adapted to handle most spatial data structures that do not satisfy these assumptions, such as the hB-tree [23] (which forms a directed acyclic graph), and quadtrees <ref> [26, 27] </ref> (where non-point objects may be stored in more than one leaf node). In the remainder of this section, we do not make a distinction between a node and the region that it represents; the meaning should be clear from the context. <p> Some widely used spatial data structures form unbalanced tree hierarchies (e.g., quadtrees <ref> [27] </ref> and the buddy-tree [28]). Bounding rectangles are not always present in the leaf nodes of these structures, even when objects are not represented directly in the leaves (i.e., the leaves only contain pointers to the objects).
Reference: [28] <author> B. Seeger and H. P. Kriegel. </author> <title> The buddy-tree: an efficient and robust access method for spatial data base systems. </title> <booktitle> Proc. of 16th VLDB Conf., </booktitle> <pages> pp. 590-601, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Some widely used spatial data structures form unbalanced tree hierarchies (e.g., quadtrees [27] and the buddy-tree <ref> [28] </ref>). Bounding rectangles are not always present in the leaf nodes of these structures, even when objects are not represented directly in the leaves (i.e., the leaves only contain pointers to the objects).
Reference: [29] <author> J. C. Shafer and R. Agrawal. </author> <title> Parallel algorithms for high-dimensional proximity joins. </title> <booktitle> Proc. of 23rd VLDB Conf., </booktitle> <pages> pp. 176-185, </pages> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The most common spatial predicate is intersect, i.e., the geometry of the objects are required to intersect [1, 7, 8, 19, 21, 22]. A generalization of this is within, where the objects are required to lie within some distance of each other <ref> [24, 29] </ref>. Other spatial predicates have been considered as well, and general methods to compute a spatial join proposed [4, 14]. Some of these methods involve special join indexes [14, 24].
Reference: [30] <author> H. W. Six and D. Wood. </author> <title> Counting and reporting intersections of d-ranges. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 31(3) </volume> <pages> 181-187, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: They have become important in enabling the development of more user friendly and interactive interfaces to database systems [16]. Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs <ref> [30] </ref>, closest pair [6], and all nearest neighbors [2, 11, 31] in a set of objects.
Reference: [31] <author> P. M. Vaidya. </author> <title> An O(n log n) algorithm for the all-nearest-neighbor problem. </title> <journal> Discrete & Computational Geometry, </journal> <volume> 4(2) </volume> <pages> 101-115, </pages> <year> 1989. </year>
Reference-contexts: Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms. A variation of our incremental distance join algorithm can be used to compute intersecting pairs [30], closest pair [6], and all nearest neighbors <ref> [2, 11, 31] </ref> in a set of objects. While our incremental distance join algorithm may not always be competitive with some of the above algorithms in terms of computational complexity, it may nevertheless be a reasonable alternative given that a spatial data structure has already been built.
Reference: [32] <author> T. L. Wang and D. Shasha. </author> <title> Query processing for distance met-rics. </title> <booktitle> Proc. of 16th VLDB Conf., </booktitle> <pages> pp. 602-613, </pages> <address> Brisbane, Aus-tralia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Note that this operation is not symmetric. In particular, the result of computing the distance semi-join of the warehouse relation and the stores relation is that for each warehouse, we get the closest store. The clustering join <ref> [32] </ref> is similar to the distance semi-join with the difference being that the clustering join is symmetric. An algorithm for computing the clustering join is also given in [32]. However, that algorithm is not well suited for spatial data that resides in d-dimensional Euclidean space. The reason is that [32] deals <p> The clustering join <ref> [32] </ref> is similar to the distance semi-join with the difference being that the clustering join is symmetric. An algorithm for computing the clustering join is also given in [32]. However, that algorithm is not well suited for spatial data that resides in d-dimensional Euclidean space. The reason is that [32] deals with more general objectssuch as patterns, strings, trees, graphs, etc.whose internal structure is unknown as far as the algorithm is concerned. <p> join <ref> [32] </ref> is similar to the distance semi-join with the difference being that the clustering join is symmetric. An algorithm for computing the clustering join is also given in [32]. However, that algorithm is not well suited for spatial data that resides in d-dimensional Euclidean space. The reason is that [32] deals with more general objectssuch as patterns, strings, trees, graphs, etc.whose internal structure is unknown as far as the algorithm is concerned. The only knowledge about the objects comes from a distance measure that returns the distance between two objects.
Reference: [33] <author> A. N. Wilschut and P. M. G. Apers. </author> <title> Dataflow query execution in a parallel main-memory environment. </title> <booktitle> Proc. of 1st Int. Conf. on Parallel and Distributed Information Systems, </booktitle> <pages> pp. 68-77, </pages> <address> Miami, FL, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: This enables a query engine to use the algorithms in a pipelined fashion. Furthermore, the algorithms aim to deliver results as soon as possible. Such fast first pipelined join methods have recently become a focus of attention <ref> [3, 33] </ref>. They have become important in enabling the development of more user friendly and interactive interfaces to database systems [16]. Recent proposals for extending SQL [10] also benefit greatly from the presence of such algorithms.
References-found: 33

