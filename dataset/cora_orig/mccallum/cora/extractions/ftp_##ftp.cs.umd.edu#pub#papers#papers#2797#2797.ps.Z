URL: ftp://ftp.cs.umd.edu/pub/papers/papers/2797/2797.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: Email: kutluhan@cs.umd.edu.  Email: nau@cs.umd.edu.  vs@cs.umd.edu.  
Title: Domain-Independent Planning: A Detailed Analysis  
Author: Kutluhan Erol Dana S. Nau V.S. Subrahmanian 
Note: This work was supported in part by the Army Research Office under Grant Number DAAL-03-92-G-0225, as well as by NSF Grant NSFD CDR-88003012 to the University of Maryland Institute for Systems Research, and NSF grants IRI-8907890 and IRI-9109755.  
Address: College Park, Maryland 20742, U.S.A.  Science.  Studies.  Email:  
Affiliation: University of Maryland  Department of Computer  Department of Computer Science, Institute for Systems Research, and Institute for Advanced Computer  Department of Computer Science and Institute for Advanced Computer Studies.  
Abstract: Technical Report CS-TR-2797, UMIACS-TR-91-154, SRC-TR-91-96. Complexity, Decidability and Undecidability Results for Abstract In this paper, we examine how the complexity of domain-independent planning with STRIPS-style operators depends on the nature of the planning operators. We show conditions under which planning is decidable and undecidable. Our results on this topic solve an open problem posed by Chapman [8], and clear up some difficulties with his undecidability theorems. For those cases where planning is decidable, we show how the time complexity varies depending on a wide variety of conditions: * whether or not function symbols are allowed; * whether or not delete lists are allowed; * whether or not negative preconditions are allowed; * whether or not the predicates are restricted to be propositional (i.e., 0-ary); * whether the planning operators are given as part of the input to the planning problem, or instead are fixed in advance. * whether or not the operators can have conditional effects. Furthermore, we provide insights about the reasons for our results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1976. </year>
Reference-contexts: What really interests us, of course, is the problem of finding the shortest plan that achieves G. This problem is at least as difficult as plan length, and in some cases harder. For example, in the Towers of Hanoi problem <ref> [1] </ref> and certain generalizations of it [17], the length of the shortest plan can be found in low-order polynomial time|but actually producing this plan requires exponential time and space, since the plan has exponential length.
Reference: [2] <author> Christer Backstrom, and Inger Klein. </author> <title> "Planning in polynomial time: </title> <booktitle> the SAS-PUBS class" Computational Intelligence 7 (1991), </booktitle> <pages> pp. 181-197. </pages>
Reference-contexts: Chapman was the first to study issues relating to the undecidability of planning; we have discussed his work in detail in Section 4. Backstrom and Klein found a class of planning problems called SAS-PUBS, for which planning can be done in polynomial time <ref> [2] </ref>. Their planning formalism is somewhat different from ours: they make use of state variables that take values from a finite set, and consider a planning state to be an assignment of values to these state variables.
Reference: [3] <author> M. Bezem. </author> <title> "Characterizing Termination of Logic Programs with Level Mappings." </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. 1989 North American Conf. on Logic Programming, </booktitle> <pages> pp. 69-80, </pages> <publisher> MIT Press. </publisher>
Reference-contexts: Any planning domain that is acyclic turns out to be weakly recurrent as well. We then use known results on weakly recurrent logic programs <ref> [3] </ref> to derive decidability results for weakly recurrent planning domains. 3.3.1 Acyclic Planning Domains Definition 3.3 A level mapping for a language L is a mapping ` : AT (L) ! N where AT (L) is the set of ground atoms in language L and N is the set of natural <p> If P is predicate acyclic, then PD (P ) is predicate acyclic. 3.3.2 Weakly Recurrent Planning Domains The above two results show that our transformations, LP, and PD, from logic programs to planning domains (and vice-versa) preserve atomic and predicate acyclicity. Bezem <ref> [3] </ref> has shown that a class of logic programs called weakly recurrent programs possess appealing decidability properties. All predicate and atomically acyclic programs are weakly recurrent (though the converse may not be true). <p> Below, we will present Bezem's definition of weakly recurrent logic programs, and then show how to define an analogous notion for planning domains which allows these decidability properties to be applied to planning. Definition 3.7 (Bezem <ref> [3] </ref>) A definite logic program is weakly recurrent iff there exists a level mapping ` such that for every clause in P having a ground instance of the form: A B 1 & : : : & B n such that if P 6j= A (i.e. <p> Intuitively, a weak recurrence says that non-provability of A can be established by verifying the non-provability of some strictly lower-level atoms B. Theorem 3.6 (Bezem <ref> [3] </ref>) If P is a weakly recurrent definite logic program, then the set of ground atoms provable from P is recursive (i.e. decidable).
Reference: [4] <author> H.A. Blair. </author> <title> "Canonical Conservative Extensions of Logic Program Completions," </title> <booktitle> Proc. 4th IEEE Symposium on Logic Programming, </booktitle> <year> 1989, </year> <pages> pp. 154-161. </pages>
Reference: [5] <author> T. Bylander. </author> <title> "Complexity Results for Planning," </title> <booktitle> Proc. IJCAI-91, </booktitle> <year> 1991, </year> <pages> pp. 274-279. </pages>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> Section 6 discusses the related work. Section 7 contains concluding remarks. Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues <ref> [5, 8, 19, 26, 27] </ref>. In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic. <p> Since a state may be any set of ground atoms, there is an exponential number of states. Since there are no variables, the number of operator instances is jOj, which of course is polynomial in jjPjj. Theorem 5.2 (Bylander <ref> [5] </ref>) 1. If we restrict P to be propositional, then plan existence is pspace-complete. 2. If we restrict P to be propositional and positive, then plan existence is pspace complete. 3. If we restrict P to be propositional and deletion-free, then plan existence is np complete. 4. <p> If we restrict P to be propositional, positive, and side-effect-free, then plan existence is in P . Synopsis of proof. Here are the basic intuitions behind the above theorem; for the details see <ref> [5] </ref>. In general, we might need to use the same operator instance more than once. <p> Then plan existence is in p. Proof. Immediate from Theorem 5.6 and Theorem 5.2. Example 5.1 (Blocks World) Bylander <ref> [5] </ref> reformulates the blocks world so that each operator is restricted to positive preconditions and one postcondition. Instead of the usual "on" and "clear" predicates, he uses proposition off ij to denote that block i is not on block j. <p> However, with minor modifications, the proofs of Theorems 5.2 through 5.17 will do the job. 6 Related Work 6.1 Planning Bylander has done several studies on the complexity of propositional planning <ref> [5, 6] </ref>. We have stated some of his results in Theorem 5.2 and Table 2. More recently, he has studied the complexity of propositional planning extended to allow a limited amount of inference in the domain theory [6]. His complexity results for this case range from polyomial time to pspace-complete.
Reference: [6] <author> T. Bylander. </author> <title> "Complexity Results for Extended Planning," </title> <booktitle> In Proc. First Internat. Conf. AI Planning Systems, </booktitle> <year> 1992, </year>
Reference-contexts: However, with minor modifications, the proofs of Theorems 5.2 through 5.17 will do the job. 6 Related Work 6.1 Planning Bylander has done several studies on the complexity of propositional planning <ref> [5, 6] </ref>. We have stated some of his results in Theorem 5.2 and Table 2. More recently, he has studied the complexity of propositional planning extended to allow a limited amount of inference in the domain theory [6]. His complexity results for this case range from polyomial time to pspace-complete. <p> We have stated some of his results in Theorem 5.2 and Table 2. More recently, he has studied the complexity of propositional planning extended to allow a limited amount of inference in the domain theory <ref> [6] </ref>. His complexity results for this case range from polyomial time to pspace-complete. Chapman was the first to study issues relating to the undecidability of planning; we have discussed his work in detail in Section 4.
Reference: [7] <author> Eugene Charniak and Drew McDermott. </author> <title> Introduction to Artificial Intelligence. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference-contexts: Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in <ref> [7, 21, 28, 37, 40, 19, 20] </ref>. Thus, from results proved in [20], it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions.
Reference: [8] <author> D. Chapman. </author> <title> "Planning for Conjunctive Goals," </title> <booktitle> Artificial Intelligence 32, </booktitle> <year> 1987, </year> <pages> pp. 333-377. </pages>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> The presence or absence of conditional operators does not affect these results. 3. We have solved an open problem stated by Chapman in <ref> [8] </ref>: whether or not planning is undecidable when the language contains infinitely many constants but the initial state is finite. In particular, this problem is decidable in the case where the planning operators have no negative preconditions and no delete lists. <p> Chapman's Second Undecidability Theorem states that "planning is undecidable even with a finite initial situation if the action representation is extended to represent actions whose effects are a function of their input situation" <ref> [8] </ref>, i.e., if the language contains function symbols and infinitely many constants. Our results show that even with a number of additional restrictions, planning is still undecidable. <p> Section 6 discusses the related work. Section 7 contains concluding remarks. Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues <ref> [5, 8, 19, 26, 27] </ref>. In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic. <p> However, in order to compare some of our results with Chapman's <ref> [8] </ref> results, in a few places in this paper we will be interested in violating one or both of these assumptions. When we do so, we will say so explicitly. 2 PRELIMINARIES 5 a c e (a) initial configuration b d (b) goal configuration 3. <p> Theorem 3.11 If the language is allowed to contain infinitely many constants but P = (S 0 ; O) is restricted to be positive, deletion-free, and function-free (and S 0 is finite), then plan existence is decidable. 3.4.2 Conditional Operators Several researchers <ref> [8, 10, 31, 30] </ref> have been interested in actions whose effects are context dependent, that is, dependent on the input situation. Thus, we found it necessary to examine the complexity of planning with such operators. <p> Thus, we found it necessary to examine the complexity of planning with such operators. We will be using Dean's [10] formulation of these operators, which is a more general version of what Chapman <ref> [8] </ref> uses. 8 Tom Bylander (personal communication) has proved a more restricted version of this theorem, in which he requires that the planning operators be allowed to contain delete lists. <p> Decidability) Whether or not the definition of a planning domain is extended to allow conditional planning operators makes no difference in any of our decidability and undecidability results. 4 Comparison with Chapman's Undecidability Results To date, the best-known results on decidability and undecidability in planning systems are those of Chapman <ref> [8] </ref>. However, there is a certain amount of confusion about what Chapman's undecidability results actually say, because some of his assumptions become clear only after a careful reading of the paper. <p> To prove this theorem, Chapman makes use of the following assumptions: 1. the planning language is function-free; 2. "an infinite [but recursive] set of constants t i are used to represent the tape squares" <ref> [8, p. 371] </ref>; 3. the initial state is infinite (but recursive). In particular, "there must be countably many successor propositions to encode the topology of the tape (and also countably many contents propositions to make all but finitely many squares blank)" [8, p. 371]. <p> t i are used to represent the tape squares" <ref> [8, p. 371] </ref>; 3. the initial state is infinite (but recursive). In particular, "there must be countably many successor propositions to encode the topology of the tape (and also countably many contents propositions to make all but finitely many squares blank)" [8, p. 371]. Our Corollary 3.8 subsumes this result, by showing that with the same set of assumptions, plan existence is undecidable even if all of the planning operators are positive and deletion-free. <p> Our Corollary 3.8 subsumes this result, by showing that with the same set of assumptions, plan existence is undecidable even if all of the planning operators are positive and deletion-free. In his discussion of the First Undecidability Theorem <ref> [8, p. 344] </ref>, Chapman says: This result is weaker than it may appear : : : the proof uses an infinite (though recursive) initial state to model the connectivity of the tape. <p> are both deletion-free and positive, then plan existence is decidable. 4.2 Second Undecidability Theorem The statement of Chapman's second undecidability theorem is that "planning is undecidable even with a finite initial state if the action representation is extended to represent actions whose effects are a function of their input situations" <ref> [8, p. 373] </ref>. The meaning of the phrase "effects are a function of their input situations" has caused some confusion. Several researchers, including ourselves [11] and Mark Peot (in his conference presentation of [31]), thought that Chapman meant a special case of the conditional operators defined in Section 3.4.2. <p> enabling-condition interactions are important for planning in general seem to be corroborated by some of our results, as discussed in Section 7.2 below. 6.2 Temporal Projection Another problem that is closely related to planning is the problem of temporal projection, or what Chapman calls the "modal truth" of an atom <ref> [8] </ref>. Given an atom a, an initial state S 0 , and a partially ordered set of actions P , the question is whether a is necessarily/possibly true after execution of P . This question is especially important in partial-order planners such as NOAH [13], NONLIN [14], and SIPE [15]. <p> One problem is what it means for a to be necessarily true if some of the total orderings of P are unexecutable. Chapman <ref> [8] </ref> assumes that a is necessarily true after executing P only if every total ordering of P is both executable and achieves a; and in return, he comes up with a polynomial-time algorithm for determining the necessary truth of a. <p> For comparison with Chapman's <ref> [8] </ref> results, Table 1 also includes decidability and undecidability results for the cases where we allow infinitely many constant symbols, infinite initial states, and operators with conditional effects. These results relate to Chapman's work as follows: 1. They solve an open problem posed in [8], regarding the decidability of planning if <p> For comparison with Chapman's <ref> [8] </ref> results, Table 1 also includes decidability and undecidability results for the cases where we allow infinitely many constant symbols, infinite initial states, and operators with conditional effects. These results relate to Chapman's work as follows: 1. They solve an open problem posed in [8], regarding the decidability of planning if infinitely many constants are allowed. Unless P is restricted to be positive or deletion free, the problem is undecidable. 2. It clarifies one of the results in [8]. <p> They solve an open problem posed in <ref> [8] </ref>, regarding the decidability of planning if infinitely many constants are allowed. Unless P is restricted to be positive or deletion free, the problem is undecidable. 2. It clarifies one of the results in [8]. In particular, whether or not the definition of a planning domain is extended to allow conditional planning operators makes no difference in any of our decidability and undecidability results.
Reference: [9] <author> Stephen V. Chenoweth. </author> <title> On the NP-hardness of blocks world. </title> <booktitle> In AAAI-91: Proc. Ninth National Conf. Artificial Intelligence, </booktitle> <pages> pp. 623-628, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Under this same set of goal interactions, they have also developed some efficient algorithms for merging plans to achieve multiple goals [41, 42]. Complexity results have been developed for blocks-world planning by Gupta and Nau [19, 20] and also by Chenoweth <ref> [9] </ref>. Gupta and Nau [19, 20] have shown that the complexity of blocks-world planning arises not from deleted-condition interactions as was previously thought, but instead from enabling-condition interactions.
Reference: [10] <author> Thomas Dean, and Mark Boddy. </author> <title> "Reasoning about Partially Ordered Events" Artificial Intelligence Journal, </title> <booktitle> 1988 pp. </booktitle> <pages> 375-399. </pages>
Reference-contexts: Theorem 3.11 If the language is allowed to contain infinitely many constants but P = (S 0 ; O) is restricted to be positive, deletion-free, and function-free (and S 0 is finite), then plan existence is decidable. 3.4.2 Conditional Operators Several researchers <ref> [8, 10, 31, 30] </ref> have been interested in actions whose effects are context dependent, that is, dependent on the input situation. Thus, we found it necessary to examine the complexity of planning with such operators. <p> Thus, we found it necessary to examine the complexity of planning with such operators. We will be using Dean's <ref> [10] </ref> formulation of these operators, which is a more general version of what Chapman [8] uses. 8 Tom Bylander (personal communication) has proved a more restricted version of this theorem, in which he requires that the planning operators be allowed to contain delete lists. <p> However, his algorithm does not work correctly for establishing the possible truth of a (in a paper currently in progress, we prove that problem is NP-hard). Chapman also proves that with conditional planning operators, establishing the necessary truth of a is co-NP-hard; and Dean and Boddy <ref> [10] </ref> prove a similar result with a more general notion of conditional planning operators (the same definition we use in Section 3.4.2). 12 Dean and Boddy [10] also try to come up with approximate solutions for the problem. <p> Chapman also proves that with conditional planning operators, establishing the necessary truth of a is co-NP-hard; and Dean and Boddy <ref> [10] </ref> prove a similar result with a more general notion of conditional planning operators (the same definition we use in Section 3.4.2). 12 Dean and Boddy [10] also try to come up with approximate solutions for the problem. They present algorithms for computing a subset of the propositions that are necessarily true, and for computing a superset of the propositions that are possibly true.
Reference: [11] <author> Kutluhan Erol, Dana S. Nau, and V. S. Subrahmanian. </author> <title> When is planning decidable? In Proc. </title> <booktitle> First Internat. Conf. AI Planning Systems, </booktitle> <year> 1992, </year> <pages> pp. 222-227. </pages>
Reference-contexts: Our results show that even with a number of additional restrictions, planning is still undecidable. We also correct a misimpression about this theorem, which has been thought by some researchers <ref> [31, 11] </ref> to refer to operators that have conditional effects. It does not| and as we mentioned above, our decidability and complexity results are unaffected by whether or not the operators have conditional effects. The rest of this paper is organized as follows. Section 2 contains the basic definitions. <p> The meaning of the phrase "effects are a function of their input situations" has caused some confusion. Several researchers, including ourselves <ref> [11] </ref> and Mark Peot (in his conference presentation of [31]), thought that Chapman meant a special case of the conditional operators defined in Section 3.4.2.
Reference: [12] <author> Richard E. Fikes, Nils J. Nilsson. </author> <title> "STRIPS: A New Approach to the Application of Theorem Proving to Problem Solving." </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 88-97. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues [5, 8, 19, 26, 27]. In the original STRIPS planner <ref> [12] </ref>, the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic. However, there were a number of problems with this formulation, such as the difficulty of providing a well-defined semantics for it [23].
Reference: [13] <author> Earl D. Sacerdoti. </author> <title> "The Nonlinear Nature of Plans." </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 162-170. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Given an atom a, an initial state S 0 , and a partially ordered set of actions P , the question is whether a is necessarily/possibly true after execution of P . This question is especially important in partial-order planners such as NOAH <ref> [13] </ref>, NONLIN [14], and SIPE [15].
Reference: [14] <author> Austin Tate. </author> <title> "Generating Project Networks" In James Allen, </title> <editor> James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 291-296. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Given an atom a, an initial state S 0 , and a partially ordered set of actions P , the question is whether a is necessarily/possibly true after execution of P . This question is especially important in partial-order planners such as NOAH [13], NONLIN <ref> [14] </ref>, and SIPE [15]. For example, McDermott [25] says "unfortunately, partial orders have a big problem, that there is no way of deciding what is true for sure before a step without considering all possible step sequences consistent with the current partial order," and Pednault [30] also expresses similar sentiments.
Reference: [15] <author> David E. Wilkins. </author> <title> "Domain independent Planning: Representation and Plan Generation" In James Allen, </title> <editor> James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 319-335. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Given an atom a, an initial state S 0 , and a partially ordered set of actions P , the question is whether a is necessarily/possibly true after execution of P . This question is especially important in partial-order planners such as NOAH [13], NONLIN [14], and SIPE <ref> [15] </ref>. For example, McDermott [25] says "unfortunately, partial orders have a big problem, that there is no way of deciding what is true for sure before a step without considering all possible step sequences consistent with the current partial order," and Pednault [30] also expresses similar sentiments.
Reference: [16] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: For more information on the relation between the complexity of optimization problems and the corresponding decision problems, see <ref> [16, pp. 115-117] </ref>. 5 This should be intuitively true, anyway, but the formal establishment of this equivalence is necessary before attempting to apply results from logic programming and deductive databases to planning problems. An important point to note is that we will only be considering truth in Herbrand models (cf.
Reference: [17] <author> R. L. Graham, D. E. Knuth, and O. Patashnik. </author> <title> Concrete Mathematics: a Foundation for Computer Science. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year> <note> REFERENCES 34 </note>
Reference-contexts: What really interests us, of course, is the problem of finding the shortest plan that achieves G. This problem is at least as difficult as plan length, and in some cases harder. For example, in the Towers of Hanoi problem [1] and certain generalizations of it <ref> [17] </ref>, the length of the shortest plan can be found in low-order polynomial time|but actually producing this plan requires exponential time and space, since the plan has exponential length.
Reference: [18] <author> C. Green. </author> <title> "Application of Theorem-Proving to Problem Solving," </title> <booktitle> Proc. </booktitle> <address> IJCAI-69, </address> <year> 1969. </year>
Reference-contexts: We now show that when L contains no function symbols, we can do away with delete lists. The idea is intuitively the same as that of Green <ref> [18, 28] </ref> (vis-a-vis the famous "Green's formulation of planning"), with one difference: Green introduces function symbols even if the original language contained none: we introduce new constants. When the language is function-free, only finitely many new constants are included.
Reference: [19] <author> Naresh Gupta and Dana S. Nau. </author> <title> "Complexity Results for Blocks-World Planning," </title> <booktitle> Proc. AAAI-91, </booktitle> <year> 1991. </year> <note> Honorable mention for the best paper award. </note>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity [8, 5, 19, 20, 26, 27]. This research has yielded some surprising results. For example, Gupta and Nau <ref> [19, 20] </ref> have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. Pednault [30] suggests that since planning is intractable in general, researchers should try to identify constraints that will lead to efficient planning. <p> Section 6 discusses the related work. Section 7 contains concluding remarks. Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues <ref> [5, 8, 19, 26, 27] </ref>. In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic. <p> Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in <ref> [7, 21, 28, 37, 40, 19, 20] </ref>. Thus, from results proved in [20], it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions. <p> Under this same set of goal interactions, they have also developed some efficient algorithms for merging plans to achieve multiple goals [41, 42]. Complexity results have been developed for blocks-world planning by Gupta and Nau <ref> [19, 20] </ref> and also by Chenoweth [9]. Gupta and Nau [19, 20] have shown that the complexity of blocks-world planning arises not from deleted-condition interactions as was previously thought, but instead from enabling-condition interactions. <p> Under this same set of goal interactions, they have also developed some efficient algorithms for merging plans to achieve multiple goals [41, 42]. Complexity results have been developed for blocks-world planning by Gupta and Nau <ref> [19, 20] </ref> and also by Chenoweth [9]. Gupta and Nau [19, 20] have shown that the complexity of blocks-world planning arises not from deleted-condition interactions as was previously thought, but instead from enabling-condition interactions.
Reference: [20] <author> Naresh Gupta and Dana S. Nau, </author> <title> "On the Complexity of Blocks-World Planning," </title> <booktitle> Artificial Intelligence 56 </booktitle> <month> 2-3 </month> <year> (1992), </year> <pages> pp. 223-254. </pages>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity [8, 5, 19, 20, 26, 27]. This research has yielded some surprising results. For example, Gupta and Nau <ref> [19, 20] </ref> have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. Pednault [30] suggests that since planning is intractable in general, researchers should try to identify constraints that will lead to efficient planning. <p> The reason for this is as follows. For plan existence, the restrictions allowed us to plan for each subgoal separately, using backwards chaining. We cannot do this for plan length, because of enabling-condition interactions. Enabling-condition interactions are discussed in more detail in <ref> [20] </ref>, but the basic idea is that a sequence of actions that achieves one subgoal might also achieve other subgoals or make it easier to achieve them. Although such interactions will not affect plan existence, they will affect plan length, because they make it possible to produce a shorter plan. <p> Let S be the current state, and b be any block. If the stack of blocks from b down to the table is consistent with the goal conditions (whether or not this is so can be determined in polynomial time <ref> [20] </ref>), then b need not be moved. Otherwise, there are three possibilities: 1. <p> Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in <ref> [7, 21, 28, 37, 40, 19, 20] </ref>. Thus, from results proved in [20], it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions. <p> Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in [7, 21, 28, 37, 40, 19, 20]. Thus, from results proved in <ref> [20] </ref>, it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions. As a result, planning is much more complex than in the previous case. <p> Under this same set of goal interactions, they have also developed some efficient algorithms for merging plans to achieve multiple goals [41, 42]. Complexity results have been developed for blocks-world planning by Gupta and Nau <ref> [19, 20] </ref> and also by Chenoweth [9]. Gupta and Nau [19, 20] have shown that the complexity of blocks-world planning arises not from deleted-condition interactions as was previously thought, but instead from enabling-condition interactions. <p> Under this same set of goal interactions, they have also developed some efficient algorithms for merging plans to achieve multiple goals [41, 42]. Complexity results have been developed for blocks-world planning by Gupta and Nau <ref> [19, 20] </ref> and also by Chenoweth [9]. Gupta and Nau [19, 20] have shown that the complexity of blocks-world planning arises not from deleted-condition interactions as was previously thought, but instead from enabling-condition interactions. <p> This is because what makes the problem hard is how to handle enabling-condition interactions, i.e., how to choose operators that achieve several sub-goals in order to minimize the overall length of the plan <ref> [20] </ref>, and this task remains equally hard regardless of whether negated preconditions are allowed. 5. Delete lists are more powerful than negated preconditions. Thus, if the operators are allowed to have delete lists, then whether or not they have negated preconditions has no effect on the complexity.
Reference: [21] <author> Kluzniak and Szapowicz. </author> <title> extract from APIC studies in data processing no. 24. </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 140-153. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in <ref> [7, 21, 28, 37, 40, 19, 20] </ref>. Thus, from results proved in [20], it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions.
Reference: [22] <author> Korf, R.E., </author> <title> "Planning as Search: A Quantitative Approach," </title> <booktitle> Artificial Intelligence 33, </booktitle> <year> 1987, </year> <pages> 65-88. </pages>
Reference-contexts: It is not very easy to compare our results with theirs, because we use a different formalism|but we can 7 CONCLUSION 29 safely state that we analyze a much broader range of problems, and we require less severe restrictions to get polynomial-time results. Korf <ref> [22] </ref> has pointed out that given certain assumptions, one can reduce exponentially the time required to solve a conjoined-goal planning problem, provided that the individual goals are independent.
Reference: [23] <author> Vladimir Lifschitz. </author> <title> "On the Semantics of STRIPS." </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 523-530. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic. However, there were a number of problems with this formulation, such as the difficulty of providing a well-defined semantics for it <ref> [23] </ref>. Thus, in subsequent work, researchers have placed severe restrictions on the nature of the planning operators [28]. Typically, the precondition lists, add lists and delete lists contain only atoms, and the goal is a conjunct of ground or existentially quantified atoms.
Reference: [24] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming, </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference: [25] <author> Drew McDermott. </author> <booktitle> "Regression Planning" International Journal of Intelligent Systems 6 (1991), </booktitle> <pages> pp. 357-416. </pages>
Reference-contexts: This question is especially important in partial-order planners such as NOAH [13], NONLIN [14], and SIPE [15]. For example, McDermott <ref> [25] </ref> says "unfortunately, partial orders have a big problem, that there is no way of deciding what is true for sure before a step without considering all possible step sequences consistent with the current partial order," and Pednault [30] also expresses similar sentiments. <p> As a result, much of the current work in planning is without much theoretical basis. For example, in his paper on regression planning <ref> [25] </ref>, McDermott states that : : : there are two main choices in the space of refinement planners: (1) a heuris tic, nonlinear, progressive planner, and (2) a rigorous, linear, regressive planner.
Reference: [26] <author> S. Minton, J. Bresna and M. Drummond. </author> <title> "Commitment strategies in planning," </title> <booktitle> Proc. IJCAI-91, </booktitle> <year> 1991. </year>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> Section 6 discusses the related work. Section 7 contains concluding remarks. Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues <ref> [5, 8, 19, 26, 27] </ref>. In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic.
Reference: [27] <author> D. McAllester and D. Rosenblitt. </author> <title> "Systematic nonlinear planning," </title> <booktitle> Proc. AAAI-91, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 INTRODUCTION 3 Despite the acknowledged difficulty of planning, it is only recently that researchers have begun to examine the computational complexity of planning problems and the reasons for that complexity <ref> [8, 5, 19, 20, 26, 27] </ref>. This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. <p> Section 6 discusses the related work. Section 7 contains concluding remarks. Section 7.3 discusses future research directions. The proofs of the theorems and lemmas appear in the appendices. 2 Preliminaries Researchers in planning have long been interested in planning with STRIPS-style operators, and this interest still continues <ref> [5, 8, 19, 26, 27] </ref>. In the original STRIPS planner [12], the planning operators' precondition lists, add lists, and delete lists were allowed to contain arbitrary well-formed formulas in first-order logic.
Reference: [28] <author> N. J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Tioga, </publisher> <address> Palo Alto, </address> <year> 1980. </year>
Reference-contexts: However, there were a number of problems with this formulation, such as the difficulty of providing a well-defined semantics for it [23]. Thus, in subsequent work, researchers have placed severe restrictions on the nature of the planning operators <ref> [28] </ref>. Typically, the precondition lists, add lists and delete lists contain only atoms, and the goal is a conjunct of ground or existentially quantified atoms. Our definitions below are in accordance with such commonly accepted formulations. <p> Example 2.1 (Blocks World) Suppose we want to talk about a blocks-world planning domain in which there are five blocks a; b; c; d; e, along with the "stack", "unstack", "pickup", and "putdown" operators used by Nilsson <ref> [28] </ref>. Suppose the initial configuration is as shown in Fig. 1 (a), and the goal is to have b on c on d, as shown in Fig. 1 (b). Then we will define the language, operators, planning domain, and planning problem as follows: 1. <p> We now show that when L contains no function symbols, we can do away with delete lists. The idea is intuitively the same as that of Green <ref> [18, 28] </ref> (vis-a-vis the famous "Green's formulation of planning"), with one difference: Green introduces function symbols even if the original language contained none: we introduce new constants. When the language is function-free, only finitely many new constants are included. <p> Since this extension to Bylander's formulation allows stack-to-stack moves, there is a one-to-one correspondence between plans in this formulation and the more usual formulations of the blocks world, such as those given in <ref> [7, 21, 28, 37, 40, 19, 20] </ref>. Thus, from results proved in [20], it follows that in this extension of Bylander's formulation, plan length is np-complete. 5.2.3 Datalog Operators Below, we no longer restrict the predicates to be propositions.
Reference: [29] <author> Earl D. Sacerdoti. </author> <title> "Planning in a hierarchy of abstraction spaces." </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 98-108. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year> <note> Originally appeared in Artificial Intelligence 5 (1974), 115-135. </note>
Reference: [30] <author> Edwin P. D. Pednault. </author> <title> "Synthesizing Plans that Contain Actions with Context-dependent Effects" Computational Intelligence 4 (1988), </title> <journal> pp. </journal> <pages> 356-372. </pages>
Reference-contexts: This research has yielded some surprising results. For example, Gupta and Nau [19, 20] have shown that contrary to prior expectations, deleted-condition interactions are easy to handle in blocks-world planning. Pednault <ref> [30] </ref> suggests that since planning is intractable in general, researchers should try to identify constraints that will lead to efficient planning. The current paper addresses this goal, by examining how the complexity of domain-independent planning depends on the nature of the planning operators. <p> Theorem 3.11 If the language is allowed to contain infinitely many constants but P = (S 0 ; O) is restricted to be positive, deletion-free, and function-free (and S 0 is finite), then plan existence is decidable. 3.4.2 Conditional Operators Several researchers <ref> [8, 10, 31, 30] </ref> have been interested in actions whose effects are context dependent, that is, dependent on the input situation. Thus, we found it necessary to examine the complexity of planning with such operators. <p> For example, McDermott [25] says "unfortunately, partial orders have a big problem, that there is no way of deciding what is true for sure before a step without considering all possible step sequences consistent with the current partial order," and Pednault <ref> [30] </ref> also expresses similar sentiments. One problem is what it means for a to be necessarily true if some of the total orderings of P are unexecutable.
Reference: [31] <author> M. A. Peot. </author> <title> "Conditional Nonlinear Planning" In Proc. </title> <booktitle> First Internat. Conf. AI Planning Systems, </booktitle> <year> 1992, </year> <pages> pp. 189-197. </pages>
Reference-contexts: Our results show that even with a number of additional restrictions, planning is still undecidable. We also correct a misimpression about this theorem, which has been thought by some researchers <ref> [31, 11] </ref> to refer to operators that have conditional effects. It does not| and as we mentioned above, our decidability and complexity results are unaffected by whether or not the operators have conditional effects. The rest of this paper is organized as follows. Section 2 contains the basic definitions. <p> Theorem 3.11 If the language is allowed to contain infinitely many constants but P = (S 0 ; O) is restricted to be positive, deletion-free, and function-free (and S 0 is finite), then plan existence is decidable. 3.4.2 Conditional Operators Several researchers <ref> [8, 10, 31, 30] </ref> have been interested in actions whose effects are context dependent, that is, dependent on the input situation. Thus, we found it necessary to examine the complexity of planning with such operators. <p> The meaning of the phrase "effects are a function of their input situations" has caused some confusion. Several researchers, including ourselves [11] and Mark Peot (in his conference presentation of <ref> [31] </ref>), thought that Chapman meant a special case of the conditional operators defined in Section 3.4.2.
Reference: [32] <author> D.A. Plaisted. </author> <title> "Complete Problems in the First-Order Predicate Calculus," </title> <booktitle> Jour. Computer and Systems Sciences 29 (1984), </booktitle> <pages> pp. 8-35. </pages>
Reference-contexts: Obviously, this is not relevant to planning. Thus, when we talk of logical consequences of programs, we will be referring to those sentences that are true in all Herbrand models of the program. For function-free languages, this condition is well known to yield decidability of logical consequence <ref> [32, 39] </ref>. 6 The only exception is when L is extended to contain infinitely many constants.
Reference: [33] <author> Earl D. Sacerdoti. </author> <title> "The nonlinear nature of plans." </title> <editor> In James Allen, James Hendler, and Austin Tate, editors, </editor> <booktitle> Readings in Planning, </booktitle> <pages> pp. 206-214. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year> <note> Originally appeared in Proc. IJCAI-75. </note>
Reference: [34] <author> J. Sebelik and P. Stepanek. </author> <title> "Horn Clause Programs for Recursive Functions." </title> <editor> In K. Clark and S.-A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pp. 325-340. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [35] <author> J. Shoenfield. </author> <title> Mathematical Logic, </title> <publisher> Academic Press, </publisher> <year> 1967. </year>
Reference-contexts: An important point to note is that we will only be considering truth in Herbrand models (cf. Shoenfield <ref> [35] </ref>) in this paper. Our undecidability/decidability results rely on this fact.
References-found: 35

