URL: http://siesta.cs.wustl.edu/~engel/doc/Europlop96.ps.gz
Refering-URL: http://siesta.cs.wustl.edu/~engel/
Root-URL: http://www.cs.wustl.edu
Title: Making Design Patterns explicit in FACE, a Framework Adaptive Composition Environment  
Author: Theo Dirk Meijler, Robert Engel 
Address: 2  
Affiliation: Software Composition Group, University of Berne 1 Washington University, Computer Science Department  
Abstract: Creating applications using object-oriented frameworks is done at a relatively low abstraction level, leaving a large gap with the high abstraction level of a design. This makes the use of a framework difficult, and allows design and realization to diverge. Design patterns are more specific elements of design, and thus reduce this gap. We even bridge this gap by making design patterns and the classes that play a role within them into special purpose software components. System realization becomes a matter of composing special purpose class-components. We also introduce a system, FACE, which supports the visual composition of such specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Don Batory and Sean OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems With Reusable Components, </title> <journal> ACM Transactions on Software Engr. and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference: [2] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci and Marty Sirkin, </author> <title> The GenVoca Model of Software-System Generators, </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1994, </year> <pages> pp. 89-94. </pages>
Reference: [3] <author> Grady Booch and James Rumbaugh, </author> <title> Unified Method for Object-Oriented Development Version 0.8, Rational Software Corporation, </title> <year> 1995. </year>
Reference-contexts: Understanding is also needed of how the classes cooperate, thus how the implementation corresponds to the overall design. On the other hand, while a high-level simple design description to understand a system is clearly needed, currently used design notations, such as e.g. a class-diagram <ref> [3] </ref>, are too generic to convey the intent of the design. The gap between the relative low abstraction level of the realization and the high abstraction level of the design is even such that the realization and the design are causally independent. <p> The main contribution of this approach is that such object-level system composition can be complemented by composition of domain specific class-components, which is at a similar high level of abstraction, and close to a traditional design (in e.g, the Unified Method <ref> [3] </ref>), but is also close to a realization. <p> It refers via special purpose slots for each of the roles in the pattern to all the class-components that play that specific role. 2. Class-components are shown represented by rectangles with a line as is normal in (e.g.,) the unified method <ref> [3] </ref>. Although class-components are like classes, in that they may have instances at run-time, there are two main reasons why we use this term instead of classes. Firstly, they are domain specific components used to compositionally specify a system.
Reference: [4] <author> Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, </author> <title> Design Patterns, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: Louis, MO 63130, USA. Tel: +1 (314) 935 8501. E-mail: engel@cs.wustl.edu. WWW: http://siesta.cs.wustl.edu/~engel. 2. Making Design Patterns explicit in FACE, a Framework the design. The realization may thus introduce classes that have not been given by the design, but even worse, it may break the design. Design patterns <ref> [4] </ref> do not only provide solutions for building flexible systems. They are also important in reducing the gap between implementation and design. They provide more special purpose design elements, and make it easier to understand, at implementation level, the connection with the design. <p> Thus, design and realization no longer need to be separate 1 That systems may be specified at a high level of abstraction in terms of compositions of domain specific objects is becoming good practice as several of the well-known design patterns show <ref> [4] </ref>. The main contribution of this approach is that such object-level system composition can be complemented by composition of domain specific class-components, which is at a similar high level of abstraction, and close to a traditional design (in e.g, the Unified Method [3]), but is also close to a realization. <p> We stress that all discussions that are specific for the state pattern illustrate a general approach. 2 Short Description of the State Design Pattern The main example in this paper will be the State design pattern. We refer to <ref> [4] </ref> for details. The state design pattern is used when an object has to exhibit state dependent behaviour, that is, dependent on the state the object reacts differently to the same requests for operation execution. <p> It changes state by exchanging that object. The TCP network protocol implementation that is an example of the use of the state pattern is taken from [5]. The solution is somewhat different from the standard solution <ref> [4] </ref> in that, in stead of the context object (here called a protocol object) directly reacting to messages, and delegating these to its state object, there will be a request object 1 that represents the operation to be executed. <p> FACE may present such a structure in a similar way 1. In [5] this is called a messenger object. We follow however the general terminology in <ref> [4] </ref>. refers in its property state to one of the state objects. Each of these state objects is a singleton instance of the classes given at the right side. The figure shows a typical sequence of messages. <p> Specialization of a class-component is thus done by means of parameterization and linking (composing) only. There are special purpose class-components for each of the different roles that classes may play in the design pattern: In this example, as corresponding to the terminology in <ref> [4] </ref>, there are operation class-components (represented by an O) the instances of which represent requests (called messenger objects in [5]) that can be executed by the protocol object. <p> The implementation of its instances will be specified elsewhere in an underlying programming language. The question is thus, how a class-component can create an instance. This is realized by applying the prototype design pattern <ref> [4] </ref>: Each class-component carries a prototype instance, that it may copy to create a new instance.
Reference: [5] <author> Hermann Hueni, Ralph E. Johnson and Robert Engel, </author> <title> A Framework for Network Protocol Software, Proceedings OOPSLA 95, </title> <journal> ACM SIGPLAN Notices, </journal> <note> to appear. </note>
Reference-contexts: The object delegates requests that have to be handled state depend ently to another object (the state object). It changes state by exchanging that object. The TCP network protocol implementation that is an example of the use of the state pattern is taken from <ref> [5] </ref>. The solution is somewhat different from the standard solution [4] in that, in stead of the context object (here called a protocol object) directly reacting to messages, and delegating these to its state object, there will be a request object 1 that represents the operation to be executed. <p> In contrast to the diagram in figure 1, this is not a figure that merely represents a design: It is a direct representation of the class-component structure, and thus (with details left out) of a realization. FACE may present such a structure in a similar way 1. In <ref> [5] </ref> this is called a messenger object. We follow however the general terminology in [4]. refers in its property state to one of the state objects. Each of these state objects is a singleton instance of the classes given at the right side. <p> Only subclasses are shown for states needed to establish a connection and for the closed state. Note that we shall call messengers as used in <ref> [5] </ref> requests in the text. state [ ] [ ]theInstanceTCPEstablished [ ]theInstanceTCPClose 4.TCPClose::instance 3.close (cm,p) aProtocol p aTCPEstablished ts 1.accept (cm) aCloseMessenger cm 2.apply (ts,p) TCPState PassiveOpen ActiveOpen Send Close TCPClosed PassiveOpen ActiveOpen Send Close TCPListen PassiveOpen ActiveOpen Send Close TCPEstablished PassiveOpen ActiveOpen Send Close TCPActiveOpen PassiveOpen ActiveOpen Send Close Theo <p> There are special purpose class-components for each of the different roles that classes may play in the design pattern: In this example, as corresponding to the terminology in [4], there are operation class-components (represented by an O) the instances of which represent requests (called messenger objects in <ref> [5] </ref>) that can be executed by the protocol object. There is one context class-component (represented by a C) here with the name TCPProtocol, the instance of which represents the protocol object the figure are special purpose components. The rectangles with a line in them are class-components. <p> The question is thus, how a class-component can create an instance. This is realized by applying the prototype design pattern [4]: Each class-component carries a prototype instance, that it may copy to create a new instance. Following the description of Hueni et.al. <ref> [5] </ref>, state class-components will only have one instance: When the class-component is requested for an instance, it will always directly return its prototype instance. up-call to its class-component, in this case to TCPClosed. TCPClosed finds the concrete operation descriptor for PassiveOpen.
Reference: [6] <author> Ralph E. Johnson and Brian Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, no. 2, </volume> <year> 1988, </year> <pages> pp. 22-35. </pages>
Reference-contexts: 1 Introduction When comparing the development of applications using frameworks <ref> [6] </ref> to the development of applications using libraries or from scratch, using a framework is after a learning period significantly less labour intensive [19]. Thus frameworks have a large commercial value. Still, the use and evolution of a framework has many pitfalls.
Reference: [7] <author> Gregor Kiczales, Jim des Rivires and Daniel G. Bobrow, </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press (Ed.), </publisher> <year> 1991. </year>
Reference-contexts: From a point of view of programming languages, special purpose class-components are framework specific abstractions. There are two principal ways of realizing the semantics of such abstractions: 1. By mapping them to lower-level general abstractions; that is, through an extensible compiler 2. By using ideas from Metaobject Protocols <ref> [7] </ref> (MOPs). We use approach 2 as described in the following. Approach 1 is under research in our group as well [22], but will not be discussed in this paper. In our approach, class-components are reified (explicitly represented) at run-time as objects as is usual in MOPs. <p> His approach in letting a separate pattern class (comparable to our container component) disentangle the dependencies between the classes seems interesting. This work has roots in the area of open programming languages such as CLOS <ref> [7] </ref>, and in Open Implementations [23]. Open programming languages such as CLOS reify their software components (classes), but the reification is not black-box the reification is too complex, and 12.
Reference: [8] <author> Wolfgang Klas, E.J. Neuhold and Michael Schrefl, </author> <title> Metaclasses in VODAK and their Application in Database Integration, </title> <journal> Arbeitpapiere der GMD, </journal> <volume> no. 462, </volume> <year> 1990 </year> . 
Reference-contexts: Making Design Patterns explicit in FACE, a Framework it is difficult to create drastically different components because of the intricate cooperation between all parts of the reified class. The way in which we use reification and reection is close to the model of Klas and Neuhold <ref> [8] </ref>. They focus on adaptive data models for databases systems, not so much on frameworks and application development. We also think that our model is simpler and thus easier to understand and use.
Reference: [9] <author> John Lamping, </author> <title> Typing the Specialization Interface, Proceedings OOPSLA 93, </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> vol. 28, no. 10, </volume> <month> Oct. </month> <year> 1993, </year> <pages> pp. 201-214. </pages>
Reference-contexts: Many problems are due to the large gap between realizing a system and designing a system. Realizing a system using a framework is done at a low abstraction level. It often requires the creation of subclasses, which requires a profound knowledge of the implementation of the superclass <ref> [9] </ref>. Understanding is also needed of how the classes cooperate, thus how the implementation corresponds to the overall design.
Reference: [10] <author> Simon Lippman, </author> <title> The C++ Primer, Second Edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991, </year> <month> (3). </month>
Reference-contexts: This may serve as an important model! 2. Note that this kind of parameterization goes much further than the parameterization used in template classes as in C++ <ref> [10] </ref> Theo Dirk Meijler, Robert Engel 3. In this paper we illustrate the approach. We focus on the ideas for class-level composition. We shall use the state design pattern as our example.
Reference: [11] <author> Christina V. Lopes, Karl J. Lieberherr, </author> <title> AP/S++: Case-Study of a MOP for Purposes of Software Evolution, Proceedings Reflection 96, </title> <note> to appear. </note>
Reference: [12] <author> Karl J. Lieberherr, Ignacio Silva-Lepe, Cun Xiao, </author> <title> Adaptive object-oriented programming using graph-based customization, </title> <journal> Commun of the ACM, </journal> <volume> Vol 37, no. 5, </volume> <month> May </month> <year> 1993, </year> <pages> pp 94-101. </pages>
Reference: [13] <author> Jeff Magee, Naranker Dulay and Jeffrey Kramer, </author> <title> Structuring Parallel and Distributed Programs, </title> <booktitle> Proceedings of the International Workshop on Configurable Distributed Systems, </booktitle> <address> London, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: The Standard Template Library STL [20] shows the power of applying this idea. Also the work of Batory et. al. [1][2] is based on parameterizing class-level components with class-level components. The work of McGee and Kramer on Darwin <ref> [13] </ref> represents another form of class-level composition: Links between components basically describe communication possibilities between the instances. The model such as presented here may encompass both forms of composition due to the fact that the semantics of a connection is not fixed (can be defined at the meta-level).
Reference: [14] <author> Marti Mntyl, Dana Nau and Jami Shah, </author> <title> Challenges in Feature-Based Manufacturing Research, </title> <journal> CACM, </journal> <volume> vol. 39, no. 2, </volume> <month> February </month> <year> 1996, </year> <pages> pp. 77-85 </pages>
Reference-contexts: This thus shows the power of the approach to class-composition. Moreover, it allows to let visual composition, and the running of applications be specified by means of visual composition to form a seamless whole. 1. We note that, as described in the CACM of february 1996 <ref> [14] </ref>, it is already possible in the area of manufacturing to have a similar direct connection between the design of a product and the realization of the corresponding manufacturing process. This may serve as an important model! 2.
Reference: [15] <author> Theo Dirk Meijler, </author> <title> User-level Integration of Data and Operation Resources by means of a Self-descriptive Data Model, </title> <type> Ph.D. Thesis, </type> <institution> Erasmus University Rotterdam, </institution> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: This is also done by means of association descriptors. For instance the subtype association descriptor between Abstract 1. We have not, and will not give details about subtyping in this paper. See <ref> [15] </ref> for details. Basically, a subtype may extend or specialize the compositional interface (as defined through association descriptors) as defined by the supertype, and it will extend or specialize the run-time interface in terms of operations and messages that can be handled. with double lines at the sides. <p> Making Design Patterns explicit in FACE, a Framework State and ConcreteState describes that an abstract state class-component has several instances of ConcreteState as subtype. The figure shows that meta-class-components have primal-classes <ref> [15] </ref>. These primal classes serve a double role: As the prototype, and as the supertype of class-components that may be instantiated. Primal-classes serve as the prototype that will be copied in order to create an instance of the meta-class-component. <p> FACE will be finished to the extent that a demonstration of the example described will be possible by the publication of this paper. Our trust in the correctness of these ideas is based on a theoretical foundation in <ref> [15] </ref>, preliminary experiments with implementation, and our first experiences of using these ideas to build the framework for supporting visual composition. Having a demonstration of an applied isolated design pattern is not sufficient to demonstrate the approach.
Reference: [16] <author> Vicki de Mey, </author> <title> Visual Composition of Software Applications, </title> <booktitle> in [21], </booktitle> <pages> pp. 275-303. </pages>
Reference-contexts: Thus class-level composition is not supported. Cooperations between components have to be explicitly implemented in the methods (event procedures) defined on each of them: There is no such thing as simply connecting components to specify their cooperation. Thus VB does not really specify object composition. Vista <ref> [16] </ref> is a visual tool that does support object composition, and that can be adapted to the composition rules. Vista does not provide a way to give class-level compositions a run-time semantic.
Reference: [17] <author> Bertrand Meyer, </author> <title> Eiffel: The Language, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference: [18] <author> Microsoft Corporation, </author> <title> Visual Basic Programmers Guide, </title> <year> 1993 </year> . 
Reference-contexts: The user will be informed by means of a graphical clue whether or not a connection may be made. 8 Related work There is a growing interest in building systems by means of composition. Commercially, so-called component-ware [27] has been successful. Visual Basic <ref> [18] </ref> (VB) is a well known example of a component-ware environment. One of the connections VB has with this work is that it allows for visual realization of a system. Components in VB are instantiated at run-time.
Reference: [19] <author> Simon Moser and Oscar Nierstrasz, </author> <title> Measuring the Effects of Object-Oriented Frameworks on the Software Process, </title> <note> submitted for publication, IAM, </note> <editor> U. Berne, </editor> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction When comparing the development of applications using frameworks [6] to the development of applications using libraries or from scratch, using a framework is after a learning period significantly less labour intensive <ref> [19] </ref>. Thus frameworks have a large commercial value. Still, the use and evolution of a framework has many pitfalls. Many problems are due to the large gap between realizing a system and designing a system. Realizing a system using a framework is done at a low abstraction level.
Reference: [20] <author> David R. Musser and Atul Saini, </author> <title> STL Tutorial and Reference Guide, </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <title> 14. Making Design Patterns explicit in FACE, a Framework </title>
Reference-contexts: Composition at the level of classes (although not visually supported) is especially encountered in generic constructs, where classes can be parameterized with other classes, such as in the template classes in C++. The Standard Template Library STL <ref> [20] </ref> shows the power of applying this idea. Also the work of Batory et. al. [1][2] is based on parameterizing class-level components with class-level components. The work of McGee and Kramer on Darwin [13] represents another form of class-level composition: Links between components basically describe communication possibilities between the instances.
Reference: [21] <editor> Oscar Nierstrasz and Dennis Tsichritzis (Ed.), </editor> <booktitle> Object-Oriented Software Composition, </booktitle> <publisher> Pren-tice Hall, </publisher> <year> 1995. </year>
Reference: [22] <editor> Oscar Nierstrasz, </editor> <booktitle> Research Topics in Software Composition, Proceedings, Langages et Modles Objets, </booktitle> <address> Nancy, </address> <month> Oct. </month> <year> 1995, </year> <pages> pp. 193-204. </pages>
Reference-contexts: By mapping them to lower-level general abstractions; that is, through an extensible compiler 2. By using ideas from Metaobject Protocols [7] (MOPs). We use approach 2 as described in the following. Approach 1 is under research in our group as well <ref> [22] </ref>, but will not be discussed in this paper. In our approach, class-components are reified (explicitly represented) at run-time as objects as is usual in MOPs. Thus all links and parameters of class-components are explicitly accessible at run-time as well.
Reference: [23] <author> Ramana Rao, </author> <title> Implementational Reflection in Silica, </title> <booktitle> Proceedings ECOOP 91, </booktitle> <editor> P. America (Ed.), </editor> <publisher> LNCS 512, Springer-Verlag, </publisher> <address> Geneva, Switzerland, </address> <month> July 15-19, </month> <year> 1991, </year> <pages> pp. 251-267. </pages>
Reference-contexts: His approach in letting a separate pattern class (comparable to our container component) disentangle the dependencies between the classes seems interesting. This work has roots in the area of open programming languages such as CLOS [7], and in Open Implementations <ref> [23] </ref>. Open programming languages such as CLOS reify their software components (classes), but the reification is not black-box the reification is too complex, and 12.
Reference: [24] <author> Alan Snyder, </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages, Proceedings OOPSLA 86, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 21, no. 11, </volume> <month> Nov </month> <year> 1986, </year> <pages> pp. 38-45. </pages>
Reference: [25] <author> Jiri Soukop, </author> <title> Implementing Patterns, Pattern Languages of Program Design, </title> <note> Addison Wes-ley 1995, Chapter 20. </note>
Reference-contexts: This paper describes links between classes (the transition descriptors) which fit in neither of these forms. These kind of links play an important role in the compositional instantiation of a design pattern. Jiri Soukop <ref> [25] </ref> has described the possibility of making design patterns concrete. Certain similarities may be observed, especially in the strong use of genericity.
Reference: [26] <author> Patrick Steyaert, K. De Hondt, S. Demeyer, N. Boyen and M. de Molder, </author> <title> Reflective User Interface Builders, </title> <booktitle> Proceedings Meta95, </booktitle> <editor> C. Zimmerman (Ed.), </editor> <year> 1995 </year> . 
Reference-contexts: They focus on adaptive data models for databases systems, not so much on frameworks and application development. We also think that our model is simpler and thus easier to understand and use. Steyaert <ref> [26] </ref> has described how the use of a meta-level interface could be applied to provide powerful configuration capabilities for user interface builders. Also, by the use of reection new kinds of components could be described using the composition environment itself.
Reference: [27] <author> James Udell, </author> <title> Componentware, </title> <journal> Byte, </journal> <volume> vol. 19, no. 5, </volume> <month> May </month> <year> 1994, </year> <pages> pp. 46-56. </pages>
Reference-contexts: The user will be informed by means of a graphical clue whether or not a connection may be made. 8 Related work There is a growing interest in building systems by means of composition. Commercially, so-called component-ware <ref> [27] </ref> has been successful. Visual Basic [18] (VB) is a well known example of a component-ware environment. One of the connections VB has with this work is that it allows for visual realization of a system. Components in VB are instantiated at run-time.
References-found: 27

