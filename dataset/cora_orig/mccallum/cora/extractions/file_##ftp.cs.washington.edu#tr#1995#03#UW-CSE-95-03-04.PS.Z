URL: file://ftp.cs.washington.edu/tr/1995/03/UW-CSE-95-03-04.PS.Z
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/publications.html
Root-URL: 
Email: fchou,ortega,gaetanog@cs.washington.edu.  
Title: The Chinook Hardware/Software Co-Synthesis System 1  
Author: Pai Chou, Ross Ortega, Gaetano Borriello 
Note: an ONR monitored contract (N00014-91-J-4041). The authors' email addresses are  
Address: Box 352350 Seattle, WA 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: Technical Report 95-03-04 March 14, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Boussinot and R. De Simone. </author> <booktitle> The Esterel language. Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference: [2] <author> CADENCE Design Systems, Inc. </author> <title> Programming Language Interface Reference Manual. CADENCE Design Systems, </title> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: As the synthesis steps refine abstract communications and operations into more concrete signals and components, outputs from intermediate design steps and the final implementation can also be simulated with cycle-level accuracy. The simulator uses the Verilog-XL Programming Language Interface <ref> [2] </ref> to communicate with peripheral device models.
Reference: [3] <author> D. Cathey. </author> <title> All things considered... important factors in choosing a real-time development system. Real-Time Magazine, </title> <booktitle> 2nd quarter 1993. </booktitle>
Reference-contexts: Their interaction with the devices and the environment must respect not only low-level signaling constraints but also performance requirements such as rate and response time constraints. To satisfy these high-level constraints, designers have used process-based scheduling techniques based on operating systems concepts <ref> [17, 3] </ref>. These techniques are coarse-grained, priority-driven, and dynamically preemptive. They assume that the processor does not perform I/O directly and the processes are independent of each other. Since all timing constraints are coarse-grained, overhead incurred by the executive during preemption can be dismissed.
Reference: [4] <author> M. Chiodo et al. </author> <title> Hardware-software codesign of embedded systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 26-36, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time intensive and some times impossible. Several formal specification methods have been proposed including finite state machines <ref> [4] </ref>, Petri nets [18], and CSP [15]. Today's tools lie somewhere in the middle - specifications are written in a high-level programming or hardware description language that is simulatable. This enables some early validation of the design.
Reference: [5] <author> P. Chou and G. Borriello. </author> <title> Software scheduling in the co-synthesis of reactive real-time systems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: We do not use critical regions to achieve atomic execution because they disable interleaving, which is necessary when servicing devices with long separation between sequential events. Instead, Chinook allows the user to define safe points in the handlers, where potential mode transitions can safely occur <ref> [5] </ref>. All parallel handlers must reach their safe points before a mode transition is allowed to take effect. 6 Interface Synthesis Interface synthesis is the realization of communication between components via both hardware and software elements. Chinook handles a wide range of interface synthesis problems.
Reference: [6] <author> P. Chou and G. Borriello. </author> <title> Interval scheduling: Fine-grained software scheduling for embedded systems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: A customized dynamic scheduler may be generated for the larger modes (i.e., those at the top of the mode hierarchy). Chinook uses a static, nonpreemptive scheduling algorithm to meet min/max timing constraints on fine-grained operations with delay ranges <ref> [6] </ref>. It determines a serial ordering for the operations, and inserts delays to meet minimum constraints, if necessary. Because the complexity of the problem is NP-hard, we employ heuristic ordering functions to help the exact algorithm quickly find a valid and short schedule.
Reference: [7] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of the hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer Aided Design, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: These ports can be accessed from software like registers thus providing a low-cost and straightforward interfacing mechanism. Chinook provides a port allocation scheme that uses the minimal amount of glue logic. Furthermore, device access routines are customized to reflect the assignments of pins <ref> [7] </ref>. The key idea is that an I/O port may be able to service multiple devices without glue logic and without performance penalties. These devices have interfaces that are able to isolate themselves from the shared bus, and become active only when the appropriate control signals, or guards, enable them.
Reference: [8] <author> P. Chou, E. A. Walkup, and G. Borriello. </author> <title> Scheduling for reactive real-time systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 37-47, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: At the low level, the constraints may correspond to setup and hold times, or simply the sequencing constraints between successive I/Os. At the high level, min/max separation can also be used to express response times to system inputs and rate constraints on performance <ref> [8] </ref>. In a given mode, the system's responses are defined by a set of handlers. Conceptually, they are event-triggered routines, but their activation conditions are checked by a time-triggered loop. Handlers respond by generating I/O events and/or causing a mode transition. <p> In statically scheduling the software, Chinook first converts handlers within a mode into a single handler contain ing their bodies, possibly using unrolling, and then schedules this single partially-ordered handler by interleaving <ref> [8] </ref>. Note that a mode transition may be triggered by one of the handlers before other handlers run to completion, and the scheduler must maintain the integrity of all handler states.
Reference: [9] <author> R. Ernst, J. Henkel, and T. Benner. </author> <title> Hardware-software cosynthesis for microcontrollers. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 10(4) </volume> <pages> 64-75, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The Chinook Hardware/Software Co-Synthesis System 3 Partitioning is the process of determining the components on which to implement portions of system functionality. This may be a split between a processor and auxiliary logic or between a set of processors. Attempts at automating partitioning have included simulated annealing algorithms <ref> [9] </ref> and hardware to software migration [12] but have for the most part ignored the problems of interfacing and communication between the parts.
Reference: [10] <author> D. D. Gajski and F. Vahid. </author> <title> Specification and design of embedded hardware-software systems. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 12(1) </volume> <pages> 53-67, </pages> <month> Spring </month> <year> 1995. </year>
Reference: [11] <author> B. Gladstone. </author> <title> Specification of timing in a digital system. </title> <booktitle> ASIC and EDA, </booktitle> <pages> pages 46-52, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via a waveform editor <ref> [11] </ref>.
Reference: [12] <author> R. Gupta and G. De Micheli. </author> <title> Hardware-software cosynthesis for digital systems. </title> <journal> Computers and Electrical Engineering, </journal> <volume> 10(3) </volume> <pages> 29-41, </pages> <month> September </month> <year> 1993. </year> <note> The Chinook Hardware/Software Co-Synthesis System 13 </note>
Reference-contexts: This may be a split between a processor and auxiliary logic or between a set of processors. Attempts at automating partitioning have included simulated annealing algorithms [9] and hardware to software migration <ref> [12] </ref> but have for the most part ignored the problems of interfacing and communication between the parts. In fact, designers spend a large fraction of the time in interfacing system components to each other and the operating environment (including user interfaces) because it is where the bulk of errors lie.
Reference: [13] <author> R. K. Gupta and G. De Micheli. </author> <title> Constrained software generation for hardware-software systems. </title> <booktitle> In Proceedings of the Third International Workshop on Hardware/Software Codesign, </booktitle> <pages> pages 56-63, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Because the complexity of the problem is NP-hard, we employ heuristic ordering functions to help the exact algorithm quickly find a valid and short schedule. Experimental results show that our best heuristic consistently outperforms a heuristic that solves the same problem inexactly <ref> [13] </ref>. At the high level, rate constraints are specified on a reference event between successive iterations, and response times are constraints on the time it takes to do a mode transition.
Reference: [14] <author> D. Harel. StateCharts: </author> <title> a visual formalism for complex systems. </title> <journal> Science of Programming, </journal> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: A mode also defines a scope for a set of timing constraints that must be satisfied while the system is within that mode but not necessarily when it is operating outside of it. Modes are similar to the hierarchical states of <ref> [14] </ref> in that they can capture both sequential and concurrent behavior. Chinook allows the specification of real-time requirements in terms of minimum and maximum separation between I/O events, namely events between system components or between the system and the environment.
Reference: [15] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: This approach has made design maintenance, upgrading, and retargeting very time intensive and some times impossible. Several formal specification methods have been proposed including finite state machines [4], Petri nets [18], and CSP <ref> [15] </ref>. Today's tools lie somewhere in the middle - specifications are written in a high-level programming or hardware description language that is simulatable. This enables some early validation of the design. There is still no accepted formalization of the timing and performance constraints that are critical in many embedded applications.
Reference: [16] <author> J. Kuskin et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In 21st Annual Internation Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <year> 1994. </year>
Reference-contexts: After building this application in hardware according to the generated netlist, the system operated correctly upon applying power. 9.2 MAGIC The MAGIC (Memory and General Interconnect Controller) is a custom node controller for the FLASH architecture <ref> [16] </ref>. It communicates with a processor, network, I/O devices and DRAM (see for the network requests and one for the I/O requests. Since the DRAM does not initiate activity, it does not require its own handler. All communication with the DRAM occurs via device driver calls.
Reference: [17] <author> A. K. Mok. </author> <title> The design of real-time programming systems based on process models. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 5-17, </pages> <year> 1984. </year>
Reference-contexts: Their interaction with the devices and the environment must respect not only low-level signaling constraints but also performance requirements such as rate and response time constraints. To satisfy these high-level constraints, designers have used process-based scheduling techniques based on operating systems concepts <ref> [17, 3] </ref>. These techniques are coarse-grained, priority-driven, and dynamically preemptive. They assume that the processor does not perform I/O directly and the processes are independent of each other. Since all timing constraints are coarse-grained, overhead incurred by the executive during preemption can be dismissed.
Reference: [18] <author> T. Murata. </author> <title> Petri nets: Properties, analysis, </title> <booktitle> and applications. Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time intensive and some times impossible. Several formal specification methods have been proposed including finite state machines [4], Petri nets <ref> [18] </ref>, and CSP [15]. Today's tools lie somewhere in the middle - specifications are written in a high-level programming or hardware description language that is simulatable. This enables some early validation of the design.
Reference: [19] <author> C. Y. Park. </author> <title> Predicting Deterministic Execution Times of Real-Time Programs. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1992. </year> <type> Technical Report 92-08-02, </type> <institution> Department of Computer Science & Engineering. </institution>
Reference-contexts: The device library contains detailed generic specification of device interfaces (in the form of timing diagrams and Verilog code) and models for their simulation (in C). For processors it contains specifications of their interfaces as well as timing schemas for software run-time estimation <ref> [19] </ref>. The device-driver synthesizer compiles the timing diagrams and Verilog device drivers into customized code for the given processor and makes low-level partitioning decisions to meet signaling constraints.
Reference: [20] <author> M. Srivastava, B.C.Richards, and R.W.Brodersen. </author> <title> System level hardware module generation. </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> 3(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: Yet, interfacing remains one of the least addressed areas in many co-synthesis tools. The interfacing task may involve both hardware and software aspects of the interface as well as low level timing concerns that may require glue logic. Interface generation has been described in <ref> [20] </ref>, though the synthesis of interface software is not addressed. Other aspects of the embedded system design cycle include retargetable code-generation (for different off-the-shelf processors as well as custom designed ones).
Reference: [21] <author> D. E. Thomas and P. R. Moorby. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic, </publisher> <year> 1991. </year>
Reference: [22] <author> E. A. Walkup and G. Borriello. </author> <title> Interface timing verification with application to synthesis. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via a waveform editor [11]. Chinook parses these waveforms and synthesizes the device driver code by choosing a linear schedule of controller events, and inserting additional interface glue logic where necessary <ref> [22] </ref>. 6.2 I/O Port Allocation Many processors used in embedded systems include I/O ports that can be used to directly sense and manipulate the processor's environment. These ports can be accessed from software like registers thus providing a low-cost and straightforward interfacing mechanism.
References-found: 22

