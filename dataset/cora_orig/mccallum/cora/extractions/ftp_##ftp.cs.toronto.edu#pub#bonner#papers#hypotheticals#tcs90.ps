URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/tcs90.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: Hypothetical Datalog: Complexity and Expressibility  
Author: Anthony J. Bonner 
Date: 76:3-51, 1990.  
Note: Appears in Theoretical Computer Science (TCS),  ftp://db.toronto.edu/pub/bonner/papers/hypotheticals/tcs90.ps.gz  
Address: New Brunswick, NJ 08903 United States  
Affiliation: Rutgers University Department of Computer Science  
Abstract: We present an extension of Horn-clause logic which can hypothetically add and delete tuples from a database. Such logics have been discussed in the literature, but their complexities and expressibilities have remained an open question. This paper examines two such logics in the function-free, predicate case. It is shown, in particular, that augmenting Horn-clause logic with hypothetical addition increases its data-complexity from PTIME to PSPACE. When deletions are added as well, complexity increases again, to EXPTIME. We then augment the logic with negation-as-failure and develop the notion of stratified hypothetical rulebases. It is shown that negation does not increase complexity. To establish expressibility, we view the logic as a query language for relational databases. It is shown that any typed generic query that is computable in PSPACE can be expressed as a stratified rulebase of hypothetical additions. Similarly, any typed generic query that is computable in EXPTIME can be expressed as a stratified rulebase of hypothetical additions and deletions. Neither of these results assumes the data domain is linearly ordered. In this way, we establish the expressive completeness of our logics for queries in PSPACE and EXPTIME, resp. This paper is available at the following URL: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> A Transaction Language Complete for Database Update Specification. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year> <note> Published in expanded form as Rapports de Recherche no. 715, </note> <institution> INRIA, </institution> <address> 78153 Le Chesnay Cedex, France. </address>
Reference: [2] <author> K.R. Apt, H.A. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year> <note> REFERENCES 47 </note>
Reference-contexts: As in the Horn case, however, if there is no recursion through negation, then it is not difficult to provide an operational semantics for negation <ref> [2] </ref>. In particular, a rulebase with negation can be stratified or layered so that within each layer, a negated premise refers only to rules found in the layers below [2]. We therefore extend the familiar notion of stratification from Horn rulebases to hypothetical rulebases. <p> case, however, if there is no recursion through negation, then it is not difficult to provide an operational semantics for negation <ref> [2] </ref>. In particular, a rulebase with negation can be stratified or layered so that within each layer, a negated premise refers only to rules found in the layers below [2]. We therefore extend the familiar notion of stratification from Horn rulebases to hypothetical rulebases. The proof theory for a stratified rulebase R is developed and is shown to be independent of any particular stratification of R. <p> The development presented here is an adaptation of that given in <ref> [2] </ref> for the semantics of stratified Horn rulebases. First, we divide a stratified rulebase R into disjoint "clusters", that is, maximal sets of rules which are mutually recursive. <p> Furthermore, if R 0 ; :::; R k is a stratification of R, then each cluster of R is contained in some stratum R i . Thus, each stratum consists of a disjoint union of clusters. Similar results were established for Horn rules in <ref> [2] </ref>. Clusters are a convenient device for hiding recursion from our theoretical development. Indeed, there is no recursion between clusters; and because each cluster lies within a single stratum, there is no need to look within a cluster. Clusters thus serve as the "atomic units" of our analysis.
Reference: [3] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference: [4] <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 480-484, </pages> <address> Saint Paul, MN, </address> <month> August 21-26 </month> <year> 1988. </year> <note> Published in expanded form as Technical Report TR-DCS-230, </note> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903. </address>
Reference: [5] <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: We show, however, that generic queries are robust in that they return the same answer no matter which linear order is used. Informally, a query is generic iff renaming the constants in the database causes the constants in the answer to be renamed in the same way <ref> [5, 6] </ref>. This is called the consistency criterion, and it formalizes the idea that the constant symbols in a database are uninter-preted. In our machine simulations, changing the linear order is equivalent to renaming the database constants. <p> Before establishing these expressibility results, we give a precise definition of what it means for a hypothetical rulebase R to express a database query. This in turn requires precise definitions of "relational database" and "database query". The first two definitions below are essentially those of <ref> [5] </ref> and [6]. Definition 20 Let U be a countable set, called the universal data domain. <p> In this case, D can be constructed from the database predicates P 1 ; :::; P m by adding the following rules to R ( ) for each i: 11 In this case we say that DB and DB 0 are isomorphic. See <ref> [5] </ref> for a more precise definition. 8 EXPRESSIBILITY 38 D (x 1 ) P i (x 1 ; x 2 :::x ff i ): With this said, we prove theorem 8 by first reducing it to the problem of expressing yes/no queries, that is, queries which return either true or false.
Reference: [6] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 333-347, </pages> <year> 1980. </year>
Reference-contexts: Adding negation-as-failure to a logic increases its expressibility, but only to a certain extent. For instance, although Datalog is more expressive with negation, it still cannot express the query EVEN <ref> [6, 7] </ref>. Thus, although its data-complexity is P-complete, there are some simple queries in P which it cannot express. This limitation can be overcome, however, by assuming that the data domain is linearly ordered. <p> We show, however, that generic queries are robust in that they return the same answer no matter which linear order is used. Informally, a query is generic iff renaming the constants in the database causes the constants in the answer to be renamed in the same way <ref> [5, 6] </ref>. This is called the consistency criterion, and it formalizes the idea that the constant symbols in a database are uninter-preted. In our machine simulations, changing the linear order is equivalent to renaming the database constants. <p> Before establishing these expressibility results, we give a precise definition of what it means for a hypothetical rulebase R to express a database query. This in turn requires precise definitions of "relational database" and "database query". The first two definitions below are essentially those of [5] and <ref> [6] </ref>. Definition 20 Let U be a countable set, called the universal data domain.
Reference: [7] <author> A.K. Chandra and D. Harel. </author> <title> Horn Clauses and the Fixpoint Query Hierarchy. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 158-163, </pages> <year> 1982. </year>
Reference-contexts: Adding negation-as-failure to a logic increases its expressibility, but only to a certain extent. For instance, although Datalog is more expressive with negation, it still cannot express the query EVEN <ref> [6, 7] </ref>. Thus, although its data-complexity is P-complete, there are some simple queries in P which it cannot express. This limitation can be overcome, however, by assuming that the data domain is linearly ordered. <p> Thus, although its data-complexity is P-complete, there are some simple queries in P which it cannot express. This limitation can be overcome, however, by assuming that the data domain is linearly ordered. Indeed, under this assumption, stratified Datalog expresses all the typed generic queries in P <ref> [13, 23, 7] </ref>. This section establishes comparable results for stratified hypothetical rulebases, but for higher complexity classes and without the assumption of a linearly ordered domain. The following example shows a stratified hypothetical rulebase which expresses the query EVEN . The operation of this rulebase is best viewed as top-down.
Reference: [8] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference: [9] <author> A.K. Chandra and L.J. Stockmeyer. </author> <title> Alternation. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 98-108, </pages> <year> 1976. </year>
Reference: [10] <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference: [11] <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference: [12] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: introduction of the time variable t. The rest of this section describes these differences. 9 See <ref> [12] </ref> for examples of such languages. 6 DATA COMPLEXITY: LOWER BOUNDS 22 6.2.1 The Database DB (s) and the Rulebase R (M ) Because time is now represented explicitly, the database can encode more than a single machine id.
Reference: [13] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 147-152, </pages> <year> 1982. </year>
Reference-contexts: Thus, although its data-complexity is P-complete, there are some simple queries in P which it cannot express. This limitation can be overcome, however, by assuming that the data domain is linearly ordered. Indeed, under this assumption, stratified Datalog expresses all the typed generic queries in P <ref> [13, 23, 7] </ref>. This section establishes comparable results for stratified hypothetical rulebases, but for higher complexity classes and without the assumption of a linearly ordered domain. The following example shows a stratified hypothetical rulebase which expresses the query EVEN . The operation of this rulebase is best viewed as top-down. <p> The rest of this section shows that the two stratified hypothetical logics are expressively complete for EXPTIME and PSPACE, resp. The proofs rely on the simulations of Turing machines developed in the section 6. In this respect, they are similar to other expressibility proofs in the literature (e.g., <ref> [13, 23] </ref>). One difference, however, is that the results presented here do not assume that the data domain is linearly ordered. Linear orders are typically used to simulate counters, which in turn, are used to simulate the movement of Turing-machine control heads. <p> In fact, by using predicates of arity k, a counter from 0 to n k 1 can be constructed in a straightforward way. For this reason, the assumption of a linearly ordered domain is common in the literature <ref> [13, 23] </ref>, especially when expressibility results are established in terms of complexity classes, as in lemma 10. With hypothetical rules, however, this assumption is unnecessary. Indeed, this section provides a set of hypothetical rules which "guess" a linear order and hypothetically add it to the database.
Reference: [14] <author> R. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: The greater part of an id, however, remains unchanged by such transitions. Indeed, except for the tape cell under the control head, the contents of all tape cells are unchanged. This is an instance of the frame axiom <ref> [14] </ref>, and we must write rules to encode it. Such rules are necessary only because we are representing time explicitly; i.e., the database represents a sequence of id's, and rules are needed to copy the unchanged portion of an id from one instant of time to the next.
Reference: [15] <author> R.E. Ladner. </author> <title> The Computational Complexity of Provability in Systems of Propositional Modal Logic. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6(3) </volume> <pages> 467-480, </pages> <year> 1977. </year>
Reference: [16] <author> S. Manchanda and D.S. Warren. </author> <title> A Logic-based Language for Database Updates. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 10, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [17] <author> Sanjay Manchanda. </author> <title> A Dynamic Logic Programming Language for Relational Updates. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, Stony Brook, </institution> <address> New York, </address> <month> December </month> <year> 1987. </year> <note> Also published as Technical Report REFERENCES 48 TR 88-2, </note> <institution> Department of Computer Science, The University of Arizona, Tuscon, Arizona 85721, </institution> <month> January, </month> <year> 1988. </year>
Reference: [18] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference: [19] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: In addition, by using a domain predicate, we can construct R (') so that theorem 8 is valid even if a naive top-down inference procedure is used, one which has no knowledge of the domain, such as the Prolog-style interpreter developed by McCarty <ref> [19] </ref>. Even so, the assumption of a data-domain predicate is not always needed, since the data domain is often defined as the set of constant symbols appearing in the database.
Reference: [20] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic Programming, </booktitle> <pages> pages 106-114, </pages> <month> Sept </month> <year> 1986. </year>
Reference: [21] <author> R. Statman. </author> <title> Intuitionistic Propositional Logic is Polynomial-Space Complete. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 9(1) </volume> <pages> 67-72, </pages> <year> 1979. </year>
Reference: [22] <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference: [23] <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: Thus, although its data-complexity is P-complete, there are some simple queries in P which it cannot express. This limitation can be overcome, however, by assuming that the data domain is linearly ordered. Indeed, under this assumption, stratified Datalog expresses all the typed generic queries in P <ref> [13, 23, 7] </ref>. This section establishes comparable results for stratified hypothetical rulebases, but for higher complexity classes and without the assumption of a linearly ordered domain. The following example shows a stratified hypothetical rulebase which expresses the query EVEN . The operation of this rulebase is best viewed as top-down. <p> The rest of this section shows that the two stratified hypothetical logics are expressively complete for EXPTIME and PSPACE, resp. The proofs rely on the simulations of Turing machines developed in the section 6. In this respect, they are similar to other expressibility proofs in the literature (e.g., <ref> [13, 23] </ref>). One difference, however, is that the results presented here do not assume that the data domain is linearly ordered. Linear orders are typically used to simulate counters, which in turn, are used to simulate the movement of Turing-machine control heads. <p> In fact, by using predicates of arity k, a counter from 0 to n k 1 can be constructed in a straightforward way. For this reason, the assumption of a linearly ordered domain is common in the literature <ref> [13, 23] </ref>, especially when expressibility results are established in terms of complexity classes, as in lemma 10. With hypothetical rules, however, this assumption is unnecessary. Indeed, this section provides a set of hypothetical rules which "guess" a linear order and hypothetically add it to the database.
Reference: [24] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
References-found: 24

