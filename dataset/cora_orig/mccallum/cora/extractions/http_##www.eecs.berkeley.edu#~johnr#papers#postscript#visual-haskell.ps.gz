URL: http://www.eecs.berkeley.edu/~johnr/papers/postscript/visual-haskell.ps.gz
Refering-URL: http://www.eecs.berkeley.edu/~johnr/papers/visual.html
Root-URL: 
Email: email: johnr@ee.uts.edu.au  
Title: Visual Haskell: A First Attempt Haskell is incomplete, lacking syntax for modules, type declarations, type
Author: H. John Reekie 
Note: Visual  These are seen as temporary omissions rather than insurmountable drawbacks.  
Address: Sydney  
Affiliation: School of Electrical Engineering University of Technology,  
Abstract: This paper presents the Visual Haskell language. Visual Haskell is intended as i) a means of visualising Haskell programs, and ii) as a complementary programming notation to standard Haskell. The syntax of Visual Haskell is specified by first giving a translation from Haskell into an intermediate, textual form; the visual syntax is then specified as a direct translation from the intermediate form into visual representations. Visual Haskell is kept as close to Haskell as possible, in the hope that it could be used in a "two-view" programming system. Several examples of function definitions illustrate how Visual Haskell looks and is used. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. C. Bier, E. E. Goei, W. H. Ho, P. D. Lapsley, M. P. O'Reilly, G. C. Sih, and E. A. Lee. Gabriel: </author> <title> A design environment for DSP. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 28-45, </pages> <month> October </month> <year> 1990. </year> <note> REFERENCES 31 </note>
Reference-contexts: This work involved the application of functional programming (using Haskell) to digital signal processing|in particular, the ways in which functional languages lend themselves to expression and transformation of dataflow-style programs [12]. In signal processing, dataflow-style visual languages have been used as formal programming notations for some years <ref> [1, 7] </ref>. These systems are generally know as "block-diagram" programming systems, because of their roots in informal diagrammatic representations of signal processing systems. Dataflow visual languages have been used successfully in other fields as well, such as image processing and instrumentation [9].
Reference: [2] <author> R. Bird. </author> <title> A calculus of functions for program derivation. </title> <type> Technical Report Technical Monograph PRG-64, </type> <institution> Oxford Computing Laboratory Programming Research Group, Oxford, </institution> <year> 1987. </year>
Reference-contexts: To increase the degree of parallelism, we can apply algebraic program transformation techniques, such as described by Bird <ref> [2] </ref>. <p> I am assuming here that the - abstraction has all arguments specified|in other words, that rule 36 or rule 37 has already been applied. For example, a variant of Bird's "fold promotion" law <ref> [2] </ref> using Haskell's "left-handed" directed reduction function, foldl , is f oldl f a (concat xs) f oldl (f oldl f ) a xs (50) If we wish to use foldr instead, we must either introduce an auxiliary function or use a -abstraction, like this: 3 f oldr f a (concat
Reference: [3] <author> Ken Dawson. </author> <title> Visual Haskell editor and parser. </title> <type> Technical report, </type> <institution> School of Electrical Engineering, University of Technology, </institution> <address> Sydney, </address> <year> 1993. </year> <type> Undergraduate thesis report. </type>
Reference-contexts: y = y where g x n | even n = g (x*x) (n `quot` 2) | otherwise = f x (n-1) (x*y) 2.4 A Visual Haskell editor Ken Dawson has constructed a prototype graphical editor for Visual Haskell, to explore the feasibility of using Visual Haskell to write programs <ref> [3] </ref>. The prototype editor allows the user to write simple function definitions in Visual Haskell, and then generate (textual) Haskell code for compilation. Although the functionality of the editor is limited, it is adequate to define functions such as map.
Reference: [4] <editor> Paul Hudak et al. </editor> <title> Report on the functional programming language Haskell, a non-strict purely-functional language, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents Visual Haskell, my attempt to develop a visual equivalent for the Haskell functional language <ref> [4] </ref>. Visual Haskell is intended both as a program visualisation tool and as a programming language in its own right. In both of these roles, it should be seen as complementary to Haskell's standard textual form, rather than as a replacement or "improved" notation. <p> Conditionals One or a series of conditionals (if-then-else) is converted into a guarded scoping expression with a null pattern. This treatment makes a series of if-then-else expressions visually simple. (Translation into case-expressions, as in <ref> [4] </ref>, would be too cumbersome visually.) 4.6.3 Bindings part of the right-hand side always matches scx, gscx, or uscx.
Reference: [5] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: This can often highlight similarities between programs that are less obvious in a textual representation. For example, consider the translation of a function to the enriched lambda calculus, as described in <ref> [5] </ref>. Translation of map (Figure 1) into a single -abstraction using case-expressions gives: map = "f xs -&gt; case xs of [] -&gt; [] (Figure 2) are, I think, clearer than with the textual forms. <p> By a translation from Haskell into the Visual Haskell intermediate form (VHIF) The translation is given by syntactic translation rules in the style of <ref> [5] </ref>. The translations are named V (for definitions), VE (for expressions), and VP (for patterns). 2. By concrete visual syntax for each production of VHIF. The parallelogram in represents a non-terminal called z. All other visual elements are terminals.
Reference: [6] <author> Paul Kelly. </author> <title> Functional Programming for Loosely-coupled Multiprocessors. </title> <booktitle> Research Monographs in Parallel and Distributed Computing. </booktitle> <publisher> Pitman, </publisher> <year> 1989. </year>
Reference-contexts: about the direction, and all of the diagrams in this paper could be mirrored without any change in meaning. 1.2 Related work Visual notations of the "box-and-arrow" style are often used to illustrate or explain functional programs: Reade [10], for example, explains function application using diagrams of this kind; Kelly <ref> [6] </ref> illustrates networks of streams and processes written using an annotated pure functional language; Waugh et al [15] illustrate the effect of program transformation on parallelism. <p> Kelly <ref> [6] </ref> and Waugh et al [15], for example, use diagrams to illustrate process networks and the effect of program transformation on them. The work referred to above uses lists to model streams|that is, communications channels between processes.
Reference: [7] <author> Edward A. Lee and David G. Messerschmitt et al. </author> <title> An overview of the Ptolemy project. </title> <note> Available by anonymous ftp from the Ptolemy distribution site, ptolemy.eecs.berkeley.edu, </note> <month> March </month> <year> 1994. </year>
Reference-contexts: This work involved the application of functional programming (using Haskell) to digital signal processing|in particular, the ways in which functional languages lend themselves to expression and transformation of dataflow-style programs [12]. In signal processing, dataflow-style visual languages have been used as formal programming notations for some years <ref> [1, 7] </ref>. These systems are generally know as "block-diagram" programming systems, because of their roots in informal diagrammatic representations of signal processing systems. Dataflow visual languages have been used successfully in other fields as well, such as image processing and instrumentation [9]. <p> Signal processing, for example, makes extensive use of the metaphor of modular units inter 4 2 EXAMPLES OF VISUAL HASKELL connected by signals (that is, streams). The Ptolemy system is an excellent example of this type of system <ref> [7] </ref>, and a number of systems based on this idea have been successful, both in signal processing and in other fields such as image processing and instrumentation [9]. In the field of visual language research, Visual Haskell is perhaps closest to that of Najork and Golin [8] on Show-and-Tell.
Reference: [8] <author> M.A. Najork and E. Golin. </author> <title> Enhancing Show-and-Tell with a polymorphic type system and higher-order functions. </title> <booktitle> In IEEE Workshop on Visual Languages, </booktitle> <address> Skokie, </address> <publisher> Illinois, </publisher> <pages> pages 215-220, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In the field of visual language research, Visual Haskell is perhaps closest to that of Najork and Golin <ref> [8] </ref> on Show-and-Tell. Show-and-Tell is also declarative in nature, and utilises a polymorphic type system similar to Haskell's.
Reference: [9] <author> John Rasure and Mark Young. </author> <title> Dataflow visual languages. </title> <journal> IEEE Potentials, </journal> <volume> 11(2) </volume> <pages> 30-33, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: These systems are generally know as "block-diagram" programming systems, because of their roots in informal diagrammatic representations of signal processing systems. Dataflow visual languages have been used successfully in other fields as well, such as image processing and instrumentation <ref> [9] </ref>. <p> The Ptolemy system is an excellent example of this type of system [7], and a number of systems based on this idea have been successful, both in signal processing and in other fields such as image processing and instrumentation <ref> [9] </ref>. In the field of visual language research, Visual Haskell is perhaps closest to that of Najork and Golin [8] on Show-and-Tell. Show-and-Tell is also declarative in nature, and utilises a polymorphic type system similar to Haskell's.
Reference: [10] <author> Chris Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Visual Haskell, however, does not care about the direction, and all of the diagrams in this paper could be mirrored without any change in meaning. 1.2 Related work Visual notations of the "box-and-arrow" style are often used to illustrate or explain functional programs: Reade <ref> [10] </ref>, for example, explains function application using diagrams of this kind; Kelly [6] illustrates networks of streams and processes written using an annotated pure functional language; Waugh et al [15] illustrate the effect of program transformation on parallelism.
Reference: [11] <author> H. John Reekie. </author> <title> Towards effective programming for parallel digital signal processing. </title> <type> Technical Report 92.1, </type> <institution> Key Centre for Advanced Computing Sciences, University of Technology, </institution> <address> Sydney, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: In Visual Haskell, streams are indicated by circular type annotations; functions such as smap have circular icons. Consider a function that performs FFTs (Fast Fourier Transforms) on successive 16-sample sections of a signal xs. (This function and the following code fragments are considered in detail in <ref> [11] </ref>.) Each element of the output stream is a vector containing the complex spectrum 6 2 EXAMPLES OF VISUAL HASKELL of a 16-sample portion of the real input signal: 1 fftnet :: (Num a) =&gt; Stream a -&gt; Stream (Vector (Complex a)) fftnet = smap fft . chop 16 . smap <p> Section 5.3 suggests an extension of this idea useful for illustrating program transformation. 3.5 Type annotations Arcs are optionally decorated to indicate their types. In this paper, only list-carrying arcs are so decorated, with an asterisk-like symbol. In other work <ref> [11] </ref> I have used a more extensive set of type annotations. Figure 16 illustrates a few annotated arcs to give the flavour of annotations.
Reference: [12] <author> H. John Reekie. </author> <title> Functional and Dataflow Programming for Realtime Distributed Multiprocessors. </title> <type> PhD thesis, </type> <institution> School of Electrical Engineering, University of Technology, </institution> <address> Sydney, </address> <year> 1994. </year> <note> In preparation. </note>
Reference-contexts: Visual Haskell evolved out of attempts during my Ph.D. research to explain my work to non-functional-programmers. This work involved the application of functional programming (using Haskell) to digital signal processing|in particular, the ways in which functional languages lend themselves to expression and transformation of dataflow-style programs <ref> [12] </ref>. In signal processing, dataflow-style visual languages have been used as formal programming notations for some years [1, 7]. These systems are generally know as "block-diagram" programming systems, because of their roots in informal diagrammatic representations of signal processing systems.
Reference: [13] <author> John Reekie. </author> <title> Integrating block-diagram and textual programming for parallel DSP. </title> <booktitle> In ISSPA '92, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: It is likely to be easier to precisely define the semantics of a visual language in terms of Haskell's semantics, than attempting to define a new semantics from scratch. One can easily imagine a "two-view" development system <ref> [13] </ref>, in which either visual or textual notation can be used by the programmer to write or view a function or expression. The choice is made by the programmer, based solely on which view is most descriptive of the program fragment at hand.
Reference: [14] <author> John Reekie and John Potter. </author> <title> Process network transformation. </title> <editor> In David Arnold, editor, </editor> <booktitle> Parallel Computing and Transputers (PCAT-93), </booktitle> <pages> pages 376-383. </pages> <publisher> IOS Press, </publisher> <month> November </month> <year> 1993. </year>
Reference-contexts: If you consider the crossed rectangle as though it were a mutable state variable, the visual representation reveals the computation performed by this application of sstate much more readily than by examining the textual definitions. <ref> [14] </ref> shows the complete series of steps in transforming the f ir function into a pipeline of processes.
Reference: [15] <author> Kevin Waugh, Patrick McAndrew, and Greg Michaelson. </author> <title> Parallel implementations from functional prototypes|a case study. </title> <type> Technical Report 90/4, </type> <institution> Heriot-Watt University, </institution> <year> 1990. </year>
Reference-contexts: in meaning. 1.2 Related work Visual notations of the "box-and-arrow" style are often used to illustrate or explain functional programs: Reade [10], for example, explains function application using diagrams of this kind; Kelly [6] illustrates networks of streams and processes written using an annotated pure functional language; Waugh et al <ref> [15] </ref> illustrate the effect of program transformation on parallelism. <p> Kelly [6] and Waugh et al <ref> [15] </ref>, for example, use diagrams to illustrate process networks and the effect of program transformation on them. The work referred to above uses lists to model streams|that is, communications channels between processes. I prefer to use a distinct datatype, Stream, to more clearly distinguish streams from other kinds of lists.
References-found: 15

