URL: http://www.cs.berkeley.edu/~manku/papers/ms-thesis.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~manku/papers2.html
Root-URL: http://www.cs.berkeley.edu
Title: Structural Symmetries and Model Checking  
Author: by Gurmeet Singh Manku R K Brayton 
Degree: in partial satisfaction of the requirements for the degree of Master  Advisor Date Professor T A Henzinger  
Affiliation: Department of Computer Science and Engineering, University of California at Berkeley  of Sciences, Plan II  Research  
Note: Research Project Submitted to the  Professor  Second Reader Date  
Abstract: Approval for the Report and Comprehensive Examination: Committee: 
Abstract-found: 1
Intro-found: 1
Reference: [AE89] <author> P. C. Attie and E. A. Emerson. </author> <title> Synthesis of Concurrent Systems with many Similar Sequential Processes. </title> <booktitle> Proc. 16th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 191-201, </pages> <year> 1989. </year>
Reference-contexts: INTRODUCTION Huber, Jepsen and Jensen [HJJ84] and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson <ref> [AE89] </ref>. The approach uses quotient structures induced by automorphisms of the system. For example, symmetry between 0 and 1 in the alternating bit protocol is factored out to reduce the size of the state space by one half. Verification of cache consistency protocols has been shown to benefit from symmetries.
Reference: [Ake78] <author> S. B. Akers. </author> <title> Binary Decision Diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37:509-516, </volume> <month> June </month> <year> 1978. </year>
Reference-contexts: Their algorithm is linear in the size of the formula and the number of states. In 1986, Bryant [Bry86] described an efficient implementation of Binary Decision Diagrams (BDDs), a data structure for representing boolean functions first introduced by Akers <ref> [Ake78] </ref>. Soon after Bryant announced the success of his BDD package, several groups started adapting explicit state space exploration techniques for BDDs. Some of the earliest symbolic techniques using BDDs were proposed by Coudert et al [CMB90], Burch et al [BCMD90] and Touati et al [TSL + 90].
Reference: [AT96] <author> M. Agrawal and T. Thierauf. </author> <title> The Boolean Isomorphism Problem. </title> <booktitle> In Proc. Symp. on Foundations of Computer Science, </booktitle> <pages> pages 422-430, </pages> <address> Burlington, Vermont, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Classes of Sub-formulas Problem: Given G Aut M L AP and a CTL* formula f , how do we find two sub-formulas g and h such that g G h? This is a computationally hard problem even if f is a simple boolean formula without path operators or temporal quantifiers <ref> [AT96] </ref>. Does the problem become easier if we replace G by G s ? If we allow operators with arbitrary arity (which is the interesting case, in practice), we can show that the problem is as hard as graph isomorphism. The reduction is simple.
Reference: [BCF + 95] <author> L. Babai, G. Cooperman, L. Finkelstein, E. Luks, and A. Seress. </author> <title> Fast Monte Carlo Algorithms for Permutation Groups. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 50(2) </volume> <pages> 296-308, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Since O (n) such cyclic shifts suffice to transform a base into another, the worst case time complexity is O (n 3 ). Recently, Las Vegas algorithms have also been proposed <ref> [CF94, BCF + 95, BLS] </ref> with expected time an order of magnitude less. 6.4.5 Extending our Algorithm How do we extend our algorithm to compute the automorphism group of a directed labeled graph? The best algorithm appears to be the following: We run the algorithm in We also maintain the group
Reference: [BCH + 91] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kurshan, S. Malik, A. L. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. Singh, and H.-Y. Wang. BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: We show the relationship between structural symmetries and symmetries in the corresponding Kripke structure. We also show how such symmetries can automatically be extracted from designs specified in a structural hardware description language like BLIF-MV <ref> [BCH + 91] </ref>. 5.1 Motivation In Section 3.5, we saw how knowledge of groups G Aut M L AP and H Aut f AP SF would help us partition sub-formulas of a CTL* formula f into equivalence classes. <p> A priori knowledge of symmetries obviates the need for computing G 1 H. In this section, we describe how G, H and G 1 H can be computed automatically, with no assistance from the designer. We start with a brief description of BLIF-MV <ref> [BCH + 91, Ber93] </ref>. We then formally state what we mean by structural symmetries of a 32 CHAPTER 5. STRUCTURAL SYMMETRIES BLIF-MV circuit and how they relate to the symmetries of the corresponding Kripke structure. <p> We do the same for CTL* formulas. Finally, we show how the two can easily be combined. 5.2 BLIF-MV BLIF-MV <ref> [BCH + 91, Ber93] </ref> is a structural hardware description language. It allows specification of a circuit in terms of its primary inputs, primary outputs, latches, tables and interconnection signals. A latch has one output and two input ports. One of the input port specifies the initial values for the latch. <p> The vertices capture the functional elements of a table and the edges capture how signals arrive at the inputs, propagate through these functional elements and define the output signals. For simplicity, we have ignored how entries corresponding to the "=" construct <ref> [BCH + 91, Ber93] </ref> need be taken care of. These nodes are easy to handle. We will outline the necessary changes in Section 5.3.6. 5.3.2 Latches For every latch, we have a vertex of type C for the input and a vertex of type O. <p> In practice, we need linear time algorithms as the graphs we deal with would have tens of thousands of vertices. Chapter 7 Results and Future Work We have implemented an algorithm for constructing a graph from a BLIF-MV <ref> [BCH + 91, Ber93] </ref> description, as described in Chapter 5. We have also implemented the search algorithm described in Chapter 6 to search for an automorphism.
Reference: [BCL + 94] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic Model Checking for Sequential Circuit Verification. </title> <journal> IEEE Tran. on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year> <note> 70 BIBLIOGRAPHY </note>
Reference-contexts: One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms <ref> [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] </ref> typically explore the states of such a finite state machine. A major problem faced by state space exploration techniques is due to the fact that the size of the machine could be exponential in the size of the system description. <p> Some of the earliest symbolic techniques using BDDs were proposed by Coudert et al [CMB90], Burch et al [BCMD90] and Touati et al [TSL + 90]. A symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al <ref> [BCL + 94] </ref>. Both symbolic and explicit CTL model checking algorithms first compute the set of states reachable from I. They also construct a parse-tree of f . Leaves of the parse tree correspond to atomic propositions in AP .
Reference: [BCMD90] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Sequential Circuit Verification Using Symbolic Model Checking. </title> <booktitle> In Proc. Design Automation Conf., </booktitle> <pages> pages 46-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms <ref> [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] </ref> typically explore the states of such a finite state machine. A major problem faced by state space exploration techniques is due to the fact that the size of the machine could be exponential in the size of the system description. <p> Soon after Bryant announced the success of his BDD package, several groups started adapting explicit state space exploration techniques for BDDs. Some of the earliest symbolic techniques using BDDs were proposed by Coudert et al [CMB90], Burch et al <ref> [BCMD90] </ref> and Touati et al [TSL + 90]. A symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al [BCL + 94].
Reference: [Ber93] <author> VLSI-CAD Group Berkeley. </author> <title> Revisiting BLIF-MV, An Intermediate Format for Verification and Synthesis of Hierarchical Networks of FSMs, </title> <year> 1993. </year>
Reference-contexts: A priori knowledge of symmetries obviates the need for computing G 1 H. In this section, we describe how G, H and G 1 H can be computed automatically, with no assistance from the designer. We start with a brief description of BLIF-MV <ref> [BCH + 91, Ber93] </ref>. We then formally state what we mean by structural symmetries of a 32 CHAPTER 5. STRUCTURAL SYMMETRIES BLIF-MV circuit and how they relate to the symmetries of the corresponding Kripke structure. <p> We do the same for CTL* formulas. Finally, we show how the two can easily be combined. 5.2 BLIF-MV BLIF-MV <ref> [BCH + 91, Ber93] </ref> is a structural hardware description language. It allows specification of a circuit in terms of its primary inputs, primary outputs, latches, tables and interconnection signals. A latch has one output and two input ports. One of the input port specifies the initial values for the latch. <p> The vertices capture the functional elements of a table and the edges capture how signals arrive at the inputs, propagate through these functional elements and define the output signals. For simplicity, we have ignored how entries corresponding to the "=" construct <ref> [BCH + 91, Ber93] </ref> need be taken care of. These nodes are easy to handle. We will outline the necessary changes in Section 5.3.6. 5.3.2 Latches For every latch, we have a vertex of type C for the input and a vertex of type O. <p> In practice, we need linear time algorithms as the graphs we deal with would have tens of thousands of vertices. Chapter 7 Results and Future Work We have implemented an algorithm for constructing a graph from a BLIF-MV <ref> [BCH + 91, Ber93] </ref> description, as described in Chapter 5. We have also implemented the search algorithm described in Chapter 6 to search for an automorphism.
Reference: [BFJ89] <author> C. A. Brown, L. Finkelstein, and P. W. Purdom Jr. </author> <title> A New Base Change Algorithm for Permutation Groups. </title> <journal> SIAM J. Computing, </journal> <volume> 18(5) </volume> <pages> 1037-1047, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The algorithm can transpose two adjacent points in the base in O (n 3 ) time. Since O (n 2 ) such transpositions suffice to transform a base into any other, we get the time bound of O (n 5 ). Brown, Finkelstein and Purdom <ref> [BFJ89] </ref> generalized this idea to computing a cyclic right shift of any contiguous subset of the base in O (n 2 ) time, using Jerrum's labeled branch-ings. Since O (n) such cyclic shifts suffice to transform a base into another, the worst case time complexity is O (n 3 ). <p> As new automorphisms are discovered, we augment this group using the technique described in [Jer86]. Alternatively, the randomized algorithm in [BLS] can be employed. As we backtrack, we dynamically change base using the algorithms in <ref> [BFJ89] </ref> or use the randomized algorithm described in [CF94]. As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group [BL85]. The structure of the group can also prune out some branches that are guaranteed to not lead to any automorphism.
Reference: [BHSV + 96] <author> R.K. Brayton, G.D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kuki-moto, A. Pardo, S. Qadeer, R.K. Ranjan, S. Sarwary, T.R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A System for Verification and Synthesis. </title> <booktitle> In Proc. 8th Intl. Conf. on Computer Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: We have also implemented the search algorithm described in Chapter 6 to search for an automorphism. Our package is integrated with VIS <ref> [BHSV + 96] </ref>, a verification system developed jointly by researchers at University of California at Berkeley and University of Colorado. The source code for our work is available at http://www-cad.eecs.berkeley.edu/~manku/symmetries/. 7.1 Results Our experiments deal with both sequential and combinational circuits. We start with a Verilog description.
Reference: [BL83] <author> L. Babai and E. M. Luks. </author> <title> Canonical Labeling of Graphs. </title> <booktitle> Proc. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 171-183, </pages> <year> 1983. </year>
Reference-contexts: For random graphs, an O (n log n) algorithm is due to Deo et al [DDL77]. A polynomial time algorithm for graphs with bounded degree has been discovered by Luks [Luk82]. For general graphs, the best known algorithm is due to Babai and Luks <ref> [BL83] </ref>. It has a worst-case time complexity of O (c n 1=2+o (1) ). 2.6.
Reference: [BL85] <author> G. Butler and C. W. H. Lam. </author> <title> A General Backtrack Algorithm for the Isomorphism Problem of Combinatorial Objects. </title> <journal> J. Symbolic Computation, </journal> <volume> 1 </volume> <pages> 363-381, </pages> <year> 1985. </year>
Reference-contexts: The problem of finding whether two objects are isomorphic and the related problem of computing the automorphism group of a single object, have received considerable attention <ref> [Leo84, BL85] </ref>. The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved [McK81]. <p> The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved [McK81]. Subsequently, Butler and Lam <ref> [BL85] </ref> presented a modification that prunes false branches by dynamically changing the base and strong generating set. Leon [Leo84] also discusses similar techniques. All the algorithms employ backtrack search. <p> A new automorphism is used to augment the subgroup discovered so far. This subgroup also serves to prune search paths that lead only to those permutations that already lie in it. Such a pruning mechanism is based on a lemma by Butler and Lam <ref> [BL85] </ref>. The lemma is useful when we are trying to extend a partial permutation by mapping v to some vertex in W and a subgroup G of Aut A is at hand. <p> It suffices to try to map v to exactly one member from each orbit of the subgroup G w 1 ;w 2 ;:::;w j where each w i is such that some vertex v i has been mapped to it. Formally, Lemma 6.7 <ref> [BL85] </ref> Let a bipartition [ 1ik f (V i ; W i )g be such that every vertex in fw 1 ; w 2 ; : : :w j g belongs to some singleton set. Let v 2 V . Let G be a known subgroup of Aut A. <p> Second, we need the ability to augment the group by adding a newly discovered permutation. 6.4.4 Base Change Algorithms Base change algorithms require elementary group theory but are somewhat involved. Sims proposed the first base change algorithm [Sim71]. Butler and Lam <ref> [BL85] </ref> showed that Sim's base change algorithm has worst case time complexity O (n 5 ). The algorithm can transpose two adjacent points in the base in O (n 3 ) time. <p> Alternatively, the randomized algorithm in [BLS] can be employed. As we backtrack, we dynamically change base using the algorithms in [BFJ89] or use the randomized algorithm described in [CF94]. As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group <ref> [BL85] </ref>. The structure of the group can also prune out some branches that are guaranteed to not lead to any automorphism. However, discovering them requires much computation [Leo84].
Reference: [BLS] <author> L. Babai, E. M. Luks, and A. Seress. </author> <title> Fast Management of Permutation Groups II. </title> <note> In Preparation. </note>
Reference-contexts: Since O (n) such cyclic shifts suffice to transform a base into another, the worst case time complexity is O (n 3 ). Recently, Las Vegas algorithms have also been proposed <ref> [CF94, BCF + 95, BLS] </ref> with expected time an order of magnitude less. 6.4.5 Extending our Algorithm How do we extend our algorithm to compute the automorphism group of a directed labeled graph? The best algorithm appears to be the following: We run the algorithm in We also maintain the group <p> As new automorphisms are discovered, we augment this group using the technique described in [Jer86]. Alternatively, the randomized algorithm in <ref> [BLS] </ref> can be employed. As we backtrack, we dynamically change base using the algorithms in [BFJ89] or use the randomized algorithm described in [CF94]. As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group [BL85].
Reference: [BLS97] <author> L. Babai, E. M. Luks, and A. Seress. </author> <title> Fast Management of Permutation Groups I. </title> <journal> SIAM J. Computing, </journal> <volume> 26(5) </volume> <pages> 1310-1342, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: The same bound was also achieved by Jerrum [Jer86]. Subsequently, an O (n 4 log c n + sn 2 ) algorithm was discovered by Babai, Luks and Seress <ref> [BLS97] </ref>. 6.4.2 Jerrum's Representation Jerrum [Jer86] devised an elegant data structure called labeled branchings to store a strong generating set in O (n 2 ) space. Essentially, a given strong generating set is reduced to at most n1 permutations and stored in a certain way.
Reference: [Bre76] <author> Brendon McKay. </author> <title> Backtrack Programming and the Graph Isomorphism Problem. </title> <type> Master's thesis, </type> <institution> University of Melbourne, </institution> <year> 1976. </year>
Reference-contexts: The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay <ref> [Bre76, McK77] </ref>. It employed branch and bound and was soon improved [McK81]. Subsequently, Butler and Lam [BL85] presented a modification that prunes false branches by dynamically changing the base and strong generating set. Leon [Leo84] also discusses similar techniques. All the algorithms employ backtrack search.
Reference: [Bry86] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Efficient procedures have been developed for solving the model checking problem. Clarke, Emerson and Sistla [CES86] presented the first algorithm for CTL model checking based on explicit state space exploration. Their algorithm is linear in the size of the formula and the number of states. In 1986, Bryant <ref> [Bry86] </ref> described an efficient implementation of Binary Decision Diagrams (BDDs), a data structure for representing boolean functions first introduced by Akers [Ake78]. Soon after Bryant announced the success of his BDD package, several groups started adapting explicit state space exploration techniques for BDDs.
Reference: [But91] <author> G. Butler. </author> <title> Fundamental Algorithms for Permutation Groups, </title> <booktitle> volume 559 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> BIBLIOGRAPHY 71 </note>
Reference-contexts: Permutation groups are studied in a book by Wielandt [Wie64]. Practical algorithms for manipulating permutation groups are presented by Butler <ref> [But91] </ref>. 2.4.1 Definitions A permutation is a bijective mapping : S ! S defined over a finite non-empty set S. Permutations are usually written in cycle form. Singleton cycles are ignored. For 2.4. <p> This is a key concept underlying essentially all polynomial-time algorithms in computational group theory. A good exposition can be found in the book by Butler <ref> [But91] </ref>. Let G be a permutation group acting on a set with cardinality n. Let x 2 be any point in the set. Let x denote the image of x under the action of 2 G. A permutation is said to stabilize an element x if x = x.
Reference: [Can84] <author> J. J. Cannon. </author> <title> An Introduction to the Group Theory Language Cayley. </title> <editor> In M. D. Atkinson, editor, </editor> <booktitle> Computational Group Theory, </booktitle> <pages> pages 145-183. </pages> <address> London: </address> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: Grape itself is one of the several packages provided by GAP [Gap], which is a general purpose software package for combinatorial objects. Another general purpose package is MAGMA [W. 96], which has been derived from an earlier package called CAYLEY <ref> [Can84] </ref>. What is the motivation for writing a new graph automorphism program? First, existing packages are general purpose and carry around a lot of baggage. In our experience, they are slow. We can specialize our algorithm for labeled graphs.
Reference: [CE81] <author> E. M. Clarke and E. A. Emerson. </author> <title> Design and Synthesis of Synchronization Skeletons Using Branching Time Logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: A path formula is either * a state formula, or * :f; f _ g; X f or f U g, where f and g are path formulas. CTL was proposed by Clarke and Emerson <ref> [CE81] </ref> much earlier than CTL*. It is that subset of state formulas of CTL* in which the path formulas are restricted to be Xf and f U g, where f and g are CTL formulas. 2.2.2 Semantics Let M = (S; R; K) be a Kripke structure.
Reference: [CEFJ96] <author> E. M. Clarke, R. Enders, T. Filkorn, and S. Jha. </author> <title> Exploiting Symmetry in Temporal Logic Model Checking. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):77-104, 1996. 
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods [Pel93, God96], abstraction [Lon93], compositional approaches [CLM89] and symmetries <ref> [Ip96, CEFJ96, ES96] </ref> appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry. <p> Verification of cache consistency protocols has been shown to benefit from symmetries. See the survey by Pong and Dubois [PD97] for details. Symmetries have proven useful even for transistor-level verification of digital circuits [PB97]. 1.1.1 CTL* Model Checking Emerson and Sistla [ES96] and Clarke et al <ref> [CEFJ96] </ref> have developed a theory of symmetries for CTL* model checking. Both papers show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. <p> This idea is distinct from building a quotient structure. The two can be used in conjunction. 2. We unify the theories for symmetries in Kripke structures and CTL* formulas, developed by Emerson and Sistla [ES96] and Clarke et al <ref> [CEFJ96] </ref>. We extend their fundamental theorems pertaining to quotient structures. 3. We formalize the notion of structural symmetries in net-list descriptions of digital circuits and CTL* formulas. We show how these symmetries relate to those in the corresponding Kripke structures. We propose algorithms for identifying these sym metries automatically. <p> Once they are described, it will become clear that identification of symmetric sub-formulas contributes to savings on top of quotient structures. Chapter 4 Quotient Structures In this chapter, we develop a theory of symmetries for Kripke structures, unifying those developed by Clarke et al <ref> [CEFJ96] </ref> and Emerson and Sistla [ES96]. We first show how a smaller sized quotient structure can be constructed from a Kripke structure and a CTL* formula so that it suffices to check the formula on the quotient. <p> f [[s]] G j s 2 Sg * K G ([[s]] G ) = K (~ G (s)) 4.2 Theory for Quotient Structures An important relationship between a Kripke structure and its quotient is captured by what is called the Path Correspondence Lemma. 4.2.1 The Path Correspondence Lemma Lemma 4.1 <ref> [CEFJ96, ES96] </ref> For a Kripke structure M and any group G Aut M LX, there is a correspondence between paths of M and its quotient structure M G , characterized by * If s 0 ; s 1 ; : : :; is a path in M , then [[s 0 <p> M G , then for every state t 0 2 [[s 0 ]] G , there exists a path t 0 ; t 1 ; : : : ; such that t i 2 [[s i ]] G for i 0. 2 4.2.2 Label Preserving Quotients The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 4.1 [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p) then (8s 2 S)((M; s j= f ) , (M G ; [[s]] G <p> 2 [[s 0 ]] G , there exists a path t 0 ; t 1 ; : : : ; such that t i 2 [[s i ]] G for i 0. 2 4.2.2 Label Preserving Quotients The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 4.1 [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p) then (8s 2 S)((M; s j= f ) , (M G ; [[s]] G j= f )) for any CTL* formula f . <p> In group-theoretic terminology, we require that each p 2 AP be centralized. In the extreme case, we could have AP = L, giving each state a unique label. As a consequence, G is trivial and the quotient structure is not smaller than the original. Therefore, to use Theorem <ref> [CEFJ96] </ref>, we should to be able to generate good outputs as atomic propositions. This is possible in practice. See [CEFJ96] for examples. A motivating example where Theorem 4.1 does not allow reduction but symmetries clearly exist, is a system consisting of n black-boxes interconnected in a ring topology. <p> As a consequence, G is trivial and the quotient structure is not smaller than the original. Therefore, to use Theorem <ref> [CEFJ96] </ref>, we should to be able to generate good outputs as atomic propositions. This is possible in practice. See [CEFJ96] for examples. A motivating example where Theorem 4.1 does not allow reduction but symmetries clearly exist, is a system consisting of n black-boxes interconnected in a ring topology. The Dining Philosophers Problem is a good example of such a system. Let each black box have a local output. <p> If the set Unexplored is maintained as a stack, the search becomes depth first. We have borrowed the algorithm from <ref> [CEFJ96] </ref>. 4.3.2 Symbolic Model Checking Using ~ G In a symbolic technique, BDDs are used to store the transition relation R : 2 L fi 2 L ! 2 1 and the set of initial states I : 2 L ! 2 1 . <p> Once we have computed G Aut M L X in the form of a set of generators, the crucial question is: How difficult is it to obtain ~ G from a set of generators for a group acting on L? In <ref> [CEFJ96] </ref>, it is shown that the following problem is as hard as graph isomor-phism: Given two states in 2 L and a set of generators for a group G acting on the set L, do the two states have the same canonical state? Therefore, the chances of devising a general purpose <p> Can we devise an algorithm that pre-processes the set of generators such that the cost of pre-processing gets amortized over a multitude of subsequent queries? This is an open problem. 4.4.1 Equivalence Relation Approach An idea suggested by <ref> [CEFJ96] </ref> is to construct a BDD for the equivalence relation fi G S fi S defined as (8s; t 2 S)(fi G (s; t) , ([[s]] G = [[t]] G )). The motivation is to use the method of Lin [LN91] to construct ~ G from fi G . <p> One choice could be the lexicographically largest/smallest value for t. Thus evaluating ~ G (s 0 ) requires just one path traversal through the BDD for fi G . Clarke et al <ref> [CEFJ96] </ref> have identified some interesting groups which are encountered in practice and for which the space complexity of any BDD for fi G has an exponential lower bound. 4.4.2 Direct Computation of ~ G We can attempt to construct ~ G directly without constructing fi G . <p> Does this one or a variant of it work well in practice? 4.4.3 Other Ideas In [HAM97], a heuristic procedure is used to compute ~(s) for individual states, one at a time, for an explicit model checker. Another idea proposed by <ref> [CEFJ96] </ref> is the use of multiple representatives for each orbit. We can solve the problem for special classes of groups for which ~ is readily computed. This is the approach used by several authors [CEFJ96, ES96, ID96, HAM97]. <p> Another idea proposed by [CEFJ96] is the use of multiple representatives for each orbit. We can solve the problem for special classes of groups for which ~ is readily computed. This is the approach used by several authors <ref> [CEFJ96, ES96, ID96, HAM97] </ref>. For example, if the system is composed of a hierarchy of fully symmetric subsystems, then ~ can be computed for a given state by simply computing the canonical state for each subsystem recursively and then sorting them. 4.5 Research Problems extracts symmetries and exploits quotient structures. <p> In Section 4.2.4, we saw how knowledge of the same group G but a different H Aut f AP M P S would allow us to construct quotient structures. In both the cases, we need to compute G 1 H. In <ref> [CEFJ96, ES96, HAM97] </ref>, a group similar to G 1 H is specified by the designer manually . <p> We can also use this theory for pruning sub-formulas from a big formula so that it suffices to prove the resulting smaller sized formula. We have cast the theory of symmetries developed for Kripke structures by Clarke et al <ref> [CEFJ96] </ref> and Emerson and Sistla [ES96] into a common framework and generalized their results. We have identified and describe some issues related to modifying a model checker that exploits symmetries. To this end, we have outlined a new algorithm for solving the canonical state problem using symbolic techniques.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms <ref> [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] </ref> typically explore the states of such a finite state machine. A major problem faced by state space exploration techniques is due to the fact that the size of the machine could be exponential in the size of the system description. <p> What makes model checking challenging is the fact that the size of S can be 8 CHAPTER 2. PRELIMINARIES exponential in the size of the specification. Efficient procedures have been developed for solving the model checking problem. Clarke, Emerson and Sistla <ref> [CES86] </ref> presented the first algorithm for CTL model checking based on explicit state space exploration. Their algorithm is linear in the size of the formula and the number of states.
Reference: [CF94] <author> G. Cooperman and L. Finkelstein. </author> <title> A Random Base Change Algorithm for Permutation Groups. </title> <journal> J. Symbolic Computation, </journal> <volume> 17(6) </volume> <pages> 513-528, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Since O (n) such cyclic shifts suffice to transform a base into another, the worst case time complexity is O (n 3 ). Recently, Las Vegas algorithms have also been proposed <ref> [CF94, BCF + 95, BLS] </ref> with expected time an order of magnitude less. 6.4.5 Extending our Algorithm How do we extend our algorithm to compute the automorphism group of a directed labeled graph? The best algorithm appears to be the following: We run the algorithm in We also maintain the group <p> As new automorphisms are discovered, we augment this group using the technique described in [Jer86]. Alternatively, the randomized algorithm in [BLS] can be employed. As we backtrack, we dynamically change base using the algorithms in [BFJ89] or use the randomized algorithm described in <ref> [CF94] </ref>. As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group [BL85]. The structure of the group can also prune out some branches that are guaranteed to not lead to any automorphism. However, discovering them requires much computation [Leo84].
Reference: [CGH + 95] <author> E. M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D. E. Long, K. L. McMillan, and L. A. Ness. </author> <title> Verification of the Futurebus+ Cache Coherence Protocol. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6(2) </volume> <pages> 217-232, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Clarke et al focus on symbolic techniques and study the complexity of related BDDs. Using carefully constructed formulas, they are able to verify the correctness of IEEE Futurebus+ standard <ref> [CGH + 95] </ref>. Emerson and Sistla focus on systems composed of isomorphic subprocesses. In both works, symmetries are specified manually. Theory for using symmetries in the presence of fairness constraints has been developed by Emerson and Sistla [ES95].
Reference: [CLM89] <author> E. M. Clarke, D. Long, and K. McMillan. </author> <title> Compositional Model Checking. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year>
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods [Pel93, God96], abstraction [Lon93], compositional approaches <ref> [CLM89] </ref> and symmetries [Ip96, CEFJ96, ES96] appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry.
Reference: [CMB90] <author> O. Coudert, J. C. Madre, and C. Berthet. </author> <title> Verifying Temporal Properties of Sequential Machines Without Building Their State Diagrams. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Proc. Workshop on Computer-Aided Verification, volume 3 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 23-32. </pages> <publisher> American Mathematical Society, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms <ref> [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] </ref> typically explore the states of such a finite state machine. A major problem faced by state space exploration techniques is due to the fact that the size of the machine could be exponential in the size of the system description. <p> Soon after Bryant announced the success of his BDD package, several groups started adapting explicit state space exploration techniques for BDDs. Some of the earliest symbolic techniques using BDDs were proposed by Coudert et al <ref> [CMB90] </ref>, Burch et al [BCMD90] and Touati et al [TSL + 90]. A symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al [BCL + 94].
Reference: [CW + 96] <author> E. M. Clarke, J. M. Wing, et al. </author> <title> Formal Methods: State of the Art and Future Directions. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4) </volume> <pages> 626-43, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Introduction As design cycles become shorter, circuit size and complexity grow larger and costs of design errors increase in magnitude [Hof95], traditional approaches like simulation are being augmented by more complete techniques like formal verification <ref> [CW + 96] </ref>. One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny.
Reference: [CYB93] <author> S.-T. Cheng, G. York, and R. K. Brayton. VL2MV: </author> <note> A Compiler from Verilog to BLIF-MV, October 1993. 72 BIBLIOGRAPHY </note>
Reference-contexts: The source code for our work is available at http://www-cad.eecs.berkeley.edu/~manku/symmetries/. 7.1 Results Our experiments deal with both sequential and combinational circuits. We start with a Verilog description. We then obtain a BLIF-MV description using a compiler called vl2mv written by Cheng <ref> [CYB93] </ref>. The BLIF-MV description is flattened using a standard VIS command. The flattened description and a set of partial mappings is then fed to our program.
Reference: [DDL77] <author> N. Deo, J. M. Davis, and R. E. Lord. </author> <title> A New Algorithm for Graph Iso-morphism. </title> <journal> BIT, </journal> <volume> 17 </volume> <pages> 16-30, </pages> <year> 1977. </year>
Reference-contexts: For planar graphs with n vertices, Hopcroft and Wong [HW74] present an O (n) time algorithm. A linear time algorithm for interval graphs is due to Lueker and Booth [LB79]. For random graphs, an O (n log n) algorithm is due to Deo et al <ref> [DDL77] </ref>. A polynomial time algorithm for graphs with bounded degree has been discovered by Luks [Luk82]. For general graphs, the best known algorithm is due to Babai and Luks [BL83]. It has a worst-case time complexity of O (c n 1=2+o (1) ). 2.6.
Reference: [EDI97] <institution> EDIF Version 3.0.0 IEC Standard 61690-1, </institution> <year> 1997. </year> <note> Version 4.0.0 is an EIA/ANSI Standard and being currently reviewed within IEC as IEC 61690-2. </note>
Reference-contexts: This is where Condition 3 in Section 5.2.2 comes into play. Although we used BLIF-MV terminology to formalize the notion of structural symmetries, we believe that our definition is general enough to be applicable to gate level descriptions like those expressible in EDIF <ref> [EDI97] </ref>, Verilog [Ver97] and VHDL [VHD93].
Reference: [EH86] <author> E. A. Emerson and J. Y. Halpern. </author> <title> "Sometimes" and "Not Never" Revisited: on Branching versus Linear Time Temporal Logic. </title> <journal> J. of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: There are effective procedures for converting a Mealy machine into a Moore machine. In general, such a conversion changes the set of state variables. 6 CHAPTER 2. PRELIMINARIES 2.2 Temporal Logic CTL* CTL* was first proposed by Emerson and Halpern <ref> [EH86] </ref>. It has two kinds of boolean formulas: state formulas that evaluate to true in a specific state, and path formulas that evaluate to true along a specific path. 2.2.1 Syntax Let AP be a finite set of atomic propositions.
Reference: [EJP97] <author> E. A. Emerson, S. Jha, and D. Peled. </author> <title> Combining Partial Order and Symmetry Reductions. </title> <editor> In E. Brinksma, editor, </editor> <booktitle> Proc. Third Intl. Workshop on Tools and Algorithms for the Construction and Analysis of Systems, </booktitle> <pages> pages 19-34. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: More recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Theory for combining partial orders and symmetries has been developed by Emerson, Jha and Peled <ref> [EJP97] </ref>. 1.1.2 Scalarsets Ip and Dill [ID93, ID96] use symmetries for speeding up verification of safety properties using explicit state exploration techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type called scalarset. <p> Recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. It might also be interesting to study how our framework can be extended to incorporate both partial orders and symmetries, as accomplished by Emerson, Jha and Peled <ref> [EJP97] </ref>. 7.3. FUTURE WORK 67 Symmetries Everywhere Symmetric systems show up almost everywhere. From high level design to layout, several CAD algorithms might benefit from a priori knowledge of symmetries in the circuit under consideration.
Reference: [Eme90] <author> E. A. Emerson. </author> <title> Temporal and Modal Logic. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 996-1072. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: Introduction As design cycles become shorter, circuit size and complexity grow larger and costs of design errors increase in magnitude [Hof95], traditional approaches like simulation are being augmented by more complete techniques like formal verification [CW + 96]. One popular verification technique is model checking <ref> [Eme90] </ref>, in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] typically explore the states of such a finite state machine.
Reference: [ES95] <author> E. A. Emerson and A. P. Sistla. </author> <title> Utilizing Symmetry when Model Checking under Fairness Assumptions: An Automata-theoretic Approach. </title> <editor> In P. Wolper, editor, </editor> <booktitle> Proc. 7th Intl. Conf. on Computer Aided Verification, </booktitle> <pages> pages 309-324. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: Emerson and Sistla focus on systems composed of isomorphic subprocesses. In both works, symmetries are specified manually. Theory for using symmetries in the presence of fairness constraints has been developed by Emerson and Sistla <ref> [ES95] </ref>. More recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. <p> We would also need theory for keeping the sets of permutations around. Finally, we need to identify scenarios where this is useful. Fairness and Partial Orders We need to incorporate fairness constraints into our framework, as done by Emer-son and Sistla <ref> [ES95] </ref>. Recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. It might also be interesting to study how our framework can be extended to incorporate both partial orders and symmetries, as accomplished by Emerson, Jha and Peled [EJP97]. 7.3.
Reference: [ES96] <author> E. A. Emerson and A. P. Sistla. </author> <title> Symmetry and Model Checking. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):105-131, 1996. 
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods [Pel93, God96], abstraction [Lon93], compositional approaches [CLM89] and symmetries <ref> [Ip96, CEFJ96, ES96] </ref> appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry. <p> Verification of cache consistency protocols has been shown to benefit from symmetries. See the survey by Pong and Dubois [PD97] for details. Symmetries have proven useful even for transistor-level verification of digital circuits [PB97]. 1.1.1 CTL* Model Checking Emerson and Sistla <ref> [ES96] </ref> and Clarke et al [CEFJ96] have developed a theory of symmetries for CTL* model checking. Both papers show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. <p> This idea is distinct from building a quotient structure. The two can be used in conjunction. 2. We unify the theories for symmetries in Kripke structures and CTL* formulas, developed by Emerson and Sistla <ref> [ES96] </ref> and Clarke et al [CEFJ96]. We extend their fundamental theorems pertaining to quotient structures. 3. We formalize the notion of structural symmetries in net-list descriptions of digital circuits and CTL* formulas. We show how these symmetries relate to those in the corresponding Kripke structures. <p> We propose a novel fast algorithm for solving the graph automorphism problem for directed labeled graphs. This problem arises during automatic extraction of structural 4 CHAPTER 1. INTRODUCTION symmetries. We note that our framework can be extended to formulas in -calculus, as done by Emerson and Sistla <ref> [ES96] </ref>. 1.3 Organization of Report In Chapter 2, we review background material. In Chapter 3, we show how the set of sub-formulas of a CTL* formula can be partitioned into equivalence classes. In Chapter 4, we develop theory for quotient structures. <p> Once they are described, it will become clear that identification of symmetric sub-formulas contributes to savings on top of quotient structures. Chapter 4 Quotient Structures In this chapter, we develop a theory of symmetries for Kripke structures, unifying those developed by Clarke et al [CEFJ96] and Emerson and Sistla <ref> [ES96] </ref>. We first show how a smaller sized quotient structure can be constructed from a Kripke structure and a CTL* formula so that it suffices to check the formula on the quotient. We then show how a model checker need be modified to use quotient structures. <p> f [[s]] G j s 2 Sg * K G ([[s]] G ) = K (~ G (s)) 4.2 Theory for Quotient Structures An important relationship between a Kripke structure and its quotient is captured by what is called the Path Correspondence Lemma. 4.2.1 The Path Correspondence Lemma Lemma 4.1 <ref> [CEFJ96, ES96] </ref> For a Kripke structure M and any group G Aut M LX, there is a correspondence between paths of M and its quotient structure M G , characterized by * If s 0 ; s 1 ; : : :; is a path in M , then [[s 0 <p> We note that the definition of H is along the same lines as that of Auto 0 f in <ref> [ES96] </ref>. However, their theory is built for a system composed of isomorphic processes such that all states are uniquely labeled i.e. AP = L. <p> AP = L. In Chapter 5, we will show how G, H and G 1 H can be computed automatically from a structural specification and CTL* formula. 4.2.5 An Extension of Emerson-Sistla Theorem Emerson and Sistla <ref> [ES96] </ref> build their theory of Kripke structures for systems of communicating isomorphic processes, with the set of atomic propositions being the set of shared variables. In our terminology, it amounts to assuming AP = L and restricting the number of initial states to one. <p> Another idea proposed by [CEFJ96] is the use of multiple representatives for each orbit. We can solve the problem for special classes of groups for which ~ is readily computed. This is the approach used by several authors <ref> [CEFJ96, ES96, ID96, HAM97] </ref>. For example, if the system is composed of a hierarchy of fully symmetric subsystems, then ~ can be computed for a given state by simply computing the canonical state for each subsystem recursively and then sorting them. 4.5 Research Problems extracts symmetries and exploits quotient structures. <p> In Section 4.2.4, we saw how knowledge of the same group G but a different H Aut f AP M P S would allow us to construct quotient structures. In both the cases, we need to compute G 1 H. In <ref> [CEFJ96, ES96, HAM97] </ref>, a group similar to G 1 H is specified by the designer manually . <p> We can also use this theory for pruning sub-formulas from a big formula so that it suffices to prove the resulting smaller sized formula. We have cast the theory of symmetries developed for Kripke structures by Clarke et al [CEFJ96] and Emerson and Sistla <ref> [ES96] </ref> into a common framework and generalized their results. We have identified and describe some issues related to modifying a model checker that exploits symmetries. To this end, we have outlined a new algorithm for solving the canonical state problem using symbolic techniques.
Reference: [FHG + 83] <author> G. Fowler, R. Haralick, F. G. Gray, C. Feustel, and C. Grinstead. </author> <title> Efficient Graph Automorphism by Vertex Partitioning. </title> <journal> Aritificial Intelligence, </journal> <volume> 21 </volume> <pages> 245-269, </pages> <year> 1983. </year>
Reference-contexts: Having computed two such functions U 1 and U 2 , we can compute the intersection U 1 fU 2 , which is also guaranteed to be at least as coarse as U min . A good exposition of these ideas can be found in <ref> [FHG + 83] </ref>, where such functions are called vertex invariants. Mittal [Mit88] also uses vertex invariants to compute automorphisms. <p> Let U be looked upon as a labeling function. Define a function U 0 as follows: for a vertex v, it computes the set of labels of vertices incident upon v. Then U 0 is a unipartition and a vertex invariant such that U min 4 U 0 <ref> [FHG + 83] </ref>. We can now refine U by computing the intersection U f U 0 . This can be done repeatedly until U = U 0 . Computing U 0 and U f U 0 requires O (m + n) time. We stop after at most n iterations.
Reference: [FHL80] <author> M. L. Furst, J. Hopcroft, and E. M. Luks. </author> <title> Polynomial Time Algorithms for Permutation Groups. </title> <booktitle> Proc. 21st IEEE Foundations of Computer Science, </booktitle> <pages> pages 36-41, </pages> <year> 1980. </year>
Reference-contexts: Sims [Sim70, Sim71] presented an algorithm for constructing a base and strong generating set from a set of generators of size s. The time complexity of the algorithm was shown to be O (n 6 + sn 2 ) by Furst, Hopcroft and Luks <ref> [FHL80] </ref> for a version of Sim's algorithm. In a note in 1981 (a preliminary version of [Knu91]), Knuth gave a variant with running time O (n 5 + sn 2 ). The same bound was also achieved by Jerrum [Jer86].
Reference: [Gap] <author> GAP: </author> <title> Groups, Algorithms and Programs, </title> <note> Version 3, Release 4. Available via ftp from ftp.math.rwth-aachen.de, </note> <institution> Lehrstuhl D fuer Mathematik, RWTH Aachen, </institution> <note> Germany; directory /pub/gap. BIBLIOGRAPHY 73 </note>
Reference-contexts: One of the earliest graph automorphism programs was written by McKay [McK81]. It is still available as nauti [McK90] and can be used with a package called Grape [Soi90], which provides routines for graphs and groups. Grape itself is one of the several packages provided by GAP <ref> [Gap] </ref>, which is a general purpose software package for combinatorial objects. Another general purpose package is MAGMA [W. 96], which has been derived from an earlier package called CAYLEY [Can84].
Reference: [God96] <author> P. Godefroid. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems: An Approach to the State-Explosion Problem, </title> <booktitle> volume 1032 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods <ref> [Pel93, God96] </ref>, abstraction [Lon93], compositional approaches [CLM89] and symmetries [Ip96, CEFJ96, ES96] appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures.
Reference: [GS97] <author> V. Gyuris and A. P. Sistla. </author> <title> On-the-Fly Model Checking under Fairness that Exploits Symmetry. </title> <booktitle> In Proc. 9th Intl. Conf. on Computer Aided Verification, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <booktitle> volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 232-243. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Emerson and Sistla focus on systems composed of isomorphic subprocesses. In both works, symmetries are specified manually. Theory for using symmetries in the presence of fairness constraints has been developed by Emerson and Sistla [ES95]. More recently, Gyuris and Sistla <ref> [GS97] </ref> have developed an on-the-fly model checker that utilizes symmetries under fairness. <p> We would also need theory for keeping the sets of permutations around. Finally, we need to identify scenarios where this is useful. Fairness and Partial Orders We need to incorporate fairness constraints into our framework, as done by Emer-son and Sistla [ES95]. Recently, Gyuris and Sistla <ref> [GS97] </ref> have developed an on-the-fly model checker that utilizes symmetries under fairness. It might also be interesting to study how our framework can be extended to incorporate both partial orders and symmetries, as accomplished by Emerson, Jha and Peled [EJP97]. 7.3.
Reference: [HAM97] <author> W. N. N. Hung, A. Aziz, and K. McMillan. </author> <title> Heuristic Symmetry Reduction for Invariant Checking. </title> <booktitle> In Workshop Notes of Intl. Workshop on Logic Synthesis, </booktitle> <year> 1997. </year>
Reference-contexts: It does not require the construction of R ~ G . In <ref> [HAM97] </ref>, it is argued that explicit methods should be preferred to symbolic ones for symmetric systems. They show that the BDD for the set of reachable states for some real systems encountered in practice is exponential in size. <p> It is easy to formally prove the correctness of the algorithm and to show that each do-while loop takes O (jLj) iterations. The exact complexity for this algorithm is yet to be determined. Does this one or a variant of it work well in practice? 4.4.3 Other Ideas In <ref> [HAM97] </ref>, a heuristic procedure is used to compute ~(s) for individual states, one at a time, for an explicit model checker. Another idea proposed by [CEFJ96] is the use of multiple representatives for each orbit. <p> Another idea proposed by [CEFJ96] is the use of multiple representatives for each orbit. We can solve the problem for special classes of groups for which ~ is readily computed. This is the approach used by several authors <ref> [CEFJ96, ES96, ID96, HAM97] </ref>. For example, if the system is composed of a hierarchy of fully symmetric subsystems, then ~ can be computed for a given state by simply computing the canonical state for each subsystem recursively and then sorting them. 4.5 Research Problems extracts symmetries and exploits quotient structures. <p> In Section 4.2.4, we saw how knowledge of the same group G but a different H Aut f AP M P S would allow us to construct quotient structures. In both the cases, we need to compute G 1 H. In <ref> [CEFJ96, ES96, HAM97] </ref>, a group similar to G 1 H is specified by the designer manually . <p> In both the cases, we need to compute G 1 H. In [CEFJ96, ES96, HAM97], a group similar to G 1 H is specified by the designer manually . In <ref> [HAM97] </ref>, it is mentioned that a permutation specified by the designer can be verified simply by checking that the transition relation BDD obtained by the corresponding variable substitution is the same as the original one.
Reference: [Her75] <author> I. N. Herstein. </author> <title> Topics in Algebra. </title> <institution> Xerox College Pub., Lexington, Mas-sachusetts, </institution> <year> 1975. </year>
Reference-contexts: Model checking of LTL formulas can be done using language containment and tableau construction [VW86]. 2.4 Permutation Groups A classic reference for group theory is a textbook by Herstein <ref> [Her75] </ref>. Permutation groups are studied in a book by Wielandt [Wie64]. Practical algorithms for manipulating permutation groups are presented by Butler [But91]. 2.4.1 Definitions A permutation is a bijective mapping : S ! S defined over a finite non-empty set S. Permutations are usually written in cycle form.
Reference: [HJJ84] <author> P. Huber, L. Jepsen, and K. Jensen. </author> <title> Towards Reachability Trees for High-level Petri Nets. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances on Petri Nets, </booktitle> <pages> pages 215-233, </pages> <year> 1984. </year>
Reference-contexts: Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry. The same holds for concurrent programs. Typically all designs that have replicated subcomponents exhibit symmetry. 2 CHAPTER 1. INTRODUCTION Huber, Jepsen and Jensen <ref> [HJJ84] </ref> and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson [AE89]. The approach uses quotient structures induced by automorphisms of the system.
Reference: [Hof80] <author> C. M. Hoffman. </author> <title> On the Complexity of Intersecting Permutation Groups and its Relationship with Graph Isomorphism. </title> <type> Technical Report 4/80, </type> <institution> Institut for Informatik und Praktische Mathematik, Christian-Albrechts-Universitat Kiel, </institution> <year> 1980. </year>
Reference-contexts: An advantage of this idea is that we would need to compute G only once. We can compute different groups H for different formulas f . However, computing group intersections is as hard as graph isomorphism <ref> [Hof80] </ref>. Polynomial time algorithms do exist for special cases [Hof80]. Another approach is to simply join the two graphs corresponding to G and H together at the vertices corresponding to AP . <p> An advantage of this idea is that we would need to compute G only once. We can compute different groups H for different formulas f . However, computing group intersections is as hard as graph isomorphism <ref> [Hof80] </ref>. Polynomial time algorithms do exist for special cases [Hof80]. Another approach is to simply join the two graphs corresponding to G and H together at the vertices corresponding to AP . This can be done by drawing an edge between every pair of vertices that correspond to the same p 2 AP in both the graphs.
Reference: [Hof82] <author> C. M. Hoffman. </author> <title> Group-Theoretic Algorithms and Graph Isomorphism, volume 136. </title> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: 2 ; E 2 ), is there a bijective mapping : V 1 ! V 2 such that (8v 1 ; v 2 2 V 1 )((v 1 ; v 2 ) 2 E 1 , (v 1 ; v 2 ) 2 E 2 )? The book by Hoffman <ref> [Hof82] </ref> and Section 2.6 of the survey by van Leeuwen [vL90] present a comprehensive summary of algorithmic results pertaining to the graph isomor-phism problem. The problem has withstood all attempts at a solution to date. It is neither known to be NP-complete nor known to be polynomially solvable.
Reference: [Hof95] <author> R. D. Hof. </author> <title> Intel takes a bullet and barely breaks stride. </title> <booktitle> Business Week, </booktitle> <pages> pages 38-39, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Introduction As design cycles become shorter, circuit size and complexity grow larger and costs of design errors increase in magnitude <ref> [Hof95] </ref>, traditional approaches like simulation are being augmented by more complete techniques like formal verification [CW + 96]. One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny.
Reference: [HU79] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In the context of hardware verification, L corresponds to the set of latches, AP corresponds to the set of outputs of the circuit and K represents boolean predicates on latches that generate the outputs. A Kripke structure models the state transition graph of a Moore machine <ref> [HU79] </ref>, where the outputs are functions of the current state variables. In general, it cannot model a Mealy machine, where the outputs could depend on the inputs as well. There are effective procedures for converting a Mealy machine into a Moore machine. <p> The problem remains hard for directed acyclic graphs, bipartite graphs and regular graphs. Polynomial algorithms are known for a few special cases. For rooted trees with n vertices, the problem can be solved in O (n) time (Theorem 3.3 in the book by Hopcroft and Ullman <ref> [HU79] </ref>). For planar graphs with n vertices, Hopcroft and Wong [HW74] present an O (n) time algorithm. A linear time algorithm for interval graphs is due to Lueker and Booth [LB79]. For random graphs, an O (n log n) algorithm is due to Deo et al [DDL77].
Reference: [HW74] <author> J. E. Hopcroft and J. K. Wong. </author> <title> Linear Time Algorithm for Isomorphism of Planar Graphs. </title> <booktitle> In Proc. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 172-184, </pages> <year> 1974. </year> <note> 74 BIBLIOGRAPHY </note>
Reference-contexts: Polynomial algorithms are known for a few special cases. For rooted trees with n vertices, the problem can be solved in O (n) time (Theorem 3.3 in the book by Hopcroft and Ullman [HU79]). For planar graphs with n vertices, Hopcroft and Wong <ref> [HW74] </ref> present an O (n) time algorithm. A linear time algorithm for interval graphs is due to Lueker and Booth [LB79]. For random graphs, an O (n log n) algorithm is due to Deo et al [DDL77].
Reference: [ID93] <author> C. N. Ip and D. L. Dill. </author> <title> Better Verification through Symmetry. </title> <booktitle> In 11th IFIP WG10.2 Intl. Conf. on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 97-111, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: More recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Theory for combining partial orders and symmetries has been developed by Emerson, Jha and Peled [EJP97]. 1.1.2 Scalarsets Ip and Dill <ref> [ID93, ID96] </ref> use symmetries for speeding up verification of safety properties using explicit state exploration techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type called scalarset.
Reference: [ID96] <author> C. N. Ip and D. L. Dill. </author> <title> Better Verification Through Symmetry. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):41-76, 1996. 
Reference-contexts: More recently, Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Theory for combining partial orders and symmetries has been developed by Emerson, Jha and Peled [EJP97]. 1.1.2 Scalarsets Ip and Dill <ref> [ID93, ID96] </ref> use symmetries for speeding up verification of safety properties using explicit state exploration techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type called scalarset. <p> Another idea proposed by [CEFJ96] is the use of multiple representatives for each orbit. We can solve the problem for special classes of groups for which ~ is readily computed. This is the approach used by several authors <ref> [CEFJ96, ES96, ID96, HAM97] </ref>. For example, if the system is composed of a hierarchy of fully symmetric subsystems, then ~ can be computed for a given state by simply computing the canonical state for each subsystem recursively and then sorting them. 4.5 Research Problems extracts symmetries and exploits quotient structures. <p> In [HAM97], it is mentioned that a permutation specified by the designer can be verified simply by checking that the transition relation BDD obtained by the corresponding variable substitution is the same as the original one. In <ref> [ID96] </ref>, the symmetries are extracted from high-level descriptions having a new data type with restricted usage. A priori knowledge of symmetries obviates the need for computing G 1 H.
Reference: [Ip96] <author> Norris Ip. </author> <title> State Reduction Methods for Automatic Formal Verification. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods [Pel93, God96], abstraction [Lon93], compositional approaches [CLM89] and symmetries <ref> [Ip96, CEFJ96, ES96] </ref> appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry. <p> They propose augmentation of the language itself by introducing a new data type called scalarset. A set of state variables is said to constitute a scalarset if they are fully symmetric with respect to each other. The augmented language imposes syntactic constraints on their usage. In <ref> [Ip96] </ref>, it is shown how reflexive ring symmetries like those found in the Dining Philosophers Problem can similarly be handled. 1.2. NEW IDEAS 3 Scalarsets have two advantages. First, violation of syntactic constraints can be detected during compile time.
Reference: [Jer86] <author> M. Jerrum. </author> <title> A Compact Representation for Permutation Groups. </title> <journal> J. Algorithms, </journal> <volume> 27 </volume> <pages> 60-78, </pages> <year> 1986. </year>
Reference-contexts: In a note in 1981 (a preliminary version of [Knu91]), Knuth gave a variant with running time O (n 5 + sn 2 ). The same bound was also achieved by Jerrum <ref> [Jer86] </ref>. Subsequently, an O (n 4 log c n + sn 2 ) algorithm was discovered by Babai, Luks and Seress [BLS97]. 6.4.2 Jerrum's Representation Jerrum [Jer86] devised an elegant data structure called labeled branchings to store a strong generating set in O (n 2 ) space. <p> The same bound was also achieved by Jerrum <ref> [Jer86] </ref>. Subsequently, an O (n 4 log c n + sn 2 ) algorithm was discovered by Babai, Luks and Seress [BLS97]. 6.4.2 Jerrum's Representation Jerrum [Jer86] devised an elegant data structure called labeled branchings to store a strong generating set in O (n 2 ) space. Essentially, a given strong generating set is reduced to at most n1 permutations and stored in a certain way. <p> Assuming that each permutation is represented by storing the images of elements of in an array, the bound of O (n 2 ) is optimal as there exist groups which require at least (n) generators <ref> [Jer86] </ref>. The data structure supports fast membership testing in O (n 2 ) time. <p> As new automorphisms are discovered, we augment this group using the technique described in <ref> [Jer86] </ref>. Alternatively, the randomized algorithm in [BLS] can be employed. As we backtrack, we dynamically change base using the algorithms in [BFJ89] or use the randomized algorithm described in [CF94]. As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group [BL85].
Reference: [Knu91] <author> D. E. Knuth. </author> <title> Efficient Representation of Permutation Groups. </title> <booktitle> In Combina-torica, </booktitle> <pages> pages 33-44, </pages> <year> 1991. </year>
Reference-contexts: The time complexity of the algorithm was shown to be O (n 6 + sn 2 ) by Furst, Hopcroft and Luks [FHL80] for a version of Sim's algorithm. In a note in 1981 (a preliminary version of <ref> [Knu91] </ref>), Knuth gave a variant with running time O (n 5 + sn 2 ). The same bound was also achieved by Jerrum [Jer86].
Reference: [Kur87] <author> R. P. Kurshan. </author> <title> Testing Containment of Omega-regular Languages. In Reducibility in Analysis of Coordination, </title> <booktitle> volume 103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Typically all designs that have replicated subcomponents exhibit symmetry. 2 CHAPTER 1. INTRODUCTION Huber, Jepsen and Jensen [HJJ84] and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan <ref> [Kur87] </ref> and Attie and Emerson [AE89]. The approach uses quotient structures induced by automorphisms of the system. For example, symmetry between 0 and 1 in the alternating bit protocol is factored out to reduce the size of the state space by one half.
Reference: [LB79] <author> G. S. Lueker and K. S. Booth. </author> <title> A Linear Time Algorithm for Deciding Interval Graph Isomorphism. </title> <journal> J. of the ACM, </journal> <volume> 26 </volume> <pages> 183-195, </pages> <year> 1979. </year>
Reference-contexts: For planar graphs with n vertices, Hopcroft and Wong [HW74] present an O (n) time algorithm. A linear time algorithm for interval graphs is due to Lueker and Booth <ref> [LB79] </ref>. For random graphs, an O (n log n) algorithm is due to Deo et al [DDL77]. A polynomial time algorithm for graphs with bounded degree has been discovered by Luks [Luk82]. For general graphs, the best known algorithm is due to Babai and Luks [BL83].
Reference: [Leo84] <author> J. S. Leon. </author> <title> Computing Automorphism Groups of Combinatorial Objects. </title> <booktitle> Computational Group Theory, </booktitle> <pages> pages 321-335, </pages> <year> 1984. </year>
Reference-contexts: The problem of finding whether two objects are isomorphic and the related problem of computing the automorphism group of a single object, have received considerable attention <ref> [Leo84, BL85] </ref>. The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved [McK81]. <p> One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved [McK81]. Subsequently, Butler and Lam [BL85] presented a modification that prunes false branches by dynamically changing the base and strong generating set. Leon <ref> [Leo84] </ref> also discusses similar techniques. All the algorithms employ backtrack search. <p> As we branch, we use Lemma 6.7 to avoid re-discovering any automorphism already in the group [BL85]. The structure of the group can also prune out some branches that are guaranteed to not lead to any automorphism. However, discovering them requires much computation <ref> [Leo84] </ref>. In practice, it might be useful to tailor our algorithm to perform really well on the kind of symmetries that occur in practice. It might also be advantageous to compute only 6.5.
Reference: [Leo91] <author> J. S. Leon. </author> <title> Permutation Group Algorithms based on Partitions. I. Theory and Algorithms. </title> <journal> J. Symbolic Computation, </journal> <volume> 12(4-5):533-583, </volume> <year> 1991. </year>
Reference-contexts: The problem of finding whether two objects are isomorphic and the related problem of computing the automorphism group of a single object, have received considerable attention [Leo84, BL85]. The paper by Leon <ref> [Leo91] </ref> presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved [McK81].
Reference: [LN91] <author> B. Lin and A. R. </author> <title> Newton. Efficient Symbolic Manipulation of Equivalence Relations and Classes. </title> <booktitle> In Proc. 1991 Intl. Workshop of Formal Methods in VLSI Design, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: The motivation is to use the method of Lin <ref> [LN91] </ref> to construct ~ G from fi G .
Reference: [Lon93] <author> D. </author> <title> Long. Model Checking, Abstraction and Compositional Verification. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods [Pel93, God96], abstraction <ref> [Lon93] </ref>, compositional approaches [CLM89] and symmetries [Ip96, CEFJ96, ES96] appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures.
Reference: [Luk82] <author> E. M. Luks. </author> <title> Isomorphism of Graphs of Bounded Valence can be Tested in Polynomial Time. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 25(1) </volume> <pages> 42-65, </pages> <month> August </month> <year> 1982. </year> <note> BIBLIOGRAPHY 75 </note>
Reference-contexts: A linear time algorithm for interval graphs is due to Lueker and Booth [LB79]. For random graphs, an O (n log n) algorithm is due to Deo et al [DDL77]. A polynomial time algorithm for graphs with bounded degree has been discovered by Luks <ref> [Luk82] </ref>. For general graphs, the best known algorithm is due to Babai and Luks [BL83]. It has a worst-case time complexity of O (c n 1=2+o (1) ). 2.6.
Reference: [McK77] <author> B. D. McKay. </author> <title> Computing Automorphisms and Canonical Labelings of Graphs. </title> <booktitle> In Intl. Conf. on Combinatorial Mathematics, Canberra, volume 686 of Lecture Notes in Computer Science, </booktitle> <pages> pages 223-232. </pages> <publisher> Springer Verlag, </publisher> <year> 1977. </year>
Reference-contexts: The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay <ref> [Bre76, McK77] </ref>. It employed branch and bound and was soon improved [McK81]. Subsequently, Butler and Lam [BL85] presented a modification that prunes false branches by dynamically changing the base and strong generating set. Leon [Leo84] also discusses similar techniques. All the algorithms employ backtrack search.
Reference: [McK81] <author> B. D. McKay. </author> <title> Practical Graph Isomorphism. </title> <booktitle> In Proc. Tenth Manitoba Conf. on Numerical Math. and Computing, Winnepeg, 1980, </booktitle> <volume> vol 1, </volume> <booktitle> volume 30 of Congr. Numer., </booktitle> <pages> pages 45-87, </pages> <year> 1981. </year>
Reference-contexts: The paper by Leon [Leo91] presents powerful techniques for general combinatorial objects. One of the first practical graph isomorphism algorithms was proposed by McKay [Bre76, McK77]. It employed branch and bound and was soon improved <ref> [McK81] </ref>. Subsequently, Butler and Lam [BL85] presented a modification that prunes false branches by dynamically changing the base and strong generating set. Leon [Leo84] also discusses similar techniques. All the algorithms employ backtrack search. <p> One of the earliest graph automorphism programs was written by McKay <ref> [McK81] </ref>. It is still available as nauti [McK90] and can be used with a package called Grape [Soi90], which provides routines for graphs and groups. Grape itself is one of the several packages provided by GAP [Gap], which is a general purpose software package for combinatorial objects.
Reference: [McK90] <author> B. D. McKay. </author> <title> Nauty Users Guide (Version 1.5). </title> <type> Technical Report TR-CS-90-02, </type> <institution> Computer Science Department, Australian National University, Australia, </institution> <year> 1990. </year>
Reference-contexts: In such a case, we are better off using n different breadth first searches to compute the distance matrix for a total time of O (n 2 ). Several other vertex invariants, which are useful for special types of graphs can be found in <ref> [McK90] </ref>. In practice, we should use only those that can be computed in linear time. 6.3.3 Repeated Refinement An important trick is to use a unipartition U to refine itself. Let U be looked upon as a labeling function. <p> One of the earliest graph automorphism programs was written by McKay [McK81]. It is still available as nauti <ref> [McK90] </ref> and can be used with a package called Grape [Soi90], which provides routines for graphs and groups. Grape itself is one of the several packages provided by GAP [Gap], which is a general purpose software package for combinatorial objects.
Reference: [Mit88] <author> H. B. Mittal. </author> <title> A Fast Backtrack Algorithm for Graph Isomorphism. </title> <journal> Inf. Proc. Let., </journal> <volume> 29 </volume> <pages> 105-110, </pages> <year> 1988. </year>
Reference-contexts: A good exposition of these ideas can be found in [FHG + 83], where such functions are called vertex invariants. Mittal <ref> [Mit88] </ref> also uses vertex invariants to compute automorphisms.
Reference: [PB97] <author> M. Pandey and E. Bryant. </author> <title> Exploiting Symmetry when Verifying Transistor-Level Circuits by Symbolic Trajectory Evaluation. </title> <booktitle> In Proc. 9th Intl. Conf. on Computer Aided Verification, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <booktitle> volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-255. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Verification of cache consistency protocols has been shown to benefit from symmetries. See the survey by Pong and Dubois [PD97] for details. Symmetries have proven useful even for transistor-level verification of digital circuits <ref> [PB97] </ref>. 1.1.1 CTL* Model Checking Emerson and Sistla [ES96] and Clarke et al [CEFJ96] have developed a theory of symmetries for CTL* model checking. <p> FUTURE WORK 67 Symmetries Everywhere Symmetric systems show up almost everywhere. From high level design to layout, several CAD algorithms might benefit from a priori knowledge of symmetries in the circuit under consideration. Pandey and Bryant <ref> [PB97] </ref> have demonstrated how transistor-level verification of digital circuits can benefit from symmetries. It would be interesting to extend the applicability of symmetries to other domains. 69
Reference: [PD97] <author> F. Pong and M. Dubois. </author> <title> Verification Techniques for Cache Coherence Protocols. </title> <journal> ACM Computing Surveys, </journal> <volume> 29(1) </volume> <pages> 82-126, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: For example, symmetry between 0 and 1 in the alternating bit protocol is factored out to reduce the size of the state space by one half. Verification of cache consistency protocols has been shown to benefit from symmetries. See the survey by Pong and Dubois <ref> [PD97] </ref> for details. Symmetries have proven useful even for transistor-level verification of digital circuits [PB97]. 1.1.1 CTL* Model Checking Emerson and Sistla [ES96] and Clarke et al [CEFJ96] have developed a theory of symmetries for CTL* model checking.
Reference: [Pel93] <author> D.A. Peled. </author> <title> All from One, One for All: On Model Checking Using Representatives. </title> <booktitle> In Proc. 5th Intl. Conf. on Computer-Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 409-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This phenomenon is commonly referred to as State Space Explosion. Several techniques are being developed for countering the state space explosion problem. Partial order methods <ref> [Pel93, God96] </ref>, abstraction [Lon93], compositional approaches [CLM89] and symmetries [Ip96, CEFJ96, ES96] appear to be most promising. To date, none of these techniques has been fully automated. 1.1 Symmetries Hardware circuits and distributed algorithms abound with symmetries. Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures.
Reference: [SD76] <author> D. C. Schmidt and L. E. Druffel. </author> <title> A Fast Backtrack Algorithm to Test Directed Graphs for Isomorphism using Distance Matrices. </title> <journal> J. of the ACM, </journal> <volume> 23 </volume> <pages> 433-445, </pages> <year> 1976. </year>
Reference-contexts: If the graph is acyclic, the levels of vertices constitute a vertex invariant. 6.3.2 Other Vertex Invariants We can compute some more vertex invariants at the cost of more computation by constructing the distance matrix for A <ref> [SD76] </ref>. Entries in the distance matrix are the lengths of the shortest path between pairs of vertices. Let d ij be the number of vertices that are a distance j from i.
Reference: [Sei95] <author> R. Seidel. </author> <title> On the All-Pairs-Shortest-Path Problem in Unweighted Undirected Graphs. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 51(3) </volume> <pages> 400-403, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: One such interpretation is the number of edges that are at a distance j from vertex i. Another is the number of vertices whose shortest path to i is of length j. The distance matrix can be computed using an algorithm by Seidel <ref> [Sei95] </ref> in O (n 2 log n) expected time. In practice, graphs are sparse and the out-degree of any vertex 6.4. COMPUTING THE AUTOMORPHISM GROUP OF A GRAPH 53 can be bounded by a small constant.
Reference: [Sim70] <author> C. C. Sims. </author> <title> Computational Methods in the Study of Permutation Groups. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 169-183. </pages> <publisher> Pergamon, </publisher> <address> Elmsford, N.Y., </address> <year> 1970. </year> <note> 76 BIBLIOGRAPHY </note>
Reference-contexts: See Table 7.2 on page 63 for the number of iterations required for graphs that we experimented with. 6.4 Computing the Automorphism Group of a Graph What is a good representation for Aut A and how do we compute it? 6.4.1 Base and Strong Generating Set Charles Sims <ref> [Sim70] </ref> introduced the idea of using a base and strong generating set for representing a group. This is a key concept underlying essentially all polynomial-time algorithms in computational group theory. A good exposition can be found in the book by Butler [But91]. <p> Note that any ordering of can act as a base. In general, some R x i might consist only of the identity permutation. The corresponding x i can be removed from the base to obtain a reduced base. Sims <ref> [Sim70, Sim71] </ref> presented an algorithm for constructing a base and strong generating set from a set of generators of size s. The time complexity of the algorithm was shown to be O (n 6 + sn 2 ) by Furst, Hopcroft and Luks [FHL80] for a version of Sim's algorithm.
Reference: [Sim71] <author> C. C. Sims. </author> <title> Computation with Permutation Groups. </title> <editor> In S. R. Petrick, editor, </editor> <booktitle> Proc. Second Symp. on Symbolic and Algebraic Manipulations, </booktitle> <pages> pages 23-28. </pages> <institution> Association for Computing Machinery, </institution> <address> New York, </address> <year> 1971. </year>
Reference-contexts: Note that any ordering of can act as a base. In general, some R x i might consist only of the identity permutation. The corresponding x i can be removed from the base to obtain a reduced base. Sims <ref> [Sim70, Sim71] </ref> presented an algorithm for constructing a base and strong generating set from a set of generators of size s. The time complexity of the algorithm was shown to be O (n 6 + sn 2 ) by Furst, Hopcroft and Luks [FHL80] for a version of Sim's algorithm. <p> Second, we need the ability to augment the group by adding a newly discovered permutation. 6.4.4 Base Change Algorithms Base change algorithms require elementary group theory but are somewhat involved. Sims proposed the first base change algorithm <ref> [Sim71] </ref>. Butler and Lam [BL85] showed that Sim's base change algorithm has worst case time complexity O (n 5 ). The algorithm can transpose two adjacent points in the base in O (n 3 ) time.
Reference: [Soi90] <author> L. H. Soicher. </author> <title> GRAPE: A System for Computing with Graphs and Groups. </title> <editor> In L. Finkelstein and W. M. Kantor, editors, </editor> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> volume 11, </volume> <pages> pages 287-291, </pages> <year> 1990. </year>
Reference-contexts: One of the earliest graph automorphism programs was written by McKay [McK81]. It is still available as nauti [McK90] and can be used with a package called Grape <ref> [Soi90] </ref>, which provides routines for graphs and groups. Grape itself is one of the several packages provided by GAP [Gap], which is a general purpose software package for combinatorial objects. Another general purpose package is MAGMA [W. 96], which has been derived from an earlier package called CAYLEY [Can84].
Reference: [Sta91] <author> P. Starke. </author> <title> Reachability Analysis of Petri Nets using Symmetries. Syst. Anal. Model. </title> <journal> Simul., </journal> 8(4/5):293-303, 1991. 
Reference-contexts: Hardware systems with symmetries include memories, caches, arithmetic circuits and distributed memory architectures. Several distributed algorithms exhibit symmetry. The same holds for concurrent programs. Typically all designs that have replicated subcomponents exhibit symmetry. 2 CHAPTER 1. INTRODUCTION Huber, Jepsen and Jensen [HJJ84] and Starke <ref> [Sta91] </ref> have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson [AE89]. The approach uses quotient structures induced by automorphisms of the system.
Reference: [TSL + 90] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: One popular verification technique is model checking [Eme90], in which temporal logic formulas are verified on a non-deterministic finite state machine that represents the system under scrutiny. Model checking algorithms <ref> [CES86, CMB90, BCMD90, TSL + 90, BCL + 94] </ref> typically explore the states of such a finite state machine. A major problem faced by state space exploration techniques is due to the fact that the size of the machine could be exponential in the size of the system description. <p> Soon after Bryant announced the success of his BDD package, several groups started adapting explicit state space exploration techniques for BDDs. Some of the earliest symbolic techniques using BDDs were proposed by Coudert et al [CMB90], Burch et al [BCMD90] and Touati et al <ref> [TSL + 90] </ref>. A symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al [BCL + 94]. Both symbolic and explicit CTL model checking algorithms first compute the set of states reachable from I.
Reference: [Ver97] <author> Verilog: </author> <title> IEEE 1364 Standard, </title> <year> 1997. </year>
Reference-contexts: There would always be a limit on the kind of symmetries that a designer is allowed to declare. A more serious flaw is that specification languages in the real world are not amenable to modification. For example, Verilog <ref> [Ver97] </ref> and VHDL [VHD93] are two IEEE Hardware Description Languages that cannot be modified easily. 1.2 New Ideas We have developed a practical framework for automatically identifying symmetries in CTL* formulas and structural descriptions of digital circuits and using them in a model checker to speed up verification. <p> This is where Condition 3 in Section 5.2.2 comes into play. Although we used BLIF-MV terminology to formalize the notion of structural symmetries, we believe that our definition is general enough to be applicable to gate level descriptions like those expressible in EDIF [EDI97], Verilog <ref> [Ver97] </ref> and VHDL [VHD93]. We need be a little careful with a general language that involves if, for and while constructs. 5.3 Graphs for BLIF-MV Circuits One problem with the definition of structural symmetries in Section 5.2.2 is that Condition 3 cannot be expressed in purely graph theoretic terms.
Reference: [VHD93] <editor> VHDL: </editor> <booktitle> IEEE 1076 Standard, </booktitle> <year> 1993. </year>
Reference-contexts: There would always be a limit on the kind of symmetries that a designer is allowed to declare. A more serious flaw is that specification languages in the real world are not amenable to modification. For example, Verilog [Ver97] and VHDL <ref> [VHD93] </ref> are two IEEE Hardware Description Languages that cannot be modified easily. 1.2 New Ideas We have developed a practical framework for automatically identifying symmetries in CTL* formulas and structural descriptions of digital circuits and using them in a model checker to speed up verification. <p> This is where Condition 3 in Section 5.2.2 comes into play. Although we used BLIF-MV terminology to formalize the notion of structural symmetries, we believe that our definition is general enough to be applicable to gate level descriptions like those expressible in EDIF [EDI97], Verilog [Ver97] and VHDL <ref> [VHD93] </ref>. We need be a little careful with a general language that involves if, for and while constructs. 5.3 Graphs for BLIF-MV Circuits One problem with the definition of structural symmetries in Section 5.2.2 is that Condition 3 cannot be expressed in purely graph theoretic terms.
Reference: [vL90] <author> J. van Leeuwen. </author> <title> Graph Algorithms. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms and Complexity, volume A of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 525-631. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: : V 1 ! V 2 such that (8v 1 ; v 2 2 V 1 )((v 1 ; v 2 ) 2 E 1 , (v 1 ; v 2 ) 2 E 2 )? The book by Hoffman [Hof82] and Section 2.6 of the survey by van Leeuwen <ref> [vL90] </ref> present a comprehensive summary of algorithmic results pertaining to the graph isomor-phism problem. The problem has withstood all attempts at a solution to date. It is neither known to be NP-complete nor known to be polynomially solvable. <p> The graph automorphism problem is to compute this group from a description of A. The problem of computing whether a graph has a non-trivial automorphism is as hard as graph isomorphism. See the survey by van Leeuwen <ref> [vL90] </ref> for further results. Practical algorithms for computing the automorphism group of a directed graph have received much attention in the last two decades. We discuss them in Chapter 6. <p> Ideally, we would like to start with U min , as defined in Lemma 6.3, as it is the finest such partition. However, computing U min itself is as hard as graph isomorphism <ref> [vL90] </ref>. Therefore, we compute an approximation to U min , namely a unipartition U such that U min 4 U 4 U max using the function Refine. We will describe this function in more detail in Section 6.3. Note that U is consistent with every automorphism of A.
Reference: [VW86] <author> M. Y. Vardi and P. L. Wolper. </author> <title> An Automata-Theoretic Approach to Program Verification. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 332-334, </pages> <year> 1986. </year>
Reference-contexts: The parse tree is traversed in post order. Evaluation of truth values for a path formula can be done by using a model checker for LTL, another temporal logic. Model checking of LTL formulas can be done using language containment and tableau construction <ref> [VW86] </ref>. 2.4 Permutation Groups A classic reference for group theory is a textbook by Herstein [Her75]. Permutation groups are studied in a book by Wielandt [Wie64].
Reference: [W. 96] <author> W. Bosma and J. J. Cannon and C. Playoust. </author> <title> The Magma Algebra System I: </title> <booktitle> The User Language, </booktitle> <year> 1996. </year> <note> Submitted to J. Symbolic Computation. </note>
Reference-contexts: Grape itself is one of the several packages provided by GAP [Gap], which is a general purpose software package for combinatorial objects. Another general purpose package is MAGMA <ref> [W. 96] </ref>, which has been derived from an earlier package called CAYLEY [Can84]. What is the motivation for writing a new graph automorphism program? First, existing packages are general purpose and carry around a lot of baggage. In our experience, they are slow.
Reference: [Wie64] <author> H. Wielandt. </author> <title> Finite Permutation Groups. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1964. </year>
Reference-contexts: Model checking of LTL formulas can be done using language containment and tableau construction [VW86]. 2.4 Permutation Groups A classic reference for group theory is a textbook by Herstein [Her75]. Permutation groups are studied in a book by Wielandt <ref> [Wie64] </ref>. Practical algorithms for manipulating permutation groups are presented by Butler [But91]. 2.4.1 Definitions A permutation is a bijective mapping : S ! S defined over a finite non-empty set S. Permutations are usually written in cycle form. Singleton cycles are ignored. For 2.4.
References-found: 79

