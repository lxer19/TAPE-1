URL: http://www.irisa.fr/EXTERNE/projet/lande/consel/papers/pepm-rpc.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/pe-97/
Root-URL: 
Email: fmuller,volanski,marletg@irisa.fr  
Title: Scaling up Partial Evaluation for Optimizing the Sun Commercial RPC Protocol Sun RPC experiment files,
Author: Gilles Muller, Eugen-Nicolae Volanschi, Renaud Marlet 
Note: The  are publicly available upon request to the authors.  
Address: 35042 Rennes Cedex, France  
Affiliation: IRISA INRIA Campus Universitaire de Beaulieu  
Abstract: We report here a successful experiment in using partial evaluation on a realistic program, namely the Sun commercial RPC (Remote Procedure Call) protocol. The Sun RPC is implemented in a highly generic way that offers multiple opportunities of specialization. Our study also shows the incapacity of traditional binding-time analyses to treat real system programs. Our experiment has been made with Tempo, a partial evaluator for C programs targeted towards system software. Tempo's binding-time analysis had to be improved to integrate partially static data structures (interprocedu-rally), context sensitivity, use sensitivity and return sensitivity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L.O. Andersen. </author> <title> Binding-time analysis and the taming of C pointers. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993, </year> <pages> pages 4758. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Because of the complexity of the C language, those extensions were not included in early partial evaluators for C <ref> [1, 2] </ref>. BTA was not really improved further because it seemed to fit encountered problems, which were mainly toy examples or carefully (re)written programs. As explained in the following subsections, trying to run a traditional BTA on the RPC code failed miserably.
Reference: [2] <author> L.O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> DIKU Technical Report 94/19. </type>
Reference-contexts: Because of the complexity of the C language, those extensions were not included in early partial evaluators for C <ref> [1, 2] </ref>. BTA was not really improved further because it seemed to fit encountered problems, which were mainly toy examples or carefully (re)written programs. As explained in the following subsections, trying to run a traditional BTA on the RPC code failed miserably. <p> Therefore, we expect to have much better results in the future. 6 Related Work Partial Evaluators for C. To our knowledge, the only other partial evaluator for C programs is C-Mix <ref> [2] </ref>. Like Tempo, C-Mix is an off-line evaluator, based on inter-procedural analyses, and able to deal with complex data structures and side-effects. While being a powerful tool, C-Mix was not specially written to deal with system programs.
Reference: [3] <author> T. Blackwell. </author> <title> Fast decoding of tagged message formats. </title> <booktitle> In Fifteenth Annual Joint Conference of the IEEE Computer and Communication Societies, </booktitle> <address> San Francisco, CA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: However, in order to perform this aggressive optimizations, USC imposes some restrictions over the marshaled data types: types such as floating point numbers or pointers are not allowed. In fact, USC is not designed for general argument marshaling, but rather for header conversions and interfacing to memory-mapped devices. Blackwell <ref> [3] </ref> manages external data formats which allow variable encoding, such as Q.93B [10] or ASN.1 [15]. In these representations, each data field is tagged to indicate its actual format, chosen between several possible ones.
Reference: [4] <author> G. Cabillic and I. Puaut. Stardust: </author> <title> an environment for parallel programming on networks of heterogeneous workstations. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> Febru-ary </month> <year> 1997. </year>
Reference-contexts: Because large networks are often heterogeneous, distributed environments need to encode data and often rely on Sun XDR protocol (one of the components of Sun RPC). Examples of these environments are PVM [11] for a message passing model and Star-dust <ref> [4] </ref> for a Distributed Shared Memory model. The RPC implementation used in this paper is the 1984 copyrighted version of the Sun RPC. 2.1 The Layers The RPC protocol provides one main functionality (see Figure 1): it makes a remote procedure look like a local one.
Reference: [5] <author> D.D. Clark and D.L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In SIGCOMM Symposium on Communications Architectures and Protocols, pages 200208, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> Even in the cases where data copies cannot be eliminated, they are eventually replaced by cheaper operations, like page re-mapping. All these techniques are orthogonal to our study, and should indeed give best results when combined with our kind of optimizations. Optimizing Stub Compilers. Clark and Tennenhouse <ref> [5] </ref> were the first to identify the presentation layer as an important bottleneck in protocol software. They attribute it to up to 97% of the total protocol stack overhead, in some practical applications. Rather than optimizing an existing implementation, they propose some design principles to build new efficient implementations.
Reference: [6] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <pages> pages 493501, </pages> <address> Charleston, SC, USA, Jan-uary 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The Sun RPC case has been one of the driving test-examples of Tempo's research, design and implementation [25, 26]. Tempo is an off-line specializer <ref> [6] </ref>: partial evaluation is split into a preprocessing phase that performs alias, side-effect, binding-time and action (i.e., program transformation) analysis and, given some input values, a processing phase which does code generation. Tempo supports traditional compile-time specialization as well as run-time specialization [8].
Reference: [7] <author> C. Consel, L. Hornof, F. Noel, J. </author> <title> Noye, and E.N. Volanschi. A uniform approach for compile-time and run-time specialization. </title> <editor> In O. Danvy, R. Gluck, and P. Thiemann, editors, </editor> <title> Partial Evaluation, </title> <booktitle> International Seminar, Dagstuhl Castle, number 1110 in Lecture Notes in Computer Science, </booktitle> <pages> pages 5472, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. Our group is currently developing a partial evaluator for C, named Tempo <ref> [7] </ref>. It is targeted at realistic programs, as opposed to toy examples or especially (re)written programs. It is more specifically designed to treat industrial-strength system code. The RPC experiment described here has been one of the driving test examples of Tempo's recent research, design and implementation. <p> Yet, realistic programs such as RPC make a heavy use of non liftable values. That had to be addressed. 4.1 Tempo Our group is developing a partial evaluator for C, named Tempo <ref> [7] </ref>. To make sure that the analysis and optimizations that it performs address realistic programs, Tempo has been targeted towards a specific and very demanding application area: system software. The Sun RPC case has been one of the driving test-examples of Tempo's research, design and implementation [25, 26]. <p> Tempo supports traditional compile-time specialization as well as run-time specialization [8]. Both share the same common core analysis <ref> [7] </ref>. Tempo's BTA includes the above-mentioned refinements : partially static data structures (interprocedurally), flow sensitivity and context sensitivity. Though those features were already well-understood in other partial evaluation contexts like functional languages, they had to be adapted for C imperative programming.
Reference: [8] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Conference Record of the 23 rd Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <pages> pages 145156, </pages> <address> St. Petersburg Beach, FL, USA, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Tempo is an off-line specializer [6]: partial evaluation is split into a preprocessing phase that performs alias, side-effect, binding-time and action (i.e., program transformation) analysis and, given some input values, a processing phase which does code generation. Tempo supports traditional compile-time specialization as well as run-time specialization <ref> [8] </ref>. Both share the same common core analysis [7]. Tempo's BTA includes the above-mentioned refinements : partially static data structures (interprocedurally), flow sensitivity and context sensitivity. Though those features were already well-understood in other partial evaluation contexts like functional languages, they had to be adapted for C imperative programming.
Reference: [9] <author> M. Emami, R. Ghiya, and L.J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, pages 242256. ACM SIGPLAN Notices, </booktitle> <volume> 29(6), </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: We thus had to split the client encoding and decoding into two different functions, that are specialized independently. Removing this limitation is being worked on. The alias analysis implemented in Tempo is very similar to the points-to model of aliasing <ref> [9, 22] </ref>. It is interprocedural, flow-sensitive but context-insensitive. For specialization, the finer the alias analysis, the less (possibly dynamic) wrong target locations are considered, hence the less conservative (i.e., dynamic) binding times are assigned.
Reference: [10] <author> ATM Forum. </author> <title> ATM user-network interface specification version 3.0, </title> <year> 1993. </year>
Reference-contexts: In fact, USC is not designed for general argument marshaling, but rather for header conversions and interfacing to memory-mapped devices. Blackwell [3] manages external data formats which allow variable encoding, such as Q.93B <ref> [10] </ref> or ASN.1 [15]. In these representations, each data field is tagged to indicate its actual format, chosen between several possible ones.
Reference: [11] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and V. Sunde. </author> <title> PVM: Parallel Virtual Machine A Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: It is notably used for implementing widespread distributed services such as NFS [17] and NIS [21]. Because large networks are often heterogeneous, distributed environments need to encode data and often rely on Sun XDR protocol (one of the components of Sun RPC). Examples of these environments are PVM <ref> [11] </ref> for a message passing model and Star-dust [4] for a Distributed Shared Memory model.
Reference: [12] <author> L. Hornof and J. </author> <title> Noye. Accurate binding-time analysis for imperative languages: Flow, context, and return sensitivity. </title> <booktitle> In ACM SIGPLAN Conference on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Amsterdam, The Netherlands, June 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Differentiating between the two call contexts preserves a specialization opportunity. Other needs in the BTA emerged only after more experience with systems applications. They are covered in the following subsections. Additional comparisons may be found in <ref> [13, 12] </ref>. 4.2 Use Sensitivity In most situations, the data structures used within the XDR layer are partially static. Typically, these structures are passed to a procedure by means of a pointer.
Reference: [13] <author> L. Hornof, J. Noye, and C. Consel. </author> <title> Accurate partial evaluation of realistic programs via use sensitivity. </title> <type> Research Report 1064, </type> <institution> IRISA, Rennes, France, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Differentiating between the two call contexts preserves a specialization opportunity. Other needs in the BTA emerged only after more experience with systems applications. They are covered in the following subsections. Additional comparisons may be found in <ref> [13, 12] </ref>. 4.2 Use Sensitivity In most situations, the data structures used within the XDR layer are partially static. Typically, these structures are passed to a procedure by means of a pointer. <p> This issue is crucial in realistic programs, that make extensive use of non-liftable values, manipulating large nested data structures including pointers and arrays. Motivated by several examples like this one, an enhanced BTA has been implemented in Tempo. The conceptual problem was identified to be the use insensitivity <ref> [13] </ref> of traditional analyses, meaning that dynamic uses of a dual pointer pollute all the static uses.
Reference: [14] <author> P. Hoschka and C. Huitema. </author> <title> Control flow graph analysis for automatic fast path implementation. </title> <booktitle> In Second IEEE workshop on the architecture and Implementation of high performance communication subsystems, </booktitle> <address> Williamsburg, VA, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> Another difference from our study is that they generate this specialized code only on the send path. For the receive path, a generic, user-level marshaling code is executed. Hoschka and Huitema <ref> [14] </ref> convert marshaling code from a table-driven implementation to a procedure-driven implementation. In the former, a generic interpreter is selecting among several elementary decoding procedures, organized as a function table, while the latter is a straight sequence of code specialized for a given compound type.
Reference: [15] <author> ISO. </author> <title> Specification of abstract syntax notation one (ASN.1). ISO standard 8824, </title> <year> 1988. </year>
Reference-contexts: In fact, USC is not designed for general argument marshaling, but rather for header conversions and interfacing to memory-mapped devices. Blackwell [3] manages external data formats which allow variable encoding, such as Q.93B [10] or ASN.1 <ref> [15] </ref>. In these representations, each data field is tagged to indicate its actual format, chosen between several possible ones. Since unmarshaling code cannot be generated at compile time, Blackwell builds a special-purpose on-line compiler, which generates specialized marshaling code for the formats that are frequently encountered at run time.
Reference: [16] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> The Peregrine high-performance RPC system. </title> <journal> Software Practice And Experience, </journal> <volume> 23(2):201221, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> This makes it impossible to separately specialize an application module, and, in particular, our XDR example. General RPC Optimizations. A considerable amount of work has been dedicated to optimize existing RPC implementations (see for example <ref> [23, 16, 24] </ref>). In these studies, a fast path in the RPC is identified, corresponding to a performance-critical, frequently used case. The fast path is then optimized using a wide range of techniques. Some of these consist of manual optimizations on a specific layer of the RPC protocol stack.
Reference: [17] <author> Sun Microsystem. NFS: </author> <title> Network file system protocol specification. </title> <type> RFC 1094, </type> <institution> Sun Microsystem, </institution> <month> March </month> <year> 1989. </year> <month> 10 </month>
Reference-contexts: This protocol has become a standard in distributed operating systems design and implementation. It is notably used for implementing widespread distributed services such as NFS <ref> [17] </ref> and NIS [21]. Because large networks are often heterogeneous, distributed environments need to encode data and often rely on Sun XDR protocol (one of the components of Sun RPC).
Reference: [18] <author> S. O'Malley, T. Proebsting, </author> <title> and A.B. Montz. USC: A uni-versal stub compiler. </title> <type> Technical Report TR94-10, </type> <institution> University of Arizona, Department of Computer Science, </institution> <year> 1994. </year> <note> Also in Proc. Conf. on Communications Archi. Protocols and Applications. </note>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> Their transformation does not include complex optimizations. Rather, they are interested in the time vs. space tradeoff decision. O'Malley et al. <ref> [18] </ref> present another stub compiler, called USC. As opposed to XDR, which converts between a fixed host format and another fixed extern representation, USC is able to convert data between two user-specified formats. USC integrates several domain-specific optimizations, resulting in much faster code than the one produced by XDR.
Reference: [19] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 1995 ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 314324, </pages> <address> Copper Mountain Resort, CO, USA, </address> <month> December </month> <year> 1995. </year> <title> ACM Operating Systems Reviews, </title> <publisher> 29(5),ACM Press. </publisher>
Reference-contexts: Some work is still required to solve a few problems. However, first results are very encouraging. We can now consider the automation of previous operating systems specialization that have been obtained manually <ref> [20, 19] </ref>. We are currently working on the following improvements. As for RPC, we are working on the specialization of the server. The hypothesis are similar to those of the client.
Reference: [20] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <booktitle> Computing Systems, </booktitle> <address> 1(1):1132, </address> <month> Winter </month> <year> 1988. </year>
Reference-contexts: All protocol structures are constant (hence static) after the client initialization is performed. At first sight, treating the above variables as static might be considered as a trick. But is actually not uncommon in operating systems <ref> [20] </ref>. <p> Some work is still required to solve a few problems. However, first results are very encouraging. We can now consider the automation of previous operating systems specialization that have been obtained manually <ref> [20, 19] </ref>. We are currently working on the following improvements. As for RPC, we are working on the specialization of the server. The hypothesis are similar to those of the client.
Reference: [21] <author> R. Ramsey. </author> <title> All about administering NIS+. SunSoft, </title> <year> 1993. </year>
Reference-contexts: This protocol has become a standard in distributed operating systems design and implementation. It is notably used for implementing widespread distributed services such as NFS [17] and NIS <ref> [21] </ref>. Because large networks are often heterogeneous, distributed environments need to encode data and often rely on Sun XDR protocol (one of the components of Sun RPC). Examples of these environments are PVM [11] for a message passing model and Star-dust [4] for a Distributed Shared Memory model.
Reference: [22] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, pages 13 22. ACM SIGPLAN Notices, </booktitle> <volume> 30(6), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: We thus had to split the client encoding and decoding into two different functions, that are specialized independently. Removing this limitation is being worked on. The alias analysis implemented in Tempo is very similar to the points-to model of aliasing <ref> [9, 22] </ref>. It is interprocedural, flow-sensitive but context-insensitive. For specialization, the finer the alias analysis, the less (possibly dynamic) wrong target locations are considered, hence the less conservative (i.e., dynamic) binding times are assigned.
Reference: [23] <author> M.D. Schroeder and M. Burrows. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1):117, </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> This makes it impossible to separately specialize an application module, and, in particular, our XDR example. General RPC Optimizations. A considerable amount of work has been dedicated to optimize existing RPC implementations (see for example <ref> [23, 16, 24] </ref>). In these studies, a fast path in the RPC is identified, corresponding to a performance-critical, frequently used case. The fast path is then optimized using a wide range of techniques. Some of these consist of manual optimizations on a specific layer of the RPC protocol stack.
Reference: [24] <author> C.A. Thekkath and H.M. Levy. </author> <title> Low-latency communication on high-speed networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2):179203, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: A call to this procedure is done transparently on the local machine but the actual computation takes place on a distant machine. Performance is a key point in RPC. A lot of research has been carried out on the optimization of the layers of the protocol <ref> [23, 5, 16, 24, 14, 18] </ref>. Many studies have been proposed, but they necessitate the use of new protocols, incompatible with existing standard such as Sun RPC. The high genericity of the RPC implementation is an invitation to specialization. <p> This makes it impossible to separately specialize an application module, and, in particular, our XDR example. General RPC Optimizations. A considerable amount of work has been dedicated to optimize existing RPC implementations (see for example <ref> [23, 16, 24] </ref>). In these studies, a fast path in the RPC is identified, corresponding to a performance-critical, frequently used case. The fast path is then optimized using a wide range of techniques. Some of these consist of manual optimizations on a specific layer of the RPC protocol stack. <p> Rather than optimizing an existing implementation, they propose some design principles to build new efficient implementations. Among those principles, the Application Level Framing (ALF) and the Integrated Layer Processing (ILP) are directly relevant to the presentation layer. Thekkath and Levy <ref> [24] </ref> generate argument marshaling code at run-time, when a client is bound to a server. This code, especially built for the given client-server pair, is obtained by assembling simple, hand-generated code templates, corresponding to elementary data types.
Reference: [25] <author> E.N. Volanschi, G. Muller, and C. Consel. </author> <title> Safe operating system specialization: the RPC case study. </title> <booktitle> In Workshop Record of WCSSS'96 The Inaugural Workshop on Compiler Support for Systems Software, </booktitle> <pages> pages 2428, </pages> <address> Tucson, AZ, USA, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: To make sure that the analysis and optimizations that it performs address realistic programs, Tempo has been targeted towards a specific and very demanding application area: system software. The Sun RPC case has been one of the driving test-examples of Tempo's research, design and implementation <ref> [25, 26] </ref>. Tempo is an off-line specializer [6]: partial evaluation is split into a preprocessing phase that performs alias, side-effect, binding-time and action (i.e., program transformation) analysis and, given some input values, a processing phase which does code generation. Tempo supports traditional compile-time specialization as well as run-time specialization [8].
Reference: [26] <author> E.N. Volanschi, G. Muller, C. Consel, L. Hornof, J. Noye, and C. Pu. </author> <title> A uniform automatic approach to copy elimination in system extensions via program specialization. </title> <type> Research Report 2903, </type> <institution> INRIA, Rennes, France, </institution> <month> June </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: To make sure that the analysis and optimizations that it performs address realistic programs, Tempo has been targeted towards a specific and very demanding application area: system software. The Sun RPC case has been one of the driving test-examples of Tempo's research, design and implementation <ref> [25, 26] </ref>. Tempo is an off-line specializer [6]: partial evaluation is split into a preprocessing phase that performs alias, side-effect, binding-time and action (i.e., program transformation) analysis and, given some input values, a processing phase which does code generation. Tempo supports traditional compile-time specialization as well as run-time specialization [8].
References-found: 26

