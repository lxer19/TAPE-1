URL: http://www.daimi.aau.dk/~beta/Papers/OODP/distribution.ps
Refering-URL: http://www.daimi.aau.dk/~beta/Papers/OODP/oodp.abstract.html
Root-URL: http://www.daimi.aau.dk
Email: fsbrandt,olmadseng@daimi.aau.dk  
Title: Object-Oriented Distributed Programming in BETA  
Author: Soren Brandt and Ole Lehrmann Madsen 
Note: Email:  
Date: February 24, 1994  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: This paper describes abstractions that have been designed to support distributed programming in the object oriented programming language BETA. The approach is minimalistic in the sense that a goal is to provide the essential building blocks on top of which other distribution related abstractions may be built. This goal is made easier by demanding for type orthogonal persistence and distribution as the full power of the underlying language may then be used when building higher level abstractions on top of the basic ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Architechture Projects Management Ltd., Poseidon Hous, Castle Park, Cam-bridge, UK. </institution> <note> The ANSA Reference Manual, version 01.00, </note> <year> 1989. </year>
Reference-contexts: Other subpatterns of NameServer could be written on top of the basic abstractions and provided as library patterns. For example, a NameServer acting like the ANSA <ref> [1] </ref> federation based trader, a NFS-like distributed hierarchical name space and a replicated name server could be provided as library patterns. The point here is that programmers need not be tied to any built-in naming scheme, as is the case in e.g. <p> Libraries for handling distribution should of course contain these and other relevant abstractions, but as shown they are not mandatory as basic building blocks for distributed programming. 5.2 Different interfaces to the same object A number of object based distributed programming systems share the notion of conformity based type systems <ref> [4, 1] </ref>. Among other things this means that classes and types are distinct concepts, and that a given class may conform to different types. Alternative terms are "interface type" and "implementation type".
Reference: [2] <author> J.K. Bennett. </author> <title> The design and implementation of distributed smalltalk. </title> <booktitle> In OOPSLA PROCEEDINGS, </booktitle> <year> 1987. </year>
Reference-contexts: The most important difference between BETA and Emerald is that Emerald is lacking support for persistent objects 6 . The proxy approach has been used in a number of implementations of distributed object systems. For example, Distributed Smalltalk <ref> [2] </ref> uses the concept of proxy objects in the implementation. In contrast to Smalltalk, BETA is a statically typed language using runtime type checks only at assignments where covariance means that type checking is not possible at compile time [11]. <p> This section briefly discusses a general proxy based implementation of distributed BETA. The implementation of distributed BETA is based on the notion of proxy objects <ref> [2] </ref>. One possible alternative would be to use a single large (e.g. 64 bit) distributed shared memory [6, 9]. However, this possibility is ruled out by the CSCW applications needing support for heterogeneous wide area networks.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <address> New York NY: Ben-jamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: Concurrency issues includes description of active objects and communication and synchronization between them. Distribution issues includes mapping of objects onto processors, remote communication, failure handling, fault tolerance, object movement, stable persistence, etc. The distinction between logical and physical structure is also part of the method proposed by Booch <ref> [3] </ref>. As shown in figure 2, it is important to note that the physical structure is not just part of the implementation of a logical model. In the design phase there are issues related to logical design as well as issues related to physical design.
Reference: [4] <author> A. Black et al. </author> <title> Distribution and abstract types in emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1), </volume> <month> Jan </month> <year> 1987. </year>
Reference-contexts: Libraries for handling distribution should of course contain these and other relevant abstractions, but as shown they are not mandatory as basic building blocks for distributed programming. 5.2 Different interfaces to the same object A number of object based distributed programming systems share the notion of conformity based type systems <ref> [4, 1] </ref>. Among other things this means that classes and types are distinct concepts, and that a given class may conform to different types. Alternative terms are "interface type" and "implementation type".
Reference: [5] <author> Atkinson et al. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4), </volume> <month> Nov </month> <year> 1983. </year>
Reference-contexts: For example, BETA owes a lot of its expressive power to nested virtual classes, a language construct to our knowledge found in no other programming language, and especially in no distributed programming language. The principle of orthogonality also applies to object persistence <ref> [5] </ref> as it should be possible to save any object on stable storage regardless of the class to which the object belongs. Again, a good example of this is the classes of a large library. <p> The point here is that programmers need not be tied to any built-in naming scheme, as is the case in e.g. Arjuna [13] and PS-Algol <ref> [5] </ref>, but may define their own by implementing a special kind of NameServer. To get started, however, a system defined name server is needed, and in distributed BETA this is the NameServer part object of the ensemble described in section 3.3.
Reference: [6] <author> B. Koch et al. </author> <title> Cache coherency and storage management in a persistent object system. </title> <editor> In S.Zdonik A.Dearle, G.Shaw, editor, </editor> <booktitle> The Fourth International Workshop on Persistent Object Systems, </booktitle> <year> 1990. </year>
Reference-contexts: This section briefly discusses a general proxy based implementation of distributed BETA. The implementation of distributed BETA is based on the notion of proxy objects [2]. One possible alternative would be to use a single large (e.g. 64 bit) distributed shared memory <ref> [6, 9] </ref>. However, this possibility is ruled out by the CSCW applications needing support for heterogeneous wide area networks. In the proxy approach, remote references are, as illustrated in figure 9, handled by actually referencing a local representative of the remote object, the proxy.
Reference: [7] <author> E. Bal et al. </author> <title> Programming Languages for Distributed Computing Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <month> Sep </month> <year> 1989. </year>
Reference-contexts: Simple failure handling was covered in section 3.5. This section addresses a few of the issues that have been raised by others when discussing abstractions needed for distributed programming. 5.1 Synchronous versus asynchronous communication The distinction between asynchronous and synchronous communication has often been addressed in the literature <ref> [7] </ref>. Proposals nearly always conform to either a single thread per process combined with asynchronous communication and futures to achieve maximum concurrency, or multiple threads combined with blocking (synchronous) communication. BETA basicly supports the second possibility, that is multiple threads and blocking communication.
Reference: [8] <author> E. Jul et al. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> Feb </month> <year> 1988. </year>
Reference-contexts: For example "Quality of Service" and diverse communication parameters could be expressed this way, thereby gaining detailed control of different communication aspects without the need for access to the implementation of objects used. 4 Ob ject movement The primitives for object movement are the same as in Emerald <ref> [8] </ref>. However, instead of being expressed as language keywords as in Emerald, primitives for object movement in BETA are expressed syntactically as attributes of the objects. <p> Migrating active objects is still a problem, mainly due to the need to support heterogeneous networks, but also due to the fine granularity of the objects to be migrated. Most of these problems are the same as described in <ref> [8] </ref>, and may be solved in a similar way. * No distributed garbage collection. Efficient algorithms for doing distributed garbage collection are still an area open for investigation. However, there should be no special problems with doing distributed garbage collection in BETA as compared to other distributed OO languages.
Reference: [9] <author> J.S. Chase et al. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <booktitle> In OOPSLA PROCEEDINGS, </booktitle> <pages> pages 397-413, </pages> <year> 1992. </year>
Reference-contexts: This section briefly discusses a general proxy based implementation of distributed BETA. The implementation of distributed BETA is based on the notion of proxy objects [2]. One possible alternative would be to use a single large (e.g. 64 bit) distributed shared memory <ref> [6, 9] </ref>. However, this possibility is ruled out by the CSCW applications needing support for heterogeneous wide area networks. In the proxy approach, remote references are, as illustrated in figure 9, handled by actually referencing a local representative of the remote object, the proxy.
Reference: [10] <author> O. Agesen et al. </author> <title> Language Level Support for Persistence in BETA. </title> <editor> In J.L. Knudsen, O.L. Madsen, and B. Magnusson ands M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> Sep </month> <year> 1993. </year>
Reference-contexts: (* Reference to the ensemble running this shell: *) myEnsemble: ^|ensemble; (* Method for killing this shell: *) kill: (# ... #); (* The virtual global errorhandler of this shell: *) globalHandler:&lt; errorHandler; #) 3.3 The Ensemble The ensemble described in this article is based on the ensemble described in <ref> [10] </ref>. Minor changes have been made to model the reality of a distributed environment with a possibly large number of processors and network hosts. The model of persistence described in [10] has also been concretized and changed slightly. <p> *) globalHandler:&lt; errorHandler; #) 3.3 The Ensemble The ensemble described in this article is based on the ensemble described in <ref> [10] </ref>. Minor changes have been made to model the reality of a distributed environment with a possibly large number of processors and network hosts. The model of persistence described in [10] has also been concretized and changed slightly. The ensemble is a platform for executing BETA programs and should to some extend be thought of as equivalent to an operating system.
Reference: [11] <editor> O.L. Madsen et al. </editor> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: For example, Distributed Smalltalk [2] uses the concept of proxy objects in the implementation. In contrast to Smalltalk, BETA is a statically typed language using runtime type checks only at assignments where covariance means that type checking is not possible at compile time <ref> [11] </ref>. The pattern of a BETA object is immutable, thereby avoiding the distribution specific problems resulting from mutable Smalltalk classes. 7 The proxy approach Until this point we have primarily been focusing on the logical model of distributed programming in BETA.
Reference: [12] <author> P. Andersen et al. </author> <title> The Mjolner BETA system. </title> <editor> In J.L. Knudsen, O.L. Mad-sen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> Sep </month> <year> 1993. </year>
Reference-contexts: An active object thus defines an independent thread. Active objects may be executed concurrently or as coroutines. Access to shared objects may be synchronized by means of semaphores. Semaphores are, however, mainly used as a primitive for defining higher-level concurrency abstractions. The Mjolner BETA System <ref> [12] </ref> provides a library with a number of pre-defined concurrency abstractions corresponding to monitors and Ada-like tasks with rendezvous. These abstractions are all defined using BETA patterns and semaphores. <p> This version is also part of the Mjolner BETA System described in <ref> [12] </ref>. The current version of the PersistentStore supports automatic pointer swizzling using tagged pointers as well as a tailorable graph-traversal algorithm for limiting persistence as described in section 3.4.1.
Reference: [13] <author> S.Shrivastava et al. </author> <title> An Overview of the Arjuna Distributed Programming System. </title> <journal> IEEE Softwaare, </journal> <pages> pages 66-73, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: The point here is that programmers need not be tied to any built-in naming scheme, as is the case in e.g. Arjuna <ref> [13] </ref> and PS-Algol [5], but may define their own by implementing a special kind of NameServer. To get started, however, a system defined name server is needed, and in distributed BETA this is the NameServer part object of the ensemble described in section 3.3. <p> An example of this is shown in appendix A, where a reference to the MessageDistributor part of the MessageDistributorShell is exported to the NameServer. 15 5.3 Missing aspects Transactions are not directly supported by the abstractions described in this paper. However, among others, the Arjuna project <ref> [13] </ref> has shown that transactions can be supported by a number of library classes. A similar approach can be taken with respect to support for transactions in BETA. <p> Concerning replication, Argus and Arjuna among others have shown that object replication is easily achieved on top of a transaction mechanism. Apart from transactions, security is clearly a missing aspect needing future consideration. 6 Related work The Arjuna <ref> [13] </ref> project focuses on the implementation of atomic actions using the inheritance mechanism provided by C++. In Arjuna, a persistent object is by definition a transactional object.
Reference: [14] <author> Tanenbaum et. al. </author> <title> Experiences with the amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33 </volume> <pages> 46-63, </pages> <month> Dec </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: As the Ensemble is an abstraction modeling the operating system of a network host, there is a one-to-one correspondence between Ensemble instances and network hosts 3 . 3 In a true distributed operating system such as Amoeba <ref> [14] </ref>, the ensemble would model the operating system and therefore possibly a large number of processors/network hosts. 8 ensemble: shell (# (* Application program patterns: *) applicationProgram1: shell (# ... #); applicationProgram2: shell (# ... #); ... (* Instances of application programs: *) app1: ^|applicationProgram1; app2: ^|applicationProgram2; ... do (* Instantiation
Reference: [15] <author> J. Hem L. Sloth. </author> <title> Object oriented model for the distributed object oriented database. </title> <type> Technical report, EuroCODE, </type> <institution> Workpackage WP2 Deliverable D2.2, </institution> <year> 1993. </year>
Reference-contexts: A distributed object oriented database for BETA objects supporting nested transactions has already been built using a prototype implementation of the abstractions described in this paper <ref> [15] </ref>. Concerning replication, Argus and Arjuna among others have shown that object replication is easily achieved on top of a transaction mechanism.
Reference: [16] <author> N. E. Larsen. </author> <title> An object-oriented database in emerald. </title> <type> Master's thesis, </type> <institution> DIKU, Department of Computer Science, University of Copenhagen, </institution> <year> 1992. </year>
Reference-contexts: of a method call of the form (a,o []) -&gt; foo.m -&gt; c; where "foo" is an instance of the pattern fooPat, a is an integer passed by value and o [] is an object passed by reference. 6 Although an object oriented database for Emerald objects is being developed <ref> [16] </ref>. 7 In principle one could as well move the real object to the site of the caller.
Reference: [17] <author> B. Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> Mar </month> <year> 1988. </year>
Reference-contexts: That PersistentStore is virtual means that it may be extended in subpatterns of PersistentShell. When an ensemble running a PersistentShell crashes, the PersistentShell is automatically restarted when the ensemble comes up. When this happens, the restart virtual, corresponding to the recover operation of Argus <ref> [17] </ref> guardians, is executed. PersistentShell: shell (# ps: @PersistentStore; PersistentStore:&lt; NameServer (# ... #) restart:&lt; (# ... #); #) An object o is made persistent by associating it with a persistent store. A non-persistent object is called transient. <p> The ON-TOS application programmer who needs to save the transitive closure thus has to implement the necessary book-keeping himself. As stated earlier, we believe that saving the full transitive closure is in practice the best default. In Argus <ref> [17] </ref>, persistent objects must explicitly be declared stable. As a consequence of the transactional semantics built into the language, the stable storage copy of any persistent object is always up-to-date. Persistence is not reachability based, and therefore it is no issue whether references should be followed or not. <p> However, Arjuna has shown that a transaction mechanism may be expressed using inheritance. This approach could also be used to build a transaction library in BETA to facilitate development of applications needing transactional behaviour. In Argus <ref> [17] </ref>, transaction mechanisms are part of the language definition. Distributed access to objects is restricted to guardians using an RPC mechanism for communication between guardians.
Reference: [18] <author> O.L. Madsen. </author> <title> Building abstractions for concurrent object-oriented program ming (draft). </title> <institution> Computer Science Department, Aarhus, </institution> <month> Feb </month> <year> 1993. </year>
Reference-contexts: These abstractions are all defined using BETA patterns and semaphores. If the user is not satisfied with the concurrency abstractions of the library it is easy to define new ones, see <ref> [19, 18] </ref>. A pattern is a general abstraction mechanism that unifies abstraction mechanisms such as class, generic class, procedure, function, process, coroutine, exception, etc. A pattern P is declared in the following way: P: Super (# Dec1l; Decl2; ... Decln enter In do Imp1; Imp2; ... <p> We already have a clear model of how we would like to think about distribution with respect to BETA, as described in section 3. Furthermore, the BETA language is a concurrent language <ref> [18] </ref>, and so there is no reason why we should change or add anything to the language to handle this aspect of distributed programming. Simple failure handling was covered in section 3.5. <p> If a read on the future is executed before a write, the reader will be blocked on the semaphore until the write happens. Other examples of abstractions for concurrency are shown in <ref> [18] </ref>.
Reference: [19] <author> B. Moller-Pedersen O.L. Madsen and K. Nygaard. </author> <title> Object-Oriented Program ming in the BETA Programming Language. </title> <publisher> Addison Wesley, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction This paper describes abstractions that have been designed to support distributed programming in the object oriented programming language BETA <ref> [19] </ref>. The abstractions are relatively simple, as they are designed to cope only with distribution specifics, whereas e.g. concurrency issues are dealt with by the basic BETA language. <p> These abstractions are all defined using BETA patterns and semaphores. If the user is not satisfied with the concurrency abstractions of the library it is easy to define new ones, see <ref> [19, 18] </ref>. A pattern is a general abstraction mechanism that unifies abstraction mechanisms such as class, generic class, procedure, function, process, coroutine, exception, etc. A pattern P is declared in the following way: P: Super (# Dec1l; Decl2; ... Decln enter In do Imp1; Imp2; ... <p> A subsequent call of R3 will resume its execution at the point where it suspended. The imperative R4.fork will execute R4 as a concurrent process. The calling process will continue its execution. For a more detailed description of BETA, see <ref> [19] </ref>. In the next section an example of a BETA program is given. 2.1 Example Throughout this article, most BETA code shown will be extracts from an example illustrating the development process from prototype to final application. <p> The physical structure of a BETA program includes its organization of the program text in terms of interface modules, implementation modules, variants, versions, etc. The basic BETA language does not include mechanisms for describing the physical structure, because the physical structure is independent of the logical structure. In <ref> [19] </ref>, the mechanism for describing the physical organization of the program text is described in details. The logical model describes the system in terms of objects and patterns, including a description of active and passive objects. Communication and synchronization of active objects are also described. <p> Handling an exception thus means further binding the corresponding virtual method by using the ::&lt; operator. Note that there are no special language constructs in BETA for handling exceptions. For a description of exception handling in BETA, see <ref> [19] </ref>, chapter 16. 12 do catch: errorHandler (# connectionBroken::&lt; (* Connection to 'theObj' lost. *) (# do &lt;<Do local cleanup&gt;>; (* Propagate exception to surrounding ErrorHandler: *) theObj [] -&gt; prevHandler.connectionBroken; #); timeOuts: @Integer; (* Number of seconds to wait for an answer: *) timeOutValue::&lt; (# do 5 -&gt; value #);
Reference: [20] <author> OMG. </author> <title> The Common Object Request Broker Architechture and Specification, </title> <month> Dec </month> <year> 1991. </year> <title> Document number 91.12.1, Revision 1.1. </title>
Reference-contexts: Again, a good example of this is the classes of a large library. Another gain from the full generality of a powerful programming language is that fewer distribution specific language constructs are needed, thereby keeping the total number of language constructs at a minimum. For example, CORBA 1 <ref> [20] </ref> includes a type system, an interface definition language and a way of handling exceptions. CORBA is referred to as "language independent". In our opinion there is no such thing as language independence. Instead CORBA defines a new language expressing a subset of a number of other languages.
Reference: [21] <author> Ontos, Inc. </author> <title> Three Burlington Woods Burlington. ONTOS Reference Manual, </title> <address> June 1991. MA 01803. </address>
Reference-contexts: In this case, it may make no sense to follow the reference when saving the object containing the reference. Instead one might want to remember what object was referred, but without actually following the reference. There are a number of possible ways to handle this problem. In the ONTOS <ref> [21] </ref> object oriented database system for C++, references to persistent objects are saved automatically, but without saving the state of the object referred. The ON-TOS application programmer who needs to save the transitive closure thus has to implement the necessary book-keeping himself.
Reference: [22] <author> J. Robie and B. </author> <title> Witte. </title> <booktitle> The POET handbook. </booktitle> <address> Berlin, Germany, </address> <year> 1991. </year>
Reference-contexts: As a consequence of the transactional semantics built into the language, the stable storage copy of any persistent object is always up-to-date. Persistence is not reachability based, and therefore it is no issue whether references should be followed or not. The approach taken in the POET <ref> [22] </ref> object oriented database system, is to add a number of keywords to the C++ language. In POET, a reference is followed unless declared transient. Doing the same in BETA would mean adding keywords to distinguish between references that should be followed and references that should not.
Reference: [23] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In First Symposium of Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <month> Apr </month> <year> 1984. </year> <journal> ACM Software Engineering. </journal>
Reference-contexts: Efficient algorithms for doing distributed garbage collection are still an area open for investigation. However, there should be no special problems with doing distributed garbage collection in BETA as compared to other distributed OO languages. The garbage collector used in non-distributed BETA is a generation scavenger based on <ref> [23] </ref>, using copy-collection in the infant object area, and mark-sweep in the adult object area. The distributed garbage collector should be able to cooperate with this highly efficient local garbage collection scheme.
References-found: 23

