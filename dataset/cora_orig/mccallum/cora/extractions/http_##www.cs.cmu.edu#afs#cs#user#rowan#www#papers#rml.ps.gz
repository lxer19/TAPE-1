URL: http://www.cs.cmu.edu/afs/cs/user/rowan/www/papers/rml.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/rowan/www/papers/abstracts.html
Root-URL: 
Email: rowan@cs.cmu.edu and fp@cs.cmu.edu  
Phone: Telephone: +1 412 268-6343  
Title: Practical Refinement-Type Checking  
Author: Rowan Davies and Frank Pfenning 
Date: September 28, 1997  
Address: Pittsburgh, PA 15213, U.S.A.  
Affiliation: Department of Computer Science Carnegie Mellon University  
Pubnum: Technical summary  
Abstract: Refinement types allow many more properties of programs to be expressed and statically checked than conventional type systems. We present a practical algorithm for refinement-type checking in a -calculus enriched with refinement-type annotations. We prove that our basic algorithm is sound and complete, and show that every term which has a refinement type can be annotated as required by our algorithm. Our positive experience with an implementation of an extension of this algorithm to the full core language of Standard ML demonstrates that refinement types can be a practical program development tool in a realistic programming language. The required refinement type definitions and annotations are not much of a burden and serve as formal, machine-checked explanations of code invariants which otherwise would remain implicit.
Abstract-found: 1
Intro-found: 1
Reference: [Car97] <author> Luca Cardelli. </author> <title> Type systems. </title> <editor> In Allen B. Tucker Jr., editor, </editor> <booktitle> The Handbook of Computer Science and Engineering, chapter 103, </booktitle> <pages> pages 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction The advantages of statically-typed programming languages are well known, and have been described many times (e.g. see <ref> [Car97] </ref>). However, conventional type systems for realistic programming languages do not capture all of the interesting properties of a program.
Reference: [CDCV81] <author> Mario Coppo, Maria Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional character of solvable terms. </title> <journal> Zeitschrift fur mathematische Logic und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: Numerous variants of intersection types (also called conjunctive types) have been studied in the literature <ref> [CDCV81] </ref>. In our setting, the presence of intersection allows the construction of a principal sort for each expression, given only its type. Base sorts refining the same base type are naturally ordered by inclusion, which is extended in a standard way to the full type hierarchy.
Reference: [DG94] <author> Razvan Diaconescu and Joseph Goguen. </author> <title> An Oxford survey of order sorted algebra. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 4 </volume> <pages> 363-392, </pages> <year> 1994. </year>
Reference-contexts: This solution is to add a more detailed level of types called refinement types to a statically typed language. Each ordinary type may then be refined by many different refinement types, which we also call sorts in accordance with the use of this term in order-sorted algebras <ref> [DG94] </ref>. Refinement types have been studied previously [FP91, Fre94, Pfe93], and allow many more properties of programs to be expressed and checked than conventional type systems.
Reference: [FA97] <author> Manuel Fahndrich and Alexander Aiken. </author> <title> Program analysis using mixed term and set constraints. </title> <booktitle> In International Static Analysis Symposium, </booktitle> <month> September </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: C533. 1 some of the benefits of static typing, namely catching errors and supporting code maintenance and modularity, when the language is dynamically typed [FFK + 96], or when the static type system of the language cannot express the properties of interest <ref> [FA97] </ref>. Unfortunately, these analyses must make approximations, since the underlying problems are undecidable, and often it is difficult for the programmer to determine whether an apparent error found by the analysis is due to these approximations or due to an actual error in their code. <p> We also intend to investigate whether some existing program analyses can be profitably reformulated using refinement types, for example, analysis of effects [LG88] or the exceptions analysis in <ref> [FA97] </ref> are good candidates. 5 Acknowledgements We gratefully acknowledge discussions with John Boyland, Perry Cheng, Denis Dancanet, Manuel Fahndrich, Matthias Felleisen, Tim Freeman, Daniel Jackson, Leaf Petersen, Chris Skalka and Hong-Wei Xi regarding the subject of this paper.
Reference: [FF97] <author> Cormac Flanagan and Matthias Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: Further, there is some evidence that this kind of analysis does not scale to very large programs <ref> [FF97] </ref>, which has prompted consideration of the possibility of a typed module language for Scheme. By contrast, sort checking is very modular, and scales linearly to very large programs.
Reference: [FFK + 96] <author> Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Stephanie Weirich, and Matthias Felleisen. </author> <title> Catching bugs in the web of program invariants. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: C533. 1 some of the benefits of static typing, namely catching errors and supporting code maintenance and modularity, when the language is dynamically typed <ref> [FFK + 96] </ref>, or when the static type system of the language cannot express the properties of interest [FA97]. <p> These experiments indicate that sort checking is fast enough to be practical, and that many interesting properties of programs can be specified and checked with only a relatively small effort to provide the required sort annotations. We briefly compare our results with those obtained by others <ref> [FFK + 96] </ref> using a different approach, but with similar goals. This work uses set-based analysis [Hei94] as a programming tool, and has demonstrated that this approach aids the construction of reliable programs in the context of the dynamically-typed language Scheme.
Reference: [FM90] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference-contexts: One important issue that we mention here is that we have principal sorts only with respect to a particular ML typing derivation which entails some loss of generality when compared to atomic subtyping <ref> [FM90] </ref>. This means that sometimes several instances of a generic polymorphic function need to be sort-checked separately.
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Each ordinary type may then be refined by many different refinement types, which we also call sorts in accordance with the use of this term in order-sorted algebras [DG94]. Refinement types have been studied previously <ref> [FP91, Fre94, Pfe93] </ref>, and allow many more properties of programs to be expressed and checked than conventional type systems. <p> The character of the resulting system is quite different from record subtyping. Previous work on sorts has demonstrated that they are a very useful addition to languages as diverse as the functional programming language Standard ML <ref> [FP91, Fre94] </ref> and the logical framework LF [Pfe93]. Part of that work considered algorithms for sort inference, but this turns out to be problematic because common programs often satisfy many accidental properties which must be reflected in the inferred sort. <p> For a motivating example of the use of sorts in ML, see Appendix A, which includes part of one of our experiments. The full code for these experiments and various other examples of sorts in ML are available electronically via http://www.cs.cmu.edu/~rowan/sorts.html, and other examples have appeared in <ref> [FP91] </ref>. Unfortunately, space limitations do not allow us to provide enough motivating examples in this summary, particularly since the need for sorts is not very convincing in small examples. 2 Basic Refinement-Type Checking In this section we present a simply-typed -calculus with let, and give declarative sorting rules for it. <p> We use explicitly typed (but not explicitly sorted) and fix forms, because we assume that type inference has been completed before sort checking is attempted. Much of the basic presentation of sorts here is based on previous work <ref> [FP91] </ref>, and so we omit some details from this technical summary for the sake of brevity. 2.1 Syntax and Typing We assume that there are some base types, denoted by a, b and that each base type is refined by a finite number of base sorts, denoted by r a ,
Reference: [Fre94] <author> Tim Freeman. </author> <title> Refinement Types for ML. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> March </month> <year> 1994. </year> <note> Available as technical report CMU-CS-94-110. </note>
Reference-contexts: Each ordinary type may then be refined by many different refinement types, which we also call sorts in accordance with the use of this term in order-sorted algebras [DG94]. Refinement types have been studied previously <ref> [FP91, Fre94, Pfe93] </ref>, and allow many more properties of programs to be expressed and checked than conventional type systems. <p> The character of the resulting system is quite different from record subtyping. Previous work on sorts has demonstrated that they are a very useful addition to languages as diverse as the functional programming language Standard ML <ref> [FP91, Fre94] </ref> and the logical framework LF [Pfe93]. Part of that work considered algorithms for sort inference, but this turns out to be problematic because common programs often satisfy many accidental properties which must be reflected in the inferred sort. <p> We address the more difficult issue of algorithmic sort checking later. Due to space limitations, we omit the details of algorithmic subsorting judgment R fi S, since variations of it have been considered previously <ref> [Fre94] </ref> and we do not consider it a major contribution of this paper. 5 2.6 Annotation Designing an algorithmic form of the sort assignment judgement is harder than for the subsorting judgement. In particular, there is no obvious way to choose R in the srt lam and srt let rules. <p> In particular, there is no obvious way to choose R in the srt lam and srt let rules. Freeman <ref> [Fre94] </ref> has described and implemented one approach to this problem, based on techniques from abstract interpretation. Unfortunately, the resulting algorithms are not always efficient enough to be practical, particularly in the case of higher-order functions and when features like recursion are included to the language. <p> We then present our experience with this implementation. Space does not permit us to formally describe all the interesting details of the extension of the sort checking algorithm. A formal presentation of sorts for a fragment of ML was given by Freeman <ref> [Fre94] </ref>, though he did not address pattern matching and did not consider sort checking algorithms. Most of this can be adapted quite easily to build on the sort checking framework given in the previous section. <p> They also only allow parametric refinements of parametric types, so for example we cannot define a refinement for ordinary lists of booleans whose head is true, although we can define a specialized type for lists of booleans and then refine this type. 3.2 Polymorphism Following Freeman <ref> [Fre94] </ref>, we allow refinements of ML polymorphic types, with the restriction that there is only a single sort variable refining each type variable. For convenience, this sort vari 10 able has the same name as the type variable. <p> However, it is not clear how to capture the sequential nature of pattern matching using sorts in a way that is accurate, intuitive, and has an efficient implementation. Freeman <ref> [Fre94] </ref> avoided this issue by only considering a simple elimination form for constructed types, and arguing that pattern matching can be expanded into nested eliminations.
Reference: [Hei94] <author> Nevin Heintze. </author> <title> Set based analysis of ML programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <year> 1994. </year> <month> 14 </month>
Reference-contexts: We briefly compare our results with those obtained by others [FFK + 96] using a different approach, but with similar goals. This work uses set-based analysis <ref> [Hei94] </ref> as a programming tool, and has demonstrated that this approach aids the construction of reliable programs in the context of the dynamically-typed language Scheme.
Reference: [LG88] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Proceedings of the Fif--teenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, 1988, San Diego, California, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: We also intend to investigate whether some existing program analyses can be profitably reformulated using refinement types, for example, analysis of effects <ref> [LG88] </ref> or the exceptions analysis in [FA97] are good candidates. 5 Acknowledgements We gratefully acknowledge discussions with John Boyland, Perry Cheng, Denis Dancanet, Manuel Fahndrich, Matthias Felleisen, Tim Freeman, Daniel Jackson, Leaf Petersen, Chris Skalka and Hong-Wei Xi regarding the subject of this paper.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Our extension of ML is conservative, so our sort checker could be added to a compiler without causing problems with existing programs. We expect that the basic approach could also be extended to allow sort checking of other languages, 2 for example the logic programming language Elf <ref> [Pfe91] </ref>, which is based on LF. For a motivating example of the use of sorts in ML, see Appendix A, which includes part of one of our experiments. <p> Part of the code from this experiment is included in Appendix A. In the second experiment we added sorts to the parser of a recent re-implementation of the Elf logic programming language <ref> [Pfe91] </ref>. In this case we were able to check some complicated invariants involving an intermediate stack of unresolved operations which is used to resolve prefix, postfix and infix operations with precedence.
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geuvers, editor, </editor> <booktitle> Informal Proceedings of the 1993 Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year> <institution> University of Nijmegen. </institution>
Reference-contexts: Each ordinary type may then be refined by many different refinement types, which we also call sorts in accordance with the use of this term in order-sorted algebras [DG94]. Refinement types have been studied previously <ref> [FP91, Fre94, Pfe93] </ref>, and allow many more properties of programs to be expressed and checked than conventional type systems. <p> The character of the resulting system is quite different from record subtyping. Previous work on sorts has demonstrated that they are a very useful addition to languages as diverse as the functional programming language Standard ML [FP91, Fre94] and the logical framework LF <ref> [Pfe93] </ref>. Part of that work considered algorithms for sort inference, but this turns out to be problematic because common programs often satisfy many accidental properties which must be reflected in the inferred sort.
Reference: [Pie93] <author> Benjamin C. Pierce. </author> <title> Intersection types and bounded polymorphism. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, TLCA'93, </booktitle> <pages> pages 346-360, </pages> <address> Utrecht, The Netherlands, </address> <month> March </month> <year> 1993. </year> <note> Springer-Verlag LNCS 664. A version will also appear in the journal MSCS. </note>
Reference-contexts: This was extended by Pierce <ref> [Pie93] </ref> to a special form binding a type variable to one of a set of alternative types. Here we take a different approach which we find more intuitive, and avoid this problem without introducing new language features.
Reference: [Reh97] <author> Jacob Rehof. </author> <title> Minimal typings in atomic subtyping. </title> <editor> In Neil Jones, editor, </editor> <booktitle> Conference Record of the 24th Symposium on Principles of Programming Languages (POPL'97), </booktitle> <pages> pages 278-291, </pages> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <note> ACM SIGPLAN-SIGACT. </note>
Reference-contexts: This means that sometimes several instances of a generic polymorphic function need to be sort-checked separately. This shortcoming might be addressed in future work at the level of ML modules (ascribing several signatures to a structure) or by combining recent ideas from polymorphic subtyping inference <ref> [Reh97] </ref> with refinement types. 3.3 Pattern matching There are few interesting choices to be made when extending the sorting rules to core Standard ML, the most difficult problems being presented by general pattern matching.
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: is no single sort annotation that we can add to the let, since the corresponding sub-derivations are of the judgements: x.r a ` y:a: x . r a ! r a and x.s a ` y:a: x . s a ! s a A similar problem was solved by Reynolds <ref> [Rey88] </ref> in a type system with general intersection types by introducing a type annotation including many alternative types. This was extended by Pierce [Pie93] to a special form binding a type variable to one of a set of alternative types.
Reference: [Rey91] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: The subsorting judgement has the form: R S Sort R is a sub-sort of S, where R and S must be compatible. The subsorting rules present a minor variation for other systems with intersection types such as <ref> [Rey91] </ref>. cnjs R s a sub base R s a sub reflex R R sub trans R 1 R 3 sub conjL1 R & S R sub conjL2 R & S S sub conjR R S & S 0 sub arrow R ! S R 0 ! S 0 sub dist <p> R Term M has sort R in context . The sorting rules are very similar to those for a system with general intersection types (e.g., see <ref> [Rey91] </ref>). Here each abstraction and fixed point includes the type assigned to the variable during type inference, so the choice of the sort for the variable is restricted to refinements of this type. x.R in ` x . R srt lam ` M . R ! S ` N .
Reference: [Ska97] <author> Chris Skalka. </author> <title> Some decision problems for ML refinement types. </title> <type> Master's thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: R. This process is much more complicated than it may appear at first, and the algorithms used are based on algorithms for regular tree grammars. A formal analysis of such algorithms is the subject of a Master's Thesis by Skalka <ref> [Ska97] </ref>. There are many obvious limitations of datasort declarations, in particular they cannot be used to define non-regular refinements, such as lists whose length is prime.
References-found: 18

