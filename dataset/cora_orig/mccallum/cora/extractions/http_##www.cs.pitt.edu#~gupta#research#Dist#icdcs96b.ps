URL: http://www.cs.pitt.edu/~gupta/research/Dist/icdcs96b.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/dist.html
Root-URL: 
Email: fgupta,mosseg@cs.pitt.edu  
Title: Real-Time Scheduling Using Compact Task Graphs  
Author: Rajiv Gupta Daniel Mosse Richard Suchoza 
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: The generation of a real-time schedule from a task precedence graph is complex and time consuming. In order to improve the efficiency of generating schedules, we propose a scheduling algorithm based upon the compact task graph (CTG) representation. In addition to precedence constraints, a CTG explicitly expresses the potential for interleaving the execution of tasks on a single processor and overlapping the execution of tasks on multiple processors. The CTG is compact since it expresses the potential for overlapping and interleaving without the generation of smaller tasks. If a task cannot be scheduled to meet its deadline through interleaving and overlapping, then selected tasks are split into smaller tasks which increases the flexibility, and hence the complexity, of scheduling the task. Thus, in effect our approach increases the complexity of scheduling a usual task graph only if it is essential. Our results demonstrate that a significant reduction in the time of scheduling is achieved using CTGs and our algorithms that exploit the CTGs. We also show how CTGs can be used for distributed on-line scheduling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Cheng, J.A. Stankovic, and K. Ramamritham, </author> <title> "Dynamic Scheduling of Groups of Tasks with Precedence Constraints in Distributed Hard Real-Time Systems," </title> <booktitle> Proc. 7th Real-Time Syst. Symp., </booktitle> <address> pp.166-174, </address> <year> 1986. </year>
Reference-contexts: In this incremental way, our algorithm increases in scheduling complexity gradually, if and only if the increase is definitely required. Other researchers have addressed the problem of scheduling multitask applications on a distributed system <ref> [1, 2, 7, 9] </ref>. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks [1, 2]. <p> Other researchers have addressed the problem of scheduling multitask applications on a distributed system [1, 2, 7, 9]. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks <ref> [1, 2, 9] </ref>. Some of the techniques split the task graph into independent tasks [1, 2]. In section 2 we introduce busy-idle profiles and the CTG representation. In section 3 we present our multiprocessor scheduling algorithm based upon compact task graphs and present performance results obtained through experimentation. <p> In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks <ref> [1, 2] </ref>. In section 2 we introduce busy-idle profiles and the CTG representation. In section 3 we present our multiprocessor scheduling algorithm based upon compact task graphs and present performance results obtained through experimentation. In section 4 we illustrate how our basic heuristic can be adapted for online scheduling.
Reference: [2] <author> M. DiNatale and J. Stankovic, </author> <title> "Dynamic End-to-End Guarantees in Dist. Real-Time Systems," </title> <booktitle> Proc. 15th IEEE Real-Time Syst. Symp., </booktitle> <address> pp.216-227, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: In this incremental way, our algorithm increases in scheduling complexity gradually, if and only if the increase is definitely required. Other researchers have addressed the problem of scheduling multitask applications on a distributed system <ref> [1, 2, 7, 9] </ref>. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks [1, 2]. <p> Other researchers have addressed the problem of scheduling multitask applications on a distributed system [1, 2, 7, 9]. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks <ref> [1, 2, 9] </ref>. Some of the techniques split the task graph into independent tasks [1, 2]. In section 2 we introduce busy-idle profiles and the CTG representation. In section 3 we present our multiprocessor scheduling algorithm based upon compact task graphs and present performance results obtained through experimentation. <p> In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks <ref> [1, 2] </ref>. In section 2 we introduce busy-idle profiles and the CTG representation. In section 3 we present our multiprocessor scheduling algorithm based upon compact task graphs and present performance results obtained through experimentation. In section 4 we illustrate how our basic heuristic can be adapted for online scheduling.
Reference: [3] <author> J. Fidge, </author> <title> "Timestamps in Message Passing Systems that Preserve the Partial Ordering," </title> <booktitle> Proc. 11th Aus-tralian Computer Science Conference, </booktitle> <address> pp.55-66, </address> <year> 1988. </year>
Reference-contexts: This approach reduces the amount of traffic generated by the updates. The information for remote sites is approximate because of the delays in communicating the state changes. The manner in which the site characteristics are updated is similar to the manner in which vector clocks <ref> [3] </ref> are maintained. Each site maintains a vector of CT D's, denoted as V ectorCT D [1::N SIT ES; 1::N IN T ER], where N SIT ES is the number of sites in the system and N IN T ER is the number of time intervals of interest.
Reference: [4] <author> R. Gupta and M. Spezialetti, </author> <title> "A Compact Task Graph Representation for Real-Time Scheduling," </title> <journal> Journal of Real Time Systems, </journal> <volume> Vol. 10, pp.71-102, </volume> <year> 1996. </year>
Reference-contexts: The main advantage of CTGs is their representation, which expresses the potential for interleaving (IL) and overlapping (OL) of tasks. The degree of IL and OL allowed for a pair of tasks is computed by the compiler using techniques described in <ref> [4] </ref>. To maximize the amount of interleaving, the compiler can select legal preemption points in the tasks other than interaction points. Thus, interleaving enables the scheduler to explore task interleavings not achievable by the approach which always splits tasks at interaction points. <p> Concluding remarks appear in section 5. 2 Busy-Idle Profiles and Compact Task Graphs The CTGs are constructed using the busy-idle profiles for tasks in an application. In this section we briefly describe the profiles and CTGs. The algorithms for computing them can be found in <ref> [4] </ref>. The busy-idle profiles show the times at which tasks are expected to be busy executing and the times at which the tasks are expected to be idle waiting for inputs. The profiles are obtained by performing timing analysis on the application code.
Reference: [5] <author> L. Lamport, </author> <title> "Time, Clocks and the Ordering of Events in Distributed Systems," </title> <journal> CACM, </journal> <volume> Vol. 21, No. 7, </volume> <year> 1978. </year>
Reference-contexts: Each entry in V ectorCT D is of the form hCT D; timestampi, where CT D is the cumulative temporal density and the timestamp of the CT D is obtained using Lamport's virtual clock algorithm <ref> [5] </ref>. The timestamps are required for updating the CT D information received from other sites. Site Selection Based upon the task and site characteristics the allocation of a task submitted to the system is carried out as follows.
Reference: [6] <author> S. K. Dhall and C. L. Liu, </author> <title> On a real-time scheduling problem. </title> <journal> Operations Research, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp 127-140, </pages> <address> Jan/Feb. </address> <year> 1978. </year>
Reference-contexts: In this incremental way, our algorithm increases in scheduling complexity gradually, if and only if the increase is definitely required. Other researchers have addressed the problem of scheduling multitask applications on a distributed system [1, 2, 7, 9]. In some cases the scheduling of independent tasks is considered <ref> [6] </ref> while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks [1, 2]. In section 2 we introduce busy-idle profiles and the CTG representation.
Reference: [7] <author> R. P. Ma, E. Lee, and M. Tsuchiya. </author> <title> A Task Allocation Model for Dist. </title> <journal> Comp. Syst. ACM TOCS, </journal> <month> Jan. </month> <year> 1982. </year>
Reference-contexts: In this incremental way, our algorithm increases in scheduling complexity gradually, if and only if the increase is definitely required. Other researchers have addressed the problem of scheduling multitask applications on a distributed system <ref> [1, 2, 7, 9] </ref>. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks [1, 2].
Reference: [8] <author> D. Mosse, S. Noh, B. Trihn, and A. K. Agrawala. </author> <title> Multiple Resource Allocation for Multiprocessor Distributed Real-Time Systems. </title> <booktitle> In Workshop on Parallel and Dist. Real-Time Syst., </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: Therefore, the use of CTGs to reduce the complexity of scheduling is particularly appropriate. We consider a distributed system in which each site is composed of multiple processors. The scheduling algorithm that we present is based on a hierarchical scheduling approach described in <ref> [8] </ref>. First a global allocation policy is used to distribute the tasks from the CTG among the various sites in the system. Next, at each site, a local allocation policy is used to assign individual tasks to specific processors at the site. <p> Second, the utilization of the resources by a task over different time intervals within the time window during which the task is to be scheduled can be computed. This characteristic is termed as the temporal density and was suggested in <ref> [8] </ref>. The temporal densities of tasks already allocated to a site, together with the temporal density of an unallocated task, can be used to determine whether the unallocated task should be assigned to the site.
Reference: [9] <author> K. Ramamritham, </author> <title> "Allocation and Scheduling of Complex Periodic tasks," </title> <booktitle> Proc. 10th International Conf. on Dist. Comp. Syst., </booktitle> <address> pp.108-115, </address> <year> 1990. </year>
Reference-contexts: In this incremental way, our algorithm increases in scheduling complexity gradually, if and only if the increase is definitely required. Other researchers have addressed the problem of scheduling multitask applications on a distributed system <ref> [1, 2, 7, 9] </ref>. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks [1, 2, 9]. Some of the techniques split the task graph into independent tasks [1, 2]. <p> Other researchers have addressed the problem of scheduling multitask applications on a distributed system [1, 2, 7, 9]. In some cases the scheduling of independent tasks is considered [6] while others have attempted to treat the problem of scheduling interrelated tasks <ref> [1, 2, 9] </ref>. Some of the techniques split the task graph into independent tasks [1, 2]. In section 2 we introduce busy-idle profiles and the CTG representation. In section 3 we present our multiprocessor scheduling algorithm based upon compact task graphs and present performance results obtained through experimentation.
Reference: [10] <author> W. Zhao and K. Ramamritham. </author> <title> Distributed Scheduling Using Bidding and Focused Addressing. </title> <booktitle> In Proc. IEEE Real-Time Syst. Symp., </booktitle> <address> pp.103-111, </address> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: The primary modification is that when the scheduling of a task at a given site using the first two levels fails, then instead of using task splitting, the task is sent to an other site of the distributed system for scheduling, as in <ref> [10] </ref>. The key steps of the hierarchical scheduling algorithm are as follows: 1. A CTG with graph-wide timing constraints is submitted to a Global Allocator (GA). Through the busy-idle profiles the GA is provided with resource utilization information over various periods of time for all tasks. <p> Tasks can be accepted or rejected at that level. Accepted tasks are guaranteed to execute within their deadlines. 4. Tasks rejected locally are submitted to another site using the focussed addressing scheme <ref> [10] </ref>. Below we discuss important aspects of the global allocator in greater detail. First, we describe our search strategy to speedup the allocation of tasks and increase the probability of a successful allocation. <p> In order to facilitate the reassignment of a task we save the list of sites, computed during the site selection process, to which the task could have been assigned (similar to the focussed addressing scheme <ref> [10] </ref>). The list can be ordered according to the excess capacities of the sites. In the order given by the list, different sites are tried for scheduling the task until the scheduling is finally successful or it is determined that no site can accept the task.
References-found: 10

