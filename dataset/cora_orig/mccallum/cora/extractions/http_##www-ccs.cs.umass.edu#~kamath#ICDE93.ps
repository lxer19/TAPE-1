URL: http://www-ccs.cs.umass.edu/~kamath/ICDE93.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/esr.html
Root-URL: 
Email: fkamath@freya.cs.umass.edu, krithi@nirvan.cs.umass.edug  
Title: Performance Characteristics of Epsilon Serializability with Hierarchical Inconsistency Bounds  
Author: Mohan Kamath and Krithi Ramamritham 
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: Epsilon serializability (ESR) is a weaker form of correctness designed to provide more concurrency than classic serializability (SR) by allowing, for example, query transactions to view inconsistent data in a controlled fashion, by limiting the inconsistency within the specified bounds. In this paper, we introduce the notion of hierarchical inconsistency bounds that allows inconsistency to be specified at different granularities | with transactions being at the top of the hierarchy, objects at the bottom, and groups in between. We discuss mechanisms needed to control the inconsistency so that it lies within the specified bounds. This paper also reports on an evaluation of the performance improvement due to ESR. We make two important observations. First, the thrashing point shifts to a higher multiprogramming level when transaction inconsistency bounds are increased. Further, for a particular multiprogramming level and a particular transaction inconsistency bound, the throughput does not increase with increasing object inconsistency bounds but peaks at some intermediate value. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, M.J. Carey and M. Livny, </author> <title> "Concur-rency control performance modeling: Alternatives and implications", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(4): </volume> <pages> pp 605-654, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: As the bounds on inconsistency increase, we would expect the throughput to increase. The thrashing point (the MPL where the throughput begins to drop) is highly dependent on the conflict ratio. For example, for the conflict ratios considered in <ref> [1] </ref>, thrashing occurs in most cases when the MPL is around 30 or 40. However in our case we had to use a higher conflict ratio so that we could observe thrashing at a lower MPL (within 10 to be precise).
Reference: [2] <author> P.A. Bernstein, V. Hadzilacos and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley Publishing Company, </publisher> <address> first edition, </address> <year> 1987. </year>
Reference-contexts: We chose timestamp ordering for concur-rency control. To simplify recovery, we enforce strict ordering <ref> [2] </ref>. Though deadlocks are rare, we detect them using the RPC timeout mechanism. Out of order operations which cannot be executed are aborted and the transaction is resubmitted after some delay. Hence we don't have the need to maintain detailed histories/logs since recovery is simple and rollbacks are not necessary.
Reference: [3] <author> T. Haerder and A. Reuter, </author> <title> "Principles of transaction oriented database recovery", </title> <journal> ACM Computing Surveys, </journal> <pages> 15(4); pp 287-317, </pages> <month> December </month> <year> 1983. </year>
Reference: [4] <author> M. Kamath and K. Ramamritham, </author> <title> "Performance Characteristics of Epsilon Serializability with Hierarchical Inconsistency Bounds", </title> <type> Technical Report 92-46, </type> <institution> Department of Computer Science, University of Massachusetts, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: In the graphs, epsilon refers to the inconsistency bounds. Due to space limitations we show only some of the results here. Others can be found in <ref> [4] </ref>. In Figure 7 we see that at higher epsilon values, the throughput with ESR is much higher than with SR. As the bounds decrease in value, ESR starts approaching SR.
Reference: [5] <author> C. Pu and A. Leff, </author> <title> "Replica Control in distributed systems: An asynchronous approach", </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pp 377-386, </pages> <address> Denver, </address> <month> May </month> <year> 1991. </year>
Reference: [6] <author> K. Ramamritham and P. K. Chrysanthis, </author> <title> "In Search of Acceptability Criteria: Database Consistency Requirements and Transaction Correctness Properties", Distributed Object Management, edited by Ozsu, Dayal, and Valduriez, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Our notion of hierarchical inconsistency control attempts to provide a finer-grained approach to controlling inconsistencies in ETs than before [8]. Several notions of correctness weaker than SR have been proposed previously but very few have been evaluated <ref> [6] </ref>. Since no work has been done to determine the performance gains from ESR, we have presented an evaluation of the quantitative performance improvements resulting from ESR, obtained through a series of tests on our prototype system.
Reference: [7] <author> K. Ramamritham and C. Pu, </author> <title> "A Formal Characterization of Epsilon Serializability", </title> <type> Technical Report 91-92, </type> <institution> Department of Computer Science, University of Massachusetts, </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: While [8] gives the details of ESR, a more precise and formal description can be found in <ref> [7] </ref>. To an application designer and transaction programmer, an ET is a classic transaction with the addition of inconsistency limits. A query ET has an import-limit, which specifies the maximum amount of inconsistency that can be imported by it. <p> OIL Q x is represented as import limit Q x in <ref> [7] </ref>. In the rest of this paper OIL Q x will be assumed to be the same for all Q and is denoted by OIL x . Similarly, OEL T x will be assumed to be the same for all T and will be denoted by OEL x . <p> In the previous literature on ESR, inconsistencies have been specified with respect to transactions [8] or with respect to objects <ref> [7] </ref>. <p> To motivate the need for hierarchical inconsistency bounds we look at a practical situation. Figure 1 pertains to a banking system. For accounting purposes, the bank categorizes the accounts broadly into 1 In <ref> [7] </ref> this proper value is denoted by x Q initial . some classes such as company, preferred customer, personal accounts etc.. Let us consider the case when the bank needs to estimate the overall amount held by the bank. <p> The current value would then correspond to the one written by W U3 (x) which could violate the inconsistency bound. One solution to this would be to always add the maximum change by an update transaction <ref> [7] </ref> while determining the inconsistency seen by a read. In our implementation we store the values of the last 20 writes on each object with the corresponding time stamps. <p> For each object x, we maintain a list of uncommitted query ETs which have read its value, along with the respective proper values (in practical environments, a better mechanism could be used). Let us denote these values as P1; P2 3 In <ref> [7] </ref> d is defined as distance (x current ,x Q initial ). and P3 for object x corresponding to Q1; Q2 and Q3 respectively. Let N 5 denote the new value that will be written by W U5 (x) if it is allowed to execute. <p> The server primarily consists of a scheduler, a transaction manager and a data manager. The scheduler, which acts as the front-end, receives transaction requests from the clients and schedules the operations based on timestamp 4 This is explained in more detail in <ref> [7] </ref>. 5 The number of conflicting operations during these tests were small. ordering by submitting it to the transaction manager. The transaction manager passes the operation to the data manager and based on the return value the transaction manager takes the appropriate action. <p> In practice, there has to be a compromise between the desired accuracy of the results and the throughput. 9 Conclusion Previous literature on ESR specified inconsistency bounds with respect to transactions [8] or objects <ref> [7] </ref>. We have introduced the notion of hierarchical inconsistency bounds that allows inconsistency to be specified at different levels. Using a practical example we demonstrated that with this, a user could gain more flexibility in specifying the inconsistency viewed by ETs.
Reference: [8] <author> K.L. Wu, P.S. Yu and C. Pu, </author> <title> "Divergence Control for Epsilon Serializability", </title> <booktitle> In Proceedings of Eighth International Conference on Data Engineering, </booktitle> <pages> pp 506-515, </pages> <address> Phoenix, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: We present detailed mechanisms for controlling the inconsistency seen by the queries within the specified bounds at different levels of a hierarchy in section 5. Wu et. al <ref> [8] </ref> suggest some general ways by which the amount of inconsistency can be controlled in ETs. However our notion of hierarchical inconsistency control attempts to provide a finer-grained approach to controlling inconsistencies in ETs. <p> Section 9 concludes with a summary of the paper. 2 Review of Epsilon Serializability In this section we touch upon some of the key aspects of ESR that are necessary for our discussion. While <ref> [8] </ref> gives the details of ESR, a more precise and formal description can be found in [7]. To an application designer and transaction programmer, an ET is a classic transaction with the addition of inconsistency limits. <p> Inconsistency f rom W rite is defined as the difference between the new value of the object and the proper value of the object. Our notion of this is slightly different from the one mentioned in <ref> [8] </ref> and we discuss this further in section 5. A database state is a set of data values. A database state space is a set of all database states. ESR is applicable to a database state space S DB if it is a metric space. <p> When an inconsistency bound, Limit x , is specified for a data item x with respect to query Q, Inconsistency x should be less than or equal to Limit x . In the previous literature on ESR, inconsistencies have been specified with respect to transactions <ref> [8] </ref> or with respect to objects [7]. <p> In this section we describe the timestamp based mechanisms we have used to control the inconsistencies. Some methods suggested in the literature <ref> [8] </ref>, where the total inconsistency of a query ET is determined by multiplying the bound of an operation and the number of operations in the ET, may result in the overestimation of the accumulated errors. We present detailed mechanisms for controlling the inconsistency at fine grain levels. <p> In this case, it is the higher of jd1j and jd2j whose values are (N 5 P1) and (N 5 P2) respectively. Our notion of Inconsistency from write differs from <ref> [8] </ref> at this point. In [8] d is determined by adding the inconsistencies ex ported to all the concurrent query ETs. <p> In this case, it is the higher of jd1j and jd2j whose values are (N 5 P1) and (N 5 P2) respectively. Our notion of Inconsistency from write differs from <ref> [8] </ref> at this point. In [8] d is determined by adding the inconsistencies ex ported to all the concurrent query ETs. <p> In practice, there has to be a compromise between the desired accuracy of the results and the throughput. 9 Conclusion Previous literature on ESR specified inconsistency bounds with respect to transactions <ref> [8] </ref> or objects [7]. We have introduced the notion of hierarchical inconsistency bounds that allows inconsistency to be specified at different levels. Using a practical example we demonstrated that with this, a user could gain more flexibility in specifying the inconsistency viewed by ETs. <p> We have also presented detailed mechanisms to control the inconsistency seen by ETs within the specified bounds at different levels of a hierarchy. Our notion of hierarchical inconsistency control attempts to provide a finer-grained approach to controlling inconsistencies in ETs than before <ref> [8] </ref>. Several notions of correctness weaker than SR have been proposed previously but very few have been evaluated [6].
References-found: 8

