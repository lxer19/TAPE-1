URL: http://www.cs.iastate.edu/tech-reports/TR97-09.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Behavioral Subtyping in Object-Oriented Languages [Logics and Meanings of Programs] Specifying and Verifying and Reasoning
Author: Krishna Kishore Dhara 
Keyword: object-oriented programming, behavioral subtype, abstract data type, mutation, aliasing, modular verification, supertype abstraction 1996 CR Categories: D.1.5 [Programming Techniques] Object-oriented Programming; D.3.1 [Programming Languages] Formal Definitions and Theory semantics; D.3.2 [Programming Languages] Language Classifications object-oriented languages; D.3.3 [Programming Languages] Language Constructs Abstract data types, modules, packages;  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: TR #97-09  F.3.1  
Abstract: A version of this technical report is published as the author's doctoral dissertation. c fl Copyright 1997 by Krishna Kishore Dhara All rights reserved. 
Abstract-found: 1
Intro-found: 1
Reference: [AL97] <author> Martin Abadi and K. Rustan M. Leino. </author> <title> A logic of object-oriented programs. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> Proceedings of Theaory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, </booktitle> <pages> pages 682-696, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, volume 1214, </publisher> <address> New York, N.Y., </address> <year> 1997. </year>
Reference-contexts: Since we use a similar framework as Leavens and Pigozzi, it is interesting to see if we could adopt their techniques to show that our notions are complete. We leave this as future work. 3.11.1.2 Abadi and Leino's subsumption Abadi and Leino <ref> [AL97] </ref> extend Cardelli's [Car91] structural subtyping rules on records to include behavior. One of the conditions for their notion of subsumption, which is their notion of behavioral subtyping, is that two types should be structurally subtypes. Hence, their notion of subsumption cannot relate arbitrary abstract data types.
Reference: [Ame87] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 276, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: Further, she requires the types of the arguments for the common methods in the subtype and supertype to be the same. In contrast to the above model-theoretic approaches, America <ref> [Ame87, Ame91] </ref>, and Liskov and Wing [LW93b, LW94] give proof-theoretic definitions of behavioral subtyping. America does not deal with extra mutators in subtypes. <p> We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches <ref> [Ame87, Ame91, LW93a, LW94, DL96] </ref>. <p> They do not consider aliasing or interference between identifiers in their programs, which is a main component in our study of behavioral subtyping. 3.11.2 Proof-theoretic approaches In contrast to our model-theoretic approach, there are several other works on proof-theoretic notions of behavioral subtyping. These include America <ref> [Ame87] </ref>, Liskov and Wing [LW93a, LW94] and our proof-theoretical notions of behavioral subtyping in [DL96]. Other than the approach, there are some fundamental differences between this dissertation and these proof-theoretic notions. <p> However, proof-theoretic approaches look at individual type specifications and define a relationship between such types. Our goal in studying behavioral subtyping is to provide a sound notion of behavioral subtyping that can be used for supertype abstraction. None of these proof-theoretic approaches <ref> [Ame87, LW93a, LW94, DL96] </ref> prove soundness of behavioral subtyping. But proving behavioral subtype relations using proof-theoretic notions is easier than using model-theoretic notions. We also identify two notions of behavioral subtyping of which the strong behavioral subtype notion is closer to the notions proposed by several proof-theoretic approaches.
Reference: [Ame91] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <address> REX School/Workshop, Noordwijkerhout, The Netherlands, </address> <month> May/June </month> <year> 1990, </year> <pages> pages 60-90, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 489, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Further, she requires the types of the arguments for the common methods in the subtype and supertype to be the same. In contrast to the above model-theoretic approaches, America <ref> [Ame87, Ame91] </ref>, and Liskov and Wing [LW93b, LW94] give proof-theoretic definitions of behavioral subtyping. America does not deal with extra mutators in subtypes. <p> We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches <ref> [Ame87, Ame91, LW93a, LW94, DL96] </ref>. <p> Whether one uses proof-theoretic techniques or model-theoretic techniques, the main goal is to capture a relationship that aids in understanding, formally or informally, OO programs. In this section, we look at this context and place the results of our work with respect to this context. Most proof-theoretic approaches <ref> [Ame91, LW94, DL96] </ref> study relationships between specific types and conclude that a behavioral subtype relationship exists. Proving these subtype relationships is easier. Since the behavior of types is given by their specification, these studies do not need a different model and a different semantics for studying behavioral subtype relations.
Reference: [BW90] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches <ref> [BW90, LW90, LP92, LW95] </ref> do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack [Cus91] has a notion of specialization that is similar to behavioral subtyping. <p> So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic <ref> [BW90, Lea89, LW95, LP94] </ref> and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96]. <p> While the former approaches study models of types and define behavior in terms of these models, the latter approaches define behavioral subtyping based on the specification of individual types. 58 3.11.1 Model theoretic definitions There are several model-theoretic studies of behavioral subtyping <ref> [BW90, Lea89, LW95, LP94] </ref> that use simulation relations or simulation functions to define behavioral subtyping. However, all these works are restricted to types with immutable objects, and hence do not deal with mutation and aliasing.
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <booktitle> volume 173, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, volume 76, numbers 2/3, pages 138-164, February/March 1988. 107 </note>
Reference-contexts: Subtyping based on signature <ref> [Car84, Car91] </ref> does not imply behavioral subtyp-ing [Sny86]. To see this, consider two types Stack and a Queue with get, put, and isIn operations. If subtyping is just based on the signature then a Stack is a subtype of a (FIFO) Queue and vice versa. <p> This would lead to surprising results because of the difference in behavior. So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions <ref> [Car84, Car91] </ref> of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96].
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 431-507. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The notion of subtyp-ing plays an important role in modularity and correctness and hence, in the success of OO programming. In [GHJV95], Gamma and his co-authors summarize a commonly used notion of subtyping based on only the interface or the structure of the types <ref> [Car91] </ref>. They define a type, S, a subtype of T if the interface of S contains the interface of T [GHJV95, page 13]. Though this notion is adequate to prevent any runtime type errors, it cannot guarantee correctness of OO programs. <p> Subtyping based on signature <ref> [Car84, Car91] </ref> does not imply behavioral subtyp-ing [Sny86]. To see this, consider two types Stack and a Queue with get, put, and isIn operations. If subtyping is just based on the signature then a Stack is a subtype of a (FIFO) Queue and vice versa. <p> This would lead to surprising results because of the difference in behavior. So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions <ref> [Car84, Car91] </ref> of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96]. <p> Since we use a similar framework as Leavens and Pigozzi, it is interesting to see if we could adopt their techniques to show that our notions are complete. We leave this as future work. 3.11.1.2 Abadi and Leino's subsumption Abadi and Leino [AL97] extend Cardelli's <ref> [Car91] </ref> structural subtyping rules on records to include behavior. One of the conditions for their notion of subsumption, which is their notion of behavioral subtyping, is that two types should be structurally subtypes. Hence, their notion of subsumption cannot relate arbitrary abstract data types.
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In Ole L. Mad-sen, editor, </editor> <booktitle> ECOOP '92, European Conference on Object-Oriented Programming, Utrecht, The Netherlands, Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56, </pages> <booktitle> volume 615, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: In OBS , for any method this simplification would force the programmers to write a set of methods such that for each combination of the type of the permitted arguments there is a unique method that applies. Chambers and Leavens [CL94] use inheritance and a form of specialization <ref> [Cha92] </ref> to reduce the number of methods that need to be written in such cases. For more flexibility (with respect to the above restriction), inheritance could be added to OBS , but that would complicate the semantics and would not be of any help to our study of behavioral subtyping.
Reference: [CL94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and modules for multi-methods. </title> <booktitle> In OOPSLA '94 Conference Proceedings, volume 29(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 1-15, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In OBS , for any method this simplification would force the programmers to write a set of methods such that for each combination of the type of the permitted arguments there is a unique method that applies. Chambers and Leavens <ref> [CL94] </ref> use inheritance and a form of specialization [Cha92] to reduce the number of methods that need to be written in such cases.
Reference: [Coo92] <author> W. R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <booktitle> In OOPSLA '92 Proceedings, </booktitle> <editor> Andreas Paepcke (editor), </editor> <booktitle> volume 27(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 1-15, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Note that we do not require any operations on Loc and it can be considered as just the common supertype of object types. For some types, like the Collection <ref> [Gol84, Coo92] </ref> types, the contained objects vary dynamically. For example, the contained objects in a List type vary with mutation, that is adding a new object to a list changes its contained objects. Hence, we cannot have a fixed tuple type as the return type of containedObjs [List].
Reference: [Cus91] <author> E. Cusack. </author> <title> Inheritance in object oriented Z. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), Geneva Switzerland, Lecture Notes in Computer Science, </booktitle> <pages> pages 167-179, </pages> <booktitle> volume 512, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches [BW90, LW90, LP92, LW95] do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack <ref> [Cus91] </ref> has a notion of specialization that is similar to behavioral subtyping. Though her class schemas allow extra methods in the subtype and seem to deal with mutation, she does not study the relation between mutation, aliasing, and subtyping. <p> Introducing history constraints in their subsumption relations would be allow such reasoning and we believe that their notion of subsumption would then be equivalent to strong behavioral subtyping that is restricted to relations between structural subtypes. 3.11.1.3 Cusack's Specialization Cusack <ref> [Cus91] </ref> defines a notion of specialization over schemas of Z [Spi88] that is like behavioral subtyping. Since she uses schemas to define the specialization both the subtypes and the supertypes should be specified in the same schema.
Reference: [DL96] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral sub-typing through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Liskov and Wing allow extra mutators provided that the extra mutators can be explained in terms of the supertype methods or if they do not violate any history constraints of the supertype. This rules out the possibility of mutable subtypes of immutable types. In <ref> [DL96] </ref>, we weaken Liskov and Wing's constraint based notion to allow more behavioral subtypes that satisfy the supertype's history constraints. We believe that the strong behavioral subtyping defined in this dissertation is a model-theoretic equivalent of the notion defined in [DL96]. <p> In <ref> [DL96] </ref>, we weaken Liskov and Wing's constraint based notion to allow more behavioral subtypes that satisfy the supertype's history constraints. We believe that the strong behavioral subtyping defined in this dissertation is a model-theoretic equivalent of the notion defined in [DL96]. We leave the formal proof as a future work. 1.4 Outline of the dissertation We present our models of mutable types in Chapter 2. In chapter 3 we define weak and strong behavioral subtype relationships with examples and comparisons to related work. <p> We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches <ref> [Ame87, Ame91, LW93a, LW94, DL96] </ref>. <p> These include America [Ame87], Liskov and Wing [LW93a, LW94] and our proof-theoretical notions of behavioral subtyping in <ref> [DL96] </ref>. Other than the approach, there are some fundamental differences between this dissertation and these proof-theoretic notions. Model-theoretic approaches look at 60 (abstractions of) different implementations of types and determine whether the sub-typing in the programs is a behavioral subtype or not. <p> However, proof-theoretic approaches look at individual type specifications and define a relationship between such types. Our goal in studying behavioral subtyping is to provide a sound notion of behavioral subtyping that can be used for supertype abstraction. None of these proof-theoretic approaches <ref> [Ame87, LW93a, LW94, DL96] </ref> prove soundness of behavioral subtyping. But proving behavioral subtype relations using proof-theoretic notions is easier than using model-theoretic notions. We also identify two notions of behavioral subtyping of which the strong behavioral subtype notion is closer to the notions proposed by several proof-theoretic approaches. <p> We also identify two notions of behavioral subtyping of which the strong behavioral subtype notion is closer to the notions proposed by several proof-theoretic approaches. The notion of weak behavioral subtyping is new to our work <ref> [DL96] </ref>. Since Liskov and Wing's work is an extension of America's work, we omit discussion of America's work. 3.11.2.1 Liskov and Wing's definition In [LW93a, LW94], Liskov and Wing define behavioral subtyping based on the specification of types. <p> Such a relation would have the advantages of both these approaches. 3.11.2.2 Dhara and Leavens' proof-theoretic definition In <ref> [DL96] </ref>, we present our proof-theoretic notion of behavioral subtyping. We weaken Liskov and Wing's "constraint" based behavioral subtyping rule slightly and define a proof-theoretic equivalent of our weak behavioral subtyping. By weakening the post condition rule, we allow subtype objects to operate in a bigger domain than supertype objects. <p> We weaken Liskov and Wing's "constraint" based behavioral subtyping rule slightly and define a proof-theoretic equivalent of our weak behavioral subtyping. By weakening the post condition rule, we allow subtype objects to operate in a bigger domain than supertype objects. For example <ref> [DL96] </ref>, consider a type T with a method foo (int x) with a specification that requires the x &gt; 0 as a precondition. Unlike, Liskov and Wing, we [DL96] allow a behavioral subtype with a foo method that weakens the precondition of T . <p> By weakening the post condition rule, we allow subtype objects to operate in a bigger domain than supertype objects. For example <ref> [DL96] </ref>, consider a type T with a method foo (int x) with a specification that requires the x &gt; 0 as a precondition. Unlike, Liskov and Wing, we [DL96] allow a behavioral subtype with a foo method that weakens the precondition of T . That is, we allow a strong behavioral subtype that has a pre-condition x &lt; 0 ^ x &gt; 0. <p> Our model-theoretic notion of strong behavioral subtype is closer to this notion of behavioral subtyping than Liskov and Wing's. We leave the proof that the strong and weak notion of behavioral subtyping of <ref> [DL96] </ref> are equivalent to those defined here as future work. 62 4. OBS A MULTI-METHOD LANGUAGE The soundness of the behavioral subtype notions defined in the last chapter can be shown by comparing the results of a function over a state with subtyping and over a state without subtyping. <p> Whether one uses proof-theoretic techniques or model-theoretic techniques, the main goal is to capture a relationship that aids in understanding, formally or informally, OO programs. In this section, we look at this context and place the results of our work with respect to this context. Most proof-theoretic approaches <ref> [Ame91, LW94, DL96] </ref> study relationships between specific types and conclude that a behavioral subtype relationship exists. Proving these subtype relationships is easier. Since the behavior of types is given by their specification, these studies do not need a different model and a different semantics for studying behavioral subtype relations.
Reference: [EM85] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics, </title> <booktitle> volume 6 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: We use this notion of direct aliasing in our study of weak behavioral subtyping. 2.6 Related work In this section, we present a brief description of some work related to mutation algebras. Mutation algebras introduced in this chapter are extensions to standard algebraic techniques described, for example, in <ref> [EM85] </ref>, [GD94]. Gougen and Diaconescu [GD94] treat states as terms of an algebra and use them to describe properties of data types. States map variables to values and the values are immutable.
Reference: [GD94] <author> Joseph A. Goguen and Razvan Diaconescu. </author> <title> Towards an algebraic semantics of the object paradigm. </title> <editor> In Hartmut Ehrig and Fernando Orejas, editors, </editor> <booktitle> Recent Trends in Data Type Specification, </booktitle> <pages> pages 1-29, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 785, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: We use this notion of direct aliasing in our study of weak behavioral subtyping. 2.6 Related work In this section, we present a brief description of some work related to mutation algebras. Mutation algebras introduced in this chapter are extensions to standard algebraic techniques described, for example, in [EM85], <ref> [GD94] </ref>. Gougen and Diaconescu [GD94] treat states as terms of an algebra and use them to describe properties of data types. States map variables to values and the values are immutable. <p> Mutation algebras introduced in this chapter are extensions to standard algebraic techniques described, for example, in [EM85], <ref> [GD94] </ref>. Gougen and Diaconescu [GD94] treat states as terms of an algebra and use them to describe properties of data types. States map variables to values and the values are immutable.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1995. </year>
Reference-contexts: Reverifying the entire program, whenever new subtypes are added, is not practical and goes against the modularity principle of OO programming. The notion of subtyp-ing plays an important role in modularity and correctness and hence, in the success of OO programming. In <ref> [GHJV95] </ref>, Gamma and his co-authors summarize a commonly used notion of subtyping based on only the interface or the structure of the types [Car91]. They define a type, S, a subtype of T if the interface of S contains the interface of T [GHJV95, page 13]. <p> In [GHJV95], Gamma and his co-authors summarize a commonly used notion of subtyping based on only the interface or the structure of the types [Car91]. They define a type, S, a subtype of T if the interface of S contains the interface of T <ref> [GHJV95, page 13] </ref>. Though this notion is adequate to prevent any runtime type errors, it cannot guarantee correctness of OO programs. A semantic notion of subtyping, based on the behavior of types, can be used to achieve modular and safe extension of OO software.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In Bruce 108 Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: We capture the "behaves like" relation as a set of semantic properties on models of types. For this we need models of mutable types, which we refer as mutation algebras. Mutation algebras, as opposed to regular algebras <ref> [Wir90, GM87] </ref>, contain stores as values. Using these stores, we model mutation as in denotational semantics. Further these algebras allow us to study observations on types independent of the language in which they are implemented. <p> ALGEBRAIC MODELS OF MUTABLE TYPES In this chapter, we develop algebraic models of mutable types. We refer to these algebras as mutation algebras. Mutation algebras are extensions of standard algebraic models of immutable types <ref> [Wir90, GM87] </ref>. There are two applications of mutation algebras in our study of behavioral sub-typing for mutable types. The first is to provide an algebraic model of types that is independent of any programming language. This allows us to study relations between different types or different implementations of types.
Reference: [Gol84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1984. </year>
Reference-contexts: Note that we do not require any operations on Loc and it can be considered as just the common supertype of object types. For some types, like the Collection <ref> [Gol84, Coo92] </ref> types, the contained objects vary dynamically. For example, the contained objects in a List type vary with mutation, that is adding a new object to a list changes its contained objects. Hence, we cannot have a fixed tuple type as the return type of containedObjs [List].
Reference: [Gur91] <author> Yuri Gurevich. </author> <title> Evolving algebras: A tutorial introduction. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: However, their treatment of states as hidden sorts is similar to our Store, though we require Store as an external type to model mutation. Evolving algebras <ref> [Gur91] </ref> have a fixed carrier set that gives values to terms in a state and function updates that keep track of the changes of structures. For a given algorithm one writes the transformations on structures. Evolving algebras are more operational in nature than our mutation algebras.
Reference: [LD94] <author> Gary T. Leavens and Krishna Kishore Dhara. </author> <title> Blended algebraic and de-notational semantics for ADT languages. </title> <type> Technical Report 93-21b, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, September </month> <year> 1994. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: We present the syntax of type and method declarations of OBS , but for simplicity, we do not give the details of its "compilation" into algebras. We leave this as a future work, which would allow a blend of denotational and algebraic semantics <ref> [LD94] </ref>. In the next section we give an overview of OBS and present its syntax (including the type and method declarations) with an example.
Reference: [Lea89] <author> Gary Todd Leavens. </author> <title> Verifying object-oriented programs that use sub-types. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: Hence, the actual set of results obtained will be a subset of the expected results. 10 1.3 Related work Our work on the model-theory of behavioral subtyping is an extension of Leavens's work in <ref> [Lea89] </ref>. The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches [BW90, LW90, LP92, LW95] do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. <p> Hence, the actual set of results obtained will be a subset of the expected results. 10 1.3 Related work Our work on the model-theory of behavioral subtyping is an extension of Leavens's work in <ref> [Lea89] </ref>. The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches [BW90, LW90, LP92, LW95] do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack [Cus91] has a notion of specialization that is similar to behavioral subtyping. <p> So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic <ref> [BW90, Lea89, LW95, LP94] </ref> and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96]. <p> While the former approaches study models of types and define behavior in terms of these models, the latter approaches define behavioral subtyping based on the specification of individual types. 58 3.11.1 Model theoretic definitions There are several model-theoretic studies of behavioral subtyping <ref> [BW90, Lea89, LW95, LP94] </ref> that use simulation relations or simulation functions to define behavioral subtyping. However, all these works are restricted to types with immutable objects, and hence do not deal with mutation and aliasing. <p> In practice, if one does not use all the methods of a type, it is possible to identify a subset of the type specification that permits more behavioral subtype relations <ref> [Lea89] </ref>. However, any future uses that might use the excluded specification might produce surprising results.
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year> <note> Revised version of the keynote address given at OOPSLA '87. </note>
Reference-contexts: That is, behavioral subtyp-ing requires some form of relation between subtype and supertype objects. Such a relationship would allow one to substitute subtype objects in place of supertype objects without surprising behavioral changes <ref> [Lis88] </ref>. We refer to such relations as simulation relations. These simulation relations form an important component in the definition of weak and strong behavioral subtyping. To define simulations, the first thing one would consider is to relate subtype values to supertype values.
Reference: [LLRS95] <author> C. Lewerentz, Th. Lindner, A. Ruping, and E. Sekerinski. </author> <title> On object-oriented design and verification. </title> <booktitle> volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 92-111. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: So it is not clear on what are the properties of types that are preserved in the context of mutation and aliasing. 3.11.1.4 Lewerentz et al.'s refinement calculus In their study <ref> [LLRS95] </ref>, Lewerentz and his colleagues present a theory of objects and present a refinement calculus based on observations on types. Their goal is to use refinement calculus in OO modeling. Like us, they define refinement using simulations. Unlike our simulations, their simulations use programs to define a "behaves like" notion.
Reference: [LP92] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed homomorphic relations extended with subtypes. </title> <editor> In Stephen Brookes, editor, </editor> <booktitle> Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-167. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches <ref> [BW90, LW90, LP92, LW95] </ref> do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack [Cus91] has a notion of specialization that is similar to behavioral subtyping.
Reference: [LP94] <author> Gary T. Leavens and Don Pigozzi. </author> <title> The behavior-realization adjunction and generalized homomorphic relations. </title> <type> Technical Report 94-18a, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, September </month> <year> 1994. </year> <note> To appear in Theoretical Computer Science. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Recall that in our model the set of visible types consists of Integer and Bool. Homomorphic relations defined in this section capture when an algebra simulates another. These homomorphic relations are similar to the generalized homomorphic relations defined in <ref> [LP94] </ref> in the sense that they require "substitution", "VIS-identical", and 32 "bistrict" properties to be satisfied by related environments. The difference is in our explicit treatment of stores. More discussion on the comparison can be found in section 3.11. <p> So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic <ref> [BW90, Lea89, LW95, LP94] </ref> and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96]. <p> While the former approaches study models of types and define behavior in terms of these models, the latter approaches define behavioral subtyping based on the specification of individual types. 58 3.11.1 Model theoretic definitions There are several model-theoretic studies of behavioral subtyping <ref> [BW90, Lea89, LW95, LP94] </ref> that use simulation relations or simulation functions to define behavioral subtyping. However, all these works are restricted to types with immutable objects, and hence do not deal with mutation and aliasing. <p> Even if one were to eliminate aliasing between identifiers/objects of different types, the definitions of behavioral subtyping for immutable types cannot be directly applied to the behavioral subtyping when mutable types are allowed. 3.11.1.1 Leavens and Pigozzi's behavioral subtyping Like Leavens and Pigozzi <ref> [LP94] </ref>, we also define behavioral subtyping based on simulations that preserve substitution, coercion, VIS -identical, and other properties. Our substitution property, as in [LP94], captures the effects of operations by relating environments before and after the invocation of an operation. <p> subtyping for immutable types cannot be directly applied to the behavioral subtyping when mutable types are allowed. 3.11.1.1 Leavens and Pigozzi's behavioral subtyping Like Leavens and Pigozzi <ref> [LP94] </ref>, we also define behavioral subtyping based on simulations that preserve substitution, coercion, VIS -identical, and other properties. Our substitution property, as in [LP94], captures the effects of operations by relating environments before and after the invocation of an operation. But since we deal with mutation, we require a special identifier store to capture the effects of operation on the internal states of different objects. <p> The work in this dissertation leads to a result that allows modular reasoning of OO programs. The next step is a modular verification logic, which is left as a future work. In <ref> [LP94] </ref>, Leavens and Pigozzi give a definition of behavioral subtyping for immutable types that is both sound and complete. Though we use a similar notion of simulations, it is not clear whether our notions of weak and strong behavioral subtyping are complete. We leave this as an open problem.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year> <month> 109 </month>
Reference-contexts: The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches <ref> [BW90, LW90, LP92, LW95] </ref> do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack [Cus91] has a notion of specialization that is similar to behavioral subtyping.
Reference: [LW93a] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A new definition of the subtype relation. </title> <editor> In Oscar M. Nierstrasz, editor, </editor> <booktitle> ECOOP '93 | Object-Oriented Programming, 7th European Conference, Kaiserslautern, Germany, volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pages 118-141. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches <ref> [Ame87, Ame91, LW93a, LW94, DL96] </ref>. <p> These include America [Ame87], Liskov and Wing <ref> [LW93a, LW94] </ref> and our proof-theoretical notions of behavioral subtyping in [DL96]. Other than the approach, there are some fundamental differences between this dissertation and these proof-theoretic notions. <p> However, proof-theoretic approaches look at individual type specifications and define a relationship between such types. Our goal in studying behavioral subtyping is to provide a sound notion of behavioral subtyping that can be used for supertype abstraction. None of these proof-theoretic approaches <ref> [Ame87, LW93a, LW94, DL96] </ref> prove soundness of behavioral subtyping. But proving behavioral subtype relations using proof-theoretic notions is easier than using model-theoretic notions. We also identify two notions of behavioral subtyping of which the strong behavioral subtype notion is closer to the notions proposed by several proof-theoretic approaches. <p> The notion of weak behavioral subtyping is new to our work [DL96]. Since Liskov and Wing's work is an extension of America's work, we omit discussion of America's work. 3.11.2.1 Liskov and Wing's definition In <ref> [LW93a, LW94] </ref>, Liskov and Wing define behavioral subtyping based on the specification of types. They require the invariant, the constraint, and the postcondition of each method of the subtype to imply that of the supertype's and the precondition of each method of the supertype to imply that of the subtype.
Reference: [LW93b] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining subtypes. </title> <booktitle> OOPSLA '93 Proceedings, </booktitle> <editor> Andreas Paepcke (editor), </editor> <volume> volume 28(10), </volume> <booktitle> ACM SIGPLAN Notices, </booktitle> <pages> pages 16-28, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Further, she requires the types of the arguments for the common methods in the subtype and supertype to be the same. In contrast to the above model-theoretic approaches, America [Ame87, Ame91], and Liskov and Wing <ref> [LW93b, LW94] </ref> give proof-theoretic definitions of behavioral subtyping. America does not deal with extra mutators in subtypes. Liskov and Wing allow extra mutators provided that the extra mutators can be explained in terms of the supertype methods or if they do not violate any history constraints of the supertype.
Reference: [LW94] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: From this we can conclude that subtype objects "behave like" supertype objects. We use the notation S w T to denote that S is a weak behavioral subtype of T . 1.2.2.4 Strong behavioral subtyping Strong behavioral subtyping is defined with respect to a history constraint. History constraints <ref> [LW94] </ref> are like invariants but are defined across different stores. Recall that the strong behavioral subtype notion allows all forms of aliasing and does not allow subtypes that violate super-type's history constraints. <p> Further, she requires the types of the arguments for the common methods in the subtype and supertype to be the same. In contrast to the above model-theoretic approaches, America [Ame87, Ame91], and Liskov and Wing <ref> [LW93b, LW94] </ref> give proof-theoretic definitions of behavioral subtyping. America does not deal with extra mutators in subtypes. Liskov and Wing allow extra mutators provided that the extra mutators can be explained in terms of the supertype methods or if they do not violate any history constraints of the supertype. <p> These properties are specified as history constraints, which are introduced by Liskov and Wing <ref> [LW94] </ref>. These history constraints can be thought of as invariants over ordered pairs of stores produced in the extension of a program. The first component of such an ordered pair is created earlier than the second component in a program. <p> We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic [BW90, Lea89, LW95, LP94] and proof-theoretic approaches <ref> [Ame87, Ame91, LW93a, LW94, DL96] </ref>. <p> These include America [Ame87], Liskov and Wing <ref> [LW93a, LW94] </ref> and our proof-theoretical notions of behavioral subtyping in [DL96]. Other than the approach, there are some fundamental differences between this dissertation and these proof-theoretic notions. <p> However, proof-theoretic approaches look at individual type specifications and define a relationship between such types. Our goal in studying behavioral subtyping is to provide a sound notion of behavioral subtyping that can be used for supertype abstraction. None of these proof-theoretic approaches <ref> [Ame87, LW93a, LW94, DL96] </ref> prove soundness of behavioral subtyping. But proving behavioral subtype relations using proof-theoretic notions is easier than using model-theoretic notions. We also identify two notions of behavioral subtyping of which the strong behavioral subtype notion is closer to the notions proposed by several proof-theoretic approaches. <p> The notion of weak behavioral subtyping is new to our work [DL96]. Since Liskov and Wing's work is an extension of America's work, we omit discussion of America's work. 3.11.2.1 Liskov and Wing's definition In <ref> [LW93a, LW94] </ref>, Liskov and Wing define behavioral subtyping based on the specification of types. They require the invariant, the constraint, and the postcondition of each method of the subtype to imply that of the supertype's and the precondition of each method of the supertype to imply that of the subtype. <p> Whether one uses proof-theoretic techniques or model-theoretic techniques, the main goal is to capture a relationship that aids in understanding, formally or informally, OO programs. In this section, we look at this context and place the results of our work with respect to this context. Most proof-theoretic approaches <ref> [Ame91, LW94, DL96] </ref> study relationships between specific types and conclude that a behavioral subtype relationship exists. Proving these subtype relationships is easier. Since the behavior of types is given by their specification, these studies do not need a different model and a different semantics for studying behavioral subtype relations.
Reference: [LW95] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32(8) </volume> <pages> 705-778, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: This notion should allow modular reasoning. By modular reasoning we mean that conclusions about unchanged programs remain valid when new behavioral subtypes are added. One technique for modular reasoning of OO programs is supertype abstraction <ref> [LW95] </ref>. This technique allows conclusions based on the static types of variables. To ensure that these conclusions do not change, only subtype objects that are based on behavior are allowed in place of supertype objects. <p> The assumption here is that behavioral subtype objects do not produce any unexpected results when used in place of supertype objects. Hence for a modular reasoning technique that uses supertype abstraction any adequate notion of behavioral subtyping should guarantee that programs do not produce "surprising" results. In <ref> [LW95] </ref>, Leavens and Weihl give a model-theoretic definition of behavioral 1 In Eiffel this is done by instances of conforming types and in C++ by pointers to objects of publicly derived classes. 2 subtyping for immutable types, 2 which allows one to use supertype abstraction as a sound and modular reasoning <p> So the question is, when PlusAccount is added, do we require a reverification of test balance? One approach to solve this problem is to use supertype abstraction as a tool for modular verification <ref> [LW95] </ref>. Using supertype abstraction and reasoning at the static types of variables, that is reasoning under the assumption that b is always a BankAccount object, the set of expected results of test balance is ftrueg. <p> The simulation relations defined in [Lea89] do not have any provision for mutation. Similarly other model-theoretic approaches <ref> [BW90, LW90, LP92, LW95] </ref> do not deal with mutation and aliasing. So none of these approaches study the relation between aliasing and behavioral subtyping. Cusack [Cus91] has a notion of specialization that is similar to behavioral subtyping. <p> So we believe that subtype relations should be based on the behavior, not just on the structure of types. We do not discuss these structural notions [Car84, Car91] of subtyping further. Studies of subtyping that are based on the behavior of types can be broadly categorized into model-theoretic <ref> [BW90, Lea89, LW95, LP94] </ref> and proof-theoretic approaches [Ame87, Ame91, LW93a, LW94, DL96]. <p> While the former approaches study models of types and define behavior in terms of these models, the latter approaches define behavioral subtyping based on the specification of individual types. 58 3.11.1 Model theoretic definitions There are several model-theoretic studies of behavioral subtyping <ref> [BW90, Lea89, LW95, LP94] </ref> that use simulation relations or simulation functions to define behavioral subtyping. However, all these works are restricted to types with immutable objects, and hence do not deal with mutation and aliasing. <p> However, none of the proof-theoretic studies, so far, apply behavioral subtyping to the results of programs and show that their notion of behavioral subtyping do not produce any surprising results. Model-theoretic studies <ref> [LW95] </ref>, including this study, give models of type specifications, define behavioral subtype relations over those models, and prove that valid behavioral subtype relationships do not result any surprising behavior. These are shown over the context of a OO programming language. <p> These are shown over the context of a OO programming language. Compared to proof-theoretic approaches, it is tedious to prove behavioral subtype relationships using model-theoretic techniques. The results of these studies can be used for a sound modular reasoning technique <ref> [LW95] </ref>. An important future work is the study that bridges these two approaches. The results of such a study combine the ease of proving subtype relationships and the automatic application of "no surprises" results to modular verification.
Reference: [Mas86] <author> I. A. Mason. </author> <title> The Semantics of Destructive Lisp. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1986. </year> <note> Also available as CSLI Lecture Notes No. </note> <month> 5, </month> <title> Center for the Study of Language and Information, </title> <publisher> Stanford University. </publisher>
Reference-contexts: Action semantics, unlike denotational semantics, is more operational in nature. It would be interesting to look at applying the concepts of actions in our mutation algebras and split semantics. Mason and Talcott [MT91], [MT92] studied the semantics of functional languages with mutation, like LISP <ref> [Mas86] </ref>. Their approach is mainly operational and uses equational logics for proving program equivalences. Further, they limit interferences (aliasing) to within objects. They work on axioms over a particular language while we work on algebras and operations of the algebras.
Reference: [Mos92] <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Another way of looking at this comparison is while our work models subtype polymorphism, Wagner's work gives a mathematical explanation for a set of classes with inheritance. Other related work includes action semantics <ref> [Mos92] </ref>, [Wat91], which specify data using algebraic techniques. Action semantics, unlike denotational semantics, is more operational in nature. It would be interesting to look at applying the concepts of actions in our mutation algebras and split semantics.
Reference: [MT91] <author> Ian Mason and Carolyn Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 287-328, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Other related work includes action semantics [Mos92], [Wat91], which specify data using algebraic techniques. Action semantics, unlike denotational semantics, is more operational in nature. It would be interesting to look at applying the concepts of actions in our mutation algebras and split semantics. Mason and Talcott <ref> [MT91] </ref>, [MT92] studied the semantics of functional languages with mutation, like LISP [Mas86]. Their approach is mainly operational and uses equational logics for proving program equivalences. Further, they limit interferences (aliasing) to within objects.
Reference: [MT92] <author> Ian A. Mason and Carolyn L. Talcott. </author> <title> References, local variables and operational reasoning. </title> <booktitle> In Seventh Annual Symposium on Logic in Computer Science. IEEE, </booktitle> <year> 1992. </year>
Reference-contexts: Other related work includes action semantics [Mos92], [Wat91], which specify data using algebraic techniques. Action semantics, unlike denotational semantics, is more operational in nature. It would be interesting to look at applying the concepts of actions in our mutation algebras and split semantics. Mason and Talcott [MT91], <ref> [MT92] </ref> studied the semantics of functional languages with mutation, like LISP [Mas86]. Their approach is mainly operational and uses equational logics for proving program equivalences. Further, they limit interferences (aliasing) to within objects.
Reference: [Nip86] <author> Tobias Nipkow. </author> <title> Non-deterministic data types: Models and implementations. </title> <journal> Acta Informatica, </journal> <volume> 22(16) </volume> <pages> 629-661, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Store) less : (Integer; Integer; Store) ! (Bool; Store) leq : (Integer; Integer; Store) ! (Bool; Store) 2.1 Visible types To facilitate the study of visible behavior, we distinguish a subset of types as visible types; these are the types of values that can be "output" by a program [Sch91] <ref> [Nip86] </ref>. These are defined as follows. VIS = fBool; Integerg (2:1) These types are used to define observable behavior of states. Hence, one needs to fix the set of operations on the visible types and the sets of externally visible values of each of these types.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <month> January </month> <year> 1980. </year> <month> 110 </month>
Reference-contexts: Signatures also contain a function, ResType, which keeps track of the upper bound of the return type of operations. That is, operations are allowed to return subtype objects of their return type. These signatures are thus a simplified form of the signatures used in category-sorted algebras <ref> [Rey80] </ref> [Rey85].
Reference: [Rey85] <author> John C. Reynolds. </author> <title> Three approaches to type structure. </title> <editor> In Hartmut Ehrig, Christiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: Signatures also contain a function, ResType, which keeps track of the upper bound of the return type of operations. That is, operations are allowed to return subtype objects of their return type. These signatures are thus a simplified form of the signatures used in category-sorted algebras [Rey80] <ref> [Rey85] </ref>.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: Since we model mutation algebraically, we require an abstract notion of stores, that is stores cannot be treated just as functions (as is common in denotational semantics, e.g., <ref> [Sch86] </ref>). The following discussion motivates the need for special types and operations to handle mutation and stores abstractly. In a given algebra, a subset of ETYPES will be implemented as object types; that is as types whose carrier set is a set of locations. <p> N [[N]] A ( store) E H [[true]] A = true A ( store) E H [[false]] A = false A ( store) E H [[nothing]] A = nothing A ( store) E H let (~v; 0 ) = Efl H The let expressions used in the semantics are strict <ref> [Sch86] </ref>. That is, for a let expression let v = E in E 1 , if E is ?, then the result of the let expression is ?. For example, if ~ E is ? then g ( ~ E) is ?.
Reference: [Sch91] <author> Oliver Schoett. </author> <title> An observational subset of first-order logic cannot specify the behavior of a counter. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91 8th Annual Symposium on Theoretical Aspects of Computer Science Hamburg, Germany, February 1991 Proceedings, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 499-510. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: (Bool; Store) less : (Integer; Integer; Store) ! (Bool; Store) leq : (Integer; Integer; Store) ! (Bool; Store) 2.1 Visible types To facilitate the study of visible behavior, we distinguish a subset of types as visible types; these are the types of values that can be "output" by a program <ref> [Sch91] </ref> [Nip86]. These are defined as follows. VIS = fBool; Integerg (2:1) These types are used to define observable behavior of states. Hence, one needs to fix the set of operations on the visible types and the sets of externally visible values of each of these types.
Reference: [Sch94] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: We use standard denotation semantics <ref> [Sch94] </ref>.
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Mey-rowitz (editor), </editor> <month> September </month> <year> 1986, </year> <title> Portland, Oregon, </title> <journal> volume 21(11) of ACM SIGPLAN Notices, </journal> <pages> pages 38-45, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Subtyping based on signature [Car84, Car91] does not imply behavioral subtyp-ing <ref> [Sny86] </ref>. To see this, consider two types Stack and a Queue with get, put, and isIn operations. If subtyping is just based on the signature then a Stack is a subtype of a (FIFO) Queue and vice versa.
Reference: [Spi88] <author> J. M. Spivey. </author> <title> Understanding Z: a Specification Language and its Formal Semantics. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Introducing history constraints in their subsumption relations would be allow such reasoning and we believe that their notion of subsumption would then be equivalent to strong behavioral subtyping that is restricted to relations between structural subtypes. 3.11.1.3 Cusack's Specialization Cusack [Cus91] defines a notion of specialization over schemas of Z <ref> [Spi88] </ref> that is like behavioral subtyping. Since she uses schemas to define the specialization both the subtypes and the supertypes should be specified in the same schema. Further, she does not deal with the subtyping in the extra arguments of methods and does not have any notion of history constraints.
Reference: [Wag92] <author> Eric G. Wagner. </author> <title> Some mathematical thoughts on languages for data directed design. </title> <editor> In Rattray & Clark, editor, </editor> <booktitle> The Unified Computation Laboratory, </booktitle> <pages> pages 3-26. </pages> <publisher> Oxford University Press, </publisher> <address> Cambridge, U.K., </address> <year> 1992. </year>
Reference-contexts: However, our approach is more denotational, so having explicit locations helps in a better understanding of subtype relationships since it is closer to the way mutation is handled in denotational semantics. In <ref> [Wag92] </ref>, Wagner gives semantics for a language with objects, classes, and inheritance. For a given a class system, he defines a state and gives semantics of a language that uses it. One can think of these states as algebras. This work is different both philosophically and technically from mutation algebras.
Reference: [Wat91] <author> David A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Another way of looking at this comparison is while our work models subtype polymorphism, Wagner's work gives a mathematical explanation for a set of classes with inheritance. Other related work includes action semantics [Mos92], <ref> [Wat91] </ref>, which specify data using algebraic techniques. Action semantics, unlike denotational semantics, is more operational in nature. It would be interesting to look at applying the concepts of actions in our mutation algebras and split semantics.
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year> <month> 111 </month>
Reference-contexts: Overloading of operation symbols based on argument types is permitted. Overloading will also be useful in applying these algebras to object-oriented languages with message passing (which supports a kind of dynamic overloading <ref> [WB89] </ref>). Signatures also contain a function, ResType, which keeps track of the upper bound of the return type of operations. That is, operations are allowed to return subtype objects of their return type. These signatures are thus a simplified form of the signatures used in category-sorted algebras [Rey80] [Rey85].
Reference: [Wir90] <author> Martin Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 13, </booktitle> <pages> pages 675-788. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: We capture the "behaves like" relation as a set of semantic properties on models of types. For this we need models of mutable types, which we refer as mutation algebras. Mutation algebras, as opposed to regular algebras <ref> [Wir90, GM87] </ref>, contain stores as values. Using these stores, we model mutation as in denotational semantics. Further these algebras allow us to study observations on types independent of the language in which they are implemented. <p> ALGEBRAIC MODELS OF MUTABLE TYPES In this chapter, we develop algebraic models of mutable types. We refer to these algebras as mutation algebras. Mutation algebras are extensions of standard algebraic models of immutable types <ref> [Wir90, GM87] </ref>. There are two applications of mutation algebras in our study of behavioral sub-typing for mutable types. The first is to provide an algebraic model of types that is independent of any programming language. This allows us to study relations between different types or different implementations of types. <p> Algebras can be thought of as having both an internal signature, for implementation, and an external signature, a common interface. Such signatures are called hierarchical signatures and are similar to those in <ref> [Wir90, page 734] </ref>. Since internal operations can operate on external types, we require that the internal signature of a hierarchical signature contain the external signature.
Reference: [AZ93] <author> Egidio Astesiano & Elena Zucca. D-oids: </author> <title> a model for dynamic data-types. </title> <booktitle> In Mathematical Structures in Computer Science Vol. </booktitle> <volume> 11, </volume> <publisher> Cambridge University Press, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: It is also not clear how to achieve this split in the context of operational semantics as the configurations depend on specific algebras. Another interesting work that explicitly treats the with modeling mutable types is D-oids <ref> [AZ93] </ref>. Essentially, a D-oid consists of a set of instant structures and dynamic operations. These instant structures can be thought of as configurations (states) that contain objects along with their operations.
References-found: 45

