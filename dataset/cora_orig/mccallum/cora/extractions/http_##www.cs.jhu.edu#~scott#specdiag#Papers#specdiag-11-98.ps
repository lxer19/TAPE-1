URL: http://www.cs.jhu.edu/~scott/specdiag/Papers/specdiag-11-98.ps
Refering-URL: http://www.cs.jhu.edu/~scott/specdiag/
Root-URL: http://www.cs.jhu.edu
Email: scott@cs.jhu.edu  clt@cs.stanford.edu  
Title: Specification Diagrams for Actor Systems  
Author: Scott F. Smith Carolyn L. Talcott 
Note: Partial funding provided by NSF grants CCR-9312433 and CCR-9619843 Partial funding provided by ONR grant N00014-94-1-0857, NSF grant CRR-9633419, DARPA/Rome Labs grant AF F30602-96-1-0300, and DARPA/SRI subcontract 17-000042.  
Date: November 14, 1998  
Affiliation: The Johns Hopkins University  Stanford University  
Abstract: Specification diagrams are a novel form of graphical notation for specifying open distributed object systems. The design goal is to define notation for specifying message-passing behavior that is expressive, intuitively understandable, and that has formal semantic underpinnings. The notation generalizes informal notations such as UML's Sequence Diagrams and broadens their applicability to later in the design cycle. Specification diagrams differ from existing actor and process algebra presentations in that they are not a programming language per se; instead, like logics, they are inherently more biased toward specification. In this paper we rigorously define the language and give examples that show the expressiveness of the language, how properties of specifications may be asserted diagrammatically, and how it is possible to reason rigorously and modularly about specification diagrams. An Actor Theory Toolkit is used to great advantage for this purpose. 
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: Operational semantics of an actor theory The operational semantics of an actor theory is given by a labeled transition relation on actor system configurations. An actor configuration can be thought of as representing a global snapshot of an actor system with respect to some idealized observer <ref> [Agh86] </ref>. A configuration has an interface and an interior. A configuration interior, I , is a state together with a multiset of message packets, called the undelivered messages.
Reference: [AH78] <author> G. Attardi and C. Hewitt. </author> <title> Specifying and proving properites of guardians for distributed systems, </title> <year> 1978. </year>
Reference-contexts: the property that that all time messages sent to the Ticker will receive a reply was expressed by the LiveTicker specification, and the statement hTicker (a)i a ; j= hLiveTicker (a)i a ; asserts the Ticker has such a property. (Note, such a liveness property was termed responsiveness by Hewitt <ref> [AH78] </ref>.) LiveTicker actually states a stronger property than liveness it asserts a bijection between receives and sends. The Ticker itself is fairly obvious to show live since the body is very short; but, this technique will work for more complex behaviors.
Reference: [AMST97] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <volume> 7:172, </volume> <year> 1997. </year>
Reference-contexts: To define the diagram actor theory, SDTh the obligations are to define the states and reaction rules. For the constrained diagram actor theory cSDTh the admissibility predicate, A sd must also be defined. The main difference with previous operational semantics for actors <ref> [AMST97, Tal97] </ref> is the emphasis here on specification versus computation; concretely, the 42 admissibility condition is stronger in that fewer paths will pass the condition. 5.1 Preliminaries We now give some mathematical preliminaries needed to define the specification diagram actor theory. <p> A definition is given below which handles the above as well as other cases. The approach taken here was inspired by the macro-steps transformation of <ref> [AMST97] </ref>. In the following, we assume diagrams are placed in a form where each rec X:D uses a unique recursion variable X. First, the structure of a big-step is defined. <p> Big steps are then formed by iteratively reshuffling actions. Similar proofs are given in <ref> [AMST97, MT99] </ref>. A further simplification can be made by making the big steps the official rules. This is a special case of the macro step transformation described in Section 4. This is formalized by the following actor theory tranformation.
Reference: [BB87] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. Computer Networks and ISDN Systems, </title> <address> 14:2559, </address> <year> 1987. </year> <month> 65 </month>
Reference-contexts: Specification diagrams are much more flexible as an assertion language, allowing more kinds of safety and liveness assertions to be made directly in the language. A number of full specification languages based on process algebra have been developed; examples include LOTOS <ref> [BB87] </ref>, which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [MP92, Lam94] . Recently temporal logics for distributed object based systems have been developed [Dua97, Den98].
Reference: [BH77] <author> Henry G. Baker and Carl Hewitt. </author> <title> Laws for communicating parallel processes. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 987992. </pages> <publisher> IFIP, </publisher> <month> August </month> <year> 1977. </year>
Reference-contexts: We may further abbreviate, by omitting mention of focus actors (which defaults to the internal actors of the source state), and empty sets of created actors, received or sent message packets. The set of rules must be closed under renaming, and must satisfy the fundamental actor locality laws of <ref> [BH77, Cli81] </ref>.
Reference: [BHH + 97] <author> R. Breu, U. Hinkel, C. Hofmann, C. Klein, B. Paech, B. Rumpe, and V. Thurner. </author> <title> Towards a formalization of the unified modeling language. </title> <booktitle> In ECOOP '97, volume 1241 of Lecture Notes in Computer Science, </booktitle> <pages> pages 344 365. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Section 3.6 gave a detailed contrast between specification diagrams and sequence diagrams. The largest difference is our more foundational approach and aim for specifying total behavior of a system and not just scenarios. An elementary semantics for sequence diagrams appears in <ref> [BHH + 97] </ref>. Wirsing and Knapp [WK96] have developed tools for generating formal executable specifications from Jacobson's interaction diagrams (an ancestor of sequence diagrams) extended with formal annotations.
Reference: [Cli81] <author> W. D. Clinger. </author> <title> Foundations of Actor Semantics. </title> <type> PhD thesis, </type> <institution> MIT, 1981. MIT Artificial Intelligence Laboratory AI-TR-633. </institution>
Reference-contexts: Like UML sequence diagrams, it may be used to sketch initial specifications. Unlike sequence diagrams, it also allows rigorous assertion that an implementation meets a given specification. Its design is related to concepts from actor event diagrams <ref> [Cli81] </ref> and UML Sequence Diagrams [RJB98], and shares concepts with process algebra [Mil80, Hoa85], and Dijkstra-style weakest precondition calculus [Nel87]. <p> We may further abbreviate, by omitting mention of focus actors (which defaults to the internal actors of the source state), and empty sets of created actors, received or sent message packets. The set of rules must be closed under renaming, and must satisfy the fundamental actor locality laws of <ref> [BH77, Cli81] </ref>. <p> An elementary semantics for sequence diagrams appears in [BHH + 97]. Wirsing and Knapp [WK96] have developed tools for generating formal executable specifications from Jacobson's interaction diagrams (an ancestor of sequence diagrams) extended with formal annotations. In the actor model, event diagrams <ref> [Gre75, Hew77, Cli81] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [Cor97] <institution> Rational Software Corporation. </institution> <note> UML Notation Guide, version 1.1. Septem-ber 1997. Obtained From http://www.rational.com. </note>
Reference-contexts: However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification. It should be added that the latest version of sequence diagrams <ref> [Cor97] </ref>, has considerable extra syntax added so more features can be expressed, bringing them somewhat closer to the syntax of specification diagrams. The left diagram of Figure 10 is a UML sequence diagram which is presented in [Cor97] (we have removed temporal constraints since specification diagrams are not real-time). <p> It should be added that the latest version of sequence diagrams <ref> [Cor97] </ref>, has considerable extra syntax added so more features can be expressed, bringing them somewhat closer to the syntax of specification diagrams. The left diagram of Figure 10 is a UML sequence diagram which is presented in [Cor97] (we have removed temporal constraints since specification diagrams are not real-time). On the right side is the same example re-expressed as a specification diagram. This example also brings out the usefulness of the send-receive cross-edges in specification diagrams.
Reference: [Den98] <author> G. Denker. </author> <title> DTL + : A Distributed Temporal Logic Supporting Several Communication Principles. </title> <type> Technical Report , SRI International, </type> <institution> Computer Science Laboratory, </institution> <address> 333 Ravenswood Ave, Menlo Park, CA 94025, </address> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [MP92, Lam94] . Recently temporal logics for distributed object based systems have been developed <ref> [Dua97, Den98] </ref>. While such logics express an extremely broad collection of properties, a 64 significant disadvantage is the need for large, complex formulae to specify non-trivial systems: readability of specifications becomes a serious issue even for small specifications, and users thus require more advanced training.
Reference: [DS90] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics, </title> <booktitle> volume 14 of Texts and Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This interpretation is analogous to the assume predicate of Dijkstra's predicate calculus <ref> [DS90] </ref>. assertion (assert (OE)) An arbitrary assertion is made. Unlike constrain, an assert that fails indicates failure of some property, and has no program matic meaning. This is analogous to Dijkstra's assert predicate. 8 assign (x := ) A variable is dynamically assigned a new value.
Reference: [Dua97] <author> C. H. </author> <title> C Duarte. A proof-theoretic approach to the design of object-based mobility. </title> <editor> In H. Bowman and J. Derrick, editors, </editor> <booktitle> Formal Methods for Open Object-based Distributed Systems, </booktitle> <volume> Volume 2, </volume> <pages> pages 3753. </pages> <publisher> Chapman & Hall, </publisher> <year> 1997. </year>
Reference-contexts: Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [MP92, Lam94] . Recently temporal logics for distributed object based systems have been developed <ref> [Dua97, Den98] </ref>. While such logics express an extremely broad collection of properties, a 64 significant disadvantage is the need for large, complex formulae to specify non-trivial systems: readability of specifications becomes a serious issue even for small specifications, and users thus require more advanced training.
Reference: [Gre75] <author> I. Greif. </author> <title> Semantics of communicating parallel processes. </title> <type> Technical Report 154, </type> <institution> MIT, Project MAC, </institution> <year> 1975. </year>
Reference-contexts: An elementary semantics for sequence diagrams appears in [BHH + 97]. Wirsing and Knapp [WK96] have developed tools for generating formal executable specifications from Jacobson's interaction diagrams (an ancestor of sequence diagrams) extended with formal annotations. In the actor model, event diagrams <ref> [Gre75, Hew77, Cli81] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8(3):231274, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Many specification languages that have achieved widespread usage have a graphical presentation format, primarily because engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include The Unified Modeling Language (UML) and its predecessors [RJB98], Petri nets, and Statecharts <ref> [Har87] </ref>. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. Our aim here is a language with similar intuitive advantages but significantly greater expressivity and formal underpinnings. <p> Finite automata are useful for specifying systems which have a strong state-based behavior. They lack expressivity, but partly make up for this lack by their amenability to automatic verification by state-space search techniques. The Stat-echarts automata formalism <ref> [Har87] </ref> has become particularly popular in industry. The primary weakness of finite automata is that a complex software system may not have a meaningful global state, and properties of such systems are often more naturally expressed in terms of events and relations on events.
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3):323364, </volume> <year> 1977. </year>
Reference-contexts: An elementary semantics for sequence diagrams appears in [BHH + 97]. Wirsing and Knapp [WK96] have developed tools for generating formal executable specifications from Jacobson's interaction diagrams (an ancestor of sequence diagrams) extended with formal annotations. In the actor model, event diagrams <ref> [Gre75, Hew77, Cli81] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Like UML sequence diagrams, it may be used to sketch initial specifications. Unlike sequence diagrams, it also allows rigorous assertion that an implementation meets a given specification. Its design is related to concepts from actor event diagrams [Cli81] and UML Sequence Diagrams [RJB98], and shares concepts with process algebra <ref> [Mil80, Hoa85] </ref>, and Dijkstra-style weakest precondition calculus [Nel87]. The underlying communication assumptions we use are taken from the actor model: object- and not channel-based naming is used, open systems are treated explicitly, and message passing is asynchronous, fair, and with nondeterministic arrival order. <p> Message send and receive have related concepts in the asynchronous -calculus [HT91]. Specification diagrams additionally allow communication to be constrained both at send and receive by cross-edges. The underlying semantics differs considerably from calculus semantics, but is similar in spirit to the trace-based models of CSP <ref> [Hoa85] </ref>; however, there still are a number of differences. CSP traces must be augmented with refusal and divergence information to obtain compositional semantics, while simple interaction paths are adequate for actor based systems [Tal98]. CSP traces do not provide directly for dynamic name creation and name passing.
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP, volume 512 of LNCS, </booktitle> <pages> pages 133147. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Process algebra notation may be used to formally specify the communication actions of concurrent systems. Parallel composition and choice is of a similar sort in specification diagrams and process algebra. Message send and receive have related concepts in the asynchronous -calculus <ref> [HT91] </ref>. Specification diagrams additionally allow communication to be constrained both at send and receive by cross-edges. The underlying semantics differs considerably from calculus semantics, but is similar in spirit to the trace-based models of CSP [Hoa85]; however, there still are a number of differences.
Reference: [Lam94] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM TOPLAS, </journal> <volume> 16(3):872923, </volume> <month> May </month> <year> 1994. </year> <month> 66 </month>
Reference-contexts: A number of full specification languages based on process algebra have been developed; examples include LOTOS [BB87], which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [MP92, Lam94] </ref> . Recently temporal logics for distributed object based systems have been developed [Dua97, Den98].
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Like UML sequence diagrams, it may be used to sketch initial specifications. Unlike sequence diagrams, it also allows rigorous assertion that an implementation meets a given specification. Its design is related to concepts from actor event diagrams [Cli81] and UML Sequence Diagrams [RJB98], and shares concepts with process algebra <ref> [Mil80, Hoa85] </ref>, and Dijkstra-style weakest precondition calculus [Nel87]. The underlying communication assumptions we use are taken from the actor model: object- and not channel-based naming is used, open systems are treated explicitly, and message passing is asynchronous, fair, and with nondeterministic arrival order.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A number of full specification languages based on process algebra have been developed; examples include LOTOS [BB87], which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [MP92, Lam94] </ref> . Recently temporal logics for distributed object based systems have been developed [Dua97, Den98].
Reference: [MT99] <author> I. A. Mason and C. L. Talcott. </author> <title> Actor languages their syntax, semantics, translation, and equivalence, </title> <note> 1999. to appear. </note>
Reference-contexts: More detail about the framework can be found in <ref> [Tal98, MT99] </ref>. We begin with a discussion of the interaction path model. We then introduce actor theories as a general semantic framework for actor systems (including specification diagrams) and show how interaction semantics is derived from actor theory semantics. <p> The framework then specifies the interaction paths induced by that rule set. The main advantage of such an approach is that it provides a basis for relating different actor system components. On one level, the semantics of a program written in an actor programming language <ref> [MT99] </ref> can be related to say the semantics of a specification diagram. On another level, two different specification diagrams can be shown equivalent by showing that actor theories specialized to their behavior structurally correspond. <p> A general example, for actor theories whose states decompose into individual actor states, can be found in <ref> [MT99] </ref>. Any canonical form transformation which requires serialization of certain silent steps (steps with no trigger or effect) with neighboring steps with an effect or trigger is sound. Silent step elimination Silent step elimination may be used to remove irrelevant silent steps from a constrained actor theory. <p> Big steps are then formed by iteratively reshuffling actions. Similar proofs are given in <ref> [AMST97, MT99] </ref>. A further simplification can be made by making the big steps the official rules. This is a special case of the macro step transformation described in Section 4. This is formalized by the following actor theory tranformation.
Reference: [Nel87] <author> Greg Nelson. </author> <title> A generalization of dijkstra's calculus. </title> <journal> TOPLAS, </journal> <volume> 11:517561, </volume> <year> 1987. </year>
Reference-contexts: Unlike sequence diagrams, it also allows rigorous assertion that an implementation meets a given specification. Its design is related to concepts from actor event diagrams [Cli81] and UML Sequence Diagrams [RJB98], and shares concepts with process algebra [Mil80, Hoa85], and Dijkstra-style weakest precondition calculus <ref> [Nel87] </ref>. The underlying communication assumptions we use are taken from the actor model: object- and not channel-based naming is used, open systems are treated explicitly, and message passing is asynchronous, fair, and with nondeterministic arrival order. We believe that the language has uncommon breadth of usefulness. <p> The manner in which computations may be cancelled in the middle of computing via constrain is similar to the behavior of the assume (miraculous or partial) command introduced by Nelson and others <ref> [Nel87] </ref>. Predicates that impose requirements, assert (OE) in specification diagrams, correspond to the Dijkstra calculus assert command. Finite automata are useful for specifying systems which have a strong state-based behavior. They lack expressivity, but partly make up for this lack by their amenability to automatic verification by state-space search techniques.
Reference: [RB96] <author> Jim Rumbaugh and Grady Booch. </author> <title> Unified Method for Object Oriented Development, </title> <note> version 0.8. 1996. Obtained From http://www.rational.com. </note>
Reference-contexts: (* receiver r *) e lift-receiver dial-tone dial-digit phone-ringsringing-phone answer-phone stop-phone stop-ringing e e r c e PhoneRoute (c,e,r) = gram 3.6 Comparison with UML Sequence Diagrams Specification diagrams were partly inspired by UML sequence diagrams [RJB98] (to be specific, by an early version known as a message trace diagram <ref> [RB96] </ref>), and the two share concepts. However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification.
Reference: [RJB98] <author> Jim Rumbaugh, Ivar Jacobson, and Grady Booch. </author> <title> Unified Modeling Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1998. </year>
Reference-contexts: Many specification languages that have achieved widespread usage have a graphical presentation format, primarily because engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include The Unified Modeling Language (UML) and its predecessors <ref> [RJB98] </ref>, Petri nets, and Statecharts [Har87]. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. Our aim here is a language with similar intuitive advantages but significantly greater expressivity and formal underpinnings. <p> Like UML sequence diagrams, it may be used to sketch initial specifications. Unlike sequence diagrams, it also allows rigorous assertion that an implementation meets a given specification. Its design is related to concepts from actor event diagrams [Cli81] and UML Sequence Diagrams <ref> [RJB98] </ref>, and shares concepts with process algebra [Mil80, Hoa85], and Dijkstra-style weakest precondition calculus [Nel87]. The underlying communication assumptions we use are taken from the actor model: object- and not channel-based naming is used, open systems are treated explicitly, and message passing is asynchronous, fair, and with nondeterministic arrival order. <p> phone stop ringing . . . (* caller c *) (* exchange e *) (* receiver r *) e lift-receiver dial-tone dial-digit phone-ringsringing-phone answer-phone stop-phone stop-ringing e e r c e PhoneRoute (c,e,r) = gram 3.6 Comparison with UML Sequence Diagrams Specification diagrams were partly inspired by UML sequence diagrams <ref> [RJB98] </ref> (to be specific, by an early version known as a message trace diagram [RB96]), and the two share concepts. However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification. <p> Specification diagrams are most closely related to other forms of message-passing diagrams, diagrams with vertical lines for processes/threads, and horizontal lines for messages. Message passing diagrams have a long history in 63 software specification and are now most widely known as UML Sequence Dia--grams <ref> [RJB98] </ref>. Section 3.6 gave a detailed contrast between specification diagrams and sequence diagrams. The largest difference is our more foundational approach and aim for specifying total behavior of a system and not just scenarios. An elementary semantics for sequence diagrams appears in [BHH + 97].
Reference: [Smi98] <author> S. Smith. </author> <title> On specification diagrams for actor systems. </title> <editor> In C. Talcott A. Gordon, A .Pitts, editor, </editor> <booktitle> Proceedings of the Second Workshop on Higher-Order Techniques in Semantics, Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1998. </year> <note> http://www.elsevier.nl/locate/entcs/volume10.html. </note>
Reference-contexts: Following that is Section 5 which shows how diagrams may be given operational meaning via an actor theory. Section 6 gives example proofs of relations between diagrams illustrating the use of the semantic framework to reason about specifications. <ref> [Smi98] </ref> is the initial paper on specification diagrams. 1.1 Actor Concepts We provide a brief overview of the underlying actor basis at this point. Section 4 builds the actor theory framework over this basis. Actors are distributed, object-based message passing entities.
Reference: [Tal96] <author> C. L. Talcott. </author> <title> Interaction semantics for components of distributed systems. </title> <editor> In E. Najm and J-B. Stefani, editors, </editor> <booktitle> 1st IFIP Workshop on Formal Methods for Open Object-based Distributed Systems, </booktitle> <address> FMOODS'96, </address> <year> 1996. </year> <note> Proceedings published in 1997 by Chapman & Hall. </note>
Reference-contexts: Thus we define the interaction semantics of a configuration to be the set of interaction paths obtained from admissible computation paths by hiding internal information. Interaction semantics gives a more abstract view of an actor system. It is a compositional semantics with many pleasant properties <ref> [Tal96, Tal98] </ref>. It hides information concerning the internal computations and what actors may be present beyond the receptionists. The interaction semantics of a configuration is the set of interaction paths obtained from admissible computation paths by hiding internal information.
Reference: [Tal97] <author> C. L. Talcott. </author> <title> Composable semantic models for actor theories. </title> <editor> In M. Abadi and T. Ito, editors, </editor> <booktitle> Theoretical Aspects of Computer Science, number 1281 in Lecture Notes in Computer Science, </booktitle> <pages> pages 321364. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: To define the diagram actor theory, SDTh the obligations are to define the states and reaction rules. For the constrained diagram actor theory cSDTh the admissibility predicate, A sd must also be defined. The main difference with previous operational semantics for actors <ref> [AMST97, Tal97] </ref> is the emphasis here on specification versus computation; concretely, the 42 admissibility condition is stronger in that fewer paths will pass the condition. 5.1 Preliminaries We now give some mathematical preliminaries needed to define the specification diagram actor theory.
Reference: [Tal98] <author> C. L. Talcott. </author> <title> Composable semantic models for actor theories. Higher-Order and Symbolic Computation, </title> <type> 11(3), </type> <year> 1998. </year>
Reference-contexts: More detail about the framework can be found in <ref> [Tal98, MT99] </ref>. We begin with a discussion of the interaction path model. We then introduce actor theories as a general semantic framework for actor systems (including specification diagrams) and show how interaction semantics is derived from actor theory semantics. <p> Thus we define the interaction semantics of a configuration to be the set of interaction paths obtained from admissible computation paths by hiding internal information. Interaction semantics gives a more abstract view of an actor system. It is a compositional semantics with many pleasant properties <ref> [Tal96, Tal98] </ref>. It hides information concerning the internal computations and what actors may be present beyond the receptionists. The interaction semantics of a configuration is the set of interaction paths obtained from admissible computation paths by hiding internal information. <p> CSP traces must be augmented with refusal and divergence information to obtain compositional semantics, while simple interaction paths are adequate for actor based systems <ref> [Tal98] </ref>. CSP traces do not provide directly for dynamic name creation and name passing. Other significant differences are found beneath the surface in the semantics of operators.
Reference: [Wir90] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 675788. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Diagrams may both be close to the coded implementation, and may be highly abstract. Two concrete notions of satisfaction are now presented. Loose Satisfaction The first notion of satisfaction we call loose satisfaction is analogy to the loose approach to algebraic specification <ref> [Wir90] </ref>. This form of satisfaction is a subset relationship on interaction path behaviors: Definition 3.1 (loose satisfaction): hD I i ae O j= hD S i ae O ]] [[hD S i ae recalling that [[]] gives the semantics of a top-level diagram as a set of interaction paths. <p> Lemma 3.2: j= is a partial order. The standard means of relating algebraic specifications is by refinement relations. Loose satisfaction is a refinement relation in the sense of <ref> [Wir90] </ref>, that is it is transitive and monotonic with respect to composition of top level diagrams. Thus we may say that D refines to D 0 just if D 0 j= D. Loose Satisfaction and the Ticker Loose specifications may easily be written in specification diagrams. <p> This is strong satisfaction, an equiva lence. Definition 3.3 (strong satisfaction): hD I i ae O j=j hD S i ae O ]] = [[hD S i ae Lemma 3.4: j=j is the least equivalence relation containing j= . In algebraic specification <ref> [Wir90] </ref>, the analogous concept is the equivalence of specifications. In our framework we additionally may assert an implementation equivalent to the specification, as this is very useful when a tight specification of an implementation is possible.
Reference: [WK96] <author> Martin Wirsing and Alexander Knapp. </author> <title> A formal approach to object oriented software engineering. </title> <editor> In J. Meseguer, editor, </editor> <booktitle> Proc. 1st Intl. Workshop on Rewriting Logic and its Applications, number 4 in Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> North Holland, </publisher> <year> 1996. </year> <month> 67 </month>
Reference-contexts: Section 3.6 gave a detailed contrast between specification diagrams and sequence diagrams. The largest difference is our more foundational approach and aim for specifying total behavior of a system and not just scenarios. An elementary semantics for sequence diagrams appears in [BHH + 97]. Wirsing and Knapp <ref> [WK96] </ref> have developed tools for generating formal executable specifications from Jacobson's interaction diagrams (an ancestor of sequence diagrams) extended with formal annotations.
References-found: 29

