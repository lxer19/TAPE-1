URL: http://www.cs.washington.edu/homes/jake/work/inv.ps
Refering-URL: http://www.cs.washington.edu/homes/jake/work/work.html
Root-URL: http://www.cs.washington.edu
Email: fmernst,jake,notking@cs.washington.edu  wgg@cs.ucsd.edu  
Phone: +1-206-543-1695  +1-619-534-6898  
Title: Dynamically Discovering Likely Program Invariants to Support Program Evolution  
Author: Michael D. Ernst Jake Cockrell William G. Griswold and David Notkin 
Keyword: Program invariants, formal specification, software evolution, dynamic analysis, execution traces, logical inference, pattern recognition  
Address: Box 352350, Seattle WA 98195-2350 USA  San Diego, 0114 La Jolla, CA 92093-0114 USA  
Affiliation: Dept. of Computer Science Engineering University of Washington  Dept. of Computer Science Engineering University of California  
Abstract: Explicitly stated program invariants can help programmers by identifying program properties that must be preserved when modifying code. In practice, however, these invariants are usually implicit. An alternative to expecting programmers to fully annotate code with invariants is to automatically infer invariants from the program itself. This research focuses on dynamic techniques for discovering invariants from execution traces. This paper reports two results. First, it describes techniques for dynamically discovering invariants, along with an instru-menter and an inference engine that embody these techniques. Second, it reports on the application of the engine to two sets of target programs. In programs from Gries's work on program derivation, we rediscovered predefined invariants. In a C program lacking explicit invariants, we discovered invariants that assisted a software evolution task. 
Abstract-found: 1
Intro-found: 1
Reference: [And98] <author> James H. Andrews. </author> <title> Testing using log file analysis: Tools, methods and issues. </title> <booktitle> In Proceedings of the 13th Annual International Conference on Automated Software Engineering (ASE'98), </booktitle> <address> Honolulu, Hawaii, </address> <month> October </month> <year> 1998. </year>
Reference: [BBM97] <author> Nicolaj Bjorner, Anca Browne, and Zohar Manna. </author> <title> Automatic generation of invariants and intermediate assertions. </title> <journal> Theoretical Computer Science, </journal> <volume> 173(1) </volume> <pages> 49-87, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, ?, BBM97] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, ?, XP98], the desired property is obvious.
Reference: [BG93] <author> Ivan Bratko and Marko Grobelnik. </author> <title> Inductive learning applied to program construction and verification. </title> <editor> In Jose Cuena, editor, </editor> <booktitle> Knowledge Oriented Software Design: Extended Papers from the IFIP TC 12 Workshop on Artificial Intelligence from the Information Processing Perspective, </booktitle> <address> AIFIPP '92, Madrid, Spain, </address> <month> 14-15 September, </month> <year> 1992, </year> <pages> pages 169-182. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: Our invariant differencing tool can indicate how a program change has affected the computed invariants. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) [Qui90, Coh94] to construct Horn clause loop invariants from variable values on particular loop executions <ref> [BG93] </ref>.
Reference: [BG97] <author> Bernard Boigelot and Patrice Godefroid. </author> <title> Automatic synthesis of specifications from the dynamic observation of reactive programs. </title> <booktitle> In Proceedings of the Third International Workshop on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'97), volume 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 321-333, </pages> <address> Twente, </address> <month> April </month> <year> 1997. </year>
Reference: [BLS96] <author> S. Bensalem, Y. Lakhnech, and H. Saidi. </author> <title> Powerful techniques for the automatic generation of invariants. </title> <booktitle> In Proceedings of the Eighth International Conference on Computer Aided Verification CAV, </booktitle> <pages> pages 323-335, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: Considerable research has addressed checking formal specifications [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92]; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it <ref> [Weg74, BLS96] </ref>; our goal is the discovery of such properties from a broad class of possible ones. Variable types are a variety of formal specification and documentation.
Reference: [CC77] <author> Patrick M. Cousot and Radhia Cousot. </author> <title> Automatic synthesis of optimal invariant assertions: </title> <booktitle> Mathematical foundations. In Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages, volume 12(8) of ACM SIGPLAN Notices, </booktitle> <pages> pages 1-12, </pages> <address> Rochester, NY, </address> <month> August </month> <year> 1977. </year>
Reference: [Coh94] <author> William W. Cohen. </author> <title> Grammatically biased learning: learning logic programs using an explicit antecedent description language. </title> <journal> Artificial Intelligence, </journal> <volume> 68 </volume> <pages> 303-366, </pages> <year> 1994. </year>
Reference-contexts: Our invariant differencing tool can indicate how a program change has affected the computed invariants. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) <ref> [Qui90, Coh94] </ref> to construct Horn clause loop invariants from variable values on particular loop executions [BG93].
Reference: [CW98a] <author> Jonathan E. Cook and Alexander L. Wolf. </author> <title> Discovering models of software processes from event-based data. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 7(3) </volume> <pages> 215-249, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: Other researchers use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace <ref> [?, ?, CW98a, CW98b] </ref>. Static Inference Static analyses operate on the program text, not on particular test runs, and are typically sound but conservative.
Reference: [CW98b] <author> Jonathan E. Cook and Alexander L. Wolf. </author> <title> Event-based detection of concurrency. </title> <booktitle> In Sixth International Symposium on the Foundations of Software Engineering (FSE-6), </booktitle> <address> Orlando, FL, </address> <month> November </month> <year> 1998. </year>
Reference-contexts: Other researchers use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace <ref> [?, ?, CW98a, CW98b] </ref>. Static Inference Static analyses operate on the program text, not on particular test runs, and are typically sound but conservative.
Reference: [DB84] <author> Douglas D. Dunlop and Victor R. Basili. </author> <title> A heuristic for deriving loop functions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(3) </volume> <pages> 275-285, </pages> <month> May </month> <year> 1984. </year>
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In Proceedings of the ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [Det96] <author> David L. Detlefs. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In First Workshop on Formal Methods in Software Practice, </booktitle> <pages> pages 1-9, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [EDG95] <author> Edison Design Group. </author> <title> C++ Front End Inter--nal Documentation, </title> <note> version 2.28 edition, </note> <month> March </month> <year> 1995. </year> <note> http://www.edg.com. </note>
Reference: [EGHT94] <author> David Evans, John Guttag, James Horning, and Yang Meng Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> Proceedings of the ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 87-97, </pages> <month> De-cember </month> <year> 1994. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [Eva96] <author> David Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> In Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 44-53, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [GC96] <author> Gerald C. Gannod and Betty H.C. Cheng. </author> <title> Strongest post-condition semantics as the formal basis for reverse engineering. </title> <journal> Journal of Automated Software Engineering, </journal> 3(1/2):139-164, June 1996. 
Reference: [GH96] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Variable types are a variety of formal specification and documentation. Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS <ref> [HHN92, GH96] </ref> propagates data structure shape descriptions through a program. Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97].
Reference: [Giv96] <author> Robert Givan. </author> <title> Inferring program specifications in polynomial-time. </title> <booktitle> In Proceedings of the Third International Symposium on Static Analysis, SAS '96, </booktitle> <pages> pages 205-219, </pages> <address> Aachen, Germany, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones. Variable types are a variety of formal specification and documentation. Type inference extends partial type annotations to full ones; similarly, Givan <ref> [Giv96] </ref> extends specifications on the inputs of a procedure to its output, and ADDS [HHN92, GH96] propagates data structure shape descriptions through a program.
Reference: [Gri81] <editor> David Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Our first result is a set of techniques, and an implementation, for discovering invariants from execution traces (Section 3). Our second result is the application of our inference engine to two sets of target programs. The first set of programs, taken from The Science of Programming <ref> [Gri81] </ref>, was derived from formal preconditions, postconditions, and loop invariants. Given runs of the program over randomly-generated inputs, our techniques discover those same program properties, plus some additional ones (Section 2). <p> Section 6 surveys related work, and Section 7 concludes. 2 REDISCOVERY OF INVARIANTS To introduce our approach and illustrate the output of our tool, we present the invariants detected in a simple program taken from The Science of Programming <ref> [Gri81] </ref>, a book that espouses deriving programs from specifications. Unlike typical programs, for which it may be difficult to determine the desired output of invariant detection, many of the book's programs include preconditions, postconditions, and loop invariants that embody important properties of the computation.
Reference: [Gup90] <author> Rajiv Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282, </pages> <address> White Plains, NY, USA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, ?, XP98] </ref>, the desired property is obvious. The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90], while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?].
Reference: [GW75] <author> Steven M. German and Ben Wegbreit. </author> <title> A synthesizer of inductive assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(1) </volume> <pages> 68-75, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, ?, BBM97] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, ?, XP98], the desired property is obvious.
Reference: [HFGO94] <author> Monica Hutchins, Herb Foster, Tarak Goradia, and Thomas Ostrand. </author> <title> Experiments on the effectiveness of dataflow-and controlflow-based test adequacy criteria. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 191-200, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Given runs of the program over randomly-generated inputs, our techniques discover those same program properties, plus some additional ones (Section 2). The second set of programs | C programs, originally from Siemens <ref> [HFGO94] </ref>, and modified by Rothermel and Harrold [RH98] | is not annotated with invariants, nor is there any indication that invariants were used in their construction. Section 4 shows how numeric invariants dynamically inferred from one of these programs assisted in understanding and changing it. <p> To help determine whether and how derived invariants might help a programmer modify a program that contains no explicitly-stated invariants, we used invariants produced by our engine in evolving a program from the Siemens suite <ref> [HFGO94, RH98] </ref>. After describing the scenario we went through in modifying this program, we discuss some of the factors that make the use of invariants qualitatively different from some more traditional styles of gathering information about programs.
Reference: [HHN92] <author> Laurie J. Hendren, Joseph Hummel, and Alexandru Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Variable types are a variety of formal specification and documentation. Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS <ref> [HHN92, GH96] </ref> propagates data structure shape descriptions through a program. Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97].
Reference: [HRWY98] <author> Mary Jean Harrold, Gregg Rothermel, Rui Wu, and Liu Yi. </author> <title> An empirical investigation of program spectra. </title> <booktitle> In ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE '98), </booktitle> <pages> pages 83-90, </pages> <address> Mon-treal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: However, we believe that generalizing these techniques, or applying them to subproblems of our task, can be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging. Program spectra (specific aspects of program runs, such as event traces, code coverage, or outputs) <ref> [RBDL97, HRWY98] </ref> can reveal differences in inputs or program versions. Other researchers use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace [?, ?, CW98a, CW98b].
Reference: [HWF90] <author> Robert Henry, Kenneth M. Whaley, and Bruce Forstall. </author> <title> The University of Washington Illustrating Compiler. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 223-246, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In the case of array bounds checking [SI77, Gup90, KW95, ?, XP98], the desired property is obvious. The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations <ref> [HWF90] </ref>, while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?].
Reference: [JGS93] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Pren-tice Hall, </publisher> <year> 1993. </year>
Reference-contexts: The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90], while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?]. Other related work includes staging and binding-time analyses, which determine invariant or semi-invariant values for use in partial evaluation <ref> [JGS93] </ref>. 7 CONCLUSIONS This paper documents the feasibility and effectiveness of discovering program invariants based on execution traces. Our technique automatically detected all the stated invariants in a set of formally-specified programs, and the invariants detected in a real C program proved useful in a software evolution task.
Reference: [JH98] <author> Ralph Jeffords and Constance Heitmeyer. </author> <title> Automatic generation of state invariants from requirements specifications. </title> <booktitle> In Proceedings of the ACM SIGSOFT '98 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 56-69, </pages> <address> Orlando, Florida, </address> <month> November 3-5, </month> <year> 1998. </year>
Reference: [JvH + 98] <author> Bart Jacobs, Joachim van den Berg, Marieke Huisman, Martijn van Berkum, Ulrich Hensel, and Hendrik Tews. </author> <title> Reasoning about Java classes. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '98), </booktitle> <address> Van-couver, BC, Canada, </address> <month> October </month> <year> 1998. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [KM76] <author> Shmuel Katz and Zohar Manna. </author> <title> Logical analysis of programs. </title> <journal> Communications of the ACM, </journal> <volume> 19(4) </volume> <pages> 188-206, </pages> <month> April </month> <year> 1976. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, ?, BBM97] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, ?, XP98], the desired property is obvious.
Reference: [KW95] <author> Priyadarshan Kolte and Michael Wolfe. </author> <title> Elimination of redundant array subscript range checks. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 270-278, </pages> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, ?, XP98] </ref>, the desired property is obvious. The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90], while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?].
Reference: [LN98] <author> K. Rustan M. Leino and Greg Nelson. </author> <title> An extended static checker for Modula-3. </title> <booktitle> In Compiler Construction: 7th International Conference, CC'98, </booktitle> <pages> pages 302-305. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1998. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [Mit97] <author> Tom M. Mitchell. </author> <title> Machine Learning. </title> <address> WCB/McGraw-Hill, Boston, MA, </address> <year> 1997. </year>
Reference-contexts: Traditionally, machine learning attempts to learn a function over n1 variables producing the nth or to classify examples into specified categories, neither of which is directly applicable to our problem <ref> [Mit97] </ref>. However, we believe that generalizing these techniques, or applying them to subproblems of our task, can be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging.
Reference: [NCOD97] <author> Gleb Naumovich, Lori A. Clarke, Leon J. Osterweil, and Matthew B. Dwyer. </author> <title> Verification of concurrent software with FLAVERS. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 594-595, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [NL98] <author> George C. Necula and Peter Lee. </author> <title> The design and implementation of a certifying compiler. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 333-344, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference: [OJ97] <author> Robert O'Callahan and Daniel Jackson. Lackwit: </author> <title> A program understanding tool based on type inference. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 338-348, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: More complicated derived variables may be added for complex expressions that appear in the program text; derived variables or invariants may also involve functions defined in the program. Type analysis can indicate which variables are incomparable, even if they have the same type in the programming language <ref> [OJ97] </ref>; our prototype does not use even the types present in the source code to prevent nonsensical comparisons. User Interface A large data set and large number of derived invariants can be overwhelming. We have already developed a tool that retrieves the variable-value tuples that satisfy or falsify an invariant.
Reference: [Pfe92] <author> Frank Pfenning. </author> <title> Dependent types in logic programming. </title> <booktitle> In Types in Logic Programming, chapter 10, </booktitle> <pages> pages 285-311. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of dynamically checking some such properties makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it [Weg74, BLS96]; our goal is the discovery of such properties from a broad class of possible ones.
Reference: [Qui90] <author> J. R. Quinlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5 </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: Our invariant differencing tool can indicate how a program change has affected the computed invariants. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) <ref> [Qui90, Coh94] </ref> to construct Horn clause loop invariants from variable values on particular loop executions [BG93].
Reference: [RBDL97] <author> Thomas Reps, Thomas Ball, Manuvir Das, and James Larus. </author> <title> The use of program profiling for software maintenance with applications to the year 2000 problem. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference and Fifth ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE 97), </booktitle> <pages> pages 432-449, </pages> <address> Zurich, Switzer-land, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: However, we believe that generalizing these techniques, or applying them to subproblems of our task, can be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging. Program spectra (specific aspects of program runs, such as event traces, code coverage, or outputs) <ref> [RBDL97, HRWY98] </ref> can reveal differences in inputs or program versions. Other researchers use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace [?, ?, CW98a, CW98b].
Reference: [RH98] <author> Gregg Rothermel and Mary Jean Harrold. </author> <title> Empirical studies of a safe regression test selection technique. </title> <journal> Transactions on Software Engineering, </journal> <volume> 24(6) </volume> <pages> 401-419, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Given runs of the program over randomly-generated inputs, our techniques discover those same program properties, plus some additional ones (Section 2). The second set of programs | C programs, originally from Siemens [HFGO94], and modified by Rothermel and Harrold <ref> [RH98] </ref> | is not annotated with invariants, nor is there any indication that invariants were used in their construction. Section 4 shows how numeric invariants dynamically inferred from one of these programs assisted in understanding and changing it. <p> To help determine whether and how derived invariants might help a programmer modify a program that contains no explicitly-stated invariants, we used invariants produced by our engine in evolving a program from the Siemens suite <ref> [HFGO94, RH98] </ref>. After describing the scenario we went through in modifying this program, we discuss some of the factors that make the use of invariants qualitatively different from some more traditional styles of gathering information about programs.
Reference: [SI77] <author> Norihisa Suzuki and Kiyoshi Ishihata. </author> <title> Implementation of an array bound checker. </title> <booktitle> In Proceedings of the Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 132-143, </pages> <address> Los Angeles, CA, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, ?, XP98] </ref>, the desired property is obvious. The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90], while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?].
Reference: [van97] <author> Guido van Rossum. </author> <title> Python Reference Manual, </title> <note> release 1.5 edition, </note> <month> December </month> <year> 1997. </year>
Reference-contexts: Because each instrumented program point is processed independently, program size affects invariant detection time only insofar as larger programs afford more instrumentation points. We ran our experiments on a 450MHz Pentium II. Our prototype invariant engine is implemented in the interpreted language Python <ref> [van97] </ref>. The engine has not yet been seriously optimized for time or space, although at one point we improved performance by nearly a factor of ten by inlining two one-line procedures.
Reference: [War96] <author> Martin P. Ward. </author> <title> Program analysis by formal transformation. </title> <journal> The Computer Journal, </journal> <volume> 39(7) </volume> <pages> 598-618, </pages> <year> 1996. </year>
Reference: [Weg74] <author> Ben Wegbreit. </author> <title> The synthesis of loop predicates. </title> <journal> Communications of the ACM, </journal> <volume> 17(2) </volume> <pages> 102-112, </pages> <month> February </month> <year> 1974. </year>
Reference-contexts: Considerable research has addressed checking formal specifications [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92]; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than checking it <ref> [Weg74, BLS96] </ref>; our goal is the discovery of such properties from a broad class of possible ones. Variable types are a variety of formal specification and documentation. <p> Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, ?, BBM97] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, ?, XP98], the desired property is obvious.
Reference: [XP98] <author> Hongwei Xi and Frank Pfenning. </author> <title> Eliminating array bound checking through dependent types. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-257, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, ?, BBM97]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, ?, XP98] </ref>, the desired property is obvious. The Illustrating Compiler heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90], while ReForm semi-automatically transforms, by provably correct steps, a program into a specification [?].
References-found: 44

