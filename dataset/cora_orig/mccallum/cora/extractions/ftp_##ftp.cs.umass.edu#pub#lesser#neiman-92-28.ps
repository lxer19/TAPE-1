URL: ftp://ftp.cs.umass.edu/pub/lesser/neiman-92-28.ps
Refering-URL: http://dis.cs.umass.edu/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [ Forgy, 1979 ] <author> C. L. Forgy. </author> <title> On the Efficient Implementation of Production Systems. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1979. </year>
Reference-contexts: When the system supports action or production parallelism, this assumption is no longer true; multiple tokens might arrive at a two-input node at any time, and at either input <ref> [ Forgy, 1979 ] </ref> . It is inevitable that eventually a token will arrive at either the left or right input while a matching token is still being processed on the opposite side. This can cause serious synchronization problems.
Reference: [ Forgy, 1981 ] <author> C. L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> CMU Computer Science Department, </institution> <month> July </month> <year> 1981. </year>
Reference-contexts: Forgy and the syntax of UMPOPS is in many respects identical to that described in the OPS5 Technical Report <ref> [ Forgy, 1981 ] </ref> . There are, however, a number of exceptions and extensions to the language, both to provide parallel operators and to increase the general expressiveness of the language. <p> The section on invocation can be skipped by the casual reader. Information on the language which is not specific to parallel OPS5 can be obtained from the OPS5 User's Manual <ref> [ Forgy, 1981 ] </ref> . 2.1 Invocation: The system is contained in the file POPSHASH.lisp; the compiled version is in the file POPSHASH.zoom 2 . The file should be loaded into a TopCL image.
Reference: [ Gordin and Pasik, 1991 ] <author> Douglas N. Gordin and Alexander J. Pasik. </author> <title> Set-oriented constructs: From rete rule bases to database systems. </title> <booktitle> In Proceedings 10th ACM Symposium on PODS, </booktitle> <pages> pages 60-67, </pages> <year> 1991. </year>
Reference: [ Gupta et al., 1988 ] <author> A. Gupta, M. Tambe, D. Kalp, C. Forgy, and A. Newell. </author> <title> Parallel implementation of OPS5 on the encore multiprocessor: Results and analysis. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 17(2), </volume> <year> 1988. </year>
Reference: [ Gupta, 1987 ] <author> Anoop Gupta. </author> <title> Parallelism in Production Systems. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: Introduction and Language Overview OPS5 is a well-known language for implementing rule-based systems. Rule-based languages have been widely used for implementing expert systems, however the performance of such systems has usually left something to be desired. It has been suggested <ref> [ Gupta, 1987, Ishida and Stolfo, 1985 ] </ref> that the performance limitations of rule-based systems could be overcome by the appropriate use of parallelism. This approach has become increasingly practical with the advent of symmetric multiprocessors and concurrent programming languages. <p> This matching process is considered to be the most time-consuming aspect of executing a production system and a considerable amount of research has been done to determine if match time can be significantly reduced by performing the match process in parallel <ref> [ Gupta, 1987 ] </ref> . In OPS5, the matching process takes place when working memory elements are added to, or deleted from, memory. This means that the match process actually takes place at the same time as the righthand execution phase. <p> Match-Level Parallelism: Match-level parallelism does not normally yield great speedups because of the small granularity of the match operations, the relatively high overhead of invoking parallel operations 27 at that level of granularity, and the small number of rules affected by the average working memory change <ref> [ Gupta, 1987 ] </ref> . There are, however, certain cases in which a significant improvement can be achieved. The most common of these is the mode-changing production. <p> Many of the details of the implementation were inspired by Gupta's study of the issues involved in parallelizing the Rete net <ref> [ Gupta, 1987 ] </ref> .
Reference: [ Hayes-Roth, 1985 ] <author> Barbara Hayes-Roth. </author> <title> A blackboard architecture for control. </title> <journal> Artificial Intelligence, </journal> <volume> 26 </volume> <pages> 251-321, </pages> <year> 1985. </year>
Reference-contexts: For example, special control meta-rules can be devised which, when they perceive a particular state occuring in the system, can execute, modifying the priority as was done in the BB1 blackboard architecture <ref> [ Hayes-Roth, 1985 ] </ref> . Such control rules should, of course, be given the highest execution priorites. Even so, it is likely that queue and execution latencies would render such control rules less responsive to the state of the system than is desirable.
Reference: [ Ishida and Stolfo, 1985 ] <author> T. Ishida and S. Stolfo. </author> <title> Towards the parallel execution of rules in production system programs. </title> <booktitle> In Proceedings of the IEEE International Conference on Parallel Processing, </booktitle> <pages> pages 568-575, </pages> <year> 1985. </year>
Reference-contexts: Introduction and Language Overview OPS5 is a well-known language for implementing rule-based systems. Rule-based languages have been widely used for implementing expert systems, however the performance of such systems has usually left something to be desired. It has been suggested <ref> [ Gupta, 1987, Ishida and Stolfo, 1985 ] </ref> that the performance limitations of rule-based systems could be overcome by the appropriate use of parallelism. This approach has become increasingly practical with the advent of symmetric multiprocessors and concurrent programming languages. <p> Instead, clashing rules may create multiple derivations of working memory elements leading to spurious or redundant rule firings and subsequent explosive growth of working memory size. A number of techniques have been developed for detecting rule interactions <ref> [ Ishida and Stolfo, 1985, Ishida, 1990, Schmolze, 1989 ] </ref> . These algorithms usually consist of a static analysis phase which is performed at compile time and a runtime component which dynamically examines all eligible rules and selects a co-executable set. <p> parallel production systems. 3.2 Restrictions on Parallel Rule Firings When rules are executed concurrently, the potential exists for interactions between the rules which can potentially leave working memory in an inconsistent state, or which can produce results which could not be achieved by any serial execution order of the productions <ref> [ Ishida and Stolfo, 1985, Schmolze, 1989, Schmolze, 1991 ] </ref> . UMPOPS provides mechanisms for detecting and preventing interactions due to positive interactions, however, this is only sufficiently powerful to allow correct programs to be written, it does not guarantee correctness.
Reference: [ Ishida, 1990 ] <author> Toru Ishida. </author> <title> Methods and effectiveness of parallel rule firing. </title> <booktitle> In 6th IEEE Conference on Artificial Intelligence Applications, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: Instead, clashing rules may create multiple derivations of working memory elements leading to spurious or redundant rule firings and subsequent explosive growth of working memory size. A number of techniques have been developed for detecting rule interactions <ref> [ Ishida and Stolfo, 1985, Ishida, 1990, Schmolze, 1989 ] </ref> . These algorithms usually consist of a static analysis phase which is performed at compile time and a runtime component which dynamically examines all eligible rules and selects a co-executable set.
Reference: [ Kalp et al., 1988 ] <author> Dirk Kalp, Milind Tambe, Anoop Gupta, Charles Forgy, Allen Newell, Anurag Acharya, Brian Milnes, and Kathy Swedlow. </author> <title> Parallel OPS5 user's manual. </title> <type> Technical Report CMU-CS-88-187, </type> <institution> CMU Computer Science Department, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: The rule demon system also makes it easier to instrument and measure the behavior of the scheduling queues. The queue-based server architecture was inspired in part by the method in which match-level parallelism is implemented in CParaOPS5 <ref> [ Kalp et al., 1988 ] </ref> . Rule Demons Although the queue servers are called "rule demons", this is actually a misnomer as they are actually responsible for filling requests for action and match-level parallel activities as well.
Reference: [ Kumar et al., 1988 ] <author> Vipin Kumar, K. Ramesh, and V. Nageshwara Rao. </author> <title> Parallel best-first search of state-space graphs: A summary of results. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 122-127, </pages> <year> 1988. </year>
Reference-contexts: Executing rules asynchronously just means that a certain amount of this work takes place before the solution is found. An analysis of the parallel nature of the travelling salesperson problem can be found in <ref> [ Kumar et al., 1988 ] </ref> .
Reference: [ Kuo et al., 1991 ] <author> Chin-Ming Kuo, Daniel Miranker, and James C. Browne. </author> <title> On the performance of the CREL system. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 424-441, </pages> <month> December </month> <year> 1991. </year> <month> 67 </month>
Reference-contexts: Rules executing in different tasks can fire asynchronously; however they are not guaranteed to access discrete resources, so locking of working memory elements accessed within tasks is necessary. This possible interaction between tasks distinguishes UMPOPS's tasks from Miranker and Kuo's notion of a set of independent clusters firing asynchronously <ref> [ Miranker et al., 1989, Kuo et al., 1991 ] </ref> . A task is a control mechanism which defines the context in which a computation's conflict resolution routines (if any) and rule-firing policy are defined and in which a local quiescence may be determined.
Reference: [ Miranker et al., 1989 ] <author> Daniel Miranker, Chin-Ming Kuo, and James C. Browne. </author> <title> Paralleliz--ing transformations for a concurrent rule execution language. </title> <type> Technical Report TR-89-30, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Rules executing in different tasks can fire asynchronously; however they are not guaranteed to access discrete resources, so locking of working memory elements accessed within tasks is necessary. This possible interaction between tasks distinguishes UMPOPS's tasks from Miranker and Kuo's notion of a set of independent clusters firing asynchronously <ref> [ Miranker et al., 1989, Kuo et al., 1991 ] </ref> . A task is a control mechanism which defines the context in which a computation's conflict resolution routines (if any) and rule-firing policy are defined and in which a local quiescence may be determined.
Reference: [ Neiman, 1991 ] <author> Daniel Neiman. </author> <title> Control issues in parallel rule-firing production systems. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence, </booktitle> <pages> pages 310-316, </pages> <year> 1991. </year>
Reference-contexts: The burden falls upon the programmer to ensure the correctness of the program. When executing rules asynchronously, the locking scheme accepts and schedules rules in the order in which they arrive, thus opportunities for heuristic control are not available. As reported elsewhere <ref> [ Neiman, 1991 ] </ref> , this is compensated for by the increased throughput provided by the asynchronous rule execution policy. A final disadvantage is that the current algorithm requires a central scheduler and lock acquisition takes place serially, thus keeping lock overhead to a minimum is critical.
Reference: [ Neiman, 1992 ] <author> Daniel E. Neiman. </author> <title> A multiple worlds implementation for parallel rule-firing production systems. </title> <note> In preparation, </note> <month> January </month> <year> 1992. </year>
Reference-contexts: An experimental version of UMPOPS has been developed with a partitioned Rete net and operators for performing parallel search in multiple worlds. This multiple worlds implementation is described more fully in <ref> [ Neiman, 1992 ] </ref> . 16 suitable for parallel search can be transparently achieved. <p> Merging Solutions The Travelling Salesperson problem was developed primarily to illustrate two points about parallel rule-firing; the elimination of the need for rule interference detection by partitioning the problem into independent states (this idea is developed further in <ref> [ Neiman, 1992 ] </ref> ) and the idiom for merging results from parallel search processes. Eventually, each parallel search path which has not been pruned terminates and posts a possible solution.
Reference: [ Pearl, 1984 ] <author> Judea Pearl. </author> <title> Heuristics: Intelligent Search Strategies for Computer Problem Solving. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: There are a number of well-known admissable heuristics for ordering the traversal of the search space in TSP; the one chosen for this example is the minimum spanning tree <ref> [ Pearl, 1984 ] </ref> . Rules are placed in the execution priority queue according to the value returned by the MST heuristic.
Reference: [ Schmolze and Neiman, 1992 ] <author> James G. Schmolze and Daniel E. Neiman. </author> <title> Comparison of three algorithms for ensuring serializability in parallel production systems. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence (AAAI-92), </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: As each rule instan-tiation enters the conflict set, each working memory element that appears on the lefthand 1 The overhead due to analysis of rule interactions has been estimated to limit effective speedup due to rule parallelism to between 5 and 10 <ref> [ Schmolze and Neiman, 1992 ] </ref> . 9 be a working memory state which could not be produced by any sequential rule firing. 10 side and which is modified in the righthand side is placed on that instantiation's write list. <p> An experimental version of UMPOPS has been developed which guarantees full serializability, but with an associated performance penalty; details of this implementation can be found in <ref> [ Schmolze and Neiman, 1992 ] </ref> . <p> Low Overhead: The overhead of the UMPOPS locking scheme is limited to the generation of the read and write lists and the actual acquisition of the locks, both of which incur minimal costs, approximately 1-2% of rule execution times as opposed to approximately 10% for full guaranteeing of serializability (see <ref> [ Schmolze and Neiman, 1992 ] </ref> for the argument behind this assertion). Because locks are acquired independently of other executing instantiations, the lock acquisition time is O (N) where N is the number of elements referenced by the instantiation.
Reference: [ Schmolze, 1989 ] <author> James G. Schmolze. </author> <title> Guaranteeing serializable results in synchronous parallel production systems. </title> <type> Technical Report 89-5, </type> <institution> Department of Computer Science, Tufts University, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Instead, clashing rules may create multiple derivations of working memory elements leading to spurious or redundant rule firings and subsequent explosive growth of working memory size. A number of techniques have been developed for detecting rule interactions <ref> [ Ishida and Stolfo, 1985, Ishida, 1990, Schmolze, 1989 ] </ref> . These algorithms usually consist of a static analysis phase which is performed at compile time and a runtime component which dynamically examines all eligible rules and selects a co-executable set. <p> parallel production systems. 3.2 Restrictions on Parallel Rule Firings When rules are executed concurrently, the potential exists for interactions between the rules which can potentially leave working memory in an inconsistent state, or which can produce results which could not be achieved by any serial execution order of the productions <ref> [ Ishida and Stolfo, 1985, Schmolze, 1989, Schmolze, 1991 ] </ref> . UMPOPS provides mechanisms for detecting and preventing interactions due to positive interactions, however, this is only sufficiently powerful to allow correct programs to be written, it does not guarantee correctness.
Reference: [ Schmolze, 1991 ] <author> James G. Schmolze. </author> <title> Guaranteeing serializable results in synchronous parallel production systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4), </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: Because locks are acquired independently of other executing instantiations, the lock acquisition time is O (N) where N is the number of elements referenced by the instantiation. In contrast, the overhead associated with the scheme proposed by Schmolze <ref> [ Schmolze, 1991 ] </ref> is at best O (N 2 ) where N is the number of instantiations in the conflict set. <p> parallel production systems. 3.2 Restrictions on Parallel Rule Firings When rules are executed concurrently, the potential exists for interactions between the rules which can potentially leave working memory in an inconsistent state, or which can produce results which could not be achieved by any serial execution order of the productions <ref> [ Ishida and Stolfo, 1985, Schmolze, 1989, Schmolze, 1991 ] </ref> . UMPOPS provides mechanisms for detecting and preventing interactions due to positive interactions, however, this is only sufficiently powerful to allow correct programs to be written, it does not guarantee correctness.
Reference: [ Sellis et al., 1987 ] <author> Timos Sellis, Chih-Chen Lin, and Louiqa Raschid. </author> <title> Implementing large production systems in a dbms environment: Concepts and algorithms. </title> <type> Technical Report CS-TR-1960, </type> <institution> Dept. of Computer Science, University of Maryland at College Park, </institution> <year> 1987. </year>
Reference-contexts: The concept of locking elements to prevent interactions due to concurrent modifications is widely used in database systems and a similar scheme to the one just described was implemented in a DBMS-based production system by Sellis,et al. <ref> [ Sellis et al., 1987 ] </ref> . This implementation uses region locks to prevent interactions due to negative conditions.
Reference: [ Stolfo et al., 1990 ] <author> Salvatore J. Stolfo, Leland Woodbury, Jason Glazier, and Philip Chan. </author> <title> The ALEXSYS mortage pool allocation expert system: A case study of speeding up rule-based programs. </title> <booktitle> In AI and Business Workshop, AAAI-90, </booktitle> <year> 1990. </year>
Reference-contexts: is likely that the programmer will occasionally wish to perform synchronous conflict resolution within the context of certain tasks or groups of rules, while allowing other activities to take place asynchronously. (An example of an application which requires such a rule-firing architecture is the Alexsys system developed at Columbia University <ref> [ Stolfo et al., 1990, Stolfo et al., 1991 ] </ref> ; a discussion of experiments with this system will appear in future reports.) A task-based rule-firing architecture is required when the computation can be divided into multiple asynchronous tasks, each of which: * Has a specific preferred order in which operators
Reference: [ Stolfo et al., 1991 ] <author> Salvatore J. Stolfo, Ouri Wolfson, Philip K. Chan, Hasanat M. Dewan, Leland Woodbury, Jason S. Glazier, and David A Ohsie. PARULEL: </author> <title> Parallel rule processing using meta-rules for redaction. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 366-382, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: is likely that the programmer will occasionally wish to perform synchronous conflict resolution within the context of certain tasks or groups of rules, while allowing other activities to take place asynchronously. (An example of an application which requires such a rule-firing architecture is the Alexsys system developed at Columbia University <ref> [ Stolfo et al., 1990, Stolfo et al., 1991 ] </ref> ; a discussion of experiments with this system will appear in future reports.) A task-based rule-firing architecture is required when the computation can be divided into multiple asynchronous tasks, each of which: * Has a specific preferred order in which operators
Reference: [ Widom and Finkelstein, 1990 ] <author> J. Widom and S.J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In ACM-SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 259-270, </pages> <year> 1990. </year> <month> 68 </month>
References-found: 22

