URL: http://www-csag.cs.uiuc.edu/projects/concert/icc/icc-paper.ps
Refering-URL: http://www-csag.cs.uiuc.edu/projects/concert/icc-plusplus.html
Root-URL: http://www.cs.uiuc.edu
Title: ICC++ A C++ Dialect for High Performance Parallel Computing  
Author: A. A. Chien, U. S. Reddy, J. Plevyak, and J. Dolby 
Keyword: concurrent object-oriented programming, concurrent languages, parallelism, object-parallel programming  
Date: July 5, 1995  
Address: 1304 W. Springfield Avenue Urbana, IL 61801  
Affiliation: Department of Computer Science  
Abstract: ICC++ is a new C++ concurrent dialect which allows sequential/parallel program versions to be maintained with single source, the construction of concurrent data abstractions, convenient expression of irregular and fine-grained concurrency, and supports high performance implementations. ICC++ provides annotations for potential concurrency, facilitating both sharing source with sequential programs and grain size tuning for efficient execution. ICC++ has a notion of object consistency which can be extended structurally and procedurally to implement larger data abstractions. Finally, ICC++ integrates arrays into the object system and hence the concurrency model. In short, ICC++ addresses concurrency and its relation to abstractions whether they are implemented by single objects, several objects, or object collections. The design of the language, its rationale, and current status are all described. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 33(9) </volume> <pages> 125-41, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages [47, 14, 3, 36, 30, 4], we focus on Actor-based languages <ref> [1] </ref> because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation. However, the actor model provides no clear basis for building data abstractions from collections of objects, and the actor model provides no concurrency guarantees.
Reference: [2] <author> Pierre America. POOL-T: </author> <title> A parallel object-oriented language. </title> <editor> In Aki Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 199-220. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting.
Reference: [3] <author> Pierre America. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proceedings of ECOOP/OOPSLA '90, </booktitle> <pages> pages 161-8, </pages> <year> 1990. </year>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: [4] <author> Birger Andersen. </author> <title> A genereal, grain-size adaptable, object-oriented programming language for distributed computers. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Copenhagen, Copenhagen, Denmark, </institution> <month> June </month> <year> 1992. </year> <type> Ph.D. thesis (partial). </type>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: [5] <author> Henri E. Bal. </author> <title> The Shared Data-Object Model as a Paradigm for Programming Distributed Systems. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit Te Amsterdam, </institution> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting.
Reference: [6] <author> Adam Beguelin, Erik Seligman, and Micheal Starkey. Dome: </author> <title> Distributed object migration environment. </title> <type> Technical Report CMU-CS-94-153, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects. Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks <ref> [6, 27] </ref>. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences [27]. Encapsulating of concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions.
Reference: [7] <author> B. Bershad, E. Lazowska, and H. Levy. </author> <title> Presto: A system for object-oriented parallel programming. </title> <journal> Software Practice and Experience, </journal> <volume> 18(8), </volume> <year> 1988. </year>
Reference-contexts: The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [7, 10, 44, 28] </ref>. These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects.
Reference: [8] <author> B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Presto: A system for object-oriented parallel programming. </title> <journal> Software | Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [10, 28, 11, 44, 8] </ref>. Concurrency guarantees define what member calls will run concurrently allowing programmers to reason about progress and deadlock. 3.1.1 Object Consistency In ICC++, concurrent method invocations on an object are constrained such that intermediate object states created within a member function are not visible.
Reference: [9] <author> M. Carson and J. Hermans. </author> <title> Molecular Dynamics and Protein Structure, </title> <booktitle> chapter The Molecular Dynamics Workshop Laboratory, </booktitle> <pages> pages 165-6. </pages> <institution> University of North Carolina, Chapel Hill, </institution> <year> 1985. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [42], and superior speedups and absolute performance on a parallel molecular dynamics application (CEDAR <ref> [9] </ref>) on the the Cray T3D [24] and Thinking Machines CM-5 [46].
Reference: [10] <author> Rohit Chandra, Anoop Gupta, and John L. Hennessy. </author> <title> Data locality and load balancing in COOL. </title> <booktitle> In Proceedings of the Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [10, 28, 11, 44, 8] </ref>. Concurrency guarantees define what member calls will run concurrently allowing programmers to reason about progress and deadlock. 3.1.1 Object Consistency In ICC++, concurrent method invocations on an object are constrained such that intermediate object states created within a member function are not visible. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [7, 10, 44, 28] </ref>. These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects.
Reference: [11] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional parallel programming. </title> <booktitle> In Pr 46 oceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, 1993. 16 </note>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [10, 28, 11, 44, 8] </ref>. Concurrency guarantees define what member calls will run concurrently allowing programmers to reason about progress and deadlock. 3.1.1 Object Consistency In ICC++, concurrent method invocations on an object are constrained such that intermediate object states created within a member function are not visible. <p> Another important distinction amongst parallel C++'s is the scheduling or concurrency guarantees provided by the language. Data parallel languages have sequential semantics, so the data parallel C++'s provide no concurrency guarantees. Of the task parallel C++ dialects, Charm++ provides explicit control over scheduling [28], and Compositional C++ <ref> [11] </ref> provides guaranteed fair thread scheduling for all par constructs. In contrast, ICC++ emphasizes the annotation of potential concurrency, and gives concurrency guarantees in an data-oriented form. This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution.
Reference: [12] <author> S. Chatterjee. </author> <title> Compiling nested data parallel programs for shared memory multiprocessors. </title> <journal> ACM Transactions of Programming Languages and Systems, </journal> <volume> 15(3), </volume> <year> 1993. </year>
Reference-contexts: This combination makes libraries of concurrent abstractions possible, a key technology for concurrent programming. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in <ref> [32, 12] </ref> and the aggregate approach as in [21]. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type.
Reference: [13] <author> A. Chien, V. Karamcheti, J. Plevyak, and D. Sahrawat. </author> <title> The concert system: Compiler and runtime technology for efficient concurrent object-oriented programming. </title> <booktitle> In Proceedings of the Computing in Aerospace 9 Conference, </booktitle> <address> San Diego, California, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches.
Reference: [14] <author> A. A. Chien and W. J. Dally. </author> <title> Concurrent Aggregates (CA). </title> <booktitle> In Proceedings of Second Symposium on Principles and Practice of Parallel Programming. ACM, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ [32, 31] employ collections or aggregates <ref> [14, 20, 43] </ref> to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of concurrency; limiting the domain of applications. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation. <p> Recent work in our group [40, 42, 41] and others [45] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates <ref> [20, 14] </ref>). The Illinois Concert system is a complete development environment for irregular parallel applications [22]. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: [15] <author> A. A. Chien, W. Feng, V. Karamcheti, and J. Plevyak. </author> <title> Techniques for efficient execution of fine-grained concurrent programs. </title> <booktitle> In Proceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <pages> pages 103-13, </pages> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, </note> <year> 1993. </year>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches.
Reference: [16] <author> A. A. Chien, M. Straka, J. Dolby, V. Karamcheti, J. Plevyak, and X. Zhang. </author> <title> A case study in irregular parallel programming. </title> <booktitle> In DIMACS Workshop on Specification of Parallel Algorithms, </booktitle> <month> May </month> <year> 1994. </year> <note> Also available as Springer-Verlag LNCS. </note>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [18, 25]. We researched the design of concurrent object oriented programs <ref> [39, 16, 20, 19] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [42, 40, 13, 23, 29, 17, 15], exploring a variety of aggressive compiler and runtime techniques. <p> All forces imparted by collisions are also calculated. The code for this phase was presented in Section 4.2; recall that parallelism was exposed both across each particle, and across each collision for each particle. It was noted in <ref> [16] </ref> that an auxiliary contact list had to be generated for each particle to vectorize this loop, but ICC++'s more flexible concurrency model makes this otiose. updating particles velocities and positions merely involves updating the velocities of the particles with the forces calculated from the collisions and changing their positions based <p> Thus all phases can be parallelized with ICC++. Contrast this with <ref> [16] </ref>, where part of the particle interaction phase (the contact list generation) was completely sequential in the data-parallel version, limiting the potential speedup. 13 6 Discussion and Related Work 6.1 C++ Compatibility Our intention was to avoid any gratuitous incompatibilities with sequential C++ programs.
Reference: [17] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation 2 based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [17, 22, 40, 42, 41] </ref>. The remainder of the paper is organized as follows. Section 2 describes how programmers express concurrency in ICC++. The relationship of concurrency, object, and data abstractions, a critical issue in object-oriented languages, is described in Section 3. <p> The ability of elements to access the entire collection allows the MultiSet elements to cooperatively implement a concurrent interface to the abstraction: multiple calls to add elt can proceed simultaneously when called upon different elements of the collection, as shown below. MultiSet&lt;int&gt; set <ref> [17] </ref>; int stuff [100]; conc for (int i = 0; i &lt; 100; i++) set [i%17].add_elt (stuff [i]); Note that the use of templates and collections allows the MultiSet to be a reusable abstraction that presents a concurrent interface.
Reference: [18] <author> Andrew Chien and Uday Reddy. </author> <title> ICC++ language definition. Concurrent Systems Architecture Group Memo, </title> <month> February </month> <year> 1995. </year>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in <ref> [18, 25] </ref>. We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines.
Reference: [19] <author> Andrew A. Chien. </author> <title> Application studies for concurrent aggregates. </title> <type> Technical report, </type> <institution> Mas-sachusetts Institute of Technology, Artificial Intelligence Laboratory, </institution> <address> Cambridge, Mas-sachusetts, </address> <year> 1990. </year>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [18, 25]. We researched the design of concurrent object oriented programs <ref> [39, 16, 20, 19] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [42, 40, 13, 23, 29, 17, 15], exploring a variety of aggressive compiler and runtime techniques.
Reference: [20] <author> Andrew A. Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [18, 25]. We researched the design of concurrent object oriented programs <ref> [39, 16, 20, 19] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [42, 40, 13, 23, 29, 17, 15], exploring a variety of aggressive compiler and runtime techniques. <p> The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ [32, 31] employ collections or aggregates <ref> [14, 20, 43] </ref> to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of concurrency; limiting the domain of applications. <p> Recent work in our group [40, 42, 41] and others [45] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates <ref> [20, 14] </ref>). The Illinois Concert system is a complete development environment for irregular parallel applications [22]. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: [21] <author> Andrew A. Chien and William J. Dally. </author> <title> Experience with concurrent aggregates (ca): </title> <booktitle> Implementation and programming. In Proceedings of the Fifth Distributed Memory Computers Conference, </booktitle> <address> Charleston, South Carolina, </address> <month> April 8-12 </month> <year> 1990. </year> <note> SIAM. </note>
Reference-contexts: This combination makes libraries of concurrent abstractions possible, a key technology for concurrent programming. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in [32, 12] and the aggregate approach as in <ref> [21] </ref>. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type.
Reference: [22] <author> Andrew A. Chien and Julian Dolby. </author> <title> The Illinois Concert system: A problem-solving environment for irregular applications. </title> <booktitle> In Proceedings of DAGS'94, The Symposium on Parallel Computation and Problem Solving Environments., </booktitle> <year> 1994. </year>
Reference-contexts: An implementation 2 based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [17, 22, 40, 42, 41] </ref>. The remainder of the paper is organized as follows. Section 2 describes how programmers express concurrency in ICC++. The relationship of concurrency, object, and data abstractions, a critical issue in object-oriented languages, is described in Section 3. <p> The Illinois Concert system is a complete development environment for irregular parallel applications <ref> [22] </ref>. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: [23] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concurrent aggregates language report 2.0. </title> <note> Available via anonymous ftp from cs.uiuc.edu in /pub/csag or from http://www-csag.cs.uiuc.edu/, September 1993. </note>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches.
Reference: [24] <institution> Cray Research, Inc., Eagan, Minnesota 55121. CRAY T3D Software Overview Technical Note, </institution> <year> 1992. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [42], and superior speedups and absolute performance on a parallel molecular dynamics application (CEDAR [9]) on the the Cray T3D <ref> [24] </ref> and Thinking Machines CM-5 [46].
Reference: [25] <author> Julian Dolby. </author> <title> The ICC++ reference manual. </title> <type> Technical report, </type> <institution> University of Illinois, Department of Computer Science, 1304 W. Springfield Avenue, Urbana, Illinois, </institution> <year> 1995. </year> <note> Also available from http://www-csag.cs.uiuc.edu/. 17 </note>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in <ref> [18, 25] </ref>. We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. <p> Jump statements are break, continue, and goto, and the second rule gives them natural semantics, serializing 1 ICC++ also includes primitives which guarantee concurrency for situations were a guarantee is required <ref> [25] </ref>; however, these primitives are expensive as they dictate an implementation to the system, and should be used with care. 3 the conc block around them. A conc block exits after all statements within it have completed. As in C++, nested blocks are treated as statements. <p> They are related to collections in pC++ [32] when used for data parallelism, but each element has access to the entire collection, which allows them to implement more complex composite behavior as well. Finally, Collections allow distributions to be explicitly specified (see <ref> [25] </ref>). 4.1 Defining Object Collections Collections are defined with standard class declarations, with the addition of [ ] to the class name and are declared just as arrays. This declaration creates separate classes for the elements, called type, and for the collection itself, called type [ ]. <p> Elements are inserted into specific elements and looking up an element 5 Other predefined collection members are available <ref> [25] </ref> 11 therefore must look across the entire collection. The ability of elements to access the entire collection allows the MultiSet elements to cooperatively implement a concurrent interface to the abstraction: multiple calls to add elt can proceed simultaneously when called upon different elements of the collection, as shown below. <p> iteration consists of three phases: checking for collisions, updating the particles' positions and finally moving the particles between grid cells. int time_steps; Grid grid [][]; for (int i = 0; i &lt; time_steps; i++) - grid-&gt;check_collisions_all (); grid-&gt;update_all (); grid-&gt;regrid_all (); - 6 This necessitates minor changes to C++ syntax <ref> [25] </ref> 12 The top-level loop is simple and clean because each phase has been encapsulated as one data- parallel operation across the entire collection grid. The three phases proceed as follows. handling collisions applies a test for contact among particles. All forces imparted by collisions are also calculated. <p> In contrast, ICC++ emphasizes the annotation of potential concurrency, and gives concurrency guarantees in an data-oriented form. This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ <ref> [25] </ref>. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages [47, 14, 3, 36, 30, 4], we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: [26] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: Note that this does not ensure global serialization the object whose reference is declared integral could be shared. 3.3 Composing Abstractions Procedurally friend A fundamental aspect of coordinating concurrent activities is the need to perform coordinated updates across several distinct abstractions <ref> [26, 34] </ref>, which involves some form of transactions. friend functions in C++ are considered member functions upon all arguments for which they are friends, and thus friend functions in ICC++ can be used to procedurally compose operations on several objects into a single consistent operation subject to the same object consistency
Reference: [27] <author> A. Grimshaw. </author> <title> Easy-to-use object-oriented parallel processing with Mentat. </title> <journal> IEEE Computer, </journal> <volume> 5(26) </volume> <pages> 39-51, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects. Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks <ref> [6, 27] </ref>. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences [27]. Encapsulating of concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions. <p> Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks [6, 27]. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences <ref> [27] </ref>. Encapsulating of concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions.
Reference: [28] <author> L. V. Kale and Sanjeev Krishnan. CHARM++: </author> <title> A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of OOPSLA'93, </booktitle> <year> 1993. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [10, 28, 11, 44, 8] </ref>. Concurrency guarantees define what member calls will run concurrently allowing programmers to reason about progress and deadlock. 3.1.1 Object Consistency In ICC++, concurrent method invocations on an object are constrained such that intermediate object states created within a member function are not visible. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [7, 10, 44, 28] </ref>. These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects. <p> Another important distinction amongst parallel C++'s is the scheduling or concurrency guarantees provided by the language. Data parallel languages have sequential semantics, so the data parallel C++'s provide no concurrency guarantees. Of the task parallel C++ dialects, Charm++ provides explicit control over scheduling <ref> [28] </ref>, and Compositional C++ [11] provides guaranteed fair thread scheduling for all par constructs. In contrast, ICC++ emphasizes the annotation of potential concurrency, and gives concurrency guarantees in an data-oriented form. This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution.
Reference: [29] <author> Vijay Karamcheti and Andrew Chien. </author> <title> Concert efficient runtime support for concurrent object-oriented programming languages on stock hardware. </title> <booktitle> In Proceedings of Supercomputing'93, </booktitle> <year> 1993. </year>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques [40, 42, 41] and runtime techniques <ref> [42, 29] </ref> to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: [30] <author> H. Konaka. </author> <title> An overview of ocore: A massively parallel object-based language. </title> <type> Technical Report TR-P-93-002, </type> <institution> Tsukuba Research Center, Real World Computing Partnership, Tsukuba Mitsui Building 16F, </institution> <address> 1-6-1 Takezono, Tsukuba-shi, Ibaraki 305, JAPAN, </address> <year> 1993. </year>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: [31] <author> James Larus. </author> <title> C**: a large-grain, object-oriented, </title> <booktitle> data parallel programming language. In Proceedings of the Fifth Workshop for Languages and Compilers for Parallel Machines, </booktitle> <pages> pages 326-341. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ <ref> [32, 31] </ref> employ collections or aggregates [14, 20, 43] to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of concurrency; limiting the domain of applications.
Reference: [32] <author> J. Lee and D. Gannon. </author> <title> Object oriented parallel programming. </title> <booktitle> In Proceedings of the ACM/IEEE Conference on Supercomputing. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: These collection classes support a wide variety of concurrency patterns, from a data-parallel array model to more complex concurrent abstractions. Thus, collections are an important tool for building the concurrent data abstractions we believe are crucial for parallel programming. They are related to collections in pC++ <ref> [32] </ref> when used for data parallelism, but each element has access to the entire collection, which allows them to implement more complex composite behavior as well. <p> This combination makes libraries of concurrent abstractions possible, a key technology for concurrent programming. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in <ref> [32, 12] </ref> and the aggregate approach as in [21]. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type. <p> All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ <ref> [32, 31] </ref> employ collections or aggregates [14, 20, 43] to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of concurrency; limiting the domain of applications.
Reference: [33] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood <ref> [33, 38, 37] </ref>, but the situation for concurrent languages is more complex [1, 47, 14, 20, 2, 5, 11, 28, 27]. Concurrency allows only a partial order on state updates, complicating the notion of consistency.
Reference: [34] <author> Barbara Liskov. </author> <title> Distributed programming in argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-313, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Note that this does not ensure global serialization the object whose reference is declared integral could be shared. 3.3 Composing Abstractions Procedurally friend A fundamental aspect of coordinating concurrent activities is the need to perform coordinated updates across several distinct abstractions <ref> [26, 34] </ref>, which involves some form of transactions. friend functions in C++ are considered member functions upon all arguments for which they are friends, and thus friend functions in ICC++ can be used to procedurally compose operations on several objects into a single consistent operation subject to the same object consistency
Reference: [35] <author> S. Matsuoka and A. Yonezawa. </author> <title> Research Directions in Object-Based Concurrency, chapter "Analysis of Inheritance Anomaly in Object-Oriented Concurrent Languages". </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The problems described by <ref> [35] </ref> involve the sequencing of messages; that is, when certain messages may be handled by a given object. <p> In a sequential object-oriented language, when one tries to dequeue from an empty queue, the dequeue generates an error rather than being delayed until such time as there is something to get, as in the examples in <ref> [35] </ref>. Due to its C++ heritage, ICC++ takes the same approach, and there is no notion of messages being delayed until they can be handled.
Reference: [36] <author> Stephan Murer, Jerome A. Feldman, Chu-Cheow Lim, and Martina-Maria Seidel. pSather: </author> <title> Layered extensions to an object-oriented language for efficient parallel computation. </title> <type> Technical Report TR-93-028, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1993 </year> <month> November </month> <year> 1993. </year>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: [37] <author> N. Wirth and J. Gutknecht. </author> <title> Project Oberon: The Design of an Operating System and Compiler. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood <ref> [33, 38, 37] </ref>, but the situation for concurrent languages is more complex [1, 47, 14, 20, 2, 5, 11, 28, 27]. Concurrency allows only a partial order on state updates, complicating the notion of consistency.
Reference: [38] <author> N. Wirth and M. Reiser. </author> <title> Programming in Oberon Steps beyond Pascal and Modula. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood <ref> [33, 38, 37] </ref>, but the situation for concurrent languages is more complex [1, 47, 14, 20, 2, 5, 11, 28, 27]. Concurrency allows only a partial order on state updates, complicating the notion of consistency.
Reference: [39] <author> T. Ng, X. Zhang, V. Karamcheti, and A. A. Chien. </author> <title> Parallel macromolecular dynamics on the Concert System. </title> <note> In Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: Object collections can be used to build highly concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [18, 25]. We researched the design of concurrent object oriented programs <ref> [39, 16, 20, 19] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [42, 40, 13, 23, 29, 17, 15], exploring a variety of aggressive compiler and runtime techniques.
Reference: [40] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference of object-oriented programs. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <year> 1994. </year> <month> 18 </month>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation 2 based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [17, 22, 40, 42, 41] </ref>. The remainder of the paper is organized as follows. Section 2 describes how programmers express concurrency in ICC++. The relationship of concurrency, object, and data abstractions, a critical issue in object-oriented languages, is described in Section 3. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [40, 42, 41] </ref> and others [45] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [20, 14]). The Illinois Concert system is a complete development environment for irregular parallel applications [22]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [22]. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [40, 42, 41] </ref> and runtime techniques [42, 29] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: [41] <author> John Plevyak, Vijay Karamcheti, Xingbin Zhang, and Andrew Chien. </author> <title> A hybrid execution model for fine-grained languages on distributed memory multicomputers. </title> <note> Submitted for Publication, </note> <year> 1995. </year>
Reference-contexts: An implementation 2 based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [17, 22, 40, 42, 41] </ref>. The remainder of the paper is organized as follows. Section 2 describes how programmers express concurrency in ICC++. The relationship of concurrency, object, and data abstractions, a critical issue in object-oriented languages, is described in Section 3. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [40, 42, 41] </ref> and others [45] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [20, 14]). The Illinois Concert system is a complete development environment for irregular parallel applications [22]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [22]. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [40, 42, 41] </ref> and runtime techniques [42, 29] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: [42] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency in concurrent object-oriented programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 311-321, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: We researched the design of concurrent object oriented programs [39, 16, 20, 19], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [42, 40, 13, 23, 29, 17, 15] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation 2 based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [17, 22, 40, 42, 41] </ref>. The remainder of the paper is organized as follows. Section 2 describes how programmers express concurrency in ICC++. The relationship of concurrency, object, and data abstractions, a critical issue in object-oriented languages, is described in Section 3. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [40, 42, 41] </ref> and others [45] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [20, 14]). The Illinois Concert system is a complete development environment for irregular parallel applications [22]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [22]. The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [40, 42, 41] </ref> and runtime techniques [42, 29] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. <p> The Concert system supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques [40, 42, 41] and runtime techniques <ref> [42, 29] </ref> to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. <p> This system employs novel compiler techniques [40, 42, 41] and runtime techniques [42, 29] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels <ref> [42] </ref>, and superior speedups and absolute performance on a parallel molecular dynamics application (CEDAR [9]) on the the Cray T3D [24] and Thinking Machines CM-5 [46].
Reference: [43] <author> G. Sabot. </author> <title> The Paralation Model. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ [32, 31] employ collections or aggregates <ref> [14, 20, 43] </ref> to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of concurrency; limiting the domain of applications.
Reference: [44] <author> K. Smith and A. Chatterjee. </author> <title> A C++ environment for distributed application execution. </title> <type> Technical Report ACT-ESP-015-91, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [10, 28, 11, 44, 8] </ref>. Concurrency guarantees define what member calls will run concurrently allowing programmers to reason about progress and deadlock. 3.1.1 Object Consistency In ICC++, concurrent method invocations on an object are constrained such that intermediate object states created within a member function are not visible. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [7, 10, 44, 28] </ref>. These languages require the programmer to build concurrency control by convention, providing no language support for object consistency or building abstractions from larger collections of objects.
Reference: [45] <author> K. Taura, S. Matsuoka, and A. Yonezawa. </author> <title> An efficient implementation scheme of concurrent object-oriented languages on stock multicomputers. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on the Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group [40, 42, 41] and others <ref> [45] </ref> demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [20, 14]). The Illinois Concert system is a complete development environment for irregular parallel applications [22].
Reference: [46] <institution> Thinking Machines Corporation, </institution> <address> 245 First Street, Cambridge, MA 02154-1264. </address> <booktitle> The Connection Machine CM-5 Technical Summary, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [42], and superior speedups and absolute performance on a parallel molecular dynamics application (CEDAR [9]) on the the Cray T3D [24] and Thinking Machines CM-5 <ref> [46] </ref>. The ongoing implementation of ICC++ which has just become operational exploits the same aggressive compiler analysis and code optimization, so we expect similar performance in the near future. 7 Summary ICC++ is a new C++ dialect designed to support both efficient sequential and parallel execution.
Reference: [47] <editor> Akinori Yonezawa, editor. </editor> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <note> ISBN 0-262-24029-7. 19 </note>
Reference-contexts: The abstraction model utilizes a set of accessor methods that perform logically atomic operations upon the abstraction's state; each operation must maintain the consistency of that state. Support for abstractions in sequential languages is well understood [33, 38, 37], but the situation for concurrent languages is more complex <ref> [1, 47, 14, 20, 2, 5, 11, 28, 27] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. If necessary, spawn can be used to guarantee concurrency in ICC++ [25]. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [47, 14, 3, 36, 30, 4] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
References-found: 47

