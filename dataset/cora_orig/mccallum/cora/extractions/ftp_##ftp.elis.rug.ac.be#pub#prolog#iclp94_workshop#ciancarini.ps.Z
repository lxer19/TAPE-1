URL: ftp://ftp.elis.rug.ac.be/pub/prolog/iclp94_workshop/ciancarini.ps.Z
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: fcianca,gasparig@cs.unibo.it  
Title: Parallel Symbolic Computing with the Shared Dataspace Coordination Model  
Author: P.Ciancarini and M.Gaspari 
Address: Italy  
Affiliation: University of Bologna  
Abstract: In this paper we demonstrate the expressiveness of Shared Prolog in a number of symbolic programming examples where coordination plays a major role. Then, we show how the language has been extended with new mechanisms for coordination. First we show how multiple tuple space can be used. Then we describe a mechanism based on path expressions to constrain synchronization among parallel agents. Finally, we show how an object-oriented programming style can be supported, based on new coordination mechanisms whose semantics is given in terms of Linear Logic.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha and C. Callsen. ActorSpace: </author> <title> An Open Distributed Programming Paradigm. </title> <booktitle> In Proc. ACM Symp. on Principles and Practice of Parallel Programming (PPOPP), volume 28:7 of ACM SIGPLAN Notices, </booktitle> <pages> pages 23-32, </pages> <address> San Diego, CA, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Coordination rules state how coordinating entities interact: by synchronization primitives, by sending/receiving messages, by associative access to a dataspace, by complex protocols, etc. Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces <ref> [1] </ref>, Linear Objects [6], Swarm [25], Profit [32], ProSet [31], Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts.
Reference: [2] <author> V. Ambriola, P. Ciancarini, and M. Danelutto. </author> <title> Design and distributed implementation of the parallel logic language Shared Prolog. </title> <booktitle> In Proc. ACM Symp. on Principles and Practice of Parallel Programming (PPOPP), volume 25:3 of ACM SIGPLAN Notices, </booktitle> <pages> pages 40-49, </pages> <year> 1990. </year>
Reference-contexts: Shared Prolog was initially proposed in [8], where a comparison with Linda was given. The first sequential interpreter was implemented in NIP (Edimbourgh) Prolog. The first distributed interpreter was implemented in NIP Prolog and C, using BSD Unix sockets for implementing communication over a network <ref> [2] </ref>. The main application of SP was as a specification language for multiuser software development environments able to support the software process [17]. In fact, in 1990 in Pisa the Oikos project started. <p> The run-time support includes a rule sched-uler which evaluates rules and manages the tuple spaces; the workers evaluate Prolog goals for agents, that are distributed and perform their internal derivation (local computation) in parallel. The implementations described in <ref> [2, 9, 4] </ref> are all based on this approach. The target architecture for all these systems is a cluster of workstations. ii. <p> More details are given in [12]. The first SP implementation was based on a main tuple manager process that managed both the tuple space and the evaluations of coordination rules, while Prolog goals were executed by separate worker processes residing in different workstations <ref> [2] </ref>. The number of workers was fixed, reflecting the number of parallel agents allowed in an initial goal. Low level communication was supported by a library of coordination mechanisms written in C under SUN-OS: it was based on a central mailbox and exploited socket communication.
Reference: [3] <author> V. Ambriola, P. Ciancarini, and C. Montangero. </author> <booktitle> Enacting software processes in Oikos. In Proc. ACM SIGSOFT Conf. on Software Development Environments, volume 15:6 of ACM SIGSOFT Software Engineering Notes, </booktitle> <pages> pages 12-23, </pages> <year> 1990. </year>
Reference-contexts: In fact, in 1990 in Pisa the Oikos project started. This was a project funded by the Italian National Council for Research, aiming at designing and building a distributed software development environment <ref> [3] </ref>. An extension of Shared Prolog, called ESP, included multiple tuple spaces and was chosen as the design language for Oikos. A first distributed version of ESP was implemented using BIM Prolog [9]; its run-time system used the same C support developed for the first distributed version of SP.
Reference: [4] <author> V. Ambriola, C. Montangero, T. Flagella, and M. Gaspari. </author> <title> Expo: a framework fo process centered environments. </title> <type> Technical report, </type> <institution> CNR-Progetto Finalizzato Calcolo Parallelo e Sistemi Informatici, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: In 1991 a whole programming environment for ESP, called EXPO, was implemented using a new fully distributed and engineered version of ESP itself and X-Windows <ref> [4] </ref>. In the meantime, P.Ciancarini was at Yale experimenting with Linda and BIM Prolog; he developed the PoliS (polispaces) programming model [15], and implemented an ESP interpreter using Network Linda [18]. The problem of enriching theories with new mechanisms for synchronized coordination was studied introducing PESP [34]. <p> The run-time support includes a rule sched-uler which evaluates rules and manages the tuple spaces; the workers evaluate Prolog goals for agents, that are distributed and perform their internal derivation (local computation) in parallel. The implementations described in <ref> [2, 9, 4] </ref> are all based on this approach. The target architecture for all these systems is a cluster of workstations. ii. <p> Such an implementation was the basis for a the one described in <ref> [4] </ref>; it currently includes a fully fledged programming environment called EXPO that is integrated with X-Window, and an interface the allows to visualize the contents of the tuple spaces.
Reference: [5] <author> J. Andreoli, P. Ciancarini, and R. Pareschi. </author> <title> Interaction Abstract Machines. </title> <editor> In G. Agha, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> Trends in Object-Based Concurrent Computing, </booktitle> <pages> pages 257-280. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: The second part specifies communications, and the third part specifies a transition to a new dataspace configuration. Two forms of concurrency are featured in COOLL: "inter"- and "intra"-object concurrency; these two forms of concurrency have been studied in <ref> [5] </ref>. Inter-object concurrency is similar to independent AND-parallelism in parallel logic languages: each dataspace is independent from other dataspaces. Intra-object concurrency is similar to multiset rewriting in Gamma [7]: each object executes a program consisting of methods that are simultaneously active in the private dataspace. <p> Other models and languages that have some affinity with PoliS and SP are LO, AbstrAct, Gamma, and Swarm. For a discussion on the relationship between LO and SP, see <ref> [5] </ref>. AbstrAct is a logic programming language by Porto and Rosado [37]. In AbstrAct the blackboard coordination model is used: a set of tasks called agenda share a dataspace that is a set of logic terms. Non-monotonic update is supported.
Reference: [6] <author> J.-M. Andreoli and R. Pareschi. </author> <title> Linear Objects: Logical Processes with Built-in Inheritance. New Generation Computing, </title> <address> 9(3-4):445-473, </address> <year> 1991. </year>
Reference-contexts: Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces [1], Linear Objects <ref> [6] </ref>, Swarm [25], Profit [32], ProSet [31], Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts. <p> However, its basic computing model is different because it is based on an abstract notion of active objects inherited form the LO (Linear Objects) language <ref> [6] </ref>. A COOLL program is composed of a set of classes; each class is a collection of methods (rewriting rules) specifying the behaviour of an object.
Reference: [7] <author> J. Banatre and D. LeMetayer. </author> <title> Programming by Multiset Transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Coordination rules state how coordinating entities interact: by synchronization primitives, by sending/receiving messages, by associative access to a dataspace, by complex protocols, etc. Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma <ref> [7] </ref>, Actor Spaces [1], Linear Objects [6], Swarm [25], Profit [32], ProSet [31], Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts. <p> Two forms of concurrency are featured in COOLL: "inter"- and "intra"-object concurrency; these two forms of concurrency have been studied in [5]. Inter-object concurrency is similar to independent AND-parallelism in parallel logic languages: each dataspace is independent from other dataspaces. Intra-object concurrency is similar to multiset rewriting in Gamma <ref> [7] </ref>: each object executes a program consisting of methods that are simultaneously active in the private dataspace. Two forms of communications rule agents coordination: one-to-many (broadcasting), like in LO, and one-to-one (named). Named communication has a Linda "flavour": it is associative and persistent. <p> AbstrAct has not been implemented and it is still in evolution: the main concern of its designers is on semantic "cleanness" of the model, that has to manage both classic logic programming and coordinated concurrency. Gamma is a programming model based on multiset rewriting coordinated by the operator <ref> [7] </ref>. In Gamma, the computation is a succession of non-deterministic applications of rules which consume elements of a multiset while producing new elements. Gamma programs do not have any sequential structure and can be implemented easily on parallel machines.
Reference: [8] <author> A. Brogi and P. Ciancarini. </author> <title> The concurrent language Shared Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 99-123, </pages> <year> 1991. </year>
Reference-contexts: Then we will introduce; a) ESP, that extends SP with multiple tuple spaces; b) PESP, that adds some declarative synchronization constraints on rule activation; and c) COOLL, that adds to multiple tuple spaces new coordination mechanisms useful for object oriented programming. 3 Shared Prolog When it was introduced in <ref> [8] </ref>, Shared Prolog was a language based only partially on the coordination model presented above. In the past years there have been several adjustments both in syntax and semantics. <p> A notable feature of SP is that control flow of test and consume operations is ruled by backtracking. Each test or consume operation either is successful or fails; a failure activates backtracking to the preceding operation. The formal semantics of such a mechanism has been studied in <ref> [8] </ref>. <p> Shared Prolog was initially proposed in <ref> [8] </ref>, where a comparison with Linda was given. The first sequential interpreter was implemented in NIP (Edimbourgh) Prolog. The first distributed interpreter was implemented in NIP Prolog and C, using BSD Unix sockets for implementing communication over a network [2].
Reference: [9] <author> A. Bucci, P. Ciancarini, and C. Montangero. </author> <title> Extended Shared Prolog: A Multiple Tuple Spaces Logic Language. </title> <booktitle> In Proc. 10 th Japanese Logic Programming Conference, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991, </year> <note> (to appear). </note>
Reference-contexts: An extension of Shared Prolog, called ESP, included multiple tuple spaces and was chosen as the design language for Oikos. A first distributed version of ESP was implemented using BIM Prolog <ref> [9] </ref>; its run-time system used the same C support developed for the first distributed version of SP. In 1991 a whole programming environment for ESP, called EXPO, was implemented using a new fully distributed and engineered version of ESP itself and X-Windows [4]. <p> This is the idea at the basis of Extended Shared Prolog. 5.1.1 Extended Shared Prolog An Extended Shared Prolog (ESP) program defines a hierarchical system of nested dataspaces <ref> [9] </ref>. Zero or more agents can be "connected" to each dataspace. An agent can read only the contents of the dataspace to which it is connected, whereas can write tuples everywhere in the dataspace system. <p> The run-time support includes a rule sched-uler which evaluates rules and manages the tuple spaces; the workers evaluate Prolog goals for agents, that are distributed and perform their internal derivation (local computation) in parallel. The implementations described in <ref> [2, 9, 4] </ref> are all based on this approach. The target architecture for all these systems is a cluster of workstations. ii. <p> Low level communication was supported by a library of coordination mechanisms written in C under SUN-OS: it was based on a central mailbox and exploited socket communication. The first ESP implementation (multiple tuple spaces) was described in <ref> [9] </ref>; its structure is depicted in Fig. 2.
Reference: [10] <author> R. Campbell and N. Habermann. </author> <title> The specification of process synchronization by path expressions. </title> <booktitle> In Proc. Int. Symp. on Operating Systems, volume 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: This problem can be avoided introducing a mechanism of coordination to declare mandatory sequences of rule activations: such a declarative mechanism is the path expression <ref> [10] </ref>. The idea is to enrich the interface of a theory with a path expression describing the allowed sequence of synchronizations of coordination rules with respect to the shared dataspace. This is the basis of Path Expression SP (PESP).
Reference: [11] <author> N. Carriero and D. Gelernter. </author> <title> Coordination Languages and Their Significance. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 97-107, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: In fact, various Strand dialect exist: we know at least Strand-C and Strand-FORTRAN. Strand is not the only coordination language. Linda is an explicitly parallel programming language that introduced the concept of shared dataspace as main tool for coordination <ref> [11] </ref>. In order to support coordination, Linda introduces a set of basic operations on the shared dataspace, that is called tuple space. Linda has been coupled to several "host languages", like C, FORTRAN, Lucid, Lisp, Scheme, Eiffel, Pascal, Ada, etc. <p> Finally, in Sect. 7 we will compare Shared Prolog with other rule-based coordination languages. 2 A coordination model with multiple dataspaces A coordination model is a set of abstract primitives for handling processes and communications that can be added to a sequential language to obtain an explicitly parallel programming language <ref> [11] </ref>. However, it is not enough to list a number of primitives: the model should also show how these primitives combine themselves with data and control constructs of the sequential language.
Reference: [12] <author> T. Castagnetti and P. Ciancarini. </author> <title> Static Analysis of a Parallel Logic Language Based on the Blackboard Model. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(12) </volume> <pages> 412-423, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: For a complete solution, see [13]. 6 Implementation Techniques for Logic Languages based on Shared Dataspaces Several implementation strategies are possible for logic languages based on the shared dataspace model. As discussed in <ref> [12] </ref> the implementation strategy depends on the granularity of parallelism that one would like to exploit. Some possible scenarios are: i. <p> Agents perform both the local sequential computation and evaluate coordination rules asking tuples to be tested or consumed to other agents. In the implementation described in <ref> [12] </ref> tuples are produced only locally (similarly to Linda implementations where out is local and read-in are broadcasted). rules program ' $ rules program ' $ ' $ Distributed Tuple Space rules rules rules "! program program "! program "! ? ? ? Rule Scheduler and Tuple Space program rules ' <p> Dataflow Coordination In a fine-grained parallel scenario agents are evaluated in parallel and their rules are evaluated exploiting OR-parallelism with a dataflow strategy. More details are given in <ref> [12] </ref>. The first SP implementation was based on a main tuple manager process that managed both the tuple space and the evaluations of coordination rules, while Prolog goals were executed by separate worker processes residing in different workstations [2]. <p> Meta Tuple Space # # # # # # "! Name server Blackboard Agent Manager Manager Manager Agent Manager Agent Blackboard Manager Blackboard Manager no pre layout quit open bb of PM interface on: historyscript enter clearexpand precond edit holdrefresh expandblackboard For instance, in <ref> [12] </ref> optimization of rule distribution in Shared Prolog was addressed, and a com-piler that could partially evaluate guards and communication flows was described. Such a compiler is targeted at a run-time system where agents execute theories in parallel and the blackboard is distributed among agents using replication techniques. <p> Possible issues for future research on improved implementations are: * to analyze the dataflow implementation model, that is best suited to a massively parallel machine as a target, * to apply the compilation techniques and indexing techniques described in [26] to a framework based on the compilation model described in <ref> [12] </ref>. * to use of Linda for programming the coordination and creation of multiple tuple spaces seems to be a promising direction for improving load balance and integrating multiparadigm tuple spaces [18]. 7 Comparison with other coordination models and lan guages The family of languages we have described in this paper <p> All the languages based on SP have been implemented as languages of the latter class, augmenting Prolog with a number of Linda-like communications mechanisms. However, they also could be considered for fine-grained parallel evaluation, using techniques developed in <ref> [12] </ref>, where a compiler was described for SP whose output is a program optimized for a dataflow-like evaluation. Other models and languages that have some affinity with PoliS and SP are LO, AbstrAct, Gamma, and Swarm. For a discussion on the relationship between LO and SP, see [5].
Reference: [13] <author> S. Castellani and P. Ciancarini. </author> <title> Exploring the Coordination Space with LO. </title> <type> Technical Report UBLCS-6, </type> <institution> Comp. Science Laboratory, Universita di Bologna, Italy, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Such a system is easily modeled and coordinated in COOLL, using one shared dataspace for each table and a new theory for describing what waiters do. For a complete solution, see <ref> [13] </ref>. 6 Implementation Techniques for Logic Languages based on Shared Dataspaces Several implementation strategies are possible for logic languages based on the shared dataspace model. As discussed in [12] the implementation strategy depends on the granularity of parallelism that one would like to exploit. Some possible scenarios are: i.
Reference: [14] <author> S. Castellani, P. Ciancarini, and S. Pompei. </author> <title> Marrying LO with SP. </title> <editor> In F.DeBoesschere, J.Jacquet, and P.Tarau, editors, </editor> <booktitle> Proc. Workshop on Blackboard-based Logic Programming, </booktitle> <pages> pages 21-26, </pages> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: PESP is a variant of SP enriched with path expressions and and used as prototyping ("animation") language for specifications written in the Z specification language. The problem of declarative semantics for logic languages based on shared dataspaces remained unsolved until the introduction of COOLL <ref> [14] </ref>, where an approach based on Linear Logic was used to give a proof-theoretic semantics. COOLL is also interesting because it demonstrates how an object oriented programming style can be easily obtained in a logic coordination language. <p> PESP has been introduced to support distributed animation of specifications written in Z [34]. A forthcoming paper will describe the method with more details. 5.3 Towards object-oriented and logic coordination Similarly to ESP, COOLL (Coordination, Objects, and Linear Logic) is based on multiple tuple spaces <ref> [14] </ref>. However, its basic computing model is different because it is based on an abstract notion of active objects inherited form the LO (Linear Objects) language [6].
Reference: [15] <author> P. Ciancarini. PoliS: </author> <title> a Programming Model for Multiple Tuple Spaces. </title> <editor> In C. Ghezzi and G. Roman, editors, </editor> <booktitle> Proc. 6th IEEE Int. Workshop on Software Specification and Design, </booktitle> <pages> pages 44-51, </pages> <address> Como, Italy, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In 1991 a whole programming environment for ESP, called EXPO, was implemented using a new fully distributed and engineered version of ESP itself and X-Windows [4]. In the meantime, P.Ciancarini was at Yale experimenting with Linda and BIM Prolog; he developed the PoliS (polispaces) programming model <ref> [15] </ref>, and implemented an ESP interpreter using Network Linda [18]. The problem of enriching theories with new mechanisms for synchronized coordination was studied introducing PESP [34].
Reference: [16] <author> P. Ciancarini. </author> <title> Parallel Programming with Logic Languages: a Survey. </title> <journal> Computer Languages, </journal> <volume> 17(4) </volume> <pages> 213-240, </pages> <year> 1992. </year>
Reference-contexts: These languages have been based mostly on one single model of parallel computation, called the stream-based process model: processes execute logic rules that can spawn new processes; they communicate via streams; special constraints on streams rule the synchronization among producer and consumer processes <ref> [16] </ref>. From a pragmatic point of view parallel logic languages have been suggested for symbolic programming on massive parallel architectures, but their diffusion in the world outside academia is limited, possibly with one exception: Strand [24].
Reference: [17] <author> P. Ciancarini. </author> <title> Coordinating Rule-Based Software Processes with ESP. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 203-227, </pages> <year> 1993. </year>
Reference-contexts: The first distributed interpreter was implemented in NIP Prolog and C, using BSD Unix sockets for implementing communication over a network [2]. The main application of SP was as a specification language for multiuser software development environments able to support the software process <ref> [17] </ref>. In fact, in 1990 in Pisa the Oikos project started. This was a project funded by the Italian National Council for Research, aiming at designing and building a distributed software development environment [3].
Reference: [18] <author> P. Ciancarini. </author> <title> Distributed programming with logic tuple spaces. </title> <journal> New Generation Computing, </journal> <volume> 12(3), </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: In the meantime, P.Ciancarini was at Yale experimenting with Linda and BIM Prolog; he developed the PoliS (polispaces) programming model [15], and implemented an ESP interpreter using Network Linda <ref> [18] </ref>. The problem of enriching theories with new mechanisms for synchronized coordination was studied introducing PESP [34]. PESP is a variant of SP enriched with path expressions and and used as prototyping ("animation") language for specifications written in the Z specification language. <p> The rightmost top window shows the history of user actions. The rightmost bottom window shows the name of the blackboard, and three buttons used to manipulate the windows. Another ESP implementation is described in <ref> [18] </ref>, and it is based on Network Linda for coordinating multiple tuple spaces. The run time system is a Linda program that implements a metatuple space that supports communication and tuple space creation. All these implementations are based on interpretation, thus excluding any optimizations obtained by compilation. <p> the compilation techniques and indexing techniques described in [26] to a framework based on the compilation model described in [12]. * to use of Linda for programming the coordination and creation of multiple tuple spaces seems to be a promising direction for improving load balance and integrating multiparadigm tuple spaces <ref> [18] </ref>. 7 Comparison with other coordination models and lan guages The family of languages we have described in this paper combines shared dataspace coordination with logic programming computation.
Reference: [19] <author> K. Clark and S. Gregory. </author> <title> Parlog: Parallel programming in logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <year> 1986. </year>
Reference-contexts: We find this dichotomy also in parallel logic programming. There are now several Prolog compilers that allow a transparent parallel execution; these tools pay attention especially to opportunities for independent AND-parallelism and OR-parallelism. On the opposite side, logic languages like FCP [39] and Parlog <ref> [19] </ref> add explicit mechanisms for synchronization and communication to the logic paradigm.
Reference: [20] <author> A. Davison. </author> <title> Blackboard Systems in Polka. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(5) </volume> <pages> 401-424, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: takes 27.020 seconds on a Sparcstation 1 to find all 2680 solutions. 5 A family of languages based on Shared Prolog The first suggestion concerning the use of shared dataspaces in parallel logic programming can be found in a paper presenting Polka, an extension of Parlog with the blackboard concept <ref> [20] </ref>. Shared Prolog was initially proposed in [8], where a comparison with Linda was given. The first sequential interpreter was implemented in NIP (Edimbourgh) Prolog. The first distributed interpreter was implemented in NIP Prolog and C, using BSD Unix sockets for implementing communication over a network [2].
Reference: [21] <author> K. DeBosschere. </author> <title> Blackboard Communication in Prolog. </title> <editor> In A. Beaumont and G. Gupta, editors, </editor> <title> Parallel Execution of Logic Programs, </title> <booktitle> volume 569 of Lecture Notes in Computer Science, </booktitle> <pages> pages 159-172, </pages> <year> 1991. </year>
Reference-contexts: Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog <ref> [21, 22] </ref> and Prolog-D-Linda [41, 40] are Prolog extensions based on the Linda model. They are both different from SP because they do not impose any constraints on control of the communication primitives in the language: a dataspace operation can appear everywhere in a Prolog program.
Reference: [22] <author> K. DeBosschere and J. Jacquet. </author> <title> Comparative Semantics of Log. </title> <editor> In D. Etiemble and J. Syre, editors, </editor> <booktitle> Proc. Conf. on Parallel Architectures and Languages Europe (PARLE 92), volume 605 of Lecture Notes in Computer Science, </booktitle> <pages> pages 911-926, </pages> <address> Paris, France, </address> <year> 1992. </year>
Reference-contexts: Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog <ref> [21, 22] </ref> and Prolog-D-Linda [41, 40] are Prolog extensions based on the Linda model. They are both different from SP because they do not impose any constraints on control of the communication primitives in the language: a dataspace operation can appear everywhere in a Prolog program.
Reference: [23] <author> I. Foster and R. Overbeek. </author> <title> Bilingual Parallel Programming. </title> <editor> In A. Nicolau, D. Gelernter, T. Gross, and D. Padua, editors, </editor> <booktitle> Advances in Languages and Compilers for Parallel Processing, Research Monographs in Parallel and Distributed Computing, </booktitle> <pages> pages 24-43. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: The main strength of Strand for symbolic computation is the accent put by its designers on coordination: it is offered as a coordination language, i.e., as a language that offers a set of parallel programming mechanisms independent 1 from mechanisms for controlling sequential computation <ref> [23] </ref>. In fact, various Strand dialect exist: we know at least Strand-C and Strand-FORTRAN. Strand is not the only coordination language. Linda is an explicitly parallel programming language that introduced the concept of shared dataspace as main tool for coordination [11].
Reference: [24] <author> I. Foster and S. Taylor. Strand: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: From a pragmatic point of view parallel logic languages have been suggested for symbolic programming on massive parallel architectures, but their diffusion in the world outside academia is limited, possibly with one exception: Strand <ref> [24] </ref>. The main strength of Strand for symbolic computation is the accent put by its designers on coordination: it is offered as a coordination language, i.e., as a language that offers a set of parallel programming mechanisms independent 1 from mechanisms for controlling sequential computation [23]. <p> Parallel logic programming systems may be classified in two different classes: i. Fine-grain parallel logic languages evaluate in parallel atomic goals. These include AND-parallel, OR-parallel and combined AND-OR-parallel languages. Examples in this category are the family of Concurrent Logic Programming languages [39], Andorra [30], and Strand <ref> [24] </ref>. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives.
Reference: [25] <author> R. Gamble, G. Roman, and W. Ball. </author> <title> Formal Derivation of Rule-Based Programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 277-296, </pages> <year> 1993. </year>
Reference-contexts: Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces [1], Linear Objects [6], Swarm <ref> [25] </ref>, Profit [32], ProSet [31], Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts. <p> Gamma can be seen as an intermediate language between specifications and programs. High level specifications, for instance written using first order logic, can be translated into Gamma programs and then compiled into a parallel programs. Another model that is based on a shared dataspace of tuples is Swarm <ref> [25] </ref>. However, in contrast with models which employ multisets the Swarm dataspace is not a multiset. The dataspace is partitioned into the tuple space, a set of ground tuples representing the working memory, and a transaction space, which corresponds to a set of rewriting rules.
Reference: [26] <author> M. Gaspari. </author> <title> A shared dataspace language and its compilation. </title> <type> Technical Report UBLCS-94-5, </type> <institution> Comp. Science Laboratory, Universita di Bologna, Italy, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: No assert/retract predicates can be used in the knowledge base (since agents that execute it are stateless). The goal in the body can be either normal, i.e., only one solution is returned, if any, or an all-solutions generator goal. The formal semantics of a generator goal is described in <ref> [26] </ref>; briefly, a generator goal generates all the terms that solve a given goal exploiting Prolog backtracking and for each solution adds the corresponding term to the tuple space; finally, when failure occurs it adds the failure out-set to the dataspace. <p> The benchmarks are performed on a workstation cluster consisting of 9 Sun Sparcstations 1 on a Ethernet LAN. The implementation we have used is presented in <ref> [26] </ref>. Times are reported in seconds. Workers 2+1 4+1 6+1 8+1 Master-Worker 0.721 0.671 0.608 0.612 Pipeline 215.595 198.226 197.337 199.790 Distributed Backtracking (1 sol) 36.023 34.438 37.706 37.856 As expected, there are large differences among the three solutions we have reported. <p> Such a compiler is targeted at a run-time system where agents execute theories in parallel and the blackboard is distributed among agents using replication techniques. The compiler uses static analysis techniques in order to minimize communications and conflicts among agents. In <ref> [26] </ref> a different compilation approach is described which performs optimization of rule activation using indexing techniques on the tuple space. <p> Possible issues for future research on improved implementations are: * to analyze the dataflow implementation model, that is best suited to a massively parallel machine as a target, * to apply the compilation techniques and indexing techniques described in <ref> [26] </ref> to a framework based on the compilation model described in [12]. * to use of Linda for programming the coordination and creation of multiple tuple spaces seems to be a promising direction for improving load balance and integrating multiparadigm tuple spaces [18]. 7 Comparison with other coordination models and lan
Reference: [27] <author> D. Gelernter. </author> <title> A Note on Systems Programming in Concurrent Prolog. </title> <booktitle> In Proc. Int. Symp. on Logic Programming, </booktitle> <pages> pages 76-82. </pages> <publisher> IEEE Computer Press, </publisher> <year> 1984. </year>
Reference-contexts: There is only one theory and one rule; the different instantiations of variable X allow to build two different player agents both using such a theory. 4.1.5 An anonymous server A set of clients can invoke the services of a set of homogeneous servers (this problem is taken from <ref> [27] </ref>). A client invokes a server issuing the tuple connect (Client). A free server accepts the message and answers to the client with a message connected (Client). Now the client can ask for service, starting a session consisting of message exchanges.
Reference: [28] <author> D. Gelernter. </author> <title> Generative Communication in Linda. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 80-112, </pages> <year> 1985. </year>
Reference-contexts: Access to a tuple is associative, i.e., it is done "by contents". The particular access mechanism chosen is a degree of freedom in our model: we can accommodate either a mechanism based on typed pattern matching, as in Linda <ref> [28] </ref>, or a mechanism based on unification, as in a logic language. Some tuples are active: they denote computations; in Linda an active tuple is created by eval and it can include several independent computations; in our model we only allow one computation per active tuple.
Reference: [29] <author> D. Gelernter. </author> <title> Multiple Tuple Spaces in Linda. </title> <editor> In E. Odijk, M. Rem, and J. Syre, editors, </editor> <booktitle> Proc. Conf. on Parallel Architectures and Languages Europe (PARLE 89), volume 365 of Lecture Notes in Computer Science, </booktitle> <pages> pages 20-27, </pages> <year> 1989. </year>
Reference-contexts: in the tuple space, it must be specified which is the environment assumed for variables in the code that it executes. * Syntax and semantics of operations for multiple tuple spaces (in the original Linda definition only one tuple space is allowed; a natural extension consists of releasing this constraint <ref> [29, 35] </ref>). In short, we can define a coordination model describing three concepts: the coordinating entities, the coordination medium, and the coordinating rules.
Reference: [30] <author> S. Haridi. </author> <title> A Logic Programming Language based on the Andorra Model. New Generation Computing, </title> <address> 7(2-3):109-126, </address> <year> 1990. </year>
Reference-contexts: Parallel logic programming systems may be classified in two different classes: i. Fine-grain parallel logic languages evaluate in parallel atomic goals. These include AND-parallel, OR-parallel and combined AND-OR-parallel languages. Examples in this category are the family of Concurrent Logic Programming languages [39], Andorra <ref> [30] </ref>, and Strand [24]. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives.
Reference: [31] <author> W. Hasselbring. </author> <title> Prototyping Parallel Algorithms with PROSET-Linda. </title> <type> Technical Report TR04/93, </type> <institution> Univ. of Essen, Germany, </institution> <year> 1993. </year>
Reference-contexts: Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces [1], Linear Objects [6], Swarm [25], Profit [32], ProSet <ref> [31] </ref>, Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts.
Reference: [32] <author> G. Kaiser and B. Halpern. </author> <title> An object-based programming model for shared data. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(2) </volume> <pages> 201-264, </pages> <year> 1992. </year>
Reference-contexts: Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces [1], Linear Objects [6], Swarm [25], Profit <ref> [32] </ref>, ProSet [31], Laura [43] are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts.
Reference: [33] <author> E. Kuhn, H. Pohlai, and F. Puntigam. </author> <title> Concurrency and Backtracking in Vienna Parallel Logic. </title> <journal> Computer Languages, </journal> <volume> 19(3) </volume> <pages> 185-203, </pages> <year> 1993. </year>
Reference-contexts: Examples in this category are the family of Concurrent Logic Programming languages [39], Andorra [30], and Strand [24]. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic <ref> [33] </ref>: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog [21, 22] and Prolog-D-Linda [41, 40] are Prolog extensions based on the Linda model.
Reference: [34] <author> M. Loreti. </author> <title> A Method to Animate Specifications written in Z. </title> <type> Master's thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, Italy, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: In the meantime, P.Ciancarini was at Yale experimenting with Linda and BIM Prolog; he developed the PoliS (polispaces) programming model [15], and implemented an ESP interpreter using Network Linda [18]. The problem of enriching theories with new mechanisms for synchronized coordination was studied introducing PESP <ref> [34] </ref>. PESP is a variant of SP enriched with path expressions and and used as prototyping ("animation") language for specifications written in the Z specification language. <p> PESP has been introduced to support distributed animation of specifications written in Z <ref> [34] </ref>. A forthcoming paper will describe the method with more details. 5.3 Towards object-oriented and logic coordination Similarly to ESP, COOLL (Coordination, Objects, and Linear Logic) is based on multiple tuple spaces [14].
Reference: [35] <author> S. Matsuoka and S. Kawai. </author> <title> Using tuple-space communication in distributed object-oriented architectures. </title> <booktitle> In Proc. Conf. OOP SLA, volume 23:11 of ACM SIGPLAN Notices, </booktitle> <pages> pages 276-284, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: in the tuple space, it must be specified which is the environment assumed for variables in the code that it executes. * Syntax and semantics of operations for multiple tuple spaces (in the original Linda definition only one tuple space is allowed; a natural extension consists of releasing this constraint <ref> [29, 35] </ref>). In short, we can define a coordination model describing three concepts: the coordinating entities, the coordination medium, and the coordinating rules.
Reference: [36] <author> L. Pereira and R. Nasr. DeltaProlog: </author> <title> A distributed logic programming language. </title> <booktitle> In Proc. Int. Conf. on Fifth Generation Computer Systems, </booktitle> <pages> pages 283-291, </pages> <year> 1984. </year>
Reference-contexts: These include AND-parallel, OR-parallel and combined AND-OR-parallel languages. Examples in this category are the family of Concurrent Logic Programming languages [39], Andorra [30], and Strand [24]. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog <ref> [36] </ref>, PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives.
Reference: [37] <author> A. Porto and P. Rosado. </author> <title> The AbstrAct Scheme for Concurrent programming. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Proc. 3rd Workshop on Extensions of Logic Programming, volume 660 of Lecture Notes in Computer Science, </booktitle> <pages> pages 216-241. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Other models and languages that have some affinity with PoliS and SP are LO, AbstrAct, Gamma, and Swarm. For a discussion on the relationship between LO and SP, see [5]. AbstrAct is a logic programming language by Porto and Rosado <ref> [37] </ref>. In AbstrAct the blackboard coordination model is used: a set of tasks called agenda share a dataspace that is a set of logic terms. Non-monotonic update is supported.
Reference: [38] <institution> Scientific Computing Associates, Inc., New Haven, CT. </institution> <note> C-Linda Reference Manual, </note> <year> 1990. </year>
Reference-contexts: All Prolog procedures are predicates; on the other side Linda's predicates on the tuple space, i.e., operations rdp and inp, are not supported in every implementation of the language <ref> [38] </ref>. Prolog relies upon backtracking and recursion as main control mechanisms; Linda operations are not backtrackable, i.e., the tuple space is definitely modified after an in or an out.
Reference: [39] <author> E. Shapiro. </author> <title> The Family of Concurrent Logic Languages. </title> <journal> ACM Computer Surveys, </journal> <volume> 21(3) </volume> <pages> 412-510, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: We find this dichotomy also in parallel logic programming. There are now several Prolog compilers that allow a transparent parallel execution; these tools pay attention especially to opportunities for independent AND-parallelism and OR-parallelism. On the opposite side, logic languages like FCP <ref> [39] </ref> and Parlog [19] add explicit mechanisms for synchronization and communication to the logic paradigm. <p> Parallel logic programming systems may be classified in two different classes: i. Fine-grain parallel logic languages evaluate in parallel atomic goals. These include AND-parallel, OR-parallel and combined AND-OR-parallel languages. Examples in this category are the family of Concurrent Logic Programming languages <ref> [39] </ref>, Andorra [30], and Strand [24]. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives.
Reference: [40] <author> G. Sutcliffe. Prolog-D-Linda v2: </author> <title> A New Embedding of Linda in SICStus Prolog. </title> <editor> In F. De-Boesschere, J. Jacquet, and P. Tarau, editors, </editor> <booktitle> Proc. Workshop on Blackboard-based Logic Programming, </booktitle> <pages> pages 105-117, </pages> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog [21, 22] and Prolog-D-Linda <ref> [41, 40] </ref> are Prolog extensions based on the Linda model. They are both different from SP because they do not impose any constraints on control of the communication primitives in the language: a dataspace operation can appear everywhere in a Prolog program.
Reference: [41] <author> G. Sutcliffe and J. Pinakis. Prolog-D-Linda. </author> <type> Technical Report TR91/7, </type> <institution> Dept. of CS, Univ. of Western Australia, Nedlands, Western Australia, </institution> <year> 1992. </year>
Reference-contexts: Examples are Delta-Prolog [36], PMS-Prolog [44], and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog [21, 22] and Prolog-D-Linda <ref> [41, 40] </ref> are Prolog extensions based on the Linda model. They are both different from SP because they do not impose any constraints on control of the communication primitives in the language: a dataspace operation can appear everywhere in a Prolog program.
Reference: [42] <author> E. Tick. </author> <title> Parallel Logic Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: A queen is safe if it is not attacked by another queen. Two queens attach each other if they are on the same row, column, or diagonal. This problem has been largely used as a benchmark to test the efficiency of language implementations, especially in parallel logic programming <ref> [42] </ref>. <p> We compare our results with the results obtained by E. Tick <ref> [42] </ref> running a Prolog algorithm (The "Bruynooghe fused generate-and-test") on a Sequent Symmetry, a shared memory architecture with eight 80386 processors. We report the running time (in seconds) for the 9 queens problem which has 352 solutions .
Reference: [43] <author> R. Tolksdorf. Laura: </author> <title> A Coordination Language for Open Distributed Systems. </title> <type> Technical Report 1992/35, </type> <institution> Technische Universitat Berlin, Fachbereich 20 Informatik, </institution> <year> 1992. </year>
Reference-contexts: Even if the concept of coordination based on shared dataspaces is quite recent, there are several models and languages of this kind: Gamma [7], Actor Spaces [1], Linear Objects [6], Swarm [25], Profit [32], ProSet [31], Laura <ref> [43] </ref> are only a few. We believe that none of these proposals covers the whole space of possible coordination concepts, and surely there is still much room to investigate new concepts.
Reference: [44] <author> M. Wise, D. Jones, and T. Hintz. PMS-Prolog: </author> <title> A Distributed Coarse-Grain-Parallel Prolog with Processes, Modules and Streams. </title> <editor> In P. Kacsuk and M. Wise, editors, </editor> <title> Implementations of Distributed Prolog, </title> <booktitle> Series in Parallel Computing, </booktitle> <pages> pages 379-404. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: Examples in this category are the family of Concurrent Logic Programming languages [39], Andorra [30], and Strand [24]. ii. Coarse grain parallel languages evaluate in parallel multiple sequential programs, with some mechanisms being provided for inter-process communication. Examples are Delta-Prolog [36], PMS-Prolog <ref> [44] </ref>, and Vienna Parallel Logic [33]: these can be considered as languages that extend Prolog with some standard communication primitives. In this class there are also two systems that were inspired by Linda: both Multi-Prolog [21, 22] and Prolog-D-Linda [41, 40] are Prolog extensions based on the Linda model.
References-found: 44

