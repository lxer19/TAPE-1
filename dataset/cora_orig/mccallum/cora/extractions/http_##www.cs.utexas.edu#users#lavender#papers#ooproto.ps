URL: http://www.cs.utexas.edu/users/lavender/papers/ooproto.ps
Refering-URL: http://www.cs.utexas.edu/users/lavender/papers/index.html
Root-URL: 
Email: tomlinson@mcc.com  lavender@mcc.com  kafura@cs.vt.edu  
Phone: 512.338.3765  512.338.3252  703.231.5568  
Title: Implementing Communication Protocols Using Object-Oriented Techniques  
Author: R. GREG LAVENDER DENNIS G. KAFURA 
Address: 3500 W. Balcones Center Dr. Austin, TX 78759-6509  3500 W. Balcones Center Dr. Austin, TX 78759-6509  562 McBryde Hall, Virginia Tech Blacksburg, VA 24061-0106  
Affiliation: MCC  MCC  Department of Computer Science  
Abstract: Appropriate use of object-oriented programming mechanisms in the implementation of communication architectures results in a type structure that reects the architectural model and increases the run-time performance of the protocol machines at each layer. This result is important since it contradicts the assertion by some that layered protocol architectures, such as the ISO Reference Model, necessarily suffer in performance because of layering, thus forcing implementors to violate the layering principle in search of efficiency. The result substantiates the experience of others, notably Clark, that sound network programming methodology leads to efficient implementations that are also understandable. In this paper, elements of an object-oriented implementation of the upper layer OSI protocols are presented. The purpose of the paper is two-fold: first, to communicate to software engineers, particularly those developing systems software, that object-oriented programing techniques facilitate and enhance the implementation of layered architectures; second, to convey to language designers that object-oriented language features are useful in building communication protocols. The focus is on the requirements for the upper layer OSI protocols and how inheritance, subtyping, and polymorphic functions effect their implementation. Paper Category: Experience CHRIS J. TOMLINSON 
Abstract-found: 1
Intro-found: 1
Reference: [Agha 1986] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> M.I.T. Press, </publisher> <year> 1986. </year>
Reference-contexts: The performance improvement results primarily from a simplified control structure induced by the explicit type structure and selective function inlining. Our current research interest is in rapidly developing new OSI-based applications using an extensible concurrent object-oriented language based on the MIT Actor model <ref> [Agha 1986] </ref>, augmented with reection and inheritance. The language, called Rosette [Tomlinson 1991], is based on a virtual machine architecture implemented in C++, which has integrated interprocess communication support using both the Internet protocols and the OSI protocols.
Reference: [Atkins 1988] <author> M. Stella Atkins. </author> <title> Experiments in SR with different upcall program structures, </title> <journal> ACM TOCS, </journal> <volume> 6(4), </volume> <month> November </month> <year> 1988, </year> <pages> pp. 365392. </pages>
Reference-contexts: The upcall methodology requires that the implementation language support higher-order functions; i.e., provide a mechanism for passing functions, or pointers to functions, as arguments to other functions. Atkins reports on experience using upcalls in a concurrent non-object-oriented language <ref> [Atkins 1988] </ref>.
Reference: [Campbell 1987] <author> Roy H. Campbell, Gary M. Johnston and Vincent F. Russo. </author> <title> Choices (Class Hierarchical Open Interface for Custom Embedded Systems), </title> <journal> Operating Systems Review, </journal> <volume> No. 21, </volume> <month> July </month> <year> 1987, </year> <pages> pp. 917. </pages>
Reference-contexts: It is relevant to explore how object-oriented language features can be used in the implementation of a layered protocol architecture. Constructing layered systems using object-oriented techniques is an area of interest to several others as well. Relatively recent work includes Choices <ref> [Campbell 1987] </ref>, the Conduit [Zweig 1990], and OTSO [Koivisto 1991]. Two reasons motivated the implementation of OOSI. First, we desire a rich and exible communications infrastructure on which to build distributed actor-based computations for a new generation of applications.
Reference: [Cardelli 1985] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism, </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985, </year> <pages> pp. 471522. </pages>
Reference-contexts: Subsequent mention of this feature shall be in a context simple enough to comprehend. Polymorphic functions are realized in C++ by a function overloading mechanism that allows multiple function declarations with the same name, but distinct type signatures. Function polymor-phism of this form is classified as ad hoc polymorphism <ref> [Cardelli 1985] </ref>. C++ also supports a constrained form of parametric polymorphism for functions declared within a class. The virtual attribute applied to a function declaration signals to the compiler that a subclass may redefine an inherited function, subject to the inheriting rules just described and signature compatibility rules.
Reference: [CCITT 1989] <institution> Data Communication Networks Open Systems Interconnection (OSI) Model and Notation, Service Definition, </institution> <note> Recommendations X.200-X.219, Blue Book Series, The International Telegraph and Telephone Consultative Committee, Geneva 1989. 17 </note>
Reference-contexts: 1. Introduction An object-oriented approach to developing layered protocol architectures, such as the ISO Reference Model for Open System Interconnection (OSI) <ref> [CCITT 1989] </ref>, has useful implications for object-oriented applications. Layers are commonly interpreted as monolithic protocol machines with horizontally related internal state structures representing the set of layer users. A monolithic approach often dictates intra-layer multiplexing and inter-layer communication based on copying and buffering of data, resulting in adverse performance costs.
Reference: [Clark 1985] <author> David D. Clark. </author> <title> The structuring of systems using upcalls, </title> <booktitle> 10th ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1985, </year> <pages> pp. 171180. </pages>
Reference-contexts: Research on lower layer protocol implementation has led to programming techniques for streamlining control ow within a process. From a methodology perspective, the most important contribution to network programming to date is the idea of structuring protocol implementations in terms of upcalls <ref> [Clark 1985] </ref>. The upcall methodology requires that the implementation language support higher-order functions; i.e., provide a mechanism for passing functions, or pointers to functions, as arguments to other functions. Atkins reports on experience using upcalls in a concurrent non-object-oriented language [Atkins 1988].
Reference: [Clark 1989] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An analysis of TCP processing overhead, </title> <journal> IEEE Communications Magazine, </journal> <month> June </month> <year> 1989, </year> <pages> pp. 2329. </pages>
Reference-contexts: A significant amount of implementation, experimentation, and performance tuning has been done at the transport layer and below with regard to the Internet protocols <ref> [Clark 1989] </ref>. The experiences gained with lower layer implementations in the Internet translate well to both the OSI lower 5. On Berkeley Unix systems the socket interface abstraction is used, while on System V it is the Transport Layer Interface (TLI), perhaps hidden by a socket abstraction. 6.
Reference: [Clark 1990] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols, </title> <booktitle> ACM SIGCOMM90, </booktitle> <pages> pp. </pages> <note> 200208. [Cook 1990]. </note> <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping, </title> <booktitle> Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp. 125135. </pages>
Reference-contexts: It has been shown that architectural choices, and their realization in upper layer implementations, can have a dramatic affect on the ability of the services to meet the type of demands likely to be made by more sophisticated applications <ref> [Clark 1990] </ref>. Research on lower layer protocol implementation has led to programming techniques for streamlining control ow within a process. From a methodology perspective, the most important contribution to network programming to date is the idea of structuring protocol implementations in terms of upcalls [Clark 1985].
Reference: [Davidson 1992] <author> Jack W. Davidson and Anne M. Holler. </author> <title> Subprogram inlining: a study of its effects on program execution time, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(2), </volume> <month> February </month> <year> 1992, </year> <pages> pp. 89102. </pages>
Reference-contexts: A VSAP separates the layer interface from the protocol machine implementation. The merits of function inlining have been extensively debated. In general, selective function inlining can result in an increase in performance in cases where inlining and register allocation do not adversely affect one another <ref> [Davidson 1992] </ref> 7 . In the case of VSAP functions, no local function variables exist (other than parameters), thus interaction with a compilers register allocation algorithm is minimized.
Reference: [Ellis 1990] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: A complete description of the encapsulation relaxation rules is beyond the scope of this paper; the reader is referred to <ref> [Ellis 1990] </ref>. Subsequent mention of this feature shall be in a context simple enough to comprehend. Polymorphic functions are realized in C++ by a function overloading mechanism that allows multiple function declarations with the same name, but distinct type signatures.
Reference: [Hufnagel 1989] <author> Stephen P. Hufnagel and James C. Browne. </author> <title> Performance properties of vertically partitioned object-oriented systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(8), </volume> <month> August </month> <year> 1989, </year> <pages> pp. 935946. </pages>
Reference-contexts: An object-oriented approach based on class inheritance between well-defined types naturally represents the vertical structure. Vertical partitioning has been shown to have a positive inuence on performance in certain contexts <ref> [Hufnagel 1989] </ref>. Applications in which each object is allocated its own thread of control can benefit from this alternative structure since each object can have its own instance of a protocol machine hierarchy.
Reference: [Hutchinson 1989] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Abbott, and Sean OMalley. </author> <title> RPC in the x-kernel: evaluating new design techniques, </title> <booktitle> Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1989, </year> <pages> pp. 91101. </pages>
Reference-contexts: Using inheritance and polymorphism to compose protocol machines such that upcalls and downcalls through the protocol layers translate into subclass and superclass method invocations seems particularly elegant and useful, although it is inherently static. Others have experimented with exi-ble protocol composition mechanisms at the lower layers <ref> [Hutchinson 1989] </ref>, [Tschudin 1991]. The concept of a more exible protocol stack is achievable in OOSI using object-oriented techniques and may be incorporated in a future version. Good quantitative performance comparisons of OOSI and ISODE are not available at this time. Measurements shall be obtained in the near future.
Reference: [Kafura 1989] <author> Dennis G. Kafura and Keung Hae Lee. </author> <title> Inheritance in actor-based concurrent object-oriented languages, </title> <booktitle> ECOOP89 Conference Proceedings, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989, </year> <pages> pp. 131-145. </pages>
Reference-contexts: Various techniques have been proposed in different language contexts. Tomlinson and Singh implemented Enabled Sets in Rosette [Tomlinson 1989], while Kafura and Lee implemented Behavior Abstraction in ACT++ <ref> [Kafura 1989] </ref>. Protocol machines have similar requirements for synchronization control. By incorporating both the downcall and upcall methods in the class interface, rather than separating them, OOSI is in a position to exploit future developments with regard to controlling method access via an object interface.
Reference: [Koivisto 1990] <author> Juha Koivisto and Juhani Malka. </author> <title> OTSO - an object-oriented approach to distributed computation, </title> <booktitle> Usenix C++ Conference Proceedings, </booktitle> <month> April </month> <year> 1991, </year> <pages> pp. 163177. </pages>
Reference: [RFC 1006] <author> Marshall T. Rose and Dwight E. Cass. </author> <title> RFC 1006 ISO Transport Services on top of the TCP, Version 3, Internet Request For Comments, </title> <month> May </month> <year> 1987. </year>
Reference-contexts: The mapping onto TCP/IP is done using a convergence protocol defined in <ref> [RFC 1006] </ref>. In mapping onto TCP/IP, the transport switch implements a lightweight instance of the OSI transport protocol 6 which expects a reliable connection-oriented network service.
Reference: [Rose 1986] <author> Marshall T. Rose. </author> <title> OSI transport services on top of the TCP, </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 12(3), </volume> <year> 1986. </year>
Reference-contexts: In this section, the requirements for the OSI upper layers are presented. applications in Unix workstation environments. FIGURE 2. Unix-Based Multi-Protocol Architecture The transport switch layer depicted in Figure 2 is not part of the standard OSI model. The concept of transport switching in OSI was first introduced by <ref> [Rose 1986] </ref>. The switch addresses, in an elegant manner, the pragmatic issue of simultaneously using many underlying transport services arising from different transport/network protocol combinations. Different protocol combinations are required due to the varying characteristics of different subnetwork technologies.
Reference: [Rose 1989] <author> Marshall T. Rose. </author> <title> The Open Book: A Practical Perspective on OSI, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Svobodova provides a good presentation on the core implementation issues facing the implementors of OSI systems [Svobodova 1989]. Rose gives a detailed treatment of the pragmatics of OSI using the ISODE as a reference implementation <ref> [Rose 1989] </ref>. In the next section, the requirements for implementing the upper layer protocols in support of object-oriented applications are presented. 2.3 Realizing OSI-Based Object-Oriented Systems Current network-oriented systems consist of a mixture of network services provided by various protocol module combinations.
Reference: [Rose 1991] <author> Marshall T. Rose. </author> <title> The ISO Development Environment Users Manual Version 7.0, Volumes 1-5, </title> <booktitle> Performance Systems International, </booktitle> <month> July </month> <year> 1991. </year> <month> 18 </month>
Reference-contexts: This paper describes features of an object-oriented implementation of the OSI upper layers, called OOSI (ooo-zi), which is in the final stages of development. OOSI is implemented in C++ and is the result of an almost complete re-engineering of the core elements of the ISO Development Environment (ISODE) <ref> [Rose 1991] </ref>, a widely used research implementation of the upper layer OSI protocols. It is relevant to explore how object-oriented language features can be used in the implementation of a layered protocol architecture. Constructing layered systems using object-oriented techniques is an area of interest to several others as well.
Reference: [Scherlis 1986] <author> William L. Scherlis. </author> <title> Abstract data types, specialization, and program reuse, </title> <booktitle> in International Workshop on Advanced Programming Environments, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Specifically, the C++ inheritance mechanism permits controlled compile-time relaxation of strict encapsulation and method visibility. It can be argued that controlled relaxation of encapsulation is useful when efficiency requirements are paramount, although doing so imposes limits on the potential for reusability <ref> [Scherlis 1986] </ref>. The C++ programmer exercises relaxation of encapsulation by inheriting private, protected, or public, while also declaring methods and/or instance variables in a class definition consisting of private, protected, and public clauses.
Reference: [Snyder 1986] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages, </title> <booktitle> ACM OOPSLA86 Conference Proceedings, </booktitle> <month> September </month> <year> 1986, </year> <pages> pp. 3845. </pages>
Reference-contexts: In C++, the same inheritance mechanism is used for constructing both types of relations it is the programmers responsibility to separate the two notions in a sensible manner. The reader should also have an appreciation for the arguments made by Snyder concerning degrees of encapsulation with respect to inheritance <ref> [Snyder 1986] </ref>. Specifically, the C++ inheritance mechanism permits controlled compile-time relaxation of strict encapsulation and method visibility. It can be argued that controlled relaxation of encapsulation is useful when efficiency requirements are paramount, although doing so imposes limits on the potential for reusability [Scherlis 1986].
Reference: [Svobodova 1989] <author> Liba Svobodova. </author> <title> Implementing OSI systems, </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(7), </volume> <month> September </month> <year> 1989, </year> <pages> pp. 11151130. </pages>
Reference-contexts: The diagram on the right side of Figure 1 is a more accurate illustration of the peer-to-peer structure. Interaction among layer entities occurs in two forms: direct and indirect. Direct interaction occurs between vertically adjacent layer entities, related only by the exist 3. Adapted in part from <ref> [Svobodova 1989] </ref>. Application Network Presentation Session Transport Data Link Physical Upper Layers Lower Layers (N)-layer (N-1)-layer (N+1)-layer (N)-entity (N)-protocol (N-1)-entity (N-1)-protoco1 (N-1)-SAP (N-1)-SAP (N-1)-entity (N)-entity (N)-service.request (N)-service.indication (N)-PDUs (N-1)-PDUs (N)-SDU 6 ence of a functional dependency for service. <p> Formal implementation agreements, usually at the national level, augment the basic standards by providing implementation guidelines for those areas in the standards which are vague or left to interpretation. Svobodova provides a good presentation on the core implementation issues facing the implementors of OSI systems <ref> [Svobodova 1989] </ref>. Rose gives a detailed treatment of the pragmatics of OSI using the ISODE as a reference implementation [Rose 1989].
Reference: [Tennenhouse 1989] <author> David L. Tennenhouse. </author> <title> Layered multiplexing considered harmful, Protocols for High-Speed Networks, </title> <publisher> North-Holland, </publisher> <year> 1989, </year> <pages> pp. 143148. </pages>
Reference-contexts: ISO Transport Class 0, or TP0. ISO/CCITT Upper Layer Protocols ISO/CCITT Lower Layer Internet Protocols Various Subnetwork Technologies RPC Protocols Protocol Transport Switch Object-Oriented Application Infrastructure 8 layers and upper layers. In particular, protocol engineers know that excessive copying of data severely affects performance, as does layer multiplexing <ref> [Tennenhouse 1989] </ref>. In general, there has been little attention paid to the fine-tuning of upper layer protocol implementations with regard to the impact on concurrent applications which utilize the upper layer services.
Reference: [Tomlinson 1989] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with enabled-sets, </title> <booktitle> ACM OOPSLA89 Conference Proceedings, </booktitle> <month> October </month> <year> 1989, </year> <pages> pp. 103112. </pages>
Reference-contexts: The basic idea is that the set of methods visible in the interface to an object can be computed and controlled based on the internal state of an object. Various techniques have been proposed in different language contexts. Tomlinson and Singh implemented Enabled Sets in Rosette <ref> [Tomlinson 1989] </ref>, while Kafura and Lee implemented Behavior Abstraction in ACT++ [Kafura 1989]. Protocol machines have similar requirements for synchronization control.
Reference: [Tomlinson 1991] <author> Chris Tomlinson, Mark Scheevel, and Vineet Singh. </author> <note> Report on Rosette 1.1, MCC Technical Report ACT-OODS-275-91, </note> <month> July </month> <year> 1991. </year>
Reference-contexts: Our current research interest is in rapidly developing new OSI-based applications using an extensible concurrent object-oriented language based on the MIT Actor model [Agha 1986], augmented with reection and inheritance. The language, called Rosette <ref> [Tomlinson 1991] </ref>, is based on a virtual machine architecture implemented in C++, which has integrated interprocess communication support using both the Internet protocols and the OSI protocols. The OSI interface was originally based on the ISODE, but is being changed to use OOSI.
Reference: [Tschudin 1991] <author> Christian Tschudin. </author> <title> Flexible Protocol Stacks, </title> <booktitle> ACM SIGCOMM91 Conference Proceedings, </booktitle> <month> September </month> <year> 1991, </year> <pages> pp. </pages> <year> 197205. </year>
Reference-contexts: Using inheritance and polymorphism to compose protocol machines such that upcalls and downcalls through the protocol layers translate into subclass and superclass method invocations seems particularly elegant and useful, although it is inherently static. Others have experimented with exi-ble protocol composition mechanisms at the lower layers [Hutchinson 1989], <ref> [Tschudin 1991] </ref>. The concept of a more exible protocol stack is achievable in OOSI using object-oriented techniques and may be incorporated in a future version. Good quantitative performance comparisons of OOSI and ISODE are not available at this time. Measurements shall be obtained in the near future.
Reference: [Zweig 1990] <author> Jonathan M. Zweig and Ralph E. Johnson. </author> <title> The conduit: a communication abstraction in C++, </title> <booktitle> 1990 Usenix C++ Conference Proceedings, </booktitle> <month> April </month> <year> 1990, </year> <pages> pp. </pages> <year> 191203. </year>
Reference-contexts: It is relevant to explore how object-oriented language features can be used in the implementation of a layered protocol architecture. Constructing layered systems using object-oriented techniques is an area of interest to several others as well. Relatively recent work includes Choices [Campbell 1987], the Conduit <ref> [Zweig 1990] </ref>, and OTSO [Koivisto 1991]. Two reasons motivated the implementation of OOSI. First, we desire a rich and exible communications infrastructure on which to build distributed actor-based computations for a new generation of applications.
References-found: 26

