URL: http://www.cs.umr.edu/techreports/91-07.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Email: ff@cs.umr.edu  
Title: COMPARISON OF THREE AXIOMATIC SYSTEMS FOR CSP  
Author: Hanan Lutfiyya and Bruce McMillin 
Note: This work was supported in part by the National Science Foundation under Grant Numbers MIP-8909749 and CDA-8820714, and in part by the AMOCO Faculty Development Program.  
Address: Rolla, Missouri 65401  
Affiliation: Department of Computer Science University of Missouri at Rolla  
Date: June 6, 1991  
Pubnum: CSC-91-7  
Abstract-found: 0
Intro-found: 1
Reference: [ApRo81] <author> Apt, R. and Roever, </author> <title> W ``A Proof System for Communicating Sequential Processes'', </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2, 3, </volume> <year> 1981, </year> <pages> 359-385. </pages>
Reference-contexts: Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], [HaKi57], [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in <ref> [ApRo81] </ref>, [LeGr81], and [Soun84]. These three proof systems are representative of the work done using the axiomatic approach. Similar work has been done in [ChMi88]. <p> The first is the sequential proofs of each individual processes that makes assumptions about the effects of the communication commands. The second part is to ensure that the assumptions are "legitimate". This will be discussed later. This approach is taken in <ref> [Apro81] </ref> and [LeGr81]. The second approach allows us to prove properties of the individual processes using the axioms and rules of inference applicable to the statements in the individual processes. <p> Distributed termination provides the means for automatic termination of a loop in one process because another process has terminated. It is assumed that all termination of loops occurs when all boolean guards are false. <ref> [ApRo81] </ref> and [Soun84] do not make this assumption. <p> This necessitates the need for a Proof of Non-interference. This consists of showing that for each assertion T in process P i , it must be shown that T is invariant over any parallel execution. This is the non-interference property of [Owic75]. 6.2 Communication and Parallel Decomposition rules of <ref> [ApRo81] </ref> This approach is similar to the approach of [LeGr81]. It also allows for sequential proofs of the individual processes of the program and then the proving of properties of the program from the proven properties of the individual properties. <p> It is as follows: ( " / - i: -P i - S i -Q i -) processes cooperate -( " / - i: P i )- [|| i=1:n A i : : S i ]-( " / - i: Q i )- (parallel) In <ref> [ApRo81] </ref> auxiliary variables are used in the same way as in [LeGr81]'s proof system. They are used as a way to record part of the history of the communication sequence. However, auxiliary variables are local. A global invariant is used to relate the auxiliary variables. <p> However, the history of a communication sequence changes after each communication. Auxiliary variables are not updated as the communication command has been executed. Instead, auxiliary variables are changed to reect the new history just before or just after the communication takes place. <ref> [ApRo81] </ref> treats the assignments to the auxiliary variables and the communication command as an atomic section, where the global invariant is not necessary true. This atomic section is frequently referred to as the bracketed section. <p> ?flag 0 -I/ "flag 0 = 0 fi turn 1 = 0 -true-C?(in 0 , turn 0 )-true-and -turn 0 = 0 / " turn 1 = 0 / " I-P 0 !(1, 1)-I A proof Non-interference is easy (but tedious) to show. 7.2 Example using the Axiomatic System of <ref> [ApRo81] </ref> The following represents the CSP program with the addition of auxiliary variables turn 0 , turn 1 , flag 0 , and flag 1 . Also included are the assertions needed to show mutual 30 exclusion. <p> P 1 ?flag 1 fi [flag 1 = 0 fi [busy = false; [flag 0 = 1 fi [busy: = true; P 0 !1] flag 0 = 0 fi skip]]; flag 1 = 1&&busy = false fi busy = true; P 1 !1]] 8. COMPARATIVE ANALYSIS 8.1 Translation from <ref> [ApRo81] </ref> to [LeGr81] In this section, we show that any proof of a CSP program given in any of the proof systems can be translated into a proof of any of the other proof systems, assuming that we ignore the differences in the repetitive rule (remember that the different proof systems <p> be translated into a proof of any of the other proof systems, assuming that we ignore the differences in the repetitive rule (remember that the different proof systems have different ways of handling distributive termination). 33 First, let us examine translating a proof outline of a CSP program in the <ref> [ApRo81] </ref> proof system to that of a proof outline using the [LeGr81] proof system. In both of these proof systems, the correctness proof is divided into two parts. The first part consists of the sequential proofs of each individual process. <p> The second part of the correctness proof is to ensure that the assumptions made about the effects of the communication commands are "legitimate". Both of these systems make use of auxiliary variables to keep a partial history of the communication history between processes. In the <ref> [ApRo81] </ref> proof system the auxiliary variables are local. A global invariant is used to relate the different auxiliary variables. On the other hand, in the [LeGr81] proof system, global auxiliary variables are used. <p> On the other hand, in the [LeGr81] proof system, global auxiliary variables are used. A non-interference proof is used to show that for each assertion T, T is invariant over any parallel execution. The method of translation of a proof outline of a CSP program in the <ref> [ApRo81] </ref> proof system to that of the [LeGr81] proof system is trivially done for the sequential part, by using the same auxiliary variables and assertions. Lemma 8.1: The sequential proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system <p> method of translation of a proof outline of a CSP program in the <ref> [ApRo81] </ref> proof system to that of the [LeGr81] proof system is trivially done for the sequential part, by using the same auxiliary variables and assertions. Lemma 8.1: The sequential proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system of [LeGr81]. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of <p> Lemma 8.1: The sequential proof of an individual component process using the <ref> [ApRo81] </ref> proof system can be translated into a sequential proof using the proof system of [LeGr81]. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 that the effects of the communication command, as <p> The sequential proof of an individual component process using the <ref> [ApRo81] </ref> proof system can be translated into a sequential proof using the proof system of [LeGr81]. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 that the effects of the communication command, as modeled by the logical assertions Q and T, are legitimate. The proof system of [ApRo81] does this <p> Both the <ref> [ApRo81] </ref> and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 that the effects of the communication command, as modeled by the logical assertions Q and T, are legitimate. The proof system of [ApRo81] does this by the use of a cooperation proof, while the proof system of [LeGr81] does this by the use of a satisfaction proof. In the proof system of [ApRo81], the assignments to the auxiliary variables and the communication command is treated as an atomic section, where the global invariant <p> The proof system of <ref> [ApRo81] </ref> does this by the use of a cooperation proof, while the proof system of [LeGr81] does this by the use of a satisfaction proof. In the proof system of [ApRo81], the assignments to the auxiliary variables and the communication command is treated as an atomic section, where the global invariant in not necessarily true. This is referred to as a bracketed section. <p> It should be noted that assertions p and q include the global invariant. The satisfaction rule of [LeGr81] requires that the following is shown: p 2 is Q/ "S. It should be noted Lemma 8.2: The cooperation proof of the <ref> [ApRo81] </ref> proof system implies the satisfaction condition of the [LeGr81] proof system. Proof: In order to show that -p 1 -(P 2 ?x||P 1 !y)-p 2 is true, the communication axiom is used. The communication axiom implies that a communication is an assignment. <p> This is also the satisfaction condition. Hence, since the cooperation proof shows that (P/ "R) fi (Q/ "S) x y is true, then the cooperation proof implies satisfaction. Lemma 8.3: The cooperation proof of the <ref> [ApRo81] </ref> proof system implies the noninterference property of the [LeGr81] proof system. Proof: The proof of non-interference consists of showing that for each assertion T in process P i , that T is invariant over any parallel execution. Assume T I, where I is the global invariant of equation 8.1. <p> Now, the bracketed sections are considered atomic. The cooperation proof showed that I is invariant over a bracketed section. Therefore, non-interference is guaranteed. Theorem 8.1: Any proof of a CSP program given in the proof system of <ref> [ApRo81] </ref> can be translated into a proof using the proof system of [LeGr81]. Proof: From Lemma 8.1, the sequential proofs of each of the individual processes can be shown. Lemma 8.2 shows that the satisfaction condition of [LeGr81] is satisfied by the 36 cooperation proof. <p> Proof: Since both of these proof systems use the same axioms and inference rules for sequential reasoning (with the exception of the communication axioms) and Lemma 8.4. 8.3 Translation from [Soun84] to <ref> [ApRo81] </ref> As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat <p> sequential reasoning (with the exception of the communication axioms) and Lemma 8.4. 8.3 Translation from [Soun84] to <ref> [ApRo81] </ref> As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. <p> Translation from [Soun84] to <ref> [ApRo81] </ref> As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. The assertions used in the proof outline for the [Soun84] proof system remain the same for a proof outline for the [ApRo81] proof system, since the variables h i are local. <p> variables h i of [Soun84] as auxiliary variables in <ref> [ApRo81] </ref> and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. The assertions used in the proof outline for the [Soun84] proof system remain the same for a proof outline for the [ApRo81] proof system, since the variables h i are local. Lemma 8.5: The sequential proof of an individual component process using the [Soun84] proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can <p> the [Soun84] proof system remain the same for a proof outline for the <ref> [ApRo81] </ref> proof system, since the variables h i are local. Lemma 8.5: The sequential proof of an individual component process using the [Soun84] proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables h i s are updated simultaneously with the execution of a communication command. <p> outline for the <ref> [ApRo81] </ref> proof system, since the variables h i are local. Lemma 8.5: The sequential proof of an individual component process using the [Soun84] proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables h i s are updated simultaneously with the execution of a communication command. This can be simulated in the [ApRo81] proof system by updating h <p> since both the [Soun84] and <ref> [ApRo81] </ref> proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables h i s are updated simultaneously with the execution of a communication command. This can be simulated in the [ApRo81] proof system by updating h i in an assignment statement immediately following a communication command. The communication command and the 39 corresponding assignment statement will form a bracketed section. <p> The communication command and the 39 corresponding assignment statement will form a bracketed section. In other words, if P j !y is a communication command in process P i , then the following assignment is included after the communication command in the proof outline for <ref> [ApRo81] </ref>: h i : = h ^ i (i, j, y). This implies that P j !y and h i : = h ^ i (i, j, y) form a bracketed section. The intermediate assertion i.e. the assertion in the bracketed section is the global invariant I. <p> The intermediate assertion i.e. the assertion in the bracketed section is the global invariant I. Lemma 8.6: The translation described above of a proof outline using the [Soun84] proof system to the <ref> [ApRo81] </ref> proof system will ensure cooperation. Proof: It is necessary to show for each matching pair of bracketed sections: P 1 : [ . . . -P- &lt; P 2 ?x; -I-h 1 : = h 1 ^(2, 1, y) &gt; -Q-] cooperates. <p> Theorem 8.3: Any proof of a CSP program given using the proof system of [Soun84] can be translated into a proof using the proof system of <ref> [ApRo81] </ref>. Proof: From Lemma 8.5, the sequential proofs of each of the individual processes can be shown. Lemma 8.6 shows cooperation. The sequential proofs of each individual process and the cooperation proof are by the parallel decomposition rule of [ApRo81] are sufficient as a proof of the system as a whole. <p> can be translated into a proof using the proof system of <ref> [ApRo81] </ref>. Proof: From Lemma 8.5, the sequential proofs of each of the individual processes can be shown. Lemma 8.6 shows cooperation. The sequential proofs of each individual process and the cooperation proof are by the parallel decomposition rule of [ApRo81] are sufficient as a proof of the system as a whole. 40 8.3 8.2 [LeGr81] [Soun84] [ApRo81] Since, we are able to find transformations between these proof systems, we may conclude that these systems allows us to prove the same properties of programs. <p> Lemma 8.6 shows cooperation. The sequential proofs of each individual process and the cooperation proof are by the parallel decomposition rule of <ref> [ApRo81] </ref> are sufficient as a proof of the system as a whole. 40 8.3 8.2 [LeGr81] [Soun84] [ApRo81] Since, we are able to find transformations between these proof systems, we may conclude that these systems allows us to prove the same properties of programs. No system is more powerful then the other. <p> Proofs of the component processes can no longer be done in isolation. Another example, is the use of global vs. local auxiliary variables in the approaches of [LeGr81] and <ref> [ApRo81] </ref> respectively. Local auxiliary variables make a non-interference proof unnecessary, but there appear to be some language features that are most conveniently axiomatized by using global shared variables. For example, [GeRe83] suggest that Ada entry queues be modeled by shared variables. 9.
Reference: [Boeh73] <author> Boehm, B. </author> <title> ``Software and its impact: A quantitative assessment'', </title> <journal> Datama-tion, 1973, </journal> <volume> 19, </volume> <pages> pp. 48-59. </pages>
Reference-contexts: This would imply that to find test data that reliably reveals errors, all conditions relevant to the correct operation of a program must be known and test data must be devised to exercise all possible combinations of these conditions. This is known as exhaustive testing <ref> [Boeh73] </ref>. Not all programs can be exhaustively tested. If the system is deterministic, a trial run on a specific test data case provides a precise, accurate prediction about how the system will behave in that one case.
Reference: [Boeh79] <author> Boehm, B. </author> <title> ``Software Engineering: R & D Trend and Defense Needs'', </title> <booktitle> Research Directions in Software Technology, </booktitle> <year> 1979, </year> <editor> ed. </editor> <address> E Horiwitz. Reading, Mass.: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Software engineering includes, but is broader than, computer programming. It also embraces the analysis, specification, design, validation, documentation and maintenance of computer software systems. This distinction is brought out by Boehm <ref> [Boeh79] </ref> who defines software to mean the computer programs plus all associated documentation required to develop, operate and maintain these programs.
Reference: [ChMi88] <author> Chandy, M. and Misra, J. </author> <title> Parallel program design, 1988, </title> <publisher> Addision-Wesley Pub. Co </publisher>
Reference-contexts: These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84]. These three proof systems are representative of the work done using the axiomatic approach. Similar work has been done in <ref> [ChMi88] </ref>. Specifically, we discuss CSP, the general meaning of an axiomatic system, axioms and inference rules shared by the three systems, the differences in the axioms and inference rules for the communication primitives and an examination of the differences of power in proving properties. 2.
Reference: [Clin73] <author> Clint, M. </author> <title> ``Program proving: </title> <journal> coroutines.''. Acta Informatical, </journal> <volume> 2, </volume> <year> 1973, </year> <pages> pp. 50-63. </pages>
Reference-contexts: This is done with use "dummy" or auxiliary variables that relate program variables of one process to program variables of another. The need for such variables has been independently recognized by many. The first reference that shows the usefulness of auxiliary variables is found in <ref> [Clin73] </ref>. 4. OVERALL PROOF APPROACH As discussed before a CSP program is made up of component sequential processes executing in parallel. In general, to prove properties about the program, first properties of each component process are derived in isolation. <p> Assertions make use of functions defined on the communications sequences. As discussed previously and in <ref> [Clin73] </ref>, auxiliary variables are used to save part of the communications sequence. In other words, auxiliary variables are functions of the communication sequences.
Reference: [CoCo80] <author> Cousot, P. and Cousot, R. </author> <title> ``Semantic Analysis of Communicating Sequential Processes'', Automata, </title> <booktitle> languages and programming. Lecture Notes in Computer Sciences, </booktitle> <volume> 85, </volume> <year> 1980, </year> <pages> pp. 119-133. </pages>
Reference-contexts: Operation semantics depends on sequences of atomic actions. It consists of a formal system that models the interpretation of programs, i.e. the process of performing the sequences of actions specified by the programs <ref> [CoCo80] </ref>. The effect of executing a concurrent program is defined by a set of histories, each history corresponding to one possible interleaving of the sequences of atomic actions that result from execution of its processes.
Reference: [Deut73] <author> Deutsch, L. </author> <title> ``An Interactive Program Verifier '', Ph.D Dissertation, </title> <institution> Dept. Computer Science, Univ. Of Calif., Berkeley, </institution> <year> 1973 </year>
Reference-contexts: In the axiomatic approach mathematical logic can be used for making assertions about the program variables before, during and after program execution. These assertions characterize properties of program variables and relationships between them at various stages of program execution. Discussion of program verification using assertional reasoning in found in <ref> [Deut73] </ref>, [Floy67], [HaKi57], [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84].
Reference: [Dijk76] <author> Dijkstra, E. </author> <title> A Discipline of Programming, 1976, </title> <publisher> Prentice-Hall, Inc. </publisher>
Reference-contexts: A sequential proof for it only proves facts about it running in isolation. With only one process running, communication commands deadlock. Thus, any predicate Q may be assumed to be true upon termination of a communication command because termination never occurs. The Law of the Excluded Miracle <ref> [Dijk76] </ref> states that the statement -false- should never be derived. This is the requirement to ensure a sound statement. The communication axiom does violate the Law of the Excluded Miracle.
Reference: [Floy67] <author> Floyd, R. </author> <title> ``Assigning meanings to programs'', </title> <journal> Proc. Symoposium Applied Math, </journal> <volume> 19, </volume> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference-contexts: These assertions characterize properties of program variables and relationships between them at various stages of program execution. Discussion of program verification using assertional reasoning in found in [Deut73], <ref> [Floy67] </ref>, [HaKi57], [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84].
Reference: [FrHo79] <author> Francez, N. and Hoare C. and Lehmann, D. and Roever, W. </author> <title> ``Semantics of Nondeterminism, </title> <journal> Concurrency, and Communication'', Journal of Computer and System Sciences, </journal> <volume> 19, </volume> <year> 1979, </year> <pages> pp. 290-308 43 </pages>
Reference-contexts: Denotational semantics is a formalism dependent on the last state. In denotational semantics, a function is defined for each command. This function is dependent on the last state and defines the next state if this command is executed <ref> [FrHo79] </ref>. Operation semantics depends on sequences of atomic actions. It consists of a formal system that models the interpretation of programs, i.e. the process of performing the sequences of actions specified by the programs [CoCo80].
Reference: [GeRo83] <author> Gerth, R. Roever, W. </author> <title> ``A Proof System for Concurrent Ada Programs'', </title> <type> Tech. Rep. </type> <institution> RUU-CS-83-2, Vakgroep Informatica, Rijksuniversiteit Utrecht, </institution> <address> The Netherlands, </address> <month> Jan. </month> <year> 1983. </year>
Reference: [GoCo78] <author> Good, D. and Cohen, R. and Hoch, C. and Hunter, L. and Hare, D. </author> <title> ``Report on the language Gypsy'', </title> <type> Tech. Rep. </type> <institution> ICSCA-CMP-10, The University of Texas at Austin, </institution> <year> 1978. </year>
Reference-contexts: One approach to handling proofs of liveness properties using assertional reasoning is temporal logic (MaPn81). 10. FUTURE OF THE AXIOMATIC APPROACH The most ambitious work to date in program verification is the Gypsy Verification Environment <ref> [GoCo78] </ref>. Verification with the communication commands is based on an approach similar to that found in [Soun84]. However, verification using this system requires to much computing and manpower. In general, program verification has seen little practical automated use.
Reference: [HaKi57] <author> Hantler, S. and King, J. </author> <title> ``An Introduction to Proving the Correctness of Programs'' ACM Computing Surveys, </title> <type> 8, 3, </type> <year> 1976, </year> <pages> pp. 331-353. </pages>
Reference-contexts: These assertions characterize properties of program variables and relationships between them at various stages of program execution. Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], <ref> [HaKi57] </ref>, [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84].
Reference: [Hoar69] <author> Hoare, C. </author> <title> ``An Axiomatic Basis for Computer Programming'', </title> <journal> Communications of the ACM, </journal> <volume> 12, 10, </volume> <year> 1969, </year> <pages> 576-583. </pages>
Reference-contexts: The following are common to all the axiomatic systems and apply to reasoning about sequential programs. The basis of the axiomatic approach to sequential programming can be found in <ref> [Hoar69] </ref>. 15 5.1 Axioms The skip axiom is simple, since execution of the skip statement has no effect on any program or auxiliary variables. -P- skip -P- (skip) The axiom states that anything about the program and logical variables that holds before executing skip also holds after it has terminated.
Reference: [Hoar78] <author> Hoare, C. </author> <title> ``Communicating Sequential processes'', </title> <journal> Communications of the ACM, </journal> <volume> 21, </volume> <year> 1978, </year> <pages> 666-677. </pages>
Reference-contexts: Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], [HaKi57], [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming <ref> [Hoar78] </ref>. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84]. These three proof systems are representative of the work done using the axiomatic approach. Similar work has been done in [ChMi88]. <p> CSP This section provides an informal brief description of the syntax and meaning of CSP commands. Full details of CSP are contained in <ref> [Hoar78] </ref>. Communicating Sequential Processes (CSP) was proposed as a preliminary solution to the problem of defining a synchronous message-based language. It was not intended to be used a programming language per se, but it does reect Hoare's concerns of proving the correctness of programs. <p> The repetition ends when no boolean guard is true, so b 1 / " b 2 / " . . . b n will also hold at that time. [LeGr81] does not have distributed termination which is contradictory to Hoare's original version of CSP <ref> [Hoar78] </ref>. Distributed termination provides the means for automatic termination of a loop in one process because another process has terminated. It is assumed that all termination of loops occurs when all boolean guards are false. [ApRo81] and [Soun84] do not make this assumption.
Reference: [King71] <author> King, J. </author> <title> ``Proving programs to be correct'', </title> <journal> IEEE Transactions on Computers, C-20, </journal> <volume> 11, </volume> <year> 1971, </year> <pages> pp. 1331-1336 </pages>
Reference-contexts: These assertions characterize properties of program variables and relationships between them at various stages of program execution. Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], [HaKi57], <ref> [King71] </ref>, [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84].
Reference: [LeGr81] <author> Levin, G.M and Gries, </author> <title> David ``A Proof Technique for Communicating Sequential Process'', </title> <journal> Acta Information, </journal> <volume> 15, </volume> <year> 1981, </year> <pages> 281-302. </pages>
Reference-contexts: Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], [HaKi57], [King71], [Mann74]. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], <ref> [LeGr81] </ref>, and [Soun84]. These three proof systems are representative of the work done using the axiomatic approach. Similar work has been done in [ChMi88]. <p> The first is the sequential proofs of each individual processes that makes assumptions about the effects of the communication commands. The second part is to ensure that the assumptions are "legitimate". This will be discussed later. This approach is taken in [Apro81] and <ref> [LeGr81] </ref>. The second approach allows us to prove properties of the individual processes using the axioms and rules of inference applicable to the statements in the individual processes. <p> In <ref> [LeGr81] </ref>, the inference rule for the repetition command is based on a loop invariant i.e. an assertion that holds both before and after every iteration of a loop. " / - i: -P / " b i - c i ; S i -P -P-*[ b i c i fi S <p> Thus, P will hold if the repetition terminates. The repetition ends when no boolean guard is true, so b 1 / " b 2 / " . . . b n will also hold at that time. <ref> [LeGr81] </ref> does not have distributed termination which is contradictory to Hoare's original version of CSP [Hoar78]. Distributed termination provides the means for automatic termination of a loop in one process because another process has terminated. <p> AXIOMS AND INFERENCE RULES DEALING WITH COMMUNICATION 6.1 Communication and Parallel Decomposition rules of <ref> [LeGr81] </ref> The communication axiom is as follows: -Pa-Q- (communication) where a is a communication command. Remember that -P-S-Q- means total correctness if S terminates. S terminates in the absence of deadlock. <p> This consists of showing that for each assertion T in process P i , it must be shown that T is invariant over any parallel execution. This is the non-interference property of [Owic75]. 6.2 Communication and Parallel Decomposition rules of [ApRo81] This approach is similar to the approach of <ref> [LeGr81] </ref>. It also allows for sequential proofs of the individual processes of the program and then the proving of properties of the program from the proven properties of the individual properties. The axiom used for the input and output commands is the same as [LeGr81]'s communication axiom. <p> Hence, if C gets a request from P i it does not give permission until it ensures that the other process is out of its critical section. A process relinquishes control of the critical section by sending a zero to process C. 7.1 Example using the Axiomatic system of <ref> [LeGr81] </ref> The following is the program to be proven with annotated with auxiliary variables. The auxiliary variables are turn 0 and turn 1 . Note that P 0 and P 1 are annotated with intermediate assertions. The sequential proof is easy due to the assignment and communication axioms. <p> invariant GI, which is the following: (turn 0 = 1 / " turn 1 = 1) / " flag 0 = 0 fi flag 0 = turn 0 / " flag 1 = 0 fi flag 1 = turn 1 The reasoning behind this assertion is similar to that of <ref> [LeGr81] </ref>. We will assume that the pre and post conditions of P 0 and P 1 are -true- and the intermediate assertions assert the value of turn 0 and turn 1 respectively. <p> COMPARATIVE ANALYSIS 8.1 Translation from [ApRo81] to <ref> [LeGr81] </ref> In this section, we show that any proof of a CSP program given in any of the proof systems can be translated into a proof of any of the other proof systems, assuming that we ignore the differences in the repetitive rule (remember that the different proof systems have different <p> systems, assuming that we ignore the differences in the repetitive rule (remember that the different proof systems have different ways of handling distributive termination). 33 First, let us examine translating a proof outline of a CSP program in the [ApRo81] proof system to that of a proof outline using the <ref> [LeGr81] </ref> proof system. In both of these proof systems, the correctness proof is divided into two parts. The first part consists of the sequential proofs of each individual process. The sequential proofs of each individual process includes assumptions about the effects of the communication commands. <p> Both of these systems make use of auxiliary variables to keep a partial history of the communication history between processes. In the [ApRo81] proof system the auxiliary variables are local. A global invariant is used to relate the different auxiliary variables. On the other hand, in the <ref> [LeGr81] </ref> proof system, global auxiliary variables are used. A non-interference proof is used to show that for each assertion T, T is invariant over any parallel execution. The method of translation of a proof outline of a CSP program in the [ApRo81] proof system to that of the [LeGr81] proof system <p> in the <ref> [LeGr81] </ref> proof system, global auxiliary variables are used. A non-interference proof is used to show that for each assertion T, T is invariant over any parallel execution. The method of translation of a proof outline of a CSP program in the [ApRo81] proof system to that of the [LeGr81] proof system is trivially done for the sequential part, by using the same auxiliary variables and assertions. Lemma 8.1: The sequential proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system of [LeGr81]. <p> system to that of the <ref> [LeGr81] </ref> proof system is trivially done for the sequential part, by using the same auxiliary variables and assertions. Lemma 8.1: The sequential proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system of [LeGr81]. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 <p> Lemma 8.1: The sequential proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system of <ref> [LeGr81] </ref>. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 that the effects of the communication command, as modeled by <p> proof of an individual component process using the [ApRo81] proof system can be translated into a sequential proof using the proof system of <ref> [LeGr81] </ref>. Proof: This is straightforward, since both the [ApRo81] and [LeGr81] proof systems use the same axioms and inference rules for sequential reasoning. Both the [ApRo81] and [LeGr81] proof systems require for each proof outline of a matching communication pair: P 1 : [ . . . -P-P 2 ?x-Q-] 34 that the effects of the communication command, as modeled by the logical assertions Q and T, are legitimate. <p> The proof system of [ApRo81] does this by the use of a cooperation proof, while the proof system of <ref> [LeGr81] </ref> does this by the use of a satisfaction proof. In the proof system of [ApRo81], the assignments to the auxiliary variables and the communication command is treated as an atomic section, where the global invariant in not necessarily true. This is referred to as a bracketed section. <p> It should be noted that assertions p and q include the global invariant. The satisfaction rule of <ref> [LeGr81] </ref> requires that the following is shown: p 2 is Q/ "S. It should be noted Lemma 8.2: The cooperation proof of the [ApRo81] proof system implies the satisfaction condition of the [LeGr81] proof system. <p> It should be noted that assertions p and q include the global invariant. The satisfaction rule of <ref> [LeGr81] </ref> requires that the following is shown: p 2 is Q/ "S. It should be noted Lemma 8.2: The cooperation proof of the [ApRo81] proof system implies the satisfaction condition of the [LeGr81] proof system. Proof: In order to show that -p 1 -(P 2 ?x||P 1 !y)-p 2 is true, the communication axiom is used. The communication axiom implies that a communication is an assignment. <p> This is also the satisfaction condition. Hence, since the cooperation proof shows that (P/ "R) fi (Q/ "S) x y is true, then the cooperation proof implies satisfaction. Lemma 8.3: The cooperation proof of the [ApRo81] proof system implies the noninterference property of the <ref> [LeGr81] </ref> proof system. Proof: The proof of non-interference consists of showing that for each assertion T in process P i , that T is invariant over any parallel execution. Assume T I, where I is the global invariant of equation 8.1. <p> Now, the bracketed sections are considered atomic. The cooperation proof showed that I is invariant over a bracketed section. Therefore, non-interference is guaranteed. Theorem 8.1: Any proof of a CSP program given in the proof system of [ApRo81] can be translated into a proof using the proof system of <ref> [LeGr81] </ref>. Proof: From Lemma 8.1, the sequential proofs of each of the individual processes can be shown. Lemma 8.2 shows that the satisfaction condition of [LeGr81] is satisfied by the 36 cooperation proof. Lemma 8.3 shows that the cooperation proof also implies noninterference. <p> 8.1: Any proof of a CSP program given in the proof system of [ApRo81] can be translated into a proof using the proof system of <ref> [LeGr81] </ref>. Proof: From Lemma 8.1, the sequential proofs of each of the individual processes can be shown. Lemma 8.2 shows that the satisfaction condition of [LeGr81] is satisfied by the 36 cooperation proof. Lemma 8.3 shows that the cooperation proof also implies noninterference. The sequential proofs of each individual process, the satisfaction proof, and non-interference are by the parallel decomposition rule of [LeGr81] are sufficient as a proof of the system as a whole. 8.2 Translation <p> Lemma 8.2 shows that the satisfaction condition of <ref> [LeGr81] </ref> is satisfied by the 36 cooperation proof. Lemma 8.3 shows that the cooperation proof also implies noninterference. The sequential proofs of each individual process, the satisfaction proof, and non-interference are by the parallel decomposition rule of [LeGr81] are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to [Soun84] In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are <p> Lemma 8.3 shows that the cooperation proof also implies noninterference. The sequential proofs of each individual process, the satisfaction proof, and non-interference are by the parallel decomposition rule of <ref> [LeGr81] </ref> are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to [Soun84] In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are not made about the effects of the communication commands. <p> parallel decomposition rule of <ref> [LeGr81] </ref> are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to [Soun84] In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are not made about the effects of the communication commands. Instead the communication and parallel decomposition rules are structured in such a manner that in proving a property of an individual process, it is sufficient to prove it in isolation. <p> As discussed previously and in [Clin73], auxiliary variables are used to save part of the communications sequence. In other words, auxiliary variables are functions of the communication sequences. The method of translation of a proof outline of a CSP program in the proof system of <ref> [LeGr81] </ref> to that of [Soun84] is done by replacing all the auxiliary variables in each assertion by the appropriate function of the communication sequence. It should be noted that in most cases, this is not trivial. However, for our work it is enough to realize that such a function exists. <p> Assume that -P-a -R- and -Q-a -S- are true in the sequential proofs. Then a and a are said to semantically match if -P/ "Q- is true. 37 If a pair of matching pairs do not semantically match in <ref> [LeGr81] </ref>, then this implies that this communication does not take place. Let a be a communication command in process P i , where -P-a -R- is shown to be true in the sequential proof and shown to be legitimate by the satisfaction proof of [LeGr81]. <p> pairs do not semantically match in <ref> [LeGr81] </ref>, then this implies that this communication does not take place. Let a be a communication command in process P i , where -P-a -R- is shown to be true in the sequential proof and shown to be legitimate by the satisfaction proof of [LeGr81]. Let P 1 , R 1 represent the assertions P and R respectively, with the auxiliary variables replaced by the appropriate functions of the communication sequences. Lemma 8.4: Let a , P, R, P 1 and R 1 be as defined in the previous paragraph. <p> Lemma 8.4: Let a , P, R, P 1 and R 1 be as defined in the previous paragraph. If -P-a -R-is is shown to be true in the sequential proof and shown to be legitimate by the satisfaction proof of <ref> [LeGr81] </ref> then the communication axioms of the proof system of [Soun84] is sufficient to prove -P 1 a -R 1 -. Proof: The input and output axioms of [Sound84] imply that the execution of a communication statement is an assignment. <p> The proof that P 1 fi R 1 is done by assuming the negation of P 1 fi R 1 and deriving a contradic tion. In <ref> [LeGr81] </ref>, a satisfaction proof shows that for each matching pair of communication commands a , a in P i , P j respectively, that if -P-a -R- and -Q-a -S- are true in the sequential proofs, then P/ "Q fi R / "S , where R and S denote the resulting <p> Since, we are only dealing with semantically matching pairs, we have that P/ "Q is true. But since, R is false, then the implication: P/ "Q fi R / "S is false, contradicting the earlier assumption that that this statement was true by the satisfaction proof of <ref> [LeGr81] </ref>. Hence, we can conclude that P 1 fi R 1 . Theorem 8.2: Any proof a CSP program given in the proof system of [LeGr81] system can be translated into a proof using the proof system [Soun84]. <p> the implication: P/ "Q fi R / "S is false, contradicting the earlier assumption that that this statement was true by the satisfaction proof of <ref> [LeGr81] </ref>. Hence, we can conclude that P 1 fi R 1 . Theorem 8.2: Any proof a CSP program given in the proof system of [LeGr81] system can be translated into a proof using the proof system [Soun84]. <p> Lemma 8.6 shows cooperation. The sequential proofs of each individual process and the cooperation proof are by the parallel decomposition rule of [ApRo81] are sufficient as a proof of the system as a whole. 40 8.3 8.2 <ref> [LeGr81] </ref> [Soun84] [ApRo81] Since, we are able to find transformations between these proof systems, we may conclude that these systems allows us to prove the same properties of programs. No system is more powerful then the other. <p> Proofs of the component processes can no longer be done in isolation. Another example, is the use of global vs. local auxiliary variables in the approaches of <ref> [LeGr81] </ref> and [ApRo81] respectively. Local auxiliary variables make a non-interference proof unnecessary, but there appear to be some language features that are most conveniently axiomatized by using global shared variables. For example, [GeRe83] suggest that Ada entry queues be modeled by shared variables. 9.
Reference: [Lond75] <author> London, R. </author> <title> ``A view of program verification'', </title> <booktitle> Proc. 1975 Int. Conf. on Reliable Software, </booktitle> <year> 1975, </year> <pages> pp. 534-545. </pages>
Reference: [Mann74] <author> Manna, Z. </author> <title> Mathematical theory of computation McGraw-Hill Book, </title> <publisher> Co., </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: These assertions characterize properties of program variables and relationships between them at various stages of program execution. Discussion of program verification using assertional reasoning in found in [Deut73], [Floy67], [HaKi57], [King71], <ref> [Mann74] </ref>. In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and [Soun84].
Reference: [MaPn79] <author> Manna, Z. and Pnueli, A. </author> <title> ``Temporal verification of concurrent programs'', The Correctness Problem in Computer Science ed. </title> <editor> Boyer, R. and Strother, J, </editor> <booktitle> 1981, </booktitle> <publisher> Academic Press. </publisher>
Reference: [OwGr76] <author> Owicki, S. and Gries, </author> <title> D ``An Axiomatic Proof Technique for Parallel Programs I'', </title> <journal> Acta Informatica, </journal> <volume> 6, </volume> <year> 1976, </year> <pages> 319-340 44 </pages>
Reference: [ScAn86] <author> Schneider, F. and Andrews, G. </author> <title> ``Concepts for Concurrent Programming'', </title> <booktitle> Lecture Notes in Computer Science: Current Trends in Concurrency, </booktitle> <volume> 224, </volume> <year> 1986, </year> <pages> 669-716. </pages>
Reference: [SoMo87] <author> Sommerville, I. and Morrison, R. </author> <title> Software Development with Ada, 1987, </title> <publisher> Addison-Wesley Publishers Ltd. </publisher>
Reference-contexts: For such programs, there is often no need for detailed specification and design documents to describe the system; a listing of the code is often all that is needed to understand it <ref> [SoMo87] </ref>. Some problems, however, are so complex that programs to solve these problems must be very large indeed. They may be made up of thousands or even millions of lines of code and cannot possibly be understood in detail or developed by a single person.
Reference: [Soun84] <author> Soundararahan, </author> <title> N ``Axiomatic Semantics of Communicating Sequential Processes'', </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, 4, </volume> <year> 1984, </year> <pages> 647-662. </pages>
Reference-contexts: In this paper, we focus on three axiomatic proof systems for Concurrent Sequential Processes (CSP), which is Hoare's model for concurrent programming [Hoar78]. These three axiomatic proof systems can be found in [ApRo81], [LeGr81], and <ref> [Soun84] </ref>. These three proof systems are representative of the work done using the axiomatic approach. Similar work has been done in [ChMi88]. <p> These properties are then used to prove properties of the entire program. This is the approach of <ref> [Soun84] </ref>. 5. AXIOMS AND INFERENCE RULES USED FOR SEQUENTIAL REASONING In addition to the axioms and inference rules of predicate logic, there is one axiom or inference rule for each type of statement, as well as some statement-independent inference rules. <p> Distributed termination provides the means for automatic termination of a loop in one process because another process has terminated. It is assumed that all termination of loops occurs when all boolean guards are false. [ApRo81] and <ref> [Soun84] </ref> do not make this assumption. <p> Since, auxiliary variables are not subject to change except in a bracketed section and since the cooperation proof ensures that the global invariant is true except through the bracketed section, then a proof of non-interference is not needed. 6.3 Communication and Parallel Decomposition rules of <ref> [Soun84] </ref> 23 The communication and parallel decomposition rules are structured in such manner such that in proving a property of one of the processes, it must be considered in isolation. No assumptions that must be verified later about the behavior of the other processes are made. <p> However, the same conditions and hence the same cooperation proof exists for the second occurrence. The above proofs are easy using the formation, arrow, communication substitution, and consequence rules. 7.3 Example using the Axiomatic System of <ref> [Soun84] </ref> We use the following function on the communication sequence in order to aid in formulating assertions: Last_comm (i,j) = the last element of h i that involves j We would like the following assertion to always be true: (Last_comm (h c , p 0 ) = (c, p 0 , <p> Lemma 8.3 shows that the cooperation proof also implies noninterference. The sequential proofs of each individual process, the satisfaction proof, and non-interference are by the parallel decomposition rule of [LeGr81] are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to <ref> [Soun84] </ref> In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are not made about the effects of the communication commands. <p> The sequential proofs of each individual process, the satisfaction proof, and non-interference are by the parallel decomposition rule of [LeGr81] are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to <ref> [Soun84] </ref> In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are not made about the effects of the communication commands. <p> rule of [LeGr81] are sufficient as a proof of the system as a whole. 8.2 Translation from [LeGr81] to <ref> [Soun84] </ref> In the proof system of [Soun84] proof system, the correctness proof consists of the sequential proofs of each individual process. Unlike the approach of the proof systems of [LeGr81] and [Soun84], assumptions are not made about the effects of the communication commands. Instead the communication and parallel decomposition rules are structured in such a manner that in proving a property of an individual process, it is sufficient to prove it in isolation. The proof system of [Soun84] associates with each individual <p> systems of [LeGr81] and <ref> [Soun84] </ref>, assumptions are not made about the effects of the communication commands. Instead the communication and parallel decomposition rules are structured in such a manner that in proving a property of an individual process, it is sufficient to prove it in isolation. The proof system of [Soun84] associates with each individual process P i of a program a variable h i . h i is the sequence of all communications in which P i has so far participated. Assertions make use of functions defined on the communications sequences. <p> As discussed previously and in [Clin73], auxiliary variables are used to save part of the communications sequence. In other words, auxiliary variables are functions of the communication sequences. The method of translation of a proof outline of a CSP program in the proof system of [LeGr81] to that of <ref> [Soun84] </ref> is done by replacing all the auxiliary variables in each assertion by the appropriate function of the communication sequence. It should be noted that in most cases, this is not trivial. However, for our work it is enough to realize that such a function exists. <p> It should be noted that in most cases, this is not trivial. However, for our work it is enough to realize that such a function exists. All assignments to auxiliary variables may be deleted. No explicit updating of the communications sequences is required, since the <ref> [Soun84] </ref> proof system assumes automatic update of the communication sequence when a communication command has been executed. Definition 8.1: Let a and a be a matching pair of communication commands. Assume that -P-a -R- and -Q-a -S- are true in the sequential proofs. <p> If -P-a -R-is is shown to be true in the sequential proof and shown to be legitimate by the satisfaction proof of [LeGr81] then the communication axioms of the proof system of <ref> [Soun84] </ref> is sufficient to prove -P 1 a -R 1 -. Proof: The input and output axioms of [Sound84] imply that the execution of a communication statement is an assignment. <p> Hence, we can conclude that P 1 fi R 1 . Theorem 8.2: Any proof a CSP program given in the proof system of [LeGr81] system can be translated into a proof using the proof system <ref> [Soun84] </ref>. Proof: Since both of these proof systems use the same axioms and inference rules for sequential reasoning (with the exception of the communication axioms) and Lemma 8.4. 8.3 Translation from [Soun84] to [ApRo81] As discussed before, auxiliary variables are functions of communications sequences. <p> program given in the proof system of [LeGr81] system can be translated into a proof using the proof system <ref> [Soun84] </ref>. Proof: Since both of these proof systems use the same axioms and inference rules for sequential reasoning (with the exception of the communication axioms) and Lemma 8.4. 8.3 Translation from [Soun84] to [ApRo81] As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the <p> same axioms and inference rules for sequential reasoning (with the exception of the communication axioms) and Lemma 8.4. 8.3 Translation from <ref> [Soun84] </ref> to [ApRo81] As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. The assertions used in the proof outline for the [Soun84] proof system <p> axioms) and Lemma 8.4. 8.3 Translation from <ref> [Soun84] </ref> to [ApRo81] As discussed before, auxiliary variables are functions of communications sequences. Therefore, a translation of a proof outline of a CSP program in the proof system of [Soun84] to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. The assertions used in the proof outline for the [Soun84] proof system remain the same for a proof outline for the [ApRo81] proof system, since the <p> system of <ref> [Soun84] </ref> to the proof system of [ApRo81] involves considering the variables h i of [Soun84] as auxiliary variables in [ApRo81] and the predicate Compat (h 1 , . . . , h n ) as the global invariant I. The assertions used in the proof outline for the [Soun84] proof system remain the same for a proof outline for the [ApRo81] proof system, since the variables h i are local. Lemma 8.5: The sequential proof of an individual component process using the [Soun84] proof system can be translated into a sequential proof using the proof system of [ApRo81]. <p> The assertions used in the proof outline for the <ref> [Soun84] </ref> proof system remain the same for a proof outline for the [ApRo81] proof system, since the variables h i are local. Lemma 8.5: The sequential proof of an individual component process using the [Soun84] proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables <p> Lemma 8.5: The sequential proof of an individual component process using the <ref> [Soun84] </ref> proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables h i s are updated simultaneously with the execution of a communication command. <p> an individual component process using the <ref> [Soun84] </ref> proof system can be translated into a sequential proof using the proof system of [ApRo81]. Proof: This is straightforward, since both the [Soun84] and [ApRo81] proof systems can use the same axioms and inference rules for sequential reasoning. In the proof system of [Soun84], it is assumed that the variables h i s are updated simultaneously with the execution of a communication command. This can be simulated in the [ApRo81] proof system by updating h i in an assignment statement immediately following a communication command. <p> This implies that P j !y and h i : = h ^ i (i, j, y) form a bracketed section. The intermediate assertion i.e. the assertion in the bracketed section is the global invariant I. Lemma 8.6: The translation described above of a proof outline using the <ref> [Soun84] </ref> proof system to the [ApRo81] proof system will ensure cooperation. Proof: It is necessary to show for each matching pair of bracketed sections: P 1 : [ . . . -P- &lt; P 2 ?x; -I-h 1 : = h 1 ^(2, 1, y) &gt; -Q-] cooperates. <p> This is easy to see, since, CSP variables are local and the proof system of <ref> [Soun84] </ref> assumes that the h i s are local. Theorem 8.3: Any proof of a CSP program given using the proof system of [Soun84] can be translated into a proof using the proof system of [ApRo81]. <p> This is easy to see, since, CSP variables are local and the proof system of <ref> [Soun84] </ref> assumes that the h i s are local. Theorem 8.3: Any proof of a CSP program given using the proof system of [Soun84] can be translated into a proof using the proof system of [ApRo81]. Proof: From Lemma 8.5, the sequential proofs of each of the individual processes can be shown. Lemma 8.6 shows cooperation. <p> Lemma 8.6 shows cooperation. The sequential proofs of each individual process and the cooperation proof are by the parallel decomposition rule of [ApRo81] are sufficient as a proof of the system as a whole. 40 8.3 8.2 [LeGr81] <ref> [Soun84] </ref> [ApRo81] Since, we are able to find transformations between these proof systems, we may conclude that these systems allows us to prove the same properties of programs. No system is more powerful then the other. <p> No system is more powerful then the other. However, there are very different approaches to thinking about the proof of the program and the applicability in a practical environment. For example, it is conceptually easier to work with the proof system of <ref> [Soun84] </ref>, because the proofs of the component processes are done in isolation. However, it is difficult to maintain the communication sequences. On the other hand, in the other two approaches, the auxiliary variables are used to record the needed history of the communication sequences, but the proofs are more complicated. <p> FUTURE OF THE AXIOMATIC APPROACH The most ambitious work to date in program verification is the Gypsy Verification Environment [GoCo78]. Verification with the communication commands is based on an approach similar to that found in <ref> [Soun84] </ref>. However, verification using this system requires to much computing and manpower. In general, program verification has seen little practical automated use. Many researchers have found that program verification consumed too many resources to apply it to practical systems.
References-found: 24

