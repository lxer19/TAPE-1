URL: http://www.cs.rice.edu/CS/PLT/Publications/tr93-200.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Polymorphism for Imperative Languages without Imperative Types  
Author: Andrew K. Wright 
Date: February 18, 1993  
Affiliation: Rice University  
Pubnum: Technical Report TR93-200  
Abstract: The simple and elegant Hindley/Milner polymorphic type discipline is the basis of the type system of Standard ML, but ML's imperative features are a blight on this otherwise clean landscape. Polymorphism and imperative features cannot freely coexist without compromising type safety, hence Standard ML assigns imperative types of limited polymorphism to procedures that use references, exceptions, or continuations. Several other solutions exist, but all introduce new kinds of types that complicate the type system, contaminate module signatures, and violate abstraction by revealing the pure or imperative nature of a procedure in its type. We propose a seemingly radical alternative: by restricting polymorphism to values, imperative procedures have the same types as their behaviorally equivalent functional counterparts. Although the resulting type system does not accept all expressions typable in the purely functional sublanguage, this limitation is seldom encountered in practice. The vast majority of ML code already satisfies the restriction of polymorphism to values, and simple syntactic modifica tions fix the few non-conforming programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Damas, L. M. M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> When partially applied: let val flatten = imperativeMap hd the resulting procedure flatten has polymorphic type 8ff 1 : ff 1 list list ! ff 1 list. In Tofte's system, flatten may not be used polymorphically. Damas: Damas proposed one of the earliest systems for typing references <ref> [1] </ref>. His system derives type judgments of the form: ` e : t fl where is a finite set of the types of cells that may be allocated by evaluating e.
Reference: [2] <author> Harper, R., Duba, B. F., and MacQueen, D. </author> <title> Typing first-class continuations in ML. </title> <note> Journal of Functional Programming (to appear 1993). Preliminary version in Proc. 18th Annual Symposium on Principles of Programming Languages, </note> <year> 1991, </year> <pages> pp. 163-173. 9 </pages>
Reference-contexts: It may be possible to allow unbound type variables even in the absence of a signature constraint, but we have not investigated this more flexible extension. 5 This was discovered by Robert Harper and Mark Lillibridge [sml electronic mailing list, July 8, 1991]. For further details, see <ref> [2] </ref> or [16]. 6 Standard ML: Standard ML adopts Tofte's method of typing imperative features [14]. Tofte's solution generalizes the types of values as above, but in addition is able to generalize some type variables when the bound expression is not a value. <p> In effect, this system is able to prove that the side effects with imperativeMap are local. But due to the undecidable nature of the problem, there exist more complicated procedures whose type reveals their imperative nature. 6 Damas uses a slightly different notation. 7 Call-by-name Polymorphism: Several authors <ref> [2, 5] </ref> have suggested using call-by-name seman-tics for let-expressions in order to combine imperative features and polymorphism. That is, in the expression: let x = e 1 in e 2 the subexpression e 1 is not evaluated until it is needed, and it is re-evaluated each time it is used. <p> All were trivial to fix. Reppy's Concurrent ML implementation [11] illustrates the benefit of assigning fully polymorphic types to imperative procedures. Concurrent ML makes extensive use of Standard ML of New Jersey's first-class continuations <ref> [2] </ref> to implement threads.
Reference: [3] <author> Hoang, M., Mitchell, J., and Viswanathan, R. </author> <title> Standard ML weak polymorphism and imperative constructs. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Logic in Computer Science (June 1993). To appear. </booktitle>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> Weak Types: A system proposed by MacQueen has been implemented by Standard ML of New Jersey [12] for several years, and has recently been formalized by Hoang, Mitchell, and Viswanathan <ref> [3] </ref>. This system extends Tofte's method by assinging "weakness" numbers to type variables. The weakness of a type variable indicates how many arguments must be supplied to a procedure before it allocates a reference containing that type variable.
Reference: [4] <author> Leroy, X. </author> <title> Typage polymorphe d'un langage algorithmique. </title> <type> PhD thesis, </type> <address> L'Universite Paris 7, </address> <year> 1992. </year>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> Suppose the bound expression involves purely functional computation, like the following example: 1 Leroy's original closure typing system [6] did not type all such functional expressions. His dissertation <ref> [4] </ref> corrects this oversight. 2 let val f = (fn x =&gt; x)(fn y =&gt; y) f true end With pure Hindley/Milner typing, this expression would be typable by assigning to f the polymorphic type 8ff: ff ! ff. <p> Type schemes that represent function types are augmented by a similar set on the outermost arrow, i.e., 8ff fl : t 1 Within such a type scheme, indicates the types of reference cells that the procedure may allocate when it is applied. 6 Closure Typing: Leroy and Weis <ref> [4, 6] </ref> propose a closure typing system based on the observation that it is only necessary to prohibit generalization of type variables appearing in the types of cells reachable after the bound expression has been evaluated (i.e., cells that would not be reclaimed by a garbage collection at this point).
Reference: [5] <author> Leroy, X. </author> <title> Polymorphism by name for references and continuations. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages (January 1993), </booktitle> <pages> pp. 220-231. </pages>
Reference-contexts: Indeed, it is polymorphic in Standard ML's type system and the other systems for combining references and polymorphism, but with polymor-phism restricted to values, map' is not polymorphic. Leroy gives several other academic examples of computing polymorphic procedures <ref> [5] </ref>. Determining whether the result of a computation can be polymorphic involves determining whether the computation has visible side effects. This problem is undecidable, hence the existing systems for typing references use different techniques to achieve conservatively approximate solutions. <p> In effect, this system is able to prove that the side effects with imperativeMap are local. But due to the undecidable nature of the problem, there exist more complicated procedures whose type reveals their imperative nature. 6 Damas uses a slightly different notation. 7 Call-by-name Polymorphism: Several authors <ref> [2, 5] </ref> have suggested using call-by-name seman-tics for let-expressions in order to combine imperative features and polymorphism. That is, in the expression: let x = e 1 in e 2 the subexpression e 1 is not evaluated until it is needed, and it is re-evaluated each time it is used.
Reference: [6] <author> Leroy, X., and Weis, P. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> pp. 291-302. </pages>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> Expressions that diverge are uninteresting,but what about expressions that compute polymorphic procedures? Let us examine this limitation according to whether the computation is purely functional or uses imperative features. Suppose the bound expression involves purely functional computation, like the following example: 1 Leroy's original closure typing system <ref> [6] </ref> did not type all such functional expressions. His dissertation [4] corrects this oversight. 2 let val f = (fn x =&gt; x)(fn y =&gt; y) f true end With pure Hindley/Milner typing, this expression would be typable by assigning to f the polymorphic type 8ff: ff ! ff. <p> Type schemes that represent function types are augmented by a similar set on the outermost arrow, i.e., 8ff fl : t 1 Within such a type scheme, indicates the types of reference cells that the procedure may allocate when it is applied. 6 Closure Typing: Leroy and Weis <ref> [4, 6] </ref> propose a closure typing system based on the observation that it is only necessary to prohibit generalization of type variables appearing in the types of cells reachable after the bound expression has been evaluated (i.e., cells that would not be reclaimed by a garbage collection at this point).
Reference: [7] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: 1 The Problem with Polymorphic References The simple and elegant Hindley/Milner polymorphic type discipline <ref> [7] </ref> is the basis of the type system of Standard ML [9], but ML's imperative features are a blight on this otherwise clean landscape. Polymorphism and imperative features like references cannot freely coexist in a call-by-value language without compromising type safety.
Reference: [8] <author> Milner, R., and Tofte, M. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: In this structure: structure Foo = struct val flatten = map hd end 3 See rules 100-102 of the Definition [9], and the footnote on page 55 of the Commentary <ref> [8] </ref>. 5 flatten has type ff list list ! ff list, but since map hd is not a value, ff cannot be generalized, and this structure must be rejected.
Reference: [9] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 The Problem with Polymorphic References The simple and elegant Hindley/Milner polymorphic type discipline [7] is the basis of the type system of Standard ML <ref> [9] </ref>, but ML's imperative features are a blight on this otherwise clean landscape. Polymorphism and imperative features like references cannot freely coexist in a call-by-value language without compromising type safety. <p> In this structure: structure Foo = struct val flatten = map hd end 3 See rules 100-102 of the Definition <ref> [9] </ref>, and the footnote on page 55 of the Commentary [8]. 5 flatten has type ff list list ! ff list, but since map hd is not a value, ff cannot be generalized, and this structure must be rejected.
Reference: [10] <author> Plotkin, G. D. </author> <title> Call-by-name, call-by-value and the lambda-calculus. </title> <booktitle> Theoretical Computer Science 1 (1975), </booktitle> <pages> 125-159. </pages>
Reference-contexts: Programs are expressions that are closed with respect to an initial environment that provides bindings for the program's free variables. Programs are evaluated according to the usual semantics for a call-by-value language <ref> [10] </ref>. The let-expression is semantically equivalent to the expression ((x:e 2 ) e 1 ).
Reference: [11] <author> Reppy, J. H. </author> <title> Higher-order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1991. </year>
Reference-contexts: The other cases were partial applications of procedures like map or the function composition operator, o. All were trivial to fix. Reppy's Concurrent ML implementation <ref> [11] </ref> illustrates the benefit of assigning fully polymorphic types to imperative procedures. Concurrent ML makes extensive use of Standard ML of New Jersey's first-class continuations [2] to implement threads.
Reference: [12] <institution> Standard ML of New Jersey release notes (version 0.75). AT&T Bell Laboratories, </institution> <month> Novem-ber </month> <year> 1991. </year>
Reference-contexts: Any type substituted for an imperative type variable must contain only imperative type variables, and imperative type variables may not be generalized when the bound expression is not a value. Weak Types: A system proposed by MacQueen has been implemented by Standard ML of New Jersey <ref> [12] </ref> for several years, and has recently been formalized by Hoang, Mitchell, and Viswanathan [3]. This system extends Tofte's method by assinging "weakness" numbers to type variables.
Reference: [13] <author> Talpin, J.-P., and Jouvelot, P. </author> <title> The type and effect discipline. </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Logic in Computer Science (June 1992), </booktitle> <pages> pp. 162-173. </pages>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> Determining whether the result of a computation can be polymorphic involves determining whether the computation has visible side effects. This problem is undecidable, hence the existing systems for typing references use different techniques to achieve conservatively approximate solutions. These solutions are generally incompatible <ref> [13, 15] </ref>, and determining whether an expression will yield a polymorphic type requires sophisticated reasoning processes that are usually beyond the programmer's capability. Perhaps because of the difficulty of predicting these type systems, programmers avoid computing polymorphic procedures in an imperative manner. <p> In this system, imperativeMap has type 8fffi& 1 & 2 & 3 : (ff & 1 & 2 ! ff list & 1 & 3 fffi ! fi list. A more sophisticated system devised by Talpin and Jouvelot infers types, effects, and effect regions for expressions <ref> [13] </ref>. This system assigns to both map and imperativeMap the same type, 8fffi& 1 & 2 & 3 : (ff & & 2 ! ff list & 1 & 3 ! fi list. In effect, this system is able to prove that the side effects with imperativeMap are local.
Reference: [14] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference-contexts: The problem is that in typing the expression: let val x = e 1 in e 2 if evaluating e 1 causes side effects, type variables involved in these side effects must not be generalized in assigning a type to x <ref> [14] </ref>. The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type [1, 3, 4, 6, 13, 14, 15]. <p> The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> For further details, see [2] or [16]. 6 Standard ML: Standard ML adopts Tofte's method of typing imperative features <ref> [14] </ref>. Tofte's solution generalizes the types of values as above, but in addition is able to generalize some type variables when the bound expression is not a value.
Reference: [15] <author> Wright, A. K. </author> <title> Typing references by effect inference. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 473-491. </pages>
Reference-contexts: The existing solutions attempt to determine when e 1 will cause undesirable side effects by recording information about potential side effects in an expression's type <ref> [1, 3, 4, 6, 13, 14, 15] </ref>. <p> Determining whether the result of a computation can be polymorphic involves determining whether the computation has visible side effects. This problem is undecidable, hence the existing systems for typing references use different techniques to achieve conservatively approximate solutions. These solutions are generally incompatible <ref> [13, 15] </ref>, and determining whether an expression will yield a polymorphic type requires sophisticated reasoning processes that are usually beyond the programmer's capability. Perhaps because of the difficulty of predicting these type systems, programmers avoid computing polymorphic procedures in an imperative manner. <p> A sys tem proposed by the author in essence extends Damas's system to attach effect sets () to all function type arrows <ref> [15] </ref>. In this system, imperativeMap has type 8fffi& 1 & 2 & 3 : (ff & 1 & 2 ! ff list & 1 & 3 fffi ! fi list. A more sophisticated system devised by Talpin and Jouvelot infers types, effects, and effect regions for expressions [13].
Reference: [16] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> To appear in: Information and Computation. 10 </note>
Reference-contexts: In the absence of a signature constraint, unbound type variables in structures are still illegal. 4 3.2 Other Imperative Features The difficulties of typing other imperative features like exceptions and continuations are similar to the difficulties of typing references <ref> [16] </ref>. <p> It may be possible to allow unbound type variables even in the absence of a signature constraint, but we have not investigated this more flexible extension. 5 This was discovered by Robert Harper and Mark Lillibridge [sml electronic mailing list, July 8, 1991]. For further details, see [2] or <ref> [16] </ref>. 6 Standard ML: Standard ML adopts Tofte's method of typing imperative features [14]. Tofte's solution generalizes the types of values as above, but in addition is able to generalize some type variables when the bound expression is not a value.
References-found: 16

