URL: http://www.cs.cmu.edu/afs/cs/project/able/ftp/aesop-fse2.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/able/www/paper_abstracts/aesop-fse2.html
Root-URL: 
Title: Exploiting Style in Architectural Design Environments  
Author: David Garlan Robert Allen John Ockerbloom 
Address: Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: As the design of software architectures emerges as a discipline within software engineering, it will become increasingly important to support architectural description and analysis with tools and environments. In this paper we describe a system for developing architectural design environments that exploit architectural styles to guide software architects in producing specific systems. The primary contributions of this research are: (a) a generic object model for representing architectural designs; (b) the characterization of architectural styles as specializations of this object model; and (c) a toolkit for creating an open architectural design environment from a description of a specific architectural style. We use our experience in implementing these concepts to illustrate how style-oriented architectural design raises new challenges for software support environments. 
Abstract-found: 1
Intro-found: 1
Reference: [AAG93] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Using style to give meaning to software architecture. </title> <booktitle> In Proceedings of SIGSOFT'93: Foundations of Software Engineering, Software Engineering Notes 118(3), </booktitle> <pages> pages 9-20. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: Hence, our research is attacking a more general problem. The second area is research aimed at providing a rigorous basis for architectural specification and design <ref> [GN91, AG92, AAG93, PW92] </ref>. To the extent that such research clarifies the nature of architectural representation and the meaning of architectural style, our work builds on those results. <p> More specifically, we observe that architectural styles typically determine four kinds of properties <ref> [AAG93] </ref>: 1. They provide a vocabulary of design elements component and connector types such as pipes, filters, clients, servers, parsers, databases etc. 2. They define a set of configuration rules or topological constraints that determine the permitted compositions of those elements. <p> Operations supported by these classes include adding and removing ports to components, 3 An argument for representation of connectors as first class semantic entities is beyond the scope of this paper, but can be found elsewhere [AG94a, Sha93]. Also, for a more formal treatment of the architectural model see <ref> [AAG93] </ref>. 4 Note that bindingsare not connectors: connectors define paths of interaction, while bindings identify equivalences between two interface points.
Reference: [AG92] <author> Robert Allen and David Garlan. </author> <title> A formal approach to software architectures. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Proceedings of IFIP'92. </booktitle> <publisher> Elsevier Science Publishers B.V., </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: Hence, our research is attacking a more general problem. The second area is research aimed at providing a rigorous basis for architectural specification and design <ref> [GN91, AG92, AAG93, PW92] </ref>. To the extent that such research clarifies the nature of architectural representation and the meaning of architectural style, our work builds on those results.
Reference: [AG94a] <author> Robert Allen and David Garlan. </author> <title> Beyond definition/use: Architectural interconnection. </title> <booktitle> In Proceedings of the ACM Interface Definition Language Workshop, volume 29(8). SIGPLAN Notices, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Operations supported by these classes include adding and removing ports to components, 3 An argument for representation of connectors as first class semantic entities is beyond the scope of this paper, but can be found elsewhere <ref> [AG94a, Sha93] </ref>. Also, for a more formal treatment of the architectural model see [AAG93]. 4 Note that bindingsare not connectors: connectors define paths of interaction, while bindings identify equivalences between two interface points.
Reference: [AG94b] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994. </year> <editor> [B 88] G. Boudier et al. </editor> <title> An overview of PCTE and PCTE+. </title> <booktitle> In Proc. 3rd Software Development Environments Symposium, </booktitle> <month> November </month> <year> 1988. </year>
Reference-contexts: In particular, the basic model of architectural representation (Section 4.3) and the elements of style description (Section 3) emerged as a result of our own experience with formalization of architecture. Moreover, tools that have resulted from efforts to formalize software architecture (e.g., architectural compatibility checkers <ref> [AG94b] </ref> and refinement tools [MQR94]) are natural candidates for tools in our style-specific environments. The third is research on languages for architectural description. These efforts have focused on providing general-purpose architectural description languages, linguistic mechanisms for component specification and generation, and tools to support these. <p> In many cases representation of a component or connector is not architectural, per se. For example, a component might have a representation that specifies its functionality, or a code module that describes an implementation. Similarly, a connector might have a representation that specifies its protocol <ref> [AG94b] </ref>. That information is often best manipulated by external non-architectural tools, such as compilers and proof checkers, and stored in an external database (such as the file system). <p> Specifically, in what ways can subclasses alter the behavior of their superclasses through overriding? In our system, the rule is: architectural subclasses must respect the semantic behavior of their superclasses. The term 5 Currently we use the Wright language <ref> [AG94b] </ref> to define the semantics of connectors as a collection of protocols. fam_bool pf_source::attach (fam_port p) - if (!fam_is_subtype (p.fam_type (),PF_WRITE_TYPE)) - return false; - else - return fam_port::attach (p); - respect, however, is used in a non-standard way. <p> In the prototype pipe-filter the semantics of filters is given by a simple, style-specific filter language, as was illustrated in Figure 3. The associated tool (based on Gan-dalf [HN86]) provides typechecking and other static analyses. The semantics of pipes is described formally (but off-line) as in <ref> [AG94b] </ref>. 6 Of course, this can not be automatically enforced for C++. 8 #include "filter_header.h" void split (in,left,right) - char __buf; int __i; /* no declarations */ /* dup and close */ in = dup (in);left = dup (left); right = dup (right); for (__i=0;__i&lt;NUM_CONS;__i++) - close (fildes [__i][0]); close (fildes
Reference: [BV93] <author> Pam Binns and Steve Vestal. </author> <title> Formal real-time architecture specification and analysis. </title> <booktitle> In Tenth IEEE Workshop on Real-Time Operating Systems and Soft ware, </booktitle> <address> New York, NY, </address> <month> May </month> <year> 1993. </year> <title> [C 90] M. </title> <editor> Carey et al. </editor> <title> The EXODUS extensible DBMS project: An overview. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: These environments typically provide tools to support particular architectural design paradigms and their associated development methods. Examples include architectures based on data flow [Mak92], object-oriented design [R + 91], blackboard shells [Nii86], control systems <ref> [BV93] </ref>, and reactive integration [Fro89]. Unfortunately each such environment is built as an independent, hand-crafted effortand at great cost. <p> Other reference architectures include communication reference models (such as the ISO OSI 7-layer model [McC91]), some user interface frameworks [K + 91], and a large variety of domain-specific approaches in areas such as avionics <ref> [BV93] </ref> and mobile robotics [SLF90, HR90]. More specifically, we observe that architectural styles typically determine four kinds of properties [AAG93]: 1. They provide a vocabulary of design elements component and connector types such as pipes, filters, clients, servers, parsers, databases etc. 2.
Reference: [Cha93] <author> Craig Chambers. </author> <title> Predicate classes. </title> <booktitle> In Proceedings of ECOOP `93, </booktitle> <year> 1993. </year>
Reference-contexts: To get the benefits of pipelines, however, we would need to change the type of the object from filter to stage. While such coersions can be handled on a case-by-case basis, a more uniform mechanism, such as one based on predicate types <ref> [Cha93] </ref>, would be preferable. These features suggest ways in which style-oriented architectural design raises new challenges for software support environments. First, heterogeneity of styles is critical.
Reference: [Coa92] <author> Peter Coad. </author> <title> Object-oriented patterns. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 153-159, </pages> <year> 1992. </year>
Reference-contexts: Architectural styles fall into two broad categories. Idioms and patterns: This category includes global organizational structures, such as layered systems, pipe-filter systems, client-server organizations, blackboards, etc. It also includes localized patterns, such as model-view-controller [KP88] and many other object-oriented patterns <ref> [Coa92, GHJV94] </ref>. Reference models: This category includes system organizations that prescribe specific (often parameterized) configurations of components and interactions for specific application areas. A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator [PW92].
Reference: [Cor91] <editor> The Common Object Request Broker: </editor> <title> Architecture and specification. OMG Document Number 91.12.1, </title> <month> December </month> <year> 1991. </year> <note> Revision 1.1 (Draft 10). </note>
Reference-contexts: For example, even without giving details, characterization of a system as a client-server organization immediately conveys a strong image of the kinds of pieces and how they fit together. Fourth, use of standardized styles supports interoperability. Examples include CORBA object-oriented architecture <ref> [Cor91] </ref>, the OSI protocol stack [McC91], and event-based tool integration [Ger89]. Fifth, as noted above, by constraining the design space, an architectural style often permits specialized, style-specific analyses. For example, it is possible to analyze systems built in a pipe-filter style for schedulability, throughput, latency, and deadlock-freedom.
Reference: [DGHKL84] <author> Veronique Donzeau-Gouge, Gerard Huet, Gilles Kahn, and Bernard Lang. </author> <title> Programming environments based on structured editors: The Mentor experience. </title> <editor> In David R. Barstow, Howard E. Shrobe, and Erik Sandewall, editors, </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill Book Co., </publisher> <year> 1984. </year>
Reference-contexts: open architectural design environment from a description of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks [B + 88, Ger89], environment generators and toolkits <ref> [RT89, vLDD + 88, DGHKL84] </ref>, process-oriented support [KFP88, T + 88], etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment.
Reference: [Fro89] <author> Brian Fromme. </author> <title> HP Encapsulator: Bridging the generation gap. </title> <type> Technical Report SESD-89-26, </type> <institution> Hewlett Packard Software Engineering Systems Division, Fort Collins, Colorado, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: These environments typically provide tools to support particular architectural design paradigms and their associated development methods. Examples include architectures based on data flow [Mak92], object-oriented design [R + 91], blackboard shells [Nii86], control systems [BV93], and reactive integration <ref> [Fro89] </ref>. Unfortunately each such environment is built as an independent, hand-crafted effortand at great cost. While development efforts may exploit emerging software environment infrastructure (persistent object bases, tool integration frameworks, user interface toolkits, etc.), the architectural aspects are typically redesigned and reimplemented from scratch for each new style. <p> To take two illustrative industrial examples, the HP Softbench Encapsulator helps developers build applications that conform to a particular Softbench event-based style <ref> [Fro89] </ref>. Applications are integrated into a system by wrappping them with an interface that permits them to interact with other tools via event broadcast. Similarly, the Honeywell MetaH language and supporting development tools provide an architectural description language for real-time, embedded avionics applications [Ves94].
Reference: [Ger89] <author> Colin Gerety. </author> <title> HP Softbench: A new generation of software development tools. </title> <type> Technical Report SESD-89-25, </type> <institution> Hewlett-Packard Software Engineering Sys tems Division, Fort Collins, Colorado, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: subtyping); and (c) a toolkit for creating an open architectural design environment from a description of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks <ref> [B + 88, Ger89] </ref>, environment generators and toolkits [RT89, vLDD + 88, DGHKL84], process-oriented support [KFP88, T + 88], etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment. <p> Fourth, use of standardized styles supports interoperability. Examples include CORBA object-oriented architecture [Cor91], the OSI protocol stack [McC91], and event-based tool integration <ref> [Ger89] </ref>. Fifth, as noted above, by constraining the design space, an architectural style often permits specialized, style-specific analyses. For example, it is possible to analyze systems built in a pipe-filter style for schedulability, throughput, latency, and deadlock-freedom. <p> As a third example, Figure 4 illustrates an environment for an event-based style similar to Field [Rei90] or Softbench <ref> [Ger89] </ref>. 1 In this environment the components are active (event-announcing) objects, and the connectors are drawn as a kind of software bus along which events are announced and received by the components. In this case the connector can be opened to expose its underlying representation as an event dispatcher. <p> This interface is defined as a set of C++ object types that are linked with tools that intend to directly manipulate architectural data. Additionally, tools can register an interest in specific data objects, and will be notified when they change. Currently we use Hewlett Packard's Softbench <ref> [Ger89] </ref> for event-based tool invocation. This same mechanism also serves to integrate external tools. For example, in the pipe-filter environment, described above, code is generated by announcing a message to a suitably encapsulated code generation tool. Tools such as external editors are handled in the same way.
Reference: [GHJV94] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Micro-Architectures for Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Architectural styles fall into two broad categories. Idioms and patterns: This category includes global organizational structures, such as layered systems, pipe-filter systems, client-server organizations, blackboards, etc. It also includes localized patterns, such as model-view-controller [KP88] and many other object-oriented patterns <ref> [Coa92, GHJV94] </ref>. Reference models: This category includes system organizations that prescribe specific (often parameterized) configurations of components and interactions for specific application areas. A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator [PW92].
Reference: [GN91] <author> David Garlan and David Notkin. </author> <title> Formalizing design spaces: Implicit invocation mechanisms. </title> <booktitle> In VDM'91: Formal Software Development Methods, </booktitle> <pages> pages 31-44, </pages> <address> Noordwijkerhout, The Netherlands, </address> <month> October </month> <year> 1991. </year> <note> Springer-Verlag, LNCS 551. </note>
Reference-contexts: Hence, our research is attacking a more general problem. The second area is research aimed at providing a rigorous basis for architectural specification and design <ref> [GN91, AG92, AAG93, PW92] </ref>. To the extent that such research clarifies the nature of architectural representation and the meaning of architectural style, our work builds on those results.
Reference: [GP94] <author> David Garlan and Dewayne Perry. </author> <title> Software architecture: Practice, potential, and pitfalls. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994. </year> <title> Panel Introduction. </title>
Reference-contexts: opportunities for design guidance, analysis, and synthesis. 3 What is Software Architecture and Architectural Style? While there is currently no single well-accepted definition of software architecture it is generally recognized that an architectural design of a system is concerned with describing its gross decomposition into computational elements and their interactions <ref> [PW92, GS93b, GP94] </ref>. Issues relevant to this level of design include organization of a system as a composition of components; global control structures; protocols for communication, synchronization, and data access; assignment of functionality to design elements; physical distribution; scaling and performance; dimensions of evolution; and selection among design alternatives.
Reference: [GS93a] <author> David Garlan and Curtis Scott. </author> <title> Adding implicit invocation to traditional programming languages. </title> <booktitle> In Proceedings of the Fifteenth International Confer ence on Software Engineering, </booktitle> <address> Baltimore, MD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Analyses. A number of analyses are possible in event-based styles, such as identifying the flow of communication between components. As in the pipe-filter style, given a language for specifying the communication behavior of participant components, a compiler can be built to generate code for a particular event-based configuration <ref> [GS93a] </ref>. (We did not do this, however, in our prototype.) 4.5 User Interface In addition to providing a representational model for tools to create and manipulate architectural descriptions, an environment must also provide a way for the user to view, edit, and use these descriptions.
Reference: [GS93b] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V.Ambriola and G.Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, Volume I, </booktitle> <address> New Jersey, 1993. </address> <publisher> World Scientific Publishing Company. </publisher>
Reference-contexts: opportunities for design guidance, analysis, and synthesis. 3 What is Software Architecture and Architectural Style? While there is currently no single well-accepted definition of software architecture it is generally recognized that an architectural design of a system is concerned with describing its gross decomposition into computational elements and their interactions <ref> [PW92, GS93b, GP94] </ref>. Issues relevant to this level of design include organization of a system as a composition of components; global control structures; protocols for communication, synchronization, and data access; assignment of functionality to design elements; physical distribution; scaling and performance; dimensions of evolution; and selection among design alternatives.
Reference: [HN86] <author> A Nico. Habermann and David S. Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Trans actions on Software Engineering, </journal> <volume> SE-12(12):1117-1127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Most of the configuration rules are equally simple, although somesuch as prohibiting cyclescan be considerably more complex.) Semantic interpretation. In the prototype pipe-filter the semantics of filters is given by a simple, style-specific filter language, as was illustrated in Figure 3. The associated tool (based on Gan-dalf <ref> [HN86] </ref>) provides typechecking and other static analyses.
Reference: [HR90] <author> Barbara Hayes-Roth. </author> <title> Architectural foundations for real-time performance in intelligent agents. The Jour nal of Real-Time Systems, </title> <publisher> Kluwer Academic Publishers, </publisher> <pages> 2 99-125, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Other reference architectures include communication reference models (such as the ISO OSI 7-layer model [McC91]), some user interface frameworks [K + 91], and a large variety of domain-specific approaches in areas such as avionics [BV93] and mobile robotics <ref> [SLF90, HR90] </ref>. More specifically, we observe that architectural styles typically determine four kinds of properties [AAG93]: 1. They provide a vocabulary of design elements component and connector types such as pipes, filters, clients, servers, parsers, databases etc. 2.
Reference: [JC94] <author> G.R. Ribeiro Justo and P.R. Freire Cunha. </author> <title> Deadlock-free configuration programming. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: They define analyses that can be performed on systems built in that style. Examples include schedulability analysis for a style oriented toward real-time processing [Ves94] and deadlock detection for client-server message passing <ref> [JC94] </ref>. A 2 specific, but important, special case of analysis is code gen-eration: many styles support application generation (e.g., parser generators), or enable the reuse of code for certain shared facilities (e.g., user interface frameworks and support for communication between distributed processes).
Reference: [Jef92] <author> Kevin Jeffay. </author> <title> Scheduling sporadic tasks with shared resources in hard-real-time systems. </title> <booktitle> In Proceed ings of the 13th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 89-99, </pages> <address> Phoenix, AZ, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: We created an Aesop environment for an architectural style, developed at the University of North Carolina, that supports the design of such systems [Jef93]. Underlying the architectural style is a body of theory for analyzing real-time systems <ref> [Jef92] </ref>. This theory allows one to determine the (scheduling) feasibility of a system from the processing rates of its component tasks, rates of inputs from external devices, and shared resource loads. The theory also leads to heuristics for improving the schedulability of a system that is not feasible.
Reference: [Jef93] <author> Kevin Jeffay. </author> <title> The real-time producer/consumer paradigm: A paradigm for the construction of efficient, predictable real-time systems. </title> <booktitle> In Proceedings of the 1993 ACM/SIGAPP Symposium on Applied Computing, </booktitle> <pages> pages 796-804, </pages> <address> Indianapolis, IN, Febru-ary 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Within this general category are systems that must satisfy real-time scheduling constraints while processing their data. We created an Aesop environment for an architectural style, developed at the University of North Carolina, that supports the design of such systems <ref> [Jef93] </ref>. Underlying the architectural style is a body of theory for analyzing real-time systems [Jef92]. This theory allows one to determine the (scheduling) feasibility of a system from the processing rates of its component tasks, rates of inputs from external devices, and shared resource loads.
Reference: [K + 91] <author> Rudolf K. Keller et al. </author> <title> User interface development and software environments: </title> <booktitle> The Chiron-1 System. In Proc. 13th International Conference on Software Engineering, </booktitle> <year> 1991. </year>
Reference-contexts: A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator [PW92]. Other reference architectures include communication reference models (such as the ISO OSI 7-layer model [McC91]), some user interface frameworks <ref> [K + 91] </ref>, and a large variety of domain-specific approaches in areas such as avionics [BV93] and mobile robotics [SLF90, HR90]. More specifically, we observe that architectural styles typically determine four kinds of properties [AAG93]: 1.
Reference: [KFP88] <author> Gail E. Kaiser, Peter H. Feiler, and Steven S. Popovich. </author> <title> Intelligent assistance for software develop ment and maintenance. </title> <journal> IEEE Software, </journal> <pages> pages 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks [B + 88, Ger89], environment generators and toolkits [RT89, vLDD + 88, DGHKL84], process-oriented support <ref> [KFP88, T + 88] </ref>, etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment.
Reference: [KP88] <author> G.E. Krasner and S.T. Pope. </author> <title> A cookbook for using the model-view-controller user interface paradigm in Smalltalk-80. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 26-49, </pages> <note> August/September 1988. </note> <author> [LAK + 95] David C Luckham, Lary M. Augustin, John J. Ken-ney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture us ing Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> to appear, 1995. 13 </note>
Reference-contexts: However, good designers tend to reuse a set of established architectural organizations or architectural styles. Architectural styles fall into two broad categories. Idioms and patterns: This category includes global organizational structures, such as layered systems, pipe-filter systems, client-server organizations, blackboards, etc. It also includes localized patterns, such as model-view-controller <ref> [KP88] </ref> and many other object-oriented patterns [Coa92, GHJV94]. Reference models: This category includes system organizations that prescribe specific (often parameterized) configurations of components and interactions for specific application areas. A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator [PW92].
Reference: [LVC89] <author> Mark A. Linton, John M. Vlissides, and Paul R. Calder. </author> <title> Compusing user interfaces with interviews. </title> <journal> IEEE Computer, </journal> <volume> 22(2), </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: As was illustrated in the examples earlier (and explained in more detail later), this tool can be customized to provide style-specific displays and views. The current graphical editor is based on the UniDraw framework of InterViews <ref> [LVC89] </ref>, a C++-based GUI toolkit.
Reference: [LW93] <author> Barbara Liskov and Jeannette Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In Proceedings of ECOOP `93, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Rather than implying behavioral equivalence (as defined, for example, by Liskov and Wing <ref> [LW93] </ref>), we require that a subclass must provide strict subtyping behavior for operations that succeed, but they may introduce additional sources of failure. 6 To see why this is useful (and necessary), consider the operation addport, which adds a port to a component.
Reference: [Mak92] <author> Victor W. Mak. </author> <title> Connection: An inter-component communication paradigm for configurable distributed systems. </title> <booktitle> In Proceedings of the International Workshopon Configurable Distributed Systems, </booktitle> <address> Lon-don, UK, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Indeed, already we are beginning to see a proliferation of environments oriented around specific architectural styles. These environments typically provide tools to support particular architectural design paradigms and their associated development methods. Examples include architectures based on data flow <ref> [Mak92] </ref>, object-oriented design [R + 91], blackboard shells [Nii86], control systems [BV93], and reactive integration [Fro89]. Unfortunately each such environment is built as an independent, hand-crafted effortand at great cost.
Reference: [McC91] <author> Gary R. McClain, </author> <title> editor. Open Systems Interconnection Handbook. </title> <publisher> Intertext Publications McGraw-Hill Book Company, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator [PW92]. Other reference architectures include communication reference models (such as the ISO OSI 7-layer model <ref> [McC91] </ref>), some user interface frameworks [K + 91], and a large variety of domain-specific approaches in areas such as avionics [BV93] and mobile robotics [SLF90, HR90]. More specifically, we observe that architectural styles typically determine four kinds of properties [AAG93]: 1. <p> For example, even without giving details, characterization of a system as a client-server organization immediately conveys a strong image of the kinds of pieces and how they fit together. Fourth, use of standardized styles supports interoperability. Examples include CORBA object-oriented architecture [Cor91], the OSI protocol stack <ref> [McC91] </ref>, and event-based tool integration [Ger89]. Fifth, as noted above, by constraining the design space, an architectural style often permits specialized, style-specific analyses. For example, it is possible to analyze systems built in a pipe-filter style for schedulability, throughput, latency, and deadlock-freedom.
Reference: [MQR94] <author> Mark Moriconi, Xiaolei Qian, and R. A. Riemensh-neider. </author> <title> A formal approach to correct refinement of software architectures. </title> <type> Technical Report SRI-CSL-94-05, </type> <institution> SRI International Computer Science Laboratory, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In particular, the basic model of architectural representation (Section 4.3) and the elements of style description (Section 3) emerged as a result of our own experience with formalization of architecture. Moreover, tools that have resulted from efforts to formalize software architecture (e.g., architectural compatibility checkers [AG94b] and refinement tools <ref> [MQR94] </ref>) are natural candidates for tools in our style-specific environments. The third is research on languages for architectural description. These efforts have focused on providing general-purpose architectural description languages, linguistic mechanisms for component specification and generation, and tools to support these.
Reference: [MR88] <author> Naftaly H. Minsky and David Rozenshtein. </author> <title> A software development environment for law-governed systems. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <note> Published as SIG-PLAN NOTICES, 24(2). </note>
Reference-contexts: This makes it difficult to reason about a style on the basis of its Aesop definition, to tell whether two styles have conflicting constraints, or to modify the policies associated with constraint enforcement and tool invocation. Approaches based on explicit rules (e.g., as in Darwin <ref> [MR88] </ref>) or inter-object mediation (e.g., as in [SN92]) are attractive alternatives. * Control over supertype visibility. When a new style is defined, it is often the case that the types of design elements should be restricted to just those defined by the new style.
Reference: [Nii86] <author> H. Penny Nii. </author> <title> Blackboard systems Parts 1 & 2. </title> <journal> AI Magazine, </journal> <pages> 7 nos 3 (pp. 38-53) and 4 (pp. 62-69), </pages> <year> 1986. </year>
Reference-contexts: Indeed, already we are beginning to see a proliferation of environments oriented around specific architectural styles. These environments typically provide tools to support particular architectural design paradigms and their associated development methods. Examples include architectures based on data flow [Mak92], object-oriented design [R + 91], blackboard shells <ref> [Nii86] </ref>, control systems [BV93], and reactive integration [Fro89]. Unfortunately each such environment is built as an independent, hand-crafted effortand at great cost.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: While this editor is provided as a default, it is important to note that it runs as a separate tool, and can be easily replaced or augmented with other interface tools. (For example, we have recently added an alternative interface based on Tcl/Tk <ref> [Ous94] </ref>.) 4.3 Representing Architectural Designs Given a persistent object base for architectural representation, an important question is what are the types of objects that can be stored in the database.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Hence, our research is attacking a more general problem. The second area is research aimed at providing a rigorous basis for architectural specification and design <ref> [GN91, AG92, AAG93, PW92] </ref>. To the extent that such research clarifies the nature of architectural representation and the meaning of architectural style, our work builds on those results. <p> opportunities for design guidance, analysis, and synthesis. 3 What is Software Architecture and Architectural Style? While there is currently no single well-accepted definition of software architecture it is generally recognized that an architectural design of a system is concerned with describing its gross decomposition into computational elements and their interactions <ref> [PW92, GS93b, GP94] </ref>. Issues relevant to this level of design include organization of a system as a composition of components; global control structures; protocols for communication, synchronization, and data access; assignment of functionality to design elements; physical distribution; scaling and performance; dimensions of evolution; and selection among design alternatives. <p> Reference models: This category includes system organizations that prescribe specific (often parameterized) configurations of components and interactions for specific application areas. A familiar example is the standard organization of a compiler into lexer, parser, typer, optimizer, code generator <ref> [PW92] </ref>. Other reference architectures include communication reference models (such as the ISO OSI 7-layer model [McC91]), some user interface frameworks [K + 91], and a large variety of domain-specific approaches in areas such as avionics [BV93] and mobile robotics [SLF90, HR90].
Reference: [R + 91] <author> James Rumbaugh et al. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Indeed, already we are beginning to see a proliferation of environments oriented around specific architectural styles. These environments typically provide tools to support particular architectural design paradigms and their associated development methods. Examples include architectures based on data flow [Mak92], object-oriented design <ref> [R + 91] </ref>, blackboard shells [Nii86], control systems [BV93], and reactive integration [Fro89]. Unfortunately each such environment is built as an independent, hand-crafted effortand at great cost.
Reference: [Rei90] <author> S.P. Reiss. </author> <title> Connecting tools using message passing in the Field Environment. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: As a third example, Figure 4 illustrates an environment for an event-based style similar to Field <ref> [Rei90] </ref> or Softbench [Ger89]. 1 In this environment the components are active (event-announcing) objects, and the connectors are drawn as a kind of software bus along which events are announced and received by the components.
Reference: [RT89] <author> Tom Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Contstructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> [SDK + 95] Mary Shaw, </note> <author> Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: open architectural design environment from a description of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks [B + 88, Ger89], environment generators and toolkits <ref> [RT89, vLDD + 88, DGHKL84] </ref>, process-oriented support [KFP88, T + 88], etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment.
Reference: [Sha93] <author> Mary Shaw. </author> <title> Procedure calls are the assembly language of system interconnection: Connectors deserve first-class status. </title> <booktitle> In Proceedings of the Workshop on Studies of Software Design, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Operations supported by these classes include adding and removing ports to components, 3 An argument for representation of connectors as first class semantic entities is beyond the scope of this paper, but can be found elsewhere <ref> [AG94a, Sha93] </ref>. Also, for a more formal treatment of the architectural model see [AAG93]. 4 Note that bindingsare not connectors: connectors define paths of interaction, while bindings identify equivalences between two interface points.
Reference: [SLF90] <author> Reid Simmons, Long-Ji Lin, and Christopher Fedor. </author> <title> Autonomous task control for mobile robots. </title> <booktitle> In Proceedings of the 5th IEEE International Symposium on Intelligent Control, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Other reference architectures include communication reference models (such as the ISO OSI 7-layer model [McC91]), some user interface frameworks [K + 91], and a large variety of domain-specific approaches in areas such as avionics [BV93] and mobile robotics <ref> [SLF90, HR90] </ref>. More specifically, we observe that architectural styles typically determine four kinds of properties [AAG93]: 1. They provide a vocabulary of design elements component and connector types such as pipes, filters, clients, servers, parsers, databases etc. 2.
Reference: [SN92] <author> Kevin J. Sullivan and David Notkin. </author> <title> Reconciling environment integration and software evolution. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3) </volume> <pages> 229-268, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Approaches based on explicit rules (e.g., as in Darwin [MR88]) or inter-object mediation (e.g., as in <ref> [SN92] </ref>) are attractive alternatives. * Control over supertype visibility. When a new style is defined, it is often the case that the types of design elements should be restricted to just those defined by the new style.
Reference: [T + 88] <editor> Richard N. Taylor et al. </editor> <booktitle> Foundations for the Arcadia environment architecture. In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <note> Published as SIGPLAN NOTICES, 24(2). </note>
Reference-contexts: of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks [B + 88, Ger89], environment generators and toolkits [RT89, vLDD + 88, DGHKL84], process-oriented support <ref> [KFP88, T + 88] </ref>, etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment.
Reference: [Ves94] <author> Steve Vestal. </author> <title> Mode changes in real-time architecture description language. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: They define a semantic interpretation, whereby compositions of design elements, suitably constrained by the configuration rules, have well-defined meanings. 4. They define analyses that can be performed on systems built in that style. Examples include schedulability analysis for a style oriented toward real-time processing <ref> [Ves94] </ref> and deadlock detection for client-server message passing [JC94]. A 2 specific, but important, special case of analysis is code gen-eration: many styles support application generation (e.g., parser generators), or enable the reuse of code for certain shared facilities (e.g., user interface frameworks and support for communication between distributed processes). <p> Applications are integrated into a system by wrappping them with an interface that permits them to interact with other tools via event broadcast. Similarly, the Honeywell MetaH language and supporting development tools provide an architectural description language for real-time, embedded avionics applications <ref> [Ves94] </ref>. The tools check a system description for schedulability and other properties and generate the glue code that handles real-time process dispatching, communication, and resource synchronization.
Reference: [vLDD + 88] <author> A. van Lamsweerrde, B. Delcourt, E. Delor, M. C. Schayes, and R. Champagne. </author> <title> Generic lifecycle support in the ALMA environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 720-741, </pages> <month> June </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: open architectural design environment from a description of a specific architectural style. 2 Related Work 2.1 Software Development Environments For the past decade there has been considerable research and development in the area of automated support for software development: tool integration frameworks [B + 88, Ger89], environment generators and toolkits <ref> [RT89, vLDD + 88, DGHKL84] </ref>, process-oriented support [KFP88, T + 88], etc. These facilities typically provide generic support for some aspects of software development, and can be specialized or instantiated for a particular development environment.
References-found: 42

