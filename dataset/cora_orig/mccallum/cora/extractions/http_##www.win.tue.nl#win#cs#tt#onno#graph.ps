URL: http://www.win.tue.nl/win/cs/tt/onno/graph.ps
Refering-URL: http://www.win.tue.nl/win/cs/tt/onno/
Root-URL: http://www.win.tue.nl
Title: Drawing Execution Graphs by Parsing  
Author: G.A.M. de Bruyn O.S. van Roosmalen 
Date: October 4, 1994  
Abstract: In this paper we present an algorithm for drawing execution graphs. Such graphs represent the control flow in a program. Because a program is constructed according to a grammar, this is reflected in the corresponding execution graph. Therefore, we introduce graph production rules that are based on generally used programming language constructs. Each rule is applied to a certain class of topologies of the graph. By parsing an execution graph according to these rules a visually appealing layout of the graph can be generated. We take into account that the nodes in a graph can have variable sizes. 
Abstract-found: 1
Intro-found: 1
Reference: [Bloe 93] <author> A. Bloesch, </author> <title> Aesthetic Layout of Generalized Trees, </title> <journal> Software Practice and Experience, </journal> <year> 1993, </year> <pages> pp. 817-827 </pages>
Reference-contexts: Reingold and Tilford [Rein 81] added that isomorphic subtrees contain the same drawings, and symmetric subtrees have got mirror image drawings. Generalizations for n-ary trees are made by Walker [Walk 90] and Bloesch (allowing also variable-sized nodes) <ref> [Bloe 93] </ref>. In all these algorithms two traversals through the graph are needed to produce a drawing. Hierarchical Graphs: Electronic circuit layout graphs and visualization of data struc tures are examples of hierarchical graphs. These graphs have the common property to be directed and acyclic.
Reference: [Bruy 93] <author> G.A.M. de Bruyn, </author> <title> Graph Viewer for DEDOS applications, </title> <type> Master's thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: Execution graphs are such a kind of graphs. They express all possible execution paths through a computer program cq. process. Programming language constructs are reflected in the structure of the graph. An execution graph viewer <ref> [Bruy 93] </ref> has been developed at Eindhoven University of Technology as part of the DEpendable Distributed Operating System (DEDOS) project [Hamm 94]. This operating system is being developed as a platform for the execution of distributed real-time applications. <p> They are discussed in more detail in <ref> [Bruy 93] </ref>. 4.5 Aesthetic Rules The aesthetic rules (in order of priority) are: AR1 Center a node over its predecessors and successors. AR2 Put a node as close as possible below its strong predecessors. AR3 Minimize the number of bends of an edge. AR4 Minimize the number of edge crossings. <p> We don't treat this here. For more about this we refer to <ref> [Bruy 93] </ref> G u;v : ? @ oe ? G u+1;w r dn Let G u;v be a SEG, where 0 u &lt; v N . Let n = GN [u] and BSEL (n) and :BREP (n). So G u;v starts with a selection. <p> Although we have applied the method to execution graphs, considering a limited number of programming language constructs, the method is more generally applicable. Not only additional language constructs leading to more variaty in the graph toplogy can be included <ref> [bruy 93] </ref>, but also the drawing of other types of graphs based on a grammar can be tackled in this fashion.
Reference: [Hamm 94] <author> D.K Hammer, E.J. Luit, O.S. van Roosmalen, P.D.V. van der Stok and J.P.C. Verhoosel, DEDOS: </author> <title> A Distributed Real-Time Environment, </title> <note> accepted for publication in Parallel & distributed Technology, </note> <month> October </month> <year> 1994 </year>
Reference-contexts: They express all possible execution paths through a computer program cq. process. Programming language constructs are reflected in the structure of the graph. An execution graph viewer [Bruy 93] has been developed at Eindhoven University of Technology as part of the DEpendable Distributed Operating System (DEDOS) project <ref> [Hamm 94] </ref>. This operating system is being developed as a platform for the execution of distributed real-time applications. As a support for off-line scheduling of hard real-time processes, the execution graph viewer helps the programmer to find bottle necks that prohibit a feasible schedule.
Reference: [Rein 81] <author> E.M. Reingold, J. S. Tilford, </author> <title> Tidier Drawings of Trees, </title> <journal> IEEE Transactions On Software Engineering, </journal> <volume> Vol. SE-7, No2., </volume> <year> 1981, </year> <pages> pp. 223-227 </pages>
Reference-contexts: In the algorithm for binary trees presented by Wetherell and Shannon [Weth 79] nodes are pushed as much to the left as possible, provided they are correctly placed with respect to their fathers and children. Reingold and Tilford <ref> [Rein 81] </ref> added that isomorphic subtrees contain the same drawings, and symmetric subtrees have got mirror image drawings. Generalizations for n-ary trees are made by Walker [Walk 90] and Bloesch (allowing also variable-sized nodes) [Bloe 93].
Reference: [Sugi 81] <author> K. Sugiyama, S. Tagawa, M. </author> <title> Toda, Methods for Visual Understanding of Hierarchical System Structures, </title> <journal> IEEE Transactions On Systems, Man And Cy-bernatics, </journal> <volume> Vol. SMC-11, No. 2, </volume> <month> February, </month> <year> 1981, </year> <pages> pp. 109-125. </pages>
Reference-contexts: Hierarchical Graphs: Electronic circuit layout graphs and visualization of data struc tures are examples of hierarchical graphs. These graphs have the common property to be directed and acyclic. Algorithms to compute a nice drawing are complex. Most of them are heuristic and derived from the algorithm of Sugiyama <ref> [Sugi 81] </ref>. They basically consist of the following three phases: First, levels are assigned to nodes. The levels relate to a vertical displacement. For each long edge (i.e. an edge that spans several levels) a so-called dummy node is introduced for each level that is crossed.
Reference: [Tama 88] <author> R. Tamassia, G. Di Battista and Carlo Batini, </author> <title> Automatic Graph Drawing and Readability of Diagrams, </title> <journal> IEEE Transactions On Systems, Man And Cy-bernatics, Vol.18, </journal> <volume> No. 1, </volume> <month> February, </month> <year> 1988, </year> <pages> pp. 61-76. </pages>
Reference: [Walk 90] <author> J.Q. Walker II, </author> <title> A Node-positioning Algorithm for General Trees, </title> <journal> Software-Practice And Experience. </journal> <volume> Vol. 20(7), </volume> <year> 1990, </year> <pages> pp. 685-705 </pages>
Reference-contexts: Reingold and Tilford [Rein 81] added that isomorphic subtrees contain the same drawings, and symmetric subtrees have got mirror image drawings. Generalizations for n-ary trees are made by Walker <ref> [Walk 90] </ref> and Bloesch (allowing also variable-sized nodes) [Bloe 93]. In all these algorithms two traversals through the graph are needed to produce a drawing. Hierarchical Graphs: Electronic circuit layout graphs and visualization of data struc tures are examples of hierarchical graphs.
References-found: 7

