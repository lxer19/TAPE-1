URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1997/TR32.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Compositional Design of Multitolerant Repetitive Byzantine Agreement 1  
Author: Sandeep S. Kulkarni Anish Arora 
Address: Columbus, OH 43210 USA  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: We illustrate in this paper a compositional and stepwise method for designing programs that offer a potentially unique tolerance to each of their fault-classes. More specifically, our illustration is a design of a repetitive agreement program that offers two tolerances: (a) it masks the effects of Byzantine failures and (b) it is stabilizing in the presence of transient and Byzantine failures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and S. S. Kulkarni. </author> <title> Component-based design of multitolerance. </title> <type> Technical Report OSU-CISRC TR37, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Revised for IEEE Transactions on Software Engineering. </note>
Reference-contexts: Designing dependable systems is difficult, essentially because some desired dependability property, say, availability in the presence of faults, may interfere with some other desired dependability property, say, security in presence of intrusions. To effectively formulate multiple dependability properties, we have proposed the concept of multitol-erance <ref> [1] </ref>: Each source of undependability is formulated as a class of "faults" and each dependability property is formulated as a type of "tolerance". Thus, multitolerance refers to the ability of a system to tolerate multiple classes of faults, each in a possibly different way. <p> Thus, multitolerance refers to the ability of a system to tolerate multiple classes of faults, each in a possibly different way. Moreover, to effectively design multitolerant systems, we have proposed a component-based method <ref> [1] </ref>: The method, explained briefly, starts with an intolerant system and adds a set of components, one for each desired type of tolerance. Thus, the complexity of multitolerant system design is reduced to that of designing the components and of correctly adding them to the intolerant system. <p> While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of <ref> [1] </ref>. The formalization builds upon previous work on compositionality, e.g. [6, 7, 8]. We found that the method of adding a component to provide each desired tolerance property facilitated the solution of a multitolerance problem. <p> Analogous to the compositional design of large correctors, large detectors can be designed in a stepwise and hierarchical fashion, by parallel and/or sequential composition of small detectors. The interested reader is referred to a companion paper <ref> [1] </ref> for an indepth study of detectors and correctors. Self-tolerances of components.
Reference: [2] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1982. </year>
Reference-contexts: The resulting multitolerant program is, to the best of our knowledge, the first program for repetitive agreement that is both masking tolerant and stabilizing tolerant. (Previous designs are only masking tolerant, e.g. <ref> [2] </ref>, or only nonmasking tolerant [3], e.g. [4], but none is multitolerant. In fact, we are not aware of any previous design that is stabilizing tolerant.) The rest of the paper is organized as follows. In Section 2, we recall the problem of repetitive agreement. <p> compositionally design a masking as well as stabilizing tolerant repetitive agreement program, let us recall the wellknown fact that for repetitive agreement to be masking tolerant it is both necessary and sufficient for the system to have at least 3t+1 processes, where t is the total number of Byzantine processes <ref> [2] </ref>. Therefore, for ease of exposition, we will initially restrict our attention, in Sections 3-5, to the special case where the total number of processes in the system (including g) is 4 and, hence, t is 1. <p> of the d values at the non-general processes.) In other words, C (j) itself contains a repetitive agreement program ! With this insight, we are now ready to generalize program SMR to handle the multiple Byzantine faults, based on an idea that is essentially due to Lamport, Shostak, and Pease <ref> [2] </ref>. (Our generalization, of course, is distinguished by being multitolerant.) Let g denote the general process, X denote the set of non-general processes, t denote the maximum number of Byzantine processes. <p> The proof of masking tolerance is similar to the one in <ref> [2] </ref>. 7 Refining the Atomicity While Preserving Multitolerance Program R, the masking component, and the stabilizing component all have read-and-write atomicity, i.e., where each action of a process can atomically read the variables of other processes and updates the variables of that process.
Reference: [3] <author> A. Arora and S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. Revised for IEEE Transactions on Software Engineering. </title> <booktitle> A preliminary version appears in the Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </booktitle> <pages> 174-185, </pages> <year> 1995. </year>
Reference-contexts: The resulting multitolerant program is, to the best of our knowledge, the first program for repetitive agreement that is both masking tolerant and stabilizing tolerant. (Previous designs are only masking tolerant, e.g. [2], or only nonmasking tolerant <ref> [3] </ref>, e.g. [4], but none is multitolerant. In fact, we are not aware of any previous design that is stabilizing tolerant.) The rest of the paper is organized as follows. In Section 2, we recall the problem of repetitive agreement. <p> Alternative ways are exemplified by designs that yield self-checking, self-stabilizing, and inherently fault-tolerant programs. 10 Stepwise design of tolerances. The addition of multiple detector and corrector components for, say, adding masking tolerance, may be simplified by using a stepwise appraoch <ref> [3] </ref>: For instance, we may first augment the program with detectors and then augment the resulting fail-safe tolerant program with correctors. Alternatively, we may first augment the program with correctors and then augment the resulting nonmasking tolerant program with detectors.
Reference: [4] <author> Y. Zhao and F. B. Bastani. </author> <title> A self-adjusting algorithm for Byzantine agreement. </title> <journal> Distributed Computing, </journal> <volume> 5 </volume> <pages> 219-226, </pages> <year> 1992. </year>
Reference-contexts: The resulting multitolerant program is, to the best of our knowledge, the first program for repetitive agreement that is both masking tolerant and stabilizing tolerant. (Previous designs are only masking tolerant, e.g. [2], or only nonmasking tolerant [3], e.g. <ref> [4] </ref>, but none is multitolerant. In fact, we are not aware of any previous design that is stabilizing tolerant.) The rest of the paper is organized as follows. In Section 2, we recall the problem of repetitive agreement. <p> Alternative tolerances to Byzantine failures. In the presence of Byzantine failures alone, SM R satisfies the specification of repetitive agreement in each round. The reader may wonder whether this strong guarantee is true of every repetitive agreement program that tolerates Byzantine failures. The answer is negative: Zhao and Bastani <ref> [4] </ref> have presented a program that is nonmasking tolerant to Byzantine failures, i.e., that could violate the specification in some finite number of rounds only. Moreover, we present here a program that is stabilizing tolerant |but not masking tolerant| to Byzantine failure.
Reference: [5] <author> A. Arora and M. G. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <year> 1994. </year> <booktitle> Extended abstract in Proceedings of the Tenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <pages> 316-331, </pages> <year> 1990. </year>
Reference-contexts: In this section, we show that R and the tolerance components can all be refined into read-or-write atomicity, i.e., where each action of a process can either atomically read the variables of some other process or atomically write its own variables but not both. We choose a standard refinement <ref> [5] </ref>: Introduce in each process j a copy of every variable that it reads from another process. For each of these variables, add an action to j that asynchronously reads that variable into the copy. <p> the set of possible sequence numbers has to be increased to f0::K 1g where K 4. (This claim follows from the fact that between g and j there are four sequence numbers, namely, sn:g, sn:j, and the copies of sn:g and sn:j at j and g respectively; for details, see <ref> [5] </ref>.) Moreover, a deadlock has to be avoided in the states of refined version of R where sn:j 6= sn:g and sn:j 6= sn:g 1. (These states do not exist in R since its sequence numbers are either 0 or 1.) Therefore, to preserve stabilization, we need to add actions to
Reference: [6] <author> K. Apt, N. Francez, and W.-P. de Roever. </author> <title> A proof system for communicating sequential processes. </title> <journal> ACM transactions on Programming Languages and Systems, </journal> <pages> pages 359-385, </pages> <year> 1980. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [6, 7, 8] </ref>. We found that the method of adding a component to provide each desired tolerance property facilitated the solution of a multitolerance problem.
Reference: [7] <author> H. Schepers. </author> <title> Fault Tolerance and Timing of Distributed Systems: Compositional specification and verification. </title> <type> PhD thesis, </type> <institution> Eindhoven University, </institution> <year> 1994. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [6, 7, 8] </ref>. We found that the method of adding a component to provide each desired tolerance property facilitated the solution of a multitolerance problem.
Reference: [8] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [6, 7, 8] </ref>. We found that the method of adding a component to provide each desired tolerance property facilitated the solution of a multitolerance problem.
References-found: 8

