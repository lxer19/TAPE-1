URL: http://www.math.luc.edu/~laufer/ftp/papers/interactions.ps.gz
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fgb, russog@cs.purdue.edu  laufer@math.luc.edu  
Title: On the Interaction of Object-Oriented Design Patterns and Programming Languages  
Author: Gerald Baumgartner Konstantin Laufer flfl Vincent F. Russo 
Date: August 5, 1996  
Address: West Lafayette, IN 47907, U.S.A.  Chicago, IL 60626, U.S.A.  
Affiliation: Department of Computer Sciences Purdue University  flfl Department of Mathematical and Computer Sciences Loyola University  
Abstract: Design patterns are distilled from many real systems to catalog common programming practice. However, some object-oriented design patterns are distorted or overly complicated because of the lack of supporting programming language constructs or mechanisms. For this paper, we have analyzed several published design patterns looking for idiomatic ways of working around constraints of the implementation language. From this analysis, we lay a groundwork of general-purpose language constructs and mechanisms that, if provided by a statically typed, object-oriented language, would better support the implementation of design patterns and, transitively, benefit the construction of many real systems. In particular, our catalog of language constructs includes subtyping separate from inheritance, lexically scoped closure objects independent of classes, and multimethod dispatch. The proposed constructs and mechanisms are not radically new, but rather are adopted from a variety of languages and programming language research and combined in a new, orthogonal manner. We argue that by describing design patterns in terms of the proposed constructs and mechanisms, pattern descriptions become simpler and, therefore, accessible to a larger number of language communities. Constructs and mechanisms lacking in a particular language can be implemented using paradigmatic idioms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <editor> In Walter Olthoff, editor, </editor> <booktitle> Proceedings of the ECOOP '95 European Conference on Object-Oriented Programming, volume 952 of Lecture Notes in Computer Science, </booktitle> <pages> pages 145-167, </pages> <address> Aarhus, Denmark, 7-11 August 1995. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York. </address> <month> 32 </month>
Reference-contexts: For type-checking inheritance in the presence of selftype, the compiler has to employ the matching algorithm as described in <ref> [12, 1] </ref>. The implementation of interfaces with structural conformance is straightforward and has been discussed in the literature [6, 7]. For an interface declaration, the compiler does not generate any code but only enters the interface type into the symbol table.
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: Like a class instance, a classless object is simply allocated on the heap, or in static memory if the object is in global scope, and initialized. A closure object, like a function closure, has to contain a static link, i.e., a pointer to the enclosing function or method scope <ref> [2] </ref>. The compilation of metaclass objects is no different than that of other objects. Dispatching a multimethod with n arguments requires an n-dimensional table lookup. For multimethods in a class, this lookup could be combined with the dispatch on the receiver of the method.
Reference: [3] <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proceedings of the OOPSLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 161-168, </pages> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 25(10), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald [8, 9] has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods. POOL-I <ref> [3] </ref> has interfaces separate from classes and structural subtyping but does not have classless objects, metaclass objects, or multimethod dispatch.
Reference: [4] <author> Eric Amiel, Olivier Gruber, and Eric Simon. </author> <title> Optimizing multi-method dispatch using compressed dispatch tables. </title> <booktitle> In Proceedings of the OOPSLA '94 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 244-258, </pages> <address> Portland, Oregon, </address> <month> 23-27 October </month> <year> 1994. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 29(10), </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: Because of this and since such tables could become very large, it is preferable to keep the multimethod dispatch separate from the dispatch on the receiver at the cost of an additional memory reference. Further techniques for reducing table sizes are discussed in <ref> [4] </ref>. Run-Time Type Identification Since inheritance does not define a subtype relationship, an interface table uniquely identifies an interface-class pair, or an interface-object pair in case of a classless object.
Reference: [5] <author> Henry G. Baker. </author> <title> Iterators: Signs of weakness in object-oriented languages. </title> <journal> ACM OOPS Messenger, </journal> <volume> 4(3) </volume> <pages> 18-25, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Internal iterators do not have these problems, but are hard to write in languages like C ++ because of the lack of lexical scoping. External iterators are mostly a workaround for the lack of internal iterators in such languages <ref> [5] </ref>. The only other advantage of external iterators is that they allow the user to control the progress of the iteration. This is useful in situations in which it is not desirable to traverse an entire collection at once (see also the pairwise iteration example in Section 7).
Reference: [6] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Signatures: A language extension for improving type abstraction and subtype polymorphism in C ++ . Software|Practice & Experience, </title> <booktitle> 25(8) </booktitle> <pages> 863-889, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: This solution is workable in most object-oriented languages but introduces the added burden of having to code the forwarding explicitly along with the associated run-time overhead. In <ref> [6, 7] </ref>, a conservative extension to C ++ is proposed that gives both syntactic and semantic support for separating interfaces from implementations. <p> For type-checking inheritance in the presence of selftype, the compiler has to employ the matching algorithm as described in [12, 1]. The implementation of interfaces with structural conformance is straightforward and has been discussed in the literature <ref> [6, 7] </ref>. For an interface declaration, the compiler does not generate any code but only enters the interface type into the symbol table. For an interface pointer/reference initialization or assignment, the compiler verifies that the RHS type conforms to the LHS type and, if necessary, generates a dispatch table.
Reference: [7] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Implementing signatures for C ++ . ACM Transactions on Programming Languages and Systems, </title> <note> 1996. To appear. </note>
Reference-contexts: This solution is workable in most object-oriented languages but introduces the added burden of having to code the forwarding explicitly along with the associated run-time overhead. In <ref> [6, 7] </ref>, a conservative extension to C ++ is proposed that gives both syntactic and semantic support for separating interfaces from implementations. <p> For type-checking inheritance in the presence of selftype, the compiler has to employ the matching algorithm as described in [12, 1]. The implementation of interfaces with structural conformance is straightforward and has been discussed in the literature <ref> [6, 7] </ref>. For an interface declaration, the compiler does not generate any code but only enters the interface type into the symbol table. For an interface pointer/reference initialization or assignment, the compiler verifies that the RHS type conforms to the LHS type and, if necessary, generates a dispatch table.
Reference: [8] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: For example, C ++ [36, 27] and Modula-3 [16] lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald <ref> [8, 9] </ref> has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods. POOL-I [3] has interfaces separate from classes and structural subtyping but does not have classless objects, metaclass objects, or multimethod dispatch.
Reference: [9] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and abstract types in emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: For example, C ++ [36, 27] and Modula-3 [16] lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald <ref> [8, 9] </ref> has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods. POOL-I [3] has interfaces separate from classes and structural subtyping but does not have classless objects, metaclass objects, or multimethod dispatch.
Reference: [10] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp object system specification: X3J13 document 88-002R. </title> <journal> ACM SIGPLAN Notices, 23(Special Issue), </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS <ref> [10, 53, 47] </ref>, and Cecil [18, 19]. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> Dispatch based on multiple arguments would allow defining the new method without modifying the class hierarchy by dispatching on an argument whose type is a class from this hierarchy. Methods whose selection is based on several arguments are called multimethods as supported in CLOS <ref> [10, 53, 47] </ref> and Cecil [18, 19]. Typical multimethods include binary arithmetic operations, binary equality testing, and simultaneous iteration over several collections.
Reference: [11] <author> Thomas M. Breuel. </author> <booktitle> Lexical closures for C ++ . In Proceedings of the 1988 USENIX C ++ Conference, </booktitle> <pages> pages 293-304, </pages> <address> Denver, Colorado, </address> <month> 17-21 October </month> <year> 1988. </year> <institution> USENIX Association. </institution>
Reference-contexts: Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. Breuel <ref> [11] </ref> describes an extension of C ++ that supports efficient named lexically scoped functions. We propose further generalizing those ideas by introducing lexically scoped closure objects. We use the object construct previously introduced in Section 4 to express closure objects. A closure object can be named or anonymous. <p> MyClass * receiver = new MyClass; // ... void aCommand () - receiver-&gt;MyAction (); - // ... otherFunction (aCommand); Uses Workarounds for the lack of lexical closures in a language are as pervasive [24, 39] as attempts to introduce them into languages that lack them <ref> [11, 26] </ref>.
Reference: [12] <author> Kim B. Bruce. </author> <title> Typing in object-oriented languages: Achieving expressibility and safety. </title> <journal> ACM Computing Surveys, </journal> <note> 1996. To appear. </note>
Reference-contexts: For type-checking inheritance in the presence of selftype, the compiler has to employ the matching algorithm as described in <ref> [12, 1] </ref>. The implementation of interfaces with structural conformance is straightforward and has been discussed in the literature [6, 7]. For an interface declaration, the compiler does not generate any code but only enters the interface type into the symbol table.
Reference: [13] <author> Frank Buschmann and Regine Meunier. </author> <title> A system of patterns. In Coplien and Schmidt [25], </title> <booktitle> chapter 17, </booktitle> <pages> pages 325-343. </pages>
Reference-contexts: Explicit storage management also complicates several other idioms in Coplien's collection. In a language with a garbage-collected heap, these idioms would be greatly simplified or not needed at all. Observe that not all design patterns are influenced by their implementation language. Some patterns, such as Producer-Consumer <ref> [13, 41] </ref>, can be described independent of the programming language. The reason the Producer-Consumer pattern is language-independent is that the language constructs and mechanism it relies on (arrays or lists and functions) are basic enough that they can be found in any language.
Reference: [14] <author> Roy H. Campbell and A. Nico Habermann. </author> <title> The specification of process synchronization by path expressions. </title> <editor> In E. Gelenbe and Claude Kaiser, editors, </editor> <booktitle> Proceedings of the International Symposium on Operating Systems, volume 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102, </pages> <address> Rocquencourt, France, 23-25 April 1974. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York. </address>
Reference-contexts: Second, virtual method dispatch tables are no longer needed. Third, object migration in a distributed environment is easier to implement since all the code that needs to be shipped is readily available without walking the class hierarchy. Forth, generating code for path expressions <ref> [14] </ref> or similar mechanisms for synchronizing concurrent method calls becomes simpler since a method might have different synchronization constraints depending on the class of the receiver. Finally, the semantics are cleaner than with the complicated table lookup in C ++ .
Reference: [15] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proceedings of the OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 24(10), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: present a complete language design; rather, code samples and illustrations of proposed language constructs are presented in pseudo-C ++ syntax for illustrative purposes. 2 Explicit Interface Descriptions It is often desirable to develop a hierarchy of interface types independent from the class hierarchy, which provides concrete implementations of these interfaces <ref> [15, 22] </ref>. With respect to design, two major problems arise when class inheritance is co-opted into implementing both the interface and implementation hierarchies for a system.
Reference: [16] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-43, </pages> <month> August </month> <year> 1992. </year> <month> 33 </month>
Reference-contexts: A Singleton is a class with only one instance and code that ensures that no other instances will be created. If a language allows the definition of a single object without a class, or if it offers a module construct as in Modula-3 <ref> [16] </ref>, there is no need for the Singleton pattern. <p> Mixin inheritance simplifies the reuse of the components whose public methods should be made available. The standard mechanisms used for this style of code reuse is multiple inheritance of (mostly) non-virtual methods. The import statement in Modula-3 <ref> [16] </ref> serves a similar purpose, except that imported functions are not automatically re-exported. Theft In some cases, a class might only inherit part of its superclass (es) or rename inherited methods purely for reusing existing code without intending any semantic relationship between the superclass (es) and the subclass. <p> Packages The object construct described above is related to module constructs as found in Modula-3 <ref> [16] </ref> or ML [43, 42]. Unlike modules in these languages, objects are first-class values, i.e., they can be passed to and returned from functions or assigned to variables. The advantage of modules is that they allow packaging and exporting of types in addition to variables and functions. <p> Most contemporary statically typed object-oriented languages do not have closures and have only a rudimentary form of packages. For example, C ++ [36, 27] and Modula-3 <ref> [16] </ref> lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald [8, 9] has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods.
Reference: [17] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 182-192, </pages> <address> San Francisco, California, </address> <month> 22-24 June </month> <year> 1992. </year> <title> Association for Computing Machinery. Lisp Pointers, </title> <type> 5(1), </type> <month> January-March </month> <year> 1992. </year>
Reference-contexts: Using C ++ -like syntax, multimethods can be defined as methods in a class or object. We suggest to perform dynamic dispatching on all arguments whose type is a class reference or class pointer. Unlike static overloading resolution, dispatching is performed at run-time, although multimethods can be statically typed <ref> [50, 17, 20] </ref>. By combining multimethods and packages, we can simplify the abstract syntax tree example by bundling the visitation methods for each tree operation in a package. object TypeChecker - public: void Visit (AssignmentNode & n) - // ...
Reference: [18] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In Ole Lehr mann Madsen, editor, </editor> <booktitle> Proceedings of the ECOOP '92 European Conference on Object-Oriented Programming, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56, </pages> <address> Utrecht, The Netherlands, 29 June - 3 July 1992. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York. </address>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS [10, 53, 47], and Cecil <ref> [18, 19] </ref>. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> Dispatch based on multiple arguments would allow defining the new method without modifying the class hierarchy by dispatching on an argument whose type is a class from this hierarchy. Methods whose selection is based on several arguments are called multimethods as supported in CLOS [10, 53, 47] and Cecil <ref> [18, 19] </ref>. Typical multimethods include binary arithmetic operations, binary equality testing, and simultaneous iteration over several collections. Examples Multimethods are not directly supported by single-dispatching object-oriented languages, but can be simulated by invoking several methods such that each argument that participates in method selection acts as the receiver once. <p> Such a construct allows the programmer to indicate on which arguments method selection should be based. Instead of specifying method lookup procedurally (as in the idiom), multimethods provide a way of specifying method lookup declaratively <ref> [18] </ref>. We argue that multimethods make it easy to define new visitation methods or extend the element and visitor hierarchies alike. Using C ++ -like syntax, multimethods can be defined as methods in a class or object. <p> Encapsulation problems as encountered in the Visitor pattern thus no longer occur. Uses Typical uses of multimethods include binary arithmetic operations, binary equality testing, simultaneous iteration over several collections, and displaying a shape on an output device (see also <ref> [18] </ref>). For example, a multimethod for iterating simultaneously over two collections could be defined as follows. This method would traverse the two collections in lock step and apply a visitation function to each pair of items visited in each step.
Reference: [19] <author> Craig Chambers. </author> <title> The Cecil language: Specification and rationale. </title> <type> Technical Report 93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, Washington, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS [10, 53, 47], and Cecil <ref> [18, 19] </ref>. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> Dispatch based on multiple arguments would allow defining the new method without modifying the class hierarchy by dispatching on an argument whose type is a class from this hierarchy. Methods whose selection is based on several arguments are called multimethods as supported in CLOS [10, 53, 47] and Cecil <ref> [18, 19] </ref>. Typical multimethods include binary arithmetic operations, binary equality testing, and simultaneous iteration over several collections. Examples Multimethods are not directly supported by single-dispatching object-oriented languages, but can be simulated by invoking several methods such that each argument that participates in method selection acts as the receiver once.
Reference: [20] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and modules for multimethods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(6) </volume> <pages> 805-843, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Using C ++ -like syntax, multimethods can be defined as methods in a class or object. We suggest to perform dynamic dispatching on all arguments whose type is a class reference or class pointer. Unlike static overloading resolution, dispatching is performed at run-time, although multimethods can be statically typed <ref> [50, 17, 20] </ref>. By combining multimethods and packages, we can simplify the abstract syntax tree example by bundling the visitation methods for each tree operation in a package. object TypeChecker - public: void Visit (AssignmentNode & n) - // ... <p> Therefore, determining statically whether a multimethod is defined for all parameter type combinations is slightly more complicated than in systems with an explicit subtype hierarchy such as Cecil <ref> [20] </ref> and would require linker support. The necessary information could be collected by the linker from the compiler-generated method dispatch tables. To maintain an object-oriented or data-abstraction-oriented view of multimethods, we could conceptually consider a multimethod as part of each class for which the method dispatches. <p> It is, therefore, possible for the compiler to test whether a multimethod is defined for all possible argument combinations. For example, Cecil <ref> [20] </ref> allows the definitions of a multimethod g to be spread across multiple modules. To resolve any possible inconsistencies between independent modules, the programmer has to write a resolving module that extends all modules containing definitions of g and adds any missing definitions.
Reference: [21] <author> Marshall P. Cline and Greg A. Lomow. C ++ FAQs: </author> <title> Frequently Asked Questions. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: The only case where interface conformance cannot be used instead of class inheritance to define a subtype relationship is when the subclass overrides a non-virtual method of the superclass. This use of inheritance, however, is usually considered a programming error <ref> [21] </ref>. If inheritance does not define a subtype relationship, it can be made more flexible for code reuse purposes in two ways. By introducing the notion of selftype, it is possible to override methods covariantly. Furthermore, private inheritance can be used more frequently for code reuse.
Reference: [22] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, California, </address> <month> 17-19 January </month> <year> 1990. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: present a complete language design; rather, code samples and illustrations of proposed language constructs are presented in pseudo-C ++ syntax for illustrative purposes. 2 Explicit Interface Descriptions It is often desirable to develop a hierarchy of interface types independent from the class hierarchy, which provides concrete implementations of these interfaces <ref> [15, 22] </ref>. With respect to design, two major problems arise when class inheritance is co-opted into implementing both the interface and implementation hierarchies for a system. <p> To motivate the limitation of public inheritance, suppose we have an implementation of coordinate points and would like to extend them to color points (this example is based on examples from <ref> [23, 22] </ref>). Class ColorPoint inherits class Point, adds color support, and redefines equality to compare the color as well. class Point - protected: int x, y; public: of code reuse seem to be considered directly supported by a language's inheritance mechanism.
Reference: [23] <author> William R. Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proceedings of the OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 24(10), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: To motivate the limitation of public inheritance, suppose we have an implementation of coordinate points and would like to extend them to color points (this example is based on examples from <ref> [23, 22] </ref>). Class ColorPoint inherits class Point, adds color support, and redefines equality to compare the color as well. class Point - protected: int x, y; public: of code reuse seem to be considered directly supported by a language's inheritance mechanism.
Reference: [24] <author> James O. Coplien. </author> <title> Advanced C ++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1992. </year>
Reference-contexts: For examples of patterns that work around a defect in the programming language, consider that most of the complexity of Coplien's Handle-Body and Envelope-Letter idioms <ref> [24] </ref> is due to the need to implement reference counting since C ++ [36] lacks garbage collection. Explicit storage management also complicates several other idioms in Coplien's collection. In a language with a garbage-collected heap, these idioms would be greatly simplified or not needed at all. <p> Bridging Programming Practice and Language Theory We have analyzed design patterns from several sources <ref> [28, 25, 49, 24] </ref> and looked for idiomatic ways of working around constraints of the implementation language. Based on this analysis, we catalog general-purpose language constructs and mechanisms that, if provided by a statically typed, object-oriented language, would benefit design patterns and, transitively, a large body of real systems. <p> This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS [10, 53, 47], and Cecil [18, 19]. Coplien <ref> [24] </ref> and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> The function itself can be invoked from elsewhere. MyClass * receiver = new MyClass; // ... void aCommand () - receiver-&gt;MyAction (); - // ... otherFunction (aCommand); Uses Workarounds for the lack of lexical closures in a language are as pervasive <ref> [24, 39] </ref> as attempts to introduce them into languages that lack them [11, 26].
Reference: [25] <author> James O. Coplien and Douglas C. Schmidt, </author> <title> editors. Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Object-oriented programming is now at a stage where enough experience is available to search for idioms that could be converted into language constructs or mechanisms. This programming experience is made accessible through design patterns. Design patterns <ref> [28, 25, 49] </ref> are a distillation of many real systems for the purpose of cataloging and categorizing common programming and program design practice. A design pattern basically consists of a statement of a design problem together with the skeleton of a solution. <p> Bridging Programming Practice and Language Theory We have analyzed design patterns from several sources <ref> [28, 25, 49, 24] </ref> and looked for idiomatic ways of working around constraints of the implementation language. Based on this analysis, we catalog general-purpose language constructs and mechanisms that, if provided by a statically typed, object-oriented language, would benefit design patterns and, transitively, a large body of real systems.
Reference: [26] <author> Laurent Dami. </author> <title> Software Composition: Towards an Integration of Functional and Object-Oriented Approaches. </title> <type> PhD thesis, </type> <institution> University of Geneva, Geneva, Switzerland, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: MyClass * receiver = new MyClass; // ... void aCommand () - receiver-&gt;MyAction (); - // ... otherFunction (aCommand); Uses Workarounds for the lack of lexical closures in a language are as pervasive [24, 39] as attempts to introduce them into languages that lack them <ref> [11, 26] </ref>.
Reference: [27] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Achieving interface hierarchies separate from implementation hierarchies is problematic in traditional object-oriented programming languages. In statically typed languages like C ++ , the required interface classes are usually defined as abstract base classes <ref> [27] </ref>. Multiple inheritance (from both an implementation class and an interface) can be used to establish the needed type relationships in the implementation hierarchy. Linking implementation and interface hierarchies together can lead to type conflicts. Consider an abstract type Matrix with two subtypes NegativeDefiniteMatrix and OrthogonalMatrix. <p> Common situations that could benefit from a closure mechanism are the parameterization of an object by behavior, the state change of an object from one behavior to another, and the creation of new behavior by partial application of existing behavior. Many statically typed object-oriented languages such as C ++ <ref> [27] </ref> or Java [54] neither allow behavior to be created on the fly, nor do they give functions or objects access to the surrounding local environment. By contrast, Smalltalk-80 [29] provides blocks as a limited form of closures. <p> A function to print or analyze these instantiation counts could then take as an argument any metaclass object conforming to the interface. 7 Method Dispatching on Multiple Parameters Typical object-oriented programming languages such as Smalltalk-80 [29] and C ++ <ref> [27] </ref> use single dispatching to determine the method invoked. When a method is invoked on a receiver object, a suitable method implementation is selected dynamically according to the class of the receiver. Other arguments do not influence method selection and are simply passed to the method. <p> For a multimethod defined in a class, the receiver is an instance of the class. For a multimethod defined in an object, the receiver is the object itself. Syntactically, multimethods appear like statically overloaded methods in C ++ <ref> [27] </ref>. Semantically, multimethods reduce to overloaded methods only when passed a class pointer or reference. We propose an exact-match multimethod selection scheme that operates in two steps. First, the method is dispatched with respect to the receiver; this step determines in which class or object the method is defined. <p> Most contemporary statically typed object-oriented languages do not have closures and have only a rudimentary form of packages. For example, C ++ <ref> [36, 27] </ref> and Modula-3 [16] lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald [8, 9] has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods.
Reference: [28] <author> Erich Gamma, Richard Helm, Ralph E. Johnson, and John M. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Professional Computing Series. Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Object-oriented programming is now at a stage where enough experience is available to search for idioms that could be converted into language constructs or mechanisms. This programming experience is made accessible through design patterns. Design patterns <ref> [28, 25, 49] </ref> are a distillation of many real systems for the purpose of cataloging and categorizing common programming and program design practice. A design pattern basically consists of a statement of a design problem together with the skeleton of a solution. <p> Influence of Languages on Patterns The choice of language has a two-fold effect on a pattern collection. First, while many patterns provide genuine design solutions, as Gamma et al. observed <ref> [28, page 4] </ref>, some low-level patterns can be omitted if the programming language supports them directly through a language construct or mechanism. The choice of programming language is important because it influences one's point of view. <p> Second, since patterns are distilled from real code, they are often distorted or overly complicated by idiosyncrasies of the programming language used, even if the design problem is language independent. The Singleton pattern <ref> [28] </ref> is an example of a pattern that merely implements a missing language construct. A Singleton is a class with only one instance and code that ensures that no other instances will be created. <p> This does not mean that such a pattern is not generally applicable, but rather that 2 in a non-object-oriented language the missing language constructs and mechanisms need to be implemented in the form of other patterns. The Composite pattern <ref> [28] </ref>, for example, relies on the ability to use the two classes Leaf and Composite polymorphically. To implement subtype polymorphism in C, all that is needed is to maintain a dispatch table containing function pointers [51]. <p> Bridging Programming Practice and Language Theory We have analyzed design patterns from several sources <ref> [28, 25, 49, 24] </ref> and looked for idiomatic ways of working around constraints of the implementation language. Based on this analysis, we catalog general-purpose language constructs and mechanisms that, if provided by a statically typed, object-oriented language, would benefit design patterns and, transitively, a large body of real systems. <p> A clean, language-supported separation of interface from implementation also allows the flexibility of inheritance for code reuse to be strengthened, as discussed in Section 3. Examples The need for explicit interface specifications is particularly evident in the Bridge, Adapter, Proxy, and Decorator patterns <ref> [28] </ref>. 4 Bridge and Adapter The general idea of the Bridge pattern is to support the construction of an abstraction hierarchy parallel to an implementation hierarchy and to avoid a permanent binding between the abstractions and the implementations of these abstractions. <p> Since this type relation is passed down through the implementation hierarchy, it still can cause the difficulty described above. The object form of the Adapter pattern <ref> [28] </ref> proposes another idiomatic pattern to solve the problem by using a forwarding class with a single instance variable that references an implementation class. This solution is workable in most object-oriented languages but introduces the added burden of having to code the forwarding explicitly along with the associated run-time overhead. <p> However, for the reasons described above this should not be mandatory. Another useful feature would be to support method renaming, perhaps with some form of cast notation. For example, in the Bridge pattern <ref> [28] </ref>, one of the libraries may have chosen different method names. interface Graphic - public: void draw (); void move (int, int); -; class Graphic1 - public: void render (); void move (int, int); -; Graphic * g = (rename render to draw) new Graphic1; Renaming is useful since it can <p> When a simple renaming is not sufficient, class or object Adapters <ref> [28] </ref> can still be used. Uses The need for type abstraction separate from implementation is pervasive throughout numerous patterns (in particular the Structural Patterns in Gamma et al. [28]). <p> When a simple renaming is not sufficient, class or object Adapters <ref> [28] </ref> can still be used. Uses The need for type abstraction separate from implementation is pervasive throughout numerous patterns (in particular the Structural Patterns in Gamma et al. [28]). The general observation can be made that any abstract class that contains no code should be replaced by an interface definition instead. <p> An implementation has to be provided by a subclass. The Smalltalk-80 term for this mechanism is subclass responsibility. The style of refining certain steps of an algorithm is described in the Template Method pattern in <ref> [28] </ref>. Mixin In the mixin programming style [45], inheritance is used to add functional components to a class. The same effect could be achieved by making the components fields of the class. However, making the methods of a component available to clients of the class would require writing forwarding methods. <p> Class ColorPoint inherits class Point, adds color support, and redefines equality to compare the color as well. class Point - protected: int x, y; public: of code reuse seem to be considered directly supported by a language's inheritance mechanism. Since inheritance is assumed to be a basic language mechanism <ref> [28] </ref>, these code reuse patterns are not found in object-oriented design pattern collections. <p> For some applications, however, this is the desired behavior. If a subtype relationship is needed, it can be achieved by declaring parameter and return types to be of an interface instead of a class type. For implementing frameworks using the Template Method pattern <ref> [28] </ref>, a subtype relationship between the abstract class and the concrete class is not required. The concrete class inherits the code of the abstract class and fills in the missing methods. The result is that the concrete class conforms to any interface the abstract class conforms to. <p> In the above example, we could specify the sharing constraint sharing D::A == E::A; in class CDE. The advantage over virtual inheritance is that its use does not have to be anticipated when defining classes D and E. 11 Uses In most patterns in Gamma et al. <ref> [28] </ref>, inheritance is used to define a subtype relationship by inheriting an abstract superclass. In these cases, the proper language construct to use would be an interface. The most common form of code reuse found in design patterns is a framework. <p> For example, a compiler contains only one parser. Even though there might be multiple network interfaces, an operating system contains only one TCP/IP stack. In the Abstract Factory pattern <ref> [28] </ref>, there is only one product factory. In languages that only provide classes for constructing objects, it is necessary to ensure that certain classes get instantiated at most once. This is the purpose of the Singleton pattern [28]. <p> In the Abstract Factory pattern <ref> [28] </ref>, there is only one product factory. In languages that only provide classes for constructing objects, it is necessary to ensure that certain classes get instantiated at most once. This is the purpose of the Singleton pattern [28]. In addition to constructing singleton software components, there is a need for packaging components for program delivery. Some object-oriented languages provide constructs specifically for this purpose. Examples are namespaces in C ++ [36] or packages in Java [54]. Shaw [52] lists module as a pattern for component packaging. <p> Namespaces in C ++ and packages in Java provide rudimentary support for packaging but are not flexible enough to be used as singleton components. They cannot be parameterized, passed to functions, or specialized through inheritance. Examples The Singleton Pattern Instead of defining a singleton object, using the Singleton pattern <ref> [28] </ref> allows the programmer to define a class that has only one instance. To ensure that no more than one instance can be created, it is necessary to intercept requests to create new objects. <p> Using a named class allows the singleton object to be passed to functions or to be specialized in subclasses. In C ++ , a typical implementation of the Singleton pattern is (from <ref> [28] </ref>): class Singleton - public: static Singleton * Instance (); protected: Singleton (); private: static Singleton * _instance; -; By not making the constructor public, the only way for clients to create an instance is through the method Instance (): 12 Singleton * Singleton::_instance = 0; Singleton * Singleton::Instance () - <p> Accessing the object indirectly through the Instance () method has the disadvantage that it precludes static resolution of method calls to the singleton object. Component Packaging The Abstract Factory pattern <ref> [28] </ref> provides an interface for creating families of products. Suppose we need to create scrollbars and windows of either the Presentation Manager or the Motif product families. <p> For languages without classless objects, the Singleton pattern would be the necessary paradigmatic idiom. Any pattern that uses the Singleton pattern can be expressed directly using the object construct. In the Abstract Factory pattern <ref> [28] </ref>, the abstract factory and the abstract product become interfaces, and the concrete factory becomes an object. Only the concrete products remain classes. Similarly in the Builder pattern [28], builder and concrete builder become an interface and an object, respectively. The purpose of the Facade pattern [28] is to package software <p> Any pattern that uses the Singleton pattern can be expressed directly using the object construct. In the Abstract Factory pattern <ref> [28] </ref>, the abstract factory and the abstract product become interfaces, and the concrete factory becomes an object. Only the concrete products remain classes. Similarly in the Builder pattern [28], builder and concrete builder become an interface and an object, respectively. The purpose of the Facade pattern [28] is to package software components. Since usually only one facade object is required, it could be implemented as a package. Similarly, a Mediator [28] would typically be a package. <p> the Abstract Factory pattern <ref> [28] </ref>, the abstract factory and the abstract product become interfaces, and the concrete factory becomes an object. Only the concrete products remain classes. Similarly in the Builder pattern [28], builder and concrete builder become an interface and an object, respectively. The purpose of the Facade pattern [28] is to package software components. Since usually only one facade object is required, it could be implemented as a package. Similarly, a Mediator [28] would typically be a package. Both the Strategy and the Visitor patterns [28] package only methods. They do not define any new data structure. <p> Similarly in the Builder pattern <ref> [28] </ref>, builder and concrete builder become an interface and an object, respectively. The purpose of the Facade pattern [28] is to package software components. Since usually only one facade object is required, it could be implemented as a package. Similarly, a Mediator [28] would typically be a package. Both the Strategy and the Visitor patterns [28] package only methods. They do not define any new data structure. Concrete strategies and concrete visitors would therefore be singleton objects, with the abstract classes Strategy and Visitor being replaced by interfaces. <p> The purpose of the Facade pattern <ref> [28] </ref> is to package software components. Since usually only one facade object is required, it could be implemented as a package. Similarly, a Mediator [28] would typically be a package. Both the Strategy and the Visitor patterns [28] package only methods. They do not define any new data structure. Concrete strategies and concrete visitors would therefore be singleton objects, with the abstract classes Strategy and Visitor being replaced by interfaces. Similarly, each concrete state in the State pattern [28] would be a singleton object. 5 Lexically Scoped Closure <p> Both the Strategy and the Visitor patterns <ref> [28] </ref> package only methods. They do not define any new data structure. Concrete strategies and concrete visitors would therefore be singleton objects, with the abstract classes Strategy and Visitor being replaced by interfaces. Similarly, each concrete state in the State pattern [28] would be a singleton object. 5 Lexically Scoped Closure Objects Some programming situations call for a (lexical) closure mechanism for creating behavior on the fly that can be invoked at a later time but has access to the lexical environment current when this behavior was created. <p> By contrast, Smalltalk-80 [29] provides blocks as a limited form of closures. Examples Specialized behavioral patterns such as Command, Iterator, State, and Strategy <ref> [28] </ref> are workarounds for missing language support for lexical closures. The abundance of such patterns has probably emerged due to a lack of closure support in many object-oriented languages and a failure to identify closures as the underlying generalized mechanism. <p> The only difference between State and Strategy is that State allows dynamic configuration, while Strategy usually provides static configuration. There is also a minor stylistic difference in the C ++ code given for the two patterns <ref> [28] </ref>. In the State pattern, the Context class does not use the State class in its public interface. In the Strategy pattern, by contrast, the constructor of the Context class is explicitly parameterized by a Strategy class or object. <p> Gamma et al. do not establish any relationship between the three patterns other than relating State and Strategy to the Flyweight pattern <ref> [28] </ref>. Zimmer recognizes the commonalities between these behavioral patterns and tries to capture them in the Objectifier pattern [58], which is not significantly different from the Strategy pattern. The following example (adopted from [28]) illustrates the Strategy pattern. <p> establish any relationship between the three patterns other than relating State and Strategy to the Flyweight pattern <ref> [28] </ref>. Zimmer recognizes the commonalities between these behavioral patterns and tries to capture them in the Objectifier pattern [58], which is not significantly different from the Strategy pattern. The following example (adopted from [28]) illustrates the Strategy pattern. A composition maintains a collection of textual and graphical components of a document. <p> Such metaclass objects would have fields and methods associated with the class, such as instantiation counts or constructors. We could then abstract over metaclass objects with regular interfaces, treat classes as values, and even allow parameterization by a class. Examples Abstract Factory and Factory Method The Abstract Factory pattern <ref> [28] </ref> provides an interface for creating families of products without specifying their concrete classes. Suppose we want to configure an application with either the Presentation Manager or the Motif look-and-feel. When creating widgets such as scrollbars or windows, the application should not hard-code the names of the widget classes. <p> The application refers to the factory through a reference of type WidgetFactory. The Factory Method pattern <ref> [28] </ref> is similar to the Abstract Factory pattern but refers to only one creation method. In the above example, both CreateScrollBar () and CreateWindow () are factory methods. <p> With a run-time representation of the product classes, we could parameterize both the abstract factory and the creator, with the product class (es) to be instantiated. 21 Solution Smalltalk-80 [29] supports classes as objects directly and, as discussed in Gamma et al. <ref> [28] </ref>, such metaclasses greatly simplify cases like the one described above. C ++ only supports a limited form of metaclass by allowing fields and variables to be declared static. <p> void init (ProductLibrary & lib) - P = lib; AbstractScrollBar & makeScrollBar (int x, int y, String label) - return P.ScrollBar.new (x, y, label); - AbstractWindow & makeWindow (int x, int y, int h, int w) - return P.Window.new (x, y, h, w); - WidgetFactory.init (Motif); Uses The Builder pattern <ref> [28] </ref> can benefit from metaclasses objects in a similar way as the Abstract Factory pattern. Instead of writing product-specific concrete builder classes, we only need to parameterize the Builder class by the concrete product to be built. <p> This technique is called multiple dispatching [33] or, in the common case of dispatching on two arguments, double dispatching. Double dispatching is exemplified in the Visitor pattern <ref> [28] </ref>. The Visitor Pattern In the Visitor pattern, a visitor represents an operation to be performed on the elements of a structure. This allows defining new operations without changing the classes of the elements to be operated on. <p> This allows defining new operations without changing the classes of the elements to be operated on. As a typical C ++ example of the Visitor pattern, consider abstract syntax trees and operations on these trees in the context of a compiler (adopted from <ref> [28] </ref>). Abstract syntax trees are built from nodes for assignments, variable references, expressions, and so on. Operations on abstract syntax trees include type checking, code generation, flow analysis, etc.
Reference: [29] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: Since permutation matrices are positive definite, this would violate the type hierarchy. The alternative of having a separate class SparseNegativeDefiniteMatrix is not satisfying either since it causes code replication. 6 Similar arguments have been given in the literature to show that the Collection class hierarchy of Smalltalk-80 <ref> [29] </ref> is not appropriate as a basis for subtyping. While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. Explicit support for object interfaces has been introduced into some object-oriented languages. <p> In C ++ terminology, the mechanisms used for this purpose are public inheritance and redefinition of virtual member functions [36]. In Smalltalk-80, all inheritance is public and all methods are virtual <ref> [29] </ref>. Template Method A framework is a skeleton of an application or algorithm that implements the control structure of a class of related applications or algorithms. The framework defines an interface for pieces to be filled in to create a specific instance of such an application or algorithm. <p> Many statically typed object-oriented languages such as C ++ [27] or Java [54] neither allow behavior to be created on the fly, nor do they give functions or objects access to the surrounding local environment. By contrast, Smalltalk-80 <ref> [29] </ref> provides blocks as a limited form of closures. Examples Specialized behavioral patterns such as Command, Iterator, State, and Strategy [28] are workarounds for missing language support for lexical closures. <p> By contrast, an internal iterator is usually provided as a method of the container class that takes a visitation function as its argument. For example, the do: method in the Smalltalk-80 collection class hierarchy <ref> [29] </ref> is an internal iterator parameterized by a block. The following example shows a typical application of the Iterator pattern for multiple traversal of a container in C ++ . Each of the two iterators keeps track of one position in the traversal. <p> This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 <ref> [29] </ref>, CLOS [10, 53, 47], and Cecil [18, 19]. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. <p> With a run-time representation of the product classes, we could parameterize both the abstract factory and the creator, with the product class (es) to be instantiated. 21 Solution Smalltalk-80 <ref> [29] </ref> supports classes as objects directly and, as discussed in Gamma et al. [28], such metaclasses greatly simplify cases like the one described above. C ++ only supports a limited form of metaclass by allowing fields and variables to be declared static. <p> We would define an interface for the methods to access the instantiation count. A function to print or analyze these instantiation counts could then take as an argument any metaclass object conforming to the interface. 7 Method Dispatching on Multiple Parameters Typical object-oriented programming languages such as Smalltalk-80 <ref> [29] </ref> and C ++ [27] use single dispatching to determine the method invoked. When a method is invoked on a receiver object, a suitable method implementation is selected dynamically according to the class of the receiver. Other arguments do not influence method selection and are simply passed to the method.
Reference: [30] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 123-137, </pages> <address> Portland, Oregon, </address> <month> 17-21 January </month> <year> 1994. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Such a solution was proposed as an object-based extension of ML modules by Mitchell et al. [44] and for supporting separate compilation of ML modules by Harper and Lillibridge <ref> [30] </ref>. As with classes, it is often useful to define new objects by reusing the code of existing objects, as shown in the definition of Singleton2 above.
Reference: [31] <author> Paul Hudak and Joseph Fasel. </author> <title> A gentle introduction to Haskell. </title> <journal> ACM SIGPLAN Notices, 27(5):Section T, </journal> <month> May </month> <year> 1992. </year> <month> 34 </month>
Reference-contexts: To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML [43, 42], Haskell <ref> [31, 32] </ref>, and Axiom and its predecessor Scratchpad II [34, 56, 55], have closures and packages but lack classes. Objective CAML is an ML dialect with classes, but it requires explicit coercion instead of allowing implicit subtyping and it does not offer class interfaces, metaclass objects, or multimethods.
Reference: [32] <author> Paul Hudak (ed.), Simon Peyton Jones (ed.), Philip Wadler (ed.), Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell: A non-strict, purely functional language, version 1.2. </title> <journal> ACM SIGPLAN Notices, 27(5):Section R, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: For example, using an updatable state or performing system calls with side effects, such as drawing to the screen or writing to a file, cannot be expressed conveniently in a purely functional language such as Haskell <ref> [32] </ref>. In such cases, programmers often develop idioms for expressing such algorithms or algorithm structures. In a purely functional language, for example, any state has to be passed as an argument to functions accessing the state. <p> To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML [43, 42], Haskell <ref> [31, 32] </ref>, and Axiom and its predecessor Scratchpad II [34, 56, 55], have closures and packages but lack classes. Objective CAML is an ML dialect with classes, but it requires explicit coercion instead of allowing implicit subtyping and it does not offer class interfaces, metaclass objects, or multimethods.
Reference: [33] <author> Daniel H. H. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 347-349, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: As soon as the class of an object is known, the class name is encoded in the name of the next method invoked. This technique is called multiple dispatching <ref> [33] </ref> or, in the common case of dispatching on two arguments, double dispatching. Double dispatching is exemplified in the Visitor pattern [28]. The Visitor Pattern In the Visitor pattern, a visitor represents an operation to be performed on the elements of a structure.
Reference: [34] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: The Scientific Computation System. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1992. </year>
Reference-contexts: To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML [43, 42], Haskell [31, 32], and Axiom and its predecessor Scratchpad II <ref> [34, 56, 55] </ref>, have closures and packages but lack classes. Objective CAML is an ML dialect with classes, but it requires explicit coercion instead of allowing implicit subtyping and it does not offer class interfaces, metaclass objects, or multimethods.
Reference: [35] <author> Brian W. Kernighan and Dennis M. Richie. </author> <title> The C Programming Language. </title> <booktitle> Prentice-Hall Software Series. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: This evolution of language constructs from idioms can also be observed in the case of modules. To manage the complexity of larger programs, functions are often grouped with the data on which they work to form abstract data types. C <ref> [35] </ref>, for example, weakly supports this programming style by distinguishing between global scope and static file scope. Auxiliary functions that should not be accessible to clients of an abstract data type can be hidden by declaring them to be static.
Reference: [36] <author> Andrew R. Koenig, </author> <title> editor. Working Paper for Draft Proposed International Standard for Information Systems | Programming Language C ++ . Accredited Standards Committee X3, </title> <booktitle> Information Processing Systems, American National Standards Institute, </booktitle> <address> X3J16/95-0087, WG21/N0687, </address> <month> 28 April </month> <year> 1995. </year> <note> Available from http://www.cygnus.com/misc/wp/index.html. </note>
Reference-contexts: For examples of patterns that work around a defect in the programming language, consider that most of the complexity of Coplien's Handle-Body and Envelope-Letter idioms [24] is due to the need to implement reference counting since C ++ <ref> [36] </ref> lacks garbage collection. Explicit storage management also complicates several other idioms in Coplien's collection. In a language with a garbage-collected heap, these idioms would be greatly simplified or not needed at all. Observe that not all design patterns are influenced by their implementation language. <p> The other forms 8 Specialization For specializing an existing class, a subclass can add new fields and methods or override existing methods. In C ++ terminology, the mechanisms used for this purpose are public inheritance and redefinition of virtual member functions <ref> [36] </ref>. In Smalltalk-80, all inheritance is public and all methods are virtual [29]. Template Method A framework is a skeleton of an application or algorithm that implements the control structure of a class of related applications or algorithms. <p> This is the purpose of the Singleton pattern [28]. In addition to constructing singleton software components, there is a need for packaging components for program delivery. Some object-oriented languages provide constructs specifically for this purpose. Examples are namespaces in C ++ <ref> [36] </ref> or packages in Java [54]. Shaw [52] lists module as a pattern for component packaging. Namespaces in C ++ and packages in Java provide rudimentary support for packaging but are not flexible enough to be used as singleton components. <p> Most contemporary statically typed object-oriented languages do not have closures and have only a rudimentary form of packages. For example, C ++ <ref> [36, 27] </ref> and Modula-3 [16] lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model [54] is similar to that of C ++ and adds interfaces without structural subtyping. Emerald [8, 9] has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods.
Reference: [37] <author> Thomas Kofler. </author> <title> Robust iterators for ET++. </title> <journal> Structured Programming, </journal> <volume> 14(2) </volume> <pages> 62-85, </pages> <year> 1993. </year>
Reference-contexts: For example, invoking Next after IsDone returns true is probably undefined. Finally, robustness becomes an issue with external iterators because the user can change the container by adding or deleting elements during iteration <ref> [37] </ref>. Internal iterators do not have these problems, but are hard to write in languages like C ++ because of the lack of lexical scoping. External iterators are mostly a workaround for the lack of internal iterators in such languages [5].
Reference: [38] <author> Thomas Kuhne. </author> <title> Inheritance versus parameterization. </title> <editor> In Christine Mingins and Bertrand Meyer, editors, </editor> <booktitle> Proceedings of the 1994 Conference on Technology of Object-Oriented Languages and Systems (TOOLS Pacific '94), </booktitle> <pages> pages 235-245, </pages> <address> Melbourne, Australia, </address> <year> 1995. </year> <title> Prentice-Hall. The article in the proceedings was corrupted in typesetting; a correct version can be obtained from the author (kuehne@isa.informatik.th-darmstadt.de). </title>
Reference-contexts: Closures and closure objects are useful for any type of behavioral parameterization, including callbacks in event-driven systems and parameters to applicative versions of iterators as used in functional languages <ref> [38] </ref>. 6 Metaclass Objects Many patterns rely on the ability either to abstract over classes or to parameterize an operation based on an object's class. For example, it would be useful to allow object construction to be parameterized by a class chosen at run time.
Reference: [39] <author> Konstantin Laufer. </author> <booktitle> A framework for higher-order functions in C ++ . In Proceedings of the USENIX Conference on Object-Oriented Technologies (COOTS), </booktitle> <pages> pages 103-116, </pages> <address> Monterey, California, 26-29 June 1995. </address> <publisher> USENIX Association. </publisher>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS [10, 53, 47], and Cecil [18, 19]. Coplien [24] and Laufer <ref> [39] </ref> developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> The function itself can be invoked from elsewhere. MyClass * receiver = new MyClass; // ... void aCommand () - receiver-&gt;MyAction (); - // ... otherFunction (aCommand); Uses Workarounds for the lack of lexical closures in a language are as pervasive <ref> [24, 39] </ref> as attempts to introduce them into languages that lack them [11, 26].
Reference: [40] <author> Barbara H. Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in clu. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: C [35], for example, weakly supports this programming style by distinguishing between global scope and static file scope. Auxiliary functions that should not be accessible to clients of an abstract data type can be hidden by declaring them to be static. In languages such as CLU <ref> [40] </ref> and Modula-2 [57], this program structure has been formalized as the module language construct. A definition module is used to declare the module interface, i.e., it corresponds to global scope in C.
Reference: [41] <author> Regine Meunier. </author> <title> The pipes and filters architecture. In Coplien and Schmidt [25], </title> <booktitle> chapter 22, </booktitle> <pages> pages 427-440. </pages>
Reference-contexts: Explicit storage management also complicates several other idioms in Coplien's collection. In a language with a garbage-collected heap, these idioms would be greatly simplified or not needed at all. Observe that not all design patterns are influenced by their implementation language. Some patterns, such as Producer-Consumer <ref> [13, 41] </ref>, can be described independent of the programming language. The reason the Producer-Consumer pattern is language-independent is that the language constructs and mechanism it relies on (arrays or lists and functions) are basic enough that they can be found in any language.
Reference: [42] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: For classes D and E to share the same A part, in C ++ they would need to use virtual inheritance from class A. We suggest to use sharing constrains similar to those in ML <ref> [43, 42] </ref> instead. In the above example, we could specify the sharing constraint sharing D::A == E::A; in class CDE. <p> Packages The object construct described above is related to module constructs as found in Modula-3 [16] or ML <ref> [43, 42] </ref>. Unlike modules in these languages, objects are first-class values, i.e., they can be passed to and returned from functions or assigned to variables. The advantage of modules is that they allow packaging and exporting of types in addition to variables and functions. <p> To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML <ref> [43, 42] </ref>, Haskell [31, 32], and Axiom and its predecessor Scratchpad II [34, 56, 55], have closures and packages but lack classes.
Reference: [43] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: For classes D and E to share the same A part, in C ++ they would need to use virtual inheritance from class A. We suggest to use sharing constrains similar to those in ML <ref> [43, 42] </ref> instead. In the above example, we could specify the sharing constraint sharing D::A == E::A; in class CDE. <p> Packages The object construct described above is related to module constructs as found in Modula-3 [16] or ML <ref> [43, 42] </ref>. Unlike modules in these languages, objects are first-class values, i.e., they can be passed to and returned from functions or assigned to variables. The advantage of modules is that they allow packaging and exporting of types in addition to variables and functions. <p> To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML <ref> [43, 42] </ref>, Haskell [31, 32], and Axiom and its predecessor Scratchpad II [34, 56, 55], have closures and packages but lack classes.
Reference: [44] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Proceedings of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 270-278, </pages> <address> Orlando, Florida, </address> <month> 21-23 January </month> <year> 1991. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: The same syntax can be used for selectively importing a class. Similar syntax has been proposed in <ref> [44] </ref>. Note that in the above example, the interface of class CDE will conform to the interface of class D if D::f and E::f have the same type. Interface conformance, therefore, enables us to define subtype relationships that could not be achieved with inheritance. <p> The solution for getting the best of both worlds, exported types and first-class packages, is to consider exported types opaque when a package is accessed through an object reference. Such a solution was proposed as an object-based extension of ML modules by Mitchell et al. <ref> [44] </ref> and for supporting separate compilation of ML modules by Harper and Lillibridge [30]. As with classes, it is often useful to define new objects by reusing the code of existing objects, as shown in the definition of Singleton2 above.
Reference: [45] <author> David A. Moon. </author> <title> Object-oriented programming with flavors. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-8, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: An implementation has to be provided by a subclass. The Smalltalk-80 term for this mechanism is subclass responsibility. The style of refining certain steps of an algorithm is described in the Template Method pattern in [28]. Mixin In the mixin programming style <ref> [45] </ref>, inheritance is used to add functional components to a class. The same effect could be achieved by making the components fields of the class. However, making the methods of a component available to clients of the class would require writing forwarding methods.
Reference: [46] <author> Diane E. Mularz. </author> <title> Pattern-based integration architectures. In Coplien and Schmidt [25], </title> <booktitle> chapter 23, </booktitle> <pages> pages 441-452. 35 </pages>
Reference-contexts: The former solution is rather inelegant, and the latter two clutter up the name space with a superfluous set of new class names. Mularz <ref> [46] </ref> makes a similar observation when discussing building wrappers to access legacy code. Even with source code available, if the component classes are already part of another application, altering their inheritance relationships could break that application.
Reference: [47] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS <ref> [10, 53, 47] </ref>, and Cecil [18, 19]. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> Dispatch based on multiple arguments would allow defining the new method without modifying the class hierarchy by dispatching on an argument whose type is a class from this hierarchy. Methods whose selection is based on several arguments are called multimethods as supported in CLOS <ref> [10, 53, 47] </ref> and Cecil [18, 19]. Typical multimethods include binary arithmetic operations, binary equality testing, and simultaneous iteration over several collections.
Reference: [48] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 71-84, </pages> <address> Charleston, South Carolina, </address> <month> 11-13 January </month> <year> 1993. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: For example, 1 Haskell provides monads to support passing state to functions at the top level of a functional program <ref> [48] </ref>. This evolution of language constructs from idioms can also be observed in the case of modules. To manage the complexity of larger programs, functions are often grouped with the data on which they work to form abstract data types.
Reference: [49] <author> Wolfgang Pree. </author> <title> Design Patterns for Object Oriented Software Developers. </title> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <year> 1994. </year>
Reference-contexts: Object-oriented programming is now at a stage where enough experience is available to search for idioms that could be converted into language constructs or mechanisms. This programming experience is made accessible through design patterns. Design patterns <ref> [28, 25, 49] </ref> are a distillation of many real systems for the purpose of cataloging and categorizing common programming and program design practice. A design pattern basically consists of a statement of a design problem together with the skeleton of a solution. <p> Bridging Programming Practice and Language Theory We have analyzed design patterns from several sources <ref> [28, 25, 49, 24] </ref> and looked for idiomatic ways of working around constraints of the implementation language. Based on this analysis, we catalog general-purpose language constructs and mechanisms that, if provided by a statically typed, object-oriented language, would benefit design patterns and, transitively, a large body of real systems.
Reference: [50] <author> Fran~cois Rouaix. </author> <title> Safe run-time overloading. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 355-366, </pages> <address> San Francisco, California, </address> <month> 17-19 January </month> <year> 1990. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Using C ++ -like syntax, multimethods can be defined as methods in a class or object. We suggest to perform dynamic dispatching on all arguments whose type is a class reference or class pointer. Unlike static overloading resolution, dispatching is performed at run-time, although multimethods can be statically typed <ref> [50, 17, 20] </ref>. By combining multimethods and packages, we can simplify the abstract syntax tree example by bundling the visitation methods for each tree operation in a package. object TypeChecker - public: void Visit (AssignmentNode & n) - // ...
Reference: [51] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: The Composite pattern [28], for example, relies on the ability to use the two classes Leaf and Composite polymorphically. To implement subtype polymorphism in C, all that is needed is to maintain a dispatch table containing function pointers <ref> [51] </ref>. The Composite pattern can, therefore, be implemented in C by defining structures representing Leaf and Composite together with a function dispatch table implementation of the Polymorphism pattern. We term a pattern that implements a missing language construct or mechanism (such as Polymorphism and Singleton) a paradigmatic idiom.
Reference: [52] <author> Mary Shaw. </author> <title> Patterns for software architectures. In Coplien and Schmidt [25], </title> <booktitle> chapter 24, </booktitle> <pages> pages 453-462. </pages>
Reference-contexts: This is the purpose of the Singleton pattern [28]. In addition to constructing singleton software components, there is a need for packaging components for program delivery. Some object-oriented languages provide constructs specifically for this purpose. Examples are namespaces in C ++ [36] or packages in Java [54]. Shaw <ref> [52] </ref> lists module as a pattern for component packaging. Namespaces in C ++ and packages in Java provide rudimentary support for packaging but are not flexible enough to be used as singleton components. They cannot be parameterized, passed to functions, or specialized through inheritance.
Reference: [53] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, 2nd edition, </address> <year> 1990. </year>
Reference-contexts: This kind of mechanism is known as (lexical) closure and is a standard feature 18 of functional or applicative languages and of some object-oriented languages, including Smalltalk-80 [29], CLOS <ref> [10, 53, 47] </ref>, and Cecil [18, 19]. Coplien [24] and Laufer [39] developed a paradigmatic idiom that simulates closures in C ++ using classes. Their approaches fall short of true lexical closures in that closures cannot be anonymous and must capture explicitly the portions of the environment they use. <p> Dispatch based on multiple arguments would allow defining the new method without modifying the class hierarchy by dispatching on an argument whose type is a class from this hierarchy. Methods whose selection is based on several arguments are called multimethods as supported in CLOS <ref> [10, 53, 47] </ref> and Cecil [18, 19]. Typical multimethods include binary arithmetic operations, binary equality testing, and simultaneous iteration over several collections.
Reference: [54] <author> Sun Microsystems, </author> <title> Mountain View, California. The Java Language Specification, </title> <note> Version 1.0 Beta, 30 October 1995. Available from ftp://ftp.javasoft.com/docs/javaspec.ps. </note>
Reference-contexts: While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. Explicit support for object interfaces has been introduced into some object-oriented languages. For example, interfaces are supported in Java <ref> [54] </ref> as an explicit syntactical construct. A type hierarchy can be created using interfaces, and an implementation hierarchy can be created through class (single) inheritance. <p> The result is that the concrete class conforms to any interface the abstract class conforms to. Since both for specializing an existing class and for defining a framework virtual methods are more common, we suggest to use syntax similar to Java's <ref> [54] </ref>: methods are virtual by default unless they are explicitly declared final. Also for specifying abstract methods, a keyword, such as Java's abstract keyword, could be used. To support the mixin programming style, we suggest that object-oriented languages support an import mechanism related to that found in Modula-3. <p> This is the purpose of the Singleton pattern [28]. In addition to constructing singleton software components, there is a need for packaging components for program delivery. Some object-oriented languages provide constructs specifically for this purpose. Examples are namespaces in C ++ [36] or packages in Java <ref> [54] </ref>. Shaw [52] lists module as a pattern for component packaging. Namespaces in C ++ and packages in Java provide rudimentary support for packaging but are not flexible enough to be used as singleton components. They cannot be parameterized, passed to functions, or specialized through inheritance. <p> Many statically typed object-oriented languages such as C ++ [27] or Java <ref> [54] </ref> neither allow behavior to be created on the fly, nor do they give functions or objects access to the surrounding local environment. By contrast, Smalltalk-80 [29] provides blocks as a limited form of closures. <p> Most contemporary statically typed object-oriented languages do not have closures and have only a rudimentary form of packages. For example, C ++ [36, 27] and Modula-3 [16] lack class interfaces with structural subtyping, metaclass objects, and multimethods. Java's object model <ref> [54] </ref> is similar to that of C ++ and adds interfaces without structural subtyping. Emerald [8, 9] has interfaces, objects, and structural subtyping but does not have classes, inheritance, or multimethods.
Reference: [55] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> The type inference and coercion facilities in the Scratchpad II interpreter. </title> <booktitle> In Proceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 56-63, </pages> <address> St. Paul, Minnesota, </address> <month> 24-26 June </month> <year> 1987. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 22(7), </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML [43, 42], Haskell [31, 32], and Axiom and its predecessor Scratchpad II <ref> [34, 56, 55] </ref>, have closures and packages but lack classes. Objective CAML is an ML dialect with classes, but it requires explicit coercion instead of allowing implicit subtyping and it does not offer class interfaces, metaclass objects, or multimethods.
Reference: [56] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II type system: Domains and subdomains. </title> <editor> In Alfonso M. Miola, editor, </editor> <booktitle> Computing Tools for Scientific Problem Solving, </booktitle> <pages> pages 63-82. </pages> <publisher> Academic Press, </publisher> <address> London, Great Britain, </address> <year> 1990. </year>
Reference-contexts: To our knowledge, there does not yet exist a programming language that supports the full range of our language constructs and mechanisms. Modern functional and abstract data type languages, such as ML [43, 42], Haskell [31, 32], and Axiom and its predecessor Scratchpad II <ref> [34, 56, 55] </ref>, have closures and packages but lack classes. Objective CAML is an ML dialect with classes, but it requires explicit coercion instead of allowing implicit subtyping and it does not offer class interfaces, metaclass objects, or multimethods.
Reference: [57] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg, Germany, </address> <year> 1985. </year>
Reference-contexts: C [35], for example, weakly supports this programming style by distinguishing between global scope and static file scope. Auxiliary functions that should not be accessible to clients of an abstract data type can be hidden by declaring them to be static. In languages such as CLU [40] and Modula-2 <ref> [57] </ref>, this program structure has been formalized as the module language construct. A definition module is used to declare the module interface, i.e., it corresponds to global scope in C. An implementation module contains the code for the functions declared in the definition module as well as other, auxiliary, functions.
Reference: [58] <author> Walter Zimmer. </author> <title> Relationships between design patterns. In Coplien and Schmidt [25], </title> <booktitle> chapter 18, </booktitle> <pages> pages 345-364. </pages>
Reference-contexts: Gamma et al. do not establish any relationship between the three patterns other than relating State and Strategy to the Flyweight pattern [28]. Zimmer recognizes the commonalities between these behavioral patterns and tries to capture them in the Objectifier pattern <ref> [58] </ref>, which is not significantly different from the Strategy pattern. The following example (adopted from [28]) illustrates the Strategy pattern. A composition maintains a collection of textual and graphical components of a document.
References-found: 58

