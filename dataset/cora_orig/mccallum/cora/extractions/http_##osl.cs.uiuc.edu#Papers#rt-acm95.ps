URL: http://osl.cs.uiuc.edu/Papers/rt-acm95.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/RT.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: f ren j agha g@cs.uiuc.edu  
Title: RTsynchronizer: Language Support for Real-Time Specifications in Distributed Systems how real-time constraints for periodic events,
Author: Shangping Ren and Gul A. Agha 
Web: examples illustrate  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Date: June 1995.  
Note: ACM SIGPLAN Workshop on Languages, Compilers and Tools for Real-Time Systems, La Jolla, California,  A number of examples are given to illustrate the use of RTsynchronizers. These  and producer-consumer may be specified. The research described has been made possible by support from the Office of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), by an Incentives for Excellence Award from the Digital Equipment Corporation Faculty Program, and by joint support from the Defense Advanced Research Projects Agency and the National Science Foundation (NSF CCR 90-07195). The authors would like to thank Mark Astley, Brian Nielsen, Masahiko Saitoh and Daniel Sturman for helpful discussions concerning the manuscript.  
Abstract: We argue that the specification of an object's functional behavior and the timing constraints imposed on it may be separated. Specifically, we describe RTsynchronizer, a high-level programming language construct for specifying real-time constraints between objects in a distributed concurrent system. During program execution, RTsynchronizers affect the scheduling of distributed objects to enforce real-time relations between events. Objects in our system are defined in terms of the actor model extended with timing assumptions. Separation of the functional behaviors of actors and the timing constraints on patterns of actor invocation provides at least three important advantages. First, it simplifies code development by separating design concerns. Second, multiple timing constraints can be independently specified and composed. And finally, a specification of timing constraints can be reused even if the representation of the functional behavior of actors has changed, and conversely. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The transformation involves scheduling and possibly placement of actors; it does not affect their functional behavior in response to a particular message. 3 The Real-Time Actor Model Actors are concurrent objects which interact by sending buffered, asynchronous messages <ref> [1, 3] </ref>. We will call the processing of a message by an actor an invocation of the actor by the message. Each actor has a unique mail addresses which may be used to send it messages.
Reference: [2] <author> G. Agha, S. Frolund, W. Kim, R. Panwar, A. Patterson, and D. Sturman, </author> <title> Abstraction and Modularity Mechanisms for Concurrent Computing, </title> <booktitle> IEEE Parallel and Distributed Technology: Systems and Applications 1 (1993), </booktitle> <volume> no. 2, </volume> <pages> 3-14. </pages>
Reference-contexts: For our purposes, there are two weaknesses of this work. First, the timing requirements are intermixed with the code for the methods of individual objects. Second, Flex does not support concurrency. Concurrent object-oriented programming is an active area of research interest (for example, see <ref> [4, 16, 2] </ref>). Specifically, there are a number of real-time languages based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [13]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from "ordinary" (unconstrained) objects.
Reference: [3] <author> G. Agha, I. Mason, S. Smith, and C. Talcott, </author> <title> Towards a Theory of Actor Computation, </title> <booktitle> Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992, </year> <pages> LNCS, pp. 565-579. </pages>
Reference-contexts: The transformation involves scheduling and possibly placement of actors; it does not affect their functional behavior in response to a particular message. 3 The Real-Time Actor Model Actors are concurrent objects which interact by sending buffered, asynchronous messages <ref> [1, 3] </ref>. We will call the processing of a message by an actor an invocation of the actor by the message. Each actor has a unique mail addresses which may be used to send it messages.
Reference: [4] <editor> G. Agha, P. Wegner, and A. Yonezawa (eds.), </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachussets, </address> <year> 1993. </year>
Reference-contexts: For our purposes, there are two weaknesses of this work. First, the timing requirements are intermixed with the code for the methods of individual objects. Second, Flex does not support concurrency. Concurrent object-oriented programming is an active area of research interest (for example, see <ref> [4, 16, 2] </ref>). Specifically, there are a number of real-time languages based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [13]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from "ordinary" (unconstrained) objects.
Reference: [5] <author> C. Hewitt, </author> <title> Viewing Control Structures as Patterns of Passing Messages, </title> <journal> Journal of Artificial Intelligence Vol. </journal> <volume> 8, </volume> <year> 1977, </year> <pages> pp. 323-364. </pages>
Reference: [6] <author> W. Clinger, </author> <title> Foundation of Actor Semantics, </title> <type> MIT technical report, </type> <institution> AI-TR-633. </institution>
Reference: [7] <author> A. Yonezawa, J. P. Briot and E. Shibayana, </author> <booktitle> Object-Oriented Concurrent Programming in ABCL/1, </booktitle> <month> September </month> <year> 1986, </year> <booktitle> OOPSLA, </booktitle> <pages> pp. 258-268. </pages>
Reference: [8] <author> M. Aksit, J. Bosch, and W. </author> <title> Sterren Real-Time Specification Inheritance Anomalies and Real-Time Filters Springer-Verlag, July 1994, </title> <publisher> LNCS, </publisher> <pages> pp. 386-407. </pages>
Reference-contexts: One approach to solve this difficulty is to observe a programming discipline which confines specification of temporal constraints to certain isolated components in some standard pattern [23]. We take a more linguistic approach (similar in spirit to the work of Aksit et al. <ref> [8] </ref>): the goal of our research is to allow a separation of the two different design concerns in order to support configuration of components with real-time constraints. We model components of a distributed real-time system, such as control processes and hardware devices, uniformly as actors. <p> By contrast, by using the actor model, we avoid the possibility of inconsistencies within the state of an actor due to concurrent accesses. From a linguistic point of view, the cleanest approach thus far appears to be the work of Aksit et al. <ref> [8, 9] </ref>: they introduce a linguistic mechanism called a real-time filter. Real-time filters extend an object's interfaces to include input filters and output filters. An out-going message has to go through a series of zero or more output filters before it is sent to its target.
Reference: [9] <author> M. Aksit, K. Wakita, J. bosch, L. Bergmans, and A. Yonezawa, </author> <title> Abstracting Object Interactions Using Composition Filters, </title> <publisher> Springer-Verlag, </publisher> <address> July 1993, </address> <publisher> LNCS, </publisher> <pages> pp. 152-1184. </pages>
Reference-contexts: By contrast, by using the actor model, we avoid the possibility of inconsistencies within the state of an actor due to concurrent accesses. From a linguistic point of view, the cleanest approach thus far appears to be the work of Aksit et al. <ref> [8, 9] </ref>: they introduce a linguistic mechanism called a real-time filter. Real-time filters extend an object's interfaces to include input filters and output filters. An out-going message has to go through a series of zero or more output filters before it is sent to its target.
Reference: [10] <author> S. Matsuoka, and A. Yonezawa, </author> <title> Analysis of Inheritance Anomaly in Object-Oriented Concurrent Programming Languages, </title> <booktitle> in Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT press, </publisher> <year> 1993 </year>
Reference: [11] <author> B. Dasarathy, </author> <title> Timing Constraints of Real-Time Systems: constructs for expressing them, methods for validating them, </title> <journal> IEEE Transactions of Software Engineering, </journal> <month> January, </month> <year> 1985, </year> <pages> pp. 80-86. </pages>
Reference: [12] <author> Y. Ishika, H. Tokuda, and C.W. Mercer, </author> <title> Object-Oriented Real-Time Language Design: Constructs for Timing Constraints, </title> <booktitle> ECOOP/OOPSLA proceedings, </booktitle> <year> 1990, </year> <pages> pp. 289-298. </pages>
Reference: [13] <author> Y. Ishikawa, H, Tokuda, and C. W. Mercer, </author> <title> An Object-Oriented Real-Time Programming Language, </title> <booktitle> IEEE Computer, </booktitle> <month> October </month> <year> 1992, </year> <pages> pp. 66-73. </pages>
Reference-contexts: Second, Flex does not support concurrency. Concurrent object-oriented programming is an active area of research interest (for example, see [4, 16, 2]). Specifically, there are a number of real-time languages based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ <ref> [13] </ref>. In RTC++, temporally constrained objects (called real-time objects) are distinguished from "ordinary" (unconstrained) objects. The distinction between real-time objects and ordinary objects means that objects with the same logical behaviors but with different temporal constraints require separate specification.
Reference: [14] <author> L. Y. Liu, and R. K. Shyamasundar, RT-CDL: </author> <title> A real-time design language and its semantics, </title> <booktitle> Information Processing, </booktitle> <year> 1989, </year> <pages> pp. 21-26. </pages>
Reference: [15] <author> N. Wirth, </author> <title> Towards a Discipline of Real-Time Programming, </title> <journal> Communication of ACM, 1977, </journal> <volume> vol. </volume> <pages> 20 pp. 577-583. </pages>
Reference: [16] <author> Denis Caromel, </author> <title> Toward a Method of Object-Oriented Concurrent Programming, </title> <journal> Communications of the ACM 36 (1993), </journal> <volume> no. 9, </volume> <pages> 90-102. </pages>
Reference-contexts: For our purposes, there are two weaknesses of this work. First, the timing requirements are intermixed with the code for the methods of individual objects. Second, Flex does not support concurrency. Concurrent object-oriented programming is an active area of research interest (for example, see <ref> [4, 16, 2] </ref>). Specifically, there are a number of real-time languages based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [13]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from "ordinary" (unconstrained) objects.
Reference: [17] <author> S. Frolund, and G. Agha, </author> <title> A Language Framework for Multi-Object Coordination, </title> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1993, </year> <note> LNCS 627. </note>
Reference-contexts: We extend the Actor model to allow each actor to have a local clock, and further assume that local clocks of a temporally constrained set of actors are sufficiently synchronized to allow a meaningful interpretation of the constraints. Our work builds on the earlier work of Frolund and Agha <ref> [17] </ref> who developed synchronizers to provide declarative specification of coordination constraints on groups of actors. Synchronizers may be used to enforce qualitative temporal ordering and indivisible (atomic) scheduling of multiple invocations at a group of objects. On the other hand, RT-synchronizers allow the specification of quantitative constraints. <p> The devices have to make the adjustment within time t. We model Dye/Drain valve, Heater, Pressure, Hatch, Sensors and Timer as corresponding actors. The qualitative relationships between these actors, such as Drain/Dye cannot open when Heater/Pressure's heat, cool/increasePressure, decreasePressue method is in processing, may be simply expressed by synchronizers <ref> [17] </ref>. We focus on the quantitative time constraints represented by the RTsynchronizers.
Reference: [18] <author> S. Frolund, </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages, </title> <booktitle> ECOOP'92 European conference on Object-Oriented Programming (O. </booktitle> <editor> Lehrmann Madsen, ed.), </editor> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992, </year> <pages> LNCS 615, pp. 185-196. </pages>
Reference: [19] <author> T. Baker, W. Halang, S. Natarajan, and O. Pazy, </author> <title> Languages: ADA ? Object-Oriented ? IFAC Real Time Programming, </title> <address> Georgis, USA, </address> <year> 1991. </year>
Reference-contexts: We draw the conclusion in section 6. 2 Related Work Ada is a programming language intended for critical software systems. However, it is difficult to implement full Ada in distributed systems | not only because `it is already too complicated' <ref> [19] </ref>, but also because ADA's tasking model is integrated into a stack and heap model.
Reference: [20] <author> D. Kafura, and K. H. Lee, </author> <title> ACT++: Building a Concurrent C++ with Actors, JOOP, </title> <booktitle> May/June 1990, </booktitle> <pages> pp. 25-37. </pages>
Reference: [21] <author> B. Selic, G.Cullekson, and P. T. Ward, </author> <title> Real-Time Object-Oriented Modeling WILEY, </title> <year> 1994 </year>
Reference-contexts: define an RTsynchronizer to specify the problem without changing the logical behaviors of the producer or consumer: RTsynchronizer ProdCons ( real: delta; actor: Producer, Consumer) f Rules with f (put: Producer.put) (get: Consumer.get)g f assert fiTime (get) &lt;= iTime (put) + delta gg g Processes Control Example Selic et al. <ref> [21] </ref> describe a dye control industrial process as a canonical process control problem. The problem is as follows.
Reference: [22] <author> M. Joseph, </author> <title> Problems, promises and performance: some questions for real-time system specification, </title> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1991, </year> <pages> LNCS 600, pp. 315-324. </pages>
Reference: [23] <author> N. Wirth, </author> <title> Toward a Discipline of Real-Time Programming, </title> <journal> Communication of ACM, </journal> <volume> Vol. 20, No. 8, </volume> <month> Auguest </month> <year> 1977. </year>
Reference-contexts: This complicates the design of real-time systems as well as reasoning about them. One approach to solve this difficulty is to observe a programming discipline which confines specification of temporal constraints to certain isolated components in some standard pattern <ref> [23] </ref>. We take a more linguistic approach (similar in spirit to the work of Aksit et al. [8]): the goal of our research is to allow a separation of the two different design concerns in order to support configuration of components with real-time constraints.
Reference: [24] <author> K. Lin, J. W. S. Liu, </author> <title> FLEX: A Language for Real-Time Systems Programming, </title> <type> Technical Report No. 1634, </type> <institution> UIUC </institution>
Reference-contexts: The lack of modularity makes it hard to reuse the program code and therefore makes it very difficult to design and reason about large systems. Some researchers have proposed integrating timing constraints with sequential objects. In particular, the real-time programming language Flex <ref> [24] </ref> extends C++ with a language construct called a control block, which can reside in the body of methods; timing constraints are specified in the control block. For our purposes, there are two weaknesses of this work.
Reference: [25] <author> F. Jahanian and A. K. Mok, Modechart: </author> <title> A Specification Language for Real-Time System, </title> <journal> IEEE transactions on Software Engineering, </journal> <year> 1988 </year>
Reference-contexts: There are a number of real-time specification languages, such as timed Petri Nets, Modechart, i-o automata, and RTL <ref> [26, 25, 27, 28] </ref>. At the application level, specification languages can assist in real-time system design. Moreover, specification languages provide support for reasoning about real-time systems. However, the purpose of our research is to provide high-level programming language constructs for developing real-time applications.
Reference: [26] <author> C. Ghezzi, D. Mandrioli, S. Morasca, and M. Pezze, </author> <title> A Unified High-Level Petri Net Formalizm for Timed-Critical Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol 17, No. </volume> <month> 2 February </month> <year> 1991 </year>
Reference-contexts: There are a number of real-time specification languages, such as timed Petri Nets, Modechart, i-o automata, and RTL <ref> [26, 25, 27, 28] </ref>. At the application level, specification languages can assist in real-time system design. Moreover, specification languages provide support for reasoning about real-time systems. However, the purpose of our research is to provide high-level programming language constructs for developing real-time applications.
Reference: [27] <author> N. A. Lynch and M. R. </author> <title> Tuttle,An Introduction to input/output atuomata, </title> <journal> CWI Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> September, </month> <year> 1989 </year>
Reference-contexts: There are a number of real-time specification languages, such as timed Petri Nets, Modechart, i-o automata, and RTL <ref> [26, 25, 27, 28] </ref>. At the application level, specification languages can assist in real-time system design. Moreover, specification languages provide support for reasoning about real-time systems. However, the purpose of our research is to provide high-level programming language constructs for developing real-time applications.
Reference: [28] <author> R. Alur and T. A. Henzigner, </author> <title> A really temporal logic, </title> <booktitle> Proc. 30th Annual Symp. Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Science Press, </publisher> <pages> PP. 164-169, </pages> <year> 1989 </year>
Reference-contexts: There are a number of real-time specification languages, such as timed Petri Nets, Modechart, i-o automata, and RTL <ref> [26, 25, 27, 28] </ref>. At the application level, specification languages can assist in real-time system design. Moreover, specification languages provide support for reasoning about real-time systems. However, the purpose of our research is to provide high-level programming language constructs for developing real-time applications.
Reference: [29] <author> Z. Manna, A. Puneli, </author> <title> The Temporal Logic of Reactive and Concurrent Systems | Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1992 </year>
References-found: 29

