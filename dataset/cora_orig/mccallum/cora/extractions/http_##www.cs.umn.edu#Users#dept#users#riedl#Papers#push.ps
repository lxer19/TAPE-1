URL: http://www.cs.umn.edu/Users/dept/users/riedl/Papers/push.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/riedl/Papers/
Root-URL: http://www.cs.umn.edu
Title: Push: An Experimental Facility for Implementing Distributed Database Services in Operating Systems  
Author: Bharat Bhargava Enrique Mafla Quito, Ecuador John Riedl 
Keyword: Operating Systems, Database, Communications, Extensible, Adaptable.  
Note: This research is supported by NASA and AIRMICS under grant number NAG-1-676, NSF grant IRI 8821398, and AT&T.  
Address: West Lafayette, IN 47907  San Fransisco  Minneapolis, Minnesota 55455  
Affiliation: Department of Computer Sciences Purdue University  Universidad  Department of Computer Science University of Minnesota  
Abstract: Distributed database systems need special operating system support. Support routines can be implemented inside the kernel or at the user level. Kernel-level functions, while efficient, are hard to implement. User-level implementations are easier, but suffer from poor performance and lack of security. This paper proposes a new approach to supplement or modify kernel facilities for database transaction processing. Our experimental facility, called Push, is based on an extension language interpreted within the kernel. Our implementation provides the efficiency of kernel-resident code as well as the simplicity and safety of user-level programming. This facility enables experimentation that would be difficult and time-consuming in current environments. The overhead of the Push implementation can be factored out to give a good estimate of the performance of a native kernel implementation. We have used Push to implement several kernel-resident services. In the case of multi-RPC and commit protocols, Push implementations significantly improve performance and scalability over user-level implementations. The experiments show the benefits of Push both as an operational tool 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bharat Bhargava and John Riedl. </author> <title> The Raid distributed database system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(6), </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: When Push is used as an operational tool, Push routines can be added to or deleted from the kernel dynamically during normal operation of the system. This feature introduces a form of adaptability in the operating system <ref> [1] </ref>. Database implementors have suggested that additional support in the underlying operating system is needed for efficiency [2, 3, 4]. Push provides a facility for experimenting with new or extended operating system services.
Reference: [2] <author> Michael Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: This feature introduces a form of adaptability in the operating system [1]. Database implementors have suggested that additional support in the underlying operating system is needed for efficiency <ref> [2, 3, 4] </ref>. Push provides a facility for experimenting with new or extended operating system services. Examples of these services include buffer management, file system support, process management, interprocess communication, con-currency control, atomicity control, and crash recovery. <p> The services that are present in current operating systems are general-purpose and do not satisfy the demands of distributed 1 Unix is a trademark of AT&T Bell Laboratories. 3 transaction processing algorithms <ref> [2, 3, 5] </ref>. For instance, locking facilities and buffer man-agement are generally implemented by database systems because the services provided in operating systems are inadequate. This paper is organized as follows. Section 2 discusses design, implementation, and performance issues of Push. Section 3 describes experiments conducted with Push. <p> The user interface presented by the file system may not be convenient for implementing transaction processing algorithms <ref> [2] </ref>. We have written Push routines that extend the Unix file system to accommodate it to the demands of database systems. These routines use the file system primitives creat, open, close, read, and write provided by the Push machine.
Reference: [3] <author> Michael Stonebraker, Deborah DuBourdieux, and William Edwards. </author> <title> Problems in supporting data base transactions in an operating system transaction manager. </title> <journal> Operating System Review, </journal> <volume> 19(1) </volume> <pages> 6-14, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: This feature introduces a form of adaptability in the operating system [1]. Database implementors have suggested that additional support in the underlying operating system is needed for efficiency <ref> [2, 3, 4] </ref>. Push provides a facility for experimenting with new or extended operating system services. Examples of these services include buffer management, file system support, process management, interprocess communication, con-currency control, atomicity control, and crash recovery. <p> The services that are present in current operating systems are general-purpose and do not satisfy the demands of distributed 1 Unix is a trademark of AT&T Bell Laboratories. 3 transaction processing algorithms <ref> [2, 3, 5] </ref>. For instance, locking facilities and buffer man-agement are generally implemented by database systems because the services provided in operating systems are inadequate. This paper is organized as follows. Section 2 discusses design, implementation, and performance issues of Push. Section 3 describes experiments conducted with Push.
Reference: [4] <author> Alfred Z. Spector. </author> <title> Communication support in operating systems for distributed transactions. </title> <booktitle> In Networking in Open Systems, </booktitle> <pages> pages 313-324. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: This feature introduces a form of adaptability in the operating system [1]. Database implementors have suggested that additional support in the underlying operating system is needed for efficiency <ref> [2, 3, 4] </ref>. Push provides a facility for experimenting with new or extended operating system services. Examples of these services include buffer management, file system support, process management, interprocess communication, con-currency control, atomicity control, and crash recovery. <p> Subsection 3.5 suggests ways to reduce this overhead. The multi RPC program can be easily modified to provide services that read/write data from/to different sites with one system call. Quorum formation can also be efficiently implemented using similar kernel-resident routines [8]. 3.3 Commitment Protocol In Camelot <ref> [4] </ref>, the authors suggest that certain distributed transactions protocols can be added to the operating system to improve performance and to raise the level of the operating system interface. In database-oriented operating systems, commitment protocols can be added to the kernel.
Reference: [5] <author> Kenneth Birman and Keith Marzullo. </author> <title> ISIS and the META project. </title> <booktitle> Sun Technology, </booktitle> <pages> pages 90-104, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The services that are present in current operating systems are general-purpose and do not satisfy the demands of distributed 1 Unix is a trademark of AT&T Bell Laboratories. 3 transaction processing algorithms <ref> [2, 3, 5] </ref>. For instance, locking facilities and buffer man-agement are generally implemented by database systems because the services provided in operating systems are inadequate. This paper is organized as follows. Section 2 discusses design, implementation, and performance issues of Push. Section 3 describes experiments conducted with Push.
Reference: [6] <author> Bharat Bhargava, Tom Mueller, and John Riedl. </author> <title> Experimental analysis of layered Ethernet software. </title> <booktitle> In Proc of the ACM-IEEE Computer Society 1987 Fall Joint Computer Conference, </booktitle> <pages> pages 559-568, </pages> <address> Dallas, Texas, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: To implement the user and kernel versions of the communication services, we used the SE suite of protocols. SE (Simple Ethernet) is a set of streamlined, low-overhead communication protocols for the Ethernet <ref> [6] </ref>. The three services compared in each of these experiments provide the same functionality. Experimental Method. All of the experiments were run in similar conditions. The machines were idle, and the measurements were taken at night when the network was relatively idle. <p> The numbers in the first column are estimates that we obtained using the measurements observed in <ref> [6] </ref>. For twenty destinations, we observe a 27% improvement over the user-level program and a 26% degradation from the kernel-level routine. <p> For example, the Unix BSD model for interprocess communication, whose main goal is generality, results in an expensive sequence of procedure calls. Many of those procedure calls are irrelevant to individual messages <ref> [6] </ref>. The Synthesis project also studied the problem of reducing the context switch overhead [18]. Their solution is based on additional hardware support. Push can be used to reduce context switch time along with Synthesis improvements in the performance of layered code, on systems without the special hardware support.
Reference: [7] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: Simulated multicast inside the kernel is an important service for short-lived mul-ticast groups. Short-lived multicast groups are frequently used in distributed transaction processing systems. Each transaction involves a different subset of sites, based on the distribution of replicas of items read or written <ref> [7] </ref>. Multicasting to the subset of sites happens during transaction processing (to read/write or to form quorums [8]) and during transaction 4 The times were collected using Peter Danzig's and Steve Melvin's timer board. It uses the timer chip AM9513A from Advanced Micro Devices, Inc.
Reference: [8] <author> D. K. Gifford. </author> <title> Weighted voting for replicated data. </title> <booktitle> In Proc of the 7th Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <address> Asilomar, California, </address> <month> December </month> <year> 1979. </year>
Reference-contexts: Short-lived multicast groups are frequently used in distributed transaction processing systems. Each transaction involves a different subset of sites, based on the distribution of replicas of items read or written [7]. Multicasting to the subset of sites happens during transaction processing (to read/write or to form quorums <ref> [8] </ref>) and during transaction 4 The times were collected using Peter Danzig's and Steve Melvin's timer board. It uses the timer chip AM9513A from Advanced Micro Devices, Inc. The timer has a resolution of up to four ticks per microsecond. 9 commitment. <p> Subsection 3.5 suggests ways to reduce this overhead. The multi RPC program can be easily modified to provide services that read/write data from/to different sites with one system call. Quorum formation can also be efficiently implemented using similar kernel-resident routines <ref> [8] </ref>. 3.3 Commitment Protocol In Camelot [4], the authors suggest that certain distributed transactions protocols can be added to the operating system to improve performance and to raise the level of the operating system interface. In database-oriented operating systems, commitment protocols can be added to the kernel.
Reference: [9] <author> Bharat Bhargava, Enrique Mafla, and John Riedl. </author> <title> Communication in the Raid distributed database system. </title> <journal> International Journal on Computers and ISDN Systems, </journal> (21):81-92, 1991. 
Reference-contexts: In order to support multicast, this utility must call the device driver for each member in the multicast group. The kernel-level SE multicast utility uses the multiSE device driver <ref> [9] </ref>. This device driver can send the same message to a group of destinations on the Ethernet with one system call.
Reference: [10] <author> D. Skeen. </author> <title> Nonblocking commit protocols. </title> <booktitle> In Proc of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 133-147, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1982. </year>
Reference-contexts: The performance is improved because of the reduced user-kernel interaction. The database system can also readily switch between alternative commitment protocols according to the demands of the system. Two-phase commit protocols are often 12 used despite their blocking drawback <ref> [10] </ref>, because the message exchanges that take place during each phase impose a significant overhead on the system. The performance improvements provided by Push can make the implementation of three-phase commit protocols a practical solution to the blocking problems.
Reference: [11] <author> J. Bachant and J. McDermot. </author> <title> R1 revisited: Four years in the trenches. </title> <journal> AI Magazine, </journal> <volume> 5(3) </volume> <pages> 21-32, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: Monolithic operating systems offer a limited degree of flexibility. Configuration files and compilation or boot-time parameters provide options thought of by the system designers. Digital Equipment Corporation's configuration expert system, XICON, can assist users in the customized configuration of a complete computing system <ref> [11] </ref>. To avoid overcrowding in the kernel, certain operating systems services have been implemented as user-level processes. These processes called daemons, run in close relation with the kernel. However, because all crucial information resides inside the kernel, performance and even consistency cannot be guaranteed.
Reference: [12] <author> C. A. R. Hoare. </author> <title> Operating systems: Their purpose, objectives, functions, and scope. </title> <editor> In Hoare and Perrot, editors, </editor> <booktitle> Operating System Techniques, </booktitle> <pages> pages 11-25. </pages> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: The operating system could be initialized with a small set of services, and dynamically extended as necessary. Hoare proposed the micro-kernel approach to operating systems <ref> [12] </ref>. Under this model, the kernel provides only basic services, i.e., process management, memory management, and interprocess communication. On top of this infrastructure, a customized operating system can be built to support a given processing and hardware environment.
Reference: [13] <author> David R. Cheriton. </author> <title> The V kernel: A software base for distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year> <month> 18 </month>
Reference-contexts: In this case, generalizing the operating system services to accommodate all potential uses of the system results in obtrusive, unreliable, and inefficient kernels. In the last decade, several micro-kernel operating systems have been proposed and implemented <ref> [13, 14, 15, 16] </ref>. Operating system services are provided as server processes. These servers can provide not only conventional operating system services such as file systems and network communication, but many other services for different applications.
Reference: [14] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proc of the 11th Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: In this case, generalizing the operating system services to accommodate all potential uses of the system results in obtrusive, unreliable, and inefficient kernels. In the last decade, several micro-kernel operating systems have been proposed and implemented <ref> [13, 14, 15, 16] </ref>. Operating system services are provided as server processes. These servers can provide not only conventional operating system services such as file systems and network communication, but many other services for different applications.
Reference: [15] <author> Partha Dasgupta, Richard J. LeBlanc Jr., and William F. Appelbe. </author> <title> The CLOUDS distributed operating system: Functional description, implementation details and related work. </title> <booktitle> In Proc of the 8th Intl Conf on Distributed Computing Systems, </booktitle> <address> San Jose, CA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: In this case, generalizing the operating system services to accommodate all potential uses of the system results in obtrusive, unreliable, and inefficient kernels. In the last decade, several micro-kernel operating systems have been proposed and implemented <ref> [13, 14, 15, 16] </ref>. Operating system services are provided as server processes. These servers can provide not only conventional operating system services such as file systems and network communication, but many other services for different applications.
Reference: [16] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> CHORUS distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <year> 1988. </year>
Reference-contexts: In this case, generalizing the operating system services to accommodate all potential uses of the system results in obtrusive, unreliable, and inefficient kernels. In the last decade, several micro-kernel operating systems have been proposed and implemented <ref> [13, 14, 15, 16] </ref>. Operating system services are provided as server processes. These servers can provide not only conventional operating system services such as file systems and network communication, but many other services for different applications.
Reference: [17] <author> Henry Massalin and Calton Pu. </author> <title> Fine-grain adaptive scheduling using feedback. </title> <journal> Computing Systems, </journal> <volume> 3(1) </volume> <pages> 139-173, </pages> <year> 1990. </year>
Reference-contexts: Switching between domains significantly increases the cost of the services. Push can be used in a small kernel to supply crucial operating system services without context switch and protection domain overhead. The Synthesis kernel suggests a solution that goes beyond the efficiency/power tradeoff that was mentioned above <ref> [17] </ref>. This approach employs a monolithic kernel and uses several techniques to specialize the kernel code that executes specific requests. These techniques include the elimination of redundant computation and the collapsing of kernel layers.
Reference: [18] <author> Henry Massalin and Calton Pu. </author> <title> Fine-grain scheduling. </title> <booktitle> In Proc of the USENIX Workshop on Experiences with Distributed and Multiprocessor Systems, </booktitle> <pages> pages 91-104, </pages> <address> Fort Lauderdale, FL, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: For example, the Unix BSD model for interprocess communication, whose main goal is generality, results in an expensive sequence of procedure calls. Many of those procedure calls are irrelevant to individual messages [6]. The Synthesis project also studied the problem of reducing the context switch overhead <ref> [18] </ref>. Their solution is based on additional hardware support. Push can be used to reduce context switch time along with Synthesis improvements in the performance of layered code, on systems without the special hardware support. Streams increase the modularity and reusability of kernel code in the input-output subsystem [19].
Reference: [19] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Their solution is based on additional hardware support. Push can be used to reduce context switch time along with Synthesis improvements in the performance of layered code, on systems without the special hardware support. Streams increase the modularity and reusability of kernel code in the input-output subsystem <ref> [19] </ref>. Streams try to eliminate the duplication of functionality existing in conventional 15 device drivers. A stream is a two-way connection between a process and a device driver. Modules that process data flowing along this two-way path can be inserted and deleted dynamically, changing the behavior of the user interface.
Reference: [20] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: New communication protocol suites can be implemented and tested using a stream connecting the user with the network interface. Modules written in Push can then implement the different layers of the protocol suite. The packet filter presents another alternative to the efficiency/flexibility dilemma for network code implementation <ref> [20] </ref>. The packet filter demultiplexes network packets according to rules specified by the users. These rules can be quite complex and can be changed dynamically. By running inside the kernel, the packet filter eliminates much of the context switch overhead incurred by user-level demultiplexers.
Reference: [21] <author> Brian N. Bershad and C. Brian Pinkerton. Watchdogs: </author> <title> Extending the UNIX file system. </title> <booktitle> In Proc of the USENIX Winter Conference, </booktitle> <pages> pages 267-275, </pages> <address> Dallas, TX, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: The packet filter implementation supports evaluation of straight-line predicates. Push extends the technique to general purpose algorithms. Extensions to the Unix file system have also been proposed in <ref> [21] </ref>. There, the additional file system services are implemented in user-level servers. The Unix kernel is modified to associate special processing requests with files. <p> IntelligentI/O is a similar idea in which rules determine actions to be performed at I/O time [22]. The rule processing is performed in the kernel, but actions execute in user space. Push extends <ref> [21] </ref> and [22] by providing the same functionality with enhanced performance and security.
Reference: [22] <author> Gabriel Broner and Patrick Powell. </author> <title> Intelligent I/O: Rule-based input/ouput processing for operating systems. </title> <journal> Operating Systems Review, </journal> <volume> 25(3), </volume> <month> July </month> <year> 1991. </year> <note> 19 APPENDICES </note>
Reference-contexts: For instance, an encrypted file system can be implemented transparently by modifying the read and write system calls to automatically encrypt and decrypt blocks of the file. IntelligentI/O is a similar idea in which rules determine actions to be performed at I/O time <ref> [22] </ref>. The rule processing is performed in the kernel, but actions execute in user space. Push extends [21] and [22] by providing the same functionality with enhanced performance and security. <p> IntelligentI/O is a similar idea in which rules determine actions to be performed at I/O time <ref> [22] </ref>. The rule processing is performed in the kernel, but actions execute in user space. Push extends [21] and [22] by providing the same functionality with enhanced performance and security.
References-found: 22

