URL: http://www.cs.purdue.edu/homes/palsberg/paper/scp94.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk mis@daimi.aau.dk  
Title: Static Typing for Object-Oriented Programming  
Author: Jens Palsberg Michael I. Schwartzbach 
Address: Ny Munkegade DK-8000 -Arhus C, Denmark  
Affiliation: Computer Science Department Aarhus University  
Note: Science of Computer Programming 23(1):19-53, 1994.  
Abstract: We develop a theory of statically typed object-oriented languages. It represents classes as labeled, regular trees, types as finite sets of classes, and subclassing as a partial order on trees. We show that our subclassing order strictly generalizes inheritance, and that a novel genericity mechanism arises as an order-theoretic complement. This mechanism, called class substitution, is pragmatically useful and can be implemented efficiently.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <month> 38 </month> <year> 1974. </year>
Reference-contexts: Definition 5.8: Let G be a directed, rooted graph containing a path from the root to each vertex. A particular unfolding of G, called unfold (G), is obtained by the following variation of the standard depth-first search algorithm <ref> [1] </ref> starting in the root. The modification is that if the current edge leads to a previously visited vertex in a different strongly connected component, then a fresh copy of that entire component is inserted in the graph.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: It is well-known that such an equation system has a unique solution [19], which clearly is an L-tree. If any part of a class is recursive, then the tree will be infinite. Quite often, recursive types are represented as regular trees with nodes labeled by type constructors <ref> [2] </ref>. This is in fact what we have done, with the proviso that we consider every class as a user-defined type constructor|rather than as a user-defined type. We have now abstracted away from the class names, which obviously cannot be uniquely recovered.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <publisher> The Ben-jamin/Cummings Publishing Company, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Object-oriented programming is becoming widespread. Numerous programming languages supporting object-oriented concepts are in use, and theories about object-oriented design and implementation are being developed and applied <ref> [21, 3, 14] </ref>. An important issue in object-oriented programming is to obtain reusable software components [30]. This is achieved through the notions of object, class, inheritance, late binding, and the imperative constructs of variables and assignments. <p> For a denotational semantics of inheritance, see [16, 48, 31, 17]. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method <ref> [21, 3, 14, 30] </ref>. Common to all approaches is that the superclass is created before the subclass. We will henceforth use the terminology that the subclass is temporally dependent on its superclass. A class can be a subclass of another class which itself is defined by inheritance.
Reference: [4] <author> Alan H. Borning and Daniel H. H. Ingalls. </author> <title> A type declaration and inference system for Smalltalk. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-141, </pages> <year> 1982. </year>
Reference-contexts: The purpose of a type system is to allow the programmer to annotate programs with information about which methods are available in a given object, and to allow the compiler to guarantee the the error messageNotUnderstood will never occur <ref> [4, 9] </ref>. The latter immediately enables compile-time optimizations because a number of checks need not be inserted into the code. In Smalltalk, any object can be assigned to any variable.
Reference: [5] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. OOP-SLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 303-311, </pages> <year> 1990. </year>
Reference-contexts: Dually, the construct inner directs the search to go from the present location towards the right. This will nearly give the usual semantics, and is certainly in line with the explanation given in <ref> [5] </ref>. When expanding the inheritance shorthand it is necessary to be careful when encountering recursive occurrences of a class. A class C is recursive if C has-a C. If a class D inherits this class C, then after expansion, all occurrences of C must have been transformed into D.
Reference: [6] <author> Ronald J. Brachman. </author> <title> "I lied about the trees" or, defaults and definitions in knowledge representation. </title> <journal> The AI Magazine, </journal> <volume> 6(3) </volume> <pages> 80-93, </pages> <year> 1985. </year>
Reference-contexts: This is actually enforced in Smalltalk. In this situation, the inheritance hierarchy is a tree, otherwise it is a forest. If C is the superclass and D is the subclass, then it is common to say that D is-a C <ref> [6, 55] </ref>. For example, if Student is a subclass of Person, then it seems reasonable to say that Student is-a Person. It is convenient to let is-a denote the transitive closure of this relation. The other possible relation between classes is has-a.
Reference: [7] <author> Kim B. Bruce. </author> <title> The equivalence of two semantic definitions for inheritance in object-oriented languages. </title> <booktitle> In Proc. Mathmatical Foundations of Programming Semantics, </booktitle> <pages> pages 102-124. </pages> <publisher> Springer-Verlag (LNCS 598), </publisher> <year> 1992. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types [40, 13, 23], or F -bounded constraints <ref> [8, 15, 7] </ref> in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [8] <author> Peter S. Canning, William R. Cook, Walter L. Hill, John Mitchell, and Wal-ter G. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types [40, 13, 23], or F -bounded constraints <ref> [8, 15, 7] </ref> in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [9] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proc. OOP-SLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 457-467. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The purpose of a type system is to allow the programmer to annotate programs with information about which methods are available in a given object, and to allow the compiler to guarantee the the error messageNotUnderstood will never occur <ref> [4, 9] </ref>. The latter immediately enables compile-time optimizations because a number of checks need not be inserted into the code. In Smalltalk, any object can be assigned to any variable.
Reference: [10] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In Gilles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes <ref> [10, 41] </ref>, polymorphic types [40, 13, 23], or F -bounded constraints [8, 15, 7] in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [11] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report No. 45, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values. Furthermore, the coercion models|while being very general in some respects| do not support variables and assignments, because variable (mutable) types have no non-trivial subtypes, as observed by Cardelli <ref> [11] </ref>. In a functional language, an assignment must be emulated by the creation of an updated copy, and it is extremely hard to preserve the type of the original value.
Reference: [12] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <booktitle> In Proc. Mathmatical Foundations of Programming Semantics, </booktitle> <pages> pages 22-52. </pages> <publisher> Springer-Verlag (LNCS 442), </publisher> <year> 1989. </year> <month> 39 </month>
Reference-contexts: It was long believed that bounded parametric polymorphism was sufficient [13], but it has been realized that considerably more fine-grained type systems are required to handle even simple updates <ref> [12] </ref>. Graver and Johnson's type system for Smalltalk [29, 27, 28] has much in common with ours. Their types are essentially finite sets of classes, but they have to axiomatize a subtype relation that corresponds exactly to set inclusion because 6 the type system involves type variables.
Reference: [13] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types <ref> [40, 13, 23] </ref>, or F -bounded constraints [8, 15, 7] in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values. <p> In a functional language, an assignment must be emulated by the creation of an updated copy, and it is extremely hard to preserve the type of the original value. It was long believed that bounded parametric polymorphism was sufficient <ref> [13] </ref>, but it has been realized that considerably more fine-grained type systems are required to handle even simple updates [12]. Graver and Johnson's type system for Smalltalk [29, 27, 28] has much in common with ours.
Reference: [14] <author> Peter Coad and Edward Yourdon. </author> <title> Object-Oriented Analysis. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Object-oriented programming is becoming widespread. Numerous programming languages supporting object-oriented concepts are in use, and theories about object-oriented design and implementation are being developed and applied <ref> [21, 3, 14] </ref>. An important issue in object-oriented programming is to obtain reusable software components [30]. This is achieved through the notions of object, class, inheritance, late binding, and the imperative constructs of variables and assignments. <p> For a denotational semantics of inheritance, see [16, 48, 31, 17]. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method <ref> [21, 3, 14, 30] </ref>. Common to all approaches is that the superclass is created before the subclass. We will henceforth use the terminology that the subclass is temporally dependent on its superclass. A class can be a subclass of another class which itself is defined by inheritance.
Reference: [15] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types [40, 13, 23], or F -bounded constraints <ref> [8, 15, 7] </ref> in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [16] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation, </journal> <volume> 114(2) </volume> <pages> 329-350, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: It has been argued by Snyder [53] that much better encapsulation is achieved if only the existing methods can be referred; we ignore this consideration in this paper. For a denotational semantics of inheritance, see <ref> [16, 48, 31, 17] </ref>. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method [21, 3, 14, 30]. Common to all approaches is that the superclass is created before the subclass.
Reference: [17] <author> William R. Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: It has been argued by Snyder [53] that much better encapsulation is achieved if only the existing methods can be referred; we ignore this consideration in this paper. For a denotational semantics of inheritance, see <ref> [16, 48, 31, 17] </ref>. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method [21, 3, 14, 30]. Common to all approaches is that the superclass is created before the subclass.
Reference: [18] <author> William R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <journal> The Computer Journal, </journal> <volume> 32(4) </volume> <pages> 305-311, </pages> <year> 1989. </year>
Reference-contexts: We take the liberty of using a for-statement, even though is has not been included in the syntax. Class Matrixmatrix is obtained through class substitution alone. It seems that class substitution could solve the problems in the Eiffel type system that were reported by Cook <ref> [18] </ref>, since attributes cannot be redeclared in isolation in subclasses, there are no asymmetries as with declaration by association, and generic-instantiation can be expressed as subclassing. 8 Separate Compilation and Infinite Types One common aspect of many existing object-oriented languages has so far not been captured by our framework.
Reference: [19] <author> Bruno Courcelle. </author> <title> Infinite trees in normal form and recursive equations having a unique solution. </title> <journal> Mathematical Systems Theory, </journal> <volume> 13 </volume> <pages> 131-180, </pages> <year> 1979. </year>
Reference-contexts: If the gap replaced the class C j , then the subtree is tree (C j ); if the gap replaced selfClass, then the subtree is tree (C i ). It is well-known that such an equation system has a unique solution <ref> [19] </ref>, which clearly is an L-tree. If any part of a class is recursive, then the tree will be infinite. Quite often, recursive types are represented as regular trees with nodes labeled by type constructors [2].
Reference: [20] <author> Bruno Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25(1) </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: The mathematical framework is a kind of labeled trees, which we shall call L-trees. Definition 3.1: Let be a finite alphabet. An L-tree over is an ordered, node-labeled, regular tree. We recall that a tree is regular when it has only finitely many different subtrees <ref> [20] </ref>. The labels are finite strings over [ f*g, where it is assumed that * 62 . The empty label is denoted by . We shall refer to the special symbol * as a gap.
Reference: [21] <author> Brad J. Cox. </author> <title> Object Oriented Programming, an Evolutionary Approach. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Object-oriented programming is becoming widespread. Numerous programming languages supporting object-oriented concepts are in use, and theories about object-oriented design and implementation are being developed and applied <ref> [21, 3, 14] </ref>. An important issue in object-oriented programming is to obtain reusable software components [30]. This is achieved through the notions of object, class, inheritance, late binding, and the imperative constructs of variables and assignments. <p> For a denotational semantics of inheritance, see [16, 48, 31, 17]. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method <ref> [21, 3, 14, 30] </ref>. Common to all approaches is that the superclass is created before the subclass. We will henceforth use the terminology that the subclass is temporally dependent on its superclass. A class can be a subclass of another class which itself is defined by inheritance.
Reference: [22] <author> Ole-Johan Dahl, Bjtrn Myhrhaug, and Kristen Nygaard. </author> <title> Simula 67 common base language. </title> <type> Technical report, </type> <institution> Norwegian Computing Center, Oslo, Norway, </institution> <year> 1968. </year>
Reference: [23] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types <ref> [40, 13, 23] </ref>, or F -bounded constraints [8, 15, 7] in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [24] <author> Jean D. Ichbiah et al. </author> <title> Reference Manual for the Ada Programming Language. </title> <type> US DoD, </type> <month> July </month> <year> 1982. </year>
Reference-contexts: This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity [38, 39, 50, 34, 49, 42]. Similar constructs are found in conventional procedural languages, for example Ada generic packages <ref> [24] </ref>, and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied. Generic-instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized.
Reference: [25] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: An important issue in object-oriented programming is to obtain reusable software components [30]. This is achieved through the notions of object, class, inheritance, late binding, and the imperative constructs of variables and assignments. Such features are found for example in the Smalltalk language <ref> [25] </ref> in which a large number of reusable classes have been written. Smalltalk, however, is untyped. Though this is ideal for prototyping and exploratory development, a static type system is required to ensure that programs are readable, reliable, and efficient. <p> Inheritance can be viewed as a shorthand: it allows the definition of a class to be a modification of an existing one. More specifically, it allows the construction of subclasses by adding variables and methods, and by overriding method bodies <ref> [25, 57] </ref>. A thorough discussion of inheritance is given in a later section. The difference between inheritance and subtyping is illustrated in figure 2 which displays a class hierarchy discussed in [36], together with the corresponding type hierarchy. <p> The loss of an explicit class hierarchy may at first seem to cause severe problems, since some programming mechanisms depend on exactly this. In particular, we think about redefinition of method bodies in subclasses, and about the constructs super <ref> [25] </ref> and inner [33, 37]. However, these mechanisms depend primarily on the existence of multiple implementations of methods. This we can certainly handle, since a label contains a sequence of implementations of methods|several of which may have the same name.
Reference: [26] <author> George Gratzer. </author> <title> General Lattice Theory. </title> <publisher> Birkhauser, </publisher> <year> 1978. </year> <month> 40 </month>
Reference-contexts: We call Q; R an orthogonal basis for P when * Q ? P R * Q ? P R 0 ) R R 0 This generalizes the notion of basis in <ref> [26] </ref>. 2 For example, if (S 1 ; 1 ) and (S 2 ; 2 ) are partial orders, then 1 fi 4 (S 2 ) and 4 (S 1 )fi 2 form an orthogonal basis for 1 fi 2 .
Reference: [27] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Sev--enteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: It was long believed that bounded parametric polymorphism was sufficient [13], but it has been realized that considerably more fine-grained type systems are required to handle even simple updates [12]. Graver and Johnson's type system for Smalltalk <ref> [29, 27, 28] </ref> has much in common with ours. Their types are essentially finite sets of classes, but they have to axiomatize a subtype relation that corresponds exactly to set inclusion because 6 the type system involves type variables.
Reference: [28] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> August </month> <year> 1989. </year> <month> UIUCD-R-89-1539. </month>
Reference-contexts: It was long believed that bounded parametric polymorphism was sufficient [13], but it has been realized that considerably more fine-grained type systems are required to handle even simple updates [12]. Graver and Johnson's type system for Smalltalk <ref> [29, 27, 28] </ref> has much in common with ours. Their types are essentially finite sets of classes, but they have to axiomatize a subtype relation that corresponds exactly to set inclusion because 6 the type system involves type variables.
Reference: [29] <author> Ralph E. Johnson. </author> <title> Type-checking Smalltalk. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 315-321. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Any choice of type system for a language must be able to remedy some or all of the above deficiencies <ref> [29] </ref>. Types may be used as annotations, and those can be read not only by humans but also by the compiler which may be able to exhibit a safety-guarantee and perform compile-time optimizations. <p> It was long believed that bounded parametric polymorphism was sufficient [13], but it has been realized that considerably more fine-grained type systems are required to handle even simple updates [12]. Graver and Johnson's type system for Smalltalk <ref> [29, 27, 28] </ref> has much in common with ours. Their types are essentially finite sets of classes, but they have to axiomatize a subtype relation that corresponds exactly to set inclusion because 6 the type system involves type variables.
Reference: [30] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reuable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Object-oriented programming is becoming widespread. Numerous programming languages supporting object-oriented concepts are in use, and theories about object-oriented design and implementation are being developed and applied [21, 3, 14]. An important issue in object-oriented programming is to obtain reusable software components <ref> [30] </ref>. This is achieved through the notions of object, class, inheritance, late binding, and the imperative constructs of variables and assignments. Such features are found for example in the Smalltalk language [25] in which a large number of reusable classes have been written. Smalltalk, however, is untyped. <p> For a denotational semantics of inheritance, see [16, 48, 31, 17]. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method <ref> [21, 3, 14, 30] </ref>. Common to all approaches is that the superclass is created before the subclass. We will henceforth use the terminology that the subclass is temporally dependent on its superclass. A class can be a subclass of another class which itself is defined by inheritance.
Reference: [31] <author> Samuel Kamin. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Fifteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: Note that we ignore keeping track of nil-values; this can be treated separately by flow analysis. A formal proof of these claims should be based on a dynamic semantics of the example language <ref> [48, 31] </ref>. We will not go into the details in this paper, however, but move on to define a convenient representation of classes. 3.3 Tree Representations of Classes We shall work with a slightly abstracted form of classes, which will allow us to give a formal treatment of their relationships. <p> It has been argued by Snyder [53] that much better encapsulation is achieved if only the existing methods can be referred; we ignore this consideration in this paper. For a denotational semantics of inheritance, see <ref> [16, 48, 31, 17] </ref>. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method [21, 3, 14, 30]. Common to all approaches is that the superclass is created before the subclass.
Reference: [32] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Treating nil as a non-instance is in line with its implementation in typed languages such as C++ [54], Eiffel [39], and Simula [22]/Beta <ref> [32] </ref>. In the language we later present, nil is in fact the only constant value.
Reference: [33] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> Classification of actions or inheritance also for methods. </title> <booktitle> In Proc. ECOOP'87, European Conference on Object-Oriented Programming, </booktitle> <pages> pages 98-107. </pages> <publisher> Springer-Verlag (LNCS 276), </publisher> <year> 1987. </year>
Reference-contexts: The loss of an explicit class hierarchy may at first seem to cause severe problems, since some programming mechanisms depend on exactly this. In particular, we think about redefinition of method bodies in subclasses, and about the constructs super [25] and inner <ref> [33, 37] </ref>. However, these mechanisms depend primarily on the existence of multiple implementations of methods. This we can certainly handle, since a label contains a sequence of implementations of methods|several of which may have the same name.
Reference: [34] <author> Karl J. Lieberherr and Arthur J. Riel. </author> <title> Contributions to teaching object-oriented design and programming. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 11-22. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied.
Reference: [35] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Scaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity [38, 39, 50, 34, 49, 42]. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters <ref> [35] </ref>. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied. Generic-instantiation of parameterized classes is less flexible than inheritance, since any class can be inherited but is not in itself parameterized.
Reference: [36] <author> Ole Lehrmann Madsen, Boris Magnusson, and Birger Mtller-Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In Proc. OOP-SLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 140-150, </pages> <year> 1990. </year> <month> 41 </month>
Reference-contexts: More specifically, it allows the construction of subclasses by adding variables and methods, and by overriding method bodies [25, 57]. A thorough discussion of inheritance is given in a later section. The difference between inheritance and subtyping is illustrated in figure 2 which displays a class hierarchy discussed in <ref> [36] </ref>, together with the corresponding type hierarchy. Notice that we turn the class hierarchy "upside-down" in order to get the smallest class at the bottom, and that the figure uses the notation " C for the set of all subclasses of C, even potential ones. <p> The class hierarchy is a tree, whereas the type hierarchy is a lattice. Note that the Beta group has suggested interpreting nil as an instance of an auxiliary class on top of the class hierarchy <ref> [36] </ref>. This is awkward because it implies that this class can be obtained by some sort of multiple inheritance of all other classes. This again implies that instances of this auxiliary class should be able to respond to any message; clearly nil is not able to do this. <p> For cones, membership is just subclassing, and inclusion coincides with reverse subclassing, i.e. A perfect match is not possible, but the types in a language such as Beta correspond closely to either singletons or cones <ref> [36] </ref>. Recall the important property of our framework that can be stated as the slogan: subclassing preserves subtyping. In the presence of cones, the picture changes dramatically.
Reference: [37] <author> Ole Lehrmann Madsen and Birger Mtller-Pedersen. </author> <title> Virtual classes: A pow-erful mechanism in object-oriented programming. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 397-406. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The loss of an explicit class hierarchy may at first seem to cause severe problems, since some programming mechanisms depend on exactly this. In particular, we think about redefinition of method bodies in subclasses, and about the constructs super [25] and inner <ref> [33, 37] </ref>. However, these mechanisms depend primarily on the existence of multiple implementations of methods. This we can certainly handle, since a label contains a sequence of implementations of methods|several of which may have the same name.
Reference: [38] <author> Bertrand Meyer. </author> <title> Genericity versus inheritance. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 391-405. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied. <p> Thus, class substitution is also a genericity mechanism, and in contrast to parameterized classes it is the orthogonal complement of inheritance. This indicates that class substitution gives more expressive power to an object-oriented language than parameterized classes, and indeed Meyer <ref> [38] </ref> argued that parameterized classes can be simulated by inheritance. 32 ? ? ? - S S I I Booleanmatrix Matrixmatrix Matrix Ring [Object DoubleRingArray] BooleanringRing [Object Boolean]Ring BooleanstackStackObject 33 class Array method at (i: Integer) returns Object . . . method atput (i: Integer ; x: Object) returns selfClass .
Reference: [39] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> En-glewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Treating nil as a non-instance is in line with its implementation in typed languages such as C++ [54], Eiffel <ref> [39] </ref>, and Simula [22]/Beta [32]. In the language we later present, nil is in fact the only constant value. <p> Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied.
Reference: [40] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes [10, 41], polymorphic types <ref> [40, 13, 23] </ref>, or F -bounded constraints [8, 15, 7] in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [41] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <year> 1990. </year>
Reference-contexts: They represent objects as records and methods as functions, and involve coercions together with subtypes <ref> [10, 41] </ref>, polymorphic types [40, 13, 23], or F -bounded constraints [8, 15, 7] in the description of inheritance. In contrast, traditional object-oriented languages are not based on coercions and do not support methods as values.
Reference: [42] <author> Atsushi Ohori and Peter Buneman. </author> <title> Static type inference for parametric classes. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 445-456. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied.
Reference: [43] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Type substitution for object-oriented programming. </title> <booktitle> In Proc. OOPSLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 151-160, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: However, with our structural equivalence on classes recursive occurrences must be transformed in order to make the subclass statically correct. The problem could be solved by introducing opacity operators on classes, in line with <ref> [43] </ref>. In this paper we will not explore this aspect further. 15 4.3 The Expansion Algorithm We now present the algorithm that expands a program using inheritance into an equivalent one that does not. <p> For example, if we try to obtain Booleanstack by textually substituting occurrences of Object by Boolean, then among others the expression space.atput (index,x) (in push) becomes statically incorrect; it will have an Boolean instance where an Object instance is required. For further examples, see <ref> [43] </ref>. Another drawback of parameterized classes is that they cannot be gradually generically-instantiated. This makes it awkward to, for example, declare a class Ring, then specialize it to a class Matrix, and finally specialize Matrix to a class Booleanmatrix.
Reference: [44] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: It is not sufficient for expressing mutually recursive classes, however. For that, it is necessary to use the class names directly. We have no primitive types (like integer and boolean) nor type constructors (like list) because we can program classes that encode them, see <ref> [44] </ref>. Note that we ignore the issues of concurrency and persistence [56]. 3.2 Static Correctness We define correctness of a method body with respect to the name of the enclosing class, and global and local environments. These can be uniquely determined from the program syntax.
Reference: [45] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> What is type-safe code reuse? In Proc. </title> <booktitle> ECOOP'91, Fifth European Conference on Object-Oriented Programming, </booktitle> <pages> pages 325-341. </pages> <publisher> Springer-Verlag (LNCS 512), </publisher> <address> Geneva, Switzerland, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: This arises directly from the application on U of a partial order on general L-trees. 5.1 A Generalized Interpreter In <ref> [45] </ref> we present a generalization of a nave Smalltalk interpreter. This interpreter supports inheritance through a method lookup|a run-time search for implementations of methods. Our extended interpreter also does a run-time search for arguments to new and instanceOf operations. <p> Our extended interpreter also does a run-time search for arguments to new and instanceOf operations. This allows a more general form of code reuse, which we can express through a partial order / on classes. In <ref> [45] </ref> we give a precise description of the run-time environments of the extended interpreter, and we show the following property: if T 1 / T 2 holds, then any run-time implementation of T 1 can be extended to yield a run-time implementation 17 of T 2 . <p> all subtype checks will remain satisfied; hence, the code of the superclass can only be reused in a manner that preserves static correctness. * the recursive structure must be preserved: this is essential for allowing the code to be reused since different code is generated for selfClass and other classes <ref> [45] </ref>. The partial order / is our generalized notion of subclassing, such that if A is the superclass and B is the subclass, then A / B. It may seem strange that super is smaller than sub, but this is a common confusion of terminology.
Reference: [46] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: Given that a program contains no temporal cycles, the classes can be sorted in temporal order and then expanded one by one. For a detailed explanation and examples of this, see <ref> [46] </ref>. 5 Generalized Subclassing The main purpose of providing an independent notion of classes is to define a generalized, structural notion of subclassing. <p> Using a well-formedness criterion similar to the one presented in Section 4, the substitution specifications can be 31 sorted and expanded one by one. For a detailed explanation and examples of this, see <ref> [46] </ref>. 7.3 Pragmatics The fact that class substitution realizes / S is not sufficient to ensure that class substitution is a useful and pleasant programming mechanism. Only pragmatic arguments can really justify such a claim. <p> It can be useful for programmers who want to use inheritance but are required to implement their programs in a language which does not support it. Further explanations of the expansion algorithms in this paper are given in <ref> [46] </ref>. Acknowledgement. The authors thank Ole Lehrmann Madsen, Peter Mosses, and Flemming Nielson for helpful comments on drafts of the paper.
Reference: [47] <author> Claus H. Pedersen. </author> <title> Extending ordinary inheritance schemes to include generalization. </title> <booktitle> In Proc. OOPSLA'89, ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 407-418, </pages> <year> 1989. </year> <month> 42 </month>
Reference-contexts: Such relations will be independent both of class names and of the particular shorthands that can be used in program texts. So far, the only shorthand we have encountered is inheritance, but later on we will define another called class substitution. Pedersen <ref> [47] </ref> proposed the notion of generalization which is the inverse of inheritance. The loss of an explicit class hierarchy may at first seem to cause severe problems, since some programming mechanisms depend on exactly this.
Reference: [48] <author> Uday S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: Note that we ignore keeping track of nil-values; this can be treated separately by flow analysis. A formal proof of these claims should be based on a dynamic semantics of the example language <ref> [48, 31] </ref>. We will not go into the details in this paper, however, but move on to define a convenient representation of classes. 3.3 Tree Representations of Classes We shall work with a slightly abstracted form of classes, which will allow us to give a formal treatment of their relationships. <p> It has been argued by Snyder [53] that much better encapsulation is achieved if only the existing methods can be referred; we ignore this consideration in this paper. For a denotational semantics of inheritance, see <ref> [16, 48, 31, 17] </ref>. 13 4.2 Properties Inheritance can be used in various ways, ranging from undisciplined code-grabbing to disciplined program structuring based on a hierarchical design method [21, 3, 14, 30]. Common to all approaches is that the superclass is created before the subclass.
Reference: [49] <author> David Sandberg. </author> <title> An alternative to subclassing. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 424-428. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied.
Reference: [50] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 9-16. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Thus, Stack acts like a parameterized class but is just a class, not a second-order entity. This enables gradual generic-instantiations, as demonstrated below. The use of parameterized classes is the traditional approach to genericity <ref> [38, 39, 50, 34, 49, 42] </ref>. Similar constructs are found in conventional procedural languages, for example Ada generic packages [24], and parameterized Clu clusters [35]. A parameterized class is a second-order entity which is generically-instantiated to specific classes when actual type parameters are supplied.
Reference: [51] <author> Michael I. Schwartzbach. </author> <title> Static correctness of hierarchical procedures. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1990, </booktitle> <pages> pages 32-45. </pages> <publisher> Springer-Verlag (LNCS 443), </publisher> <year> 1990. </year>
Reference-contexts: The transitions of the automaton are determined by the fanout from the corresponding root. 2 These automata provide finite representations of L-trees. The idea of representing a regular tree as an automaton is also exploited in <ref> [51, 52] </ref>. All later algorithms will in reality work on such automata. Proposition 5.3: The partial order v is decidable.
Reference: [52] <author> Michael I. Schwartzbach. </author> <title> Type inference with inequalities. </title> <booktitle> In Proc. TAP-SOFT'91, </booktitle> <pages> pages 441-455. </pages> <publisher> Springer-Verlag (LNCS 493), </publisher> <year> 1991. </year>
Reference-contexts: The transitions of the automaton are determined by the fanout from the corresponding root. 2 These automata provide finite representations of L-trees. The idea of representing a regular tree as an automaton is also exploited in <ref> [51, 52] </ref>. All later algorithms will in reality work on such automata. Proposition 5.3: The partial order v is decidable.
Reference: [53] <author> Alan Snyder. </author> <title> Inheritance and the development of encapsulated software components. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 165-188. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The body of a new method definition may refer to both the existing variables and the existing methods. It has been argued by Snyder <ref> [53] </ref> that much better encapsulation is achieved if only the existing methods can be referred; we ignore this consideration in this paper.
Reference: [54] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Instead of having undefinedObject as an explicit member of all types, we will define nil to be a special primitive value which implicitly has the empty type and, hence, has all types. Treating nil as a non-instance is in line with its implementation in typed languages such as C++ <ref> [54] </ref>, Eiffel [39], and Simula [22]/Beta [32]. In the language we later present, nil is in fact the only constant value.
Reference: [55] <author> David S. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1986. </year>
Reference-contexts: This is actually enforced in Smalltalk. In this situation, the inheritance hierarchy is a tree, otherwise it is a forest. If C is the superclass and D is the subclass, then it is common to say that D is-a C <ref> [6, 55] </ref>. For example, if Student is a subclass of Person, then it seems reasonable to say that Student is-a Person. It is convenient to let is-a denote the transitive closure of this relation. The other possible relation between classes is has-a.
Reference: [56] <author> Peter Wegner. </author> <title> Dimensions of object-based language design. </title> <booktitle> In Proc. OOP-SLA'87, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 168-182, </pages> <year> 1987. </year>
Reference-contexts: For that, it is necessary to use the class names directly. We have no primitive types (like integer and boolean) nor type constructors (like list) because we can program classes that encode them, see [44]. Note that we ignore the issues of concurrency and persistence <ref> [56] </ref>. 3.2 Static Correctness We define correctness of a method body with respect to the name of the enclosing class, and global and local environments. These can be uniquely determined from the program syntax. The global environment maps class names to class descriptions.
Reference: [57] <author> Peter Wegner and Stanley B. Zdonik. </author> <title> Inheritance as an incremental modification mechanism or what like is and isn't like. </title> <booktitle> In Proc. ECOOP'88, European Conference on Object-Oriented Programming, </booktitle> <pages> pages 55-77. </pages> <publisher> Springer-Verlag (LNCS 322), </publisher> <year> 1988. </year>
Reference-contexts: Inheritance can be viewed as a shorthand: it allows the definition of a class to be a modification of an existing one. More specifically, it allows the construction of subclasses by adding variables and methods, and by overriding method bodies <ref> [25, 57] </ref>. A thorough discussion of inheritance is given in a later section. The difference between inheritance and subtyping is illustrated in figure 2 which displays a class hierarchy discussed in [36], together with the corresponding type hierarchy.
Reference: [58] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year> <month> 43 </month>
Reference-contexts: An object groups together variables and procedures (called methods), and prevents direct outside access to the variables; it may be thought of as a module <ref> [58] </ref>. Objects are instances of classes, see for example figure 1. The class Record specifies a pattern from which all Record objects will be created. Such an object is created for example in class File by the expression "Record new" and it gets a separate copy of all variables.
References-found: 58

