URL: http://www.eecs.umich.edu/~farnam/papers/rtpb95.ps
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fashish,farnamg@eecs.umich.edu jrex@research.att.com  
Title: Design and Evaluation of a Window-Consistent Replication Service  
Author: Ashish Mehray, Jennifer Rexfordz, and Farnam Jahaniany 
Keyword: Index terms: real-time systems, fault tolerance, replication protocols, temporal con sistency, scheduling  
Address: Ann Arbor, MI 48109 Florham Park, NJ 07932  
Affiliation: yReal-Time Computing Lab zNetwork Mathematics Research Department of EECS Networking and Distributed Systems The University of Michigan AT&T Labs Research  
Abstract: Real-time applications typically operate under strict timing and dependability constraints. Although traditional data replication protocols provide fault tolerance, real-time guarantees require bounded overhead for managing this redundancy. This paper presents the design and evaluation of a window-consistent primary-backup replication service that provides timely availability of the repository by relaxing the consistency of the replicated data. The service guarantees controlled inconsistency by scheduling update transmissions from the primary to the backup(s); this ensures that client applications interact with a window-consistent repository when a backup must supplant a failed primary. Experiments on our prototype implementation, on a network of Intel-based PCs running RT-Mach, show that the service handles a range of client loads while maintaining bounds on temporal inconsistency. The work reported in this paper was supported in part by the National Science Foundation under Grant MIP-9203895. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the view of the NSF. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso, D. Barbara, and H. Garcia-Molina, </author> <title> "Data caching issues in an information retrieval system," </title> <journal> ACM Trans. Database Systems, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Weak consistency can also improve performance in non-real-time applications. For instance, the quasi-copy model permits some inconsistency between the central data and its cached copies at remote sites <ref> [1] </ref>. This gives the scheduler more flexibility in propagating updates to the cached copies.
Reference: [2] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resources," </title> <booktitle> in Proc. IEEE Int'l Conf. on Software Engineering, </booktitle> <address> Los Angeles, </address> <year> 1976. </year>
Reference-contexts: In active (state-machine) replication schemes [6, 30], a collection of identical servers maintains copies of the system state. Client write operations are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers can continue the service. Passive (primary-backup) replication <ref> [2, 9] </ref>, on the other hand, distinguishes one replica as the primary server, which handles all client requests. A write operation at the primary invokes the transmission of an update message to the backup servers. <p> For example, Figure 2 (a) shows the basic primary-backup model, where a client write operation at the primary P triggers a synchronous update to the backup B [4]. The service can improve response time by allowing the backup B to acknowledge the client C <ref> [2] </ref>, as shown in Figure 2 (b). Finally, the primary can further reduce write latency by replying to C immediately after sending an update message to B, without waiting for an acknowledgement [8], as shown in Figure 2 (c). Similar performance optimizations apply to the state-machine replication model.
Reference: [3] <author> C. M. Aras, J. F. Kurose, D. S. Reeves, and H. Schulzrinne, </author> <title> "Real-time communication in packet-switched networks," </title> <journal> Proc. of the IEEE, </journal> <volume> vol. 82, no. 1, </volume> <pages> pp. 122-139, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: For example, a real-time channel [14, 23] with the desired bound could be established between the primary and the backups. Several other approaches to providing bounds on communication latency are discussed in <ref> [3] </ref>. If a client operation modifies O i , the primary must send an update for the object within the next ffi i ` time units; otherwise, the backups may not receive a sufficiently recent version of O i before the time-window ffi i elapses.
Reference: [4] <author> J. F. Bartlett, </author> <title> "A NonStop kernel," </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <year> 1981. </year>
Reference-contexts: A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine [7, 11, 26] or primary-backup <ref> [4, 5, 9] </ref> replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary. <p> For example, Figure 2 (a) shows the basic primary-backup model, where a client write operation at the primary P triggers a synchronous update to the backup B <ref> [4] </ref>. The service can improve response time by allowing the backup B to acknowledge the client C [2], as shown in Figure 2 (b).
Reference: [5] <author> A. Bhide, E. N. Elnozahy, and S. P. Morgan, </author> <title> "A highly available network file server," </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 199-205, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine [7, 11, 26] or primary-backup <ref> [4, 5, 9] </ref> replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [6] <author> K. P. Birman and T. A. Joseph, </author> <title> "Reliable communication in the presence of failures," </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 47-76, </pages> <year> 1987. </year> <month> 25 </month>
Reference-contexts: Section 7 concludes the paper by highlighting the limitations of this work and discussing future research directions. 2 Related Work 2.1 Replication Models A common approach to building fault-tolerant distributed systems is to replicate servers that fail independently. In active (state-machine) replication schemes <ref> [6, 30] </ref>, a collection of identical servers maintains copies of the system state. Client write operations are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers can continue the service.
Reference: [7] <author> K. P. Birman, </author> <title> "The process group approach to reliable distributed computing," </title> <journal> Com--munications of the ACM, </journal> <volume> vol. 36, no. 12, </volume> <pages> pp. 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine <ref> [7, 11, 26] </ref> or primary-backup [4, 5, 9] replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [8] <author> N. Budhiraja and K. Marzullo, </author> <title> "Tradeoffs in implementing primary-backup protocols," </title> <institution> Department of Computer Science TR-92-1307, Cornell University, </institution> <year> 1992. </year>
Reference-contexts: The service can improve response time by allowing the backup B to acknowledge the client C [2], as shown in Figure 2 (b). Finally, the primary can further reduce write latency by replying to C immediately after sending an update message to B, without waiting for an acknowledgement <ref> [8] </ref>, as shown in Figure 2 (c). Similar performance optimizations apply to the state-machine replication model. Although these techniques significantly improve average performance, they do not guarantee bounded worst-case delay, since they do not limit communication within the service.
Reference: [9] <author> N. Budhiraja and K. Marzullo, </author> <title> "Tradeoffs in implementing primary-backup protocols," </title> <booktitle> in Proc. IEEE Symposium on Parallal and Distributed Processing, </booktitle> <pages> pp. 280-288, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: In active (state-machine) replication schemes [6, 30], a collection of identical servers maintains copies of the system state. Client write operations are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers can continue the service. Passive (primary-backup) replication <ref> [2, 9] </ref>, on the other hand, distinguishes one replica as the primary server, which handles all client requests. A write operation at the primary invokes the transmission of an update message to the backup servers. <p> A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine [7, 11, 26] or primary-backup <ref> [4, 5, 9] </ref> replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [10] <author> F. Cristian, </author> <title> "Understanding fault tolerant distributed systems," </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, no. 2, </volume> <pages> pp. 56-78, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: In the absence of link (performance or 8 crash) failures <ref> [10] </ref>, we assume a bound ` on the end-to-end communication latency within the service. For example, a real-time channel [14, 23] with the desired bound could be established between the primary and the backups. Several other approaches to providing bounds on communication latency are discussed in [3].
Reference: [11] <author> F. Cristian, B. Dancy, and J. Dehn, </author> <title> "Fault-tolerance in the advanced automation system," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine <ref> [7, 11, 26] </ref> or primary-backup [4, 5, 9] replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [12] <author> S. B. Davidson and A. Watters, </author> <title> "Partial computation in real-time database systems," </title> <booktitle> in Proc. Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pp. 117-121, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [12, 17, 18, 20, 28] </ref>. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation [22].
Reference: [13] <author> C.-C. Han and K.-J. Lin, </author> <title> "Scheduling distance-constrained real-time tasks," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 300-308, </pages> <year> 1992. </year>
Reference-contexts: This occurs because, on average, the periodic model schedules updates twice as often as necessary, in order to guarantee the required worst-case spacing between update transmissions. We are exploring other scheduling algorithms, such as the distance-constrained task model <ref> [13] </ref> which assigns task priorities based on separation constraints, in terms of their implementation complexity and ability to accommodate dynamic creation/deletion of objects. We are also considering techniques to maximize the "goodness" of the replicated data.
Reference: [14] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multi-hop networks," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In the absence of link (performance or 8 crash) failures [10], we assume a bound ` on the end-to-end communication latency within the service. For example, a real-time channel <ref> [14, 23] </ref> with the desired bound could be established between the primary and the backups. Several other approaches to providing bounds on communication latency are discussed in [3].
Reference: [15] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger, </author> <title> "Distributed fault-tolerant real-time systems: The MARS approach," </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 25-40, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Synchronization of redundant servers poses additional challenges in real-time environments, where applications operate under strict timing and dependability constraints; server replication for hard real-time systems is under investigation in several recent experimental projects <ref> [15, 16, 33] </ref>. Synchronization overheads, communication delay, and interaction with the external environment complicate the design of replication protocols for real-time applications.
Reference: [16] <author> H. Kopetz and G. Grunsteidl, </author> <title> "TTP a protocol for fault-tolerant real-time systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 27, no. 1, </volume> <pages> pp. 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Synchronization of redundant servers poses additional challenges in real-time environments, where applications operate under strict timing and dependability constraints; server replication for hard real-time systems is under investigation in several recent experimental projects <ref> [15, 16, 33] </ref>. Synchronization overheads, communication delay, and interaction with the external environment complicate the design of replication protocols for real-time applications.
Reference: [17] <author> H. F. Korth, N. Soparkar, and A. Silberschatz, </author> <title> "Triggered real time databases with consistency constraints," </title> <booktitle> in Proc. Int'l Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [12, 17, 18, 20, 28] </ref>. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation [22].
Reference: [18] <author> T.-W. Kuo and A. K. Mok, </author> <title> "Ssp: a semantics-based protocol for real-time data access," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 76-86, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [12, 17, 18, 20, 28] </ref>. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation [22].
Reference: [19] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The rate monotonic scheduling algorithm: Exact characterization and average case behavior," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 166-171. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: The primary constructs a schedule that sends each object to the backup exactly once, and allows the primary to smoothly transition to the update transmission schedule. While several task models can accommodate the requirements of window-consistent scheduling and backup integration, we initially consider the periodic task model <ref> [19, 21] </ref>. 4.1 Periodic Scheduling of Updates The transmissions of updates can be cast as "tasks" that run periodically with deadlines derived from the objects' window-consistency requirements. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [19, 21] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [21]. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedu-lability criterion governs object admission into the replication service.
Reference: [20] <author> K.-J. Lin, F. Jahanian, A. Jhingran, and C. D. Locke, </author> <title> "A model of hard real-time transaction systems," </title> <type> Technical Report RC 17515, </type> <institution> IBM T.J. Watson Reseach Center, </institution> <month> January </month> <year> 1992. </year> <month> 26 </month>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [12, 17, 18, 20, 28] </ref>. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation [22].
Reference: [21] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: The primary constructs a schedule that sends each object to the backup exactly once, and allows the primary to smoothly transition to the update transmission schedule. While several task models can accommodate the requirements of window-consistent scheduling and backup integration, we initially consider the periodic task model <ref> [19, 21] </ref>. 4.1 Periodic Scheduling of Updates The transmissions of updates can be cast as "tasks" that run periodically with deadlines derived from the objects' window-consistency requirements. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [19, 21] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [21]. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedu-lability criterion governs object admission into the replication service. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods [19, 21], while earliest-due-date scheduling favors tasks with earlier deadlines <ref> [21] </ref>. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedu-lability criterion governs object admission into the replication service. <p> The scheduling algorithm maintains window consistency for all objects as long as the the collection of tasks does not exceed a certain bound on resource utilization (e.g., 0:69 for rate-monotonic and 1 for earliest-due-date) <ref> [21] </ref>. 4.2 Compressing the Periodic Schedule While the periodic model can guarantee sufficient updates for each object, the schedule updates O i only once per period p i , even if computation and network resources permit more frequent transmissions.
Reference: [22] <author> J. W. S. Liu, W.-K. Shih, and K.-J. Lin, </author> <title> "Imprecise computations," </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 83-94, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state [12, 17, 18, 20, 28]. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation <ref> [22] </ref>. This is particularly useful in applications that use discrete samples of continuous-time variables, since these values can be approximated when there is not sufficient time to compute an exact value. Weak consistency can also improve performance in non-real-time applications.
Reference: [23] <author> A. Mehra, A. Indiresan, and K. G. Shin, </author> <title> "Structuring communication software for quality-of-service guarantees," </title> <booktitle> in Proc. 17th Real-Time Systems Symposium, </booktitle> <pages> pp. 144-154, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In the absence of link (performance or 8 crash) failures [10], we assume a bound ` on the end-to-end communication latency within the service. For example, a real-time channel <ref> [14, 23] </ref> with the desired bound could be established between the primary and the backups. Several other approaches to providing bounds on communication latency are discussed in [3].
Reference: [24] <author> A. Mehra, J. Rexford, H.-S. Ang, and F. Jahanian, </author> <title> "Design and evaluation of a window-consistent replication service," </title> <booktitle> in Proc. IEEE Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 182-191, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: This paper presents the design and implementation of a data replication service that combines fault-tolerant protocols, real-time scheduling, and temporal consistency semantics to accommodate such system requirements <ref> [24, 29] </ref>. A client application registers a data object with the service by declaring the consistency requirements for the data, in terms of a time window. <p> The primary and backup sites maintain in-memory logs of events at run-time to efficiently collect performance data with minimal intrusion. Estimates of the clock skew between the primary and the backup, derived from actual measurements of round-trip 2 earlier experiments on Sun workstations running Solaris 1.1 show similar results <ref> [24] </ref>. 3 The 100 ms tick period has the same granularity as the process scheduling quantum to limit the interference from other jobs running on the machine.
Reference: [25] <author> C. W. Mercer, S. Savage, and H. Tokuda, </author> <title> "Processor capacity reserves: Operating system support for multimedia applications," </title> <booktitle> in Proc. IEEE International Conference on Multimedia Computing and Systems, </booktitle> <pages> pp. 90-99, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Any client read/write requests and update acknowledgements are processed next, with priority given to client requests. Each server is currently an Intel-based PC running the Real-Time Mach <ref> [25, 32] </ref> operat 18 (a) Average maximum distance (b) Probability (backup inconsistent) i : The graphs show the performance of the service as a function of the client write rate, message loss, and schedule compression. <p> We have recently added support for fault-detection, failover, and integration of new backups. Further experiments on the current platform will ascertain the usefulness of processor capacity reserves <ref> [25] </ref> and other RT-Mach features in implementing the window-consistent replication service. The present work extends into several fruitful areas of research: Object admission/scheduling: We are studying techniques to maximize the number of admitted objects and improve objects' window consistency by optimizing object admission and update scheduling.
Reference: [26] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting, </author> <title> "Consul: A communication substrate for fault-tolerant distributed programs," </title> <type> Technical Report 91-32, </type> <institution> University of Arizona, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: A write operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine <ref> [7, 11, 26] </ref> or primary-backup [4, 5, 9] replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [27] <author> J.-F. Paris, </author> <title> "Using volatile witnesses to extend the applicability of available copy protocols," </title> <booktitle> in Proc. Workshop on the Management of Replicated Data, </booktitle> <pages> pp. 30-33, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: When the system has multiple backups, the replicas can vote to select a single, valid primary. However, when the service has only two sites, communication failures can cause each site to assume the other has failed. In this situation, a third-party "witness" <ref> [27] </ref> can select the primary site. This witness does not act as a primary or backup server, but casts the deciding vote in failure diagnosis.
Reference: [28] <author> C. Pu and A. Leff, </author> <title> "Replica control in distributed systems: An asynchronous approach," </title> <booktitle> in Proc. ACM SIGMOD, </booktitle> <pages> pp. 377-386, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [12, 17, 18, 20, 28] </ref>. Similarly, imprecise computation guarantees timely completion of an application by relaxing the accuracy requirements of the computation [22].
Reference: [29] <author> J. Rexford, A. Mehra, J. Dolter, and F. Jahanian, </author> <title> "Window-consistent replication for real-time applications," </title> <booktitle> in Proc. Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pp. 107-111, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This paper presents the design and implementation of a data replication service that combines fault-tolerant protocols, real-time scheduling, and temporal consistency semantics to accommodate such system requirements <ref> [24, 29] </ref>. A client application registers a data object with the service by declaring the consistency requirements for the data, in terms of a time window.
Reference: [30] <author> F. B. Schneider, </author> <title> "Implementing fault-tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Section 7 concludes the paper by highlighting the limitations of this work and discussing future research directions. 2 Related Work 2.1 Replication Models A common approach to building fault-tolerant distributed systems is to replicate servers that fail independently. In active (state-machine) replication schemes <ref> [6, 30] </ref>, a collection of identical servers maintains copies of the system state. Client write operations are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers can continue the service.
Reference: [31] <author> G. Swaminathan, </author> <title> C++ Socket Classes, </title> <institution> University of Virginia, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Inconsistency increases as the client writes more frequently, since the primary changes it object soon after transmitting an update message to the backup. ing system 2 . The sites communicate over an Ethernet through UDP datagrams using the Socket++ library <ref> [31] </ref>, with extensions to the UNIX select call for priority-based access to the active sockets. At initialization, sockets are registered at the appropriate priority such that the socket for receiving client requests has a higher priority over that for receiving update acknowledgements from the backup.
Reference: [32] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-Time Mach: Toward a predictable real-time system," </title> <booktitle> in Proc. USENIX Mach Workshop, </booktitle> <pages> pp. 73-82, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In Section 6, we present and evaluate an implementation of the window-consistent replication service on a network of Intel-based PCs running RT-Mach <ref> [32] </ref>. Section 7 concludes the paper by highlighting the limitations of this work and discussing future research directions. 2 Related Work 2.1 Replication Models A common approach to building fault-tolerant distributed systems is to replicate servers that fail independently. <p> Any client read/write requests and update acknowledgements are processed next, with priority given to client requests. Each server is currently an Intel-based PC running the Real-Time Mach <ref> [25, 32] </ref> operat 18 (a) Average maximum distance (b) Probability (backup inconsistent) i : The graphs show the performance of the service as a function of the client write rate, message loss, and schedule compression.
Reference: [33] <author> P. Verissimo, P. Barrett, P. Bond, A. Hilborne, L. Rodrigues, and D. Seaton, </author> <title> "The extra performance architecture (XPA)," in Delta-4 A Generic Architecture for Dependable Distributed Computing, </title> <editor> D. Powell, editor, </editor> <year> 1991. </year> <month> 27 </month>
Reference-contexts: Synchronization of redundant servers poses additional challenges in real-time environments, where applications operate under strict timing and dependability constraints; server replication for hard real-time systems is under investigation in several recent experimental projects <ref> [15, 16, 33] </ref>. Synchronization overheads, communication delay, and interaction with the external environment complicate the design of replication protocols for real-time applications.
References-found: 33

