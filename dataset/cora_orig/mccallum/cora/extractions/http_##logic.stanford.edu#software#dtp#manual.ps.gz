URL: http://logic.stanford.edu/software/dtp/manual.ps.gz
Refering-URL: http://logic.stanford.edu/software/dtp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Documentation  
Author: Donald F. Geddis 
Date: March 10, 1995  
Abstract-found: 0
Intro-found: 0
Reference: [BM] <author> Boyer and Moore. NQTHM: </author> <title> The Boyer-Moore theorem prover. </title> <note> Available online as ftp://ftp.cli.com/pub/nqthm/nqthm.tar.Z Email contact: kaufman@cli.com. </note>
Reference-contexts: In that case, a much more efficient algorithm can be used which takes advantage of this metalevel constraint. Some examples of such systems are the aforementioned prolog, as well as otter [McC], the Boyer-Moore theorem prover <ref> [BM] </ref>, rrl [Lab], frapps [Fri], and the suite of algorithms in epikit [GS]. 1.1.1 Approach How is one to deal with this task of solving arbitrary queries from an unknown knowledge base? It is clear that, since inference is NP-hard, not all queries will be answerable in a polynomial amount of
Reference: [Fri] <author> Alan M. Frisch. FRAPPS: </author> <title> Framework for Resolution-based Automated Proof Procedures. </title> <note> Available online as ftp://a.cs.uiuc.edu/pub/frapps/ Email contact: frisch@cs.uiuc.edu. </note>
Reference-contexts: In that case, a much more efficient algorithm can be used which takes advantage of this metalevel constraint. Some examples of such systems are the aforementioned prolog, as well as otter [McC], the Boyer-Moore theorem prover [BM], rrl [Lab], frapps <ref> [Fri] </ref>, and the suite of algorithms in epikit [GS]. 1.1.1 Approach How is one to deal with this task of solving arbitrary queries from an unknown knowledge base? It is clear that, since inference is NP-hard, not all queries will be answerable in a polynomial amount of time.
Reference: [Ged] <author> Donald F. Geddis. dtp: </author> <title> Don's Theorem Prover. </title> <note> Available online as http://meta.stanford.edu/dtp/. </note>
Reference-contexts: : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 29 4 References 34 2 Chapter 1 DTP Overview This manual describes the implemented inference engine called dtp 1 <ref> [Ged] </ref>. The system does refutation proofs of queries from databases in first-order predicate calculus, using a Model Elimination-style algorithm and domain-independent control of reasoning.
Reference: [Ged95] <author> Donald F. Geddis. </author> <title> Caching and First-Order Inference in Model Elimination Theorem Provers. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1995. </year>
Reference-contexts: The system does refutation proofs of queries from databases in first-order predicate calculus, using a Model Elimination-style algorithm and domain-independent control of reasoning. Technical discussion about the ideas behind some of the algorithms (particularily the caching strategies) can be found in my thesis <ref> [Ged95] </ref>. 1.1 Introduction Is dtp for you? The intended audience is those who need a reliable black box inference engine. dtp knows more about inference than most other theorem provers. An ideal application, for example, would be as the back end to a machine learning program or mobile robot. <p> Thus standard approaches such as DFID are required in cases where such infinite spaces are likely. An example using the animal theory follows. The sample run also takes advantage of postponement caching, as described in <ref> [Ged95] </ref>. <p> Describing them all is beyond the scope of this section; please see my thesis <ref> [Ged95] </ref> for more details. 1.5.1 Conjunction Forking Ideally, the caching mechanism would be independent of the heuristic question of what part of the space to search next. We would like to be able to explore relevant subgoals in any order that seems to be most useful.
Reference: [GF92] <author> Michael R. Genesereth and Richard E. Fikes. </author> <title> Knowledge interchange format: Version 3.0 reference manual. Logic Group Report Logic-92-1, </title> <institution> Stanford University, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Ginsberg's [Gin93b]) contain at least an overview of the topic. More details of the standard approach can be found in a specialized text such as [GN87]. The logical syntax used by dtp is generally compatible with kif, the Knowledge Interchange Format defined in <ref> [GF92] </ref>. Variables are lisp atoms beginning with the "?" character. Sentences are lisp s-expressions in prefix form, with the following operator constants predefined: not, and, or, =&gt;, &lt;=, and &lt;=&gt;. Many function constants are predefined to correspond to various arithmetic functions in lisp, as described in the section 1.4.7.
Reference: [Gin] <author> Matthew L. Ginsberg. </author> <title> mvl: A multi-valued logic theorem prover. </title> <note> Available online as ftp://t.uoregon.edu/mvl/. </note>
Reference-contexts: Term reasoning may be added by defining the function term-inference in the dtp package. 2 Disjunctive answers are maintained through the use of answer literals. The unification code was taken from Matt Ginsberg's mvl prover <ref> [Gin] </ref>. 1.2 Syntax Most of this manual assumes that the reader is familiar with the basic concepts of automated inference, such as resolution, unification, and database indexing. If not, many introductory AI texts (e.g. Ginsberg's [Gin93b]) contain at least an overview of the topic. <p> Is there a formal basis for such a protocol? In what way is it different from doing breadth-first search, which seems to sacrifice focus? 1.7 Acknowledgements The unification source code came from Ginsberg's mvl inference system <ref> [Gin] </ref>. Chapter 2 DTP User Manual This appendix describes version 2.7 of dtp. <p> Related files: misc-inference terms subgoals conjunctions conjunct caching residue ordering prover. below.lisp Graphical Explanations Child expansions for existing proof spaces. Related files: view dotify textify. binding-dag.lisp Unification Binding lists. This is a slightly modified version of the file from mvl <ref> [Gin] </ref>. Related files: symbols bindings match cnf. bindings.lisp Unification Binding lists. This is a slightly modified version of the file from mvl [Gin]. Related files: symbols binding-dag match cnf. caching.lisp Inference Subgoal caching and recursion control. Related files: misc-inference terms subgoals conjunctions conjunct backtrack residue ordering prover. CHAPTER 3. <p> Related files: view dotify textify. binding-dag.lisp Unification Binding lists. This is a slightly modified version of the file from mvl <ref> [Gin] </ref>. Related files: symbols bindings match cnf. bindings.lisp Unification Binding lists. This is a slightly modified version of the file from mvl [Gin]. Related files: symbols binding-dag match cnf. caching.lisp Inference Subgoal caching and recursion control. Related files: misc-inference terms subgoals conjunctions conjunct backtrack residue ordering prover. CHAPTER 3. <p> Related files: types variables structures. clauses.lisp Knowledge Base Clauses (skolemized logical sentences in conjunctive-normal form). Related files: literals labels answers database. cnf.lisp Unification Database, clausal form. This is a slightly modified version of the file from mvl <ref> [Gin] </ref>. Related files: symbols bindings binding-dag match. conjunct.lisp Inference Computations for conjunct nodes in the proof space. Related files: misc-inference terms subgoals conjunctions backtrack caching residue ordering prover. conjunctions.lisp Inference Computations for conjunction nodes in the proof space. <p> Related files: literals clauses answers database. literals.lisp Knowledge Base Logical literals (positive and negative, ground and with variables). Related files: clauses labels answers database. match.lisp Unification Logic variables. This is a slightly modified version of the file from mvl <ref> [Gin] </ref>. Related files: symbols bindings binding-dag cnf. misc-inference.lisp Inference Generic functions for inference. Related files: terms subgoals conjunctions conjunct backtrack caching residue ordering prover. ordering.lisp Inference Search control (priority queue for the agenda of subgoals). <p> Related files: types variables classes. subgoals.lisp Inference Computations for subgoal nodes in the proof space. Related files: misc-inference terms conjunctions conjunct backtrack caching residue ordering prover. symbols.lisp Unification Logic variables. This is a slightly modified version of the file from mvl <ref> [Gin] </ref>. Related files: bindings binding-dag match cnf. terms.lisp Inference Procedural attachment for terms, and (hooks for) term inference/rewriting. Related files: misc-inference subgoals conjunctions conjunct backtrack caching residue ordering prover. CHAPTER 3. DTP REFERENCE MANUAL 33 test.lisp Miscellaneous Runs lisp examples in order to test the entire dtp system.
Reference: [Gin93a] <author> Matthew L. Ginsberg. </author> <title> Dynamic backtracking. </title> <journal> Journal of Artificial Intelligence Research (JAIR), </journal> <volume> 1 </volume> <pages> 25-46, </pages> <year> 1993. </year> <note> Available online as ftp://t.uoregon.edu/papers/dynamic.dvi JAIR is published in comp.ai.jair.papers. </note>
Reference-contexts: The proof space is shown in figure 1.2. 5 Other candidate algorithms include GSAT, Min-conflicts, Dependency-directed backtracking, and Dynamic backtracking <ref> [Gin93a] </ref>. 6 The example presented only requires database lookup to solve. Note that this is only for clarity of explanation, as dtp does backjumping for full inference problems. CHAPTER 1. <p> an arbitrary amount of work involved in finding all the solutions to B (?y), even though we can easily see that none of them will prevent a continuing failure for the subgoal D (1). 7 The attempt to avoid re-doing such work is the inspiration behind the dynamic backtracking algorithm <ref> [Gin93a] </ref>. 8 I am indebted to Michael Genesereth for this example. CHAPTER 1. DTP OVERVIEW 11 P (?x,?y) ( A (?x) and B (?y) A (1) B (10) C (10) D (2) Table 1.2: Backjumping across conjunctions CHAPTER 1.
Reference: [Gin93b] <author> Matthew L. Ginsberg. </author> <booktitle> Essentials of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1993. </year>
Reference-contexts: The unification code was taken from Matt Ginsberg's mvl prover [Gin]. 1.2 Syntax Most of this manual assumes that the reader is familiar with the basic concepts of automated inference, such as resolution, unification, and database indexing. If not, many introductory AI texts (e.g. Ginsberg's <ref> [Gin93b] </ref>) contain at least an overview of the topic. More details of the standard approach can be found in a specialized text such as [GN87]. The logical syntax used by dtp is generally compatible with kif, the Knowledge Interchange Format defined in [GF92].
Reference: [GN87] <author> Michael R. Genesereth and Nils J. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: If not, many introductory AI texts (e.g. Ginsberg's [Gin93b]) contain at least an overview of the topic. More details of the standard approach can be found in a specialized text such as <ref> [GN87] </ref>. The logical syntax used by dtp is generally compatible with kif, the Knowledge Interchange Format defined in [GF92]. Variables are lisp atoms beginning with the "?" character. Sentences are lisp s-expressions in prefix form, with the following operator constants predefined: not, and, or, =&gt;, &lt;=, and &lt;=&gt;.
Reference: [GS] <author> Michael R. Genesereth and Narinder P. Singh. epikit. </author> <note> Available from Epistemics, </note> <institution> Inc. Contact the authors at genesereth@cs.stanford.edu or singh@cs.stanford.edu. </institution>
Reference-contexts: In that case, a much more efficient algorithm can be used which takes advantage of this metalevel constraint. Some examples of such systems are the aforementioned prolog, as well as otter [McC], the Boyer-Moore theorem prover [BM], rrl [Lab], frapps [Fri], and the suite of algorithms in epikit <ref> [GS] </ref>. 1.1.1 Approach How is one to deal with this task of solving arbitrary queries from an unknown knowledge base? It is clear that, since inference is NP-hard, not all queries will be answerable in a polynomial amount of time. <p> User functions: dtp-load. Related files: hierarchy output test epikit-dtp. hierarchy.lisp Miscellaneous Directed acyclic inclusion graph for the theories of logical sentences. Related functions: all-theories includes unincludes includees decludes included-active-theory-names show-theory-dag. Related files: output file test epikit-dtp. 1 The other theorem prover in this case is epikit, from Epistemics <ref> [GS] </ref>. CHAPTER 3. DTP REFERENCE MANUAL 32 internals.lisp Extensions Simple, generic dtp extensions to Common Lisp. Related functions: reset-dtp. Related files: defsystem. labels.lisp Knowledge Base Local labels for logical sentences. Related files: literals clauses answers database. literals.lisp Knowledge Base Logical literals (positive and negative, ground and with variables).
Reference: [Kor85] <author> Richard E. Korf. </author> <title> Depth-first iterative deepening: An optimal admissible tree search. </title> <journal> Artificial Intelligence, </journal> <volume> 27(1) </volume> <pages> 97-109, </pages> <year> 1985. </year> <note> 34 CHAPTER 4. REFERENCES 35 </note>
Reference-contexts: The reduction of this with the initial query (with binding ?j!a) yields the answer (p a a). 1.4 Enhancements 1.4.1 Iteration dtp allows the inference space to be searched with depth-first iterative deepening (DFID) <ref> [Kor85] </ref> rather than simple depth-first search. This iteration may apply to either the depth of a subgoal, in terms of the length of the path from the root to the subgoal, or the depth of function nesting of terms in a subgoal. This latter search is particularly important in dtp.
Reference: [Kor92] <author> Richard E. Korf. </author> <title> Linear-space best-first search: Summary of results. </title> <booktitle> In Proceedings of the Tenth National Conference on Artificial Intelligence (AAAI-92), </booktitle> <pages> pages 533-538, </pages> <address> Menlo Park, California, 1992. </address> <publisher> AAAI Press. </publisher>
Reference-contexts: The most blatant example is that the entire proof space that has been explored so far remains resident. As Richard Korf writes <ref> [Kor92] </ref>: Since best-first search stores all generated nodes in the Open or Closed lists, its space complexity is the same as its time complexity, which is typically exponential. <p> When available memory is filled, selective forgetting can free up needed space, by throwing away the least useful part of the space. In order to maintain completeness, some form of summarization is needed. As an example in straight search, Korf's recursive best-first search algorithm <ref> [Kor92] </ref> maintains this selective forgetting with appropriate summaries. I imagine something similar could work here, although it would require more theoretical effort to work out the details. At the moment dtp will just fill the available memory and then fail.
Reference: [Lab] <institution> Rewrite Rule Laboratory. RRL: Rewrite Rule Laboratory. </institution> <note> Available online as ftp://herky.cs.uiowa.edu/public/rrl. </note>
Reference-contexts: In that case, a much more efficient algorithm can be used which takes advantage of this metalevel constraint. Some examples of such systems are the aforementioned prolog, as well as otter [McC], the Boyer-Moore theorem prover [BM], rrl <ref> [Lab] </ref>, frapps [Fri], and the suite of algorithms in epikit [GS]. 1.1.1 Approach How is one to deal with this task of solving arbitrary queries from an unknown knowledge base? It is clear that, since inference is NP-hard, not all queries will be answerable in a polynomial amount of time.
Reference: [McC] <author> William W. McCune. </author> <title> otter: Organized Techniques for Theorem-proving and Effective Research. </title> <note> Available by anonymous ftp from Argonne National Laboratory. Contact mccune@mcs.anl.gov or 708/972-3065. </note>
Reference-contexts: In that case, a much more efficient algorithm can be used which takes advantage of this metalevel constraint. Some examples of such systems are the aforementioned prolog, as well as otter <ref> [McC] </ref>, the Boyer-Moore theorem prover [BM], rrl [Lab], frapps [Fri], and the suite of algorithms in epikit [GS]. 1.1.1 Approach How is one to deal with this task of solving arbitrary queries from an unknown knowledge base? It is clear that, since inference is NP-hard, not all queries will be answerable
References-found: 14

