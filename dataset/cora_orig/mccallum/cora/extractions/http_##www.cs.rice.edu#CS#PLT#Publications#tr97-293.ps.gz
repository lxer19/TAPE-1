URL: http://www.cs.rice.edu/CS/PLT/Publications/tr97-293.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: A Programmer's Reduction Semantics for Classes and Mixins an intuitive model of an essential Java
Author: Matthew Flatt, Shriram Krishnamurthi, Matthias Felleisen 
Note: 1.  these languages.  
Affiliation: Rice University  
Abstract: While class-based object-oriented programming languages provide a flexible mechanism for re-using and managing related pieces of code, they typically lack linguistic facilities for specifying a uniform extension of many classes with one set of fields and methods. As a result, programmers are unable to express certain abstractions over classes. In this paper we develop a model of class-to-class functions that we refer to as mixins. A mixin function maps a class to an extended class by adding or overriding fields and methods. Programming with mixins is similar to programming with single inheritance classes, but mixins more directly encourage programming to interfaces. The paper develops these ideas within the context of Java. The results are 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abadi, M., and Cardelli, L. </author> <title> A theory of primitive objects | untyped and first-order systems. </title> <booktitle> In Theoretical Aspects of Computer Software, </booktitle> <editor> M. Hagiya and J. C. Mitchell, Eds., </editor> <volume> vol. </volume> <publisher> 789 of LNCS. Springer-Verlag, </publisher> <month> Apr. </month> <year> 1994, </year> <pages> pp. 296-320. </pages>
Reference-contexts: (P ) InterfacesOnce (P ) MethodOncePerClass (P ) FieldOncePerClass (P ) CompleteClasses (P ) WellFoundedClasses (P ) CompleteInterfaces (P ) WellFoundedInterfaces (P ) ClassFieldsOK (P ) ClassMethodsOK (P ) InterfaceMethodsOK (P ) InterfacesAbstract (P ) ClassesImplementAll (P ) P ` d defn j ) defn 0 j for j 2 <ref> [1; n] </ref> P; [ ] ` e e ) e 0 : t where P = defn 1 : : : defn n e ` p defn 1 : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog c ] <p> t where P = defn 1 : : : defn n e ` p defn 1 : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog c ] ` d P ` t t j for each j 2 <ref> [1; n] </ref> P; c ` m meth k ) meth 0 k for each k 2 [1; p] P ` d class c f t 1 fd 1 : : : t n fd n meth 1 : : : meth p g ) class c f t 1 fd 1 <p> : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog c ] ` d P ` t t j for each j 2 [1; n] P; c ` m meth k ) meth 0 k for each k 2 <ref> [1; p] </ref> P ` d class c f t 1 fd 1 : : : t n fd n meth 1 : : : meth p g ) class c f t 1 fd 1 : : : t n fd n meth 0 1 : : : meth 0 p <p> meth 1 : : : meth p g ) class c f t 1 fd 1 : : : t n fd n meth 0 1 : : : meth 0 p g [defn c ] P; i ` m meth j ) meth 0 j for each j 2 <ref> [1; p] </ref> P ` d interface i f meth 1 : : : meth p g ) interface i f meth 0 1 : : : meth 0 p g [defn i ] ` m P ` t t P ` t t j for j 2 [1; n] P ,[this <p> each j 2 [1; p] P ` d interface i f meth 1 : : : meth p g ) interface i f meth 0 1 : : : meth 0 p g [defn i ] ` m P ` t t P ` t t j for j 2 <ref> [1; n] </ref> P ,[this : t o , var 1 : t 1 , : : : var n : t n ] ` s e ) e 0 : t P; t o ` m t md (t 1 var 1 : : : t n var n ) f <p> super method invocations, the annotation contains the compile-time P; ` e e ) e 0 : t 0 hmd, (t 1 : : : t n ! t), (var 1 : : : var n ), e b i 2 P t 0 j : t j for j 2 <ref> [1; n] </ref> 1 : : : e 0 [call c ] P; ` e this ) this : c 0 c 0 c P c hmd, (t 1 : : : t n ! t), (var 1 : : : var n ), e b i 2 P c P; ` <p> this ) this : c 0 c 0 c P c hmd, (t 1 : : : t n ! t), (var 1 : : : var n ), e b i 2 P c P; ` s e j ) e 0 j : t j for j 2 <ref> [1; n] </ref> e b 6= abstract P; ` e super.md (e 1 : : : e n ) ) super this : c .md (e 0 1 : : : e 0 [super c ] P; ` s e ) e 0 : t P; ` e view t e ) <p> Case [call ]. From P , ` e object .md (v 1 , . . . v n ) : t we know P , ` e object : t 0 , P , ` s v i : t i for i in <ref> [1; n] </ref>, and hmd; (t 1 : : : t n ! t); (var 1 ; :::; var n ); ei 2 c t 0 . <p> (P ) MethodOncePerMixin (P ) InterfacesOnce (P ) CompleteMixins (P ) WellFoundedMixins (P ) CompleteInterfaces (P ) WellFoundedInterfaces (P ) MixinFieldsOK (P ) MixinMethodsOK (P ) InterfaceMethodsOK (P ) InterfacesAbstract (P ) NoAbstractMixins (P ) MixinsImplementAll (P ) P ` d defn j ) defn 0 j for j 2 <ref> [1; n] </ref> P; [ ] ` e e ) e 0 : t where P = defn 1 : : : defn n e ` p defn 1 : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog m ] <p> t where P = defn 1 : : : defn n e ` p defn 1 : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog m ] ` d P ` t t j for each j 2 <ref> [1; n] </ref> P; m ` m meth k ) meth 0 k for each k 2 [1; p] P ` d mixin m f t 1 fd 1 : : : t n fd n meth 1 : : : meth p g ) mixin m f t 1 fd 1 <p> : : : defn n e ) defn 0 1 : : : defn 0 n e 0 : t [prog m ] ` d P ` t t j for each j 2 [1; n] P; m ` m meth k ) meth 0 k for each k 2 <ref> [1; p] </ref> P ` d mixin m f t 1 fd 1 : : : t n fd n meth 1 : : : meth p g ) mixin m f t 1 fd 1 : : : t n fd n meth 0 1 : : : meth 0 p <p> m ] v : t v : t P; ` e e ) e 0 : t 0 hmd, (t 1 : : : t n ! t), (var 1 : : : var n ), e b i 2 P t 0 j : t j for j 2 <ref> [1; n] </ref> 1 : : : e 0 [call m ] P; ` e this ) this : m m j m P i hmd, (t 1 : : : t n ! t), (var 1 : : : var n ), abstracti 2 P i P; ` s e j
Reference: 2. <author> Abadi, M., and Cardelli, L. </author> <title> A theory of primitive objects: second-order systems. </title> <booktitle> In Proc. European Symposium on Programming (New York, </booktitle> <address> N.Y., </address> <year> 1994), </year> <editor> D. Sannella, Ed., </editor> <booktitle> Lecture Notes in Computer Science 788, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 1-25. </pages>
Reference: 3. <author> Abadi, M., and Cardelli, L. </author> <title> An imperative object calculus. In TAP-SOFT'95: Theory and Practice of Software Development (May 1995), </title> <editor> P. D. Mosses, M. Nielsen, and M. I. Schwartzbach, Eds., </editor> <booktitle> Lecture Notes in Computer Science 915, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 471-485. </pages>
Reference: 4. <author> Ancona, D., and Zucca, E. </author> <title> An algebraic approach to mixins and modularity. </title> <booktitle> In Proc. Conference on Algebraic and Logic Programming (Berlin, </booktitle> <year> 1996), </year> <editor> M. Hanus and M. Rodrguez-Artalejo, Eds., </editor> <booktitle> Lecture Notes in Computer Science 1139, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 179-193. </pages>
Reference-contexts: Bracha has investigated the use of "mixin modules" as a general language for expressing inheritance and overriding in objects [5-7]. His system is based on earlier work by Cook [8]; its underlying semantics was recently reformulated in categorical terms by Ancona and Zucca <ref> [4] </ref>. Bracha's system gives the programmer a mechanism for defining modules (classes, in our sense) as a collection of attributes (methods). Modules can be combined into new modules through various merging operators.
Reference: 5. <author> Bracha, G. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, University of Utah, </institution> <month> Mar. </month> <year> 1992. </year>
Reference: 6. <author> Bracha, G., and Cook, W. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990). </year>
Reference-contexts: A programmer who also follows a particular protocol for such extensions can mimic the use of class-to-class functions. Common Lisp programmers refer to this protocol as mixin programming [20, 21], because it roughly corresponds to mixing in additional ingredients during class creation. Bracha and Cook <ref> [6] </ref> designed a language of class manipulators that promote mixin thinking in this style and permit programmers to build mixin-like classes.
Reference: 7. <author> Bracha, G., and Lindstrom, G. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. IEEE Computer Society International Conference on Computer Languages (Washington, </booktitle> <address> DC, </address> <month> Apr. </month> <year> 1992), </year> <journal> IEEE Computer Society, </journal> <pages> pp. 282-290. </pages>
Reference: 8. <author> Cook, W. R. </author> <title> A Denotational Semantics of Inheritance. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Brown University, Providence, RI, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Bracha has investigated the use of "mixin modules" as a general language for expressing inheritance and overriding in objects [5-7]. His system is based on earlier work by Cook <ref> [8] </ref>; its underlying semantics was recently reformulated in categorical terms by Ancona and Zucca [4]. Bracha's system gives the programmer a mechanism for defining modules (classes, in our sense) as a collection of attributes (methods). Modules can be combined into new modules through various merging operators.
Reference: 9. <author> Drossopolou, S., and Eisenbach, S. </author> <title> Java is typesafe probably. </title> <booktitle> In Proc. European Conference on Object Oriented Programming (June 1997). </booktitle>
Reference-contexts: The store is unchanged and the only addition to the environment is not an object , so the store relation holds. 2 2.5 Related Work on Classes Our model for class-based object-oriented languages is similar to two recently published semantics for Java <ref> [9, 28] </ref>, but entirely motivated by prior work on Scheme and ML models [13, 18, 29]. The approach is fundamentally different from most of the previous work on the semantics of objects.
Reference: 10. <author> Ducournau, R., Habib, M., Huchard, M., and Mugnier, M. L. </author> <title> Monotonic conflict resolution mechanisms for inheritance. </title> <booktitle> In Proc. Conference on Object-Oriented Programming Systems, Languages, and Applications (Oct. </booktitle> <year> 1992), </year> <pages> pp. 16-24. </pages>
Reference-contexts: Unfortunately, the original linearization algorithm for CLOS's multiple inheritance breaks the encapsulation of class definitions <ref> [10] </ref>, which makes it difficult to use CLOS for proper mixin programming. The CommonObjects [27] dialect of CLOS supports multiple inheritance without breaking encapsulation, but the language does not provide simple composition operators for mixins.
Reference: 11. <author> Eifrig, J., Smith, S., Trifonov, V., and Zwarico, A. </author> <title> Application of OOP type theory: State, decidability, integration. </title> <booktitle> In Proc. Conference on Object-Oriented Programming Systems, Languages, and Applications (Oct. </booktitle> <year> 1994), </year> <pages> pp. 16-30. </pages>
Reference-contexts: The approach is fundamentally different from most of the previous work on the semantics of objects. Much of that work has focused on interpreting object systems and the underlying mechanisms via record extensions of lambda calculi <ref> [11, 19, 24, 22, 25] </ref> or as "native" object calculi (with a record flavor) [1-3]. In our semantics, types are simply the names of entities declared in the program; the collection of types forms a dag, which is specified by the programmer.
Reference: 12. <author> Felleisen, M. </author> <title> Programming languages and lambda calculi. </title> <address> URL: www.cs.rice.edu/~matthias/411web/mono.ps. </address>
Reference-contexts: Similarly, the reduction semantics only assumes that an expression can be partitioned into a proper redex and an (evaluation) context; it does not provide a partitioning algorithm. The model can easily be refined to expose more implementation details <ref> [12, 18] </ref>. 2.1 ClassicJava Programs The syntax for ClassicJava is shown in Figure 3. A program P is a sequence of class and interface definitions followed by an expression.
Reference: 13. <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Tech. Rep. 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <journal> Theoretical Computer Science, </journal> <volume> volume 102, </volume> <year> 1992. </year>
Reference-contexts: Given a type graph, reductions map a store-expression pair to a new pair 2 A Model of Classes ClassicJava is a small but essential subset of sequential Java. To model its type structure and semantics, we use well-known type elaboration and rewriting techniques for Scheme and ML <ref> [13, 18, 29] </ref>. Figures 1 and 2 illustrate our strategy. Type elaboration verifies that a program defines a static tree of classes and a directed acyclic graph (dag) of interfaces. A type is simply a node in the combined graph. <p> A store S is a mapping from objects to class-tagged field records. A field record F is a mapping from elaborated field names to values. The evaluation rules are a straightforward modification of those for imperative Scheme <ref> [13] </ref>. The complete evaluation rules are in Figure 8. <p> the only addition to the environment is not an object , so the store relation holds. 2 2.5 Related Work on Classes Our model for class-based object-oriented languages is similar to two recently published semantics for Java [9, 28], but entirely motivated by prior work on Scheme and ML models <ref> [13, 18, 29] </ref>. The approach is fundamentally different from most of the previous work on the semantics of objects.
Reference: 14. <author> Findler, R. B., Flanagan, C., Flatt, M., Krishnamurthi, S., and Felleisen, M. DrScheme: </author> <title> A pedagogic programming environment for Scheme. </title> <booktitle> In Proc. International Symposium on Programming Languages, Implementations, Logics, and Programs (1997), </booktitle> <pages> pp. 369-388. </pages>
Reference-contexts: In MzScheme, classes form a single inheritance hierarchy, but are also first-class values that can be created and extended at run-time. Once this capability was available, the programmers of our team used it extensively for the construction of DrScheme <ref> [14] </ref>, a Scheme programming environment. However, a thorough analysis reveals that the code only contains first-order functions on classes. In this paper, we present a typed model of such "class functors" for Java [17].
Reference: 15. <author> Flatt, M. PLT MzScheme: </author> <title> Language manual. </title> <type> Tech. Rep. </type> <institution> TR97-280, Rice University, </institution> <year> 1997. </year>
Reference-contexts: Unfortunately, multiple inheritance and its cousins are semantically complex and difficult to understand for programmers. 2 As a result, implementing a mixin protocol with these approaches is error-prone and typically avoided. For the design of MzScheme's class and interface system <ref> [15] </ref>, we experimented with a different approach. In MzScheme, classes form a single inheritance hierarchy, but are also first-class values that can be created and extended at run-time.
Reference: 16. <author> Gamma, E., Helm, R., Johnson, R., and Vlissides, J. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Still, the context remains the same for most of the evaluation. 3 From Classes to Mixins: An Example Implementing a maze adventure game <ref> [16, page 81] </ref> illustrates the need for adding mixins to a class-based language. A player in the adventure game wanders through rooms and doors in a virtual world. <p> A programmer implements mixins in exactly the same way as a derived class, except that the programmer cannot rely on the implementation of the mixin's superclass, only on its interface. We consider this an advantage of mixins because it enforces the maxim "program to an interface, not an implementation" <ref> [16, page 11] </ref>. The right side of Figure 9 shows how to define mixins for locked and short doors. The mixin Locked m is nearly identical to the original LockedDoor c class definition, except that the superclass is specified via the interface Door i .
Reference: 17. <author> Gosling, J., Joy, B., and Steele, G. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, a thorough analysis reveals that the code only contains first-order functions on classes. In this paper, we present a typed model of such "class functors" for Java <ref> [17] </ref>. We refer to the functors as mixins due to their similarity to Common Lisp's multiple inheritance mechanism and Bracha's class operators. Our proposal is superior in that it isolates the useful aspects of multiple inheritance yet retains the simple, intuitive nature of class-oriented Java programming.
Reference: 18. <author> Harper, R., and Stone, C. </author> <title> A type-theoretic semantics for Standard ML 1996. </title> <note> Submitted for publication, </note> <year> 1997. </year>
Reference-contexts: Given a type graph, reductions map a store-expression pair to a new pair 2 A Model of Classes ClassicJava is a small but essential subset of sequential Java. To model its type structure and semantics, we use well-known type elaboration and rewriting techniques for Scheme and ML <ref> [13, 18, 29] </ref>. Figures 1 and 2 illustrate our strategy. Type elaboration verifies that a program defines a static tree of classes and a directed acyclic graph (dag) of interfaces. A type is simply a node in the combined graph. <p> Similarly, the reduction semantics only assumes that an expression can be partitioned into a proper redex and an (evaluation) context; it does not provide a partitioning algorithm. The model can easily be refined to expose more implementation details <ref> [12, 18] </ref>. 2.1 ClassicJava Programs The syntax for ClassicJava is shown in Figure 3. A program P is a sequence of class and interface definitions followed by an expression. <p> the only addition to the environment is not an object , so the store relation holds. 2 2.5 Related Work on Classes Our model for class-based object-oriented languages is similar to two recently published semantics for Java [9, 28], but entirely motivated by prior work on Scheme and ML models <ref> [13, 18, 29] </ref>. The approach is fundamentally different from most of the previous work on the semantics of objects.
Reference: 19. <author> Kamin, S. </author> <title> Inheritance in smalltalk-80: a denotational definition. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1988). </year>
Reference-contexts: The approach is fundamentally different from most of the previous work on the semantics of objects. Much of that work has focused on interpreting object systems and the underlying mechanisms via record extensions of lambda calculi <ref> [11, 19, 24, 22, 25] </ref> or as "native" object calculi (with a record flavor) [1-3]. In our semantics, types are simply the names of entities declared in the program; the collection of types forms a dag, which is specified by the programmer.
Reference: 20. <author> Kessler, R. R. </author> <title> LISP, Objects, and Symbolic Programming. Scott, </title> <publisher> Foresman and Company, </publisher> <address> Glenview, IL, USA, </address> <year> 1988. </year>
Reference-contexts: A programmer who also follows a particular protocol for such extensions can mimic the use of class-to-class functions. Common Lisp programmers refer to this protocol as mixin programming <ref> [20, 21] </ref>, because it roughly corresponds to mixing in additional ingredients during class creation. Bracha and Cook [6] designed a language of class manipulators that promote mixin thinking in this style and permit programmers to build mixin-like classes. <p> In a language that provides both classes and mixins, portions of the program that do not use mixins do not incur any extra overhead. 4.6 Related Work on Mixins Mixins first appeared as a CLOS programming pattern <ref> [20, 21] </ref>. Unfortunately, the original linearization algorithm for CLOS's multiple inheritance breaks the encapsulation of class definitions [10], which makes it difficult to use CLOS for proper mixin programming.
Reference: 21. <author> Koschmann, T. </author> <title> The Common LISP Companion. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: A programmer who also follows a particular protocol for such extensions can mimic the use of class-to-class functions. Common Lisp programmers refer to this protocol as mixin programming <ref> [20, 21] </ref>, because it roughly corresponds to mixing in additional ingredients during class creation. Bracha and Cook [6] designed a language of class manipulators that promote mixin thinking in this style and permit programmers to build mixin-like classes. <p> In a language that provides both classes and mixins, portions of the program that do not use mixins do not incur any extra overhead. 4.6 Related Work on Mixins Mixins first appeared as a CLOS programming pattern <ref> [20, 21] </ref>. Unfortunately, the original linearization algorithm for CLOS's multiple inheritance breaks the encapsulation of class definitions [10], which makes it difficult to use CLOS for proper mixin programming.
Reference: 22. <author> Mason, I. A., and Talcott, C. L. </author> <title> Reasoning about object systems in VTLoE. </title> <booktitle> International Journal of Foundations of Computer Science 6, </booktitle> <address> 3 (Sept. </address> <year> 1995), </year> <pages> 265-298. </pages>
Reference-contexts: The approach is fundamentally different from most of the previous work on the semantics of objects. Much of that work has focused on interpreting object systems and the underlying mechanisms via record extensions of lambda calculi <ref> [11, 19, 24, 22, 25] </ref> or as "native" object calculi (with a record flavor) [1-3]. In our semantics, types are simply the names of entities declared in the program; the collection of types forms a dag, which is specified by the programmer.
Reference: 23. <author> Palsberg, J., and Schwartzbach, M. I. </author> <title> Object-oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference: 24. <author> Reddy, U. S. </author> <title> Objects as closures: Abstract semantics of object oriented languages. </title> <booktitle> In Proc. Conference on Lisp and Functional Programming (July 1988), </booktitle> <pages> pp. 289-297. </pages>
Reference-contexts: The approach is fundamentally different from most of the previous work on the semantics of objects. Much of that work has focused on interpreting object systems and the underlying mechanisms via record extensions of lambda calculi <ref> [11, 19, 24, 22, 25] </ref> or as "native" object calculi (with a record flavor) [1-3]. In our semantics, types are simply the names of entities declared in the program; the collection of types forms a dag, which is specified by the programmer.
Reference: 25. <author> R emy, D. </author> <title> Programming objects with ML-ART: An extension to ML with abstract and record types. </title> <booktitle> In Theoretical Aspects of Computer Software (New York, </booktitle> <address> N.Y., </address> <month> Apr. </month> <year> 1994), </year> <editor> M. Hagiya and J. C. Mitchell, Eds., </editor> <booktitle> Lecture Notes in Computer Science 789, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 321-346. </pages>
Reference-contexts: The approach is fundamentally different from most of the previous work on the semantics of objects. Much of that work has focused on interpreting object systems and the underlying mechanisms via record extensions of lambda calculi <ref> [11, 19, 24, 22, 25] </ref> or as "native" object calculi (with a record flavor) [1-3]. In our semantics, types are simply the names of entities declared in the program; the collection of types forms a dag, which is specified by the programmer.
Reference: 26. <author> Rossie, J. G., Friedman, D. P., and Wand, M. </author> <title> Modeling subobject-based inheritance. </title> <booktitle> In Proc. European Conference on Object-Oriented Programming (Berlin, </booktitle> <address> Heidelberg, and New York, </address> <month> July </month> <year> 1996), </year> <editor> P. Cointe, Ed., </editor> <booktitle> Lecture Notes in Computer Science 1098, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 248-274. </pages>
Reference-contexts: The tail designates a specific point in the full mixin chain for 6 A view is analogous to a "subobject" in languages with multiple inheritance, but without the complexity of shared superclasses <ref> [26] </ref>. e = : : : j hobjectkMi v = hobjectkMi j null E = [ ] j E : m .fd j E : m .fd = e j v : m .fd = E j super v .md (v : : : E e : : :) j view
Reference: 27. <author> Snyder, A. </author> <title> Inheritance and the development of encapsulated software components. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 165-188. </pages>
Reference-contexts: Unfortunately, the original linearization algorithm for CLOS's multiple inheritance breaks the encapsulation of class definitions [10], which makes it difficult to use CLOS for proper mixin programming. The CommonObjects <ref> [27] </ref> dialect of CLOS supports multiple inheritance without breaking encapsulation, but the language does not provide simple composition operators for mixins. Bracha has investigated the use of "mixin modules" as a general language for expressing inheritance and overriding in objects [5-7].
Reference: 28. <author> Syme, D. </author> <title> Proving Java type soundness. </title> <type> Tech. Rep. 427, </type> <institution> University of Cambridge, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The store is unchanged and the only addition to the environment is not an object , so the store relation holds. 2 2.5 Related Work on Classes Our model for class-based object-oriented languages is similar to two recently published semantics for Java <ref> [9, 28] </ref>, but entirely motivated by prior work on Scheme and ML models [13, 18, 29]. The approach is fundamentally different from most of the previous work on the semantics of objects.
Reference: 29. <author> Wright, A., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 160, </type> <institution> Rice University, </institution> <year> 1991. </year> <journal> Information and Computation, </journal> <volume> volume 115, </volume> <year> 1994. </year>
Reference-contexts: Given a type graph, reductions map a store-expression pair to a new pair 2 A Model of Classes ClassicJava is a small but essential subset of sequential Java. To model its type structure and semantics, we use well-known type elaboration and rewriting techniques for Scheme and ML <ref> [13, 18, 29] </ref>. Figures 1 and 2 illustrate our strategy. Type elaboration verifies that a program defines a static tree of classes and a directed acyclic graph (dag) of interfaces. A type is simply a node in the combined graph. <p> The main lemma in support of this theorem states that each step taken in the evaluation preserves the type correctness of the expression-store pair (relative to the program) <ref> [29] </ref>. Specifically, for a configuration on the left-hand side of an evaluation step, there exists a type environment that establishes the expression's type as some t. This environment must be consistent with the store. Definition 2 (Environment-Store Consistency). <p> the only addition to the environment is not an object , so the store relation holds. 2 2.5 Related Work on Classes Our model for class-based object-oriented languages is similar to two recently published semantics for Java [9, 28], but entirely motivated by prior work on Scheme and ML models <ref> [13, 18, 29] </ref>. The approach is fundamentally different from most of the previous work on the semantics of objects.
References-found: 29

