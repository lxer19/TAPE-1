URL: http://www.cs.berkeley.edu/~xjam/rush-tcl94.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~xjam/personal.htm
Root-URL: 
Email: fasah, blojo, xjamg@cs.Berkeley.EDU  
Title: An Introduction to the Rush Language  
Author: Adam Sah Jon Blow, and Brian Dennis 
Date: May 29, 1994  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division Electrical Engineering and Computer Sciences University of California  
Abstract: Rush is a new language that looks and feels much like Tcl [Oust94]; we offer a compiler that executes scripts a hundred times faster than Tcl 7.x, allowing programs to run at speeds close to their C-language counterparts. Rush incorporates many features from Tcl and contains new features. From Tcl, Rush acquires its syntax, everything is a string model, set of core commands and datatypes, scoping rules, C callout facility, and support for popular libraries, including Tk and Tcl-DP. New features in Rush include pass-by-reference, first class closures and production rules. A generalization of operator syntax allows users to code in either command-style or operator- style syntax; a converter program provides a translation between the two forms. We introduce the language as a set of changes to Tcl, with a focus on performance issues and discussion of new features. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Alfred Aho, Ravi Sethi, and Jeffrey Ullman. </author> <title> Compilers: Principles, Techniques and Tools. pp.422-423 introduce the issues in implementing dynamic scope, although their text predates the acceptance of RISC architectures and the new importance on storing local variables in registers, as op-posed to their maintenance in memory lo-cations. </title>
Reference-contexts: A full description of possible compiler optimizations and their in <p>- 2 teraction with language features is well beyond the scope of this paper; at appropriate times, however, we present short summaries of the ways in which features interact with optimization. Those who remain unconvinced should see <ref> [ASU86] </ref> and [ARZ] for rigorous explanations. 2 Language Overview 2.1 Basic Types in Rush The Rush type system behaves like Tcl's, complete with string representations for all datatypes and automatic type conversion as needed by primitives. <p> For a complete discussion of the troubles of dynamic scoping, please see <ref> [ASU86] </ref>. The commands uplevel and upvar are used fairly often in Tcl, so if we wish to remove them, we must provide a mechanism that meets the same needs.
Reference: [ARZ] <author> Fran Allen, Barry Rosen, and Kenneth Zadeck. </author> <title> Optimization in Compilers. This is a highly-detailed point-by-point description of modern optimization techniques. </title> <publisher> ACM press, forthcoming. </publisher>
Reference-contexts: A full description of possible compiler optimizations and their in <p>- 2 teraction with language features is well beyond the scope of this paper; at appropriate times, however, we present short summaries of the ways in which features interact with optimization. Those who remain unconvinced should see [ASU86] and <ref> [ARZ] </ref> for rigorous explanations. 2 Language Overview 2.1 Basic Types in Rush The Rush type system behaves like Tcl's, complete with string representations for all datatypes and automatic type conversion as needed by primitives.
Reference: [WF90] <author> Jennifer Widom and Sheldon Finkelstein. </author> <title> Set-Oriented Production Rules in Relational Database Systems. </title> <booktitle> Proc. ACM SIGMOD. </booktitle> <address> Atlantic City, NJ, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, though Rush variables need not be delimited by dollar signs, we offer dollar-sign notation for backward compatibility and because it is necessary when substituting items into double-quoted strings. 2.5 Rules in Rush 2.5.1 Introduction to Rules A rule is a predicate attached to a list of commands. <ref> [WF90] </ref> Any time during the course of program execution that the predicate becomes true, the list of commands is run. This is unlike an 'if' command, which only tests a predicate at one point in the program. A rule is like an `if' command that is always watching.
Reference: [Oust94] <author> John Ousterhout. </author> <title> An Introdution to Tcl and Tk. </title> <publisher> Addison-Wesley, </publisher> <address> New York, NY, </address> <year> 1994. </year>
Reference: [Bart89] <author> Joel Bartlett. </author> <title> Scheme!C : a portable Scheme-to-C compiler, </title> <type> DEC WRL Technical Report #89/1, </type> <month> Jan, </month> <year> 1989. </year>
Reference-contexts: Our parser translates Rush code into Scheme, which is compiled together with the runtime libraries and any Scheme code provided by the user. The Scheme compiler chosen was Bartlett's Scheme!C system <ref> [Bart89] </ref> and so the output of this compilation is a stream of C code. This C code is then compiled into either an interpreter or standalone program.
Reference: [Brav93] <author> Michael Braverman. Caste: </author> <title> a class system for Tcl, </title> <booktitle> Proc. Tcl'93 Workshop. </booktitle> <month> June, </month> <year> 1993. </year>
Reference-contexts: In these cases, it is clear that Tcl is the preferred language for the job, yet the programmer is forced to code in C. In the most painful case an entire application must be rewritten, as with the Caste object-oriented library <ref> [Brav93] </ref>. Finally, many programmers would like to write entire applications directly in Tcl. For example, Tk- Man, the Unix manual page browser, is written entirely in Tcl.
Reference: [SB93] <author> Adam Sah and Jon Blow. </author> <title> TC: A Compiler for the Tcl Language, </title> <booktitle> Proc. Tcl'93 Workshop. </booktitle> <month> June, </month> <year> 1993. </year>
Reference-contexts: This adds up to a lot of unnecessary conversion, the expense of which often dwarfs the amount of useful computation being performed. This is why Tcl7.x executes loops so slowly. In the Tcl compiler project, TC <ref> [SB93] </ref> [Sah94], we remedied this problem by caching the results of type conversions with variables. Running under TC, the example above would parse x as an integer once and operate only on integers thereafter.
Reference: [Sah94] <author> Adam Sah. </author> <title> An Efficient Implementation of the Tcl Language. </title> <type> Master's Thesis, </type> <institution> Univ. of Cal. at Berkeley tech report #UCB-CSD94-812. </institution> <month> May, </month> <year> 1994. </year>
Reference-contexts: This adds up to a lot of unnecessary conversion, the expense of which often dwarfs the amount of useful computation being performed. This is why Tcl7.x executes loops so slowly. In the Tcl compiler project, TC [SB93] <ref> [Sah94] </ref>, we remedied this problem by caching the results of type conversions with variables. Running under TC, the example above would parse x as an integer once and operate only on integers thereafter.
Reference: [Surv94] <author> Adam Sah, ed. </author> <title> USENET survey of Tcl usage on comp.lang.tcl. </title> <type> Unpublished. </type> <month> April, </month> <year> 1994. </year>
Reference-contexts: For example, the Perspecta Presents! slide-making program consists of ~29,000 lines of C code and only ~13,000 lines of Tcl code. The tendency to write large sections of code in C for performance reasons was verified in the results of a comp.lang.tcl survey <ref> [Surv94] </ref> Rewriting Tcl code in C can be a heavy time sink, and once is done, the incremental development offered by high-level script interpretation is lost forever.
Reference: [Shiv88] <author> Olin Shivers. </author> <title> Control Flow Analysis in Scheme. </title> <journal> ACM Prg Lang Des. and Impl. </journal> <month> June, </month> <year> 1988. </year>
Reference-contexts: That is so, but our current compiler does not take advantage of most of these opportunities! A more heroic Scheme optimizer, perhaps one that massages code in continuation passing style <ref> [Shiv88] </ref> [App92], might bring us close to our theoretical limit. A sophisticated debugging environment would be nice for scripting languages such as Rush and Tcl, which tend to catch fewer errors at compile-time than more rigid languages like Pascal and C.
Reference: [App92] <author> Andrew Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: That is so, but our current compiler does not take advantage of most of these opportunities! A more heroic Scheme optimizer, perhaps one that massages code in continuation passing style [Shiv88] <ref> [App92] </ref>, might bring us close to our theoretical limit. A sophisticated debugging environment would be nice for scripting languages such as Rush and Tcl, which tend to catch fewer errors at compile-time than more rigid languages like Pascal and C.
Reference: [VP89] <author> Steven Vegdahl, Uwe Pleban. </author> <title> The Runtime Environment for Screme, a Scheme Implementation on the 88000. </title> <booktitle> 3rd Int'l Conf. ASPLOS. SIGPLAN Notices 24, </booktitle> <month> April </month> <year> 1989. </year>
Reference-contexts: We believe that the individual weaknesses of these two Scheme interpreters is a result of the portability-for- performance tradeoff that each made in using native C facilities for their implementations. In less portable systems like Screme <ref> [VP89] </ref>, we would expect better performance. pass code/create closure Tcl 45 + .29sec/char interpreted Rush 84.0 sec compiled Rush 3.1 sec 15+ x Tcl 10 uplevel call/execute closure Tcl 74.0 sec interpreted Rush 5.0 sec 13x Tcl compiled Rush .35 sec 211x Tcl 4.5 Rules Our test for rules shows a
Reference: [SHH86] <author> Michael Stonebraker, Eric Hanson, and Chin-Heng Hong. </author> <title> "The Design of the Postgres Rules System." </title> <institution> UC Berkeley tech re-port #UCB/ERL M86/80. </institution>
Reference: [Sto93] <author> Michael Stonebraker. </author> <title> The Integration of Rule Systems and Databases. </title> <institution> UC Berkeley tech report #UCB/ERL M93/25. </institution> <year> 1993. </year>
Reference: [Ros93] <author> Guido van Rossum. </author> <title> "An Introduction to Python for UNIX/C Programmers". </title> <booktitle> Proceedings of the NLUUG najaarsconferentie 1993. </booktitle>
Reference-contexts: Tcl offers some of the poorest performance of interpreted scripting languages, such as Perl [WS91], Python <ref> [Ros93] </ref>, and xlisp. The argument is that Tcl performance doesn't matter. This is true for Tcl procedures that are tied to I/O operations such as network reads and user-interface events.
Reference: [WS91] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming Perl. </title> <publisher> O'Reilly and Associates, </publisher> <year> 1991. </year>
Reference-contexts: Tcl offers some of the poorest performance of interpreted scripting languages, such as Perl <ref> [WS91] </ref>, Python [Ros93], and xlisp. The argument is that Tcl performance doesn't matter. This is true for Tcl procedures that are tied to I/O operations such as network reads and user-interface events.
Reference: [YS93] <author> Curtis Yarvin and Adam Sah. </author> <title> "Binary Optimization for Portable Runtime Code Generation in C." </title> <institution> UC Berkeley Tech Report #UCBCSD-93/792. </institution> <month> December </month> <year> 1993. </year> <month> 12 </month>
Reference-contexts: Also, we are developing methods for viewing and debugging rules, since rules have the potential to interact with each other in mysterious ways. One long-term goal for Rush is to provide a run- time compilation system that generates very efficient code <ref> [YS93] </ref>; such a system would perform many of the operations of traditional optimizing compilers, but for statements entered on the command line.
References-found: 17

