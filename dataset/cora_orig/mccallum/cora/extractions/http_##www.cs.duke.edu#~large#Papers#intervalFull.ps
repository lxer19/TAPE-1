URL: http://www.cs.duke.edu/~large/Papers/intervalFull.ps
Refering-URL: http://www.cs.duke.edu/~large/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Optimal Dynamic Interval Management in External Memory  
Author: Lars Arge Jeffrey Scott Vitter 
Date: August 1996  
Note: Draft of  
Address: Aarhus Durham, NC 27708-0129 Aarhus, Denmark USA  
Affiliation: BRICS Dept. of Computer Science Dept. of Computer Science Duke University University of  
Abstract: We present a space- and I/O-optimal external-memory data structure for answering stabbing queries on a set of dynamically maintained intervals. Our data structure settles an open problem in databases and I/O algorithms by providing the first optimal external-memory solution to the dynamic interval management problem, which is a special case of 2-dimensional range searching and a central problem for object-oriented and temporal databases and for constraint logic programming. Our data structure is simultaneously optimal in space and I/O, and it is the first optimal external data structure for a 2-dimensional range searching problem that has worst-case as opposed to amortized update bounds. Part of the data structure uses a novel balancing technique for efficient worst-case manipulation of balanced trees, which is of independent interest.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal and J. S. Vitter. </author> <title> The Input/Output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1116-1127, </pages> <year> 1988. </year>
Reference-contexts: the major theoretical open problems in the area, and in [23] it is even called "the most elegant open question." In this paper we develop such an optimal structure. 1.1 Memory model and previous results We will be working in the standard model for external memory with one (logical) disk <ref> [24, 1] </ref>. We assume that each external-memory access transmits one page of B units of data, which we count as one I/O. We measure the efficiency of an algorithm in terms of the number of I/O operations it performs.
Reference: [2] <author> L. Arge. </author> <title> The buffer tree: A new technique for optimal I/O-algorithms. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures, </booktitle> <volume> LNCS 955, </volume> <pages> pages 334-345, </pages> <year> 1995. </year> <note> A complete version appears as BRICS technical report RS-96-28, </note> <institution> University of Aarhus. </institution>
Reference-contexts: The starting idea behind our successful externalization of the structure, as compared with previous attempts [9, 35], is that the nodes in our structure have fan-out B instead of B, following ideas from <ref> [2, 3, 4] </ref>. The implications of this smaller fan-out are explained later in this section.
Reference: [3] <author> L. Arge. </author> <title> Efficient External-Memory Data Structures and Applications. </title> <type> PhD thesis, </type> <institution> University of Aarhus, </institution> <month> February/August </month> <year> 1996. </year>
Reference-contexts: The starting idea behind our successful externalization of the structure, as compared with previous attempts [9, 35], is that the nodes in our structure have fan-out B instead of B, following ideas from <ref> [2, 3, 4] </ref>. The implications of this smaller fan-out are explained later in this section.
Reference: [4] <author> L. Arge, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory algorithms for processing line segments in geographic information systems. </title> <booktitle> In Proc. Annual European Symposium on Algorithms, </booktitle> <volume> LNCS 979, </volume> <pages> pages 295-310, </pages> <year> 1995. </year> <note> A complete version (to appear in special issue of Algorithmica) appears as BRICS technical report RS-96-12, </note> <institution> University of Aarhus. </institution>
Reference-contexts: The starting idea behind our successful externalization of the structure, as compared with previous attempts [9, 35], is that the nodes in our structure have fan-out B instead of B, following ideas from <ref> [2, 3, 4] </ref>. The implications of this smaller fan-out are explained later in this section.
Reference: [5] <author> R. Bayer and E. McCreight. </author> <title> Organization and maintenance of large ordered indizes. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: Throughout most of this paper we also make this assumption, but in section 4 we show how to do without it. While B-trees and their variants <ref> [5, 12] </ref> have been an unqualified success in supporting external dynamic 1-dimensional range searching, they are inefficient at handling more general problems like 2-dimensional or higher-dimensional range searching. The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. <p> We also assume that the internal memory is capable of holding O (B) blocks of data. As mentioned, we remove these assumptions in Sections 3 and 4. 2.1 Preliminaries Our external-memory interval tree makes use of two kinds of secondary structures: the B-tree and a "corner structure" [23]. B-trees <ref> [5, 12] </ref> or more generally (a; b)-trees [20] are search tree structures suitable for external memory: Lemma 1 A set of N elements can be stored in a B-tree structure using O (N=B) blocks of external memory such that updates and queries can be performed in O (log B N ) <p> shall see later, the rebalancing operations on the weight-balanced B-tree (splits of nodes instead of rotations) allow us to spread the rebalancing work over a number of updates in an easy way, and thus we can remove the amortization from the update bounds. 3.1 Weight-balanced B-tree In a normal B-tree <ref> [5, 12] </ref> all leaves have the same depth, and each internal node has at least a and at most 2a 1 children, where a is some constant. In weak B-trees or (a; b)-trees [20] a wider range in the number of children is allowed.
Reference: [6] <author> J. L. Bentley. </author> <title> Algorithms for klee's rectangle problems. </title> <institution> Dept. of Computer Science, Carnegie Mellon Univ., </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. Many elegant data structures like the range tree [7], the priority search tree [27], the segment tree <ref> [6] </ref>, and the interval tree [14, 15] have been proposed for use in main memory for 2-dimensional range searching and its special cases (see [11] for a detailed survey). Most of these structures are not efficient when mapped to external memory. <p> It should be mentioned that the p-range tree can be extended to answer general 2-dimensional queries, and that very recently a static structure for 3-dimensional queries has been developed in [43]. The segment tree <ref> [6] </ref> can also be used to solve the stabbing query problem, but even in internal memory it uses more than linear space. Some attempts have been made to externalizing this structure [8, 35] and they all use O ((N=B) log 2 N ) blocks of external memory.
Reference: [7] <author> J. L. Bentley. </author> <title> Multidimensional divide and conquer. </title> <journal> Communications of the ACM, </journal> <volume> 23(6) </volume> <pages> 214-229, </pages> <year> 1980. </year>
Reference-contexts: The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. Many elegant data structures like the range tree <ref> [7] </ref>, the priority search tree [27], the segment tree [6], and the interval tree [14, 15] have been proposed for use in main memory for 2-dimensional range searching and its special cases (see [11] for a detailed survey). Most of these structures are not efficient when mapped to external memory.
Reference: [8] <author> G. Blankenagel and R. Guting. </author> <title> External segment trees. </title> <journal> Algorithmica, </journal> <volume> 12 </volume> <pages> 498-532, </pages> <year> 1994. </year>
Reference-contexts: The segment tree [6] can also be used to solve the stabbing query problem, but even in internal memory it uses more than linear space. Some attempts have been made to externalizing this structure <ref> [8, 35] </ref> and they all use O ((N=B) log 2 N ) blocks of external memory. <p> Finally, in Section 5 we discuss how to use the ideas behind our external interval tree to develop an external version of the segment tree with space bound O ((N=B) log B N ). This improves upon previously known data structures <ref> [8, 35] </ref>, which use O ((N=B) log 2 N ) blocks of external memory. Our structure has worst-case optimal query and update I/O bounds, whereas the other known structures are only query optimal in the static case. <p> from our external interval tree structure and proves Theorem 4. 5 External-memory segment tree The ideas behind our external-memory interval tree can also be used to develop an external-memory segment tree-like structure with optimal update and query I/O bounds and a better space bound than all previous known such structures <ref> [8, 35] </ref>. In this section we sketch this structure.
Reference: [9] <author> G. Blankenagel and R. H. Guting. </author> <title> XP-trees|External priority search trees. </title> <type> Technical report, </type> <institution> FernUniversitat Hagen, </institution> <note> Informatik-Bericht Nr. 92, 1990. 22 </note>
Reference-contexts: The priority search tree [27] for example can be used to answer slightly more general queries than diagonal corner queries, namely 3-sided range queries (Figure 1), in optimal query and update time using optimal space. A number of attempts have been made to externalize this structure, including <ref> [9, 21, 35] </ref>, but they are all non-optimal. The structure in [21] uses optimal space but answers queries in O (log 2 N +T =B) I/Os. The structure in [9] also uses optimal space but answers queries in O (log B N + T ) I/Os. <p> A number of attempts have been made to externalize this structure, including [9, 21, 35], but they are all non-optimal. The structure in [21] uses optimal space but answers queries in O (log 2 N +T =B) I/Os. The structure in <ref> [9] </ref> also uses optimal space but answers queries in O (log B N + T ) I/Os. In both papers a number of non-optimal dynamic versions of the structures are also developed. <p> In [35] a technique called path caching for transforming an 2 3-sided query2-sided querydiagonal corner query general 2-dimensional query Space (blocks) Query I/O bound Update I/O bound Priority search tree [21] O (N=B) O (log 2 N + T =B) XP-tree <ref> [9] </ref> O (N=B) O (log B N + T ) Metablock tree [23] O (N=B) O (log B N + T =B) O (log B N + (log B N ) 2 =B) amortized (inserts only) P-range tree [41] O (N=B) O (log B N + T =B+ O (log B <p> This creates a number of problems when we want to store segments in secondary structures such that queries can be answered efficiently. The starting idea behind our successful externalization of the structure, as compared with previous attempts <ref> [9, 35] </ref>, is that the nodes in our structure have fan-out B instead of B, following ideas from [2, 3, 4]. The implications of this smaller fan-out are explained later in this section.
Reference: [10] <author> N. Blum and K. Mehlhorn. </author> <title> On the average number of rebalancing operations in weight--balanced trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 11 </volume> <pages> 303-320, </pages> <year> 1980. </year>
Reference-contexts: In internal memory a natural choice of dynamic base tree is therefore the BB [ff]-tree [30], because in this structure a node with w items below it (with "weight" w) can only be involved in a rebalancing operation for every (w) updates that access (pass through) the node <ref> [10, 28] </ref>. This leads to an O (1) amortized bound on performing a rebalancing operation. Unfortunately BB [ff]-trees are not suitable for implementation in external memory.
Reference: [11] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <journal> Proceedings of IEEE, Special Issue on Computational Geometry, </journal> <volume> 80(9) </volume> <pages> 362-381, </pages> <year> 1992. </year>
Reference-contexts: Many elegant data structures like the range tree [7], the priority search tree [27], the segment tree [6], and the interval tree [14, 15] have been proposed for use in main memory for 2-dimensional range searching and its special cases (see <ref> [11] </ref> for a detailed survey). Most of these structures are not efficient when mapped to external memory.
Reference: [12] <author> D. Cormer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: Throughout most of this paper we also make this assumption, but in section 4 we show how to do without it. While B-trees and their variants <ref> [5, 12] </ref> have been an unqualified success in supporting external dynamic 1-dimensional range searching, they are inefficient at handling more general problems like 2-dimensional or higher-dimensional range searching. The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. <p> We also assume that the internal memory is capable of holding O (B) blocks of data. As mentioned, we remove these assumptions in Sections 3 and 4. 2.1 Preliminaries Our external-memory interval tree makes use of two kinds of secondary structures: the B-tree and a "corner structure" [23]. B-trees <ref> [5, 12] </ref> or more generally (a; b)-trees [20] are search tree structures suitable for external memory: Lemma 1 A set of N elements can be stored in a B-tree structure using O (N=B) blocks of external memory such that updates and queries can be performed in O (log B N ) <p> shall see later, the rebalancing operations on the weight-balanced B-tree (splits of nodes instead of rotations) allow us to spread the rebalancing work over a number of updates in an easy way, and thus we can remove the amortization from the update bounds. 3.1 Weight-balanced B-tree In a normal B-tree <ref> [5, 12] </ref> all leaves have the same depth, and each internal node has at least a and at most 2a 1 children, where a is some constant. In weak B-trees or (a; b)-trees [20] a wider range in the number of children is allowed.
Reference: [13] <author> R. F. Cromp. </author> <title> An intellegent information fusion system for handling the archiving and querying of terabyte-sized spatial databases. </title> <editor> In S. R. Tate ed., </editor> <title> Report on the Workshop on Data and Image Compression Needs and Uses in the Scientific Community, </title> <type> CESDIS Technical Report Series, </type> <month> TR-93-99, </month> <pages> pages 75-84, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) <ref> [13, 19, 25, 38, 42] </ref>, graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23]. <p> Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck. NASA's EOS project GIS system <ref> [13] </ref> is an example of such an application, as it is expected to manipulate petabytes (thousands of terabytes, or millions of gigabytes) of data! The effect of the I/O bottleneck is getting more pronounced as internal computation gets faster, and especially as parallel computing gains popularity [33].
Reference: [14] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part I. </title> <journal> Int. J. Computer Mathematics, </journal> <volume> 13 </volume> <pages> 209-219, </pages> <year> 1983. </year>
Reference-contexts: The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. Many elegant data structures like the range tree [7], the priority search tree [27], the segment tree [6], and the interval tree <ref> [14, 15] </ref> have been proposed for use in main memory for 2-dimensional range searching and its special cases (see [11] for a detailed survey). Most of these structures are not efficient when mapped to external memory. <p> Also, as mentioned, our structure works without the assumption often made that the internal memory is capable of holding O (B 2 ) items. Our solution to the stabbing query problem is an external-memory version of the interval tree <ref> [14, 15] </ref>. In Section 2 we present the basic structure where the endpoints of the intervals stored in the structure belong to a fixed set of points. In Section 3 we then remove the fixed endpoint-set assumption. <p> section it will also become clearer why the structure is called a "corner structure." 2.2 The structure An internal-memory interval tree consists of a binary tree over the endpoints of the segments stored in the structure, with the segments stored in secondary structure in the internal nodes of this tree <ref> [14] </ref>. We associate an interval X v with every node v consisting of all the endpoints below v.
Reference: [15] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part II. </title> <journal> Int. J. Computer Mathematics, </journal> <volume> 13 </volume> <pages> 221-229, </pages> <year> 1983. </year>
Reference-contexts: The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. Many elegant data structures like the range tree [7], the priority search tree [27], the segment tree [6], and the interval tree <ref> [14, 15] </ref> have been proposed for use in main memory for 2-dimensional range searching and its special cases (see [11] for a detailed survey). Most of these structures are not efficient when mapped to external memory. <p> Also, as mentioned, our structure works without the assumption often made that the internal memory is capable of holding O (B 2 ) items. Our solution to the stabbing query problem is an external-memory version of the interval tree <ref> [14, 15] </ref>. In Section 2 we present the basic structure where the endpoints of the intervals stored in the structure belong to a fixed set of points. In Section 3 we then remove the fixed endpoint-set assumption.
Reference: [16] <author> J. Foley, A. van Dam, S. Feiner, and J. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) [13, 19, 25, 38, 42], graphics <ref> [16] </ref>, indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23]. Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck.
Reference: [17] <author> O. Gunther. </author> <title> The design of the cell tree: An object-oriented index structure for geometric databases. </title> <booktitle> In Proc. of the fifth Int. Conf. on Data Engineering, </booktitle> <pages> pages 598-605, </pages> <year> 1989. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees <ref> [17] </ref>, and various R-trees [18, 40]. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [18] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proc. ACM Conf. on Management of Data, </booktitle> <pages> pages 47-57, </pages> <year> 1985. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees <ref> [18, 40] </ref>. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [19] <author> L. M. Haas and W. F. Cody. </author> <title> Exploiting extensible dbms in integrated geographic information systems. </title> <booktitle> In Proc. of Advances in Spatial Databases, LNCS 525, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) <ref> [13, 19, 25, 38, 42] </ref>, graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23].
Reference: [20] <author> S. Huddleston and K. Mehlhorn. </author> <title> A new data structure for representing sorted lists. </title> <journal> Acta Informatica, </journal> <volume> 17 </volume> <pages> 157-184, </pages> <year> 1982. </year>
Reference-contexts: As mentioned, we remove these assumptions in Sections 3 and 4. 2.1 Preliminaries Our external-memory interval tree makes use of two kinds of secondary structures: the B-tree and a "corner structure" [23]. B-trees [5, 12] or more generally (a; b)-trees <ref> [20] </ref> are search tree structures suitable for external memory: Lemma 1 A set of N elements can be stored in a B-tree structure using O (N=B) blocks of external memory such that updates and queries can be performed in O (log B N ) I/Os. <p> In weak B-trees or (a; b)-trees <ref> [20] </ref> a wider range in the number of children is allowed. Here we define the weight-balanced B-tree by imposing constraints on the weight of subtrees rather than on the number of children.
Reference: [21] <author> C. Icking, R. Klein, and T. Ottmann. </author> <title> Priority search trees in secondary memory. </title> <booktitle> In Proc. Graph-Theoretic Concepts in Computer Science, </booktitle> <volume> LNCS 314, </volume> <pages> pages 84-93, </pages> <year> 1987. </year>
Reference-contexts: The priority search tree [27] for example can be used to answer slightly more general queries than diagonal corner queries, namely 3-sided range queries (Figure 1), in optimal query and update time using optimal space. A number of attempts have been made to externalize this structure, including <ref> [9, 21, 35] </ref>, but they are all non-optimal. The structure in [21] uses optimal space but answers queries in O (log 2 N +T =B) I/Os. The structure in [9] also uses optimal space but answers queries in O (log B N + T ) I/Os. <p> A number of attempts have been made to externalize this structure, including [9, 21, 35], but they are all non-optimal. The structure in <ref> [21] </ref> uses optimal space but answers queries in O (log 2 N +T =B) I/Os. The structure in [9] also uses optimal space but answers queries in O (log B N + T ) I/Os. In both papers a number of non-optimal dynamic versions of the structures are also developed. <p> In both papers a number of non-optimal dynamic versions of the structures are also developed. In [35] a technique called path caching for transforming an 2 3-sided query2-sided querydiagonal corner query general 2-dimensional query Space (blocks) Query I/O bound Update I/O bound Priority search tree <ref> [21] </ref> O (N=B) O (log 2 N + T =B) XP-tree [9] O (N=B) O (log B N + T ) Metablock tree [23] O (N=B) O (log B N + T =B) O (log B N + (log B N ) 2 =B) amortized (inserts only) P-range tree [41] O
Reference: [22] <author> P. C. Kanellakis, G. Kuper, and P. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proc. ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <year> 1990. </year>
Reference-contexts: there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) [13, 19, 25, 38, 42], graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming <ref> [22, 23] </ref>. Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck. <p> Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually [37]. In this paper we consider the special case of external 2-dimensional range searching called dynamic interval management, which is highlighted in <ref> [22, 23, 35, 41] </ref> as one of the important fl An extended abstract version of this paper was presented at the 1996 IEEE Symposium on Foundations of Computer Science (FOCS'96). y Supported in part by the ESPRIT Long Term Research Programme of the EU under project number 20244 (ALCOM-IT). <p> In [23] the dynamic interval management problem is considered, in which intervals can be inserted and deleted, and given a query interval all current intervals that intersect the query interval must be reported. This problem is crucial for indexing constraints in constraint databases and in temporal databases <ref> [22, 23, 34] </ref>. A key component of external dynamic interval management is answering stabbing queries. Given a set of intervals, to answer a stabbing query with a point q one has to report all intervals that contain q.
Reference: [23] <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, and J. S. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. ACM Symp. Principles of Database Systems, </booktitle> <year> 1993. </year> <note> A complete version (to appear in special issue of JCSS on principles of database systems) appears as technical report 90-31, </note> <institution> Brown University. </institution>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) [13, 19, 25, 38, 42], graphics [16], indexing in object-oriented and temporal databases <ref> [23, 34] </ref>, and constraint logic programming [22, 23]. Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck. <p> there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) [13, 19, 25, 38, 42], graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming <ref> [22, 23] </ref>. Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck. <p> Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually [37]. In this paper we consider the special case of external 2-dimensional range searching called dynamic interval management, which is highlighted in <ref> [22, 23, 35, 41] </ref> as one of the important fl An extended abstract version of this paper was presented at the 1996 IEEE Symposium on Foundations of Computer Science (FOCS'96). y Supported in part by the ESPRIT Long Term Research Programme of the EU under project number 20244 (ALCOM-IT). <p> The problem of developing a space and I/O-time optimal external data structure for the problem is mentioned in [35] as one of the major theoretical open problems in the area, and in <ref> [23] </ref> it is even called "the most elegant open question." In this paper we develop such an optimal structure. 1.1 Memory model and previous results We will be working in the standard model for external memory with one (logical) disk [24, 1]. <p> The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see <ref> [23] </ref> for a complete reference on the field). Recently some progress has been made on the construction of external 2-dimensional range searching structures with provably good performance. In [23] the dynamic interval management problem is considered, in which intervals can be inserted and deleted, and given a query interval all current <p> performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see <ref> [23] </ref> for a complete reference on the field). Recently some progress has been made on the construction of external 2-dimensional range searching structures with provably good performance. In [23] the dynamic interval management problem is considered, in which intervals can be inserted and deleted, and given a query interval all current intervals that intersect the query interval must be reported. This problem is crucial for indexing constraints in constraint databases and in temporal databases [22, 23, 34]. <p> In [23] the dynamic interval management problem is considered, in which intervals can be inserted and deleted, and given a query interval all current intervals that intersect the query interval must be reported. This problem is crucial for indexing constraints in constraint databases and in temporal databases <ref> [22, 23, 34] </ref>. A key component of external dynamic interval management is answering stabbing queries. Given a set of intervals, to answer a stabbing query with a point q one has to report all intervals that contain q. <p> The metablock tree developed in <ref> [23] </ref> answers diagonal corner queries in optimal O (log B N + T =B) I/Os using optimal O (N=B) blocks of external memory, where T denotes the number of points reported. <p> technique called path caching for transforming an 2 3-sided query2-sided querydiagonal corner query general 2-dimensional query Space (blocks) Query I/O bound Update I/O bound Priority search tree [21] O (N=B) O (log 2 N + T =B) XP-tree [9] O (N=B) O (log B N + T ) Metablock tree <ref> [23] </ref> O (N=B) O (log B N + T =B) O (log B N + (log B N ) 2 =B) amortized (inserts only) P-range tree [41] O (N=B) O (log B N + T =B+ O (log B N + (log B N ) 2 =B) IL fl (B)) amortized <p> Various other external data structures for answering 3-sided queries are also developed in <ref> [23] </ref> and in [35]. In [41] another attempt is made on designing a structure for answering 3-sided queries and a dynamic structure called the p-range tree is developed. <p> As mentioned, this result leads to the first known optimal solution to the interval management problem, and thus it settles an open problem highlighted in <ref> [23, 35, 41] </ref>. <p> We also assume that the internal memory is capable of holding O (B) blocks of data. As mentioned, we remove these assumptions in Sections 3 and 4. 2.1 Preliminaries Our external-memory interval tree makes use of two kinds of secondary structures: the B-tree and a "corner structure" <ref> [23] </ref>. <p> A B-tree on N sorted elements can be built in O (N=B) I/Os and the T smallest (largest) elements can be reported in O (T =B + 1) I/Os 4 A "corner structure" <ref> [23] </ref> is a stabbing query data structure that is efficient when the number of segments stored in it is O (B 2 ). Lemma 2 (Kanellakis, Ramaswamy, Vengroff, Vitter [23]) A set of k B 2 segments can be represented using O (k=B) blocks of external memory such that a stabbing <p> I/Os and the T smallest (largest) elements can be reported in O (T =B + 1) I/Os 4 A "corner structure" <ref> [23] </ref> is a stabbing query data structure that is efficient when the number of segments stored in it is O (B 2 ). Lemma 2 (Kanellakis, Ramaswamy, Vengroff, Vitter [23]) A set of k B 2 segments can be represented using O (k=B) blocks of external memory such that a stabbing query can be answered in O (T =B + 1) I/O operations where T is the number of reported segments. As discussed in [23] the corner structure can be <p> 2 (Kanellakis, Ramaswamy, Vengroff, Vitter <ref> [23] </ref>) A set of k B 2 segments can be represented using O (k=B) blocks of external memory such that a stabbing query can be answered in O (T =B + 1) I/O operations where T is the number of reported segments. As discussed in [23] the corner structure can be made dynamic by maintaining a special update block. Updates are inserted in this block and the structure is then rebuilt using O (B) I/Os once B updates have been inserted. <p> This leaves us with the amortization introduced via the underflow structure and the splitting of nodes in the base tree. In Section 4.2 we repeat the definition of the "corner structure" <ref> [23] </ref> which was used as underflow structure, and show how to do updates on this structure in O (1) I/Os in the worst case; that is, we show how to remove the amortization from Lemma 3. <p> B) Definition of a c i . 4.2 Removing amortization from the corner structure In this section we will show how to make the update bound on the "corner structure" in Lemma 3 <ref> [23] </ref> worst case. During this we will also remove the assumption about the internal memory being capable of holding O (B) blocks. Recall from the introduction that by regarding an interval [x; y] as the point (x; y) in the plane, stabbing queries reduce to diagonal corner queries. <p> Recall from the introduction that by regarding an interval [x; y] as the point (x; y) in the plane, stabbing queries reduce to diagonal corner queries. This property is used in the "corner structure" <ref> [23] </ref> which actually is a data structure that stores points in the plane above the x = y line, such that diagonal corner queries can be answered efficiently. <p> It is shown in <ref> [23] </ref> that after having defined C and C fl in the above way, and blocked the points as discussed, the total number of blocks used to store all the sets S fl i is O (k=B). <p> This is then also a bound on the total number of blocks used by the structure. Then it is show how a query can be answered in O (T =B + 1) I/Os using the representation, arriving at Lemma 2. We omit the details here and refer to <ref> [23] </ref>. Note however, that one key property is that the size of C (and thus C fl ) is less than B, which means that we can hold the set in one block. <p> As described in the introduction the assumption about the internal memory being capable of holding O (B 2 ) elements is in <ref> [23] </ref> used to make the structure dynamic with O (1) I/O amortized update bounds (Lemma 3). This is done by maintaining a special update block and then rebuild the structure completely once B updates have been inserted in this block. <p> To produce S fl j+1 we use O (djS fl djS fl j+1 j=Be) I/O's, which means that the total number of I/Os used is O (2 P j =Bje). As previously mentioned it is proved in <ref> [23] </ref> that this number is O (k=B). This completes the description of the rebuilding algorithm.
Reference: [24] <author> D. Knuth. </author> <title> The Art of Computer Programming, Vol. 3 Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: the major theoretical open problems in the area, and in [23] it is even called "the most elegant open question." In this paper we develop such an optimal structure. 1.1 Memory model and previous results We will be working in the standard model for external memory with one (logical) disk <ref> [24, 1] </ref>. We assume that each external-memory access transmits one page of B units of data, which we count as one I/O. We measure the efficiency of an algorithm in terms of the number of I/O operations it performs.
Reference: [25] <author> R. Laurini and A. D. Thompson. </author> <title> Fundamentals of Spatial Information Systems. A.P.I.C. Series, </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) <ref> [13, 19, 25, 38, 42] </ref>, graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23].
Reference: [26] <author> D. Lomet and B. Salzberg. </author> <title> The hB-tree: A multiattribute indexing method with good guaranteed performance. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(4) </volume> <pages> 625-658, </pages> <year> 1990. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees <ref> [26] </ref>, cell-trees [17], and various R-trees [18, 40]. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [27] <author> E. McCreight. </author> <title> Priority search trees. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(2) </volume> <pages> 257-276, </pages> <year> 1985. </year> <month> 23 </month>
Reference-contexts: The problem of 2-dimensional range searching in both main and external memory has been the subject of much research. Many elegant data structures like the range tree [7], the priority search tree <ref> [27] </ref>, the segment tree [6], and the interval tree [14, 15] have been proposed for use in main memory for 2-dimensional range searching and its special cases (see [11] for a detailed survey). Most of these structures are not efficient when mapped to external memory. <p> The structure is fairly involved and supports only insertions (not deletions) in O (log B N + (log B N ) 2 =B) I/Os amortized. As mentioned a number of elegant internal-memory solutions exist for 2-dimensional range searching. The priority search tree <ref> [27] </ref> for example can be used to answer slightly more general queries than diagonal corner queries, namely 3-sided range queries (Figure 1), in optimal query and update time using optimal space.
Reference: [28] <author> K. Mehlhorn. </author> <title> Data Structures and Algorithms 3: Multi-dimensional Searching and Compu--tational Geometry. </title> <note> Springer-Verlag, EATCS Monographs on Theoretical Computer Science, </note> <year> 1984. </year>
Reference-contexts: In Section 3 we then remove the fixed endpoint-set assumption. In internal memory the assumption is normally removed by using a BB [ff]-tree [30] as base search tree structure <ref> [28] </ref>, and this leads to amortized update bounds. But as BB [ff]-trees are not very suitable for implementation in external memory, we develop a special weight-balanced B-tree for use in our external interval tree structure. Like in internal memory this results in amortized update bounds. <p> In internal memory a natural choice of dynamic base tree is therefore the BB [ff]-tree [30], because in this structure a node with w items below it (with "weight" w) can only be involved in a rebalancing operation for every (w) updates that access (pass through) the node <ref> [10, 28] </ref>. This leads to an O (1) amortized bound on performing a rebalancing operation. Unfortunately BB [ff]-trees are not suitable for implementation in external memory.
Reference: [29] <author> J. Nievergelt, H. Hinterberger, and K. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(1) </volume> <pages> 257-276, </pages> <year> 1984. </year>
Reference-contexts: However, the practical need for I/O support has led to the development of a large number of external data structures that do not have good theoretical worst-case update and query I/O bounds, but do have good average-case behavior for common problems. Such methods include the grid file <ref> [29] </ref>, various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees [18, 40].
Reference: [30] <author> J. Nievergelt and E. M. Reingold. </author> <title> Binary search tree of bounded balance. </title> <journal> SIAM Journal of Computing, </journal> <volume> 2(1), </volume> <year> 1973. </year>
Reference-contexts: In Section 2 we present the basic structure where the endpoints of the intervals stored in the structure belong to a fixed set of points. In Section 3 we then remove the fixed endpoint-set assumption. In internal memory the assumption is normally removed by using a BB [ff]-tree <ref> [30] </ref> as base search tree structure [28], and this leads to amortized update bounds. But as BB [ff]-trees are not very suitable for implementation in external memory, we develop a special weight-balanced B-tree for use in our external interval tree structure. <p> In internal memory a natural choice of dynamic base tree is therefore the BB [ff]-tree <ref> [30] </ref>, because in this structure a node with w items below it (with "weight" w) can only be involved in a rebalancing operation for every (w) updates that access (pass through) the node [10, 28]. This leads to an O (1) amortized bound on performing a rebalancing operation.
Reference: [31] <author> J. Orenstein. </author> <title> Spatial query processing in an object-oriented database system. </title> <booktitle> In Proc. ACM Conf. on Management of Data, </booktitle> <pages> pages 326-336, </pages> <year> 1986. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders <ref> [31] </ref> and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees [18, 40]. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [32] <author> M. H. Overmars. </author> <title> The Design of Dynamic Data Structures. </title> <publisher> Springer-Verlag, LNCS 156, </publisher> <year> 1983. </year>
Reference-contexts: For simplicity we only consider inserts in this section. In the next section, where we will use the weight-balanced B-tree as base tree in our external interval tree, we discuss how deletes can be handled using the global rebuilding technique <ref> [32] </ref>. After finding the leaf w to insert a new elements into, we do the following: We insert the element in the sorted order of elements in w. <p> The large number of updates between splits of a node immediately implies the good amortized bound, and using the global rebuilding technique <ref> [32] </ref>, where the rebuilding of the secondary structures is done lazily over the next O (w) updates that access the node, results in the worst-case bound. <p> Now as mentioned in Section 3.1 we can also handle deletions by using the global rebuilding technique <ref> [32] </ref>. When we want to delete a segment s, we delete it from the secondary structures as described in Section 2 without deleting the endpoints of s from the base tree. Instead we just mark the two endpoints in the leaves of the base tree as deleted. <p> The last use of amortization can be made worst case using the standard global rebuilding technique. The general idea is the following (see <ref> [32] </ref> for details): Instead of using O (N log B N ) I/Os all at once to rebuild the entire structure when the number of endpoints falls below N=2, we distribute the rebuilding over the next 1=3 N=2 updates, that is, we still use and update the original structure and in
Reference: [33] <author> Y. N. Patt. </author> <title> The I/O subsystem|a candidate for improvement. Guest Editor's Introduction in IEEE Computer, </title> <booktitle> 27(3) </booktitle> <pages> 15-16, </pages> <year> 1994. </year>
Reference-contexts: EOS project GIS system [13] is an example of such an application, as it is expected to manipulate petabytes (thousands of terabytes, or millions of gigabytes) of data! The effect of the I/O bottleneck is getting more pronounced as internal computation gets faster, and especially as parallel computing gains popularity <ref> [33] </ref>. Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually [37].
Reference: [34] <author> S. Ramaswamy and P. Kanellakis. </author> <title> OOBD indexing by class division. </title> <booktitle> In A.P.I.C. Series, </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) [13, 19, 25, 38, 42], graphics [16], indexing in object-oriented and temporal databases <ref> [23, 34] </ref>, and constraint logic programming [22, 23]. Often the amount of data manipulated in such applications are too large to fit in main memory and must reside on disk, and in such cases the Input/Output (I/O) communication can become a bottleneck. <p> In [23] the dynamic interval management problem is considered, in which intervals can be inserted and deleted, and given a query interval all current intervals that intersect the query interval must be reported. This problem is crucial for indexing constraints in constraint databases and in temporal databases <ref> [22, 23, 34] </ref>. A key component of external dynamic interval management is answering stabbing queries. Given a set of intervals, to answer a stabbing query with a point q one has to report all intervals that contain q.
Reference: [35] <author> S. Ramaswamy and S. Subramanian. </author> <title> Path caching: A technique for optimal external searching. </title> <booktitle> In Proc. ACM Symp. Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually [37]. In this paper we consider the special case of external 2-dimensional range searching called dynamic interval management, which is highlighted in <ref> [22, 23, 35, 41] </ref> as one of the important fl An extended abstract version of this paper was presented at the 1996 IEEE Symposium on Foundations of Computer Science (FOCS'96). y Supported in part by the ESPRIT Long Term Research Programme of the EU under project number 20244 (ALCOM-IT). <p> The problem of developing a space and I/O-time optimal external data structure for the problem is mentioned in <ref> [35] </ref> as one of the major theoretical open problems in the area, and in [23] it is even called "the most elegant open question." In this paper we develop such an optimal structure. 1.1 Memory model and previous results We will be working in the standard model for external memory with <p> The priority search tree [27] for example can be used to answer slightly more general queries than diagonal corner queries, namely 3-sided range queries (Figure 1), in optimal query and update time using optimal space. A number of attempts have been made to externalize this structure, including <ref> [9, 21, 35] </ref>, but they are all non-optimal. The structure in [21] uses optimal space but answers queries in O (log 2 N +T =B) I/Os. The structure in [9] also uses optimal space but answers queries in O (log B N + T ) I/Os. <p> The structure in [9] also uses optimal space but answers queries in O (log B N + T ) I/Os. In both papers a number of non-optimal dynamic versions of the structures are also developed. In <ref> [35] </ref> a technique called path caching for transforming an 2 3-sided query2-sided querydiagonal corner query general 2-dimensional query Space (blocks) Query I/O bound Update I/O bound Priority search tree [21] O (N=B) O (log 2 N + T =B) XP-tree [9] O (N=B) O (log B N + T ) Metablock <p> O (log B N + T =B) O (log B N + (log B N ) 2 =B) amortized (inserts only) P-range tree [41] O (N=B) O (log B N + T =B+ O (log B N + (log B N ) 2 =B) IL fl (B)) amortized Path Caching <ref> [35] </ref> O ((N=B) log 2 log 2 B) O (log B N + T =B) O (log B N ) amortized Our Result O (N=B) O (log B N + T =B) O (log B N ) efficient internal-memory data structure into an I/O efficient one is developed. <p> Various other external data structures for answering 3-sided queries are also developed in [23] and in <ref> [35] </ref>. In [41] another attempt is made on designing a structure for answering 3-sided queries and a dynamic structure called the p-range tree is developed. <p> The segment tree [6] can also be used to solve the stabbing query problem, but even in internal memory it uses more than linear space. Some attempts have been made to externalizing this structure <ref> [8, 35] </ref> and they all use O ((N=B) log 2 N ) blocks of external memory. <p> Some attempts have been made to externalizing this structure [8, 35] and they all use O ((N=B) log 2 N ) blocks of external memory. The best of them <ref> [35] </ref> is static and answers queries in the optimal O (log B N + T =B) I/Os. 1.2 Overview of our results Our main results in this paper is an optimal external-memory data structure for the stabbing query problem. <p> As mentioned, this result leads to the first known optimal solution to the interval management problem, and thus it settles an open problem highlighted in <ref> [23, 35, 41] </ref>. <p> Finally, in Section 5 we discuss how to use the ideas behind our external interval tree to develop an external version of the segment tree with space bound O ((N=B) log B N ). This improves upon previously known data structures <ref> [8, 35] </ref>, which use O ((N=B) log 2 N ) blocks of external memory. Our structure has worst-case optimal query and update I/O bounds, whereas the other known structures are only query optimal in the static case. <p> This creates a number of problems when we want to store segments in secondary structures such that queries can be answered efficiently. The starting idea behind our successful externalization of the structure, as compared with previous attempts <ref> [9, 35] </ref>, is that the nodes in our structure have fan-out B instead of B, following ideas from [2, 3, 4]. The implications of this smaller fan-out are explained later in this section. <p> from our external interval tree structure and proves Theorem 4. 5 External-memory segment tree The ideas behind our external-memory interval tree can also be used to develop an external-memory segment tree-like structure with optimal update and query I/O bounds and a better space bound than all previous known such structures <ref> [8, 35] </ref>. In this section we sketch this structure.
Reference: [36] <author> J. Robinson. </author> <title> The K-D-B tree: A search structure for large multidimensional dynamic indexes. </title> <booktitle> In Proc. ACM Conf. on Management of Data, </booktitle> <pages> pages 10-18, </pages> <year> 1984. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress <ref> [36] </ref>, hB-trees [26], cell-trees [17], and various R-trees [18, 40]. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [37] <author> C. Ruemmler and J. Wilkes. </author> <title> An introduction to disk drive modeling. </title> <journal> IEEE Computer, </journal> <volume> 27(3) </volume> <pages> 17-28, </pages> <year> 1994. </year>
Reference-contexts: Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually <ref> [37] </ref>.
Reference: [38] <author> H. Samet. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) <ref> [13, 19, 25, 38, 42] </ref>, graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23]. <p> Such methods include the grid file [29], various quad-trees <ref> [38, 39] </ref>, z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees [18, 40].
Reference: [39] <author> H. Samet. </author> <title> The Design and Analyses of Spatial Data Structures. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1989. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees <ref> [38, 39] </ref>, z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees [18, 40].
Reference: [40] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + -tree: A dynamic index for multidimensional objects. </title> <booktitle> In Proc. IEEE International Conf. on Very Large Databases, </booktitle> <year> 1987. </year>
Reference-contexts: Such methods include the grid file [29], various quad-trees [38, 39], z-orders [31] and other space filling curves, k-d-B-tress [36], hB-trees [26], cell-trees [17], and various R-trees <ref> [18, 40] </ref>. The worst-case performance of these data structures is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B-trees (see [23] for a complete reference on the field).
Reference: [41] <author> S. Subramanian and S. Ramaswamy. </author> <title> The p-range tree: A new data structure for range searching in secondary memory. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 378-387, </pages> <year> 1995. </year>
Reference-contexts: Currently, technological advances are increasing CPU speeds at an annual rate of 40-60% while disk transfer rates are only increasing by 7-10% annually [37]. In this paper we consider the special case of external 2-dimensional range searching called dynamic interval management, which is highlighted in <ref> [22, 23, 35, 41] </ref> as one of the important fl An extended abstract version of this paper was presented at the 1996 IEEE Symposium on Foundations of Computer Science (FOCS'96). y Supported in part by the ESPRIT Long Term Research Programme of the EU under project number 20244 (ALCOM-IT). <p> tree [21] O (N=B) O (log 2 N + T =B) XP-tree [9] O (N=B) O (log B N + T ) Metablock tree [23] O (N=B) O (log B N + T =B) O (log B N + (log B N ) 2 =B) amortized (inserts only) P-range tree <ref> [41] </ref> O (N=B) O (log B N + T =B+ O (log B N + (log B N ) 2 =B) IL fl (B)) amortized Path Caching [35] O ((N=B) log 2 log 2 B) O (log B N + T =B) O (log B N ) amortized Our Result O <p> Various other external data structures for answering 3-sided queries are also developed in [23] and in [35]. In <ref> [41] </ref> another attempt is made on designing a structure for answering 3-sided queries and a dynamic structure called the p-range tree is developed. <p> As mentioned, this result leads to the first known optimal solution to the interval management problem, and thus it settles an open problem highlighted in <ref> [23, 35, 41] </ref>.
Reference: [42] <author> M. van Kreveld. </author> <title> Geographic information systems. </title> <institution> Utrecht University, INF/DOC-95-01, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction In recent years there has been much effort in developing efficient external-memory data structures for range searching, which is a fundamental primitive in several large-scale applications, including spatial databases and geographic information systems (GIS) <ref> [13, 19, 25, 38, 42] </ref>, graphics [16], indexing in object-oriented and temporal databases [23, 34], and constraint logic programming [22, 23].
Reference: [43] <author> D. E. Vengroff and J. S. Vitter. </author> <title> Efficient 3-d range searching in external memory. </title> <booktitle> In Proc. ACM Symp. on Theory of Computation, </booktitle> <pages> pages 192-201, </pages> <year> 1996. </year>
Reference-contexts: It should be mentioned that the p-range tree can be extended to answer general 2-dimensional queries, and that very recently a static structure for 3-dimensional queries has been developed in <ref> [43] </ref>. The segment tree [6] can also be used to solve the stabbing query problem, but even in internal memory it uses more than linear space.
Reference: [44] <author> D. Willard and G. Lueker. </author> <title> Adding range restriction capability to dynamic data structures. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 597-617, </pages> <year> 1985. </year> <month> 24 </month>
Reference-contexts: For example fixing B to a constant in our result yields an internal-memory interval tree with worst-case update bounds. Our B-tree structure can also be used as a (simpler) alternative to the rather complicated structure developed in <ref> [44] </ref> in order to add range restriction capabilities to internal-memory dynamic data structures. It seems possible to use the techniques in [44] to remove the amortization from the update bound of the internal interval tree, but our method is much simpler. <p> Our B-tree structure can also be used as a (simpler) alternative to the rather complicated structure developed in <ref> [44] </ref> in order to add range restriction capabilities to internal-memory dynamic data structures. It seems possible to use the techniques in [44] to remove the amortization from the update bound of the internal interval tree, but our method is much simpler. <p> Fixing B to a constant yields an internal-memory segment tree (without the fixed endpoint set assumption) with worst case update bounds. Again we believe that our way of removing the amortization is simpler than a possible complicated use of the techniques in <ref> [44] </ref>. 2 External-memory interval tree with fixed endpoint set In this section we present the basic structure where the endpoints of the intervals have to belong to a fixed set. We also assume that the internal memory is capable of holding O (B) blocks of data. <p> As mentioned in the introduction one example of how the weight-balanced B-tree can be used as a simpler alternative to existing internal-memory data structures, is in adding range restriction capabilities to dynamic data structures as described in <ref> [44] </ref>. We will not go into details with the construction, but refer the interested reader to [44]. <p> the introduction one example of how the weight-balanced B-tree can be used as a simpler alternative to existing internal-memory data structures, is in adding range restriction capabilities to dynamic data structures as described in <ref> [44] </ref>. We will not go into details with the construction, but refer the interested reader to [44]. The essence in the construction is to have a base search tree and then augment every internal node of this tree with another dynamic data structure on the set of items in the leaves below the node. <p> Using a BB [ff]-tree as the base tree results in good amortized update bounds as discussed, and in <ref> [44] </ref> it is shown how good worst-case bounds 10 can be obtained by a complicated redefinition of the BB [ff]-tree and the operations on it.
References-found: 44

