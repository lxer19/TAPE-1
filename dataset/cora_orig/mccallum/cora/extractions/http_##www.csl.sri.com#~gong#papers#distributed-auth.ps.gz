URL: http://www.csl.sri.com/~gong/papers/distributed-auth.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs93.html
Root-URL: 
Title: Increasing Availability and Security of an Authentication Service  
Author: Li Gong 
Date: June 9, 1993  
Address: 333 Ravenswood Avenue Menlo Park, California 94025, U.S.A.  
Affiliation: SRI International Computer Science Laboratory  
Abstract: Authentication is a process by which one satisfies another about one's claim of identity. Typically an authentication server provides the authentication service via an authentication protocol. The authentication service is a security bottleneck in that its compromise can lead to the compromise of the whole system. The service is also a performance bottleneck because many activities cannot proceed unless the identities of concerned parties can be satisfactorily established. Therefore, a desirable authentication service should be both highly secure and highly available. We propose a general solution by replicating the authentication server such that a minority of malicious and colluding servers cannot compromise security or disrupt service. We discuss some unusual features of such a distributed authentication service, including the trade-off between availability and security. A distributed service is also useful when clients cannot identify or agree upon trusted servers prior to authentication. For example, in some cooperative or federated systems, clients simply cannot all trust the same set of servers. 
Abstract-found: 1
Intro-found: 1
Reference: [Bull 92] <author> J.A. Bull, L. Gong, and K.R. Sollins, </author> <title> "Towards Security in an Open Systems Federation", </title> <booktitle> Proceedings of European Symposium on Research in Computer Security, </booktitle> <address> 10 Toulouse, France, </address> <month> November, </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Sci--ence, </note> <editor> Vol.648, pp.3-20, </editor> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A distributed authentication service is particularly useful when clients cannot identify or agree upon trusted servers prior to authentication. Apart from enabling activities such as internal auditing, such a distributed service also forms a necessary basis for some cooperative or federated systems (e.g., <ref> [Bull 92] </ref>). For example, mutually competitive, hostile, but nevertheless communicating organizations cannot let any particular organization to manage the authentication service; nor can they all trust the same set of servers. 2 We organize the rest of the paper as follows.
Reference: [Burrows 90] <author> M. Burrows, M. Abadi, R.M. Needham, </author> <title> "A Logic for Authentication", </title> <journal> ACM Transactions on Computer Systems, Vol.8, </journal> <volume> No.1, </volume> <month> February, </month> <year> 1990, </year> <month> pp.18-36. </month>
Reference-contexts: Better coding techniques may reduce the size of a cross checksum. We have not fully analyzed the proposed protocol using logics of authentication <ref> [Burrows 90, Gong 90] </ref>, although preliminary examination suggests that the protocol does not have the kind of weaknesses that the logic is designed to capture. Acknowledgement Professor D.J.
Reference: [Chor 85] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch, </author> <title> "Verifiable Secret Sharing and Achieving Simultaneity in the Process of Faults", </title> <booktitle> Proceedings of the 26th IEEE Symposium on the Foundations of Computer Science, </booktitle> <month> October, </month> <year> 1985, </year> <month> pp.383-395. </month>
Reference-contexts: Some proposed schemes (e.g., <ref> [Chor 85] </ref>) are not very suited to the application here because they use many rounds of messages and usually require all participants' cooperation to complete the protocol. We now introduce a cross-checksum scheme as a suitable alternative.
Reference: [Denning 81] <author> D.E. Denning and G.M. Sacco, </author> <title> "Timestamps in Key Distribution Protocols", </title> <journal> Communications of the ACM, Vol.24, </journal> <volume> No.8, </volume> <month> August, </month> <year> 1981, </year> <month> pp.533-536. </month>
Reference-contexts: Since there are n servers to communicate with 2 , the total number of messages is 4n + 3. If participants of the protocol already have synchronized clocks, they can use time-stamps in place of the nonces to prove message timeliness <ref> [Denning 81] </ref>. In this case, A no longer needs the initial exchange (messages 1 and 2), thus the total number of messages is reduced from 4n + 3 to 2n + 3.
Reference: [Desmedt 91] <author> Y. Desmedt and Y. Frankel, </author> <title> "Shared Generation of Authenticators and Signatures", </title> <booktitle> Advances in Cryptology, Proceedings of Crypto '91. Published as Lecture Notes in Computer Science, </booktitle> <address> No.576, </address> <publisher> Springer-Verlag, pp.457-469. </publisher>
Reference-contexts: The handshake messages need to be modified 9 accordingly. When a client shares public keys with the servers, the case is similar except that the client has to remember many public keys. This last requirement could be relaxed by using a threshold signature scheme <ref> [Desmedt 91, Reiter 92] </ref>. Other hybrid schemes are also possible.
Reference: [Diffie 76] <author> W. Diffie and M.E. Hellman, </author> <title> "New Directions in Cryptography", </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. </volume> <pages> IT-22, </pages> <address> No.6, </address> <month> November, </month> <year> 1976, </year> <month> pp.644-654. </month>
Reference-contexts: For brevity, we use mutual authentication in our discussion, though our results also apply to one way authentication. An authentication protocol can be based on either a conventional cryptosystem or a public-key system or both <ref> [Diffie 76, Needham 78] </ref>. We first concentrate on the (most common) case of using conventional systems. Later we will discuss the use of public-key systems. <p> We assume that a client (say A) registers a different key Kai with server S i . Client A can derive these keys from a master key Ka. For example, if h () is a suitable one-way hash function <ref> [Diffie 76, Merkle 90] </ref>, then A could register key Kai = h (Ka; S i ) with server S i . This arrangement gives extra security since one server (say S 1 ) does not know A's other keys (Ka; Ka2; : : : ; Kan).
Reference: [Gifford 79] <author> D. Gifford, </author> <title> "Weighted Voting for Replicated Data", </title> <booktitle> Proceedings of the 7th ACM Symposium on Operating System Principles, </booktitle> <month> December, </month> <year> 1979, </year> <month> pp.150-162. </month>
Reference-contexts: This weighted voting approach works well because the security parameters (the weights) can be dynamically assigned and a protocol operates consistently in the presence of network partitions <ref> [Gifford 79] </ref>. Moreover, by assigning more votes to some servers, clients may communicate with less servers, thus the number of messages is reduced and the overall availability is improved. This once again demonstrates the trade-off between availability and security. Servers need not communicate among themselves.
Reference: [Gligor 92] <author> V.D. Gligor, S.W. Luan, and J. Pato, </author> <title> "On Inter-Realm Authentication in Large Distributed Systems", </title> <booktitle> Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, California, </address> <month> May, </month> <year> 1992, </year> <month> pp.2-17. </month>
Reference-contexts: A worthwhile effort, like that in the Kerberos work [Miller 88], would be to engineer a practical design of a distributed authentication service and complete an implementation. Issues such as inter-realm authentication <ref> [Gligor 92] </ref> can only be fully examined in such an experiment. Also, the basic protocol may be extended to deal with additional concerns, such as protecting poorly-chosen client keys [Gong 93]. Reducing the cost of replication is important, especially when the use of public-key system is impractical.
Reference: [Gong 89] <author> L. Gong, </author> <title> "Securely Replicating Authentication Services", </title> <booktitle> Proceedings of the IEEE 9th International Conference on Distributed Computing Systems, </booktitle> <address> Newport Beach, California, </address> <month> June, </month> <year> 1989, </year> <month> pp.85-91. </month>
Reference-contexts: Acknowledgement Professor D.J. Wheeler and Mark Lomas of Cambridge University brought this subject to my attention and provided valuable comments on an earlier version of this paper <ref> [Gong 89] </ref>.
Reference: [Gong 90] <author> L. Gong, R. Needham, and R. Yahalom, </author> <title> "Reasoning about Belief in Cryptographic Protocols", </title> <booktitle> Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <address> Oakland, California, </address> <month> May, </month> <year> 1990, </year> <month> pp.234-248. </month>
Reference-contexts: Better coding techniques may reduce the size of a cross checksum. We have not fully analyzed the proposed protocol using logics of authentication <ref> [Burrows 90, Gong 90] </ref>, although preliminary examination suggests that the protocol does not have the kind of weaknesses that the logic is designed to capture. Acknowledgement Professor D.J.
Reference: [Gong 92] <author> L. Gong, </author> <title> "A Security Risk of Depending on Synchronized Clocks", </title> <journal> ACM Operating Systems Review, Vol.26, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1992, </year> <month> pp.49-53. </month>
Reference-contexts: In this case, A no longer needs the initial exchange (messages 1 and 2), thus the total number of messages is reduced from 4n + 3 to 2n + 3. Maintaining synchronized clocks by itself is a non-trivial and costly task (e.g., <ref> [Mills 89, Simons 90, Liskov 91, Gong 92] </ref>). Also, since the clock of a compromised or faulty server cannot be trusted to tell the correct time, a client may need to vote on the time-stamps received from the servers.
Reference: [Gong 93] <author> L. Gong, T.M.A. Lomas, R.M. Needham, and J.H. Saltzer, </author> <title> "Protecting Poorly-Chosen Secrets from Guessing Attacks", </title> <journal> IEEE Journal on Selected Areas in Communications", Vol.11, </journal> <volume> No.5, </volume> <month> June, </month> <year> 1993. </year>
Reference-contexts: Issues such as inter-realm authentication [Gligor 92] can only be fully examined in such an experiment. Also, the basic protocol may be extended to deal with additional concerns, such as protecting poorly-chosen client keys <ref> [Gong 93] </ref>. Reducing the cost of replication is important, especially when the use of public-key system is impractical. For example, using Rabin's secret-sharing scheme [Rabin 89] can significantly reduce the size of a shadow, with only minor security implications in that t 1 shadows reveal limited information about a key.
Reference: [Herlihy 87] <author> M.P. Herlihy and J.D. Tygar, </author> <title> "How to Make Replicated Data Secure", </title> <booktitle> Advances in Cryptology, Proceedings of Crypto '87. Published as Lecture Notes in Computer Science, </booktitle> <address> Vol.293, </address> <publisher> Springer-Verlag, pp.379-391. </publisher>
Reference-contexts: Since clients do not share secrets before authentication completes, they cannot verify the correctness of the replicated service through a separate and secure channel. This unique feature distinguishes the replication of an authentication server from other replications such as a key-based secure replication of a file server <ref> [Herlihy 87] </ref>. A distributed authentication service is particularly useful when clients cannot identify or agree upon trusted servers prior to authentication. Apart from enabling activities such as internal auditing, such a distributed service also forms a necessary basis for some cooperative or federated systems (e.g., [Bull 92]).
Reference: [Kothari 84] <author> S.C. Kothari, </author> <title> "Generalized Linear Threshold Scheme", </title> <booktitle> Advances in Cryptology, Proceedings of Crypto '84. Published as Lecture Notes in Computer Science, </booktitle> <volume> Vol. 196, </volume> <publisher> Springer-Verlag, pp.231-241. </publisher> <pages> 11 </pages>
Reference-contexts: With messages 1 and 2, A obtains a nonce from each server. A chooses a candidate session key x and computes f t;n (x; i) for each server S i . Here f t;n () is a threshold function <ref> [Kothari 84] </ref> that produces n shadows of x in such a way that it is easy to recover x from any t shadows, but less than t shadows reveals no information about x. We will explain this function later. In message 3, A sends one shadow to each server. <p> Hierarchical threshold schemes <ref> [Kothari 84] </ref> can be used in this case. One scheme is to give selected servers more shadows so that they have more say in voting out illegitimate messages and they contribute more to availability.
Reference: [Liskov 91] <author> B. Liskov, </author> <title> "Practical Uses of Synchronized Clocks in Distributed Systems", </title> <booktitle> Pro--ceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, </address> <month> August, </month> <year> 1991, </year> <month> pp.1-9. </month>
Reference-contexts: In this case, A no longer needs the initial exchange (messages 1 and 2), thus the total number of messages is reduced from 4n + 3 to 2n + 3. Maintaining synchronized clocks by itself is a non-trivial and costly task (e.g., <ref> [Mills 89, Simons 90, Liskov 91, Gong 92] </ref>). Also, since the clock of a compromised or faulty server cannot be trusted to tell the correct time, a client may need to vote on the time-stamps received from the servers.
Reference: [Merkle 90] <author> R.C. Merkle, </author> <title> "A Fast Software One Way Hash Function", </title> <journal> Journal of Cryptology, Vol.3, </journal> <volume> No.1, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990, </year> <month> pp.43-58. </month>
Reference-contexts: We assume that a client (say A) registers a different key Kai with server S i . Client A can derive these keys from a master key Ka. For example, if h () is a suitable one-way hash function <ref> [Diffie 76, Merkle 90] </ref>, then A could register key Kai = h (Ka; S i ) with server S i . This arrangement gives extra security since one server (say S 1 ) does not know A's other keys (Ka; Ka2; : : : ; Kan). <p> B ! A: fB; na; y i ; cc (y)g kai ; fnag Kab ; nb 7. A ! B: fnbg Kab Adding the cross checksums does not degrade security because g () is a one-way hash function (e.g., <ref> [Merkle 90] </ref>). We require that given a number of pairs z's and g (z)'s, it is computationally infeasible to compute k from g (k; x) and x.
Reference: [Miller 88] <author> S.P. Miller, B.C. Neuman, J.L. Schiller, and J.H. Saltzer, </author> <title> "Kerberos Authentication and Authorization System", </title> <type> Project Athena Technical Plan, </type> <institution> Section E.2.1, Massachusetts Institute of Technology, </institution> <month> October, </month> <year> 1988. </year>
Reference-contexts: Apart from removing the bottlenecks, a distributed service is also useful when clients cannot identify trusted authentication servers or cannot all trust the same servers. A worthwhile effort, like that in the Kerberos work <ref> [Miller 88] </ref>, would be to engineer a practical design of a distributed authentication service and complete an implementation. Issues such as inter-realm authentication [Gligor 92] can only be fully examined in such an experiment.
Reference: [Mills 89] <author> D.L. Mills, </author> <title> "Network Time Protocol (Version 2) Specification and Implementation", IAB Network Working Group, </title> <type> RFC 1119, </type> <month> September, </month> <year> 1989. </year>
Reference-contexts: In this case, A no longer needs the initial exchange (messages 1 and 2), thus the total number of messages is reduced from 4n + 3 to 2n + 3. Maintaining synchronized clocks by itself is a non-trivial and costly task (e.g., <ref> [Mills 89, Simons 90, Liskov 91, Gong 92] </ref>). Also, since the clock of a compromised or faulty server cannot be trusted to tell the correct time, a client may need to vote on the time-stamps received from the servers.
Reference: [Needham 78] <author> R.M. Needham, and M.D. Schroeder, </author> <title> "Using Encryption for Authentication in Large Networks of Computers", </title> <journal> Communications of the ACM, Vol.21, No.12, </journal> <volume> De-cember, </volume> <year> 1978, </year> <month> pp.993-999. </month>
Reference-contexts: As a proof of concept, we use secret-sharing techniques and introduce a cross-checksum scheme to develop a protocol that is similar to the Needham-Schroeder authentication protocol <ref> [Needham 78] </ref>, but is different in that a set of servers provide a distributed authentication service, with each server providing only a fraction of the authentication. <p> For brevity, we use mutual authentication in our discussion, though our results also apply to one way authentication. An authentication protocol can be based on either a conventional cryptosystem or a public-key system or both <ref> [Diffie 76, Needham 78] </ref>. We first concentrate on the (most common) case of using conventional systems. Later we will discuss the use of public-key systems. <p> Thus an authentication protocol is sometimes also called a key distribution protocol. Let us now examine a protocol that is similar to the Needham-Schroeder protocol <ref> [Needham 78, Needham 87] </ref>, with messages packaged in the style of Otway-Rees [Otway 87]. Client A (or B) exclusively shares a secret key Ka (or Kb) with the trusted authentication server S. By executing the following protocol, A and B intend to establish a session key Kab. <p> Also assume that they still share conventional system keys with the servers. Now an authentication protocol could arrange that A obtains K pb (instead of y) and B obtains K pa (instead of x) <ref> [Needham 78] </ref>, similarly using the servers as brokers. <p> If no majority is found, A (or B) considers the service unavailable. Otherwise, they can use the two keys directly for subsequent communication, or they can arrange a further session key (for a conventional cryptosystem) <ref> [Needham 78] </ref>. The handshake messages need to be modified 9 accordingly. When a client shares public keys with the servers, the case is similar except that the client has to remember many public keys. This last requirement could be relaxed by using a threshold signature scheme [Desmedt 91, Reiter 92].
Reference: [Needham 87] <author> R.M. Needham and M.D. Schroeder, </author> <title> "Authentication Revisited", </title> <journal> ACM Operating Systems Review, Vol.21, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1987, </year> <month> p.7. </month>
Reference-contexts: Thus an authentication protocol is sometimes also called a key distribution protocol. Let us now examine a protocol that is similar to the Needham-Schroeder protocol <ref> [Needham 78, Needham 87] </ref>, with messages packaged in the style of Otway-Rees [Otway 87]. Client A (or B) exclusively shares a secret key Ka (or Kb) with the trusted authentication server S. By executing the following protocol, A and B intend to establish a session key Kab. <p> A ! B: fnbg Kab Each participant generates a nonce (nsi for S i , na for A, and nb for B), which is later included in encrypted messages (3 though 7) addressed to the participant so that the freshness of the messages can be established <ref> [Needham 87] </ref>. With messages 1 and 2, A obtains a nonce from each server. A chooses a candidate session key x and computes f t;n (x; i) for each server S i .
Reference: [Otway 87] <author> D. Otway and O. Rees, </author> <title> "Efficient and Timely Mutual Authentication", </title> <journal> ACM Operating Systems Review, Vol.21, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1987, </year> <month> pp.8-10. </month>
Reference-contexts: Thus an authentication protocol is sometimes also called a key distribution protocol. Let us now examine a protocol that is similar to the Needham-Schroeder protocol [Needham 78, Needham 87], with messages packaged in the style of Otway-Rees <ref> [Otway 87] </ref>. Client A (or B) exclusively shares a secret key Ka (or Kb) with the trusted authentication server S. By executing the following protocol, A and B intend to establish a session key Kab.
Reference: [Rabin 89] <author> M.O. Rabin, </author> <title> "Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance", </title> <journal> Journal of the ACM, Vol.36, No.2, </journal> <month> April, </month> <year> 1989, </year> <month> pp.335-348. </month>
Reference-contexts: Also, the basic protocol may be extended to deal with additional concerns, such as protecting poorly-chosen client keys [Gong 93]. Reducing the cost of replication is important, especially when the use of public-key system is impractical. For example, using Rabin's secret-sharing scheme <ref> [Rabin 89] </ref> can significantly reduce the size of a shadow, with only minor security implications in that t 1 shadows reveal limited information about a key. Better coding techniques may reduce the size of a cross checksum.
Reference: [Reiter 92] <author> M. K. Reiter and K. P. Birman, </author> <title> "How to Securely Replicate Services", </title> <institution> TR92-1287, Department of Computer Science, Cornell University, </institution> <month> June, </month> <year> 1992. </year>
Reference-contexts: The handshake messages need to be modified 9 accordingly. When a client shares public keys with the servers, the case is similar except that the client has to remember many public keys. This last requirement could be relaxed by using a threshold signature scheme <ref> [Desmedt 91, Reiter 92] </ref>. Other hybrid schemes are also possible.
Reference: [Schlichting 83] <author> R.D. Schlichting and F.B. Schneider, </author> <title> "Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems", </title> <journal> ACM Transactions on Computing Systems, Vol.1, </journal> <volume> No.3, </volume> <month> August, </month> <year> 1983, </year> <month> pp.222-238. </month>
Reference-contexts: From now on, we do not distinguish between denial of service, node crash, 1 A fail-stop processor automatically halts in response to any internal failure and does so before the effects are visible to the outside world <ref> [Schlichting 83] </ref>. 4 and communication failure, because they are all availability issues and have the same appearance to clients.
Reference: [Shamir 79] <author> A. Shamir, </author> <title> "How to Share a Secret", </title> <journal> Communications of the ACM, Vol.22, </journal> <volume> No.11, </volume> <month> November, </month> <year> 1979, </year> <month> pp.612-613. </month>
Reference-contexts: Then they both compute session key Kab = g (x; y), where g () is a pre-determined one-way hash function, and complete a two way handshake. To see how f t;n () works, we describe Shamir's secret-sharing scheme <ref> [Shamir 79] </ref>, which is based on polynomial interpolation. To compute f t;n (x; i), A chooses a random (t 1) degree polynomial p (x) with p (0) = x. A then computes x i = f t;n (x; i) = p (i); i = 1; : : :; n.
Reference: [Simons 90] <author> B. Simons, J.L. Welch, and N. Lynch, </author> <title> "An Overview of Clock Synchronization", </title> <editor> in B. Simons and A. Spector (Eds.), </editor> <booktitle> Fault-Tolerant Distributed Computing, published as Lecture Notes in Computer Science, </booktitle> <address> No.448, </address> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <month> 12 </month>
Reference-contexts: In this case, A no longer needs the initial exchange (messages 1 and 2), thus the total number of messages is reduced from 4n + 3 to 2n + 3. Maintaining synchronized clocks by itself is a non-trivial and costly task (e.g., <ref> [Mills 89, Simons 90, Liskov 91, Gong 92] </ref>). Also, since the clock of a compromised or faulty server cannot be trusted to tell the correct time, a client may need to vote on the time-stamps received from the servers.
References-found: 26

