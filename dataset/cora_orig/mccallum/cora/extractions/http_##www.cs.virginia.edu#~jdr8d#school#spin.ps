URL: http://www.cs.virginia.edu/~jdr8d/school/spin.ps
Refering-URL: http://www.cs.virginia.edu/~jdr8d/school/
Root-URL: http://www.cs.virginia.edu
Title: Using Spin to Help Teach Concurrent Programming  
Author: John Regehr 
Date: May 1, 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Wayne A. Christopher, Steven J. Procter, and Thomas E. Anderson. </author> <title> The Nachos Instructional Operating System. </title> <institution> Computer Science Division, University of California at Berkeley. </institution>
Reference-contexts: I will argue that the former is very difficult to teach well, and that it can be taught better with the help of a system that can be used to model and prove properties about concurrent programs. 2 What's Wrong with Nachos and Minix Nachos <ref> [1] </ref>, Minix [5], and XINU [2] are operating systems designed to teach operating systems. The premise is that a simplified system will contain the essential structure, without bogging students down with the irrelevant details that pervade a real OS. <p> This logic is sound with respect to teaching operating systems design and implementation; however, it does not carry over to teaching concurrent programming, which the student is usually expected to pick up along the with rest. For example, we find the following quote in <ref> [1] </ref>: When we first used Nachos, we omitted many of the practice problems we now include, thinking that students would see enough con-currency in the rest of the project.
Reference: [2] <author> Douglas E. Comer. </author> <title> Operating Systems Design: The XINU Approach. </title> <publisher> Pren-tice Hall, </publisher> <year> 1984. </year>
Reference-contexts: I will argue that the former is very difficult to teach well, and that it can be taught better with the help of a system that can be used to model and prove properties about concurrent programs. 2 What's Wrong with Nachos and Minix Nachos [1], Minix [5], and XINU <ref> [2] </ref> are operating systems designed to teach operating systems. The premise is that a simplified system will contain the essential structure, without bogging students down with the irrelevant details that pervade a real OS. <p> If both processes can be in the critical section at the same time, the assertion will fail. byte in; bool lock; active <ref> [2] </ref> proctype user () - /* wait for lock to be free */ (lock == 0); /* grab the lock */ lock = 1; /* critical section */ in++; assert (in == 1); in--; /* release the lock */ lock = 0; goto L1; - 5 ASSIGNMENT 1: MUTUAL EXCLUSION 4 <p> Therefore, there are many algorithms designed to implement mutual exclusion using only basic atomic operations such as memory references. Try to find a situation in which the following algorithm does not guarantee mutual exclusion: byte in; byte x, y, z; active <ref> [2] </ref> proctype user () - byte me = _pid+1; /* me is 1 or 2 */ L1: x = me; :: (y != 0 && y != me) -&gt; goto L1 /* try again */ :: (y == 0 || y == me) L3: z = me; :: (x != me) <p> Also explain in your own words what went wrong. 5.4 Another Real Algorithm Implement the following 2-process mutual exclusion algorithm (from p. 143 of Silberschatz and Galvin) in Promela without using atomic. i is the id of the running process, and is either 0 or 1. bool flag <ref> [2] </ref>; bool turn; while (TRUE) - flag [i] = TRUE; turn = 1-i; while (flag [1-i] && turn == i-1) - /* critical section */ flag [i] = FALSE; - Prove that it enforces mutual exclusion; include a copy of your implementa tion along with Spin output verifying it in what <p> 3) [in = (in+1)] Spin: line 16 "pan_in", Error: assertion violated #processes: 2 7: proc 1 (user) line 16 "pan_in" (state 4) 7: proc 0 (user) line 16 "pan_in" (state 4) 2 processes created A SOLUTIONS TO ASSIGNMENT 1 9 Exit-Status 0 The "fixed" program: byte in; bool lock; active <ref> [2] </ref> proctype user () - /* atomically, wait for lock to be free and grab it */ atomic - (lock == 0); lock = 1; - /* critical section */ in++; assert (in == 1); in--; /* release the lock */ lock = 0; goto L1; - Results of the successful <p> [in = (in+1)] Spin: line 26 "pan_in", Error: assertion violated #processes: 2 15: proc 1 (user) line 26 "pan_in" (state 20) 15: proc 0 (user) line 26 "pan_in" (state 20) 2 processes created Exit-Status 0 The mutex algorithm from S&G p. 143: #define TRUE 1 #define FALSE 0 bool flag <ref> [2] </ref>; bool turn; int in; active [2] proctype user () - flag [_pid] = TRUE; turn = 1-_pid; (flag [1-_pid] == FALSE || turn != 1-_pid); /* critical section */ in++; assert (in == 1); in--; B SOLUTIONS TO ASSIGNMENT 2 11 flag [_pid] = FALSE; goto L1; - Spin output: <p> "pan_in", Error: assertion violated #processes: 2 15: proc 1 (user) line 26 "pan_in" (state 20) 15: proc 0 (user) line 26 "pan_in" (state 20) 2 processes created Exit-Status 0 The mutex algorithm from S&G p. 143: #define TRUE 1 #define FALSE 0 bool flag <ref> [2] </ref>; bool turn; int in; active [2] proctype user () - flag [_pid] = TRUE; turn = 1-_pid; (flag [1-_pid] == FALSE || turn != 1-_pid); /* critical section */ in++; assert (in == 1); in--; B SOLUTIONS TO ASSIGNMENT 2 11 flag [_pid] = FALSE; goto L1; - Spin output: Spin Version 3.2.0 -- 8 April
Reference: [3] <author> Edsger W. Dijkstra. </author> <title> On the cruelty of really teaching computing science. </title> <journal> Communications of the ACM, </journal> <volume> 32(12), </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: One way to avoid misleading students about the difficulty of the task is to have them prove that their programs are correct this is the approach advocated by Dijkstra in <ref> [3] </ref>.
Reference: [4] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: To avoid the pain of proving properties of programs by hand, we use a system called Spin, which is designed to prove properties about models of concurrent programs. 3 Modeling Concurrent Systems: Spin Spin <ref> [4] </ref> allows us create a model of a concurrent system which is simple enough to prove things about, but detailed enough to map easily to a real system. Spin was designed for communication protocol analysis, but works just as well for processes communicating through shared memory. <p> Students should be introduced to Spin with one or two lectures; there is a large amount of Spin documentation in Holzmann's book <ref> [4] </ref> and at the Spin web site: http://plan9.bell-labs.com/netlib/spin/whatispin.html 5 Assignment 1: Mutual Exclusion The purpose of this assignment is to introduce you to Spin, and to programming in Promela. You will need access to a machine with Spin and XSpin version 3.2.0 or newer installed.
Reference: [5] <author> Andrew S. Tannenbaum. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: I will argue that the former is very difficult to teach well, and that it can be taught better with the help of a system that can be used to model and prove properties about concurrent programs. 2 What's Wrong with Nachos and Minix Nachos [1], Minix <ref> [5] </ref>, and XINU [2] are operating systems designed to teach operating systems. The premise is that a simplified system will contain the essential structure, without bogging students down with the irrelevant details that pervade a real OS.
References-found: 5

