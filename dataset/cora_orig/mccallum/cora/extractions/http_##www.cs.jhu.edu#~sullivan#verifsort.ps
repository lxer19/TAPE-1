URL: http://www.cs.jhu.edu/~sullivan/verifsort.ps
Refering-URL: http://www.cs.jhu.edu/~sullivan/ftdownload.html
Root-URL: http://www.cs.jhu.edu
Title: A Formally Verified Sorting Certifier  
Author: Jonathan D. Bright, Gregory F. Sullivan, Gerald M. Masson 
Date: 1999 1  
Note: IEEE TRANSACTIONS ON COMPUTERS, VOL. XX, NO. Y, MONTH  
Abstract: In this paper we describe the use of the certification-trail technique as the basis of a hybrid framework for building formally verified software systems. Our technique involves formally verifying only a part of a software system; however, the technique yields a software system which still satisfies the most important correctness properties. Substantial savings in the overhead of software verification, and also in program running time are shown to be possible in comparison to traditional methods. We apply our technique to the problem of sorting since sorting represents one of the most basic operations in computer science, and a formally verified sorting certifier should have significant applicability. The results presented in this paper represent an enhancement of the certification-trail technique relative to the detection of incorrect computational output caused by software faults. Keywords| Sorting; formal program verification; software correctness; certification trails; program result checking. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. F. Sullivan and G. M. </author> <title> Masson, "Using certification trails to achieve software fault tolerance," </title> <booktitle> in Digest of the 1990 Fault Tolerant Computing Symposium. </booktitle> <year> 1990, </year> <pages> pp. 423-431, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: XX, NO. Y, MONTH 1999 5 check that a list is the sorted version of another list. This will be accomplished by using a certification trail. Intuitively, the certification trail will consist of a permutation that when applied to the output, yields the input <ref> [1] </ref>. The certification trail will be constructed during the first phase by tagging each element of the input with its index position. Then after sorting the numbers in the input, the tags will give the desired permutation.
Reference: [2] <author> G. F. Sullivan and G. M. </author> <title> Masson, "Certification trails for data structures," </title> <booktitle> in Digest of the 1991 Fault Tolerant Computing Symposium. </booktitle> <year> 1991, </year> <pages> pp. 240-247, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [3] <author> D. S. Wilson, G. F. Sullivan, and G. M. </author> <title> Masson, "Experimental evaluation of certification trails using abstract-data-type validation," </title> <booktitle> in Proceedings of the 1992 Computer Software and Applications Conference. </booktitle> <year> 1992, </year> <pages> pp. 300-306, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [4] <author> G. F. Sullivan, D. S. Wilson, and G. M. </author> <title> Masson, "Certification trails and software design for testability," </title> <booktitle> in Proceedings of the 1993 International Test Conference. </booktitle> <year> 1993, </year> <pages> pp. 200-209, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our work, in contrast, does allow modification of the program being checked. We believe that both these approaches are quite valuable and that they are complementary, displaying different strengths and weaknesses. We now present timing data from previous work on the problem of sorting <ref> [4] </ref>. Our experiments were performed on a Sun SPARC-ELC using the CC compiler with optimization enabled. In table 1, the columns for F , F 1 , and F 2 give the running time in seconds for the particular program for the specified problem size. <p> Let F be a program that solves P , and let F 1 and F 2 be a certification-trail solution for P . By previous work <ref> [4] </ref>, the assumption that time (P 1 ) is 10% greater than time (P ), and that time (P 2 ) is 5% of time (P) is actually conservative.
Reference: [5] <author> G. F. Sullivan, D. S. Wilson, and G. M. </author> <title> Masson, "Certification of computational results," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 44, </volume> <pages> pp. 833-847, </pages> <year> 1995. </year>
Reference-contexts: This is especially true if the acceptance test is capable of detecting most if not all of the possible error types. But it is true that if an acceptance test is particularly simple it will most likely run faster than the certification-trail method. In <ref> [5] </ref> we present a more complete comparison between the certification-trail technique and other methods. In previous work, the certification-trail technique has been applied to a wide variety of problems such as sorting, convex hull, shortest path, huffman tree, line segment intersection, and many others [1][2][3][4][5].
Reference: [6] <author> B. Johnson, </author> <title> Design and Analysis of Fault Tolerant Digital Systems, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference: [7] <author> A. Avizienis, </author> <title> "The N-version approach to fault tolerant software," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 11, </volume> <pages> pp. 1491-1501, </pages> <month> December </month> <year> 1985. </year>
Reference: [8] <author> A. Avizienis and J. Kelly, </author> <title> "Fault tolerance by design diversity: Concepts and experiments," </title> <journal> Computer, </journal> <volume> vol. 17, </volume> <pages> pp. 67-80, </pages> <month> August </month> <year> 1984. </year>
Reference: [9] <author> L. Chen and A. Avizienis, </author> <title> "N-version programming: a fault tolerant approach to reliability of software operation," </title> <booktitle> in Digest of the 1978 Fault Tolerant Computing Symposium. </booktitle> <year> 1978, </year> <pages> pp. 3-9, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [10] <author> B. Randell, </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: In the following discussions, we refer to the program F 1 as the first phase program, and F 2 as either the second phase or certifier program. The certification-trail method has some similarities to the acceptance test method <ref> [10] </ref>. In the acceptance test method, after a computation has been finished and before the answer has been output, some checks are performed on the result to determine if an error has occurred. If an error is detected then various steps can be taken to remedy the situation.
Reference: [11] <author> J. D. Bright and G. F. Sullivan, </author> <title> "Checking mergeable priority queues," </title> <booktitle> in Digest of the 24th Symposium on Fault-Tolerant Computing. </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 144-153, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [12] <author> M. Blum and S. Kannan, </author> <title> "Designing programs that check their work," </title> <booktitle> in Proc. of the 1989 ACM Symp. on Theory of Computing. </booktitle> <year> 1989, </year> <pages> pp. 86-97, </pages> <publisher> ACM. </publisher>
Reference-contexts: It is also necessary to check that the output is a permutation of the input. Several elegant probabilistic methods for checking the permutation property are discussed in <ref> [12] </ref>, where the probability that an error goes undetected can be made arbitrarily small through iteration. In [13], a method for checking the permutation property which is similar to the one presented here is given. However, the work in [12] [14] and [13] uses a methodology that differs significantly from ours. <p> elegant probabilistic methods for checking the permutation property are discussed in <ref> [12] </ref>, where the probability that an error goes undetected can be made arbitrarily small through iteration. In [13], a method for checking the permutation property which is similar to the one presented here is given. However, the work in [12] [14] and [13] uses a methodology that differs significantly from ours. That methodology treats the program being checked as a black box, and hence any modification of the program is avoided. Our work, in contrast, does allow modification of the program being checked. <p> If F 2 accepts the output, then since F 2 has been proven correct, we know that it is not possible for the output to be incorrect due to software faults in either F 1 or F 2 . We note that Blum et al <ref> [12] </ref>, [14] and Rubinfeld [13] have also proposed hybrid schemes for formal verification when using program checkers. Depending upon the particular application, reporting that F 1 has made an error in place of actually producing a correct output may be sufficient.
Reference: [13] <author> R. A. Rubinfeld, </author> <title> A Mathematical Theory of Self-checking, Self-testing and Self-correcting Programs, </title> <type> Ph.D. thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1990. </year> <journal> IEEE TRANSACTIONS ON COMPUTERS, </journal> <volume> VOL. XX, NO. </volume> <pages> Y, </pages> <month> MONTH </month> <year> 1999 </year> <month> 9 </month>
Reference-contexts: It is also necessary to check that the output is a permutation of the input. Several elegant probabilistic methods for checking the permutation property are discussed in [12], where the probability that an error goes undetected can be made arbitrarily small through iteration. In <ref> [13] </ref>, a method for checking the permutation property which is similar to the one presented here is given. However, the work in [12] [14] and [13] uses a methodology that differs significantly from ours. <p> In <ref> [13] </ref>, a method for checking the permutation property which is similar to the one presented here is given. However, the work in [12] [14] and [13] uses a methodology that differs significantly from ours. That methodology treats the program being checked as a black box, and hence any modification of the program is avoided. Our work, in contrast, does allow modification of the program being checked. <p> If F 2 accepts the output, then since F 2 has been proven correct, we know that it is not possible for the output to be incorrect due to software faults in either F 1 or F 2 . We note that Blum et al [12], [14] and Rubinfeld <ref> [13] </ref> have also proposed hybrid schemes for formal verification when using program checkers. Depending upon the particular application, reporting that F 1 has made an error in place of actually producing a correct output may be sufficient. But if it is not, then more steps need to be taken. <p> Then after sorting the numbers in the input, the tags will give the desired permutation. It is easy to modify most sorting algorithms to also keep track of the tags. A similar idea for checking sorting also appears in <ref> [13] </ref>. However, since in their model they treat the sorting program as a black box which can not be modified, they are forced to encode the tags as part of the input.
Reference: [14] <author> M. Blum and H. Wasserman, </author> <title> "Reflections on the pentium division bug," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 45, no. 4, </volume> <pages> pp. 385-393, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: In [13], a method for checking the permutation property which is similar to the one presented here is given. However, the work in [12] <ref> [14] </ref> and [13] uses a methodology that differs significantly from ours. That methodology treats the program being checked as a black box, and hence any modification of the program is avoided. Our work, in contrast, does allow modification of the program being checked. <p> If F 2 accepts the output, then since F 2 has been proven correct, we know that it is not possible for the output to be incorrect due to software faults in either F 1 or F 2 . We note that Blum et al [12], <ref> [14] </ref> and Rubinfeld [13] have also proposed hybrid schemes for formal verification when using program checkers. Depending upon the particular application, reporting that F 1 has made an error in place of actually producing a correct output may be sufficient.
Reference: [15] <author> S. Purushothaman and P. A. Subrahmanyam, </author> <title> "Mechanical certification of systolic algorithms," </title> <journal> Journal of Automated Reasoning, </journal> <volume> vol. 5, </volume> <pages> pp. 67-91, </pages> <year> 1989. </year>
Reference-contexts: III. The Boyer-Moore Theorem Prover We now give a brief introduction to the Boyer-Moore Theorem Prover (B&MTP). This description is very similar to the one that appears in <ref> [15] </ref>. For more details the reader is advised to consult the books [16][17]. For a survey of the major accomplishments using the B&MTP the reader can IEEE TRANSACTIONS ON COMPUTERS, VOL. XX, NO. Y, MONTH 1999 4 consult [18]. The Boyer-Moore Logic is a quantifier-free first-order logic with equality.
Reference: [16] <author> R. S. Boyer and J. S. Moore, </author> <title> A Computational Logic, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference: [17] <author> R. S. Boyer and J. S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference: [18] <author> M. Kaufmann, </author> <title> "Response to fm91 survey of formal methods: Nqthm and pc-nqthm," </title> <type> Tech. Rep. 75, </type> <institution> Computational Logic Inc., </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: This description is very similar to the one that appears in [15]. For more details the reader is advised to consult the books [16][17]. For a survey of the major accomplishments using the B&MTP the reader can IEEE TRANSACTIONS ON COMPUTERS, VOL. XX, NO. Y, MONTH 1999 4 consult <ref> [18] </ref>. The Boyer-Moore Logic is a quantifier-free first-order logic with equality. All variables are assumed to be universally quantified. The language is closely related to pure Lisp and consists of variables and functions combined in a prefix notation.
Reference: [19] <author> J. D. </author> <title> Bright, Checking and Certifying Computational Results, </title> <type> Ph.D. thesis, </type> <institution> Johns Hopkins University, </institution> <year> 1994. </year>
Reference-contexts: We still need to give a function F 1 which if given an i, produces an o and a c such that certsort (i ; o; c) = T holds. In the appendix we provide most of the details for the soundness proof. In <ref> [19] </ref> we also show how to construct a function F 1 and prove its correctness. For now, we will only state the soundness theorem that we proved. Theorem: certsort-sort certsort (i , o, c) ! sort (i , o) V. Experimental Results In this section we discuss our experimental results.
Reference: [20] <author> J. C. Guzman and P. Hudak, </author> <title> "Single-threaded polymorphic lambda calculus," </title> <booktitle> in 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, Pennsylvania, </address> <month> June </month> <year> 1990, </year> <pages> pp. 333-343, </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [21] <author> F. Honsell, I. A. Mason, S. Smith, and C. Talcott, </author> <title> "A variable typed logic of effects," </title> <journal> Information and Computation, </journal> <volume> vol. 119, </volume> <pages> pp. 55-90, </pages> <year> 1995. </year>
Reference: [22] <author> A. V. S. Sastry, W. Clinger, and Z. Ariola, </author> <title> "Order-of-evaluation analysis for destructive updates in strict functional languages with flat aggregates," </title> <booktitle> in Conference on Functional Programming Languages and Computers, </booktitle> <year> 1993, </year> <pages> pp. 266-275. </pages>
Reference: [23] <author> C. A. R. Hoare, </author> <title> "Quicksort," </title> <journal> Computer Journal, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 10-15, </pages> <year> 1962. </year>
Reference-contexts: XX, NO. Y, MONTH 1999 7 TABLE II Execution speed comparisons for Faster-CertSort, Allegro-Sort, and C-Sort. Input Allegro C-Sort Faster % Size Sort CertSort Savings 5000 .338 .112 .0951 38.7 50000 4.06 1.54 .921 39.4 200000 18.09 7.17 3.71 39.9 68020 version of quicksort <ref> [23] </ref> was formally verified by Dr. Yuan Yu as part of his dissertation research [24]. However, this was a very difficult project: the modeling of the behavior of the 68020 alone was very hard. An experienced member of the theorem proving community might comment that our proofs are rather straightforward.

References-found: 23

