URL: http://www.win.tue.nl/~hooman/PDPVS.ps
Refering-URL: http://www.win.tue.nl/~hooman/PDPVS.html
Root-URL: http://www.win.tue.nl
Email: e-mail: wsinjh@win.tue.nl  
Title: Program Design in PVS  
Author: Jozef Hooman 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Computing Science Eindhoven University of Technology  
Abstract: Hoare triples (precondition, program, postcondition) have been incorporated in the verification system PVS. Two approaches are presented: the conventional one, with a clear distinction between syntax and semantics, and another where programs are identified with their semantics. In the last approach specifications are embedded in the semantic framework, leading to a formalism where specifications and programming constructs can be mixed freely. This framework forms the basis of a formal method for the design of distributed real-time systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Hoo94a] <author> J. Hooman. </author> <title> Compositional verification of a distributed real-time arbitration protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(2) </volume> <pages> 173-205, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction General aim of our work is the formal specification and compositional verification of distributed real-time systems. To this end, a formalism based on Hoare triples (precondition, program, postcondition) has been devised and applied to a number of examples such as a distributed real-time arbitration protocol <ref> [Hoo94a] </ref>, a chemical batch processing system [Hoo94c], and a mine pump system [Hoo96a]. These examples have been verified manually. To investigate whether the method scales up to larger systems, clearly some form of mechanical support is indispensable.
Reference: [Hoo94b] <author> J. Hooman. </author> <title> Correctness of real time systems by construction. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 19-40. </pages> <publisher> LNCS 863, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: =&gt; prog2) IMPLIES (seq (prog3,prog4) =&gt; seq (prog1,prog2)) mono_while : THEOREM (prog =&gt; prog1) IMPLIES (while (b, prog) =&gt; while (b, prog1)) END rules 4 Concluding Remarks The framework of section 3 describes the main principles behind a formal method for the design of distributed real-time systems, as described in <ref> [Hoo94b] </ref>. Compared to that paper, notation and proofs could be improved due to the use of a more powerful version of PVS. <p> For instance, it is no longer needed to define a special strategy for the verification of sequential programs without while constructs, since this can now be done directly by the (grind) command. In <ref> [Hoo94b] </ref> the framework has been used for the top-down design of a chemical batch processing example, where all design steps have been proved correct by the interactive theorem prover of PVS. Based on this paradigm, also a steam boiler control system has been designed and verified in PVS [VH96].
Reference: [Hoo94c] <author> J. Hooman. </author> <title> Extending Hoare logic to real-time. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):801-825, </volume> <year> 1994. </year>
Reference-contexts: To this end, a formalism based on Hoare triples (precondition, program, postcondition) has been devised and applied to a number of examples such as a distributed real-time arbitration protocol [Hoo94a], a chemical batch processing system <ref> [Hoo94c] </ref>, and a mine pump system [Hoo96a]. These examples have been verified manually. To investigate whether the method scales up to larger systems, clearly some form of mechanical support is indispensable. Usually there is a large number of simple verification conditions which should be discharged automatically.
Reference: [Hoo95] <author> J. Hooman. </author> <title> Verifying part of the ACCESS.bus protocol using PVS. </title> <booktitle> In Proc. 15th Conf. on the Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> LNCS 1026, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This is motivated by the fact that most errors are often due to mistakes in the requirements specification and high-level design. Related own work in this field consists of the specification and verification of a part of the ACCESS.bus protocol <ref> [Hoo95] </ref>, starting from an informal description. The translation from an informal to a formal specification was also addressed in the RPC-Memory specification problem [Hoo96b] 2 .
Reference: [Hoo96a] <author> J. Hooman. </author> <title> Assertional specification and verification. </title> <editor> In M. Joseph, editor, </editor> <title> Real-time Systems: Specification, Verification and Analysis, </title> <booktitle> chapter 5, </booktitle> <pages> pages 97-146. </pages> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: To this end, a formalism based on Hoare triples (precondition, program, postcondition) has been devised and applied to a number of examples such as a distributed real-time arbitration protocol [Hoo94a], a chemical batch processing system [Hoo94c], and a mine pump system <ref> [Hoo96a] </ref>. These examples have been verified manually. To investigate whether the method scales up to larger systems, clearly some form of mechanical support is indispensable. Usually there is a large number of simple verification conditions which should be discharged automatically.
Reference: [Hoo96b] <author> J. Hooman. </author> <title> Using PVS for an assertional verification of the RPC-memory specification problem. </title> <booktitle> In Proc. Dagstuhl-seminar of the RPC-Memory Specification Problem, to appear. </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Related own work in this field consists of the specification and verification of a part of the ACCESS.bus protocol [Hoo95], starting from an informal description. The translation from an informal to a formal specification was also addressed in the RPC-Memory specification problem <ref> [Hoo96b] </ref> 2 .
Reference: [Old85] <author> E. R. Olderog. </author> <title> Process theory: semantics, specification and verification. </title> <booktitle> In ESPRIT/LPC Advanced School on Current Trends in Concurrency, </booktitle> <pages> pages 509-519. </pages> <publisher> LNCS 194, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Section 2 shows the conventional approach, with a clear distinction between the syntax of programs and their semantics. In section 3 programs are identified with their semantics. By doing the same for specifications, a mixed framework is obtained where programming constructs and specifications are integrated (similar to e.g. <ref> [Old85] </ref>). This makes it easy to express the intermediate stages during top-down program design.
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Based on these requirements, we decided to use the verification system PVS 1 (Prototype Verification System) <ref> [ORS92, ORSvH95] </ref>. An advantage is that the basics of PVS are rather easy to learn and one can quickly start experimenting with the intended application. The PVS specification language is a higher-order typed logic, with many built-in types including booleans, integers, rationals, sequences, lists, and sets.
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference-contexts: Based on these requirements, we decided to use the verification system PVS 1 (Prototype Verification System) <ref> [ORS92, ORSvH95] </ref>. An advantage is that the basics of PVS are rather easy to learn and one can quickly start experimenting with the intended application. The PVS specification language is a higher-order typed logic, with many built-in types including booleans, integers, rationals, sequences, lists, and sets.
Reference: [Rus95] <author> John Rushby. </author> <title> Mechanizing formal methods: Opportunities and challenges. </title> <booktitle> In ZUM '95: The Z Formal Specification Notation; 9th International Conference of Z Users, </booktitle> <pages> pages 105-113. </pages> <publisher> LNCS 967, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Whereas the current paper, and parts of the examples mentioned above, deal with program verification, the designers of PVS emphasize the use of this tool during the early phases of system design, when the requirements are formulated and formalized <ref> [Rus95] </ref>. This is motivated by the fact that most errors are often due to mistakes in the requirements specification and high-level design. Related own work in this field consists of the specification and verification of a part of the ACCESS.bus protocol [Hoo95], starting from an informal description.
Reference: [VH96] <author> J. Vitt and J. Hooman. </author> <title> Assertional specification and verification using PVS of the steam boiler control system. In Steam-Boiler Case Study Book, to appear. </title> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1996. </year> <title> This article was processed using the L A T E X macro package with LLNCS style 2 Recent work is available on http://www.win.tue.nl/win/cs/tt/hooman/JH.html </title>
Reference-contexts: In [Hoo94b] the framework has been used for the top-down design of a chemical batch processing example, where all design steps have been proved correct by the interactive theorem prover of PVS. Based on this paradigm, also a steam boiler control system has been designed and verified in PVS <ref> [VH96] </ref>. Whereas the current paper, and parts of the examples mentioned above, deal with program verification, the designers of PVS emphasize the use of this tool during the early phases of system design, when the requirements are formulated and formalized [Rus95].
References-found: 11

