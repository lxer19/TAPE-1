URL: http://www.cs.wvu.edu/~atkinson/pubs/thesis-submitted.ps.gz
Refering-URL: http://www.cs.wvu.edu/~atkinson/publications.html
Root-URL: http://www.cs.wvu.edu
Title: Formal Engineering of Software Library Systems  
Author: Steven Ross Atkinson BInfTech(Honours) 
Degree: A thesis submitted to The School of Information Technology The University of Queensland for the degree of DOCTOR OF PHILOSOPHY  
Date: October, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abadi. </author> <title> Baby Modula-3 and a Theory of Objects. </title> <type> Technical Report 95, </type> <institution> Digital Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: DATA REQUIREMENTS were introduced in order to gather related data and process elements of software systems, and were called abstract data types. The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components <ref> [1] </ref>.
Reference: [2] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <type> Technical Report 66, </type> <institution> Digital Systems Research Center, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport <ref> [2] </ref> develop results for language-independent specification composition. Butler and Duke [16] and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z [30, 32]. Software generation systems synthesise software systems by composing components from component libraries.
Reference: [3] <author> S. Atkinson. </author> <title> A Formal Model for Integrated Retrieval from Software Libraries. </title> <booktitle> In Technology of Object-Oriented Languages and Systems: TOOLS 21, </booktitle> <pages> pages 153-167. </pages> <institution> Monash University Printing Services, Caulfield, </institution> <address> Victoria, Australia, </address> <year> 1996. </year>
Reference-contexts: The quality of retrieval schemes used can alleviate both problems, by searching collections and finding components closely resembling the desired component. However, it is still difficult for an automated retrieval scheme to reach that goal <ref> [3, 85] </ref>. Retrieval of components will be discussed in Chapters 6 and 7. Problems 1 and 2 are problems which can be addressed in a relatively direct manner.
Reference: [4] <author> S. Atkinson and R. Duke. </author> <title> Behavioural retrieval from class libraries. </title> <journal> Australian Computer Science Communications, </journal> <volume> 17(1) </volume> <pages> 13-20, </pages> <month> January </month> <year> 1995. </year> <note> An extended version appears as Software Verification Research Centre Technical Report 94-28, </note> <year> 1994. </year>
Reference-contexts: The ordering is defined so that behaviours having only small differences in the number of responses (determinism) and the position and number of rejected messages (failures) are more closely related than others. The precise definition of the ordering is given in <ref> [4] </ref>. It is modelled here as a (partially ordered) relationship between behaviours called ordering: BhvrOrdering == Behaviour $ Behaviour ; ordering : BhvrOrdering The behavioural ordering is used in conjunction with the behaviour from the query to determine which behaviours are closest to the query's behaviour.
Reference: [5] <author> M. Banahan, Declan Brady, and Mark Doran. </author> <title> The C book : featuring the ANSI C standard. Instruction set series. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England and Reading, Mass. USA, </address> <year> 1991. </year>
Reference-contexts: The chapter concludes with a summary of the issues raised by the formal model. 8.1 Introduction The process of computer language standardisation aims to promote multi-platform software development. This has usually been achieved through the standardisation of library facilities offered across many platforms <ref> [5] </ref>. The underlying principle of substitutability behind a standard library is that any program which adheres to the standard library facilities can be readily compiled and executed on any platform which supports these facilities.
Reference: [6] <author> M. J. Bates. </author> <title> Where should the person stop and the information search interface start? Information Processing and Management, </title> <booktitle> 26(5) </booktitle> <pages> 575-591, </pages> <year> 1990. </year>
Reference-contexts: Information Retrieval The information retrieval approach to software libraries is to regard software components as textual documents. This is done in order to take advantage of the work investigating the well-known problem of document retrieval. Bates <ref> [6] </ref> argues that the objective of retrieval systems should not be to strive for near-automation of the search process but rather to allow humans access to some of the hitherto internal strategic search processes used during retrieval.
Reference: [7] <author> D. Batory and B. J. Geraci. </author> <title> Validating Component Compositions in Software System Generators. </title> <booktitle> In Sitaraman [103], </booktitle> <pages> pages 72-81. </pages> <month> 235 9.3. </month> <title> RELATED AND FUTURE WORK </title>
Reference-contexts: Butler and Duke [16] and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z [30, 32]. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. Batory and Geraci <ref> [7] </ref> discuss the problem of validating the generated compositions, to ensure their semantic correctness. Biggerstaff [11] expresses the importance of factoring out common library components for subsequent composition, alleviating the problem of exponential component explosion.
Reference: [8] <author> D. Batory and S. O'Malley. </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components. </title> <journal> ACM TOSEM, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [16] and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z [30, 32]. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley <ref> [8] </ref> developed software system generators, called GenVoca generators. Batory and Geraci [7] discuss the problem of validating the generated compositions, to ensure their semantic correctness. Biggerstaff [11] expresses the importance of factoring out common library components for subsequent composition, alleviating the problem of exponential component explosion.
Reference: [9] <author> K. Beck. </author> <title> Smalltalk: Best Practice Patterns. </title> <publisher> Prentice-Hall, </publisher> <year> 1997. </year>
Reference-contexts: Additionally, an application domain can be abstracted into a collection of patterns called a framework [61]. The notion of patterns extends across levels of abstraction from coding patterns <ref> [9] </ref> to meta-patterns [93]. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code [15].
Reference: [10] <author> N.J. Belkin and W. B. Croft. </author> <title> Information filtering and retrieval: Two sides of the same coin? Commun. </title> <journal> ACM, </journal> <volume> 35(12) </volume> <pages> 29-38, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: In the context of software libraries, this becomes especially relevant because the artefacts retrieved are potentially complex interacting software systems, the construction of which demands some measure of library user control. Belkin and Croft <ref> [10] </ref> present process models for information retrieval and filtering, concluding that at an abstract level, filtering and retrieval are identifiable tasks. Filtering software components from software libraries using metrics has already been treated as a viable method for retrieval from software libraries [91].
Reference: [11] <author> T.J. Biggerstaff. </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse. </title> <editor> In W.B. Frakes, editor, </editor> <booktitle> Third International Conference on Software Reuse: Advances in Software Reusability, </booktitle> <pages> pages 102-109, </pages> <address> Los Alamitos, CA, Novem-ber 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. Batory and Geraci [7] discuss the problem of validating the generated compositions, to ensure their semantic correctness. Biggerstaff <ref> [11] </ref> expresses the importance of factoring out common library components for subsequent composition, alleviating the problem of exponential component explosion.
Reference: [12] <author> T.J. Biggerstaff and A.J. Perlis. </author> <title> Software Reusability: Concepts and Models, vol I. Frontier Series. </title> <publisher> ACM (Addison Wesley), </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Regular attempts to summarise the status of software reuse research have been made. These summaries and some important issues raised in each are mentioned below: * Biggerstaff and Perlis <ref> [12] </ref> collected assorted articles from the literature, and parti tioned reuse approaches into two sub-fields: - Composition-based systems: reuse is enabled via composition of software components. <p> existing approaches to the component retrieval problem into a formally specified object-oriented framework, providing a model enabling comparison and description of integrated retrieval schemes. 6.1 Introduction The problem of retrieval from component libraries has long been considered to be the central technical issue surrounding the task of software library construction <ref> [12, 77] </ref>. However, the recent movement towards organisational and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [96] and controlled-vocabulary [41] retrieval schemes to be applied with some success.
Reference: [13] <author> G. Booch. </author> <title> Software Components with Ada Structures. Tools, and Subsystems, </title> <year> 1987. </year>
Reference-contexts: Lins [71] defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch <ref> [13] </ref>. Uhl and Schmid [113] define a general catalogue of reusable abstract data types (focusing on container classes) using Ada as the component definition language. 15 2.1.
Reference: [14] <author> J. Borstler. </author> <title> Feature-Oriented Classification for Software Reuse. </title> <booktitle> In Proc. Seventh International Conference of Software Engineering and Knowledge Engineering (SEKE'95), </booktitle> <year> 1995. </year>
Reference-contexts: The retrieval schemes proposed in the literature can be classified into categories, based upon the technique used to represent components during the search process: Classification-based schemes: Various indexing techniques, including keyword comparison, facet [97], frame [21], descriptor [81], lexical affinity [75] and feature-based <ref> [14] </ref> techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the component. Structural schemes: Type signature [122] and specification matching [39, 58, 99, 123] techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. <p> Faceted retrieval schemes are one of many retrieval schemes using vocabulary based classification of software components. Examples of similar classification schemes include retrieval using the Reboot project's faceted scheme [102], frames [21], features <ref> [14] </ref>, class descriptors [81] and lexical affinity [75]. These retrieval schemes could also be modelled under the common framework presented in this section. 6.2.7 Assembled Formal Declarations This section presents a summary of the general abstract framework for retrieval schemes.
Reference: [15] <author> F.J. Budinsky, M.A. Finnie, J.M. Vlissides, and P.S. Yu. </author> <title> Automatic Code Generation from Design Patterns. </title> <journal> IBM Systems Journal, </journal> <volume> 35(2), </volume> <year> 1996. </year>
Reference-contexts: The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns [93]. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code <ref> [15] </ref>. London and Milstead [73] present component specifications of two Smalltalk components (realistic sets and dictionaries) in the Z specification language [108] in order to evaluate some of the problems with using formal specification languages to specify components.
Reference: [16] <author> S. Butler and R. Duke. </author> <title> Defining Composition Operators for Object Interaction. </title> <type> Technical Report 96-12, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, </institution> <year> 1996. </year> <note> Accepted in Journal of Object-oriented Systems (OOS). </note>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke <ref> [16] </ref> and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z [30, 32]. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. <p> ConstructedOperation GeneralComponent Label == Identifier left ; right : ComposedOperation components = hleft ; right i references = ? A number of different collaboration styles are defined in Object-Z <ref> [16] </ref>. The Transfer operation currently uses the sequential style of collaboration between operations (denoted by symbol o 9 ). The three other styles of collaboration are conjunctive (symbol ^), parallel (symbol k) and angelic choice (symbol []). <p> BEHAVIOURAL RETRIEVAL Incorporating Component Composition Hall searched a library of function components, and used functional application of one component on another as the sole composition operator. Butler and Duke <ref> [16] </ref> define several composition operators for object-based systems. We apply their framework to give an extension of the behavioural retrieval scheme above.
Reference: [17] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and poly-morphism. ACM Comput. Surv., </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year> <title> 236 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: It has been recognised that replacement d ? should be compatible in some way with removed component c?, to provide guarantees for clients of operation c? who subsequently use d ?. Generally, two forms of guarantees have been investigated: statically checkable guarantees such as signature [122] or type <ref> [17, 90] </ref> compatibility; and dynamic guarantees of behavioural compatibility as mentioned in Section 2.2.2. The operation RemoveOperation has been constructed by identifying all components possibly affected, and propagating change to them in form of operations DetachReference and DetachComponent .
Reference: [18] <author> E. Casais. </author> <title> Managing class evolution in object-oriented systems. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: These interface issues are important to ensure cooperation of components when adapted from a retrieved library component. Additionally the library itself will need to evolve over time, and do so in a way which minimally affects client code. Casais <ref> [18] </ref> discusses in detail, and provides algorithms for, small and large scale object-oriented library evolution. <p> The relation is used in the definition of the sample removal policies below. Sample Removal Policy 1: Class Removal Suppose a class component cl is to be removed from a library l . Class removal policies have been implemented and presented in the object-oriented database literature. Casais <ref> [18] </ref> investigated the class removal policies of three object-oriented database systems (Gemstone, ORION and O 2 ). Suppose we adopt the class removal policy of the O 2 99 5.4.
Reference: [19] <author> P. Coad. </author> <title> Object-oriented patterns. </title> <journal> Commun. ACM, </journal> <volume> 35(9) </volume> <pages> 152-159, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This implies that ideas from all stages of development comprise knowledge that is reusable. In particular, the reuse of common patterns which appear during software design <ref> [19, 42] </ref> 21 2.2. DATA REQUIREMENTS has been an area of intensive research. Design patterns capture architectural and environmental constraints on participating components and connections between the components.
Reference: [20] <author> M. Sitaraman (coordinator). </author> <title> Special feature: Component-based software using RESOLVE. </title> <journal> Software Engineering Notes, </journal> <volume> 19(4) </volume> <pages> 21-67, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE <ref> [20] </ref>, and Design Patterns [43]) have been proposed. These disciplines prescribe recommended styles of expression within some component description language. The choice of any single component description language for software libraries is not clear given the continuing evolution of component description languages. However, this should 18 2.2.
Reference: [21] <author> M. del Rosario Girardi and B. Ibrahim. </author> <title> A similarity measure for retrieving software artifacts. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering (SEKE'94), </booktitle> <pages> pages 478-485. </pages> <address> Jurmala, Latvia, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The retrieval schemes proposed in the literature can be classified into categories, based upon the technique used to represent components during the search process: Classification-based schemes: Various indexing techniques, including keyword comparison, facet [97], frame <ref> [21] </ref>, descriptor [81], lexical affinity [75] and feature-based [14] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the component. <p> Faceted retrieval schemes are one of many retrieval schemes using vocabulary based classification of software components. Examples of similar classification schemes include retrieval using the Reboot project's faceted scheme [102], frames <ref> [21] </ref>, features [14], class descriptors [81] and lexical affinity [75]. These retrieval schemes could also be modelled under the common framework presented in this section. 6.2.7 Assembled Formal Declarations This section presents a summary of the general abstract framework for retrieval schemes.
Reference: [22] <author> J. Dick and A. Faivre. </author> <title> Automating the Generating and Sequencing of Test Cases From Model-Based Specifications. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, </editor> <booktitle> FME '93: Industrial Strength Formal Methods, 5th International Symposium of Formal Methods Europe, volume 670 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 268-284. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: This conversion function remains undefined, as extraction of behavioural responses from static models is the subject of ongoing research. In particular, in the specification-based testing community have defined methods for defining test cases based on semi-automated derivation of state machines <ref> [22] </ref> and test graphs which characterise state machines [55]. In general, we want to show that compatibility of two classes implies substitutability of those classes. This would provide the behavioural guarantee desired.
Reference: [23] <author> J. S. Dong. </author> <title> Living with Free Type and Class Union. </title> <booktitle> In Proc. Asia-Pacific Software Engineering Conference (APSEC '95), </booktitle> <pages> pages 304-312. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: The collection of components (as shown in Figure 4.5) is modelled as a class union of the Object-Z components: Component == System [ Cluster [ Class [ State [ Declaration [ Operation [ Predicate [ Expression [ NullComponent The class union operator, defined in Dong <ref> [23] </ref>, views each Object-Z class as a set of identified objects (i.e. those objects conforming to the class specification). The class union operator, when applied to a pair of classes, forms a set of object identities by 71 4.5. <p> A library will contain a number of components and a number of (possibly integrated) retrieval schemes, of various kinds. The collection of retrieval schemes for a given library can be described using the Object-Z class union construct <ref> [23] </ref>: Scheme == FacetedScheme [V i ; :::] [ SignatureScheme [V j ; :::] [ SpecificationScheme [V k ; :::] [ BehaviouralScheme [V l ; :::] [ ::: 156 6.6.
Reference: [24] <author> J. S. Dong, G. Rose, and R. Duke. </author> <title> The Role of Secondary Attributes in Formal Object Modelling. </title> <editor> In A. Stoyenko, editor, </editor> <booktitle> The First IEEE International Conference on Engineering Complex Computer Systems (ICECCS'95), </booktitle> <pages> pages 31-38, </pages> <address> Florida, November 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The effect of insertion upon the relation is determined implicitly from the definition of the relation without the need for explicit declaration of the effects. The role of derived attributes in formal object modelling was considered in detail by Dong <ref> [24] </ref>. 5.8.3 Conclusions The operational sufficiency of the data model presented in Chapter 4 has been established, subject to further consideration of the retrieval operation in Chapters 6 and 7. Clearly many other operations and annotations could be defined for a library of components. <p> AN ABSTRACT RETRIEVAL FRAMEWORK The searcher is not modelled in detail within the framework; however, it is convenient to represent the searcher as part of the definition of the search process by inclusion of the secondary attribute <ref> [24] </ref>: searcher : Searcher into the RetrievalSchemeName class, where the type Searcher is assumed to be part of the surrounding environment of the framework. Every search proceeds with the searcher issuing a query and the retrieval scheme performing the search. <p> Because this information depends on and can be derived from the kernel environment using component relationships, these two collections are modelled as secondary attributes <ref> [24] </ref>. In the next section it is shown that feature declarations record which class declaration they originated from (i.e. the class declaration in which they are immediately defined).
Reference: [25] <author> J.S. Dong and R. Duke. </author> <title> The Geometry of Object Containment. </title> <booktitle> Object Oriented Systems, </booktitle> <volume> 2 </volume> <pages> 41-63, </pages> <year> 1995. </year> <title> 237 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: The implicit attribute self holds the identity of the current object, and the implicit containment attribute contain represents the closure of the containment relation, which in this case denotes the set of all subcomponents. The concept of containment for Object-Z class declarations is defined by Dong <ref> [25] </ref>. While it is the static form of components that is of immediate concern, some dynamic aspects of the core schema are included here for future use. Some operations are made available to affect component enclosure.
Reference: [26] <author> J.S. Dong and R. Duke. </author> <title> Using Object-Z to Specify Object-Oriented Programming Languages. </title> <type> Technical Report 96-02, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <year> 1996. </year>
Reference-contexts: The use of invariants in Object-Z to implicitly enforce integrity constraints has also been exploited in other works. Invariant conditions were used to capture database constraints in Leadbetter [68] and to capture static semantic constraints of programming languages in Dong <ref> [26] </ref>. The use of derived variables to capture and describe annotations has also been presented. The advantage gained is the automatic re-calculation of derived variables when the library is modified. For example, insertion of an operation into a class component may change the outgoing reference relation of the class.
Reference: [27] <author> R. Duke. </author> <title> Do Formal Object-Oriented Methods have a Future? . In Technology of Object-Oriented Languages and Systems: </title> <booktitle> TOOLS 15, </booktitle> <pages> pages 273-280. </pages> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The problem exists where a number of separate libraries which each contain similar software artefacts are organised using different abstractions. This problem was subsequently highlighted by Duke <ref> [27] </ref> where it is argued that such differences make libraries difficult to use, by imposing a burden of understanding upon the library user. There it is claimed that the use of a library should be governed by formal rules to expose and maintain an underlying design rationale.
Reference: [28] <author> R. Duke, C. Bailes, and G. Smith. </author> <title> Modelling reactive objects. </title> <type> Technical Report 93-1, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: One component may be a subtype [72] of another, be behaviourally compatible [106] with an 19 2.2. DATA REQUIREMENTS other, or be substitutable <ref> [28] </ref> with another. These notions all differ slightly in their definition. The subtype relationship in Lisov and Wing [72] (the Liskov Substitutability Principle) is concerned with being able to operate a component of a subtype as a component of its supertype. <p> The behavioural compatibility relationships as defined in Smith [106] use a formal model of object behaviour to define operational and observational notions of compatibility for passive and active objects respectively. The substitutability relationships between objects defined in Duke <ref> [28] </ref> model objects as state transition systems and use a lattice over such systems to determine object compatibility. It is important to consider all such relationships, because the organisation of a software library can benefit from and may reflect the knowledge embodied in many component relationships.
Reference: [29] <author> R. Duke, C. Bailes, and G. Smith. </author> <title> A Blocking Model for Reactive Objects. </title> <journal> Formal Aspects of Computing, </journal> <volume> 8 </volume> <pages> 347-368, </pages> <year> 1996. </year>
Reference-contexts: Following this idea, users may specify desired behaviour with a formal specification, from which behaviour can be inferred <ref> [29, 106] </ref>. The aim is to enable the methodology to be applied to a library of classes described by formal specifications.
Reference: [30] <author> R. Duke, P. King, G. Rose, and G. Smith. </author> <title> The Object-Z specification language. </title> <editor> In T. Korson, V. Vaishnavi, and B. Meyer, editors, </editor> <booktitle> Technology of Object-Oriented Languages and Systems: TOOLS 5, </booktitle> <pages> pages 465-483. </pages> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [16] and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z <ref> [30, 32] </ref>. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. Batory and Geraci [7] discuss the problem of validating the generated compositions, to ensure their semantic correctness. <p> Additionally, the encoding of the compatibility rules of ELS in a formal specification language has the advantage of enabling formal verification of the adequacy of the rules. 189 8.2. MODELLING EIFFEL DECLARATIONS The next sections present a model of the ELS standard in the formal specification language Object-Z <ref> [30] </ref>, which has been advocated for the specification of standards [32]. The focus of the model will be on specifying the library compatibility rules; hence the specific detail about the features each class offers will not be discussed.
Reference: [31] <author> R. Duke and G. Rose. </author> <title> Formal Object-Oriented Specification and Design Using Object-Z. </title> <type> Internal draft, </type> <institution> Software Verification Research Centre., </institution> <year> 1995. </year>
Reference: [32] <author> R. Duke, G. Rose, and G. Smith. Object-Z: </author> <title> a Specification Language Advocated for the Description of Standards. </title> <type> Technical Report 94-45, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <year> 1994. </year> <title> Appears in a special issue of Computer Standards and Interfaces on Formal Methods and Standards, </title> <month> September </month> <year> 1995. </year>
Reference-contexts: A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [16] and Griffiths [48] provide semantics for the operation composition operators of the formal specification language Object-Z <ref> [30, 32] </ref>. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. Batory and Geraci [7] discuss the problem of validating the generated compositions, to ensure their semantic correctness. <p> MODELLING EIFFEL DECLARATIONS The next sections present a model of the ELS standard in the formal specification language Object-Z [30], which has been advocated for the specification of standards <ref> [32] </ref>. The focus of the model will be on specifying the library compatibility rules; hence the specific detail about the features each class offers will not be discussed.
Reference: [33] <author> S.H. Edwards. </author> <title> Common Interface Models for Reusable Software. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 3(2) </volume> <pages> 193-206, </pages> <year> 1993. </year>
Reference-contexts: Retrieved systems may have to be adapted via refactoring to ensure efficiency or readability. Jeng and Cheng [60] show how using order-sorted unification of specifications can yield a set of substitutions guiding the adaptation of retrieved components. Edwards <ref> [33] </ref> notes the problems of mismatched component interfaces: when one component mistakenly presumes another offers a particular set of features. Thatte [111] discusses 26 2.4. SUMMARY the synthesis of interface stubs given two components with differing interfaces.
Reference: [34] <author> S.H. Edwards. </author> <title> Inheritance: One mechanism, many conflicting uses. </title> <booktitle> In Proc. of the Sixth Annual Workshop on Software Reuse, 1993. 238 9.3. RELATED AND FUTURE WORK </booktitle>
Reference-contexts: Wolczko [120] revisits the notion of delegation to note that a component's interface should not only include the message it can receive but also the messages it sends in response. Edwards <ref> [34] </ref> discusses the problems inheritance causes when defining reusable components. The relevance of the use of inheritance to software libraries is important since it is a commonly used relationship between components.
Reference: [35] <author> D.A. Eichmann. </author> <title> A Hybrid Approach to Software Repository Retrieval: Blending Faceted Classification and Type Signatures. </title> <booktitle> In Proc. International Conference on Software Engineering and Knowledge Engineering (SEKE'91), </booktitle> <pages> pages 236-240, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Structural schemes: Type signature [122] and specification matching [39, 58, 99, 123] techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in <ref> [35] </ref>. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques [49, 84, 92] seek to find relevant components by comparing input and output spaces of components. A formal theory for behavioural retrieval schemes is presented in Chapter 7. <p> This provides a model enabling rigorous comparison and description of integrated retrieval schemes. An integrated retrieval scheme is a scheme that comprises several retrieval schemes in its definition. For example, an integrated scheme comprising faceted and signature matching schemes was conceived by Eichmann <ref> [35] </ref>; Fischer et. al [39] also proposed an integrated scheme, pipelining signature and specification matching techniques. In Section 2.3.1, retrieval schemes proposed in the literature were classified into three categories, namely classification based schemes, structural schemes and behavioural schemes.
Reference: [36] <author> D.A. Eichmann. </author> <title> Supporting Multiple Domains in a Single Reuse Repository. </title> <booktitle> In Proc. Fourth International Conference of Software Engineering and Knowledge Engineering (SEKE'92), </booktitle> <pages> pages 164-169, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This has enabled specialist techniques such as domain-modelling [96] and controlled-vocabulary [41] retrieval schemes to be applied with some success. Nevertheless there remains the desire to develop software retrieval strategies suited for large-scale, 119 6.1. INTRODUCTION domain-spanning libraries <ref> [36, 52] </ref>. It is assumed that components of these libraries take the form of object-oriented class declarations as in Chapter 4.
Reference: [37] <author> R. Elmasri and S.B. Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> Benjamin Cum-mings, </publisher> <year> 1989. </year>
Reference-contexts: To view software libraries as information systems necessitates consideration of transactions on software libraries. As for any information system, the major concerns are the detection, assessment and repair of integrity constraint violations to avoid update anomalies. Elmasri and Navathe <ref> [37] </ref> claim "no data model is capable of representing all types of constraints that may occur" within a universe of discourse. Taking this observation, we distinguish between the kinds of integrity constraints that can be represented in the data model (direct constraints), and those that cannot (indirect constraints). 86 5.2.
Reference: [38] <author> J.W. Moore et. al. </author> <title> Reuse Library Interoperability Group: Purpose and Progress. </title> <booktitle> In Proceedings of TRI-Ada'93. </booktitle> <publisher> ACM Press, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Many programmers maintain a personal library of code which may be reused in later projects. However, existing software libraries vary in scale from such personally maintained collections of code, through comprehensive domain-specific collections, to a number of very large domain-spanning libraries <ref> [38, 107] </ref>. There are several existing software library systems used in this chapter to highlight the cognitive design deficiencies. They are based on the languages Eiffel [81], C++[109], Smalltalk [46], and Java [69].
Reference: [39] <author> B. Fischer, M. Kievernagel, and W. Struckmann. VCR: </author> <title> A VDM-based software component retrieval tool. </title> <type> Technical Report 94-08, </type> <institution> Institut fur Programmiersprachen und Informationssysteme, Technische Universitat Braunschweig, </institution> <address> Gaustasse 17, D-38092 Braunschweig, Germany, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Structural schemes: Type signature [122] and specification matching <ref> [39, 58, 99, 123] </ref> techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. <p> Querying by class and method name can be performed in many development environments. All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [39, 97, 123] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [91] suggests another strategy for large libraries, called "affinity browsing". <p> This provides a model enabling rigorous comparison and description of integrated retrieval schemes. An integrated retrieval scheme is a scheme that comprises several retrieval schemes in its definition. For example, an integrated scheme comprising faceted and signature matching schemes was conceived by Eichmann [35]; Fischer et. al <ref> [39] </ref> also proposed an integrated scheme, pipelining signature and specification matching techniques. In Section 2.3.1, retrieval schemes proposed in the literature were classified into three categories, namely classification based schemes, structural schemes and behavioural schemes. <p> Some implementations of specification matching schemes appear in the literature. Rollins and Wing [99] use higher order unification in a Prolog dialect called -Prolog. Fischer et. al <ref> [39] </ref> present a specification matching implementation using specifications written in the VDM [64] specification language. Mili and Mittermeir [84] present a system implemented using a theorem prover called Otter to discharge proofs generated using relations 145 6.5. BEHAVIOURAL RETRIEVAL between component specifications and implementations. <p> Note that vocabulary sets TSym and FSym denote term and formula symbols from some logic, as required by specification schemes. SigSpecScheme [Signature; TSym; FSym] SignatureScheme [Signature] [SigSearch=Search; :::] SpecificationScheme [TSym; FSym] [SpecSearch=Search; :::] SequentialSearch b= SigSearch o 9 SpecSearch ConjoinedSearch b= SigSearch [sig!=cs!] ^ SpecSearch [spec!=cs!] Fischer et. al <ref> [39] </ref> developed such a integrated scheme with SequentialSearch capability using signature and specification matching schemes. They state that "the successive filtering of components....allows free combination of different retrieval schemes".
Reference: [40] <author> G. Fischer, S. Henninger, and D. Redmiles. </author> <title> Intertwining Query Construction and Relevance Evaluation. </title> <booktitle> In Proc. CHI '91: Human Factors in Computing Systems, </booktitle> <pages> pages 55-61, </pages> <address> New York, 1991. </address> <publisher> ACM Press. </publisher>
Reference: [41] <author> W.B. Frakes and P.B. Gandel. </author> <title> Representing reusable software. </title> <journal> Information and Software Technology, </journal> <volume> 32(10), </volume> <year> 1990. </year> <month> 32(10). </month>
Reference-contexts: However, the recent movement towards organisational and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [96] and controlled-vocabulary <ref> [41] </ref> retrieval schemes to be applied with some success. Nevertheless there remains the desire to develop software retrieval strategies suited for large-scale, 119 6.1. INTRODUCTION domain-spanning libraries [36, 52]. It is assumed that components of these libraries take the form of object-oriented class declarations as in Chapter 4.
Reference: [42] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <editor> In Oscar Nierstrasz, editor, </editor> <booktitle> European Conference on Object-Oriented Programming, </booktitle> <pages> pages 406-431, </pages> <address> Kaiserlauten, Germany, </address> <month> July </month> <year> 1993. </year> <title> Springer-Verlag. 239 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: This implies that ideas from all stages of development comprise knowledge that is reusable. In particular, the reuse of common patterns which appear during software design <ref> [19, 42] </ref> 21 2.2. DATA REQUIREMENTS has been an area of intensive research. Design patterns capture architectural and environmental constraints on participating components and connections between the components. <p> These applications serve as vehicles for idiomatic familiarisation, and often expose the library user to ways of constructing useful collaborations in ways intended by the library developer. Often 42 3.2. COMPONENT REPRESENTATION such collaborative frameworks are also documented in reference material provided with the software library. Design patterns <ref> [42] </ref> can be viewed as generic extractions of common, useful collaborative structures of components. If such additional structure is provided with libraries, clearly "comment and type signature" interfaces alone are not adequate for effective use of a library.
Reference: [43] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE [20], and Design Patterns <ref> [43] </ref>) have been proposed. These disciplines prescribe recommended styles of expression within some component description language. The choice of any single component description language for software libraries is not clear given the continuing evolution of component description languages. However, this should 18 2.2. <p> The storage of design patterns in a software library will therefore be beneficial to software engineers, by providing components which have been found to be practically useful. In general, a design pattern has four essential elements <ref> [43] </ref>: a pattern name, a problem 231 9.3. RELATED AND FUTURE WORK context, a solution comprising components, their relationships and collaboration, and any consequences application of the pattern may have. Typically, the pattern problem is informally explained using natural language.
Reference: [44] <author> Simon Gibbs. </author> <title> Querying large class collections. Object management, </title> <institution> Centre Uni-versitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: This section provides a short overview of the software library retrieval problem and the main approaches taken in the literature so far. The operation of retrieval will be discussed in more detail in Chapters 6 and 7. Gibbs <ref> [44] </ref> discusses the problem of querying and retrieving from large collections of components.
Reference: [45] <author> Simon Gibbs, Dennis Tsichritzis, Eduardo Casais, Oscar Nierstrasz, and Xavier Pintado. </author> <title> Class management for software communities. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 90-103, </pages> <month> September </month> <year> 1990. </year>
Reference: [46] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: the language. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: There are several existing software library systems used in this chapter to highlight the cognitive design deficiencies. They are based on the languages Eiffel [81], C++[109], Smalltalk <ref> [46] </ref>, and Java [69]. The existing libraries which have been chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction. <p> The Eiffel Base library presents a list of standard categories [82, p104] into which all operations in the library are classified. For example, "access" operations are used to obtain elements from a structure, and "measurement" operations are queries pertaining to the size of a structure. The Smalltalk library <ref> [46] </ref> also utilises categories into which methods and classes are classified.
Reference: [47] <author> T. Grechenig and S. Bi*. </author> <title> Introducing a software reuse culture in practice. </title> <booktitle> In SEI SE Education "Conference", </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse. The conclusion is that the current trends towards domain analysis [96] and development of reuse process models to integrate reuse into standard lifecycles <ref> [47] </ref> may help solve the reuse problem. * Mili et. al.[85] provides a discussion on issues and research directions which touches upon costing and measuring reuse, reuse-oriented software engineering process models, developing reusable assets, and developing with reusable assets (dealing with retrieval, composition, and adaptation of components). 1.2 The Role of
Reference: [48] <author> A. Griffiths. </author> <title> An Extended Semantic Foundation for Object-Z. </title> <type> Technical Report 95-39, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, </institution> <year> 1995. </year>
Reference-contexts: In effect, composition of components can be regarded as composition of their specifications. A number of attempts to formalise the composition operators of specifications have been made. Abadi and Lamport [2] develop results for language-independent specification composition. Butler and Duke [16] and Griffiths <ref> [48] </ref> provide semantics for the operation composition operators of the formal specification language Object-Z [30, 32]. Software generation systems synthesise software systems by composing components from component libraries. Batory and O'Malley [8] developed software system generators, called GenVoca generators. <p> Weide and Hollingsworth [119] argue that insertion of a component should en 25 2.3. OPERATIONAL REQUIREMENTS sure its local certifiability. Griffiths <ref> [48] </ref> formally distinguishes between strictly modular properties of a component and properties which must be ensured within the context of a particular system.
Reference: [49] <author> R. J. Hall. </author> <title> Generalized behavior-based retrieval. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 371-380, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: DATA REQUIREMENTS The fundamental difficulty when considering this problem is how to decompose the requirements in such a way as to yield known component specifications. It is not always the case that such a decomposition is possible. Hall <ref> [49] </ref> reverses the problem by attempting to search the space of all possible component compositions until one satisfying the requirements is found. <p> OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [49, 84, 92] </ref> seek to find relevant components by comparing input and output spaces of components. A formal theory for behavioural retrieval schemes is presented in Chapter 7. In addition to software-specific retrieval proposals, the field of information retrieval offers some useful results when considering retrieval from software libraries. <p> In that case, the retrieval scheme could not have found a component with a behaviour closer to that desired. A different style of behaviour-based retrieval has been proposed by Hall <ref> [49] </ref>. The major difference is that the behaviours of functional compositions of components are also searched, allowing small programs consisting of composed components to be selected. <p> However, it is the dynamic behaviour of objects that is of the most concern when building applications <ref> [49, 92] </ref>. It is this behavioural view of retrieval that is discussed. In Section 7.2 a class is modelled in terms of the way objects of that class respond to sequences of messages. In Section 7.3 a partial order is constructed to compare the behaviour of different classes. <p> Secondly, a notion of failure was included in the behavioural model, and the idea that failures can be removed was incorporated into the underlying partial order between behaviours. Thirdly, a prescription for behavioural retrieval involving the join and meet lattice operations was given. 7.6.2 Implementation Concerns Hall <ref> [49] </ref> presents and discusses implementation issues of a library of functions; these were presented in Section 6.5.5. There are number of practical considerations when considering the implementation of the object-based methodology of this chapter.
Reference: [50] <author> W. Harrison, H. Ossher, R.B. Smith, and D. Ungar. </author> <booktitle> Subjectivity in Object-Oriented Systems: Workshop Summary. Addendum to OOPSLA 1994., </booktitle> <year> 1994. </year>
Reference-contexts: There are no guarantees that useful results will be found. The results may be too specific or general, unfit for the searcher's intended purpose or irrelevant entirely. Subjectivity <ref> [50] </ref> and the resulting abstraction and vocabulary mismatches further reduce the likelihood of finding useful components. Even when relevant components are found, it is often not clear what their expected uses are. This lack of documentation can leave software engineers prone to contextual mis-use of the component.
Reference: [51] <author> W.H. Harrison and H. Ossher. </author> <title> Subject-Oriented Programming (A Critique of Pure Objects). </title> <booktitle> In Proc. 8th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'93), </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [65]. The choice of any object-oriented component description language for libraries may still be premature. Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming <ref> [51, 89] </ref> all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE [20], and Design Patterns [43]) have been proposed. These disciplines prescribe recommended styles of expression within some component description language.
Reference: [52] <author> R. Helm and Y.S. Maarek. </author> <title> Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries. </title> <booktitle> In Proc. 7th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'91), </booktitle> <pages> pages 47-61, </pages> <year> 1991. </year> <title> 240 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: Contributors in the field of software retrieval who have utilised some aspects of information retrieval theory are Helm and Maarek <ref> [52] </ref> who attempt to integrate semantically poor and rich retrieval methods, and Maarek et. al.[75] where document indexing techniques from information retrieval were used to organise software components into related clusters. 2.3.2 Insertion and Removal There is not much literature directly discussing procedures for insertion into software libraries. <p> This has enabled specialist techniques such as domain-modelling [96] and controlled-vocabulary [41] retrieval schemes to be applied with some success. Nevertheless there remains the desire to develop software retrieval strategies suited for large-scale, 119 6.1. INTRODUCTION domain-spanning libraries <ref> [36, 52] </ref>. It is assumed that components of these libraries take the form of object-oriented class declarations as in Chapter 4.
Reference: [53] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying behavioural compositions in object-oriented systems. </title> <booktitle> In Proceedings OOP-SLA/ECOOP '90, </booktitle> <pages> pages 169-180, </pages> <month> October </month> <year> 1990. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 25, number 10. </volume>
Reference: [54] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: COMPONENT INSERTION is maintained. The notions of quality for functional descriptions of the real world and means for evaluating them are the subject of continuing research into software engineering notations (e.g. UML [98] (object-oriented notation), VDM [64] (formal notation), CSP <ref> [54] </ref> (concurrency notation)). 5.3.2 Inserting Object-Z Components In this section, the insertion of components into a library of Object-Z components is considered. In particular, we discuss the insertion of an operation into an existing class component. Insertion at other levels of granularity share similar concerns.
Reference: [55] <author> D.M. </author> <title> Hoffman and P.A. Strooper. The Testgraph Methodology: Automated Testing of Collection Classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 8(7) </volume> <pages> 35-41, </pages> <month> November-December </month> <year> 1995. </year>
Reference-contexts: This conversion function remains undefined, as extraction of behavioural responses from static models is the subject of ongoing research. In particular, in the specification-based testing community have defined methods for defining test cases based on semi-automated derivation of state machines [22] and test graphs which characterise state machines <ref> [55] </ref>. In general, we want to show that compatibility of two classes implies substitutability of those classes. This would provide the behavioural guarantee desired.
Reference: [56] <author> D. Jackson and M. Jackson. </author> <title> Problem Decomposition for Reuse. </title> <type> Technical Report CMU-CS-95-108, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: This means that in order for an operation on a component to be successful, both "views" of a component must be maintained so as to satisfy the invariant relating them. Methods for such specification of separate viewpoints and their subsequent merging have been proposed for the Z specification language <ref> [56] </ref> and for object-oriented hierarchies [88]. Adoption of viewpoint specification techniques may simplify the library development and component annotation processes. 234
Reference: [57] <author> I. Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: However, in order to make use of these appliances, we learn a series of button presses to attain the goal of cooking or recording particular items. Such a series of actions, called a recipe (sometimes called a scenario or a use-case <ref> [57] </ref>), denotes the intended or conventional use of a component. Furthermore, one or more recipes may be associated with each component, since the manuals for many microwaves and VCRs often include a collection of recipes for different tasks, each recipe being documented as a series of button presses.
Reference: [58] <author> J. Jeng and B. H. C. Cheng. </author> <title> Using analogy to determine program modifications based on specification changes. </title> <booktitle> In Proc. of IEEE 5th Int'l Conf. on Tools with Artificial Intelligence, </booktitle> <pages> pages 113-116, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Structural schemes: Type signature [122] and specification matching <ref> [39, 58, 99, 123] </ref> techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability.
Reference: [59] <author> J. Jeng and B. H. C. Cheng. </author> <title> Using Formal Methods to Construct a Software Component Library. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 717 </volume> <pages> 397-417, </pages> <month> September </month> <year> 1993. </year> <note> (Proc. of Fourth European Software Engineering Conference), longer version in Techreport MSU-CPS-92-11. </note>
Reference-contexts: The clustering of the libraries mentioned above is presumably undertaken by library designers. However, there have been attempts at automatically clustering component descriptions using lexical metrics derived from code comments [75], and using analysis of ranked order-sorted specification formulae <ref> [59] </ref>. There is no single way of clustering components which is universally useful. Many different criteria could be used in different circumstances (for example, alphabetical by class name or using the inheritance relationship). The criteria chosen depends on the needs of the library searcher.
Reference: [60] <author> J. Jeng and B. H. C. Cheng. </author> <title> A formal approach to reusing more general components. </title> <booktitle> In IEEE 9th Knowledge-Based Software Engineering Conference, </booktitle> <address> Monterey, California, </address> <month> September </month> <year> 1994. </year> <title> 241 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: To refactor a system means to change its internal structure without changing its externally visible behaviour. A simple refactoring is to move an object attribute from a subclass to a superclass. Retrieved systems may have to be adapted via refactoring to ensure efficiency or readability. Jeng and Cheng <ref> [60] </ref> show how using order-sorted unification of specifications can yield a set of substitutions guiding the adaptation of retrieved components. Edwards [33] notes the problems of mismatched component interfaces: when one component mistakenly presumes another offers a particular set of features. Thatte [111] discusses 26 2.4. <p> Mili and Mittermeir [84] present a system implemented using a theorem prover called Otter to discharge proofs generated using relations 145 6.5. BEHAVIOURAL RETRIEVAL between component specifications and implementations. Jeng and Cheng <ref> [60] </ref> show how using order-sorted unification of specifications can yield a set of substitutions guiding the adaptation of returned components. 6.5 Behavioural Retrieval This section presents a formal model for behavioural retrieval according to the framework given in Section 6.2.
Reference: [61] <author> R. E. Johnson. </author> <title> Documenting frameworks using patterns. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, </booktitle> <pages> pages 63-76, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Such patterns can be used to replay software developments using a catalogue of standard patterns [62], lessening the overheads of communication between software engineers. Additionally, an application domain can be abstracted into a collection of patterns called a framework <ref> [61] </ref>. The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns [93]. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code [15].
Reference: [62] <author> R.E. Johnson and V.F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: DATA REQUIREMENTS has been an area of intensive research. Design patterns capture architectural and environmental constraints on participating components and connections between the components. Such patterns can be used to replay software developments using a catalogue of standard patterns <ref> [62] </ref>, lessening the overheads of communication between software engineers. Additionally, an application domain can be abstracted into a collection of patterns called a framework [61]. The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns [93].
Reference: [63] <author> Wendy Johnston. </author> <title> A type checker for Object-Z. </title> <type> Technical Report 96-24, </type> <institution> Software Verification Research Centre, Department of Computer Science, The University of Queensland, St. Lucia, QLD 4072, Australia, </institution> <month> July </month> <year> 1996. </year> <note> Available from ftp://ftp.cs.uq.edu.au/pub/SVRC/techreports/. </note>
Reference-contexts: Of course, it is desirable that components in the library are well-formed and well-typed. However, the constraints expressed throughout this section are not sufficient for ensuring meaningful Object-Z declarations. Detailed structural and type constraints for Object-Z have been implemented in a type-checking tool developed at the University of Queensland <ref> [63] </ref>. 4.5.2 Cluster Components A cluster refers to a collection of components which are grouped according to some criteria. The third cognitive deficiency of existing libraries, stated in Section 3.3.1, was in part to impede access to components through subjective clustering of components. <p> Foremost, the specification and development procedures should be pragmatically applied to construct a software library implementation. Work in this area has started, with the development of a parser, type checker and browser for Object-Z specifications called 232 9.3. RELATED AND FUTURE WORK Wizard <ref> [63] </ref>. However, Wizard was developed in the absence of the general component model, rendering incorporation of that model difficult. Moreover, the approach taken in this thesis was to specify a software library before undertaking an implementation.
Reference: [64] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: COMPONENT INSERTION is maintained. The notions of quality for functional descriptions of the real world and means for evaluating them are the subject of continuing research into software engineering notations (e.g. UML [98] (object-oriented notation), VDM <ref> [64] </ref> (formal notation), CSP [54] (concurrency notation)). 5.3.2 Inserting Object-Z Components In this section, the insertion of components into a library of Object-Z components is considered. In particular, we discuss the insertion of an operation into an existing class component. Insertion at other levels of granularity share similar concerns. <p> Integrity constraints for specification languages are motivated by the quality of the semantics of submitted components. More sophisticated means to assess the semantics of specification components may include checks to detect whether a submitted component is fully-abstract <ref> [64] </ref>, and not implementation or performance biased [104]. However, automated means for such detection and provision of appropriate feedback are not yet existent. Acceptance The operation to insert an accepted operation component into a class can be modelled by augmenting the Class component definition in Section 4.5.3. <p> Some implementations of specification matching schemes appear in the literature. Rollins and Wing [99] use higher order unification in a Prolog dialect called -Prolog. Fischer et. al [39] present a specification matching implementation using specifications written in the VDM <ref> [64] </ref> specification language. Mili and Mittermeir [84] present a system implemented using a theorem prover called Otter to discharge proofs generated using relations 145 6.5. BEHAVIOURAL RETRIEVAL between component specifications and implementations.
Reference: [65] <author> G. Kiczales. </author> <title> Towards a New Model of Abstraction in Software Engineering. </title> <booktitle> In Proceedings of the IMSA'92 Workshop on Reflection and Meta-level Architectures, </booktitle> <year> 1992. </year>
Reference-contexts: Weide and Hollingsworth [119] argue that properties of components should be locally certifiable to allow their reuse in larger systems. It is claimed that no language paradigm enforces this notion. It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations <ref> [65] </ref>. The choice of any object-oriented component description language for libraries may still be premature. Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings.
Reference: [66] <author> T. Korson and J.D. McGregor. </author> <title> Technical criteria for the specification and evaluation of object-oriented libraries. </title> <journal> Software Engineering Journal, </journal> <pages> pages 85-94, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Such criteria are useful for comparison of libraries, and are also useful as a guide to the development of library requirements. Korson and McGregor <ref> [66] </ref> discuss the evaluation of object-oriented class libraries. They identify * four kinds of library users: the library architecture reuser, the library class reuser, the library class adapter and the source code reuser; * ten desirable attributes of a library: wide domain coverage, consistency, easy-to 13 2.1.
Reference: [67] <author> K.C. Lano, J.C. Bicarregui, and S.J. Goldsack. </author> <title> Formalizing Design Patterns. In Northern Formal Method Workshop. </title> <publisher> Spinger Verlag EWICS, </publisher> <year> 1996. </year>
Reference-contexts: Additionally, an application domain can be abstracted into a collection of patterns called a framework [61]. The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns [93]. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation <ref> [67] </ref> and use in automatically generating code [15]. London and Milstead [73] present component specifications of two Smalltalk components (realistic sets and dictionaries) in the Z specification language [108] in order to evaluate some of the problems with using formal specification languages to specify components.
Reference: [68] <author> D. Leadbetter. </author> <title> An integrated approach to IS modeling. </title> <booktitle> In Proc. Second Asia-Pacific Software Engineering Conference (APSEC '95). </booktitle> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: The use of invariants in Object-Z to implicitly enforce integrity constraints has also been exploited in other works. Invariant conditions were used to capture database constraints in Leadbetter <ref> [68] </ref> and to capture static semantic constraints of programming languages in Dong [26]. The use of derived variables to capture and describe annotations has also been presented. The advantage gained is the automatic re-calculation of derived variables when the library is modified.
Reference: [69] <author> L. Lemay, C.L. Perkins, and M. Morrison. </author> <title> Teach Yourself Java in 21 Days. </title> <publisher> Sams.net Publishing, </publisher> <year> 1996. </year> <title> 242 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [65]. The choice of any object-oriented component description language for libraries may still be premature. Current areas of research into interface-oriented languages (Java <ref> [69] </ref>), prototypical languages (SELF [114]), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE [20], and Design Patterns [43]) have been proposed. <p> There are several existing software library systems used in this chapter to highlight the cognitive design deficiencies. They are based on the languages Eiffel [81], C++[109], Smalltalk [46], and Java <ref> [69] </ref>. The existing libraries which have been chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction.
Reference: [70] <author> K. J. Lieberherr and I. Holland. </author> <title> Assuring good style for object-oriented programs. </title> <journal> IEEE Software, </journal> <pages> pages 38-48, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: As with natural languages, it is possible to design a well-formed and well-typed component which lacks a sense of style. The codifying of preferred style as direct constraints on the data model has been considered in the literature. For example, Lieberherr and Holland <ref> [70] </ref> present style guidelines for minimising (or in strict form banning) the dependency of an operation O upon classes which are not the type of operation parameters and not the type of state variables of the class enclosing O .
Reference: [71] <author> C. Lins. </author> <title> The Modula-2 Software Component Library. The Modula-2 Software Component Library Series, Vol. I. </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin, Heidelberg, </address> <year> 1988. </year>
Reference-contexts: Library Tools : Tools for retrieval of existing classes and integration of new classes into the library should be available. 2.1.4 Library Design Principles A number of attempts have been made to specify software library design principles by creating component libraries using three languages: Modula-2, Ada and Eiffel. Lins <ref> [71] </ref> defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch [13]. Uhl and Schmid [113] define a general catalogue of reusable abstract data types (focusing on container classes) using Ada as the component definition language. 15 2.1.
Reference: [72] <author> B. Liskov and J.M. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP '93, </booktitle> <pages> pages 118-141. </pages> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: In general, there may be many relationships between two software components, any of which may be used as the basis for browsing and retrieval from a software library. One component may be a subtype <ref> [72] </ref> of another, be behaviourally compatible [106] with an 19 2.2. DATA REQUIREMENTS other, or be substitutable [28] with another. These notions all differ slightly in their definition. The subtype relationship in Lisov and Wing [72] (the Liskov Substitutability Principle) is concerned with being able to operate a component of a <p> One component may be a subtype <ref> [72] </ref> of another, be behaviourally compatible [106] with an 19 2.2. DATA REQUIREMENTS other, or be substitutable [28] with another. These notions all differ slightly in their definition. The subtype relationship in Lisov and Wing [72] (the Liskov Substitutability Principle) is concerned with being able to operate a component of a subtype as a component of its supertype.
Reference: [73] <author> R. L. London and K. R. Milsted. </author> <title> Specifying Reusable Components Using Z: Realistic Sets and Dictionaries. </title> <journal> ACM SIGSOFT Software Eng. Notes, </journal> <volume> 14(3) </volume> <pages> 120-127, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns [93]. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code [15]. London and Milstead <ref> [73] </ref> present component specifications of two Smalltalk components (realistic sets and dictionaries) in the Z specification language [108] in order to evaluate some of the problems with using formal specification languages to specify components.
Reference: [74] <author> V. B. Lortz and K. G. Shin. </author> <title> Combining contracts and exemplar-based programming for class hiding and construction. </title> <booktitle> Proc. 9th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'94), </booktitle> <pages> pages 453-467, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: A problem they identified was that it was not clear whether one should specify in a library the abstract properties of the components or to specify their implementations. Clearly delineating the level of abstraction of a specification is important for determining its use in a library. Lortz and Shin <ref> [74] </ref> implement a dynamic object requestor using contracts. As part of their presentation they describe a process of using abstract meta-classes in a library with implementation variants as subclasses.
Reference: [75] <author> Y.S. Maarek, D.M. Berry, and G.E. Kaiser. </author> <title> An information retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(8) </volume> <pages> 800-813, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The retrieval schemes proposed in the literature can be classified into categories, based upon the technique used to represent components during the search process: Classification-based schemes: Various indexing techniques, including keyword comparison, facet [97], frame [21], descriptor [81], lexical affinity <ref> [75] </ref> and feature-based [14] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the component. Structural schemes: Type signature [122] and specification matching [39, 58, 99, 123] techniques seek to find relevant components based upon elements of the structure 23 2.3. <p> The clustering of the libraries mentioned above is presumably undertaken by library designers. However, there have been attempts at automatically clustering component descriptions using lexical metrics derived from code comments <ref> [75] </ref>, and using analysis of ranked order-sorted specification formulae [59]. There is no single way of clustering components which is universally useful. Many different criteria could be used in different circumstances (for example, alphabetical by class name or using the inheritance relationship). <p> Faceted retrieval schemes are one of many retrieval schemes using vocabulary based classification of software components. Examples of similar classification schemes include retrieval using the Reboot project's faceted scheme [102], frames [21], features [14], class descriptors [81] and lexical affinity <ref> [75] </ref>. These retrieval schemes could also be modelled under the common framework presented in this section. 6.2.7 Assembled Formal Declarations This section presents a summary of the general abstract framework for retrieval schemes. Retrieval schemes are developed by following the template of class RetrievalSchemeName 133 6.2.
Reference: [76] <author> J. McGregor and D. Sykes. </author> <title> Object Oriented Software Development: Engineering Software for Reuse. </title> <publisher> Van Nostrund Reinhold, </publisher> <year> 1992. </year>
Reference-contexts: The idea is that software development is abstracted into a set of parameterised rules; when the actual parameters are input, a generated system is output. * McGregor and Sykes <ref> [76] </ref> emphasise the use of class libraries as a major step towards solving the problems of reuse. However they also highlight through their choice of examples one of the major problems with class libraries | different libraries covering the same domain are organised differently. 2 1.2. <p> The final management task discussed is that of supporting the evolution of classes in the library. Class evolution describes the process of re-developing and amending classes to fix some perceived deficiencies. Different approaches to the problem of evolution are discussed in Section 2.3.3. 2.1.2 Library Abstractions McGregor and Sykes <ref> [76] </ref> discuss the problem of library abstraction mismatches. The problem exists where a number of separate libraries which each contain similar software artefacts are organised using different abstractions.
Reference: [77] <author> M. D. McIlroy. </author> <title> Mass produced software components. </title> <booktitle> Proceedings of the 1969 NATO Conference on Software Engineeering, </booktitle> <year> 1969. </year>
Reference-contexts: Resistance to such change is pragmatically a real impediment to the introduction of reuse solutions. As a research field, software reuse has been steadily growing since the mid-eighties. Wegner [115] repeated and extended the idea of the manufacture of software components expressed by McIlroy <ref> [77] </ref>. If software is to be treated as a capital investment, then techniques are required to ensure its quality and reusability, thus ensuring that the initial development cost is amortised over the many uses of the software. Regular attempts to summarise the status of software reuse research have been made. <p> Useful software libraries should record ideas and outcomes generated during software developments in such a way as to enable other software engineers to understand them. In turn this can significantly ease the process of software engineering, by providing a source of verified software artefacts <ref> [77, 115] </ref>. 1.3 Analysis Software library systems are not yet common or mature phenomena, and as such are themselves candidates for the application of requirements analysis, formal specification, design and other software engineering activities. <p> existing approaches to the component retrieval problem into a formally specified object-oriented framework, providing a model enabling comparison and description of integrated retrieval schemes. 6.1 Introduction The problem of retrieval from component libraries has long been considered to be the central technical issue surrounding the task of software library construction <ref> [12, 77] </ref>. However, the recent movement towards organisational and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [96] and controlled-vocabulary [41] retrieval schemes to be applied with some success.
Reference: [78] <author> B. Meyer. </author> <title> The Software Knowledge Base. </title> <booktitle> In Proc. of the Eighth International Conference on Software Engineering, </booktitle> <pages> pages 158-165, </pages> <year> 1985. </year>
Reference: [79] <author> B. Meyer. </author> <title> Reusability: The case for object-oriented design. </title> <journal> IEEE Software, </journal> <volume> 4(2) </volume> <pages> 50-64, </pages> <month> March </month> <year> 1987. </year> <title> 243 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: SOFTWARE REUSE development. However, progress towards an industrial-strength reuse methodology has been hindered by organisational and technical issues. It is suggested that solutions to the technical problems of software reuse are of primary concern <ref> [79] </ref>. Nevertheless, adoption of a reuse culture requires organisational change. Resistance to such change is pragmatically a real impediment to the introduction of reuse solutions. As a research field, software reuse has been steadily growing since the mid-eighties. <p> DATA REQUIREMENTS were introduced in order to gather related data and process elements of software systems, and were called abstract data types. The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components [1]. Meyer <ref> [79, 80] </ref> argues the case for object-oriented software component descriptions by pointing out that taking a bottom-up compositional view of software construction, working with structured collections of abstract data types, and having language constructs such as multiple inheritance and deferred features all contribute to seamless development of reusable software systems.
Reference: [80] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: DATA REQUIREMENTS were introduced in order to gather related data and process elements of software systems, and were called abstract data types. The abstract data types came to be regarded as object definitions, and Modula-3 incorporated the notion of object components [1]. Meyer <ref> [79, 80] </ref> argues the case for object-oriented software component descriptions by pointing out that taking a bottom-up compositional view of software construction, working with structured collections of abstract data types, and having language constructs such as multiple inheritance and deferred features all contribute to seamless development of reusable software systems.
Reference: [81] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall Object-Oriented Series. Prentice Hall (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hertforshire HP24RG, </address> <year> 1992. </year>
Reference-contexts: Uhl and Schmid [113] define a general catalogue of reusable abstract data types (focusing on container classes) using Ada as the component definition language. 15 2.1. GENERAL SOFTWARE LIBRARY REQUIREMENTS Meyer developed the Eiffel language <ref> [81] </ref> and the Eiffel base libraries [82], attempting to form a natural taxonomy analogous to the classification of the animal kingdom. <p> The Eiffel programming language developed by Meyer <ref> [81] </ref> was designed to demonstrate and utilise the advantages that object-oriented software construction offered. The argument was that reuse can only truly be achieved with a solid technical emphasis on component description languages. <p> The retrieval schemes proposed in the literature can be classified into categories, based upon the technique used to represent components during the search process: Classification-based schemes: Various indexing techniques, including keyword comparison, facet [97], frame [21], descriptor <ref> [81] </ref>, lexical affinity [75] and feature-based [14] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the component. <p> There are several existing software library systems used in this chapter to highlight the cognitive design deficiencies. They are based on the languages Eiffel <ref> [81] </ref>, C++[109], Smalltalk [46], and Java [69]. The existing libraries which have been chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction. <p> For example, Lieberherr and Holland [70] present style guidelines for minimising (or in strict form banning) the dependency of an operation O upon classes which are not the type of operation parameters and not the type of state variables of the class enclosing O . The Eiffel language <ref> [81] </ref> has an appendix on style guidelines, discussing naming, classification, commenting, text layout, and typeface conventions. <p> Faceted retrieval schemes are one of many retrieval schemes using vocabulary based classification of software components. Examples of similar classification schemes include retrieval using the Reboot project's faceted scheme [102], frames [21], features [14], class descriptors <ref> [81] </ref> and lexical affinity [75]. These retrieval schemes could also be modelled under the common framework presented in this section. 6.2.7 Assembled Formal Declarations This section presents a summary of the general abstract framework for retrieval schemes. Retrieval schemes are developed by following the template of class RetrievalSchemeName 133 6.2. <p> the reference "Eiffel: The Language"<ref> [81] </ref> and the Eiffel Library Standard [83]. It should be noted that a number of Eiffel declaration components mentioned in this section will be left undefined because their definitions can be considered auxiliary to the theme of the chapter; they are described in Appendix H of [81]. These are the components Message (all possible messages displayed to an Eiffel user), IndexDecl (all possible descriptions used to index a class), GenFormalDecl (all possible generic formal parameter declarations), Comment (all possible class and feature comments) and Boolean expression (all possible boolean expressions). <p> A flatshort declaration is defined as the text that results from computing the flatshort form (see p106 of <ref> [81] </ref>) of a class. Class and flatshort declarations have certain properties in common, such as indexing clauses, whether a class is deferred or expanded, and their name. <p> Also note that the type relation conform used below refers to type conformance between Eiffel classes. In general, the type-conformance relation requires a complex definition (see page 219 of <ref> [81] </ref>). For the purposes of this chapter, it is assumed that a class B conforms to a class A if B inherits A. <p> THE RULES FOR KERNEL COMPATIBILITY * i 2 (b) is not a valid call, because B does not conform to C . This violates the signature conformance validity constraint (labelled VNCS on p219 of <ref> [81] </ref>) even though Rule 2.4.1.8 says the difference between the argument types is permitted. Here we have a case of a program written with respect to the standard declarations which behaves differently in distinct certified library implementations, due to the existence of rule 2.4.1.8.
Reference: [82] <author> B. Meyer. </author> <title> Reusable Software The Base object-oriented component libraries. </title> <publisher> Pren-tice Hall, </publisher> <address> ISE, </address> <institution> Santa Barbara and SOL, Paris, </institution> <year> 1994. </year>
Reference-contexts: Uhl and Schmid [113] define a general catalogue of reusable abstract data types (focusing on container classes) using Ada as the component definition language. 15 2.1. GENERAL SOFTWARE LIBRARY REQUIREMENTS Meyer developed the Eiffel language [81] and the Eiffel base libraries <ref> [82] </ref>, attempting to form a natural taxonomy analogous to the classification of the animal kingdom. <p> Operations with similar behavioural effects are named similarly. Each of the libraries above make some attempt to have uniform interfaces; in particular the Eiffel libraries <ref> [82] </ref> have undergone extensive renamings with this goal in mind. * Functional completeness: a component is said to be functionally complete if all operations that could be useful for a user of a component are available in that component. <p> Criteria for assessing the quality of component interfaces is an area of continuing research. Two criteria, the observability and controllability proferred by operations with respect to the state of the component are discussed in [118]. Of the libraries mentioned above, Meyer <ref> [82] </ref> provides the most comprehensive attempt at rationalising the design of software component libraries. Of the many principles he outlines, the most important he claims is the consistency principle: 16 2.2. <p> The principles of library design outlined in Section 2.1.4 may also serve as certification checks when insertion takes place. In particular, Meyer's library design principles <ref> [82] </ref> have all been applied as certification checks in the Eiffel Base libraries. A policy for removal of outdated, infrequently used and superseded components is also required. <p> For example, consider the style rule "minimise the number of arguments to operations". A discipline for achieving this end (expressed by Meyer <ref> [82] </ref> for the Eiffel libraries) extols the virtue of only using true operands as operation parameters, rather than including additional options as parameters. This can be regarded as a design principle. 87 5.2. INTEGRITY CONSTRAINTS Consider an operation named Draw to specify drawing a rectangle to a display. <p> To annotate those operation components enclosed by other operation components (as a result of constructed or distributed operations) serves no purpose because such operations cannot be used outside the context of an enclosing operation. The Eiffel Base library presents a list of standard categories <ref> [82, p104] </ref> into which all operations in the library are classified. For example, "access" operations are used to obtain elements from a structure, and "measurement" operations are queries pertaining to the size of a structure. The Smalltalk library [46] also utilises categories into which methods and classes are classified. <p> This may be called the query conformance problem, and can be alleviated through the use of standard operation names and interfaces, for example <ref> [82, p104] </ref>. There is also the question of how users are to construct the expected behaviour input b.
Reference: [83] <author> B. Meyer. </author> <title> The Eiffel Library Standard (Vintage 95). </title> <type> Technical Report TR-EI-48/KL, </type> <institution> Interactive Software Engineering, Inc., </institution> <month> June </month> <year> 1995. </year> <note> Version 8. Available from ftp://ftp.eiffel.com/pub/nice/library. </note>
Reference-contexts: Clearly no single library's regime of classification and clustering can be agreeable to all under all circumstances. In this case, the focus should be on flexibility, consistency and intuitiveness within (rather than between) libraries. A standard developed for the Eiffel kernel library, called the Eiffel Library Standard <ref> [83] </ref>, is formally examined in Chapter 8. The formal rules that comprise the standard can verifiably help alleviate the effects of abstraction mismatch across Eiffel libraries from different vendors. The rules allow a software engineer to directly reuse and rely upon common knowledge as defined in the standard. 49 3.4. <p> Firstly, we formally model the rules for library compatibility proposed in the Eiffel Library Standard <ref> [83] </ref>. The formal modelling process identifies a number of simplifications, ambiguities and a serious deficiency in the definition of the standard. <p> The Eiffel declarations will be modelled using the GeneralComponent model of the core library schema, as defined in Section 4.4. The Eiffel declarations are based upon the definitions provided in the reference "Eiffel: The Language"[81] and the Eiffel Library Standard <ref> [83] </ref>. It should be noted that a number of Eiffel declaration components mentioned in this section will be left undefined because their definitions can be considered auxiliary to the theme of the chapter; they are described in Appendix H of [81]. <p> These cross references are used in the description of the components, and also serve as a mechanism for traceability of the formal to the informal conditions of the ELS document. 190 8.2. MODELLING EIFFEL DECLARATIONS 8.2.1 A Kernel Model The ELS document <ref> [83] </ref> defines the names of the required kernel classes, as well as the required ancestry links between those classes. The required names are modelled below as a set of Identifier (i.e. character strings) called Kernel names. <p> a general Eiffel class declaration is: indexing f Field: value g ? [ deferred j expanded ] class NAME [ X, Y ] [ obsolete "This class is superseded by ..." ] f FEATURE g ? 1 Recall that these reference numbers refer to the rules as defined in ELS <ref> [83] </ref>. 193 8.2. MODELLING EIFFEL DECLARATIONS [ invariant ASSERTION ] end class NAME Formally, the properties of this declaration syntax are modelled by the class GeneralClass.
Reference: [84] <author> A. Mili, R. Mili, and R. Mittermeir. </author> <title> Storing and retrieving software components: A refinement based system. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 91-100. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [49, 84, 92] </ref> seek to find relevant components by comparing input and output spaces of components. A formal theory for behavioural retrieval schemes is presented in Chapter 7. In addition to software-specific retrieval proposals, the field of information retrieval offers some useful results when considering retrieval from software libraries. <p> Some implementations of specification matching schemes appear in the literature. Rollins and Wing [99] use higher order unification in a Prolog dialect called -Prolog. Fischer et. al [39] present a specification matching implementation using specifications written in the VDM [64] specification language. Mili and Mittermeir <ref> [84] </ref> present a system implemented using a theorem prover called Otter to discharge proofs generated using relations 145 6.5. BEHAVIOURAL RETRIEVAL between component specifications and implementations. <p> The idea of using a lattice structure as the basis of behavioural retrieval has been suggested by Mili <ref> [84] </ref>. In their retrieval system the nodes of the lattice were relations, serving as surrogates for specifications.
Reference: [85] <author> H. Mili, F. Mili, and A. Mili. </author> <title> Reusing Software: Issues and Research Directions. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 21(6) </volume> <pages> 528-561, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The quality of retrieval schemes used can alleviate both problems, by searching collections and finding components closely resembling the desired component. However, it is still difficult for an automated retrieval scheme to reach that goal <ref> [3, 85] </ref>. Retrieval of components will be discussed in Chapters 6 and 7. Problems 1 and 2 are problems which can be addressed in a relatively direct manner.
Reference: [86] <editor> Deux O. and et al. </editor> <title> The O2 system. </title> <journal> Communications of the ACM,, </journal> <volume> 32(4), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Class removal policies have been implemented and presented in the object-oriented database literature. Casais [18] investigated the class removal policies of three object-oriented database systems (Gemstone, ORION and O 2 ). Suppose we adopt the class removal policy of the O 2 99 5.4. COMPONENT REMOVAL database system <ref> [86] </ref>, which forbids class removal when it would result in dangling references in other definitions or when the removal leaves the inheritance graph disconnected.
Reference: [87] <author> W.F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Techniques and policies for insertion and removal are discussed in Chapter 5. 2.3.3 Adaptation and Evolution The adaptation operation modifies a component in order to either allow it to successfully cooperate with other components or to change its internal behaviour. Opdyke <ref> [87] </ref> introduces the concept of refactoring object-oriented systems. To refactor a system means to change its internal structure without changing its externally visible behaviour. A simple refactoring is to move an object attribute from a subclass to a superclass.
Reference: [88] <author> H. Ossher and W. Harrison. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In Proc. 7th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'92), </booktitle> <pages> pages 25-40, </pages> <year> 1992. </year>
Reference-contexts: Methods for such specification of separate viewpoints and their subsequent merging have been proposed for the Z specification language [56] and for object-oriented hierarchies <ref> [88] </ref>. Adoption of viewpoint specification techniques may simplify the library development and component annotation processes. 234
Reference: [89] <author> H. Ossher, M. Kaplan, W.H. Harrison, A. Katz, and V. Kruska. </author> <title> Subject-Oriented Composition Rules. </title> <booktitle> In Proc. 10th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'95), </booktitle> <pages> pages 235-250, </pages> <year> 1995. </year> <title> 244 9.3. RELATED AND FUTURE WORK </title>
Reference-contexts: It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [65]. The choice of any object-oriented component description language for libraries may still be premature. Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming <ref> [51, 89] </ref> all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE [20], and Design Patterns [43]) have been proposed. These disciplines prescribe recommended styles of expression within some component description language.
Reference: [90] <author> J. Palsberg and M.I. Schwartzbach, </author> <title> editors. Types, Inheritance and Assignments. </title> <booktitle> Proc. European Conf. on Object-Oriented Programming (ECOOP'91), </booktitle> <year> 1991. </year>
Reference-contexts: It has been recognised that replacement d ? should be compatible in some way with removed component c?, to provide guarantees for clients of operation c? who subsequently use d ?. Generally, two forms of guarantees have been investigated: statically checkable guarantees such as signature [122] or type <ref> [17, 90] </ref> compatibility; and dynamic guarantees of behavioural compatibility as mentioned in Section 2.2.2. The operation RemoveOperation has been constructed by identifying all components possibly affected, and propagating change to them in form of operations DetachReference and DetachComponent .
Reference: [91] <author> Xavier Pintado. </author> <title> Selection and exploration in an object-oriented environment: The affinity browser. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Belkin and Croft [10] present process models for information retrieval and filtering, concluding that at an abstract level, filtering and retrieval are identifiable tasks. Filtering software components from software libraries using metrics has already been treated as a viable method for retrieval from software libraries <ref> [91] </ref>. Fischer et. al.[40] developed prototype tools called CodeFinder and Explainer. Using these tools they examined the requirements of software libraries using information retrieval analysis techniques. CodeFinder suggested that it was important for software libraries 24 2.3. <p> Many other search and retrieval strategies have been proposed [39, 97, 123]. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado <ref> [91] </ref> suggests another strategy for large libraries, called "affinity browsing". Under this scheme, metrics and information derived from components are used to cluster components for browsing purposes. The libraries above address Problem 1 by segregating collections of components, using techniques of sub-libraries, categories or grouped hierarchies. <p> Until recently, most effort in solving the retrieval problem has gone into software classification, with emphasis upon domain-specific aspects such as the signature and specifications of operations [122, 123], and the determination of static metrics that can be used when searching and retrieving <ref> [91, 96] </ref>. However, it is the dynamic behaviour of objects that is of the most concern when building applications [49, 92]. It is this behavioural view of retrieval that is discussed.
Reference: [92] <author> A. Podgurski and L. Pierce. </author> <title> Behaviour sampling: A technique for automated retrieval of reusable components. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 349-360, </pages> <year> 1992. </year>
Reference-contexts: OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [49, 84, 92] </ref> seek to find relevant components by comparing input and output spaces of components. A formal theory for behavioural retrieval schemes is presented in Chapter 7. In addition to software-specific retrieval proposals, the field of information retrieval offers some useful results when considering retrieval from software libraries. <p> A more complete investigation of an object-based behavioural retrieval technique appears in Chapter 7; this section serves to introduce the basic elements of behavioural techniques in general. 6.5.1 Scheme Name and Vocabulary The behavioural retrieval scheme described here is based upon the ideas proposed by Podgurski and Peirce <ref> [92] </ref>. Behaviour-based retrieval schemes are inspired by the notion of exploiting the executability of software components to classify them. Sending a program to a component yields dynamic responses which are collected. This collection is called the behaviour of the component. <p> In Chapter 7, the ordering forms a lattice, and lattice operations are used to achieve selection. The selection scheme of <ref> [92] </ref> was based on variance between actual and expected outputs. <p> However, it is the dynamic behaviour of objects that is of the most concern when building applications <ref> [49, 92] </ref>. It is this behavioural view of retrieval that is discussed. In Section 7.2 a class is modelled in terms of the way objects of that class respond to sequences of messages. In Section 7.3 a partial order is constructed to compare the behaviour of different classes. <p> retrieval. 7.6 Discussion and Summary It should be emphasised that this chapter concentrates on the specification of a theoretical framework for behavioural retrieval, rather than giving optimised algorithms for a practical implementation. 7.6.1 Related Work The principle of behavioural retrieval from software libraries has been suggested by Podgurski and Pierce <ref> [92] </ref>. Their "behavioural sampling" technique did not necessarily collect all the possible execution responses but rather "sampled" the responses over a number of executions, and exercised the most commonly used operations based on a probability distribution.
Reference: [93] <author> W. Pree. </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1995. </year> <note> ISBN 0-201-42294-8. </note>
Reference-contexts: Additionally, an application domain can be abstracted into a collection of patterns called a framework [61]. The notion of patterns extends across levels of abstraction from coding patterns [9] to meta-patterns <ref> [93] </ref>. Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code [15]. <p> In effect, Extract and Retrieve are template operations in the framework, while Select is a hook operation in the framework (following the terminology of Pree <ref> [93] </ref>). There are many selection mechanisms for faceted classification schemes, many of which are metrics based on weights of facets and thesaurus relationships. Specified here is the simplest form of faceted-classification matching.
Reference: [94] <author> R. Prieto-Diaz. </author> <title> Implementing faceted classification for software reuse. </title> <journal> Commun. ACM, </journal> <volume> 34(5) </volume> <pages> 88-97, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Such a facet may be named Object and a word (term) in its term space may be Stack . All components that could be used to affect a Stack in some way would have the term Stack in their Object facet. Prieto-Diaz <ref> [94] </ref> implements a classification system based on a faceted classification of software. Six facets for describing software components were chosen; three describe component functionality and three describe component environment. They are Function, Object , Medium, System-Type, Functional Area and Setting.
Reference: [95] <author> R. Prieto-Diaz. </author> <title> Status report software reusability. </title> <journal> IEEE Software, </journal> <volume> 10(3) </volume> <pages> 61-66, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: However they also highlight through their choice of examples one of the major problems with class libraries | different libraries covering the same domain are organised differently. 2 1.2. THE ROLE OF SOFTWARE LIBRARIES * Prieto-Diaz <ref> [95] </ref> provides a list of different aspects of software reuse. The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse.
Reference: [96] <author> R. Prieto-Diaz and G. Arango, </author> <title> editors. Domain Analysis and Software Systems Modeling, </title> <publisher> Los Alamitos, </publisher> <address> CA, 1991. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: The following dichotomies are identified: white vs. black box reuse, planned vs. ad-hoc reuse, vertical vs. horizontal reuse and compositional vs. generative reuse. The conclusion is that the current trends towards domain analysis <ref> [96] </ref> and development of reuse process models to integrate reuse into standard lifecycles [47] may help solve the reuse problem. * Mili et. al.[85] provides a discussion on issues and research directions which touches upon costing and measuring reuse, reuse-oriented software engineering process models, developing reusable assets, and developing with reusable <p> However, the recent movement towards organisational and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling <ref> [96] </ref> and controlled-vocabulary [41] retrieval schemes to be applied with some success. Nevertheless there remains the desire to develop software retrieval strategies suited for large-scale, 119 6.1. INTRODUCTION domain-spanning libraries [36, 52]. <p> Until recently, most effort in solving the retrieval problem has gone into software classification, with emphasis upon domain-specific aspects such as the signature and specifications of operations [122, 123], and the determination of static metrics that can be used when searching and retrieving <ref> [91, 96] </ref>. However, it is the dynamic behaviour of objects that is of the most concern when building applications [49, 92]. It is this behavioural view of retrieval that is discussed.
Reference: [97] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying Software for Reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: The retrieval schemes proposed in the literature can be classified into categories, based upon the technique used to represent components during the search process: Classification-based schemes: Various indexing techniques, including keyword comparison, facet <ref> [97] </ref>, frame [21], descriptor [81], lexical affinity [75] and feature-based [14] techniques all seek to find relevant components based upon controlled vocabularies, properties and ontologies external to the component. <p> Querying by class and method name can be performed in many development environments. All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [39, 97, 123] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [91] suggests another strategy for large libraries, called "affinity browsing". <p> Each retrieval scheme will be formalised as a class of this general form. Faceted Scheme and Vocabulary The faceted scheme described here is a simple version of the scheme proposed in Prieto-Diaz <ref> [97] </ref>. Faceted classification schemes for retrieval consist of a collection of facets, or 123 6.2. AN ABSTRACT RETRIEVAL FRAMEWORK classifications, which represent the type of information that is relevant for identifying reusable components.
Reference: [98] <author> Rational Software Corporation. </author> <title> Unified Modelling Language Notation Guide. UML Document Set. Rational Software Corporation, </title> <note> 1997. Available from http://www.rational.com. </note>
Reference-contexts: COMPONENT INSERTION is maintained. The notions of quality for functional descriptions of the real world and means for evaluating them are the subject of continuing research into software engineering notations (e.g. UML <ref> [98] </ref> (object-oriented notation), VDM [64] (formal notation), CSP [54] (concurrency notation)). 5.3.2 Inserting Object-Z Components In this section, the insertion of components into a library of Object-Z components is considered. In particular, we discuss the insertion of an operation into an existing class component.
Reference: [99] <author> E. J. Rollins and J. M. Wing. </author> <title> Specifications as search keys for software libraries: A case study using lambda prolog. </title> <type> Technical Report CMU-CS-90-159, </type> <institution> Carnegie Mellon 245 9.3. RELATED AND FUTURE WORK University, School of Computer Science Carnegie Mellon University Pittsburgh, </institution> <address> PA 15213-3890, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Structural schemes: Type signature [122] and specification matching <ref> [39, 58, 99, 123] </ref> techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. <p> Some implementations of specification matching schemes appear in the literature. Rollins and Wing <ref> [99] </ref> use higher order unification in a Prolog dialect called -Prolog. Fischer et. al [39] present a specification matching implementation using specifications written in the VDM [64] specification language.
Reference: [100] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1991. </year>
Reference-contexts: RELATED AND FUTURE WORK context, a solution comprising components, their relationships and collaboration, and any consequences application of the pattern may have. Typically, the pattern problem is informally explained using natural language. Pattern solutions are generally expressed using a variant of the diagrammatic "Object Modelling Technique (OMT)" notation <ref> [100] </ref>, while pattern consequences are explained using a combination of natural language and source code fragments. Given these elements, a design pattern can be modelled under the general component model of Chapter 4. As described above, design patterns are annotated functional descriptions, as required by the general component model.
Reference: [101] <author> G. Salton and M. J. McGill. </author> <title> Introduction to Modern Information Retrieval. </title> <publisher> McGraw-Hill, </publisher> <year> 1983. </year>
Reference-contexts: It is often the case that condensed representations of components are used to facilitate an efficient search process. As mentioned in Section 6.2.1, condensed representations of components are called surrogates <ref> [101] </ref>. Searching proceeds readily when the forms of queries and surrogates are easily comparable. <p> As these strategies will not in general select identical sets of behaviours in B, both are employed in order to maximise the recall (defined to be ratio of the number of relevant retrievals to the number of relevant solutions <ref> [101] </ref>) of the retrieval process. These strategies are analogous to the behavioural filter function (see Section 6.5.3) which selects particular surrogates from a set of surrogates (in this case selecting behaviours from the behavioural projected B).
Reference: [102] <author> G. Sindre, E-A. Karlsson, and T. Stalhane. </author> <title> A method for software reuse through large component libraries. </title> <booktitle> In Proc. 5th International Conference on Computing and Information (ICCI'93), </booktitle> <month> May </month> <year> 1993. </year> <institution> Sudbury, Canada. </institution>
Reference-contexts: Faceted retrieval schemes are one of many retrieval schemes using vocabulary based classification of software components. Examples of similar classification schemes include retrieval using the Reboot project's faceted scheme <ref> [102] </ref>, frames [21], features [14], class descriptors [81] and lexical affinity [75]. These retrieval schemes could also be modelled under the common framework presented in this section. 6.2.7 Assembled Formal Declarations This section presents a summary of the general abstract framework for retrieval schemes.
Reference: [103] <editor> M. Sitaraman, editor. </editor> <booktitle> Fourth International Conference on Software Reuse: Advances in Software Reusability, </booktitle> <address> Los Alamitos, CA, April 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [104] <author> M. Sitaraman. </author> <title> Impact of performance considerations on formal specification design. </title> <journal> Formal Aspects of Computing, </journal> <volume> 8 </volume> <pages> 716-736, </pages> <year> 1996. </year>
Reference-contexts: Integrity constraints for specification languages are motivated by the quality of the semantics of submitted components. More sophisticated means to assess the semantics of specification components may include checks to detect whether a submitted component is fully-abstract [64], and not implementation or performance biased <ref> [104] </ref>. However, automated means for such detection and provision of appropriate feedback are not yet existent. Acceptance The operation to insert an accepted operation component into a class can be modelled by augmenting the Class component definition in Section 4.5.3.
Reference: [105] <author> G. Smith. </author> <title> A Logic for Object-Z. </title> <type> Technical Report 94-48, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, </institution> <month> December </month> <year> 1994. </year> <booktitle> To appear in the 9th Z User Meeting (ZUM'95). </booktitle>
Reference: [106] <author> G. Smith. </author> <title> Formal Definitions of Behavioural Compatibility for Active and Passive Objects. </title> <booktitle> In Proc. 1st Asia-Pacific Software Engineering Conference (APSEC '94), </booktitle> <pages> pages 336-344, </pages> <address> Los Alamitos, CA, December 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In general, there may be many relationships between two software components, any of which may be used as the basis for browsing and retrieval from a software library. One component may be a subtype [72] of another, be behaviourally compatible <ref> [106] </ref> with an 19 2.2. DATA REQUIREMENTS other, or be substitutable [28] with another. These notions all differ slightly in their definition. <p> These notions all differ slightly in their definition. The subtype relationship in Lisov and Wing [72] (the Liskov Substitutability Principle) is concerned with being able to operate a component of a subtype as a component of its supertype. The behavioural compatibility relationships as defined in Smith <ref> [106] </ref> use a formal model of object behaviour to define operational and observational notions of compatibility for passive and active objects respectively. The substitutability relationships between objects defined in Duke [28] model objects as state transition systems and use a lattice over such systems to determine object compatibility. <p> Following this idea, users may specify desired behaviour with a formal specification, from which behaviour can be inferred <ref> [29, 106] </ref>. The aim is to enable the methodology to be applied to a library of classes described by formal specifications.
Reference: [107] <author> J. Soldersitsch. </author> <title> Making the Case for Interoperating Reuse Libraries. </title> <booktitle> In Proc. 5th Workshop on Institutionalizing Software Reuse (WISR), </booktitle> <year> 1992. </year>
Reference-contexts: Many programmers maintain a personal library of code which may be reused in later projects. However, existing software libraries vary in scale from such personally maintained collections of code, through comprehensive domain-specific collections, to a number of very large domain-spanning libraries <ref> [38, 107] </ref>. There are several existing software library systems used in this chapter to highlight the cognitive design deficiencies. They are based on the languages Eiffel [81], C++[109], Smalltalk [46], and Java [69].
Reference: [108] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. Prentice-Hall, 1989. 246 9.3. RELATED AND FUTURE WORK </booktitle>
Reference-contexts: Their appearance at many levels of abstraction has fostered investigation of their formal interpretation [67] and use in automatically generating code [15]. London and Milstead [73] present component specifications of two Smalltalk components (realistic sets and dictionaries) in the Z specification language <ref> [108] </ref> in order to evaluate some of the problems with using formal specification languages to specify components. A problem they identified was that it was not clear whether one should specify in a library the abstract properties of the components or to specify their implementations.
Reference: [109] <author> B. Stroustrup. </author> <title> The C++ programming language. </title> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1991. </year>
Reference: [110] <institution> ParcPlace Systems. VisualWorks Cookbook. VisualWorks Manuals. ParcPlace Systems, Inc., </institution> <year> 1994. </year>
Reference-contexts: The VisualAge library also provides a collection of customisable application shells (e.g. an application shell linking a database with a user interface). VisualWorks Smalltalk has a collection of examples collated in a cookbook <ref> [110] </ref>. The exposure of library schemata through proprietary tools, coupled with idiomatic examples, falls short of providing a clear, explicit library schema which can be used to support software library operations, and thereby enhance the utility of libraries for software engineers.
Reference: [111] <author> S.R. Thatte. </author> <title> Synthesizing interface stubs for reusable classes. </title> <booktitle> In Proc. of the Sixth Annual Workshop on Software Reuse (WISR 6), </booktitle> <year> 1993. </year>
Reference-contexts: Jeng and Cheng [60] show how using order-sorted unification of specifications can yield a set of substitutions guiding the adaptation of retrieved components. Edwards [33] notes the problems of mismatched component interfaces: when one component mistakenly presumes another offers a particular set of features. Thatte <ref> [111] </ref> discusses 26 2.4. SUMMARY the synthesis of interface stubs given two components with differing interfaces. Yellin and Strom [121] attach protocol specifications to the interface of each object and use these protocols as the basis for software adaptors which bridge the differences between component interfaces.
Reference: [112] <author> W. Tracz. </author> <title> A conceptual model for megaprogramming. </title> <journal> Software Engineering Notes, </journal> <volume> 16(3) </volume> <pages> 35-45, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF [114]), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model <ref> [112] </ref>, RESOLVE [20], and Design Patterns [43]) have been proposed. These disciplines prescribe recommended styles of expression within some component description language. The choice of any single component description language for software libraries is not clear given the continuing evolution of component description languages. However, this should 18 2.2.
Reference: [113] <author> J. Uhl and H.A. Schmid. </author> <title> A Systematic Catalogue of Reusable Abstract Data Types. </title> <journal> Lect. Notes in Comput. Sci., </journal> <volume> 460, </volume> <year> 1990. </year>
Reference-contexts: Lins [71] defines a Modula-2 component library based upon data abstraction and notions of software components developed by Booch [13]. Uhl and Schmid <ref> [113] </ref> define a general catalogue of reusable abstract data types (focusing on container classes) using Ada as the component definition language. 15 2.1. <p> The libraries above each take a different stance on this issue: the Modula-2 components are minimally populated with only the most necessary operations; the Ada component library of <ref> [113] </ref> attempts to provide as many sensible operations as possible; the policy in the Eiffel libraries is to only include an extra operation in a component if certain criteria (e.g. non-duplication of existing functionality) are satisfied. Criteria for assessing the quality of component interfaces is an area of continuing research.
Reference: [114] <author> D. Ungar and R.B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proc. 2nd ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOP-SLA'87), </booktitle> <pages> pages 227-242, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [65]. The choice of any object-oriented component description language for libraries may still be premature. Current areas of research into interface-oriented languages (Java [69]), prototypical languages (SELF <ref> [114] </ref>), and subject-oriented programming [51, 89] all suggest that object-oriented component descriptions have shortcomings. To alleviate these shortcomings, disciplines to direct the use of component description languages (3C model [112], RESOLVE [20], and Design Patterns [43]) have been proposed.
Reference: [115] <author> P. </author> <title> Wegner. </title> <journal> Capital-intensive software technology. IEEE Software, </journal> <volume> 1(3), </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Nevertheless, adoption of a reuse culture requires organisational change. Resistance to such change is pragmatically a real impediment to the introduction of reuse solutions. As a research field, software reuse has been steadily growing since the mid-eighties. Wegner <ref> [115] </ref> repeated and extended the idea of the manufacture of software components expressed by McIlroy [77]. <p> Useful software libraries should record ideas and outcomes generated during software developments in such a way as to enable other software engineers to understand them. In turn this can significantly ease the process of software engineering, by providing a source of verified software artefacts <ref> [77, 115] </ref>. 1.3 Analysis Software library systems are not yet common or mature phenomena, and as such are themselves candidates for the application of requirements analysis, formal specification, design and other software engineering activities.
Reference: [116] <author> P. Wegner. </author> <title> Dimensions of object-based language design. </title> <booktitle> In Proc. 2nd ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOP-SLA'87), </booktitle> <pages> pages 168-182, </pages> <year> 1987. </year>
Reference-contexts: The inheritance relationship has been the subject of much debate in the literature; the main issue is how inheritance should and should not be used to develop software of quality. Wegner <ref> [116, 117] </ref> examines inheritance, defining inheritance of one component by another to effectively be a mechanism for resource sharing (delegation). Wolczko [120] revisits the notion of delegation to note that a component's interface should not only include the message it can receive but also the messages it sends in response.
Reference: [117] <author> P. Wegner and S. Zdonik. </author> <title> Inheritance as an incremental modification mechanism or what like is and isn't like. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> Proc. European Conf. on Object-Oriented Programming (ECOOP'88), </booktitle> <pages> pages 55-77. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The inheritance relationship has been the subject of much debate in the literature; the main issue is how inheritance should and should not be used to develop software of quality. Wegner <ref> [116, 117] </ref> examines inheritance, defining inheritance of one component by another to effectively be a mechanism for resource sharing (delegation). Wolczko [120] revisits the notion of delegation to note that a component's interface should not only include the message it can receive but also the messages it sends in response.
Reference: [118] <author> B.W. Weide, S.H. Edwards, W.D. Heym, T.J. Long, and W.F. Ogden. </author> <title> Characterizing Observability and Controllability of Software Components. </title> <booktitle> In Sitaraman [103], </booktitle> <pages> pages 62-71. </pages> <month> 247 9.3. </month> <title> RELATED AND FUTURE WORK </title>
Reference-contexts: Criteria for assessing the quality of component interfaces is an area of continuing research. Two criteria, the observability and controllability proferred by operations with respect to the state of the component are discussed in <ref> [118] </ref>. Of the libraries mentioned above, Meyer [82] provides the most comprehensive attempt at rationalising the design of software component libraries. Of the many principles he outlines, the most important he claims is the consistency principle: 16 2.2.
Reference: [119] <author> B.W. Weide and J.E. Hollingsworth. </author> <title> Scalability of reuse technology to large systems requires local certifiability. </title> <booktitle> In Proc. of the Fifth Annual Workshop on Software Reuse (WISR 5), </booktitle> <year> 1992. </year>
Reference-contexts: The argument was that reuse can only truly be achieved with a solid technical emphasis on component description languages. Other researchers have recognised that there are a number of difficulties with the object paradigm that need to be addressed. Weide and Hollingsworth <ref> [119] </ref> argue that properties of components should be locally certifiable to allow their reuse in larger systems. It is claimed that no language paradigm enforces this notion. It is also claimed that the principles of information hiding and encapsulation need re-investigation to allow open implementations [65]. <p> Weide and Hollingsworth <ref> [119] </ref> argue that insertion of a component should en 25 2.3. OPERATIONAL REQUIREMENTS sure its local certifiability. Griffiths [48] formally distinguishes between strictly modular properties of a component and properties which must be ensured within the context of a particular system.
Reference: [120] <author> M. Wolczko. </author> <title> Encapsulation, delegation and inheritance in object-oriented languages. </title> <journal> Software Engineering Journal, </journal> <pages> pages 95-101, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Wegner [116, 117] examines inheritance, defining inheritance of one component by another to effectively be a mechanism for resource sharing (delegation). Wolczko <ref> [120] </ref> revisits the notion of delegation to note that a component's interface should not only include the message it can receive but also the messages it sends in response. Edwards [34] discusses the problems inheritance causes when defining reusable components.
Reference: [121] <author> D.M. Yellin and R.E. Strom. </author> <title> Interfaces, protocols, and the semi-automatic construction of software adaptors. </title> <booktitle> In Proc. 9th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'94), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Edwards [33] notes the problems of mismatched component interfaces: when one component mistakenly presumes another offers a particular set of features. Thatte [111] discusses 26 2.4. SUMMARY the synthesis of interface stubs given two components with differing interfaces. Yellin and Strom <ref> [121] </ref> attach protocol specifications to the interface of each object and use these protocols as the basis for software adaptors which bridge the differences between component interfaces. These interface issues are important to ensure cooperation of components when adapted from a retrieved library component.
Reference: [122] <author> A. M. Zaremski and J. M. Wing. </author> <title> Signature matching: A key to reuse. </title> <type> Technical Report CMU-CS-93-151, </type> <institution> Carnegie Mellon University, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh , PA 15213, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Structural schemes: Type signature <ref> [122] </ref> and specification matching [39, 58, 99, 123] techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. <p> It has been recognised that replacement d ? should be compatible in some way with removed component c?, to provide guarantees for clients of operation c? who subsequently use d ?. Generally, two forms of guarantees have been investigated: statically checkable guarantees such as signature <ref> [122] </ref> or type [17, 90] compatibility; and dynamic guarantees of behavioural compatibility as mentioned in Section 2.2.2. The operation RemoveOperation has been constructed by identifying all components possibly affected, and propagating change to them in form of operations DetachReference and DetachComponent . <p> be-havioural retrieval using the formal framework. 6.3 Signature Matching In this section a formal model for a signature-matching retrieval is presented according to the framework outlined in Section 6.2. 6.3.1 Scheme Name and Vocabulary The signature matching scheme described here is based upon the scheme proposed in Zaremski and Wing <ref> [122] </ref>, modified slightly to be applicable to object-oriented class declarations. The signature-matching scheme for reuse of class components primarily relies upon type-matching under type-transformations. Classes are represented by a multi-set of feature signatures, where a signature records the types of a feature in a class. <p> Signature transformations will be used in the definition of the Select search operation given later in this section. A signature transformation is modelled as a relation between signatures. SigTransform == Signature $ Signature Examples of signature transformations used in <ref> [122] </ref> are: flip; curry; uncurry; generalise; specialise : SigTransform For instance, the curry signature transformation changes function signatures of the form X fi Y ! Z to signatures of the form X ! Y ! Z . <p> The complete set of applicable transforms (i.e. relations) available in a signature-matching scheme is modelled by relation transforms using the type SigTransform. The relation transforms models the union of underlying transforms (i.e. relations). For example, the transforms relation in <ref> [122] </ref> would be defined as: transforms : SigTransform transforms = flip [ curry [ uncurry [ generalise [ specialise To further increase the recall of a query, a signature-matching retrieval scheme also has an ordering on signatures. <p> This definition of the set participants for a signature-matching scheme is formalised as the predicate: participants = fc : dom extract surrogate j dom extract surrogate (c) " sigs = ?g 6.3.5 Searching There are many signature and module matching mechanisms proposed in Zaremski and Wing <ref> [122] </ref>. The matching specified here, called Generalised relaxed fl match, is mentioned as the matching mechanism most likely to be used in practice. <p> The theory developed in this chapter shows that useful, exploitable structure does exist in behaviour. Until recently, most effort in solving the retrieval problem has gone into software classification, with emphasis upon domain-specific aspects such as the signature and specifications of operations <ref> [122, 123] </ref>, and the determination of static metrics that can be used when searching and retrieving [91, 96]. However, it is the dynamic behaviour of objects that is of the most concern when building applications [49, 92]. It is this behavioural view of retrieval that is discussed.
Reference: [123] <author> A. M. Zaremski and J. M. Wing. </author> <title> Specification Matching of Software Components. </title> <booktitle> In Proc. Third Symposium on the Foundations of Software Engineering (FSE3), </booktitle> <pages> pages 6-17. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> October </month> <year> 1995. </year> <month> 248 </month>
Reference-contexts: Structural schemes: Type signature [122] and specification matching <ref> [39, 58, 99, 123] </ref> techniques seek to find relevant components based upon elements of the structure 23 2.3. OPERATIONAL REQUIREMENTS of software components. An external-static hybrid approach has been proposed in [35]. Behavioural schemes: Behavioural techniques seek to take advantage of the distinguishing property of software | executability. <p> Querying by class and method name can be performed in many development environments. All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [39, 97, 123] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [91] suggests another strategy for large libraries, called "affinity browsing". <p> Specification matching is the topic of the next section. 6.4 Specification Matching This section presents a formal model for specification-matching retrieval according to the framework outlined in Section 6.2. 6.4.1 Scheme Name and Vocabulary The specification-matching scheme described here is based upon the schemes proposed in Zaremski and Wing <ref> [123] </ref>. Specification matching primarily relies upon matching predicates in a logic, given a theory of predicate equivalence. Classes are represented by a collection of pairs of predicates; that is, the pre- and post- conditions of each class operation. <p> j let s == extract surrogate (c) * 9 p : dom s [ ran s * formula (p) formulae terms (p) termsg The auxiliary functions formula and terms respectively extract the formula symbols and ground terms from a predicate. 6.4.5 Searching There are many specification matching mechanisms proposed in <ref> [123] </ref>. The matching specified here is plug-in match; other matching mechanisms can be specified by selecting the ordering, adjusting the definition of Select and/or changing the transformations available. <p> The theory developed in this chapter shows that useful, exploitable structure does exist in behaviour. Until recently, most effort in solving the retrieval problem has gone into software classification, with emphasis upon domain-specific aspects such as the signature and specifications of operations <ref> [122, 123] </ref>, and the determination of static metrics that can be used when searching and retrieving [91, 96]. However, it is the dynamic behaviour of objects that is of the most concern when building applications [49, 92]. It is this behavioural view of retrieval that is discussed.
References-found: 123

