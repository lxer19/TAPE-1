URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-90-57.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Detecting Data Races by Analyzing Sequential Traces  
Author: David P. Helmbold Charles E. McDowell Jian-Zhong Wang 
Keyword: data race, time vector, program trace, parallel programming, debugging, distributed systems  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California at Santa Cruz  
Date: October 17, 1990  
Pubnum: 90-57  
Abstract: One of the fundamental problems encountered when debugging a parallel program is determining the potential race conditions in the program. A race condition exists when multiple tasks access shared data in an unconstrained order and at least one of the accesses is a write operation. The program's behavior can be unpredictable when race conditions are present. This paper describes techniques which automatically detect data races in parallel programs by analyzing program traces. We view a program execution as a partial ordering of events, and define which executions are consistent with a given trace. In general, it is not possible to determine which of the consistent executions occurred. Therefore we introduce the notion of "safe orderings" between events which are guaranteed to hold in every execution which is consistent with the trace. The main result of the paper is a series of algorithms which determine many of the "safe orderings". An algorithm is also presented to distinguish unordered sequential events from concurrent events. A working trace analyzer has been implemented. The trace analyzer can report various data races in parallel programs by finding unordered pairs of events and variable access conflicts. 
Abstract-found: 1
Intro-found: 1
Reference: [AP87] <author> T. R. Allen and D. A. Padua. </author> <title> Debugging fortran on a shared memory machine. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <pages> pages 721-727, </pages> <year> 1987. </year>
Reference-contexts: However, the races detectable by analysis of event histories may depend on the program input data used to generate the trace. Furthermore, since races introduce nondeterminism, a data race may hide other data races from the trace analyzer <ref> [AP87] </ref>. Nevertheless, this later approach can provide important information to help in debugging parallel programs and is the subject of this paper. When debugging a parallel program, the first step is to determine the order and concurrency relationships among the operations performed by the program. <p> and t (e) &lt; t (^e). 7 Given a specific input and trace, there may be executions on that input whose EHGs are not consistent with the trace, however, any such execution will contain a race if and only if a race occurred in the execution that generated the trace <ref> [AP87] </ref>. 8 Here we assume that matching up the i th signal with the i th wait in the trace gives a legal execution. If that is not the case, then the parings of any legal execution could be used.
Reference: [Dij65] <author> E. W. Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM, </journal> <volume> 8(9), </volume> <month> September </month> <year> 1965. </year>
Reference-contexts: it is impossible for a totally ordered trace to accurately reflect the event orderings. 2 In fact, the problem of determining all "must occur" orderings between events in a counting semaphore model has been shown to be co-NP-hard [NM90]. 3 Although operations on shared data can be used for synchronization <ref> [Dij65] </ref>, we only consider explicit synchronization operations as capable of generating synchronization events. 4 Appearance of an event indicates that the event has completed. 2. Description of the Model 3 Different tasks may perform operations concurrently. We assume, for convenience, that each task has a unique identifier.
Reference: [DS90] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <year> 1990. </year>
Reference-contexts: Summary 27 Dinning and Schonberg <ref> [DS90] </ref> present a method of detecting access anomalies in parallel programs "on-the-fly". They use a mechanism, which is similar to time vectors, to identify concurrent operations in a program execution. Some compaction methods are used to reduce the storage needed for reader and writer sets.
Reference: [EGP89] <author> P. A. Emrath, S. Ghosh, and D. A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Supercomputing '89, </booktitle> <month> November </month> <year> 1989. </year> <title> Reno, </title> <address> NV. </address>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods. <p> Unfortunately the synchronization models supported by several parallel programming languages allow for anonymous communication, where the partner is unknown. Examples of anonymous communication include locks, semaphores, and monitors. Emrath, Ghosh, and Padua <ref> [EGP89] </ref> present a method for detecting non-determinacy in parallel programs that utilize fork/join and event style synchronization instructions with the Post, Wait, and Clear primitives.
Reference: [EP88] <author> P. A. Emrath and D. A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods.
Reference: [Fid88] <author> C. J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 183-194, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In our trace analysis, each event is assigned a vector of timestamps. The ordered event pairs and unordered event pairs can be easily distinguished by comparing these time vectors. The time vectors we compute in this paper are an extension of the time vectors of Fidge <ref> [Fid88] </ref> and Mattern [Mat88]. <p> The following algorithm (derived from <ref> [Mat88, Fid88] </ref>) computes time vectors for the events in an EHG. This algorithm requires the correspondence between signal and wait events. The time vectors produced reflect the happened before partial order for that EHG. <p> The partial order resulting from the initialization phase is similar to that computed by the algorithm of <ref> [Fid88] </ref>. This partial order is a consistent EHG, so it is likely to be an unsafe order relation. The result of the rewind step is a partial order that is a safe order relation. Unfortunately, it is an overly conservative safe 8 3. <p> This paper contains a series of polynomial time algorithms for extracting useful information from sequential traces with anonymous synchronization. The first algorithm is very similar to the vector timestamp methods of Fidge and Mattern <ref> [Fid88, Mat88] </ref>. The other algorithms systematically manipulate these vectors of timestamps
Reference: [HMW90] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Analyzing traces with anonymous synchronization. </title> <booktitle> In Proc. International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods.
Reference: [HMW91] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Detecting data races from sequential traces. </title> <booktitle> In Proc. of Hawaii International Conference on System Sciences, </booktitle> <pages> pages 408-417, </pages> <year> 1991. </year> <note> References 29 </note>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods.
Reference: [IBM88] <institution> Parallel FORTRAN language and library reference. IBM, </institution> <year> 1988. </year>
Reference-contexts: However, if the trace contains anonymous synchronization (e.g. semaphores, locks, signals) then determining whether or not two events occur in a particular order in every consistent execution is much more difficult 2 . Many parallel systems (e.g. <ref> [IBM88] </ref>) provide facilities for recording important events during the execution of parallel programs. By limiting the debugger's activity, the probe effect should be reduced. The recorded information can be analyzed following the program's execution. The next section contains definitions and description of our basic model involving counting semaphores. <p> Here we generalize those results to the event-based synchronization mechanism provided by IBM Parallel FORTRAN <ref> [IBM88] </ref> and describe a working tool based on these algorithms. Although the algorithms presented in this section have the same initialize-rewind-expand top-level structure, modifications are needed to handle the IBM Parallel Fortran synchronization primitives.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> CACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The relation defined by an EHG is called the happened before relation and is denoted with the symbol !. Our definition of "happened before" is consistent with that of Lamport <ref> [Lam78] </ref>. Definition 2: Consider an EHG and two distinct events e; e 0 . If e6!e 0 and e 0 6!e then events e and e 0 are concurrent in that EHG, and thus can happen at the same time in the execution represented by the EHG.
Reference: [Mat88] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Cosnard, editor, </editor> <booktitle> Proceedings of Parallel and Distributed Algorithms, </booktitle> <year> 1988. </year>
Reference-contexts: In our trace analysis, each event is assigned a vector of timestamps. The ordered event pairs and unordered event pairs can be easily distinguished by comparing these time vectors. The time vectors we compute in this paper are an extension of the time vectors of Fidge [Fid88] and Mattern <ref> [Mat88] </ref>. <p> The following algorithm (derived from <ref> [Mat88, Fid88] </ref>) computes time vectors for the events in an EHG. This algorithm requires the correspondence between signal and wait events. The time vectors produced reflect the happened before partial order for that EHG. <p> Given the correspondence between signal and wait events in some EHG, events can be assigned time vectors by using Algorithm 1. Mattern <ref> [Mat88] </ref> has shown that the resulting time vectors correctly represent the relation ! for that EHG. Therefore, the initial time vectors, t , correctly represent the happened before relation for the canonical execution. <p> This paper contains a series of polynomial time algorithms for extracting useful information from sequential traces with anonymous synchronization. The first algorithm is very similar to the vector timestamp methods of Fidge and Mattern <ref> [Fid88, Mat88] </ref>. The other algorithms systematically manipulate these vectors of timestamps
Reference: [MC88] <author> B. P. Miller and J-D. Choi. </author> <title> Breakpoints and halting in distributed systems. </title> <booktitle> In Proc. Int. Conf. on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods.
Reference: [McD89] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> June, </month> <year> 1989. </year>
Reference-contexts: One approach to determining potential races is based on computing all of the reachable concurrency states of the program <ref> [McD89, Tay84] </ref>. The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program [EP88, MC88, EGP89, NM89, HMW90, HMW91]. <p> Alternatively, each synchronization event could include the source line number of the statement generating the event. From the source line numbers the path between two adjacent events can be determined and the variables referenced along the path can be computed <ref> [McD89] </ref>. A trace (also called an event history) is a linear list or total ordering of the events performed during an execution of the program. For our purposes, the trace reflects 2 2. Description of the Model only one of the orders in which the events could have occurred. <p> The final time vectors represent a safe partial order among events. By comparing the time vectors, we can distinguish many ordered events from unordered events. Combining this with variable reference information from START <ref> [McD89] </ref>, the trace analyzer reports those data races which can happen in any executions whose EHG is consistent with the given trace. The trace analyzer is implemented mainly in C++, and part of the code is implemented in C.
Reference: [NM89] <author> R. Netzer and B. P. Miller. </author> <title> Detecting Data Races in Parallel Program Executions. </title> <type> Technical Report 894, </type> <institution> University of Wisconsin-Madison, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program <ref> [EP88, MC88, EGP89, NM89, HMW90, HMW91] </ref>. One advantage of trace analysis is that it is much less expensive computa-tionally than the known static structure analysis methods. <p> Although their algorithm is simple, it may be computationally complex. Rather than repeatedly computing the common ancestor information, we use time vectors to calculate the guaranteed execution order. Netzer and Miller <ref> [NM89] </ref> present a formal model of a parallel program execution. Their model includes fork/join parallelism and synchronization using semaphores.
Reference: [NM90] <author> R. H. B. Netzer and B. P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel progra m executions. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <pages> pages 93-97, </pages> <year> 1990. </year>
Reference-contexts: sequence H i of events 4 . 1 When events occur concurrently, it is impossible for a totally ordered trace to accurately reflect the event orderings. 2 In fact, the problem of determining all "must occur" orderings between events in a counting semaphore model has been shown to be co-NP-hard <ref> [NM90] </ref>. 3 Although operations on shared data can be used for synchronization [Dij65], we only consider explicit synchronization operations as capable of generating synchronization events. 4 Appearance of an event indicates that the event has completed. 2. Description of the Model 3 Different tasks may perform operations concurrently. <p> Our goal is a set of time vectors which can be used to distinguish ordered events from unordered and potentially concurrent events 7 . The problem of calculating all safe order relations has been shown to be co-NP-hard by Netzer and Miller <ref> [NM90] </ref>. What we present is a good approximation of the problem. <p> Theorem 3: Algorithm 4 generates only safe order relations, i.e., for any two distinct events e and e 0 2 H: ^t (e) &lt; ^t (e 0 ) ) e e 0 3.4 Running Time Analysis The problem of calculating all safe order relations has been shown to be intractable <ref> [NM90] </ref>. We have presented a series of polynomial time algorithms that find many of the safe orderings that must occur in all executions that are consistent with the trace. Here we bound the execution times of these algorithms. <p> The problem is made even more difficult in the anonymous synchronization model, where there is no clear correspondence between the blocking and enabling events in the trace. The problem of calculating all safe order relations has been shown to be co-NP-hard by Netzer and Miller <ref> [NM90] </ref>. This paper contains a series of polynomial time algorithms for extracting useful information from sequential traces with anonymous synchronization. The first algorithm is very similar to the vector timestamp methods of Fidge and Mattern [Fid88, Mat88]. The other algorithms systematically manipulate these vectors of timestamps
Reference: [Tay84] <author> R. N. Taylor. </author> <title> Debugging Real-Time Software in a Host-Target Environment. </title> <type> Technical Report, U.C. Irvine Tech. Rep. 212, </type> <year> 1984. </year>
Reference-contexts: One approach to determining potential races is based on computing all of the reachable concurrency states of the program <ref> [McD89, Tay84] </ref>. The major disadvantage of this approach is that the number of concurrency states may become prohibitively large. Another approach to determining potential races is based on analyzing a trace from an execution of the program [EP88, MC88, EGP89, NM89, HMW90, HMW91].
Reference: [Wan90] <author> J-Z. Wang. </author> <title> Debugging Parallel Programs by Trace Analysis. </title> <type> Technical Report, Masters Thesis UCSC-CRL-90-11, </type> <year> 1990. </year>
Reference-contexts: Therefore, the initial time vectors, t , correctly represent the happened before relation for the canonical execution. Theorem 1: For any pair of distinct events e i 2 H i and e 2 H, t (e i )[i] t (e)[i] () e i ! e: See <ref> [Wan90] </ref> for detailed proofs of the theorems appearing in this paper. <p> We view the ordering relationships in the trace with suspicion, and wish to generate race reports in this situation 12 . 12 If the critical regions contain non-commutative operations, then the race to enter the regions can affect the remainder of the execution <ref> [Wan90] </ref>. 7. Summary 27 Dinning and Schonberg [DS90] present a method of detecting access anomalies in parallel programs "on-the-fly". They use a mechanism, which is similar to time vectors, to identify concurrent operations in a program execution.
References-found: 17

