URL: http://www.cs.iastate.edu/tech-reports/TR96-01.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: An Overview of Larch/C++: Behavioral Specifications for C++ Modules  
Author: Gary T. Leavens 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: February 1996  
Pubnum: TR #96-01  
Abstract: Keywords: behavioral specification, model-based, behavioral interface specification language, Larch, C++, Larch/C++, Larch Shared Language, VDM, Z, correctness, verification, abstract data type, object-oriented, specification inheritance, checkable redundancy, behavioral subtype, informality, tunable formality. 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | Assertions, invariants, pre- and post-conditions, specification techniques. Copyright c flKluwer Academic Publishers, 1996. Used by permission. A version of this paper will be a chapter in the book Specification of Behavioral Semantics in Object-Oriented Information Modeling , edited by Haim Kilov and William Harvey (Kluwer Academic Publishers, 1996). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE: An object oriented Z environment. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-199. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE <ref> [1, 2, 3] </ref>, MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The trait FourSidedFigure defines the type Edges as a tuple of four Vector values. As a convenience, the trait also introduces the operator, __ [__], which allows one to write e <ref> [1] </ref> instead of e.v1. In the asserts section, the specification states the condition on four-sided figures from [43]: that the vectors have to sum to zero (make a loop). In the implies section this property is stated in an equivalent way. <p> length operator to return an approximate result. 4 FourSidedFigure: trait includes PreVector (Scalar, Vector for Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e <ref> [1] </ref> == e.v1; e [3] == e.v3; implies 8 e: Edges e [1] + e [2] + e [3] + e [4] == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec <p> (Scalar, Vector for Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e <ref> [1] </ref> == e.v1; e [3] == e.v3; implies 8 e: Edges e [1] + e [2] + e [3] + e [4] == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] length: Vec [T] ! T is to be treated as a <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more <p> parallel sides. (The notation self * stands for the abstract value 11 imports QuadShape; imports NoInterior; abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) <p> abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == (e.v2 + e.v4 <p> - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == (e.v2 + e.v4 = 0:Vector); of self in a <p> == isaParallelogram (e) ^ (e.v2 e.v3 = 0); imports Rhombus; imports Rectangle; class Square : public Rhombus, public Rectangle - public: uses QuadSubtype (Square, Rhombus); simulates Rhombus by toSuperWithoutChange; uses QuadSubtype (Square, Rectangle); simulates Rectangle by toSuperWithoutChange; Square (Vector v1, Vector pos) - uses IsaSquare; modifies self; ensures liberally self'.edges <ref> [1] </ref> = v1 ^ self'.position = pos; claims liberally isaSquare (self'.edges); - 15 IsaSquare: trait includes IsaRectangle, IsaRhombus introduces isaSquare: Edges ! Bool asserts 8 e: Edges isaSquare (e) == isaRectangle (e) ^ isaRhombus (e); * The LSL traits specified in the examples correspond roughly to the Z specifications given in
Reference: [2] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE. </title> <editor> In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 79-94. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE <ref> [1, 2, 3] </ref>, MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e [1] == e.v1; e [3] == e.v3; implies 8 e: Edges e [1] + e <ref> [2] </ref> + e [3] + e [4] == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] length: Vec [T] ! T is to be treated as a "given". <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more <p> * stands for the abstract value 11 imports QuadShape; imports NoInterior; abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == (e.v1 + e.v3 = <p> : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == (e.v2 + e.v4 = 0:Vector); of <p> QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == (e.v2 + e.v4 = 0:Vector); of self in a visible state.
Reference: [3] <author> A. J. Alencar and J. A. Goguen. </author> <title> Specification in OOZE with examples. </title> <editor> In Kevin Lano and Howard Haughton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> The Object-Oriented Series, chapter 8, </booktitle> <pages> pages 158-183. </pages> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE <ref> [1, 2, 3] </ref>, MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> an approximate result. 4 FourSidedFigure: trait includes PreVector (Scalar, Vector for Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e [1] == e.v1; e <ref> [3] </ref> == e.v3; implies 8 e: Edges e [1] + e [2] + e [3] + e [4] == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] length: Vec [T] <p> Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e [1] == e.v1; e <ref> [3] </ref> == e.v3; implies 8 e: Edges e [1] + e [2] + e [3] + e [4] == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] length: Vec [T] ! T is to be treated as a "given". OBJ [16, 14]. <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more
Reference: [4] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector asserts 8 e: Edges e.v1 + e.v2 + e.v3 + e.v4 == 0:Vector; e [1] == e.v1; e [3] == e.v3; implies 8 e: Edges e [1] + e [2] + e [3] + e <ref> [4] </ref> == 0:Vector; PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] length: Vec [T] ! T is to be treated as a "given". OBJ [16, 14]. <p> Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [5] <author> Pierre America. </author> <title> Designing an object-oriented programming language with be-havioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, No-ordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [6] <author> Axex Borgida, John Mylopoulos, and Rayomnd Reiter. </author> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: It also allows exact C++ type information to be recorded. The body of the specification of Move has six clauses. The requires clause gives the function's precondition, the modifies and trashes clauses form a frame axiom <ref> [6] </ref>, the ensures clause gives the function's postcondition, the example clause gives an example of the function's execution, and the claims clause states a redundant property of the specification. The postcondition, and the assertions in the example and claims clauses, are predicates over two states.
Reference: [7] <author> R. M. Burstall and J. A. Goguen. </author> <title> Algebras, theories and freeness: An introduction for computer scientists. </title> <editor> In Manfred Broy and Gunther Schmidt, editors, </editor> <booktitle> Theoretical Foundations of Programming Methodology: Lecture Notes of an International Summer School directed by F. </booktitle> <editor> L. Bauer, E. W. Dijkstra and C. A. R. </editor> <booktitle> Hoare, volume 91 of series C, </booktitle> <pages> pages 329-348. </pages> <address> D. Ridel, Dordrecht, Holland, </address> <year> 1982. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>.
Reference: [8] <author> Patrice Chalin. </author> <title> On the Language Design and Semantic Foundation of LCL, a Larch/C Interface Specification Language. </title> <type> PhD thesis, </type> <institution> Concordia University, 1455 de Maisonneuve Blvd. West, Montreal, Qquebec, Canada, </institution> <month> October </month> <year> 1995. </year> <note> Available as CU/DCS TR 95-12. </note>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In LCL and other Larch interface languages, these notions are not separated, which this leads to semantic problems <ref> [8, 9] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about objects being allocated and assigned in postconditions. <p> More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language. One semantic idea is the distinction between trashing and modification <ref> [8, 9] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [9] <author> Patrice Chalin, Peter Grogono, and T. Radhakrishnan. </author> <title> Identification of and solutions to shortcomings of LCL, a Larch/C interface specification language. </title> <booktitle> In Proceedings of the FME'96 Symposium. FME'96: Industrial Benefit and Advances in Formal Methods, Formal Methods Europe., </booktitle> <year> 1996. </year> <note> To appear. An earlier version of this paper is available as Concordia University, Department of Computer Science TR 95-09. </note>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In LCL and other Larch interface languages, these notions are not separated, which this leads to semantic problems <ref> [8, 9] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about objects being allocated and assigned in postconditions. <p> More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language. One semantic idea is the distinction between trashing and modification <ref> [8, 9] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [10] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> The Larch/Smalltalk interface specification language. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(3) </volume> <pages> 221-253, </pages> <month> July </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [51, 50] (for CLU), Larch/Smalltalk <ref> [10] </ref> (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24]. <p> In Larch-style BISLs, such as Larch/C++, LM3 [18, Chapter 6], and Larch/Smalltalk <ref> [10] </ref>, abstract values of object do not have to be tuples. This means that there is a problem in giving a semantics to inherited specifications.
Reference: [11] <editor> Elspeth Cusack and G. H. B. Rafsanjani. ZEST. In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 113-126. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST <ref> [11] </ref>, Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The set of examples specifies a hierarchy of shapes that is used as a test case in the book Object Orientation in Z [43]. (The Larch/C++ specifications generally follow the Fresco [49] and ZEST <ref> [11] </ref> versions of the specifications.) 2 Quadrilaterals To write a specification in Larch/C++, one specifies an abstract model in LSL, and then uses that to specify the C++ interface and its behavior. <p> ! T PreVectorSpace (T): trait assumes RingWithUnit, Abelian (* for ffi) includes AbelianGroup (Vec [T] for T, + for ffi, 0 for unit, - __ for 1 ), DistributiveRingAction (T for M, Vec [T] for T) % ... implications omitted ... 2.2 Specification of QuadShape and Quadrilateral Following the ZEST <ref> [11] </ref> and Fresco [49] specifications of this shapes example, we start with an abstract class of four-sided figures, QuadShape. The reason for this is that, if we follow [43, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE [1, 2, 3], and ZEST <ref> [11] </ref>, there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more such abstract fields than the <p> For example, in Larch/C++ one could start out by using largely informal specifications, and then increase the level of formality as needed or desired. 3 Other Subtypes of QuadShape This section contains the behavioral interface specifications of the other sub-types of QuadShape described in [43]. As in <ref> [11] </ref>, we start with the abstract type ParallelShape, which is shown in Figure 11. This specification has two interesting features. The first an invariant clause.
Reference: [12] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <type> Technical Report 95-20b, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, December </month> <year> 1995. </year> <booktitle> To appear in proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <year> 1996. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses <ref> [12] </ref>. Thus we will follow the ZEST and Fresco specifications in using an abstract class whose objects are not shearable as the superclass of Quadrilateral. <p> Technically, in Larch/C++ behavioral subtyping is forced by inheriting the specification of the supertype's virtual member functions in the subtype <ref> [12] </ref>. The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. <p> trait includes Quad (Sub), Quad (Super); introduces toSuperWithoutChange: Sub ! Super asserts 8 x: Sub toSuperWithoutChange (x) == ([x.edges, x.position]):Super; What Larch/C++ currently (in release 4.1) requires is that the user specify a simulation function, which maps the abstract values of subtype objects to the abstract values of supertype objects <ref> [12] </ref>. Inheritance of the supertype's specifications is accomplished by applying the simulation function to each term whose type is the supertype. <p> In <ref> [12] </ref>, we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in [43]. <p> Allowing the specification of several specification cases (an idea due to Wills [47, 49, 48]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance <ref> [12] </ref>. Furthermore, when 16 combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [13] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Larch/C++ [29] is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ <ref> [13, 44] </ref> program module. 1.1 Model-Based Specification The idea of a model-based specifications builds on two seminal papers by Hoare. Hoare's paper "An Axiomatic Basis for Computer Programming" [21], used two predicates over program states to specify a computation.
Reference: [14] <author> Kokichi Futatsugi, Joseph A. Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <booktitle> Principles of OBJ2. In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1985. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>. <p> OBJ <ref> [16, 14] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. (Comments in LSL start with % and continue to the end of a line.) Two features of the implies section not previously seen are illustrated in this trait.
Reference: [15] <author> J. A. Goguen, J. W. Thatcher, and E. G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond T. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <volume> volume 4, </volume> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>.
Reference: [16] <author> Joseph A. Goguen. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: OBJ <ref> [16, 14] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. (Comments in LSL start with % and continue to the end of a line.) Two features of the implies section not previously seen are illustrated in this trait.
Reference: [17] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada <ref> [17] </ref> (for Ada), Larch/CLU [51, 50] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
Reference: [18] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [51, 50, 18] </ref>. * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [51, 50, 18]. * Although a mathematical toolkit is provided <ref> [18, Appendix A] </ref>, specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [51, 50, 18]. * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) <ref> [18, Chapter 4] </ref>. <p> Examples include LCL <ref> [18, Chapter 5] </ref> (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [51, 50] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. <p> Examples include LCL [18, Chapter 5] (for C), LM3 <ref> [18, Chapter 6] </ref> (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [51, 50] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24]. <p> abstract class QuadShape and the class Quadrilateral. 2.1 Abstract Model of Quadrilaterals Although LSL has the power to specify abstract models "from scratch," most abstract models are built using tuples (records), sets, and other standard mathematical tools that are either built-in to LSL or found in Guttag and Horning's Handbook <ref> [18, Appendix A] </ref>. A typical example is given in Figure 1. That figure specifies a theory in LSL, using a LSL module, which is called a trait . <p> In this trait's assumes clause, the type T is required to be a ring with a unit element, have a commutative multiplication operator, be totally ordered, and to have conversions to and from the real numbers. (The first three assumed traits are found in <ref> [18, Appendix A] </ref>; the last trait, and the included trait Real that specifies the real numbers, are found in [30].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in 1 In the trait FourSidedFigure, the type Vec [T] is <p> To push this mathematical modeling back to standard traits, one needs the trait PreVectorSpace, found in Figure 6. (The trait DistributiveRingAction is found in [30], the other traits are from <ref> [18, Appendix A] </ref>.) Now that we are done with the initial mathematical modeling, we can turn to the behavioral interface specifications. 5 PreVector (T): trait assumes RingWithUnit, Abelian (* for ffi), TotalOrder, CoerceToReal (T) includes PreVectorSpace (T), Real introduces __ __: Vec [T], Vec [T] ! T % inner product length: <p> In the specification of GetVec, i is passed by value. Thus i is not considered an object within the specification. This is why i denotes an int value, and why notations such as i^are not used <ref> [18, Chapter 5] </ref>. Note that, by using model-based specifications, it is easy to specify abstract classes. One imagines that objects that satisfy the specification have abstract values, even though there are no constructors. <p> In Larch-style BISLs, such as Larch/C++, LM3 <ref> [18, Chapter 6] </ref>, and Larch/Smalltalk [10], abstract values of object do not have to be tuples. This means that there is a problem in giving a semantics to inherited specifications.
Reference: [19] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. It also specifies ADTs using mathematical value spaces, called abstract models. The best-known model-based specification languages are VDM-SL [23] and Z <ref> [42, 41, 19] </ref>. Both come with a mathematical toolkit from which a user fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 can assemble abstract models for use in specifying procedures.
Reference: [20] <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Furthermore, when 16 combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete <ref> [20] </ref>. When combined with the approach of behavioral interface specification, the expressive features of Larch/C++ make it a step towards the day when formal documentation of C++ class libraries will be practical and useful. Acknowledgements Thanks to Adrian Fiech for suggestions and comments on an earlier draft.
Reference: [21] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Hoare's paper "An Axiomatic Basis for Computer Programming" <ref> [21] </ref>, used two predicates over program states to specify a computation. The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. <p> More important, allowing the user to specify both total and partial correctness for functions gives to users a choice previously reserved by specification language designers; the use of partial correctness, for example, is necessary for succinct specification of functions that may fail due to the finiteness of various data structures <ref> [21] </ref>. Allowing the specification of several specification cases (an idea due to Wills [47, 49, 48]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12].
Reference: [22] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. Hoare's paper "Proof of correctness of data representations" <ref> [22] </ref>, described the verification of abstract data type (ADT) implementations. In this paper Hoare introduced the use of an abstraction function, A, that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this set are consequently called abstract values [33].
Reference: [23] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. It also specifies ADTs using mathematical value spaces, called abstract models. The best-known model-based specification languages are VDM-SL <ref> [23] </ref> and Z [42, 41, 19]. Both come with a mathematical toolkit from which a user fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 can assemble abstract models for use in specifying procedures.
Reference: [24] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed <ref> [24] </ref>. This is of great practical benefit, because the details of the interface that need to be specified vary among programming languages.
Reference: [25] <author> K. Lano and H. Haughton. </author> <title> Specifying a concept-recognition system in Z++. </title> <editor> In Kevin Lano and Howard Haughton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> The Object-Oriented Series, chapter 7, </booktitle> <pages> pages 137-157. </pages> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [26, 25] </ref>, ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ <ref> [26, 25] </ref>, OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values
Reference: [26] <author> Kevin C. Lano. Z++. In Susan Stepney, Rosalind Barden, and David Cooper, </author> <title> editors, Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 106-112. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [26, 25] </ref>, ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ [38], Z++ <ref> [26, 25] </ref>, OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values
Reference: [27] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [28] <author> Gary T. Leavens. </author> <title> Inheritance of interface specifications (extended abstract). </title> <booktitle> In Proceedings of the Workshop on Interface Definition Languages, volume 29(8) of ACM SIGPLAN Notices, </booktitle> <pages> pages 129-138, </pages> <month> August </month> <year> 1994. </year> <month> 18 </month>
Reference-contexts: In Larch/Smalltalk the problem is resolved by having the user write enough operators in a trait so that the operators used in the supertype's specification are also defined on the abstract values of the subtype. However, because that solution seems to have modularity problems <ref> [28] </ref>, a slightly less general solution is currently used in Larch/C++. 10 QuadSubtype (Sub,Super): trait includes Quad (Sub), Quad (Super); introduces toSuperWithoutChange: Sub ! Super asserts 8 x: Sub toSuperWithoutChange (x) == ([x.edges, x.position]):Super; What Larch/C++ currently (in release 4.1) requires is that the user specify a simulation function, which maps
Reference: [29] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 4.1. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the world wide web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, December 1995. </note>
Reference-contexts: 1 Introduction Larch/C++ <ref> [29] </ref> is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ [13, 44] program module. 1.1 Model-Based Specification The idea of a model-based specifications builds on two seminal papers by Hoare. <p> This trait itself includes instances of two other traits: FourSidedFigure, and NoContainedObjects (Q). The latter of these simply says that an abstract value of type Q has no subobjects <ref> [29, Section 7.5] </ref>. The type Q itself is defined next, by using the built-in LSL tuple of notation. What LSL calls a tuple is a record-like value; in this case the tuple has two fields: edges of type Edges and position of type Vector. <p> The Larch/C++ specification of the abstract class QuadShape is given in Larch/C++, one could also specify QuadShape as a C++ template class with the types Vector and Scalar as type parameters <ref> [29, Chapter 8] </ref>, but the approach adopted here is more in keeping with the examples in [43]. In the specification of QuadShape, the first thing to note is that much of the syntax is the same as in C++. <p> C++ objects are formally modeled in Larch/C++ using various traits <ref> [29, Section 2.8] </ref>, and these traits allow one to write assigned (v, pre) to assert that the object v is allocated and assigned in the pre-state. (The pre- and post-states are reified in Larch/C++ using the keywords pre and post.) There is also a more useful notation for extracting the value <p> that the post-state value of the receiver object is equal to the pre-state value, with the position field changed to the pre-state position plus the pre-state value of the vector v. (Except for constructors, the object self is implicitly required to be assigned in every member function of a class <ref> [29, Section 6.2.2] </ref>.) A function may modify an allocated object by changing its value from unassigned to some proper value, or by changing one proper value to another proper value. Each object that a function is allowed to modify must be noted by that function's modifies clause. <p> By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about objects being allocated and assigned in postconditions. This is because, if an object is modified, it stays allocated, and if it was assigned in the pre-state, must also be assigned in the post-state <ref> [29, Section 6.2.3] </ref>. The ensures clause of Move's specification uses the Larch/C++ keyword liberally. <p> An example adds checkable redundancy to a specification. There may be several examples listed in a single function specification in Larch/C++. For each example, what is checked is roughly that the example's assertion, together with the precondition should imply the postcondition <ref> [29, Section 6.7] </ref>. (The 9 in the example given is typed as "E by users.) As far as we know, this idea of adding examples to function specifications is new in Larch/C++.
Reference: [30] <author> Gary T. Leavens. </author> <note> LSL math traits. http://www.cs.iastate.edu/~leavens/Math-traits.html, Jan 1996. </note>
Reference-contexts: ring with a unit element, have a commutative multiplication operator, be totally ordered, and to have conversions to and from the real numbers. (The first three assumed traits are found in [18, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in <ref> [30] </ref>.) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in 1 In the trait FourSidedFigure, the type Vec [T] is renamed to be Vector. <p> On the other hand, the length operator is not so well-specified, and thus is not named in the converts clause. To push this mathematical modeling back to standard traits, one needs the trait PreVectorSpace, found in Figure 6. (The trait DistributiveRingAction is found in <ref> [30] </ref>, the other traits are from [18, Appendix A].) Now that we are done with the initial mathematical modeling, we can turn to the behavioral interface specifications. 5 PreVector (T): trait assumes RingWithUnit, Abelian (* for ffi), TotalOrder, CoerceToReal (T) includes PreVectorSpace (T), Real introduces __ __: Vec [T], Vec [T]
Reference: [31] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [32] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32(8) </volume> <pages> 705-778, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [33] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In this paper Hoare introduced the use of an abstraction function, A, that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this set are consequently called abstract values <ref> [33] </ref>. The idea is that one specifies the ADT using the mathematical values, which allows clients of the ADT's operations to reason about calls without worrying about the details of the implementation. A model-based specification language combines these ideas.
Reference: [34] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> Novem-ber </month> <year> 1994. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can 6 act as if they are objects of type T <ref> [4, 5, 31, 27, 34, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; moreover, it would make certain of the classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [12].
Reference: [35] <author> Silvio Lemos Meira and Ana Lucia C. Cavalcanti. </author> <title> MooZ case studies. </title> <editor> In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 37-58. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ <ref> [35, 36] </ref>, and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ <ref> [35, 36] </ref>, VDM++ [38], Z++ [26, 25], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract
Reference: [36] <author> Silvio Lemos Meira, Ana Lucia C. Cavalcanti, and Cassio Souza Santos. </author> <title> The Unix filing system: A MooZ specification. </title> <editor> In Kevin Lano and Howard Haughton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> The Object-Oriented Series, chapter 4, </booktitle> <pages> pages 80-109. </pages> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ <ref> [35, 36] </ref>, and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ <ref> [35, 36] </ref>, VDM++ [38], Z++ [26, 25], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract
Reference: [37] <author> Tan Yang Meng. </author> <title> Formal Specification Techniques for Engineering Modular C Programs, </title> <booktitle> volume 1 of Kluwer International Series in Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool (like the LCLint tool for checking C programs based on LCL specifications <ref> [46, 45, 37] </ref>) or in formal verification. Traits, including those that define the abstract model are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [46, 45, 37] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and the postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [46, 45, 37] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [38] <author> Swapan Mitra. </author> <title> Object-oriented specification in VDM++. </title> <editor> In Kevin Lano and Howard Haughton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> The Object-Oriented Series, chapter 6, </booktitle> <pages> pages 130-136. </pages> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ <ref> [38] </ref>. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [39, 40], MooZ [35, 36], VDM++ <ref> [38] </ref>, Z++ [26, 25], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's
Reference: [39] <editor> Gordon Rose. Object-Z. In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 59-77. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z <ref> [39, 40] </ref>, OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z <ref> [39, 40] </ref>, MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or
Reference: [40] <author> Gordon Rose and Roger Duke. </author> <title> An Object-Z specification of a mobile phone system. </title> <editor> In Kevin Lano and Howard Haughton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> The Object-Oriented Series, chapter 5, </booktitle> <pages> pages 110-129. </pages> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z <ref> [39, 40] </ref>, OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z <ref> [39, 40] </ref>, MooZ [35, 36], VDM++ [38], Z++ [26, 25], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or
Reference: [41] <author> J. Spivey. </author> <title> An introduction to Z and formal specifications. </title> <journal> Software Engineering Journal, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. It also specifies ADTs using mathematical value spaces, called abstract models. The best-known model-based specification languages are VDM-SL [23] and Z <ref> [42, 41, 19] </ref>. Both come with a mathematical toolkit from which a user fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 can assemble abstract models for use in specifying procedures.
Reference: [42] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. It also specifies ADTs using mathematical value spaces, called abstract models. The best-known model-based specification languages are VDM-SL [23] and Z <ref> [42, 41, 19] </ref>. Both come with a mathematical toolkit from which a user fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 can assemble abstract models for use in specifying procedures.
Reference: [43] <author> Susan Stepney, Rosalind Barden, and David Cooper, </author> <title> editors. Object Orientation in Z. Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. The set of examples specifies a hierarchy of shapes that is used as a test case in the book Object Orientation in Z <ref> [43] </ref>. (The Larch/C++ specifications generally follow the Fresco [49] and ZEST [11] versions of the specifications.) 2 Quadrilaterals To write a specification in Larch/C++, one specifies an abstract model in LSL, and then uses that to specify the C++ interface and its behavior. <p> The trait FourSidedFigure defines the type Edges as a tuple of four Vector values. As a convenience, the trait also introduces the operator, __ [__], which allows one to write e [1] instead of e.v1. In the asserts section, the specification states the condition on four-sided figures from <ref> [43] </ref>: that the vectors have to sum to zero (make a loop). In the implies section this property is stated in an equivalent way. In [43], vectors are usually treated as a given set, meaning that their specification is of no interest. <p> In the asserts section, the specification states the condition on four-sided figures from <ref> [43] </ref>: that the vectors have to sum to zero (make a loop). In the implies section this property is stated in an equivalent way. In [43], vectors are usually treated as a given set, meaning that their specification is of no interest. <p> The specifications in <ref> [43] </ref> are a bit vague on exactly what capabilities are needed by the scalar type (which is named Scalar in FourSidedFigure and T in the trait PreVector). <p> The reason for this is that, if we follow <ref> [43, Chapter 2] </ref>, then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> The reason for this is that, if we follow [43, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. If we were to follow the class hierarchy given on page 8 of <ref> [43] </ref>, there would be problems, because as described there the classes Rectangle, Rhombus, and Square would be subtypes but not behavioral subtypes of the types of their superclasses. <p> The Larch/C++ specification of the abstract class QuadShape is given in Larch/C++, one could also specify QuadShape as a C++ template class with the types Vector and Scalar as type parameters [29, Chapter 8], but the approach adopted here is more in keeping with the examples in <ref> [43] </ref>. In the specification of QuadShape, the first thing to note is that much of the syntax is the same as in C++. Indeed, all of the C++ declaration syntax (with a few ambiguities removed) is supported by Larch/C++. <p> The specification of ShearBy illustrates another feature of Larch/C++: informal predicates. An informal predicate looks like the keyword informally, followed by a string constant. Such a predicate can be used to suppress details about a specification. This is done frequently in the specifications in <ref> [43] </ref> by using comments instead of formal specifications when discussing shearing. This also illustrates how one can use informal predicates to "tune" the level of formality in a Larch/C++ specification. <p> For example, in Larch/C++ one could start out by using largely informal specifications, and then increase the level of formality as needed or desired. 3 Other Subtypes of QuadShape This section contains the behavioral interface specifications of the other sub-types of QuadShape described in <ref> [43] </ref>. As in [11], we start with the abstract type ParallelShape, which is shown in Figure 11. This specification has two interesting features. The first an invariant clause. <p> The glyph * is typed "any by users.) The operator isaParallelogram is specified in the trait shown in Figure 12. The other interesting aspect (apparently overlooked in all the specifications in <ref> [43] </ref>) is that if all the sides of a quadrilateral are zero length, then the angle to be returned by AnglePar is not well defined. The specification of AnglePar illustrates how to specify exceptions in Larch/C++. <p> The class specification also specifies the default constructor. Turning to another concrete class specification, the type Parallelogram (which is specified in Figure 14) is public subclass of both Quadrilateral and ParallelShape. (This follows the design in <ref> [43] </ref>; whether this is a good idea for a design in C++ is debatable.) It inherits the specifications of each, including the ShearBy member function of Quadrilateral, and the invariant from ParallelShape. This is done by specifying a simulation function for each supertype. <p> The trait IsaSquare, given in Figure 20, is used in the specification of the constructor to state a claim that follows from the inherited invariant, but which might not otherwise be obvious. 4 Discussion and Conclusions The shapes example from <ref> [43] </ref> is perhaps not ideal for illustrating the mechanisms in Larch/C++ used for specification inheritance, as the subtypes all use isomorphic spaces of abstract values. In [12], we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. <p> In [12], we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in <ref> [43] </ref>. <p> = v1 ^ self'.position = pos; claims liberally isaSquare (self'.edges); - 15 IsaSquare: trait includes IsaRectangle, IsaRhombus introduces isaSquare: Edges ! Bool asserts 8 e: Edges isaSquare (e) == isaRectangle (e) ^ isaRhombus (e); * The LSL traits specified in the examples correspond roughly to the Z specifications given in <ref> [43, Chapter 2] </ref>. This says that LSL is roughly comparable to Z in terms of modeling power. <p> However, LSL includes syntax for stating redundant properties of traits, which may help catch errors in such mathematical modeling. * The behavioral interface specifications are roughly comparable to the various OO specifications written in the OO specification languages in <ref> [43] </ref>, in particular to ZEST and Fresco. However, only for Fresco is there even a hint [49, p. 135] that it may be able to specify the C++ interface details that Larch/C++ can specify. It is important that a formal specification language not require one to formalize every detail.
Reference: [44] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Larch/C++ [29] is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ <ref> [13, 44] </ref> program module. 1.1 Model-Based Specification The idea of a model-based specifications builds on two seminal papers by Hoare. Hoare's paper "An Axiomatic Basis for Computer Programming" [21], used two predicates over program states to specify a computation.
Reference: [45] <author> Yang Meng Tan. </author> <title> Formal specification techniques for promoting software modularity, enhancing documentation, and testing specifications. </title> <type> Technical Report 619, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, Mass., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool (like the LCLint tool for checking C programs based on LCL specifications <ref> [46, 45, 37] </ref>) or in formal verification. Traits, including those that define the abstract model are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [46, 45, 37] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and the postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [46, 45, 37] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [46] <author> Yang Meng Tan. </author> <title> Interface language for supporting programming styles. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 74-83, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the Workshop on Interface Definition Languages. </booktitle> <pages> 19 </pages>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool (like the LCLint tool for checking C programs based on LCL specifications <ref> [46, 45, 37] </ref>) or in formal verification. Traits, including those that define the abstract model are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [46, 45, 37] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and the postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [46, 45, 37] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [47] <author> Alan Wills. </author> <title> Capsules and types in Fresco: Program validation in Smalltalk. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 59-76. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" <ref> [47, 48] </ref> that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [47, 49, 48] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when 16 combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [48] <author> Alan Wills. </author> <title> Refinement in Fresco. </title> <editor> In Kevin Lano and Howard Houghton, editors, </editor> <title> Object-Oriented Specification Case Studies, </title> <booktitle> chapter 9, </booktitle> <pages> pages 184-201. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" <ref> [47, 48] </ref> that are "derived from C++ and Smalltalk" [49, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [47, 49, 48] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when 16 combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [49] <author> Alan Wills. </author> <title> Specification in Fresco. </title> <editor> In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, chapter 11, </booktitle> <pages> pages 127-135. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [26, 25], ZEST [11], Object-Z [39, 40], OOZE [1, 2, 3], MooZ [35, 36], and VDM++ [38]. However, apparently there are "variants of Fresco" [47, 48] that are "derived from C++ and Smalltalk" <ref> [49, p. 135] </ref>; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. The set of examples specifies a hierarchy of shapes that is used as a test case in the book Object Orientation in Z [43]. (The Larch/C++ specifications generally follow the Fresco <ref> [49] </ref> and ZEST [11] versions of the specifications.) 2 Quadrilaterals To write a specification in Larch/C++, one specifies an abstract model in LSL, and then uses that to specify the C++ interface and its behavior. <p> (T): trait assumes RingWithUnit, Abelian (* for ffi) includes AbelianGroup (Vec [T] for T, + for ffi, 0 for unit, - __ for 1 ), DistributiveRingAction (T for M, Vec [T] for T) % ... implications omitted ... 2.2 Specification of QuadShape and Quadrilateral Following the ZEST [11] and Fresco <ref> [49] </ref> specifications of this shapes example, we start with an abstract class of four-sided figures, QuadShape. The reason for this is that, if we follow [43, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> However, only for Fresco is there even a hint <ref> [49, p. 135] </ref> that it may be able to specify the C++ interface details that Larch/C++ can specify. It is important that a formal specification language not require one to formalize every detail. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [47, 49, 48] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when 16 combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [50] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [51, 50, 18] </ref>. * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU <ref> [51, 50] </ref> (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
Reference: [51] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year> <month> 20 </month>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [51, 50, 18] </ref>. * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU <ref> [51, 50] </ref> (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
References-found: 51

