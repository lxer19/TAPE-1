URL: http://www.cs.wisc.edu/~cao/papers/pfpaper.ps.Z
Refering-URL: http://www.cs.wisc.edu/~cao/papers/
Root-URL: 
Email: fgid,caog@cs.wisc.edu  
Title: Adaptive Page Replacement Based on Memory Reference Behavior  
Author: Gideon Glass and Pei Cao 
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: As disk performance continues to lag behind that of memory systems and processors, virtual memory management becomes increasingly important for overall system performance. In this paper we study the page reference behavior of a collection of memory-intensive applications, and propose a new virtual memory page replacement algorithm, SEQ. SEQ detects long sequences of page faults and applies most-recently-used replacement to those sequences. Simulations show that for a large class of applications, SEQ performs close to the optimal replacement algorithm, and significantly better than Least-Recently-Used (LRU). In addition, SEQ performs similarly to LRU for applications that do not exhibit sequential faulting. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, P.J. Denning, and J.D. Ullman. </author> <title> Principles of optimal page replacement. </title> <journal> In Journal of ACM, </journal> <volume> vol. 18, </volume> <pages> pages 80-93, </pages> <month> January </month> <year> 1971. </year>
Reference-contexts: A good survey on early research results on paging policies can be found in [12]. There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference <ref> [1] </ref>, LRU stack [26], working set [9], access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found [12, 15, 17].
Reference: [2] <author> L. A. Belady. </author> <title> A study of replacement algorithms for virtural storage. </title> <journal> IBM Systems Journal, </journal> <pages> pages 5 78-101, </pages> <year> 1966. </year>
Reference-contexts: We simulated the Least-Recently Used (LRU) page replacement algorithm and the optimal o*ine algorithm (Be-lady's OPT algorithm <ref> [2] </ref>) for these applications under varying main memory sizes. For the applications that has no visible, large-scale access patterns, both LRU and OPT show gradual, continuous reduction in page fault rate as memory size increases. LRU appears to be a good replacement policy for such programs. <p> Belady's paper in 1966 <ref> [2] </ref> introduced the optimal o*ine replacement algorithm (the OPT algorithm). A good survey on early research results on paging policies can be found in [12]. There have also been many studies on program behavior modelling and optimal online algorithms for each model. <p> A recent study [11] investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement <ref> [3, 2, 7, 20] </ref>, one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs [18]. SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9].
Reference: [3] <author> A. </author> <title> Bensoussan, C.T. Clingen, and R.C. Daley. The mul-tics virtual memory: Concepts and design. </title> <journal> In Communications of the ACM, </journal> <volume> 15(5), </volume> <pages> pages 308-318, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: A recent study [11] investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement <ref> [3, 2, 7, 20] </ref>, one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs [18]. SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9].
Reference: [4] <author> A. Borodin, S. Irani, P. Raghavan, and B. Schieber. </author> <title> Competitive paging with locality of reference. </title> <booktitle> In Proc. 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 249-259, </pages> <year> 1991. </year>
Reference-contexts: A good survey on early research results on paging policies can be found in [12]. There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs <ref> [4] </ref>, and the Markov model [17]. For each of these models, optimal online algorithms are found [12, 15, 17]. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. <p> The models include independent reference [1], LRU stack [26], working set [9], access graphs <ref> [4] </ref>, and the Markov model [17]. For each of these models, optimal online algorithms are found [12, 15, 17]. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time.
Reference: [5] <author> D.C. Burger, A. Kagi, and J.R. Goodman. </author> <title> Memory bandwidth limitations of future microprocessors. </title> <booktitle> In The 23rd Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Recently there have been a number of studies of applications' memory reference behavior in the context of cache management. One study regarding processor pin bandwidth requirements <ref> [5] </ref> confirmed that there is a significant difference in cache miss ratios under LRU and under OPT the LRU curve, and SEQ:L=50:M=20 overlaps LRU most of the time. For perl, the parameter changes only result in slight performance differences.
Reference: [6] <author> Pei Cao, Edward W. Felten, Anna R. Karlin, and Kai Li. </author> <title> A study of integrated prefetching and caching strategies. </title> <booktitle> In Proc. 1995 ACM SIGMETRICS, </booktitle> <pages> pages 188-197, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Good replacement policies, on the other hand, reduce both bandwidth consumption and latency. In this paper we focused on replacement algorithms only; how to balance prefetching and cache management (page replacement) is a complicated issue that needs further study <ref> [6] </ref>. 6 Conclusions and Future Work Our study of application reference behavior and space-time graphs shows that applications' memory reference behavior varies significantly. There are at least three categories: no visible access pattern, minor observable patterns, and regular patterns.
Reference: [7] <author> R. W. Carr and J. L. Hennessy. </author> <title> WSCLOCK | A simple and effective algorithm for virtual memory management. </title> <booktitle> In Proc. 8th SOSP, Operating Sys. Review, </booktitle> <pages> page 87, </pages> <month> December </month> <year> 1981. </year> <title> Published as Proc. 8th SOSP, Operating Sys. </title> <journal> Review, </journal> <volume> volume 15, number 5. </volume>
Reference-contexts: A recent study [11] investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement <ref> [3, 2, 7, 20] </ref>, one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs [18]. SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9].
Reference: [8] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <type> Technical Report SMLI 93-12, </type> <institution> UWCSE 93-06-06, Sun Mi-crosystems Labs, </institution> <year> 1993. </year>
Reference-contexts: Shown for each program is the number of instructions executed by the traced program and the amount of total memory used by the program. (Other columns in the table will be described further below.) 2.1 Trace Methodology We collected memory reference traces using Shade <ref> [8] </ref>, an instruction-level trace generator for the SPARC architecture. All programs ran on machines running the So-laris 2.4 operating system. Because of the length of our traces, recording all memory references individually would result in unmanageably large trace files. Instead, we record "IN" and "OUT" records.
Reference: [9] <author> Peter J. Denning. </author> <title> The working set model for program behavior. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 323-333, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: A good survey on early research results on paging policies can be found in [12]. There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set <ref> [9] </ref>, access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found [12, 15, 17]. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. <p> SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs <ref> [9] </ref>. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies [28, 14, 21, 19]. These studies focus on mechanisms by which applications inform the kernel about what pages would be good candidates for replacements. Our SEQ algorithm is basically the antithesis of such schemes.
Reference: [10] <author> Peter J. Denning. </author> <title> Working sets past and present. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):64-84, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: This "LRU flooding" phenomenon is the primary motivation for our SEQ algorithm, described in the next section. Our observations of program memory behavior arrive at different conclusions from some early research results, such as those described in Denning's excellent survey <ref> [10] </ref>. The two biggest differences are that the applications we investigated do not generally have significant "phase-transition" behavior as their reference patterns tend to be the same throughout execution (i.e. no phases). <p> Also, there are no identifiable working-sets, and no clear "knees" in the fault curve, contrary to what is observed in <ref> [10] </ref>. (See more discussions in [13]). 3 SEQ Replacement Algorithm The intuition behind the SEQ replacement algorithm is to detect long sequences of page faults and apply MRU replacement to such sequences.
Reference: [11] <author> Amos Fait and Ziv Rosen. </author> <title> Experimental studies of access graph based heuristics: </title> <booktitle> Beating the LRU standard? In 1997 SIAM Symposium on Discrete Algorithms, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time. A recent study <ref> [11] </ref> investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. <p> However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time. A recent study <ref> [11] </ref> investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement [3, 2, 7, 20], one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs [18].
Reference: [12] <author> Edward G. Coffman, Jr. and Peter J. Denning. </author> <title> Operating Systems Theory. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1973. </year>
Reference-contexts: In real systems, multiple processes run at the same time and compete for memory. There are two general approaches to page replacement in multi-process environments <ref> [12] </ref>. One approach involves a memory allocation policy that allocates memory to different processes, and a page replacement policy that chooses replacements among each process' pages when processes exceed their memory allotments. <p> Belady's paper in 1966 [2] introduced the optimal o*ine replacement algorithm (the OPT algorithm). A good survey on early research results on paging policies can be found in <ref> [12] </ref>. There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs [4], and the Markov model [17]. <p> There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found <ref> [12, 15, 17] </ref>. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time.
Reference: [13] <author> Gideon Glass and Pei Cao. </author> <title> Adaptive page replacement based on memory reference behavior. </title> <type> Technical Report 1338, </type> <institution> UW-Madison Computer Sciences Department, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Due to space constraints we cannot include all space-time graphs. Following pages contain four representative samples of the variety of the memory reference behavior for the sixteen applications. (Every application's memory behavior is different from the rest. We refer interested readers to <ref> [13] </ref> for all the space-time plots.) Observing the space-time graphs, we found that the applications fall into three categories. The first, which includes coral, murphi, m88ksim and vortex, are truly memory intensive|large numbers of pages are accessed during each execution interval. <p> Also, there are no identifiable working-sets, and no clear "knees" in the fault curve, contrary to what is observed in [10]. (See more discussions in <ref> [13] </ref>). 3 SEQ Replacement Algorithm The intuition behind the SEQ replacement algorithm is to detect long sequences of page faults and apply MRU replacement to such sequences. The goal is to avoid LRU flooding, which occurs when a program accesses a large address space range sequentially. <p> Thus, we set N = 5. In summary, we found that the performance of the SEQ algorithm is fairly insensitive to the parameter values, and our current settings appear appropriate, though we plan further testing on this issue. More details are available in <ref> [13] </ref>. 4 SEQ as a Global Replacement Algorithm So far our discussion has focused on the performance of various replacement policies for single applications. In real systems, multiple processes run at the same time and compete for memory. There are two general approaches to page replacement in multi-process environments [12].
Reference: [14] <author> K. Harty and D. R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proc. Fifth International Conf. on Architectural Support for Programming Languages and Operating Systems, SIGOPS Operating Systems Review Special Issue, </booktitle> <volume> volume 26, </volume> <pages> page 187, </pages> <address> Boston, MA, </address> <month> October 12-15 </month> <year> 1992. </year>
Reference-contexts: SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9]. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies <ref> [28, 14, 21, 19] </ref>. These studies focus on mechanisms by which applications inform the kernel about what pages would be good candidates for replacements. Our SEQ algorithm is basically the antithesis of such schemes. It will be interesting to see over time which philosophy prevails.
Reference: [15] <author> S. Irani, A. Karlin, and S. Phillips. </author> <title> Strongly competitive algorithms for paging with locality of reference. </title> <booktitle> In 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 228-236, </pages> <year> 1992. </year>
Reference-contexts: There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found <ref> [12, 15, 17] </ref>. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time.
Reference: [16] <author> Norman P. Jouppi. </author> <title> Improving direct-mapped cache performance by the addition of a small fully-associative cache and prefetch buffers. </title> <booktitle> In The 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 364-373, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. Sequence detection can be used for prefetching purposes as well. Indeed there are sequence detectors for prefetch-ing in hardware cache management <ref> [27, 16, 22] </ref>. However, prefetching does not reduce bandwidth consumption; it merely reduces latency by overlapping I/O with computation. Good replacement policies, on the other hand, reduce both bandwidth consumption and latency.
Reference: [17] <author> Anna R. Karlin, Steven J. Phillips, and Prabhakar Raghavan. </author> <title> Markov paging. </title> <booktitle> In Proc. 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 208-217, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs [4], and the Markov model <ref> [17] </ref>. For each of these models, optimal online algorithms are found [12, 15, 17]. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. <p> There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [26], working set [9], access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found <ref> [12, 15, 17] </ref>. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams. However, most theoretical studies on access-graph algorithms assume that the graph is known ahead of time, rather than being constructed at run-time.
Reference: [18] <author> T. Kilburn, D. B. G. Edwards, M. J. Lanigan, and F. H. Sumner. </author> <title> One-level storage system. </title> <journal> In IEEE Transaction on Electronic Communications, </journal> <pages> pages 223-235, </pages> <month> April </month> <year> 1962. </year>
Reference-contexts: Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement [3, 2, 7, 20], one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs <ref> [18] </ref>. SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9]. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies [28, 14, 21, 19].
Reference: [19] <author> Chao-Hsien Lee, Meng Chang Chen, and Ruei-Chuan Chang. </author> <title> HiPEC: High performance external virtual memory caching. </title> <booktitle> In Proceedings of the First Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 153-164, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9]. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies <ref> [28, 14, 21, 19] </ref>. These studies focus on mechanisms by which applications inform the kernel about what pages would be good candidates for replacements. Our SEQ algorithm is basically the antithesis of such schemes. It will be interesting to see over time which philosophy prevails.
Reference: [20] <author> H. M. Levy and P. H. Lipman. </author> <title> Virtual memory management in the VAX/VMS operating system. </title> <journal> IEEE Computer, </journal> <volume> 15(3) </volume> <pages> 35-41, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: A recent study [11] investigated constructing the graph at run-time; however the study only looked at references to program text, not data. Also, the algorithm proposed in [11] is more complex and more expensive than SEQ. Although most early experimental studies focused on efficient approximation of LRU page replacement <ref> [3, 2, 7, 20] </ref>, one scheme, the Atlas Loop Detector, investigated loop detection and MRU replacement on scientific programs [18]. SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9].
Reference: [21] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the Mach external pager interface to accommodate user-level page replacement policies. </title> <booktitle> In Proceedings of USENIX Mach Symposiumi '91, </booktitle> <pages> pages 17-29, </pages> <year> 1990. </year>
Reference-contexts: SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9]. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies <ref> [28, 14, 21, 19] </ref>. These studies focus on mechanisms by which applications inform the kernel about what pages would be good candidates for replacements. Our SEQ algorithm is basically the antithesis of such schemes. It will be interesting to see over time which philosophy prevails.
Reference: [22] <author> Subbarao Palacharla and R. E. Kessler. </author> <title> Evaluating stream buffers as a secondary cache replacement. </title> <booktitle> In Proc. 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 24-33, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. Sequence detection can be used for prefetching purposes as well. Indeed there are sequence detectors for prefetch-ing in hardware cache management <ref> [27, 16, 22] </ref>. However, prefetching does not reduce bandwidth consumption; it merely reduces latency by overlapping I/O with computation. Good replacement policies, on the other hand, reduce both bandwidth consumption and latency.
Reference: [23] <author> Sharon E. Perl and Richard L. </author> <title> Sites. Studies of windows NT performance using dynamic execution traces. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating Systems Design and Implementation (OSDI'96), </booktitle> <address> Seattle, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: For perl, the parameter changes only result in slight performance differences. For swim, SEQ:L=50:M=50 performs noticably worse than LRU for small memory sizes. replacement policies. Another study <ref> [23] </ref> included space--time graphs for some SPEC95 benchmarks. Though their graphs are for a much shorter duration of execution execution (on the order of one second), the graphs are similar to our graphs for the SPEC95 benchmarks.
Reference: [24] <author> Rob Pike. </author> <booktitle> Notes on programming in C, </booktitle> <month> February </month> <year> 1989. </year> <note> Available at http://www.lysator.liu.se/c/ pikestyle.html. </note>
Reference-contexts: These classes of behavior remind us of the following comment by Rob Pike: "The following data structures are a complete list for almost all practical programs: array, linked list, hash table, binary tree." <ref> [24] </ref> The statement clearly has some truth to it: most applications exhibiting regular reference patterns are array-based; vortex, m88ksim, murphi, coral, and perl are apparently either making heavy use of hash tables or are traversing tree structures; gcc and perl (to some extent) seem to use linked lists heavily.
Reference: [25] <author> E. Rothberg, J.P. Singh, and A. Gupta. </author> <title> Working sets, cache sizes, and node granularity issues for large-scale multiprocessors. </title> <booktitle> In The 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 14-26, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Though their graphs are for a much shorter duration of execution execution (on the order of one second), the graphs are similar to our graphs for the SPEC95 benchmarks. Finally, one study of large-scale multiprocessor architectures investigated the "working-set" and cache size issues for parallel scientific applications <ref> [25] </ref>. The study investigated a number of parallel applications, measuring their "working-sets" by simulating the number of cache misses versus cache sizes under the LRU replacement. The cache misses versus cache size curves in [25] are quite similar to our LRU page fault curves for scientific applications. <p> study of large-scale multiprocessor architectures investigated the "working-set" and cache size issues for parallel scientific applications <ref> [25] </ref>. The study investigated a number of parallel applications, measuring their "working-sets" by simulating the number of cache misses versus cache sizes under the LRU replacement. The cache misses versus cache size curves in [25] are quite similar to our LRU page fault curves for scientific applications. These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. Sequence detection can be used for prefetching purposes as well.
Reference: [26] <author> G. S. Shedler and C. Tung. </author> <title> Locality in page reference string. </title> <journal> In SIAM J. Computer, </journal> <volume> vol. 1, </volume> <pages> pages 218-241, </pages> <month> September </month> <year> 1972. </year>
Reference-contexts: A good survey on early research results on paging policies can be found in [12]. There have also been many studies on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack <ref> [26] </ref>, working set [9], access graphs [4], and the Markov model [17]. For each of these models, optimal online algorithms are found [12, 15, 17]. The SEQ algorithm is similar to the access-graph algorithms [4] in that it tries to take advantage of patterns found in reference streams.
Reference: [27] <author> Alan Jay Smith. </author> <title> Sequential program prefetching in memory hierarchies. </title> <journal> IEEE Computer, </journal> <volume> 11(12) </volume> <pages> 7-21, </pages> <month> De-cember </month> <year> 1978. </year>
Reference-contexts: These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. Sequence detection can be used for prefetching purposes as well. Indeed there are sequence detectors for prefetch-ing in hardware cache management <ref> [27, 16, 22] </ref>. However, prefetching does not reduce bandwidth consumption; it merely reduces latency by overlapping I/O with computation. Good replacement policies, on the other hand, reduce both bandwidth consumption and latency.
Reference: [28] <author> Michael Young, Avadis Tevanian, Richard Rashid, David Golub, Jeffrey Eppinger, Jonathan Chew, William Bolosky, David Black, and Robert Baron. </author> <title> The Duality of Memory and Communication in the implementation of a Multiprocessor Operating System. </title> <booktitle> In The Proceedings of the 11th Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: SEQ differs from the loop detector in that it tries hard to work well on applications where LRU is appropriate. The Atlas scheme apparently performed poorly for non-scientific programs [9]. Recent research projects on application-controlled kernels show the potential of application-specific replacement policies <ref> [28, 14, 21, 19] </ref>. These studies focus on mechanisms by which applications inform the kernel about what pages would be good candidates for replacements. Our SEQ algorithm is basically the antithesis of such schemes. It will be interesting to see over time which philosophy prevails.
References-found: 28

