URL: ftp://cse.ogi.edu/pub/crml/dood93.ps.Z
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Email: ffegaras,maier,sheardg@cse.ogi.edu  
Title: Specifying Rule-based Query Optimizers in a Reflective Framework  
Author: Leonidas Fegaras, David Maier, Tim Sheard 
Address: 20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: Numerous structures for database query optimizers have been proposed. Many of those proposals aimed at automating the construction of query optimizers from some kind of specification of optimizer behavior. These specification frameworks do a good job of partitioning and modularizing the kinds of information needed to generate a query optimizer. Most of them represent at least part of this information in a rule-like form. Nevertheless, large portions of these specifications still take a procedural form. The contributions of this work are threefold. We present a language for specifying optimizers that captures a larger portion of the necessary information in a declarative manner. This language is in turn based on a model of query rewriting where query expressions carry annotations that are propagated during query transformation and planning. This framework is reminiscent of inherited and synthesized attributes for attribute grammars, and we believe it is expressive of a wide range of information: logical and physical properties, both desired and delivered, cost estimates, optimization contexts, and control strategies. Finally, we present a mechanism for processing optimizer specifications that is based on compile-time reflection. This mechanism proves to be succinct and flexible, allowing modifications of the specification syntax, incorporation of new capabilities into generated optimizers, and retargeting the translation to a variety of optimization frameworks. We report on an implementation of our ideas using the CRML reflective functional language and on optimizer specifications we have written for several query algebras.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Blakeley, W. McKenna, and G. Graefe. </author> <title> Experiences Building the Open OODB Query Optimizer. </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <pages> pp 287-296, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This mapping can be captured in the form of a rule-based term-rewriting system <ref> [5, 6, 1] </ref>. The optimization process involves searching the space of equivalent program forms, generated mainly by the syntactic transformations captured as rewrite rules, and by the alternative access paths for accessing the same database objects, such as by the indices for retrieving data from relational tables. <p> That is, this rule propagates the expected order only to the outer relation of the join, because the order of the inner relation does not affect the sort order of the join result. Our experience with the Volcano optimizer generator <ref> [6, 1] </ref> revealed that there are some routinely performed coding tasks during an optimizer specification that are highly stereotyped and therefore amenable to automation. If they are not abstracted to system-supported primitives, they consume a lot of energy during coding and they may result in obscure code, vulnerable to errors. <p> This framework is similar to the one described by Mitchell, et al. [11]. 6 An Optimizer for an Object-Oriented Language In this section we specify an optimizer for object-oriented queries expressed in the ZQL [C++] language <ref> [1] </ref>. ZQL [C++] is an SQL-based object query language designed to be well-integrated with C++. Our approach to solving this optimization problem is influenced by the Volcano optimizer generator approach, as described by Blakeley, et al. [1]. <p> section we specify an optimizer for object-oriented queries expressed in the ZQL [C++] language <ref> [1] </ref>. ZQL [C++] is an SQL-based object query language designed to be well-integrated with C++. Our approach to solving this optimization problem is influenced by the Volcano optimizer generator approach, as described by Blakeley, et al. [1]. One example of a ZQL [C++] query is the following: select e.name, e.dept.name, e.job.name from Employee e in Employees where e.dept.plant.location="Dallas" In [1] this query is translated directly into the following expression: project (select (Mat (Mat (Mat (get (Employees):e, e.job):j, e.dept):d, d.plant):p, p.location="Dallas"), (e.name,j.name,d.name)) where the form e:x assigns the <p> Our approach to solving this optimization problem is influenced by the Volcano optimizer generator approach, as described by Blakeley, et al. <ref> [1] </ref>. One example of a ZQL [C++] query is the following: select e.name, e.dept.name, e.job.name from Employee e in Employees where e.dept.plant.location="Dallas" In [1] this query is translated directly into the following expression: project (select (Mat (Mat (Mat (get (Employees):e, e.job):j, e.dept):d, d.plant):p, p.location="Dallas"), (e.name,j.name,d.name)) where the form e:x assigns the name x (a range variable) to the output produced by expression e. <p> Rule 6 translates a selection over a table access into an indexed access, provided that there is an index for the selection predicate. 7 Related Work Our work is influenced by the EXODUS and Volcano optimizer generators <ref> [1, 5] </ref>. EXODUS allows the database implementer to write a customized optimizer by providing explicit rules.
Reference: 2. <author> D. Das. Prairie: </author> <title> An Algebraic Framework for Rule Specification in Query Optimiz-ers. </title> <type> Ph.D. Dissertation Proposal, </type> <institution> University of Texas at Austin, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Even though our work does not add more functionality to the the Volcano optimizer, we believe that our language is far clearer and more concise. There is a proposal for an improved interface to Volcano, called Prairie <ref> [2] </ref>. The Prairie specification forms are highly influenced by the ones of Volcano, but they are in a more abstract and declarative form.
Reference: 3. <author> J. C. Freytag and N. Goodman. </author> <title> Translating Aggregate Queries into Iterative Programs. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases, </booktitle> <address> Kyoto, Japan, </address> <pages> pp 138-146, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: There are other systems that use a declarative specification language to describe specific optimizers, but most of them, as far as we know, do not provide a specification implementation. One example is Freytag's work on rule-based query optimization for relational databases <ref> [3, 4] </ref>. 22 8 Conclusion and Future Work We believe our specification system for query optimizers is more comprehensive and more declarative than other systems to date.
Reference: 4. <author> J. C. Freytag. </author> <title> A Rule-Based View of Query Optimization. </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> San Francisco, </address> <publisher> Cali-fornia, </publisher> <pages> pp 173-180, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: There are other systems that use a declarative specification language to describe specific optimizers, but most of them, as far as we know, do not provide a specification implementation. One example is Freytag's work on rule-based query optimization for relational databases <ref> [3, 4] </ref>. 22 8 Conclusion and Future Work We believe our specification system for query optimizers is more comprehensive and more declarative than other systems to date.
Reference: 5. <author> G. Graefe and D. J. DeWitt. </author> <title> The EXODUS Optimizer Generator. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> San Francisco, California, </address> <pages> pp 160-171, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: This mapping can be captured in the form of a rule-based term-rewriting system <ref> [5, 6, 1] </ref>. The optimization process involves searching the space of equivalent program forms, generated mainly by the syntactic transformations captured as rewrite rules, and by the alternative access paths for accessing the same database objects, such as by the indices for retrieving data from relational tables. <p> Experience with query optimizers and other term-rewriting systems suggests the need for more sophisticated context control. For example, query optimizers for relational databases that support sort-merge joins need to enforce sort order on some subplans <ref> [5, 9] </ref>. In addition, there are often groups of rules that should be applied in a strict or partial order. In general, there might exist a transformation script that describes a strategy for the successive application of atomic transformations. <p> Examples of inherited attributes include logical properties that need to be propagated and physical properties that need to be enforced. This scheme is consistent with other rule-based systems in the literature <ref> [5, 9] </ref>. One example of logical properties is schema information, such as relation names associated with their column names. <p> Rule 6 translates a selection over a table access into an indexed access, provided that there is an index for the selection predicate. 7 Related Work Our work is influenced by the EXODUS and Volcano optimizer generators <ref> [1, 5] </ref>. EXODUS allows the database implementer to write a customized optimizer by providing explicit rules.
Reference: 6. <author> G. Graefe and W. McKenna. </author> <title> The Volcano Optimizer Generator: Extensibility and Efficient Search. </title> <booktitle> IEEE Conference on Data Engineering, </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: This mapping can be captured in the form of a rule-based term-rewriting system <ref> [5, 6, 1] </ref>. The optimization process involves searching the space of equivalent program forms, generated mainly by the syntactic transformations captured as rewrite rules, and by the alternative access paths for accessing the same database objects, such as by the indices for retrieving data from relational tables. <p> By using term-rewriting systems with attributes we gain many advantages [14]. The attribute grammar framework is adequate to capture other optimizer specification frameworks, such as Volcano <ref> [6] </ref>, in a more uniform and concise way. In fact, attributes are generalizations of logical and physical properties used in that and other optimizer frameworks. In addition, specifications are clearer because of 3 the functional evaluation of attributes. <p> That is, this rule propagates the expected order only to the outer relation of the join, because the order of the inner relation does not affect the sort order of the join result. Our experience with the Volcano optimizer generator <ref> [6, 1] </ref> revealed that there are some routinely performed coding tasks during an optimizer specification that are highly stereotyped and therefore amenable to automation. If they are not abstracted to system-supported primitives, they consume a lot of energy during coding and they may result in obscure code, vulnerable to errors. <p> the specification itself but only the macros. 4 Example: a Simple Optimizer for SQL Before describing the complete syntax of our optimizer specification language, we present an example taken from the well-known domain of query optimization for relational databases [12], and inspired by the approach of the Volcano optimizer generator <ref> [6] </ref>. 4.1 Attribute Specification The following declaration in our specification language defines the inherited and synthesized attribute names used by the SQL optimizer: &lt;attributes< sql, inherited: order: columns, indices: (string * columns) list -, synthesized: order: columns, size: int, cardinality: int, cost: real - = -order=[],size=1,cardinality=0,cost=max_real-, iequal = fn (x,y) =&gt;
Reference: 7. <author> A. Kemper and G. Moerskotte. </author> <title> Advanced Query Processing in Object Bases Using Access Support Relations. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <address> Brisbane, Australia, </address> <pages> pp 290-301. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <month> August </month> <year> 1990. </year>
Reference-contexts: Performing a projection such as Employees.department can then be achieved by the join join (get (Employees,x),get (Departments,y),x.department=y.self). In addition, some chains of object links are stored explicitly as path indices (or access support relations <ref> [7] </ref>). Path indices are implemented as binary relations with columns from and to. They are indexed on from (our optimizer can be easily extended to support inverse path indices, that is, paths indexed on column to). This information is stored in the inherited attribute path_indices.
Reference: 8. <author> D. Knuth. </author> <title> Semantics of Context-free Languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2(2) </volume> <pages> 127-145, </pages> <month> June </month> <year> 1968. </year> <month> 23 </month>
Reference-contexts: The alternative is to incorporate this knowledge about rule ordering as part of the rewrite context, switching context after each rule application. This approach implies that rules should not consist of pure syntactic transformations only, but include semantic transformations to the context as well. Attribute grammars <ref> [8] </ref> suggest a method of solving this problem: they provide a declarative way of expressing both syntactic and semantic transformations. Attribute grammars have been introduced as a method to describe context-sensitive semantics on top of a context-free syntactic base. <p> Our optimizer specification language is very close to the language that one might use to specify an optimizer by writing it down on paper. This form facilitates error-free optimizer specifications as well as experimentation and fast prototyping. Our rule-based term-rewriting system is based on attribute grammars <ref> [8] </ref>. An attribute list is a binding from a fixed set of attribute names to values. Each optimizer expressed in our specification language will have two attribute lists: inherited and synthesized. The inherited attributes provide context during term-rewriting. Suppose that we are currently rewriting a term t.
Reference: 9. <author> G. M. Lohman. </author> <title> Grammar-like Functional Rules for Representing Query Optimiza--tion Alternatives. </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Chicago, </address> <publisher> Illinois, </publisher> <pages> 13(3) 18-27, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Experience with query optimizers and other term-rewriting systems suggests the need for more sophisticated context control. For example, query optimizers for relational databases that support sort-merge joins need to enforce sort order on some subplans <ref> [5, 9] </ref>. In addition, there are often groups of rules that should be applied in a strict or partial order. In general, there might exist a transformation script that describes a strategy for the successive application of atomic transformations. <p> Examples of inherited attributes include logical properties that need to be propagated and physical properties that need to be enforced. This scheme is consistent with other rule-based systems in the literature <ref> [5, 9] </ref>. One example of logical properties is schema information, such as relation names associated with their column names. <p> Another extensible query optimization framework based on attribute grammars is the one for Starburst, as described by Lohman <ref> [9] </ref>. This framework is not a rule-based term-rewriting system, even though their specifications define optimizers that perform term-rewriting. Each production rule (called a STAR) defines a transformation from a high-level non-terminal symbol into a low-level one. Query trees and plans (called LOLEPOPs) are passed as parameters to these symbols.
Reference: 10. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Most tree transformations require decomposition of trees into their components, construction of trees from their constituent subtrees, and pattern matching. These tasks can be facilitated in a language that directly supports programming based on such operations. Examples of such languages include most pattern-based functional programming languages, such as SML <ref> [10] </ref>. <p> CRML [13] is an implementation of compile--time reflection for a subset of SML, built on top of the Standard ML of New Jersey compiler <ref> [10] </ref>. Reflection is the "magic" that turns data into programs. Compile-time reflection allows user-written functions to access data calculated during compilation in order to construct program representations. These representations are then transformed, by reflection, into the programs they represent.
Reference: 11. <author> G. Mitchell, U. Dayal, and S. B. Zdonik. </author> <title> Control of an Extensible Query Optimizer: A Planning-Based Approach. </title> <booktitle> In Proceedings of the 19th VLDB Conference, </booktitle> <month> August </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: In fact we may have a hierarchy of rule systems where a non-leaf rule system controls the evaluation of its children. This framework is similar to the one described by Mitchell, et al. <ref> [11] </ref>. 6 An Optimizer for an Object-Oriented Language In this section we specify an optimizer for object-oriented queries expressed in the ZQL [C++] language [1]. ZQL [C++] is an SQL-based object query language designed to be well-integrated with C++. <p> We intend to produce additional optimizer specifications to validate this hypothesis, particularly ones that use attributes to control optimization context, in the manner of Mitchell, et al. <ref> [11] </ref>. We also intend to experiment with different search engines that support cost-based pruning. Another interesting research area is the development of specialized libraries of support functions to aid the optimizer specification process within a specific domain of applications.
Reference: 12. <author> P. Selinger, M. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, </address> <publisher> Mas-sachusetts, </publisher> <pages> pp 23-34, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: As before, there is no need for changing the specification itself but only the macros. 4 Example: a Simple Optimizer for SQL Before describing the complete syntax of our optimizer specification language, we present an example taken from the well-known domain of query optimization for relational databases <ref> [12] </ref>, and inspired by the approach of the Volcano optimizer generator [6]. 4.1 Attribute Specification The following declaration in our specification language defines the inherited and synthesized attribute names used by the SQL optimizer: &lt;attributes< sql, inherited: order: columns, indices: (string * columns) list -, synthesized: order: columns, size: int, cardinality:
Reference: 13. <author> T. Sheard. </author> <title> Guide to using CRML: Compile-Time Reflective ML. </title> <type> Unpublished manuscript, </type> <institution> Oregon Graduate Institute, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: In our specification language, we have a large portion of the specification amenable to manipulation. Fig. 1. The Architecture for Query Optimization and Evaluation The ability to process the specification code during the specification process itself requires the aid of reflection. We are using CRML <ref> [13] </ref>, a compile-time reflective version of SML, as the language for expressing both the specification of an optimizer and the processing of these specifications. CRML provides data structures that represent program fragments in SML. These data structures can be reflected into SML programs and compiled into machine code. <p> Section 7 presents the related work on extensible query optimizers. Finally, Section 8 concludes this paper. 2 Introduction to CRML Compile-time reflection introduces program-generation capability into a language, thereby enabling automatic generation of many of the functions needed to 6 build a solution for an application. CRML <ref> [13] </ref> is an implementation of compile--time reflection for a subset of SML, built on top of the Standard ML of New Jersey compiler [10]. Reflection is the "magic" that turns data into programs. Compile-time reflection allows user-written functions to access data calculated during compilation in order to construct program representations.
Reference: 14. <author> R. Wilhelm. </author> <title> Tree Transformations, Functional Languages, and Attribute Grammars. </title> <booktitle> Proceedings of the International Workshop on Attribute Grammars and their Applications, Paris, France, </booktitle> <pages> pp 116-129, </pages> <month> September </month> <year> 1990. </year> <note> LNCS 461. 24 </note>
Reference-contexts: Even though a rewrite rule resembles a grammar production rule, terms in our language are not parse trees and attributes are propagated not only through rewrites but also inside of terms. By using term-rewriting systems with attributes we gain many advantages <ref> [14] </ref>. The attribute grammar framework is adequate to capture other optimizer specification frameworks, such as Volcano [6], in a more uniform and concise way. In fact, attributes are generalizations of logical and physical properties used in that and other optimizer frameworks.
References-found: 14

