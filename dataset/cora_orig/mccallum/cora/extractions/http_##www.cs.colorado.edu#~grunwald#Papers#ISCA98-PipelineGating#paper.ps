URL: http://www.cs.colorado.edu/~grunwald/Papers/ISCA98-PipelineGating/paper.ps
Refering-URL: http://www.cs.colorado.edu/~klauser/publications.html
Root-URL: http://www.cs.colorado.edu
Email: srilatha.manne@colorado.edu  grunwald,klauser@cs.colorado.edu  
Title: Pipeline Gating: Speculation Control For Energy Reduction  
Author: Srilatha Manne Artur Klauser, Dirk Grunwald 
Address: Boulder, CO 80309  Boulder, CO 80309  
Affiliation: University of Colorado Dept. of Electrical and Computer Engineering  University of Colorado Department of Computer Science  
Abstract: Branch prediction has enabled microprocessors to increase instruction level parallelism (ILP) by allowing programs to speculatively execute beyond control boundaries. Although speculative execution is essential for increasing the instructions per cycle (IPC), it does come at a cost. A large amount of unnecessary work results from wrong-path instructions entering the pipeline due to branch misprediction. Results generated with the SimpleScalar tool set using a 4-way issue pipeline and various branch predictors show an instruction overhead of 16% to 105% for every instruction committed. The instruction overhead will increase in the future as processors use more aggressive speculation and wider issue widths [9]. In this paper, we present an innovative method for power reduction which, unlike previous work that sacrificed flexibility or performance, reduces power in high-performance microprocessors without impacting performance. In particular, we introduce a hardware mechanism called pipeline gating to control rampant speculation in the pipeline. We present inexpensive mechanisms for determining when a branch is likely to mispredict, and for stopping wrong-path instructions from entering the pipeline. Results show up to a 38% reduction in wrong-path instructions with a negligible performance loss ( 1%). Best of all, even in programs with a high branch prediction accuracy, performance does not noticeably degrade. Our analysis indicates that there is little risk in implementing this method in existing processors since it does not impact performance and can benefit energy reduction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas D. Burd and Robert W. Brodersen. </author> <title> Processor design for portable systems. </title> <journal> Journal ov VLSI Signal Processing, </journal> <volume> 13(2/3):203222, </volume> <month> August </month> <year> 1996. </year>
Reference-contexts: In [3], Fromm et al noted a correlation between energy and performance. Reducing performance does not always reduce the overall energy consumed by the processor because of the quiescent energy consumed in the system <ref> [1] </ref>. In this paper, we reduce work while retaining performance and thus reduce the overall energy consumption of the processor. 2.1 Pipeline Gating We will use the schematic of the processor pipeline shown in Figure 2 to describe pipeline gating.
Reference: [2] <author> D. Burger and T. M. Austin. </author> <title> The simplescalar tool set, version 2.0. </title> <type> TR 1342, </type> <institution> University of Wisconson, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Since any subsequently fetched instructions would be control dependent on both branches in the pipeline, this boosting improves our gating decision. 3 Empirical Evaluation of Pipeline Gating To properly understand the effects of stalling the pipeline, we used the SimpleScalar tools <ref> [2] </ref> to develop a pipeline model of an out-of-order, speculative, wide-issue processor. We modified the sim-outorder processor model to produce the machine configuration listed in Tables 1 and 2. Table 3 shows the latency of the different operation types.
Reference: [3] <author> Richard Fromm, Stylianos Perissakis, Neal Cardwell, Christoforos Kozyrakis, Bruce McGaughy, and David Patter-son. </author> <title> The Energy Efficiency of IRAM Architectures. </title> <type> Technical report, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: Such reductions will greatly reduce packaging costs and will allow the computer architect to better balance an overall power budget across different parts of the chip. Existing low power work has focused on reducing energy in the memory subsystem <ref> [3, 8, 4] </ref>. <p> Secondly, overall energy consumption is dependent on performance. Since Energy = P ower fi T ime, simply reducing the power in a processor may not decrease the energy demands if the task now takes longer to execute. In <ref> [3] </ref>, Fromm et al noted a correlation between energy and performance. Reducing performance does not always reduce the overall energy consumed by the processor because of the quiescent energy consumed in the system [1].
Reference: [4] <author> Ricardo Gonzalez and Mark Horowitz. </author> <title> Energy Dissipation in General Purpose Microprocessors. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 31(9):12771284, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: Such reductions will greatly reduce packaging costs and will allow the computer architect to better balance an overall power budget across different parts of the chip. Existing low power work has focused on reducing energy in the memory subsystem <ref> [3, 8, 4] </ref>.
Reference: [5] <author> Dirk Grunwald, Artur Klauser, Srilatha Manne, and Andrew Pleszkun. </author> <title> Confidence esimation for speculation control. </title> <booktitle> In Proceedings 25th Annual International Symposium on Computer Architecture, SIGARCH Newsletter, </booktitle> <address> Barcelona, Spain, </address> <month> June </month> <year> 1998. </year> <note> ACM. </note>
Reference-contexts: Generally, gating stalls occur for about 2-4 processor cycles. Most processor configurations exhibit a similar distribution, and indicate that our mechanism is exhibiting fine control over the speculative state of the processor. 2.2 Confidence Estimation Metrics A complete comparison of confidence estimation mechanisms <ref> [5] </ref> is beyond the scope of this paper, but we implement several confidence estimation methods and compare their performance for pipeline gating. There are two important metrics to characterize the performance of confidence estimators used by pipeline gating: specificity SPEC and the predictive value of a negative test (PVN). <p> Therefore, pipeline gating effectively slows the injection of instructions into the pipeline rather than stopping instructions altogether. 3.1 Confidence Estimators Although branch predictors have been widely studied, confidence estimators have only recently been discussed <ref> [7, 5] </ref>. Thus, we will describe the mechanics of confidence estimation and the confidence estimators we used in more detail. <p> We tried a number of other variants with the McFarling counters and found that the Both Strong configuration provided the best results for our needs because it produced a high SPEC value with a reasonable PVN. The saturating counters method did not work well for Gshare. Distance: In <ref> [5] </ref>, we found that branch mispredictions were clustered and that this clustering could be used to build an inexpensive confidence estimator. The conditional probability of a mispredic-tion for branches that issue d branches after a mispredicted branch is resolved is higher for smaller values of d. <p> On the other hand, the pipeline performs twice the amount of necessary work for go, which suffers from a high misprediction rate. Fortunately, confidence mechanisms inherently do better on programs with a large misprediction rate <ref> [5] </ref>, and are most effective in reducing the amount of extra work in programs that have the largest overhead. 5 with a perfect confidence estimator. The entire thin bar shows EW with No Gating while the dark portion shows EW with gating. The wide, gray bar represents relative speedup. <p> Results produced are similar to those generated with the static estimation method. There are a couple of explanations for this. First, as discussed earlier, the Distance predictor does not do well for some types of programs. Secondly, the JRS estimator is tuned to work well with the Gshare predictor <ref> [7, 5] </ref>, and does not perform as well with the McFarling predictor. If the hardware can be justified, a small, multi-bit, JRS confidence estimator will provide the best results of any dynamic estimation mechanism for Gshare.
Reference: [6] <author> Steve Gunther and Suresh Rajgopal. </author> <type> Personal communication. </type>
Reference-contexts: For example, 30% of the core die area on the DECchip 21264 is devoted to cache structures, while the StrongARM processor uses 60% of the core die area for memory. Figure 1 shows a distribution of the power dissipated in a PentiumPro processor <ref> [6] </ref> during a test designed to consume the most power, which is when the processor is committing each instruction that it fetches. The fetch and decode stages, along with components necessary to perform dynamic scheduling and out-of-order execution, account for a significant portion of the power budget.
Reference: [7] <author> E. Jacobsen, E. Rotenberg, and J.E. Smith. </author> <title> Assigning Confidence to Conditional Branch Predictions. </title> <booktitle> In International Symposium on Microarchitecture, </booktitle> <pages> pages 142152, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Therefore, pipeline gating effectively slows the injection of instructions into the pipeline rather than stopping instructions altogether. 3.1 Confidence Estimators Although branch predictors have been widely studied, confidence estimators have only recently been discussed <ref> [7, 5] </ref>. Thus, we will describe the mechanics of confidence estimation and the confidence estimators we used in more detail. <p> Thus, we use the same input to select and evaluate the static confidence sites, and we varied the selection threshold across each program to report the best performance. We used the static method for both Gshare and McFarling predictors. JRS Confidence Estimation: Jacobsen et al <ref> [7] </ref> proposed a confidence estimator that paralleled the structure of the gshare branch predictor. This estimator uses a table of miss distance counters (MDC) to keep track of branch prediction correctness. Each MDC entry is a saturating resetting counter. <p> Results produced are similar to those generated with the static estimation method. There are a couple of explanations for this. First, as discussed earlier, the Distance predictor does not do well for some types of programs. Secondly, the JRS estimator is tuned to work well with the Gshare predictor <ref> [7, 5] </ref>, and does not perform as well with the McFarling predictor. If the hardware can be justified, a small, multi-bit, JRS confidence estimator will provide the best results of any dynamic estimation mechanism for Gshare.
Reference: [8] <author> J. Kin, M. Gupta, and W. Mangione-Smith. </author> <title> The Filter Cache: An Energy Efficient Memory Structure. </title> <booktitle> IEEE Micro, </booktitle> <month> Decem-ber </month> <year> 1997. </year>
Reference-contexts: Such reductions will greatly reduce packaging costs and will allow the computer architect to better balance an overall power budget across different parts of the chip. Existing low power work has focused on reducing energy in the memory subsystem <ref> [3, 8, 4] </ref>.
Reference: [9] <author> M. H. Lipasti and J. P. Shen. </author> <title> Superspeculative microarchitec-ture for beyond ad 2000. </title> <journal> IEEE Computer, </journal> <volume> 30(9), </volume> <year> 1997. </year>
Reference-contexts: We have presented an innovative method for reducing power, and there is much work left to be done in this area. With wider width processors and hyper speculation in the foreseeable future <ref> [9] </ref>, pipeline gating methods will become even more essential for no-risk energy reduction in high performance processors.
Reference: [10] <author> S. McFarling. </author> <title> Combining branch predictors. </title> <address> TN 36, DEC-WRL, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The McFarling combining predictor uses gshare and bimodal branch component predictors along with a meta predictor. The meta predictor chooses one of the branch predictors as the correct prediction for the branch. We chose the combination of gshare and bimodal because McFarling <ref> [10] </ref> indicated this combination had the best performance for the predictor sizes used in this paper. In both the Gshare and McFarling predictors, the branch prediction counters are updated at commit, and both predictors speculatively update the global history register, but not the prediction counters.
Reference: [11] <author> J. Montanaro and et. </author> <title> all. A 160-MHz, 32-b, 0.5-W CMOS RISC Microprocessor. </title> <journal> In Digital Technical Journal, </journal> <volume> volume 9. </volume> <publisher> Digital Equipment Corporation, </publisher> <year> 1997. </year>
Reference-contexts: Such reductions will greatly reduce packaging costs and will allow the computer architect to better balance an overall power budget across different parts of the chip. Existing low power work has focused on reducing energy in the memory subsystem [3, 8, 4]. In embedded processors, such as the StrongArm <ref> [11] </ref>, the memory subsystem is the dominant source of Permissions to make digital/hard copy of part or all this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage, the copyright notice, the title of the publication and
Reference: [12] <author> J. Pierce and T. Mudge. </author> <title> Wrong-Path Instruction Prefetching. </title> <booktitle> IEEE Micro, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: On the other hand, some programs, such as perl with the McFarling branch predictor, show a performance loss with perfect confidence estimation. Speculative execution has been shown to be beneficial for performance by warming up instruction caches <ref> [12] </ref>, and gating the pipeline reduces the benefits of the warm-up effect. With more realistic confidence estimation mechanisms, we do not gate as many of the incorrectly predicted paths. Hence we still benefit from some of the warm-up effects in the instruction caches.
Reference: [13] <author> J.E. Smith. </author> <title> A Study of Branch Prediction Strategies. </title> <booktitle> In Annual International Symposium on Computer Architecture, SIGARCH Newsletter, </booktitle> <pages> pages 135148, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: We also discuss the effectiveness of different JRS configurations for pipeline gating in future sections. We use the JRS method for both Gshare and McFarling predictors. Saturating Counters: Most branch predictors use some form of saturating counters to predict the likely branch outcome. Smith <ref> [13] </ref> mentioned that it may be possible to use these counters as branch confidence estimators.
Reference: [14] <author> A. Sodani and G. S. Sohi. </author> <title> Dynamic Instruction Reuse. </title> <booktitle> In Annual International Symposium on Computer Architecture, SIGARCH Newsletter, pages 194205. IEEE, </booktitle> <month> June </month> <year> 1997. </year> <month> 10 </month>
Reference-contexts: Although these advances have increased the number of instructions per cycle (IPC), they have come at the cost of wasted work. Most processors use branch prediction for speculative control flow execution, and recent work has examined value and memory speculation <ref> [14] </ref>. Branch prediction is used to execute beyond the control boundaries in the code. With high branch prediction accuracy, most issued instructions will actually commit. However, many programs have a high branch misprediction rate, and these programs issue many instructions that never commit.
References-found: 14

