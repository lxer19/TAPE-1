URL: http://www.cs.purdue.edu/homes/palsberg/paper/scp97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: A New Approach to Compiling Adaptive Programs  
Author: Jens Palsberg Boaz Patt-Shamir Karl Lieberherr 
Date: January 10, 1998  
Abstract: An adaptive program can be understood as an object-oriented program where the class graph is a parameter, and hence the class graph may be changed without changing the program. The problem of compiling an adaptive program and a class graph into an object-oriented program was studied by Palsberg, Xiao, and Lieberherr in 1995. Their compiler is efficient but works only in special cases. In this paper we present and prove the correctness of a compiler that handles the general case. The compiler first computes a finite-state automaton and then uses it to generate efficient code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Version 5.5 of the Demeter Tools/C ++ , which generates C ++ code, </institution> <note> is available through the Demeter home page: http://www.ccs.neu.edu/research/demeter/. </note>
Reference-contexts: See [6] for numerous examples of adaptive programming in an extension of C ++ . Systems which support adaptive programming have been available since 1991, and are being successfully used at Northeastern University, Xerox PARC, and other places <ref> [1] </ref>. The core of the compiler provided by these tools was presented and proved correct in [10]. The current compiler, despite being quite useful in many practical cases, is not general in the sense that there are certain combinations of adaptive programs and class graphs which the compiler rejects.
Reference: [2] <author> Simon Gibbs, Dennis Tsichritzis, Eduardo Casais, Oscar Nierstrasz, and Xavier Pintado. </author> <title> Class management for software communities. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 90-103, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The key feature of most object-oriented languages is that the description of actions (usually called "methods" in this context) is attached to the description of types ("classes"). While this characteristic property is useful in many cases, it has been observed (see, e.g., <ref> [2] </ref>) that changes in the structure of data (i.e., class definitions) may necessitate re-writing large portions of the action code (i.e, method definitions), even if essentially the underlying algorithm remains the same. Let us illustrate this point with a simple example. Consider the following two scenarios.
Reference: [3] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: For example, let D be the traversal specification of the adaptive program in Figure 2, and let G be the class graph from Figure 2. Employing standard notation for regular expressions <ref> [3] </ref>, and denoting by L (E) the language defined by a regular expression E, we have that PathSet G (D) = L Exp ( Comp (arg1 + arg2) Exp) + Num 6 2.4 Adaptive Programs Following [10], we define adaptive programs as follows. <p> We use the notation of <ref> [3] </ref>. The basic structure of the automaton does not depend on A and B: only the start and the final states are defined by them. Specifically, define FA (G) to be the set of non-deterministic automata where: 11 specification [Comp; Num]. <p> M 1 M 2 can be computed by introducing a fresh start state with * transitions to the start states of M 1 and M 2 <ref> [3] </ref>. * If M 1 ; M 2 are automata, then M 1 fi M 2 is the automaton defined as follows. <p> Proof. For (1), see <ref> [3] </ref>. To see (2), first consider a string x accepted by M 1 fi M 2 .
Reference: [4] <author> Walter L. Hursch and Linda M. Seiter. </author> <title> Automating the evolution of object-oriented systems. </title> <booktitle> In International Symposium on Object Technologies for Advanced Software, </booktitle> <year> 1996. </year> <note> To appear. 22 </note>
Reference-contexts: In this section, we define a simpler semantics which has the property that all -labels are removed before the traversal begins. The new semantics greatly simplifies the compiling algorithm presented in Section 4. Our notion of word is related to that of "calling path" in <ref> [4] </ref>. Our first step is to define the functions transforming path sets into strings (words), while deleting abstract classes.
Reference: [5] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year>
Reference-contexts: Of course, an adaptive program cannot be executed. To get an executable program, an adaptive program has to be specialized, in the sense of partial evaluation <ref> [5] </ref>, with a complete description of the actual data structures to be used. Let us outline the way adaptive programs can be used in our example from above. The basic concepts of adaptive programs will be informally introduced as we proceed. Adaptive programs consist of traversal specifications and code wrappers.
Reference: [6] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year> <note> ISBN 0-534-94602-X. </note>
Reference-contexts: Scenarios such as the one sketched above (which are quite common in the practice of software development) constitute the main motivation for adaptive programs <ref> [7, 10, 6] </ref>. Informally (a formal description is given in Section 2), an adaptive program is a program where the complete description of its data structures is a parameter. <p> We leave such developments to future work. Syntax for traversal specifications, etc. can easily be added to an existing object-oriented language. See <ref> [6] </ref> for numerous examples of adaptive programming in an extension of C ++ . Systems which support adaptive programming have been available since 1991, and are being successfully used at Northeastern University, Xerox PARC, and other places [1]. <p> We prove the correctness of the compiler with respect to the original semantics for adaptive programs, as described in <ref> [10, 6] </ref>. Our proof consists of two stages. First, we define a variant of the original semantics, and prove that it is equivalent to the original one. Then we show how to construct automata which implement the new semantics.
Reference: [7] <author> Karl J. Lieberherr, Ignacio Silva-Lepe, and Cun Xiao. </author> <title> Adaptive object-oriented programming using graph-based customization. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 94-101, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Scenarios such as the one sketched above (which are quite common in the practice of software development) constitute the main motivation for adaptive programs <ref> [7, 10, 6] </ref>. Informally (a formal description is given in Section 2), an adaptive program is a program where the complete description of its data structures is a parameter.
Reference: [8] <author> Karl J. Lieberherr and Cun Xiao. </author> <title> Object-oriented software evolution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(4) </volume> <pages> 313-343, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We will write (u; l; v) as u l In this paper we will be interested in special kinds of graphs, called class graphs and object graphs, defined as follows. (The present definitions are akin to those of <ref> [8] </ref> and [9].) Fix a set ClassName, the set of class names which can be used in class graphs. The predicate Abstract is true for names of abstract classes, and it is false otherwise. If a class is not abstract, it is said to be concrete.
Reference: [9] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: We will write (u; l; v) as u l In this paper we will be interested in special kinds of graphs, called class graphs and object graphs, defined as follows. (The present definitions are akin to those of [8] and <ref> [9] </ref>.) Fix a set ClassName, the set of class names which can be used in class graphs. The predicate Abstract is true for names of abstract classes, and it is false otherwise. If a class is not abstract, it is said to be concrete.
Reference: [10] <author> Jens Palsberg, Cun Xiao, and Karl Lieberherr. </author> <title> Efficient implementation of adaptive software. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 264-292, </pages> <month> March </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: Scenarios such as the one sketched above (which are quite common in the practice of software development) constitute the main motivation for adaptive programs <ref> [7, 10, 6] </ref>. Informally (a formal description is given in Section 2), an adaptive program is a program where the complete description of its data structures is a parameter. <p> Systems which support adaptive programming have been available since 1991, and are being successfully used at Northeastern University, Xerox PARC, and other places [1]. The core of the compiler provided by these tools was presented and proved correct in <ref> [10] </ref>. The current compiler, despite being quite useful in many practical cases, is not general in the sense that there are certain combinations of adaptive programs and class graphs which the compiler rejects. <p> If a program and a class graph cannot be compiled, then the program has to be rewritten (as discussed in <ref> [10] </ref>). This defeats the original motivation of adaptive programs, namely the automation of adaptiveness. In this paper, we present a new compiler which is applicable to combinations of adaptive program and class graph which could not be dealt with by the old compiler. Informally, the main idea is as follows. <p> We prove the correctness of the compiler with respect to the original semantics for adaptive programs, as described in <ref> [10, 6] </ref>. Our proof consists of two stages. First, we define a variant of the original semantics, and prove that it is equivalent to the original one. Then we show how to construct automata which implement the new semantics. <p> a new semantics of adaptive programs and prove that it is equivalent to the old one, and in Section 4 we give a compilation algorithm for adaptive programs and prove it correct with respect to the new semantics. 2 The Semantics of Adaptive Programs In this section we recall from <ref> [10] </ref> the definitions of class graphs, object graphs, paths, traversal specifications, wrappers, and the semantics of adaptive programs. We also define the semantics of an object-oriented target language. The target language is slightly different from the one used in [10]. <p> The Semantics of Adaptive Programs In this section we recall from <ref> [10] </ref> the definitions of class graphs, object graphs, paths, traversal specifications, wrappers, and the semantics of adaptive programs. We also define the semantics of an object-oriented target language. The target language is slightly different from the one used in [10]. <p> In a 4 class graph, only abstract classes have outgoing subclass edges. A class graph is flat if for every node u where Abstract (u), all outgoing edges are subclass edges. Following <ref> [10] </ref> we henceforth assume that all class graphs are flat. For example, in the class graph of Figure 2, Exp is an abstract class (indicated by a hexagon), and the other four classes are concrete (indicated by rectangles). <p> We usually omit the subscript G when it is clear from the context. The following basic lemma is taken from <ref> [10] </ref>. Lemma 2.1 If WF (D), then (i) PathSet (D) is well defined and (ii) each path in PathSet (D) starts in Source (D) and ends in Target (D). We henceforth assume that all traversal specifications are well formed. <p> Employing standard notation for regular expressions [3], and denoting by L (E) the language defined by a regular expression E, we have that PathSet G (D) = L Exp ( Comp (arg1 + arg2) Exp) + Num 6 2.4 Adaptive Programs Following <ref> [10] </ref>, we define adaptive programs as follows. First, define a wrapper map to be a mapping of class names to code segments called wrappers (the idea is that when an object is visited during the traversal of an adaptive program, the appropriate wrapper code will be executed). <p> We conclude that ` n o : Simplify (R) fl H is derivable. The converse is proved similarly. 4 Compiling Adaptive Programs The compiler of <ref> [10] </ref> will reject the adaptive program and class graph of Figure 2, as discussed in [10]. The reason is that the code that would be generated looks as follows. <p> We conclude that ` n o : Simplify (R) fl H is derivable. The converse is proved similarly. 4 Compiling Adaptive Programs The compiler of <ref> [10] </ref> will reject the adaptive program and class graph of Figure 2, as discussed in [10]. The reason is that the code that would be generated looks as follows. <p> Both algorithms generate efficient code for programs which could not be compiled by previous algorithms <ref> [10] </ref>. One algorithm works in the important special case of product specifications, and runs in polynomial time. The second algorithm works for any specification, but may require exponential time to compute.
References-found: 10

