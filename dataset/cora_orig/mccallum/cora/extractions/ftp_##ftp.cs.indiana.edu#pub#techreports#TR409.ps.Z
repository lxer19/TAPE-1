URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR409.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Continuations in Hardware-Software Codesign  
Author: M. Esen Tuna, Steven D. Johnson, and Robert G. Burger 
Note: To appear in the proceedings of the 1994 IEEE International Conference on Computer Design (ICCD '94 Cambridge, Massachusetts,  
Date: July 1994  October, 1994.  
Abstract: indiana university computer science department technical report no. 409 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> W. Clinger and J. Rees, </editor> <title> "The revised 4 report on the algorithmic language Scheme," </title> <journal> Lisp Pointers, </journal> <volume> vol. 4, no. 3, </volume> <pages> pp. pages 1-55, </pages> <year> 1991. </year>
Reference-contexts: It is certainly the case that for the restricted codesign applications to which they have been applied, these techniques have provided leverage over software map-over problems. The environment we have developed is based on the programming language Scheme <ref> [1] </ref>, a Lisp dialect which serves as the framework implementation language, as a formal modeling language for system specification, and with certain restrictions as a hardware description language [2, 3].
Reference: [2] <author> S. D. Johnson and B. Bose, </author> <title> "A system for mechanized digital design derivation," </title> <booktitle> in Proceedings of ACM International Workshop on Formal Methods in VLSI Design (Subramanyam, </booktitle> <editor> ed.), </editor> <month> January </month> <year> 1991. </year>
Reference-contexts: The environment we have developed is based on the programming language Scheme [1], a Lisp dialect which serves as the framework implementation language, as a formal modeling language for system specification, and with certain restrictions as a hardware description language <ref> [2, 3] </ref>. We exploit some advanced features of Scheme|most notably its support of functional values with appropriate scoping rules| in the techniques we describe below. These techniques are standard in functional programming methodology, but this is the first time they have been applied directly to hardware descriptions. <p> MPY 3 (lambda (n m q k) (if (= n 1) (MPY 3 (- n 1) m q (+ k m))))) (define RTN 3 (lambda (n m) (FAC 3 (- n 1) m))) We use systems of tail-recursive function definitions, like the one above, as a behavioral hardware description language <ref> [2, 3] </ref>. The functions represent states of an extended finite-state machine, which in this example would look like: Before leaving this example, let us briefly review it from the perspective of formal verification. The first transformations that introduce continuations are fairly standard.
Reference: [3] <author> B. Bose, </author> <title> "DDD ATransformation system for Digital Design Derivation," </title> <type> Tech. Rep. 331, </type> <institution> Indiana University, Computer Science Department, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: The environment we have developed is based on the programming language Scheme [1], a Lisp dialect which serves as the framework implementation language, as a formal modeling language for system specification, and with certain restrictions as a hardware description language <ref> [2, 3] </ref>. We exploit some advanced features of Scheme|most notably its support of functional values with appropriate scoping rules| in the techniques we describe below. These techniques are standard in functional programming methodology, but this is the first time they have been applied directly to hardware descriptions. <p> Both the CPU and the heap may be implemented in either hardware or software. Initially, the entire system is modeled at a behavioral level in software. Using tools that we have developed <ref> [3] </ref>, the executable subsystem descriptions are individually transformed into hardware. Figure 3 shows a prototype in which the heap system and the CPU have been realized in this way. <p> MPY 3 (lambda (n m q k) (if (= n 1) (MPY 3 (- n 1) m q (+ k m))))) (define RTN 3 (lambda (n m) (FAC 3 (- n 1) m))) We use systems of tail-recursive function definitions, like the one above, as a behavioral hardware description language <ref> [2, 3] </ref>. The functions represent states of an extended finite-state machine, which in this example would look like: Before leaving this example, let us briefly review it from the perspective of formal verification. The first transformations that introduce continuations are fairly standard.
Reference: [4] <author> D. P. Friedman, M. Wand, and C. T. Haynes, </author> <title> Essentials of Programming Languages. </title> <institution> The Massachusetts Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: This exercise is part of a research project to extend a software-oriented methodology <ref> [4] </ref> to include hardware implementation targets. We begin with a very-high-level specification, a simple Scheme interpreter representing a user-level definition of the language. Using existing techniques of the software methodology, the naive language specification is factored into a recursive compiler and an iterative machine model. <p> Its support of functional (procedural) objects having full status as data values is central to the techniques we develop later. Space permits only a brief sketch of this feature; tutorial material can be found in <ref> [7, 4] </ref>. The Scheme expression (lambda (x 1 x n ) e) returns a function with defining expression e involving parameters x 1 ; : : : ; x n .
Reference: [5] <author> D. Winkel, F. Prosser, R. Wehrmeister, W. C. Hunt, and C. Hess, </author> <title> "A student VLSI hardware tester," </title> <booktitle> in Proceedings of the Microelectronic Systems Education Conference and Exposition, </booktitle> <pages> pp. 15-24, </pages> <year> 1990. </year>
Reference-contexts: Figure 3 shows a prototype in which the heap system and the CPU have been realized in this way. The prototype environment, shown in Figure 3, consists of an uncommitted wire-wrap area, banks of lights and switches, and other facilities unused in this project <ref> [5, 6] </ref>. The computer to the right is connected to the project board and is used for simulating the software components, testing the hardware components, and evaluating the entire system. Typically a design starts with an all-software model, and the modules of the design are gradually mapped onto hardware.
Reference: [6] <author> R. M. Wehrmeister, </author> <title> Logic Engine User's Manual. </title> <institution> Computer Science Dept. Indiana Univ., </institution> <month> Mar. </month> <year> 1991. </year>
Reference-contexts: Figure 3 shows a prototype in which the heap system and the CPU have been realized in this way. The prototype environment, shown in Figure 3, consists of an uncommitted wire-wrap area, banks of lights and switches, and other facilities unused in this project <ref> [5, 6] </ref>. The computer to the right is connected to the project board and is used for simulating the software components, testing the hardware components, and evaluating the entire system. Typically a design starts with an all-software model, and the modules of the design are gradually mapped onto hardware.
Reference: [7] <author> G. Springer and D. P. Friedman, </author> <title> Scheme and the Art of Programming. </title> <publisher> McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Its support of functional (procedural) objects having full status as data values is central to the techniques we develop later. Space permits only a brief sketch of this feature; tutorial material can be found in <ref> [7, 4] </ref>. The Scheme expression (lambda (x 1 x n ) e) returns a function with defining expression e involving parameters x 1 ; : : : ; x n .
Reference: [8] <author> B. Bose, S. D. Johnson, and S. Pullela, </author> <title> "Integrating boolean verification with formal derivation," </title> <booktitle> in Proceedings of IFIP Conference on Hardware Description Languages and their Applications (D. </booktitle> <editor> Agnew, L. Clae-sen, and R. Camposano, </editor> <booktitle> eds.), </booktitle> <pages> pp. 127-134, </pages> <publisher> Elsevier, </publisher> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: Getting from the second to the third version of FAC was a more subtle undertaking. These refinements are less likely to be automated, and in the case that they are not, another reasoning system might be needed to verify them <ref> [8] </ref>.
Reference: [9] <author> B. Bose, M. E. Tuna, and S. D. Johnson, </author> <title> "System factorization in codesign: A case study of the use of formal techniques to achieve hardware-software decomposition," </title> <booktitle> in Proceedings of the International Conference on Computer Design, </booktitle> <pages> pp. 458-461, </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The factored component may be a complex valued stream (signal) in the circuit or a set of operations on the signals <ref> [9] </ref>. Factorization may involve a sequential or combinational component. We also view sequential state machine decomposition as factoring a set of states from the original design and creating a coprocess which is communicating with the residual system.
Reference: [10] <author> S. Kumar, J. H. Aylor, B. W. Johnson, and W. A. Wulf, </author> <title> "A framework for hardware/software codesign," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 39-45, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Maintaining the integrity and executability of the model is a central issue in codesign. In this section we introduce the use of continuations to provide for process creation and decomposition without losing model continuity <ref> [10] </ref>. Continuations provide a smooth and seamless transition from subroutines to processes and further to simple coprocesses. 3.1 Scheme Machine Exercise We consider the execution of a cons operation on an abstract Scheme machine. Cons is a primitive in Scheme to construct lists. <p> We believe that the goals and problems in codesign are going to necessitate greater flexibility at the specification level than currently exists in HDLs. There needs to be more interaction between software and hardware subsystem development <ref> [10] </ref>. There needs to be less bias toward software or hardware in modeling languages and their affiliated tools [12].
Reference: [11] <author> K. Rath, B. Bose, and S. D. Johnson, </author> <title> "Derivation of a DRAM memory interface by sequential decomposition," </title> <booktitle> in Proceedings of the International Conference on Computer Design (ICCD), </booktitle> <pages> pp. 438-441, </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: We also generate handshake signals, req and done, between the two state machines and introduce wait loops as part of the communication protocol. In this example we have introduced a protocol in an ad hoc manner; however, our research addresses sequential decomposition formally as discussed in <ref> [11] </ref>. In the ALLOC state, machine 2 sets the req signal high and waits in an idle loop until the done signal is set by the allocator. Then the new memory and the pointer become available, and execution proceeds with the continuation saved earlier.
Reference: [12] <author> N. S. Woo, A. E. Dunlop, and W. Wolf, </author> <title> "Codesign from cospecification," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 42-47, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: In the initial specification of the system, the subsystems are modeled as subpro-cedures, avoiding a premature partitioning of the system, which is a key problem in codesign <ref> [12] </ref>. We then elected an implementation of a primitive memory|a dual ported DRAM capable in certain in stances of performing two operations in 125% of a cycle. The memory unit also deals with refresh internally using time-division multiplexing on the memory bus. <p> There needs to be more interaction between software and hardware subsystem development [10]. There needs to be less bias toward software or hardware in modeling languages and their affiliated tools <ref> [12] </ref>. We found it encouraging that control manipulation techniques that have been developed in software-oriented research were so readily adapted to hardware specification problems and prototyping activities. 5 Acknowledgements The research described here is part of a large project with a substantial context.
Reference: [13] <author> K. ten Hagen and H. Meyr, </author> <title> "Partioning and surmounting the software-hardware abstraction gap in an asic design project," </title> <booktitle> in IEEE International Conference on Computer Design, </booktitle> <pages> pp. 462-465, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The idea is to gain control over control, just as in most languages one has control over data representations. A central problem in codesign is to bridge the software-hardware "abstraction gap" <ref> [13] </ref>. This notion presumes that we are able to specify at a high enough level to obscure the boundaries of hardware and software, or at least the interface between those two. Equivalently, we must obscure the distinction between procedure and process, and this entails manipulation of control.
Reference: [14] <author> K. Rath, M. E. Tuna, and S. D. Johnson, </author> <title> "Specification and synthesis of bounded indirection," </title> <type> Tech. Rep. 398, </type> <institution> Indiana University, Computer Science Department, </institution> <month> Feb. </month> <year> 1994. </year>
Reference: [15] <author> C. Boyer and S. D. Johnson, </author> <title> "Using the digital design derivation system: Case study of a VLSI garbage collector," </title> <booktitle> in Ninth International Symposium on Computer Hardware Description Languages (Dar-ringer and Ramming, eds.), (Amsterdam), IFIP WG 10.2, </booktitle> <publisher> Elsevier, </publisher> <year> 1989. </year>
Reference: [16] <author> S. D. Johnson, B. Bose, and C. Boyer, </author> <title> "A tactical framework for digital design," in VLSI Specification, Verification and Synthesis (Birtwistle and Sub-ramanyam, </title> <booktitle> eds.), </booktitle> <pages> pp. 349-383, </pages> <address> Boston: </address> <publisher> Kluwer, </publisher> <year> 1988. </year>
Reference: [17] <author> P. A. Subrahmanyam, G. D. Micheli, and K. Buchen-rieder, "Hardware-software codesign," </author> <booktitle> IEEE Computer, </booktitle> <pages> pp. 84-87, </pages> <month> Jan. </month> <year> 1993. </year>
References-found: 17

