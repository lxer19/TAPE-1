URL: http://www.cs.gatech.edu/computing/classes/cs4804a_95_summer/labs/xkman.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs4804a_95_summer/index.html
Root-URL: 
Title: -Kernel Programmer's Manual (Version 3.2)  
Author: Edwin F. Menze III Hilarie K. Orman 
Note: This work supported in part by National Science Foundation Grants CCR-8811423, IRI-9015407, and CCR-9102040, Sun Microsystems Inc., Hewlett-Packard Company, DARPA Contract DABT63-91-C-0030, and NCSC Uni versity Research Grant MDA904-92-C-515  
Date: April 26, 1995  
Abstract: This report describes how to implement protocols in the x-kernel. It gives the x-kernel's programming interface, describes how to configure an x-kernel that contains a certain collection of protocols, and demonstrates how to run and debug an x-kernel. The x-kernel can be run in one of two environments: as a user program on a Sun SparcStation running SunOS4.1, or as a task on a Mach3.0 system (some platforms). Protocols can be moved between the two environments without modification. This document assumes that the reader is already familiar with the x-kernel's object-oriented infrastructure for implementing protocols. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> Put xkernel/bin/sparc and xkernel/bin in your search path. </editor> <title> These must be before /bin and /usr/bin. This will allow use of the version of make distributed with the x-kernel (GNU make v. 3.66) rather than the standard Unix make. </title>
Reference-contexts: the participant list, and then how the low-level protocol extracts that information from the participant list. - /* set participant addresses before calling low-level protocol's open */ partInit (p, 2); partPush (p [0], &ServerHostAddr, sizeof (IPhost)); /* remote */ partPush (p [0], &ServerPort, sizeof (long)); /* remote */ partPush (p <ref> [1] </ref>, ANY_HOST, 0); /* local */ partPush (p [1], &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... 26 llpOpen ( XObj self, XObj hlpRcv, XObj hlpType, Part *p ) - /* get participant addresses within low-level protocol's open */ remoteport = (long *) partPop (p [0]); localport <p> protocol extracts that information from the participant list. - /* set participant addresses before calling low-level protocol's open */ partInit (p, 2); partPush (p [0], &ServerHostAddr, sizeof (IPhost)); /* remote */ partPush (p [0], &ServerPort, sizeof (long)); /* remote */ partPush (p <ref> [1] </ref>, ANY_HOST, 0); /* local */ partPush (p [1], &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... 26 llpOpen ( XObj self, XObj hlpRcv, XObj hlpType, Part *p ) - /* get participant addresses within low-level protocol's open */ remoteport = (long *) partPop (p [0]); localport = (long *) partPop (p [1]); ... <p> partPush (p <ref> [1] </ref>, &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... 26 llpOpen ( XObj self, XObj hlpRcv, XObj hlpType, Part *p ) - /* get participant addresses within low-level protocol's open */ remoteport = (long *) partPop (p [0]); localport = (long *) partPop (p [1]); ... Notice in this example how the high-level protocol pushes two items (a host address and a port number) onto each participant's address stack, but the low-level protocol pops only one item off.
Reference: 2. <institution> Create a new working directory to hold your kernel. </institution>
Reference-contexts: ( XObj, char **, int, int, void * ); static XObjRomOpt opts [] = - - "mtu", 3, readMtu -, - "port", 3, readPort - -; static xkern_return_t readMtu ( XObj self, char **arr, int nFields, int line, void *arg ) - PState *ps = (PState *)self-&gt;state; return sscanf (arr <ref> [2] </ref>, "%d", &ps-&gt;mtu) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - static xkern_return_t readPort ( XObj self, char **arr, int nFields, int line, void *arg ) - PState *ps = (PState *)self-&gt;state; return sscanf (arr [2], "%d", &ps-&gt;port) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - foo_init ( XObj self ) - findXObjRomOpts <p> int nFields, int line, void *arg ) - PState *ps = (PState *)self-&gt;state; return sscanf (arr <ref> [2] </ref>, "%d", &ps-&gt;mtu) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - static xkern_return_t readPort ( XObj self, char **arr, int nFields, int line, void *arg ) - PState *ps = (PState *)self-&gt;state; return sscanf (arr [2], "%d", &ps-&gt;port) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - foo_init ( XObj self ) - findXObjRomOpts (self, opts, sizeof (opts)/sizeof (XObjRomOpt), 0); ... 52 10 Control Operations Control operations are used to perform arbitrary operations on protocols and sessions, via the xControl operation described in section 2.2.12. xControl returns an
Reference: 3. <institution> Change to your new working directory. </institution>
Reference: 4. <institution> Copy the Makefile from xkernel/build/Template/Makefile.sunos into your working directory under the name Makefile: cp xkernel/build/Template/Makefile.sunos Makefile </institution>
Reference: 5. <institution> Make the Makefile writable: </institution> <address> 63 chmod u+w Makefile </address>
Reference: 6. <author> Edit the Makefile. </author> <title> Select an appropriate HOWTOCOMPILE. Generally, you want DEBUG until you are ready to run serious performance tests, then change it to OPTIMIZE. (See Section 8.) Check to see that the variable XRT in your Makefile is a path to the root of the xkernel source tree. </title>
Reference: 7. <editor> If you are including a new protocol in your kernel, </editor> <title> then create (at least) a shell for that protocol; e.g., create a shell version of yap.c. The protocol shell should define an initialization routine; e.g., yap init. You will also need to put an entry for your protocol in one of the protocol tables referenced by your graph.comp (see section 13.1.) If you are configuring a kernel that contains only existing protocols, then this step is not necessary. </title>
Reference: 8. <editor> Create a graph.comp in your build directory, </editor> <title> as discussed in section 12.1, to specify the protocol graph for your kernel. Example graph.comps are located in the xkernel/build/Template directory. In steps 9, 10, and 11, you may see one or more compiler warning messages of the form: make[n]: fopen: [filename]: No such file or directory These messages are expected and can be ignored. The files referenced by these messages will be created in steps 10 and 11. The following two steps must be redone if graph.comp is later modified: 9. make compose 10. make depend </title>
Reference-contexts: call; /* sessions only */ Pfk close; /* sessions or protocols */ Pfi control; /* sessions or protocols */ Pfk duplicate; /* sessions only */ int numdown; /* readable */ /* down info is owned by the protocol for its sessions */ int downlistsz; unsigned int idle; struct xobj *down <ref> [8] </ref>; struct xobj **downlist; struct xobj *myprotl; /* readable a session is an instance of this protocol */ struct xobj *up; /* for sessions only */ struct xobj *hlpType; g *XObj; 11 If you think of the x-kernel as implementing protocol and session graphs, then each XObj represents a node in

References-found: 8

