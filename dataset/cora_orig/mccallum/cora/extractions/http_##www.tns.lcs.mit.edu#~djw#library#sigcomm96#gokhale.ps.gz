URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/gokhale.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/program.html
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Measuring the Performance of Communication Middleware on High-Speed Networks as CORBA and traditional RPC toolkits)
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Keyword: Communication middleware, distributed object computing, CORBA, high-speed networks.  
Note: Conventional implementations of communication middleware (such  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper will appear in the SIGCOMM Conference, 1996, Stanford University, August, 1996. Abstract This paper compares the performance of several widely used communication middleware mechanisms on a high-speed ATM network. The middleware ranged from lower-level mechanisms (such as socket-based C interfaces and C++ wrappers for sockets) to higher-level mechanisms (such as RPC, hand-optimized RPC and two implementations of CORBA - Orbix and ORBeline). These measurements reveal that the lower-level C and C++ implementations outperform the CORBA implementations significantly (the best CORBA throughput for remote transfer was roughly 75 to 80 percent of the best C/C++ throughput for sending scalar data types and only around 33 percent for sending structs containing binary fields), and the hand-optimized RPC code performs slightly better than the CORBA implementations. Our goal in precisely pinpointing the sources of overhead for communication middleware is to develop scalable and flexible CORBA implementations that can deliver gigabit data rates to applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: A remedy for this problem is to use Application Level Framing (ALF) [5, 4, 9] and Integrated Layer Processing (ILP) <ref> [5, 1, 20] </ref>. ALF ensures that lower layer protocols deal with data in units specified by the application.
Reference: [2] <author> Kenneth Birman and Robbert van Renesse. </author> <title> RPC Considered Inadequate. </title> <booktitle> In Reliable Distributed Computing with the Isis Toolkit, </booktitle> <pages> pages 68-78. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1994. </year>
Reference-contexts: In general, existing implementations of CORBA have not been optimized since performance has not been a problem on low-speed networks. It is beyond the scope of this paper to discuss limitations with CORBA features (see <ref> [2] </ref> for a synopsis). 3 Experimental Results of CORBA over ATM This section describes our CORBA/ATM testbed and presents the results of our performance experiments. 3.1 CORBA/ATM Testbed Environment 3.1.1 Hardware and Software Platforms The experiments in this section were collected using a Bay Networks LattisCell 10114 ATM switch connected to
Reference: [3] <author> G.J Blaine, M.E. Boyd, and S.M. Crider. </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System. </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pages 71-81, </pages> <year> 1994. </year>
Reference-contexts: The use of low-level mechanisms increases development effort and reduces system reliability, flexibility, and reuse. This is a serious problem for mission/life-critical applications (such as satellite surveillance and medical imaging <ref> [3, 7] </ref>). Therefore, it is imperative that performance of high-level, but inefficient, communication middleware be improved to match that of low-level, but efficient, tools. <p> The use of typed data is representative of applications like electronic medical imaging <ref> [7, 3] </ref> and high-speed distributed databases (such as global change repositories [17]). In addition, measuring typed data transfer reveals the overhead of presentation layer conversions and data copying for the various communication middleware mechanisms we measured.
Reference: [4] <author> Isabelle Chrisment. </author> <title> Impact of ALF on Communication Subsystems Design and Performance. </title> <booktitle> In First International Workshop on High Performance Protocol Architectures, HIPPARCH '94, Sophia Antipo-lis, </booktitle> <address> France, </address> <month> December </month> <year> 1994. </year> <institution> INRIA France. </institution>
Reference-contexts: A remedy for this problem is to use Application Level Framing (ALF) <ref> [5, 4, 9] </ref> and Integrated Layer Processing (ILP) [5, 1, 20]. ALF ensures that lower layer protocols deal with data in units specified by the application.
Reference: [5] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <pages> pages 200-208, </pages> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: As discussed in Section 3.2.2, this overhead arises from the amount of time the CORBA implementations spend performing presentation layer conversions and data copying. 4.2 Presentation Layer and Data Copying The presentation layer is a major bottleneck in high-performance communication subsystems <ref> [5] </ref>. This layer transforms typed data objects from higher-level representations to lower-level representations (marshalling) and vice versa (demarshalling). In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. <p> A remedy for this problem is to use Application Level Framing (ALF) <ref> [5, 4, 9] </ref> and Integrated Layer Processing (ILP) [5, 1, 20]. ALF ensures that lower layer protocols deal with data in units specified by the application. <p> A remedy for this problem is to use Application Level Framing (ALF) [5, 4, 9] and Integrated Layer Processing (ILP) <ref> [5, 1, 20] </ref>. ALF ensures that lower layer protocols deal with data in units specified by the application.
Reference: [6] <author> Sudheer Dharnikota, Kurt Maly, and C. M. Overstreet. </author> <title> Performance Evaluation of TCP(UDP)/IP over ATM networks. </title> <institution> Department of Computer Science, </institution> <type> Technical Report CSTR 94 23, </type> <institution> Old Dominion University, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: However, the CORBA and RPC implementations do not omit the overhead of the function calls, which has a non-trivial overhead (shown in Section 3.2.2). 3.1.3 TTCP Parameter Settings Existing studies <ref> [7, 11, 6, 23, 18] </ref> of transport protocol performance over ATM demonstrate the impact of parameters such as socket queue sizes and data buffer on performance. <p> None of the systems described below are explicitly targeted for the requirements and constraints of communication middleware like CORBA. In particular, less attention has been paid to integrating the following topics related to communication middleware: 4.1 Transport Protocol Performance over ATM Networks <ref> [7, 11, 6] </ref> present results on performance of TCP/IP (and UDP/IP [6]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size). <p> In particular, less attention has been paid to integrating the following topics related to communication middleware: 4.1 Transport Protocol Performance over ATM Networks [7, 11, 6] present results on performance of TCP/IP (and UDP/IP <ref> [6] </ref>) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size). <p> This work indicates that in addition to the host architecture and host network interface, parameters configurable in software (like TCP window size, socket queue size and user data size) significantly affect TCP throughput. <ref> [6] </ref> also shows that UDP performs better than TCP over ATM networks, which is attributed to redundant TCP processing overhead on highly-reliable ATM links.
Reference: [7] <author> Minh DoVan, Louis Humphrey, Geri Cox, and Carl Ravin. </author> <title> Initial Experience with Asynchronous Transfer Mode for Use in a Medical Imaging Network. </title> <journal> Journal of Digital Imaging, </journal> <volume> 8(1) </volume> <pages> 43-48, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The use of low-level mechanisms increases development effort and reduces system reliability, flexibility, and reuse. This is a serious problem for mission/life-critical applications (such as satellite surveillance and medical imaging <ref> [3, 7] </ref>). Therefore, it is imperative that performance of high-level, but inefficient, communication middleware be improved to match that of low-level, but efficient, tools. <p> The use of typed data is representative of applications like electronic medical imaging <ref> [7, 3] </ref> and high-speed distributed databases (such as global change repositories [17]). In addition, measuring typed data transfer reveals the overhead of presentation layer conversions and data copying for the various communication middleware mechanisms we measured. <p> However, the CORBA and RPC implementations do not omit the overhead of the function calls, which has a non-trivial overhead (shown in Section 3.2.2). 3.1.3 TTCP Parameter Settings Existing studies <ref> [7, 11, 6, 23, 18] </ref> of transport protocol performance over ATM demonstrate the impact of parameters such as socket queue sizes and data buffer on performance. <p> None of the systems described below are explicitly targeted for the requirements and constraints of communication middleware like CORBA. In particular, less attention has been paid to integrating the following topics related to communication middleware: 4.1 Transport Protocol Performance over ATM Networks <ref> [7, 11, 6] </ref> present results on performance of TCP/IP (and UDP/IP [6]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size).
Reference: [8] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: CORBA is an improvement over conventional procedural RPC middleware (such as OSF DCE and ONC RPC) since it supports object-oriented language features (such as encapsulation, interface inheritance, parameterized types, and exception handling) and advanced design patterns <ref> [8] </ref> for distributed communication. These features and patterns enable complex distributed and concurrent applications to be developed more rapidly and correctly. As shown below, the primary drawback to using higher-level middleware like CORBA is its poor performance over high-speed networks.
Reference: [9] <author> Atanu Ghosh, Jon Crowcroft, Michael Fry, and Mark Handley. </author> <title> Integrated Layer Video Decoding and Application Layer Framed Secure Login: General Lessons from Two or Three Very Different Applications. </title> <booktitle> In First International Workshop on High Performance Protocol Architectures, HIPPARCH '94, </booktitle> <institution> Sophia Antipolis, France, </institution> <month> December </month> <year> 1994. </year> <institution> INRIA France. </institution>
Reference-contexts: A remedy for this problem is to use Application Level Framing (ALF) <ref> [5, 4, 9] </ref> and Integrated Layer Processing (ILP) [5, 1, 20]. ALF ensures that lower layer protocols deal with data in units specified by the application.
Reference: [10] <author> Phillip Hoschka and Christian Huitema. </author> <title> Automatic Generation of Optimized Code for Marshalling Routines. </title> <booktitle> In IFIP Conference of Upper Layer Protocols, Architectures and Applications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994. </address> <publisher> IFIP. </publisher>
Reference-contexts: The USC stub compiler supports the automatic generation of device and protocol header marshalling code. The USC tool generates optimized C code that automatically aligns data structures and performs network/host byte order conversions. * Generating code based on Control Flow Analysis of interface specification: <ref> [10] </ref> describes a technique of exploiting application-specific knowledge contained in the type specifications of an application to generate optimized marshalling code. This work tries to achieve an optimal tradeoff between interpreted code (which is slow but compact in size) and compiled code (which is fast but larger in size).
Reference: [11] <author> K. Modeklev, E. Klovning, and O. Kure. </author> <title> TCP/IP Behavior in a High-Speed Local ATM Network Environment. </title> <booktitle> In Proceedings of the 19 th Conference on Local Computer Networks, </booktitle> <pages> pages 176-185, </pages> <address> Minneapo-lis, MN, </address> <month> October </month> <year> 1994. </year> <note> IEEE. </note>
Reference-contexts: However, the CORBA and RPC implementations do not omit the overhead of the function calls, which has a non-trivial overhead (shown in Section 3.2.2). 3.1.3 TTCP Parameter Settings Existing studies <ref> [7, 11, 6, 23, 18] </ref> of transport protocol performance over ATM demonstrate the impact of parameters such as socket queue sizes and data buffer on performance. <p> These parameters influence the size of the TCP segment window, which has been shown to significantly impact CORBA-level and TCP-level performance on high-speed networks <ref> [11, 23] </ref>. <p> None of the systems described below are explicitly targeted for the requirements and constraints of communication middleware like CORBA. In particular, less attention has been paid to integrating the following topics related to communication middleware: 4.1 Transport Protocol Performance over ATM Networks <ref> [7, 11, 6] </ref> present results on performance of TCP/IP (and UDP/IP [6]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size).
Reference: [12] <institution> Object Management Group. </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, 95-3-31 edition, </note> <month> March </month> <year> 1994. </year>
Reference-contexts: one or two integrated processing loops, rather than manipulating the data sequentially. 5 Concluding Remarks CORBA is characterized by an integrated approach that supports platform heterogeneity, high system reliability, efficient marshalling and demarshalling of parameters, flexible and efficient object location and selection, and higher level mechanisms for collaboration among services <ref> [12] </ref>. To meet these requirements and to enhance functionality provided by traditional procedural RPC toolkits (such as Sun RPC and OSF DCE), CORBA supports object-oriented language features. Many sophisticated components must be developed to support features such as remote method invocation, transparent object location and activation, and service selection.
Reference: [13] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <address> 2.0 edition, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Substantial time and effort has traditionally been required to develop this type of software; yet all too frequently communication software fails to achieve its performance and functionality requirements. Communication mid-dleware based on the Common Object Request Broker Architecture (CORBA) <ref> [13] </ref> is a promising approach for improving the flexibility, reliability, and portability of communication software. CORBA is designed to enhance distributed applications by automating common networking tasks such as parameter marshalling, object location and object activation. <p> is organized as follows: Section 2 outlines the CORBA communication middleware architecture; Section 3 demonstrates the key sources of overhead in conventional CORBA implementations over ATM; Section 4 describes related work; and Section 5 presents concluding remarks. 2 Overview of CORBA CORBA is an open standard for distributed object computing <ref> [13] </ref>. The CORBA standard defines a set of components that allow client applications to invoke operations (op) with arguments (args) on object implementations. Flexibility is enhanced by using CORBA since the object implementations can be configured to run locally and/or remotely without affecting their implementation or use. <p> In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. IDL compilers translate interfaces written in an IDL (such as Sun RPC XDR [24], DCE NDR, or CORBA CDR <ref> [13] </ref>) to other forms such as a network wire format. A significant amount of research has been devoted to developing efficient stub generators.
Reference: [14] <author> Sean W. O'Malley, Todd A. Proebsting, and Allen B. Montz. </author> <title> USC: </title>
Reference-contexts: A significant amount of research has been devoted to developing efficient stub generators. We cite a few of these and classify them as below. * Annotating high level programming languages: The Universal Stub Compiler (USC) <ref> [14] </ref> annotates the C programming language with layouts of various data types. The USC stub compiler supports the automatic generation of device and protocol header marshalling code.
References-found: 14

