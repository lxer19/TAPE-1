URL: http://www.cs.ucsd.edu/users/mihir/papers/gb.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/gb.html
Root-URL: http://www.cs.ucsd.edu
Title: Lecture Notes on Cryptography  
Author: Shafi Goldwasser Mihir Bellare 
Note: mail: shafi@theory.lcs.mit.edu Web page:  page: http://www-cse.ucsd.edu/users/mihir  
Address: 545 Technology Square, Cambridge, MA 02139, USA. E  San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA.  
Affiliation: 1 MIT Laboratory of Computer Science,  Department of Computer Science and Engineering, Mail Code 0114, University of California at  
Email: E-mail: mihir@cs.ucsd.edu  
Phone: 2  
Date: June 19, 1997  
Web: http://theory.lcs.mit.edu/ shafi  Web  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> ISO/IEC 9796. </author> <title> Information technology security techniques digital signature scheme giving message recovery, 1991. International Organization for Standards. </title>
Reference-contexts: Definition 3.3.1 A next bit test is a special kind of statistical test which takes as input a prefix of a sequence and outputs a prediction of the next bit. Definition 3.3.2 A (discrete) probability distribution on a set S is a function D : S ! <ref> [0; 1] </ref> R so that P s2S D (s) = 1. For brevity, probability distributions on f0; 1g k will be subscripted with a k. <p> We stress that we don't know of any attack on this scheme. But we prefer, for such important primitives, to have some proof of security rather than just an absence of known attacks. The same situation holds for other standards, including ISO 9796 <ref> [1] </ref>. (There the function Hash involves no cryptographic hashing, and the message M is easily recovered from Hash (M ). This doesn't effect the points we've just made.) The above discussion highlights that collision-intractability is not enough. <p> Formally an inverting algorithms is said to be a t-inverter, where t: N ! N, if its running time plus the size of its description is bounded by t (k), in some fixed standard model of computation. We say that I (t; *)-breaks RSA, where *: N ! <ref> [0; 1] </ref>, if I is a t-inverter and for each k the success probability of I is at least *(k). Finally, we say that RSA is (t; *)-secure if there is no inverter which (t; *)-breaks RSA. Example. <p> appropriate-length prefix of H (const:h0i:x) : H (const:h1i:x) : H (const:h2i:x) : : The constant const should be unique to h; to make another hash function, g, simply select a different constant. 8.6.7 Comparison with other schemes We have already discussed the PKCS standards [160, 161] and the ISO standard <ref> [1] </ref> and seen that their security cannot be justified based on the assumption that RSA is trapdoor one-way. Other standards, such as [9], are similar to [160], and the same statement applies. The schemes we discuss in the remainder of this section do not use the hash-then-decrypt paradigm.
Reference: [2] <author> L. M. Adleman. </author> <title> On breaking generalized knapsack public key cryptosystems. </title> <booktitle> In Proc. 15th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 402-412, </pages> <address> Boston, 1983. </address> <publisher> ACM. </publisher>
Reference-contexts: Cryptography: Lecture Notes 73 In fact, history has not been kind to knapsack schemes; most of them have been broken by extremely clever analysis and the use of the powerful L 3 algorithm [118] for working in lattices. See <ref> [127, 167, 169, 2, 171, 114, 42, 138] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [54], and the multiplicative versions of the knapsack [127] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [126].
Reference: [3] <author> L. M. Adleman. </author> <title> Factoring numbers using singular integers. </title> <type> Technical Report TR 90-20, </type> <institution> U.S.C. Computer Science Department, </institution> <month> September </month> <year> 1990. </year>
Reference: [4] <author> L. M. Adleman and M. A. Huang. </author> <title> Recognizing primes in random polynomial time. </title> <booktitle> In Proc. 19th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 462-469, </pages> <address> New York City, 1987. </address> <publisher> ACM. </publisher>
Reference: [5] <author> L. M. Adleman, C. Pomerance, and R. S. Rumely. </author> <title> On distinguishing prime numbers from composite numbers. </title> <journal> Ann. Math., </journal> <volume> 117 </volume> <pages> 173-206, </pages> <year> 1983. </year>
Reference: [6] <author> W. B. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr. </author> <title> RSA/Rabin functions: certain parts are as hard as the whole. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 194-209, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Alexi, Chor, Goldreich and Schnoor <ref> [6] </ref> showed that guessing the least significant bit of x from RSA &lt;n;e&gt; (x) better than at random is as hard as inverting RSA. Theorem 2.4.9 [6] Let S I. Let c &gt; 0. <p> Alexi, Chor, Goldreich and Schnoor <ref> [6] </ref> showed that guessing the least significant bit of x from RSA &lt;n;e&gt; (x) better than at random is as hard as inverting RSA. Theorem 2.4.9 [6] Let S I. Let c &gt; 0. <p> A similar result can be shown for the most signifant bit of x and in fact for the log log n least (and most) significant bits of x simultaneously. Moreover, similar results can be shown for the RABIN and BLUM-WILLIAMS collections. We refer to <ref> [6] </ref>, [186] for the detailed results and proofs. Also see [76] for reductions of improved security. 2.5 One-Way and Trapdoor Predicates A one-way predicate, first introduced in [89, 90] is a notion which preceeds hard core predicates for one-way functions and is strongly related to it. <p> Blum, Blum, and Shub [33] propose another generator, called the squaring generator , which is simpler to implement and is provably secure assuming that the quadratic residuosity problem is hard. Alexi, Chor, Goldreich, and Schnorr <ref> [6] </ref> show that the assumption that the quadratic residuosity problem is hard can be replaced by the weaker assumption that factoring is hard. A related generator is obtained by using the RSA function.
Reference: [7] <author> D. Angluin. </author> <title> Lecture notes on the complexity of some problems in number theory. </title> <type> Technical Report TR-243, </type> <institution> Yale University Computer Science Department, </institution> <month> August </month> <year> 1982. </year>
Reference: [8] <author> Eric Bach. </author> <title> How to generate factored random numbers. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 179-193, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: An interesting problem is to find an algorithm which will generate a prime p and a generator g for Z fl p . It is not known how to find generators in polynomial time. However, in <ref> [8] </ref>, E. Bach shows how to generate random factored integers (in a given range N 2 : : : N ). <p> For this we must show that it satisfies each of the conditions in the definition of a collection of one way functions. For condition 1, define S 1 to run as follows on input 1 k . (1) Run Bach's algorithm (given in <ref> [8] </ref>) to get a random integer n such that jnj = k along with its factor ization. (2) Test whether n + 1 is prime. See primality testing in section B.9. (3) If so, let p = n + 1.
Reference: [9] <author> D. Balenson. </author> <title> RFC 1423: Privacy Enhancement for Internet Electronic Mail: Part III Algorithms, Modes, and Identifiers. </title> <institution> Internet Activities Board, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Other standards, such as <ref> [9] </ref>, are similar to [160], and the same statement applies. The schemes we discuss in the remainder of this section do not use the hash-then-decrypt paradigm. Signature schemes whose security can be provably based on the RSA assumption include [95, 21, 133, 158, 70].
Reference: [10] <author> D. Beaver. </author> <title> Efficient multiparty protocols using circuit randomization. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Proc. CRYPTO 91, </booktitle> <pages> pages 420-432. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: They want to compute it obliviously, so that at the end of the game they both have the value v = f (x A ; x B ) but neither knows anything else. There are protocols for this task, and they are quite complex. We refer the reader to <ref> [10, 41] </ref> 10.1.6 Simultaneous Secret Exchange Protocol This has been studied in [35, 185, 123, 191].
Reference: [11] <author> M. Bellare, R. Canetti, and H. Krawczyk. </author> <title> Keying hash functions for message authentication. </title> <booktitle> In Proceedings of Crypto 96, volume 1109 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: They also present a heuristic construction, the MDx-MAC, based on these findings. Kaliski and Robshaw [105] discuss and compare various constructions. Performance issues are discussed in [181, 18].) Recently, one construction seems to be gaining acceptance. This is the HMAC construction of <ref> [11] </ref>. In particular HMAC was recently chosen as the mandatory to implement authentication transform for Internet security protocols and for this purpose is described in an Internet RFC [112]. The HMAC construction Let H be the hash function. <p> The properties we require are mainly a certain kind of weak collision-freeness and some limited "unpredictability." What is shown is that if the hash function function has these properties the MAC is secure; the only way the MAC could fail is if the hash function fails. The analysis of <ref> [11] </ref> applies to hash functions of the iterated type, a class that includes MD5 and SHA, and consists of hash functions built by iterating applications of a compression function CF according to the procedure of Merkle [128] and Damg-ard [59]. (In this construction a l-bit initial variable IV is fixed, and <p> (In this construction a l-bit initial variable IV is fixed, and the output of H on text x is computed by breaking x into 512 bit blocks and hashing in stages using CF, in a simple way that the reader can find described in many places, e.g. [105].) Roughly what <ref> [11] </ref> say is that an attacker who can forge the HMAC function can, with the same effort (time and collected information), break the underlying hash function in one of the following ways: (1) The attacker finds collisions in the hash function even when the IV is random and secret, or (2)
Reference: [12] <author> M. Bellare, R. Canetti, and H. Krawczyk. </author> <title> Pseudorandom functions revisited: The cascade construction and its concrete security. </title> <booktitle> In Proc. 37th IEEE Symp. on Foundations of Comp. Science. IEEE, </booktitle> <year> 1996. </year>
Reference-contexts: Else the construction is not secure. There are also other constructions. For example, the cascade construction of <ref> [12] </ref>. Also, based on the ideas of XOR MACs [18], a construction called the Protected Counter Sum was given in [30]. Different constructions have different properties in terms of security and efficiency. Similarly (or simultaneously) we may want to extend the output length. <p> While these attacks could be adapted to attack the weak collision-resistance property of MD5, they do not seem to lead to a breaking of HMAC even when used with MD5. Resistance to known attacks As shown in <ref> [149, 12] </ref>, birthday attacks, that are the basis to finding collisions in cryptographic hash functions, can be applied to attack also keyed MAC schemes based on iterated functions (including also CBC-MAC, and other schemes). These attacks apply to most (or all) of the proposed hash-based constructions of MACs.
Reference: [13] <author> M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. </author> <title> A concrete security treatment of symmetric encryption. 1997. </title> <type> Manuscript. </type>
Reference-contexts: It is not a popular mode like CBC. Counter mode XOR sometimes goes under the name of just counter mode. The randomized mode seems first to have been considered in <ref> [13] </ref>. <p> Then many definitions can be proposed. First there are the natural analogues of the definitions for the public key case. However there are other possibilities. The definition we state below is from <ref> [13] </ref>. It is in the "indistinguishability" tradition. 5.4.1 The definition The idea is that an encryption scheme is secure if you can't tell the encryption of a message from the encryption of a random string of the same length. Namely, consider the following experiment. <p> This is just a thought experiment. Yet, in fact, it is the heart of our understanding of the scheme. It is what happens in this "ideal world" that really determines the security. Lemma 5.5.1 <ref> [13] </ref> Suppose F = R (l; L) is the family of all functions of l bits to L in RX OREN C (F ). Let A be any adversary making upto q queries, totalling bits. <p> No conditions attached. Think about the numbers, and see how the change. We will not try to do the proof here. It is somewhat technical and can be found in <ref> [13] </ref>. Security with a PRF family Now, our goal is to see what happens when we use DES in the role of F . The intuition is that if F behaves "like a random function" then the security of the scheme can't be too different from the above. Theorem 5.5.2 [13] <p> <ref> [13] </ref>. Security with a PRF family Now, our goal is to see what happens when we use DES in the role of F . The intuition is that if F behaves "like a random function" then the security of the scheme can't be too different from the above. Theorem 5.5.2 [13] Suppose F : f0; 1g fi f0; 1g l ! f0; 1g L is a (t 0 ; q 0 ; * 0 )-secure pseudorandom function family. <p> This time we omit the lemmas and just state the main result. Theorem 5.5.4 <ref> [13] </ref> Suppose F : f0; 1g fi f0; 1g l ! f0; 1g l is a (t 0 ; q 0 ; * 0 )-secure pseudorandom function family.
Reference: [14] <author> M. Bellare and P. Rogaway. </author> <title> Distributing keys with perfect forward secrecy. 1994. </title> <type> Manuscript. </type> <note> 147 148 Goldwasser and Bellare </note>
Reference-contexts: The use of the DH secret key exchange protocol here is intriguing. Is that the only way to get forward secrecy? It turns out it is. Bellare and Rogaway have noted that secret key exchange is not only sufficient but also necessary for the forward secrecy property <ref> [14] </ref>. As we noted in Section 9.1.4, the DH key is not by itself a good key because we cannot guarantee bit security.
Reference: [15] <author> M. Bellare and P. Rogaway. </author> <title> Optimal asymmetric encryption. </title> <booktitle> In Proceedings of EUROCRYPT'94, volume 950 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: But, unfortunately, it still doesn't match the heuristic schemes in efficiency. Accordingly, practioners are continuing to prefer the heuristic constructions. This section presents a scheme called the OAEP (Optimal Asymmetric Encryption Padding) which can fill the gap. It was designed by Bellare and Rogaway <ref> [15] </ref>. It meets the practical constraints but at the same time has a security that can be reasonably justified, in the following sense. The scheme can be proven secure assuming some underlying hash functions are ideal. Formally, the hash functions are modeled as random oracles. <p> It is proven secure assuming the underlying hash functions are ideal. It achieves semantic security [90] and also a notion called "plaintext-aware encryption" defined in <ref> [15] </ref>. The latter notion is very strong, and in particular implies "ambitious" goals like chosen-ciphertext security and non-malleability [67] in the ideal-hash model. The methods described here are simple and completely practical. They provide a good starting point for an asymmetric encryption/key distribution standard. <p> The methods described here are simple and completely practical. They provide a good starting point for an asymmetric encryption/key distribution standard. Now we briefly describe the basic scheme and its properties. We refer the reader to <ref> [15] </ref> for full descriptions and proofs of security. The scheme Recall k is the security parameter, f mapping k-bits to k-bits is the trapdoor permutation. Let k 0 be chosen such that the adversary's running time is significantly smaller than 2 k 0 steps. <p> Now a user with some idea of the (assumed) strength of a particular f (e.g., RSA on 512 bits) can get an idea of the resources necessary to break our encryption scheme. See <ref> [15] </ref> for more details. 6.4.7 Enhancements An enhancement to OAEP, made by Johnson and Matyas [104], is to use as redundancy, instead of the 0 k 1 above, a hash of information associated to the key. <p> Typically we will construct h from some cryptographic hash function H such as H = MD5 or H = SHA-1. Ways to do this have been discussed before in <ref> [22, 15] </ref>. For completeness we quickly summarize some of these possibilities.
Reference: [16] <author> M. Bellare and P. Rogaway. </author> <title> The exact security of digital signatures: How to sign with RSA and Rabin. </title> <booktitle> In Proceedings of EUROCRYPT'96, volume 1070 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This represents a practical compromise under which we can get efficiency with reasonable security assurances. See [22] for a full discussion of this approach.) 110 Goldwasser and Bellare We present and analyze two schemes. The first is the FDH scheme of [22]. The second is the PSS of <ref> [16] </ref>. Furthermore we present a scheme called PSS-R which has the feature of message recovery. This is a useful way to effectively shorten signature sizes. Let us now expand on all of the above. We begin by looking at current practice. <p> Furthermore we present a scheme called PSS-R which has the feature of message recovery. This is a useful way to effectively shorten signature sizes. Let us now expand on all of the above. We begin by looking at current practice. Then we consider the full domain hash scheme of <ref> [22, 16] </ref> and discuss its security. Finally we come to PSS and PSS-R, and their exact security. We present these schemes for RSA. The same can be done for the Rabin scheme. <p> Finally we come to PSS and PSS-R, and their exact security. We present these schemes for RSA. The same can be done for the Rabin scheme. The materiel of this section is taken largely from <ref> [16] </ref>. 8.6.1 Signing with RSA- Current practice The RSA system. <p> We are usually satisfied when t 0 = t poly (q hash ; q sig ; k) and * 0 *. 8.6.3 The Full-Domain-Hash Scheme - FDH The scheme. Signature scheme FDH = (GenFDH ; SignFDH ; VerifyFDH ) is defined as follows <ref> [22, 16] </ref>. The key generation algorithm, on input 1 k , runs RSA (1 k ) to obtain (N; e; d). It outputs (pk; sk), where pk = (N; e) and sk = (N; d). <p> The following theorem summarizes the exact security of the FDH scheme as provided by the reduction of <ref> [22, 16] </ref>. The proof is straightforward, but it is instructive all the same, so we include it. The disadvantage of the result, from our point of view, is that * 0 could be much smaller than *. Theorem 8.6.1 [22, 16] Suppose RSA is a (t 0 ; * 0 )-secure. <p> security of the FDH scheme as provided by the reduction of <ref> [22, 16] </ref>. The proof is straightforward, but it is instructive all the same, so we include it. The disadvantage of the result, from our point of view, is that * 0 could be much smaller than *. Theorem 8.6.1 [22, 16] Suppose RSA is a (t 0 ; * 0 )-secure. <p> It preserves the efficiency and provable security of FDH but achieves the latter with a much better security bound. This is the probabilistic signature scheme (PSS) of <ref> [16] </ref>. Description of the PSS Signature scheme PSS [k 0 ; k 1 ] = (GenPSS ; SignPSS ; VerifyPSS ) is parameterized by k 0 and k 1 , which are numbers between 1 and k satisfying k 0 + k 1 k 1. <p> The relation between t and t 0 is about the same as in Theorem 8.6.1. Cryptography: Lecture Notes 115 M r ~ ~ ~ ~ ~ ~ ~ ~ ~ w r fl M fl 0 ? ? g 1 ? g 2 (w) - Theorem 8.6.2 <ref> [16] </ref> Suppose that RSA is (t 0 ; * 0 )-secure. <p> (k) = t 0 (k) [q sig (k) + q hash (k) + 1] k 0 fi (k 3 ); and *(k) = * 0 (k) + [3 (q sig (k) + q hash (k)) 2 ] (2 k 0 + 2 k 1 ) : The proof is in <ref> [16] </ref>. We stress how that proof differs from that of Theorem 8.6.1. There, we had to "guess" the value of i 2 f1; : : : ; q sig + q hash g for which F would forge a message, and we were only successful if we guessed right. <p> The above is easily adapted to handle messages of arbitrary length. A fully-specified scheme would use about minfk; n + k 0 + k 1 + 16g bits. Security. The security of PSS-R is the same as for PSS. Theorem 8.6.3 <ref> [16] </ref> Suppose that RSA is (t 0 ; * 0 )-secure.
Reference: [17] <author> Mihir Bellare, Oded Goldreich, and Shafi Goldwasser. </author> <title> Incremental cryptography: the case of hashing and signing. </title> <editor> In Yvo G. Desmedt, editor, </editor> <booktitle> Proc. CRYPTO 94, </booktitle> <pages> pages 216-233. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <note> Lecture Notes in Computer Science No. 839. </note>
Reference-contexts: One is that they are parallelizable: the different applications of f can be made in parallel. This is useful when implementing the MAC in hardware, where f might be DES. Also these MACs are incremental in the sense of <ref> [17] </ref>, in that if we have computed the tag for M and want to compute a tag of the message M 0 obtained by modifying just one block of M , we don't need to recompute a tag of M 0 from scratch: in four computations of f we can update
Reference: [18] <author> Mihir Bellare, Roch Guerin, and Phillip Rogaway. </author> <title> XOR MACs: New methods for message authentication using finite pseudorandom functions. </title> <editor> In Don Coppersmith, editor, </editor> <booktitle> Proc. CRYPTO 95, </booktitle> <pages> pages 15-28. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science No. 963. </note>
Reference-contexts: Else the construction is not secure. There are also other constructions. For example, the cascade construction of [12]. Also, based on the ideas of XOR MACs <ref> [18] </ref>, a construction called the Protected Counter Sum was given in [30]. Different constructions have different properties in terms of security and efficiency. Similarly (or simultaneously) we may want to extend the output length. <p> But it can happen in practice. Can we fix this too? The idea is to use counters, or a random string, which, recall, we were allowed, and lead to two different proposals. 7.3.2 XOR MACs A family of message authentication schemes called XOR MACs was designed by <ref> [18] </ref>. The schemes make use of a finite PRF family F , viewed as a parameter of the scheme. Let l be the input length and L the output length of F . Let f = F K be the function specified by the shared key K. <p> For this reason verify queries are considered explicitly in <ref> [18] </ref>. Here we omit them for simplicity. 7.5 Methods for secure message authentication Here are various ways to get secure message authentication schemes. 7.5.1 Pseudorandom functions make good MACs Let F be a family of pseudorandom functions with input length m and output length L. <p> Now it considers an adversary who makes q queries, and provides an absolute bound on its forgery probability. 90 Goldwasser and Bellare Lemma 7.5.4 <ref> [18] </ref> Consider the randomized XOR MAC scheme with F = R (l; L) being the family of all functions of l bits to L bits. Let A be any adversary who makes q queries, each consisting of messages of at most n blocks. <p> This theorem indicates that some forgery probability is inevitable even if the underlying family F is as good as possible. It turns out this is not a weakness of the analysis, but a fact. There is an attack that forges with roughly this probability. More precisely: Proposition 7.5.5 <ref> [18] </ref> Consider the randomized XOR MAC scheme with F = R (l; L) being the family of all functions of l bits to L bits. <p> What happens when we use some (finite) PRF family F in the randomized XOR scheme? The following theorem provides the security in this case. It is this theorem that we actually use in practice when we implement the scheme with a particular block cipher. Theorem 7.5.6 <ref> [18] </ref> Suppose F is a (t; q; *)-secure pseudorandom function family with input length l and output length L. <p> This yields the claimed relation. Security of the counter based XOR MAC We proceed analogously to the above. The interesting thing is that in the information theoretic case we straight away see a drastic improvement in security. Namely: Lemma 7.5.7 <ref> [18] </ref> Consider the counter based XOR MAC scheme with F = R (l; L) being the family of all functions of l bits to L bits. Let A be any adversary who makes q &lt; 2 l1 queries, each consisting of messages of at most n blocks. <p> As above, it turns out this bound is tight. We won't bother to state it as a proposition because it is quite obvious. Now here is the security in the computational setting. 92 Goldwasser and Bellare Theorem 7.5.8 <ref> [18] </ref> Suppose F is a (t; q; *)-secure pseudorandom function family with input length l and output length L. <p> They also present a heuristic construction, the MDx-MAC, based on these findings. Kaliski and Robshaw [105] discuss and compare various constructions. Performance issues are discussed in <ref> [181, 18] </ref>.) Recently, one construction seems to be gaining acceptance. This is the HMAC construction of [11]. In particular HMAC was recently chosen as the mandatory to implement authentication transform for Internet security protocols and for this purpose is described in an Internet RFC [112].
Reference: [19] <author> Mihir Bellare, Joe Kilian, and Phillip Rogaway. </author> <title> The security of cipher block chaining. </title> <editor> In Yvo G. Desmedt, editor, </editor> <booktitle> Proc. CRYPTO 94, </booktitle> <pages> pages 341-358. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <note> Lecture Notes in Computer Science No. 839. </note>
Reference-contexts: Let F n denote the family of functions in which the function indexed by K maps f0; 1g nl to f0; 1g l and is given by the CBC using f = F K . Theorem 4.6.3 <ref> [19] </ref> Suppose F is a (t; q; *)-secure family of PRFs. <p> What [85] formalized is what we have here called infinite pseudorandom function families. They were interested in the complexity theoretic setting. The notion of finite pseudorandom function families, and the quantization of security in terms of (t; q; *)- security, was introduced by <ref> [19] </ref>. While the basic technical idea is the same (namely that of distinguishing Cryptography: Lecture Notes 55 tests), the motivation, and hence the formalization, are different. The idea of [19] is to model block ciphers via PRF families. Accordingly, input and output lengths are fixed. <p> notion of finite pseudorandom function families, and the quantization of security in terms of (t; q; *)- security, was introduced by <ref> [19] </ref>. While the basic technical idea is the same (namely that of distinguishing Cryptography: Lecture Notes 55 tests), the motivation, and hence the formalization, are different. The idea of [19] is to model block ciphers via PRF families. Accordingly, input and output lengths are fixed. <p> Definition 7.4.1 Message authentication scheme (Tag; Vf ) is secure over message space M if any probabilistic polynomial time adversary has negligible forgery probability. In the practical analysis of message authentication schemes we need to be more quantitative. We do this following <ref> [19] </ref>. Let us look more closely at the resources of the adversary. Certainly, there is her running time t. It is useful to separately quantify the number of queries she makes to the tagging oracle: call this q. <p> An investment of time t and q queries would bring the adversary some success probability. We let * be a bound on this number to get the following quantitative version of the definition. 88 Goldwasser and Bellare Definition 7.4.2 <ref> [19] </ref> Message authentication scheme (Tag ; Vf ) is (t; q; *)-secure over message space M if for any adversary who runs in time t and makes q message queries, the forgery probability is at most *. <p> For an m-bit message M define MAC K (M ) = F K (M ). This is a secure message authentication code. This was first pointed out by [85]. Below we state an exact security version of the theorem which is from <ref> [19] </ref>. Theorem 7.5.1 Let F be a (t; q; *)-secure family of pseudorandom functions with input length m and output length L. For an m-bit message M define MAC K (M ) = F K (M ). <p> From Theorem 7.5.1 we can now conclude that the CBC construction makes a good MAC as long as the underlying functions are pseudorandom. Cryptography: Lecture Notes 89 Theorem 7.5.2 <ref> [19] </ref> Suppose F is a (t; q; *)-secure family of PRFs. For an nl bit message M define MAC K (M ) = F n K (M ).
Reference: [20] <author> Mihir Bellare and Silvio Micali. </author> <title> How to sign given any trapdoor function. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <address> Chicago, 1988. </address> <publisher> ACM. </publisher>
Reference: [21] <author> Mihir Bellare and Silvio Micali. </author> <title> How to sign given any trapdoor permutation. </title> <journal> Journal of the ACM, </journal> <volume> 39(1) </volume> <pages> 214-233, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: We will consider the security of this proposal and others. We first define security for digital signatures. 8.3 Defining and Proving Security for Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in [94] and continued in <ref> [95, 21, 133, 158, 70] </ref>. 98 Goldwasser and Bellare 8.3.1 Attacks Against Digital Signatures We distinguish three basic kinds of attacks, listed below in the order of increasing severity. * Key-Only Attack: In this attack the adversary knows only the public key of the signer and therefore only has the capability <p> In particular, Goldreich [84] has made suggestions that make the factoring-based version of this scheme more practical while preserving its security properties. Bellare and Micali in <ref> [21] </ref> have shown a digital signature scheme whose security can be based on the existence of any trapdoor permutation (a weaker requirement than claw-freeness). <p> Other standards, such as [9], are similar to [160], and the same statement applies. The schemes we discuss in the remainder of this section do not use the hash-then-decrypt paradigm. Signature schemes whose security can be provably based on the RSA assumption include <ref> [95, 21, 133, 158, 70] </ref>. The major plus of these works is that they do not use an ideal hash function (random oracle) model| the provable security is in the standard sense. <p> On the other hand, the security reductions are quite Cryptography: Lecture Notes 117 loose for each of those schemes. On the efficiency front, the efficiency of the schemes of <ref> [95, 21, 133, 158] </ref> is too poor to seriously consider them for practice. The Dwork-Naor scheme [70], on the other hand, is computationally quite efficient, taking two to six RSA computations, although there is some storage overhead and the signatures are longer than a single RSA modulus.
Reference: [22] <author> Mihir Bellare and Phillip Rogaway. </author> <title> Random oracles are practical: A paradigm for designing efficient protocols. </title> <booktitle> In First ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 62-73, </pages> <address> Fairfax, 1993. </address> <publisher> ACM. </publisher>
Reference-contexts: Formally, the hash functions are modeled as random oracles. In implementation, the hash functions are derived from cryptographic hash functions. This random oracle model represents a practical compromise under which we can get efficiency with reasonable security assurances. See <ref> [22] </ref> for a full discussion of this approach. OAEP is currently used in the SET (Secure Electronic Transactions) protocol of Visa and Mastercard. Various efforts to standardize it for public key encryption and distribution of session keys are also underway. <p> The ideal hash function paradigm As we indicated above, when proving security we take G; H to be random, and when we want a concrete scheme, G; H are instantiated by primitives derived from a cryptographic hash function. In this regard we are following the paradigm of <ref> [22] </ref> who argue that even though results which assume an ideal hash function do not provide provable security with respect to the standard model of computation, assuming an ideal hash function and doing proofs with respect to it provides much greater assurance benefit than purely ad. hoc. protocol design. <p> This represents a practical compromise under which we can get efficiency with reasonable security assurances. See <ref> [22] </ref> for a full discussion of this approach.) 110 Goldwasser and Bellare We present and analyze two schemes. The first is the FDH scheme of [22]. The second is the PSS of [16]. Furthermore we present a scheme called PSS-R which has the feature of message recovery. <p> This represents a practical compromise under which we can get efficiency with reasonable security assurances. See <ref> [22] </ref> for a full discussion of this approach.) 110 Goldwasser and Bellare We present and analyze two schemes. The first is the FDH scheme of [22]. The second is the PSS of [16]. Furthermore we present a scheme called PSS-R which has the feature of message recovery. This is a useful way to effectively shorten signature sizes. Let us now expand on all of the above. We begin by looking at current practice. <p> Furthermore we present a scheme called PSS-R which has the feature of message recovery. This is a useful way to effectively shorten signature sizes. Let us now expand on all of the above. We begin by looking at current practice. Then we consider the full domain hash scheme of <ref> [22, 16] </ref> and discuss its security. Finally we come to PSS and PSS-R, and their exact security. We present these schemes for RSA. The same can be done for the Rabin scheme. <p> Security of signature schemes. Definitions for the security of signatures in the asymptotic setting as provided by Goldwasser, Micali and Rivest [95] have already been discussed. They were enhanced to take into account the presence of an ideal hash function in <ref> [22] </ref>. Here we provide an exact version of these definitions. A forger takes as input a public key pk, where (pk; sk) R KeyGen (1 k ), and tries to forge signatures with respect to pk. <p> We are usually satisfied when t 0 = t poly (q hash ; q sig ; k) and * 0 *. 8.6.3 The Full-Domain-Hash Scheme - FDH The scheme. Signature scheme FDH = (GenFDH ; SignFDH ; VerifyFDH ) is defined as follows <ref> [22, 16] </ref>. The key generation algorithm, on input 1 k , runs RSA (1 k ) to obtain (N; e; d). It outputs (pk; sk), where pk = (N; e) and sk = (N; d). <p> The following theorem summarizes the exact security of the FDH scheme as provided by the reduction of <ref> [22, 16] </ref>. The proof is straightforward, but it is instructive all the same, so we include it. The disadvantage of the result, from our point of view, is that * 0 could be much smaller than *. Theorem 8.6.1 [22, 16] Suppose RSA is a (t 0 ; * 0 )-secure. <p> security of the FDH scheme as provided by the reduction of <ref> [22, 16] </ref>. The proof is straightforward, but it is instructive all the same, so we include it. The disadvantage of the result, from our point of view, is that * 0 could be much smaller than *. Theorem 8.6.1 [22, 16] Suppose RSA is a (t 0 ; * 0 )-secure. <p> Typically we will construct h from some cryptographic hash function H such as H = MD5 or H = SHA-1. Ways to do this have been discussed before in <ref> [22, 15] </ref>. For completeness we quickly summarize some of these possibilities.
Reference: [23] <author> Mihir Bellare and Phillip Rogaway. </author> <title> Entity authentication and key distribution. </title> <editor> In Douglas R. Stinson, editor, </editor> <booktitle> Proc. CRYPTO 93, </booktitle> <pages> pages 232-249. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <note> Lecture Notes in Computer Science No. 773. </note>
Reference-contexts: To verify, check that H (M ) is correctly tagged under the original scheme. One can show that if (Tag ; Vf ) is secure and H is collision resistant then (Tag fl ; Vf fl ) is also secure (see for example <ref> [23] </ref>). In practice this is often a good approach. The reason is that in software, hash functions like SHA-1 are faster than block ciphers like DES. <p> We now discuss various ways to realize this information advantage, and the session key distribution problems to which they give rise. Then we explain the problem in more depth. We largely follow <ref> [23, 24] </ref>. 122 Goldwasser and Bellare 9.2.1 Trust models and key distribution problems What forms might the information advantage take? There are various different trust models and corresponding key distribution problems. The three party model This model seems to have been first mentioned by Needham and Schroeder [135]. <p> assign each run of each application a separate session key. 9.2.2 History of session key distribution Although session key distribution is an old problem, it is only recently that a cryptographically sound treatment of it, in the "provable security" or "reductionist" tradition that these lecture notes are describing, has emerged <ref> [23, 24] </ref>. Via this approach we now have models in which to discuss and prove correct protocols, and several protocols proven secure under standard cryptographic assumptions. The history prior to this was troubled. <p> Building on this, Bellare and Rogaway provide a model and a definition of security for two party symmetric session key distribution <ref> [23] </ref> and for three party session key distribution [24], just like we have for primitives like encryption and signatures. Based on this they derive protocols whose security can be proven based on standard cryptographic assumptions. It turns out the protocols are efficient too. <p> We note that insufficient protection of the session key is a flaw that is present in all session key distribution protocols of which we are aware barring those of <ref> [23, 24] </ref>. <p> There are several ways one might interpret the notion of authentication. The literature has considered two ways. The first is authentication in a very strong sense, considered in <ref> [23] </ref> for the two party case. This has been relaxed to a weaker notion in [24], considered for the three party case. The weaker notion for the two party case is still under research and development. Which to prefer depends on the setting. <p> We look at providing authentic exchange of a session key, meaning the parties want to authenticate one another and simultaneously come into possession of a shared secret session key. The formal model, and the definition of what constitutes a secure authenticated session key distribution protocol, are provided in <ref> [23] </ref>. Here we will only describe some protocols. First however let us note some conventions.
Reference: [24] <author> Mihir Bellare and Phillip Rogaway. </author> <title> Provably secure session key distribution- the three party case. </title> <booktitle> In Proc. 27th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 57-66, </pages> <address> Las Vegas, 1995. </address> <publisher> ACM. </publisher>
Reference-contexts: We now discuss various ways to realize this information advantage, and the session key distribution problems to which they give rise. Then we explain the problem in more depth. We largely follow <ref> [23, 24] </ref>. 122 Goldwasser and Bellare 9.2.1 Trust models and key distribution problems What forms might the information advantage take? There are various different trust models and corresponding key distribution problems. The three party model This model seems to have been first mentioned by Needham and Schroeder [135]. <p> assign each run of each application a separate session key. 9.2.2 History of session key distribution Although session key distribution is an old problem, it is only recently that a cryptographically sound treatment of it, in the "provable security" or "reductionist" tradition that these lecture notes are describing, has emerged <ref> [23, 24] </ref>. Via this approach we now have models in which to discuss and prove correct protocols, and several protocols proven secure under standard cryptographic assumptions. The history prior to this was troubled. <p> Building on this, Bellare and Rogaway provide a model and a definition of security for two party symmetric session key distribution [23] and for three party session key distribution <ref> [24] </ref>, just like we have for primitives like encryption and signatures. Based on this they derive protocols whose security can be proven based on standard cryptographic assumptions. It turns out the protocols are efficient too. Now other well justified protocols are also emerging. <p> We note that insufficient protection of the session key is a flaw that is present in all session key distribution protocols of which we are aware barring those of <ref> [23, 24] </ref>. <p> There are several ways one might interpret the notion of authentication. The literature has considered two ways. The first is authentication in a very strong sense, considered in [23] for the two party case. This has been relaxed to a weaker notion in <ref> [24] </ref>, considered for the three party case. The weaker notion for the two party case is still under research and development. Which to prefer depends on the setting. The approach we will follow here is to follow the existing literature. <p> We now consider parties A; B, whose keys K A and K B , respectively have this form. A terse representation of the protocol of <ref> [24] </ref> is is given in Figure 9.3, and a more complete explanation follows. Flow 1. A ! B: R A Flow 2. B ! S: R A : R B Flow 3A.
Reference: [25] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness theorems for fault-tolerant distributed computing. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <address> Chicago, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: Their protocol tolerated up to O (log n) colluders. Benaloh [26], and others [87, 74] showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders. In <ref> [25] </ref> it has been recently shown how to achieve verifiable secret sharing against a third of colluders using error correcting codes, without making cryptographic assumptions. <p> Their compiler correctness and privacy is based on the existence of trapdoor functions. Ben-Or, Goldwasser and Wigderson <ref> [25] </ref> and Chaum, Crepeau, and Damg _ard [50] go one step further. They assume secret communication between pairs of users as a primitive.
Reference: [26] <author> J. Benaloh. </author> <title> Secret sharing homomorphisms: Keeping shares of a secret sharing. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proc. CRYPTO 86. </booktitle> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: They call the new protocol verifiable secret sharing since now every party can verify that the piece of the secret he received is indeed a proper piece. Their protocol tolerated up to O (log n) colluders. Benaloh <ref> [26] </ref>, and others [87, 74] showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders. In [25] it has been recently shown how to achieve verifiable secret sharing against a third of colluders using error correcting codes, without making cryptographic assumptions.
Reference: [27] <author> J. Benaloh and D. Tuinstra. </author> <title> Receipt-free secret ballot elections. </title> <booktitle> In 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 544-553, </pages> <year> 1994. </year>
Reference-contexts: There have been some solutions proposed to this problem that use some form of physical assumption. For example one could allow the voter to exchange a limited number of bits over a secure channel with the voting centers <ref> [27, 162] </ref>. This would hopefully prevent the coercer from noticing that the voter is not following his instructions. Or one could force the voter to use some tamper-proof device that encrypts messages for him, choosing the randomness.
Reference: [28] <author> Josh Benaloh. </author> <title> Verifiable secret ballot elections. </title> <type> Technical Report TR-561, </type> <institution> Yale Department of Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: We will discuss this point at the end. The ideas behind this approach are due to Josh Benaloh <ref> [28] </ref>. The protocol described in the following section is the most efficient one in the literature due to Cramer, Franklin, Schoemakers and Yung [58].
Reference: [29] <author> R. Berger, R. Peralta, and T. Tedrick. </author> <title> A provably secure oblivious transfer protocol. </title> <editor> In T. Beth, N. Cot, and I. Ingemarsson, editors, </editor> <booktitle> Proc. EUROCRYPT 84, </booktitle> <pages> pages 379-386. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 209. </note>
Reference-contexts: This strange-sounding protocol has a number of useful applications (see, for example <ref> [152, 29] </ref>). In fact, Kilian has shown [109] that the ability to perform oblivious transfers is a sufficiently strong primitive to enable any two-party protocol to be performed.
Reference: [30] <author> D. Bernstein. </author> <title> How to stretch random functions: the security of protected counter sums, </title> <year> 1997. </year> <month> Manuscrupt. </month>
Reference-contexts: Else the construction is not secure. There are also other constructions. For example, the cascade construction of [12]. Also, based on the ideas of XOR MACs [18], a construction called the Protected Counter Sum was given in <ref> [30] </ref>. Different constructions have different properties in terms of security and efficiency. Similarly (or simultaneously) we may want to extend the output length.
Reference: [31] <author> R. Bird, I. Gopal, A. Herzberg, P. Janson, S. Kutten, R. Molva, and M. Yung. </author> <title> Systematic design of two-party authentication protocols. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Proc. CRYPTO 91, </booktitle> <pages> pages 44-61. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science No. 576. Cryptography: Lecture Notes 149 </booktitle>
Reference-contexts: The most prevalent problem is a lack of specification of what exactly is the problem that one is trying to solve. There is no model of adversarial capabilities, or definition of security. Influential works in this area were Bird et. al. <ref> [31] </ref> and Diffie et. al. [65]. In particular the former pointed to new classes of attacks, called "interleaving attacks," which they used to break existing protocols, and they suggested a protocol (2PP) defeated by none of the interleaving attacks they considered.
Reference: [32] <author> G. R. Blakley. </author> <title> Safeguarding cryptographic keys. </title> <booktitle> In Proc. AFIPS 1979 National Computer Conference, </booktitle> <pages> pages 313-317. </pages> <publisher> AFIPS, </publisher> <year> 1979. </year>
Reference-contexts: The protocol should guarantee that the "good" parties are able to achieve the goal even though the corrupted parties send misleading information or otherwise maliciously misbehave in an attempt to prevent the good parties from succeeding. 10.3.1 Secret sharing Secret Sharing protocols were invented independently by Blakley and Shamir <ref> [32, 168] </ref>. In the multi-party setting, secret sharing is a fundamental protocol and tool. The basic idea is protection of privacy of information by distribution. Say you have a key to an important system. You are afraid you might loose it, so you want to give it to someone else.
Reference: [33] <author> L. Blum, M. Blum, and M. Shub. </author> <title> A simple unpredictable pseudo-random number generator. </title> <journal> SIAM J. Computing, </journal> <volume> 15(2) </volume> <pages> 364-383, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: They call a pseudo-random bit generator secure if an adversary cannot guess the next bit in the sequence from the prefix of the sequence, better than guessing at random. Blum and Micali then proposed a particular generator based on the difficulty of computing discrete logarithms. Blum, Blum, and Shub <ref> [33] </ref> propose another generator, called the squaring generator , which is simpler to implement and is provably secure assuming that the quadratic residuosity problem is hard. <p> Listed below are these generators (including the Blum/Blum/Shub generator which will be discussed afterwards) and their associated costs. See <ref> [38, 33, 156] </ref>. <p> However, it has been shown <ref> [33, 37] </ref> using later ideas on pseudo-random number generation how to start with trapdoor functions and build a probabilistic encryption scheme that is polynomial-time secure for which the ciphertext is longer than the cleartext by only an additive factor. <p> Cryptography: Lecture Notes 81 The use of the redundancy (the 0 k 1 term and the check for it in decryption) is in order to provide plaintext awareness. Efficiency The function f can be set to any candidate trapdoor permutation such as RSA [156] or modular squaring <ref> [150, 33] </ref>. In such a case the time for computing G and H is negligible compared to the time for computing f; f 1 . Thus complexity is discussed only in terms of f; f 1 computations.
Reference: [34] <author> M. Blum. </author> <title> Coin flipping by telephone. </title> <booktitle> In Proc. IEEE Spring COMPCOM, </booktitle> <pages> pages 133-137. </pages> <publisher> IEEE, </publisher> <year> 1982. </year>
Reference-contexts: But what if the sender could create a y that could be opened both ways? It would have the discrete logarithm of s. Commitment schemes are useful for lots of things. In particular, ZK proofs, but also coin flipping. 10.1.4 Coin flipping in a well Blum <ref> [34] </ref> has proposed the problem of coin flipping over the telephone. Alice and Bob want a fair, common, coin. They want to take a random choice, but neither should be able to dictate it. Heads Alice wins, and tails Bob wins.
Reference: [35] <author> M. Blum. </author> <title> How to exchange (secret) keys. </title> <journal> Trans. Computer Systems, </journal> <volume> 1 </volume> <pages> 175-193, </pages> <month> May </month> <year> 1983. </year> <note> (Previously published in ACM STOC '83 proceedings, pages 440-447.). </note>
Reference-contexts: There are protocols for this task, and they are quite complex. We refer the reader to [10, 41] 10.1.6 Simultaneous Secret Exchange Protocol This has been studied in <ref> [35, 185, 123, 191] </ref>. The protocol given here is an example of a protocol that seems to work at first glance, but is in actuality open to cheating for similar reasons that the above oblivious transfer protocol was open to cheating. <p> What we want is for A and B to be able to figure out s B and s A at the "same time". We assume equal computing power and knowledge of algorithms. The suggested protocol of Blum <ref> [35] </ref> follows . 132 Goldwasser and Bellare Step 1: A picks a 1 ; a 2 ; :::; a K at random in Z fl n B and then computes b i = a 2 i (mod n B ) for 1 i k.
Reference: [36] <author> M. Blum. </author> <title> Independent unbiased coin flips from a correlated biased source: A finite state Markov chain. </title> <booktitle> In Proc. 25th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 425-433, </pages> <address> Singer Island, 1984. </address> <publisher> IEEE. </publisher>
Reference-contexts: The result is an unbiased uncorrelated source, since the 01 and 10 pairs will have an identical probability of occurring. Elias [71] generalizes this idea to achieve an output rate near the source entropy. Handling a correlated bit source is more difficult. Blum <ref> [36] </ref> shows how to produce unbiased uncorrelated bits from a biased correlated source which produces output bits according to a known finite Markov chain.
Reference: [37] <author> M. Blum and S. Goldwasser. </author> <title> An efficient probabilistic public-key encryption scheme which hides all partial information. </title> <editor> In G. R. Blakley and D. C. Chaum, editors, </editor> <booktitle> Proc. CRYPTO 84, </booktitle> <pages> pages 289-302. </pages> <publisher> Springer, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 196. </note>
Reference-contexts: However, it has been shown <ref> [33, 37] </ref> using later ideas on pseudo-random number generation how to start with trapdoor functions and build a probabilistic encryption scheme that is polynomial-time secure for which the ciphertext is longer than the cleartext by only an additive factor. <p> The most efficient probabilistic encryption scheme is due to Blum and Goldwasser <ref> [37] </ref> and is comparable with the RSA deterministic encryption scheme in speed and data expansion. Recall, that private-key encryption seemed to be much more efficient. <p> Examples of schemes achieving these conditions are [160, 103]. Unfortunately, these are heuristic schemes. A provably secure scheme would be preferable. We have now seen several provably good asymmetric (i.e. public key) encryption schemes. The most efficient is the Blum-Goldwasser scheme <ref> [37] </ref>. But, unfortunately, it still doesn't match the heuristic schemes in efficiency. Accordingly, practioners are continuing to prefer the heuristic constructions. This section presents a scheme called the OAEP (Optimal Asymmetric Encryption Padding) which can fill the gap. It was designed by Bellare and Rogaway [15].
Reference: [38] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM J. Computing, </journal> <volume> 13(4) </volume> <pages> 850-863, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Historical Note: The idea of a hard-core predicate for one-way functions was introduced by Blum, Goldwasser and Micali. It first appears in a paper by Blum and Micali <ref> [38] </ref> on pseduo random number generation. They showed that a if the EXP function (f p;g (x) = g x (mod p)) is hard to invert then it is hard to even guess better than guessing at random the most significant bit of x. <p> We point to <ref> [38] </ref> for a proof of the above theorem. As a corollary we immediately get the following. <p> This is not strong enough to prove that, when used in a one-time pad scheme, each bit of the message will be well-protected. Blum and Micali <ref> [38] </ref> introduced the first method for designing provably secure pseudo-random bit sequence generators, based on the use of one-way predicates. They call a pseudo-random bit generator secure if an adversary cannot guess the next bit in the sequence from the prefix of the sequence, better than guessing at random. <p> Listed below are these generators (including the Blum/Blum/Shub generator which will be discussed afterwards) and their associated costs. See <ref> [38, 33, 156] </ref>. <p> Indeed it was exactly such considerations that helped inspire ideas like semantic security [90] and hardcore bits <ref> [38, 189] </ref>. Cryptography: Lecture Notes 81 The use of the redundancy (the 0 k 1 term and the check for it in decryption) is in order to provide plaintext awareness.
Reference: [39] <author> M. Blum, A. De Santis, S. Micali, and G. Persiano. </author> <title> Noninteractive zero-knowledge. </title> <journal> SIAM J. Computing, </journal> <volume> 20(6) </volume> <pages> 1084-1118, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: If it answers m, then B i (y) = b. If it doesn't decrypt c, then B i (y) = b. What is done instead uses the notion of Non-Interactive Zero-Knowledge Proofs (NIZK) <ref> [39, 134] </ref>. The idea is that anyone can check a NIZK to see that it is correct, but no knowledge can be extracted from it about what is being proved, except that it is correct. Shamir and Lapidot have shown that if trapdoor functions exist, then NIZKs exist.
Reference: [40] <author> D. Boneh and R. Venkatesan. </author> <title> Hardness of computing the most significant bits of secret keys in Diffie-Hellman and related schemes. </title> <booktitle> In Proceedings of CRYPTO'96, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: A theorem like that for the DH key would be nice, and would indicate how to extract bits to use for a symmetric key. Recently results of this kind have been proved by Boneh and Venkatesan <ref> [40] </ref>. 9.1.5 The lack of authenticity At first glance, the DH secret key exchange might appear to solve in one stroke the entire problem of getting keys to do cryptography.
Reference: [41] <author> Gilles Brassard and Claude Crepeau. </author> <title> Zero-knowledge simulation of boolean circuits. </title> <editor> In A.M. Odlyzko, editor, </editor> <booktitle> Proc. CRYPTO 86, </booktitle> <pages> pages 223-233. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: They want to compute it obliviously, so that at the end of the game they both have the value v = f (x A ; x B ) but neither knows anything else. There are protocols for this task, and they are quite complex. We refer the reader to <ref> [10, 41] </ref> 10.1.6 Simultaneous Secret Exchange Protocol This has been studied in [35, 185, 123, 191].
Reference: [42] <author> E. F. Brickell. </author> <title> Solving low density knapsacks. </title> <editor> In D. Chaum, editor, </editor> <booktitle> Proc. CRYPTO 83, </booktitle> <pages> pages 25-37, </pages> <address> New York, 1984. </address> <publisher> Plenum Press. </publisher>
Reference-contexts: Cryptography: Lecture Notes 73 In fact, history has not been kind to knapsack schemes; most of them have been broken by extremely clever analysis and the use of the powerful L 3 algorithm [118] for working in lattices. See <ref> [127, 167, 169, 2, 171, 114, 42, 138] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [54], and the multiplicative versions of the knapsack [127] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [126].
Reference: [43] <author> M. Burrows, M. Abadi, and R. Needham. </author> <title> A logic for authentication. </title> <journal> ACM Transactions on computer systems, </journal> <volume> 8(1). </volume>
Reference-contexts: As a result of a long history of such attacks there is finally a general consensus that session key distribution is not a goal adequately addressed by giving a protocol for which the authors can find no attacks. A large body of work, beginning with Burrows, Abadi and Needham <ref> [43] </ref>, aims to improve on this situation via the use of special-purpose logics. The aim is to demonstrate a lack of "reasoning problems" in a protocol being analyzed.
Reference: [44] <author> R. Canetti, C. Dwork, M. Naor, and R. Ostrovsky. </author> <title> Deniable encryption. </title> <booktitle> In Proc. CRYPTO 97, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: This is not possible in the protocol above (unless the voter solves the discrete log problem.) Recently however a protocol for this purpose has been proposed by Canetti and Gennaro [45]. They use a new tool called deniable encryption (invented by Canetti, Dwork, Naor and Ostrovsky <ref> [44] </ref>), which is a new form of public key probabilistic encryption E with the following property. Let m be the message and r the coin tosses of the sender. The sender computes the ciphertext c = E r (m).
Reference: [45] <author> R. Canetti and R. Gennaro. </author> <title> Incoercible multiparty computation. </title> <booktitle> In Proc. 37th IEEE Symp. on Foundations of Comp. Science, </booktitle> <year> 1996. </year>
Reference-contexts: This is not possible in the protocol above (unless the voter solves the discrete log problem.) Recently however a protocol for this purpose has been proposed by Canetti and Gennaro <ref> [45] </ref>. They use a new tool called deniable encryption (invented by Canetti, Dwork, Naor and Ostrovsky [44]), which is a new form of public key probabilistic encryption E with the following property. Let m be the message and r the coin tosses of the sender.
Reference: [46] <author> E.R. Canfield, P. Erdos, and C. Pomerance. </author> <title> On a problem of Oppenheim concerning `Factorisatio Numerorum'. </title> <journal> J. Number Theory, </journal> <volume> 17 </volume> <pages> 1-28, </pages> <year> 1983. </year>
Reference: [47] <author> M. Cerecedo, T. Matsumoto, and H. Imai. </author> <title> Efficient and secure multiparty generation of digital signatures based on discrete logarithm. </title> <journal> IEICE Trans. </journal> <note> on Fund. </note> <institution> Electr. Comm. and Comp. Sci., E76-A(4):532-545, </institution> <year> 1993. </year>
Reference-contexts: For the case of discrete-log based signature schemes, this quest has been successful. Robust threshold signature schemes for the El Gamal, Schnorr and DSS signature schemes (see [80, 165, 77]) can be found in <ref> [47, 140, 83] </ref>, all using underlying results of Feldman and Pedersen [74, 141, 142]. Yet, in some cases the dealer solution is the best we can do. <p> Interaction should be reduced to a minimum For El Gamal-like schemes robust threshold signature schemes can be found in <ref> [47, 140] </ref>. The specific case of DSS turned out to be very difficult to handle. The best solution is in [83]. RSA turned out to be even less amenable to the construction of robust schemes.
Reference: [48] <author> D. Chaum. </author> <title> Untraceable electronic mail, return addresses, and digital pseudonyms. </title> <journal> Communications of the ACM, </journal> <volume> 24 </volume> <pages> 84-88, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: Using pseudonyms, individuals can enter into electronic transactions with assurance that the transactions can not be later traced to the individual. However, since the individual is anonymous, the other party may wish assurance that the individual is authorized to enter into the transaction, or is able to pay. <ref> [48, 51] </ref>. 10.3.4 Multiparty Ping-Pong Protocols One way of demonstrating that a cryptographic protocol is secure is to show that the primitive operations that each party performs can not be composed to reveal any secret information. <p> The term digital cash describes cryptographic techniques and protocols that aim to recreate the concept of cash-based shopping over the Internet. First we will describe a general approach to digital cash based on public-key cryptography. This approach was originally suggested by David Chaum <ref> [48] </ref>.
Reference: [49] <author> D. Chaum, A. Fiat, and M. Naor. </author> <title> Untraceable electronic cash. </title> <editor> In S. Goldwasser, editor, </editor> <booktitle> Proc. CRYPTO 88, </booktitle> <pages> pages 319-327. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Lecture Notes in Computer Science No. 403. </note>
Reference-contexts: If the Bank receives two identical bills with different RIS values, then the User has cheated and the bank can identify him. If the Bank receives two identical bills with the same RIS values, then the Vendor has cheated. The above idea appeared first in <ref> [49] </ref>. Here is a possible solution. Let H to be a one-way hash function. Withdrawal Protocol: 1.
Reference: [50] <author> David Chaum, Claude Crepeau, and Ivan Damg-ard. </author> <title> Multiparty unconditionally secure protocols. </title> <editor> In Carl Pomerance, editor, </editor> <booktitle> Proc. CRYPTO 87, </booktitle> <pages> pages 462-462. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Lecture Notes in Computer Science No. 293. 150 Goldwasser and Bellare </note>
Reference-contexts: Their compiler correctness and privacy is based on the existence of trapdoor functions. Ben-Or, Goldwasser and Wigderson [25] and Chaum, Crepeau, and Damg _ard <ref> [50] </ref> go one step further. They assume secret communication between pairs of users as a primitive.
Reference: [51] <author> David L. Chaum. </author> <title> Verification by anonymous monitors. </title> <editor> In Allen Gersho, editor, </editor> <booktitle> Advances in Cryptology: </booktitle>
Reference-contexts: Using pseudonyms, individuals can enter into electronic transactions with assurance that the transactions can not be later traced to the individual. However, since the individual is anonymous, the other party may wish assurance that the individual is authorized to enter into the transaction, or is able to pay. <ref> [48, 51] </ref>. 10.3.4 Multiparty Ping-Pong Protocols One way of demonstrating that a cryptographic protocol is secure is to show that the primitive operations that each party performs can not be composed to reveal any secret information.
References-found: 51

