URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-350.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: fxxzhang,ryderg@cs.rutgers.edu  wlandi@scr.siemens.com  
Title: Experiments with Combined Analysis for Pointer Aliasing  
Author: Sean Zhang Barbara G. Ryder William A. Landi 
Address: Piscataway, NJ 08855  755 College Rd. East Princeton, NJ 08540  
Affiliation: Department of Computer Science Rutgers University Hill Center, Busch Campus  Siemens Corporate Research Inc  
Abstract: We present initial empirical experiments with combined analysis, a scalable analysis technique that uses a program decomposition to apply different aliasing algorithms to independent program segments. The effectiveness of the solution strategy is validated through application to side-effect and reference analysis of C programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Lars Ole Andersen. </author> <title> Program analysis and specialization for the C programming language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> may </month> <year> 1994. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive <ref> [1] </ref>. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21].
Reference: [2] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> number No. 892, </volume> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <booktitle> Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing. </booktitle>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21].
Reference: [3] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive <ref> [3, 13] </ref>, or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. <p> These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [4] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive in-terprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of te 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [5] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [6] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis <ref> [6] </ref>, heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [7] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a dag, or a cyclic graph? a shape analysis for heap-directed pointers in c. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [8] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <year> 1990. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [9] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [10] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of 1992 ACM Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Given a program decomposition, a particular combined analysis assigns a specific analysis method to each program segment. In [23], we also compared (i) a whole-program analysis by a flow-sensitive and context-sensitive method (FS) <ref> [10] </ref>, and (ii) a whole-program analysis by a flow-insensitive and context-insensitive method (FA), with (iii) one combined analysis using both FS and FA on different segments. <p> In Figure 1, we present the test programs, which include Unix utilities, Spec benchmarks, and programs used in <ref> [10, 19] </ref>. The programs are ordered by the number of nodes in their internal representation (ICFG), a better size estimate than lines of code. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm (FS) <ref> [10, 19] </ref> 2. a flow-insensitive and context-insensitive aliasing analysis algorithm (FA) [22, 23] 3. a flow-insensitive and context-insensitive points to 2 analysis algorithm (PT) [22] 2 Aliasing information can be easily derived from points-to infor mation, although with a potential loss of precision. <p> We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [11] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis <ref> [3, 5, 7, 8, 9, 11] </ref>, or both [4, 10, 13, 17, 18, 21]. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [12] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: a clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <year> 1993. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1].
Reference: [13] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive <ref> [3, 13] </ref>, or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [14] <author> Erik Ruf. </author> <title> Partitioning dataflow analyses using types. </title> <booktitle> In Conference Record of te 24th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: We first presented a program decomposition technique for pointer aliasing [23]. Ruf <ref> [14] </ref> suggested using declared types or using type inference techniques such as [17, 18] for program decomposition. 5 Conclusion Combined analysis uses a program decomposition technique to apply aliasing algorithms that differ in cost and precision to independent segments of a program.
Reference: [15] <author> Marc Shapiro and Susan Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In Proceedings of the Fourth International Symposium on Static Analysis, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21].
Reference: [16] <author> Marc Shapiro and Susan Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Conference Record of te 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. <p> Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis. Shapiro and Horwitz investigated a family of flow-insensitive and context-insensitive points-to algorithms <ref> [16] </ref>; we believe the heuristic in our third combined analysis is related to the property they use to distinguish between the degree of approximation in these algorithms. We first presented a program decomposition technique for pointer aliasing [23].
Reference: [17] <author> Bjarne Steensgaard. </author> <title> Points-to analysis by type inference of pro-rams with structures and unions. </title> <booktitle> In International Conference on Compiler Construction, number 1060 in Lecture Notes in Computer Science, </booktitle> <pages> pages 136-150. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis. <p> We first presented a program decomposition technique for pointer aliasing [23]. Ruf [14] suggested using declared types or using type inference techniques such as <ref> [17, 18] </ref> for program decomposition. 5 Conclusion Combined analysis uses a program decomposition technique to apply aliasing algorithms that differ in cost and precision to independent segments of a program.
Reference: [18] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis. <p> We first presented a program decomposition technique for pointer aliasing [23]. Ruf [14] suggested using declared types or using type inference techniques such as <ref> [17, 18] </ref> for program decomposition. 5 Conclusion Combined analysis uses a program decomposition technique to apply aliasing algorithms that differ in cost and precision to independent segments of a program.
Reference: [19] <author> Philip Stocks, Barbara Ryder, William Landi, and Sean Zhang. </author> <title> Comparing flow and context sensitivity on the modification-side-effects problem. </title> <booktitle> In Proceeding of the International Symposium on Software Testing and Analysis, </booktitle> <month> March </month> <year> 1998. </year> <note> To Appear. Also available as DCS-TR-335. </note>
Reference-contexts: For the first combined analysis, we repeat the comparison in [23] using more data. We wish to explore the cost/precision tradeoffs in the three methods. At present, FS is not scalable to all large (&gt;10,000 lines of code) programs <ref> [19] </ref>. Investigating the application of FS to certain segments of large programs is of interest, because it has better precision than flow-insensitive methods. For the second combined analysis, we use another flow-insensitive and context-insensitive aliasing method (PT) [22] on those segments which have FA applied in the first one. <p> In Figure 1, we present the test programs, which include Unix utilities, Spec benchmarks, and programs used in <ref> [10, 19] </ref>. The programs are ordered by the number of nodes in their internal representation (ICFG), a better size estimate than lines of code. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm (FS) <ref> [10, 19] </ref> 2. a flow-insensitive and context-insensitive aliasing analysis algorithm (FA) [22, 23] 3. a flow-insensitive and context-insensitive points to 2 analysis algorithm (PT) [22] 2 Aliasing information can be easily derived from points-to infor mation, although with a potential loss of precision.
Reference: [20] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: These algorithms can be classified into flow-sensitive and context-sensitive [4, 5, 6, 7, 10, 12, 21], flow-insensitive and context-insensitive <ref> [2, 15, 16, 17, 18, 20] </ref>, flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both [4, 10, 13, 17, 18, 21].
Reference: [21] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: We plan to conduct more experiments by varying the threshold to explore the tradeoff of efficiency and precision. 4 Related Work Many pointer aliasing analysis or points-to analysis algorithms have been proposed in the literature. These algorithms can be classified into flow-sensitive and context-sensitive <ref> [4, 5, 6, 7, 10, 12, 21] </ref>, flow-insensitive and context-insensitive [2, 15, 16, 17, 18, 20], flow-sensitive and context-insensitive [3, 13], or flow-insensitive and context-sensitive [1]. <p> They can also be organized into stack-based aliasing analysis [6], heap-based aliasing analysis [3, 5, 7, 8, 9, 11], or both <ref> [4, 10, 13, 17, 18, 21] </ref>. Any of these algorithms can be employed for program segments associated with individual weakly connected components in our program decomposition and thus can be used in a combined analysis.
Reference: [22] <author> Sean Zhang. </author> <title> Practical Pointer Aliasing Analyses for C. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1998. </year>
Reference-contexts: We have extended the decomposition technique and the FA algorithm to handle more features in C such as indirect calls through function pointers, unions and type casting <ref> [22] </ref>. For the first combined analysis, we repeat the comparison in [23] using more data. We wish to explore the cost/precision tradeoffs in the three methods. At present, FS is not scalable to all large (&gt;10,000 lines of code) programs [19]. <p> Investigating the application of FS to certain segments of large programs is of interest, because it has better precision than flow-insensitive methods. For the second combined analysis, we use another flow-insensitive and context-insensitive aliasing method (PT) <ref> [22] </ref> on those segments which have FA applied in the first one. <p> 0 101 022.li 10687 7443 3 0 5 larn 21185 9550 1 0 22 008.espresso 30416 13619 15 0 191 T-W-MC 51628 23788 18 0 273 We have extended the original decomposition algorithm to handle features of C programs such as indirect calls through function pointers, unions and type casting <ref> [22] </ref> and have used this general decomposition for the experiments described here. In Figure 1, we present the test programs, which include Unix utilities, Spec benchmarks, and programs used in [10, 19]. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm (FS) [10, 19] 2. a flow-insensitive and context-insensitive aliasing analysis algorithm (FA) <ref> [22, 23] </ref> 3. a flow-insensitive and context-insensitive points to 2 analysis algorithm (PT) [22] 2 Aliasing information can be easily derived from points-to infor mation, although with a potential loss of precision. Both the FA and PT analyses can handle unions and type casting with some minor restrictions. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm (FS) [10, 19] 2. a flow-insensitive and context-insensitive aliasing analysis algorithm (FA) [22, 23] 3. a flow-insensitive and context-insensitive points to 2 analysis algorithm (PT) <ref> [22] </ref> 2 Aliasing information can be easily derived from points-to infor mation, although with a potential loss of precision. Both the FA and PT analyses can handle unions and type casting with some minor restrictions.
Reference: [23] <author> Sean Zhang, Barbara G. Ryder, and William Landi. </author> <title> Program decomposition for pointer aliasing: A setp toward practical analyses. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 81-92, </pages> <month> Oc-tober </month> <year> 1996. </year>
Reference-contexts: Measurement of analysis effectiveness is accomplished by using both side-effect and reference calculations on C programs. Previously, we presented a program decomposition technique <ref> [23] </ref>, which partitions the assignments in a program with respect to their aliasing effects. This is accomplished by calculating an equivalence relation on the names in the program. <p> This tech fl This research was supported, in part, by NSF grants CCR95-01761 and GER90-23628. nique is termed combined analysis. Given a program decomposition, a particular combined analysis assigns a specific analysis method to each program segment. In <ref> [23] </ref>, we also compared (i) a whole-program analysis by a flow-sensitive and context-sensitive method (FS) [10], and (ii) a whole-program analysis by a flow-insensitive and context-insensitive method (FA), with (iii) one combined analysis using both FS and FA on different segments. <p> We have extended the decomposition technique and the FA algorithm to handle more features in C such as indirect calls through function pointers, unions and type casting [22]. For the first combined analysis, we repeat the comparison in <ref> [23] </ref> using more data. We wish to explore the cost/precision tradeoffs in the three methods. At present, FS is not scalable to all large (&gt;10,000 lines of code) programs [19]. <p> In Section 3, we present the empirical results of the three combined analyses. Finally, we discuss related work in Section 4 and give conclusions in Section 5. 2 Program Decomposition The following is an informal description of the program decomposition technique in <ref> [23] </ref>. The key statements that affect pointer aliasing in a C program are assignments involving addresses, pointer values, and structures 1 , referred to as ptr-assignments. From them, we calculate an equivalence relation (PE relation) on the names in the program. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm (FS) [10, 19] 2. a flow-insensitive and context-insensitive aliasing analysis algorithm (FA) <ref> [22, 23] </ref> 3. a flow-insensitive and context-insensitive points to 2 analysis algorithm (PT) [22] 2 Aliasing information can be easily derived from points-to infor mation, although with a potential loss of precision. Both the FA and PT analyses can handle unions and type casting with some minor restrictions. <p> Shapiro and Horwitz investigated a family of flow-insensitive and context-insensitive points-to algorithms [16]; we believe the heuristic in our third combined analysis is related to the property they use to distinguish between the degree of approximation in these algorithms. We first presented a program decomposition technique for pointer aliasing <ref> [23] </ref>. Ruf [14] suggested using declared types or using type inference techniques such as [17, 18] for program decomposition. 5 Conclusion Combined analysis uses a program decomposition technique to apply aliasing algorithms that differ in cost and precision to independent segments of a program.
References-found: 23

