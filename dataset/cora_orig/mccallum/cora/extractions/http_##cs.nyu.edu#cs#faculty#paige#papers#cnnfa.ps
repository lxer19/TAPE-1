URL: http://cs.nyu.edu/cs/faculty/paige/papers/cnnfa.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Email: changch@iis.sinica.edu.tw  paige@cs.nyu.edu  
Title: From Regular Expressions to DFA's Using Compressed NFA's  
Author: Chia-Hsiang Chang Teipei, Taiwan, R. O. C. Robert Paige 
Date: May 3, 1996  
Address: New York University 251 Mercer St. New York, NY 10012  
Affiliation: Institute of Information Science Academica Sinica  Courant Institute of Mathematical Sciences  
Abstract: There are two principal methods for turning regular expressions into NFA's one due to McNaughton and Yamada and another due to Thomp-son. Unfortunately, both have drawbacks. Given a regular expression R of length r and with s occurrences of alphabet symbols, Chang and Paige (1992) and Bruggemann-Klein (1993) gave fi(m + r) time and O(r) space algorithms to produce a fi(m) space representation of McNaughton and Yamada's NFA with s+1 states and m transitions. The problem with this NFA is that m = fi(s 2 ) in the worst case. Thompson's method takes fi(r) time and space to construct a fi(r) space NFA with fi(r) states and fi(r) transitions. The problem with this NFA is that r can be arbitrarily larger than s. We overcome drawbacks of both methods with a fi(r) time fi(s) space algorithm to construct an O(s) space representation of McNaughton and Yamada's NFA. Given any set V of NFA states, our representation can be used to compute the set U of states one transition away from the states in V in optimal time O(jV j + jU j). McNaughton and Yamada's NFA requires fi(jV jfijU j) time in the worst case. Using Thompson's NFA, the equivalent calculation requires fi(r) time in the worst case. Comparative benchmarks show that an implementation of our method outperforms implementations fl This research was partially supported by Office of Naval Research Grant No. N00014-93-1-0924, Air Force Office of Scientific Research Grant No. AFOSR-91-0308, and National Science Foundation grant MIP-9300210. An earlier version of this paper appeared in the Conference Record of the Third Symposium on Combinatorial Pattern Matching (1992). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A., Hopcroft, J. and Ullman J., </author> <title> "Design and Analysis of Computer Algorithms", </title> <address> Reading, </address> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Throughout this paper we use a uniform cost sequential RAM <ref> [1] </ref> as our model of computaton. However, our algorithms will avoid any RAM operation with hidden costs (that might show up under a logarithmic cost criterion). We report the following four results. 1. <p> It is convenient to denote an undefined node by ? for which, f rontier (?; succ) def The preceding forest relation succ can be implemented as an adjacency list (cf. an early chapter of any elementary algorithms text; e.g. <ref> [1] </ref>) in which each node n in succ is implemented as a distinct unit-space record. It is convenient to refer to a node and its record implementation interchangeably. For each node n, its record stores a pointer to a list of pointers to the children of n.
Reference: [2] <author> Aho, A., Sethi, R. and Ullman, J., </author> <booktitle> "Compilers Principles, Techniques, and Tools", </booktitle> <address> Reading, </address> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: In particular, the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes [4], string pattern matching [3], model checking [12], lexical scanning <ref> [2] </ref>, and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20]. <p> We give more dramatic empirical evidence that constructing a DFA from the CNNFA using our implementation of next-states in the classical Rabin and Scott subset construction [19] (cf. Chapter 3 of <ref> [2] </ref>) can be achieved in time one order of magnitude faster than starting from either Thompson's NFA or McNaughton and Yamada's NFA. Our benchmarks 3 also indicate better performance using Thompson's NFA over McNaughton and Yamada's NFA for acceptance testing and subset construction. <p> This observation runs counter to the judgment of those using McNaughton and Yamada's NFA throughout UNIX. 2 Terminology and Background With few exceptions the following basic definitions and terminology can be found in <ref> [2, 13] </ref>. By an alphabet we mean a finite nonempty set of symbols. If is an alphabet, then fl denotes the set of all finite strings of symbols in . The empty string is denoted by . <p> We build Thompson's NFA according to the construction rules described in <ref> [2] </ref>. Thompson's NFA usually contains redundant states and -edges. However, to our knowledge there is no obvious/efficient algorithm to optimize Thompson's NFA without blowing up the linear space constraint. <p> The CNNFA outperforms the other machines not only in DFA construction time but also in constructed machine size. Subset construction is compared on the following five starting machines: the CNNFA, Thompson's NFA, Thompson's optimized NFA, Thompson's NFA using the kernel items heuristic <ref> [2] </ref>, and McNaughton and Yamada's NFA. We implemented subset construction tailored to the CNNFA and other machines. <p> ((aj)(bj) ) fl linearly smaller linearly smaller comparable linearly smaller (ajb) fl a (ajb) n 4 times smaller comparable comparable comparable prog. lang. 10 times smaller 5 times smaller comparable 5 times smaller denoted by a regular expression, i.e. both string and regular expression are dynamic (cf. page 128 of <ref> [2] </ref>). This problem is needed for UNIX tools such as egrep. Aho's heuristic constructs McNaughton and Yamada's NFA first, and subsequently builds a DFA specialized to the input string incrementally as the string is scanned from left to right.
Reference: [3] <author> Aho, A., </author> <title> "Pattern Matching in Strings", in Formal Language Theory, </title> <editor> ed. R. V. </editor> <publisher> Book, Academic Press, Inc. </publisher> <year> 1980. </year>
Reference-contexts: Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown. In particular, the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes [4], string pattern matching <ref> [3] </ref>, model checking [12], lexical scanning [2], and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20].
Reference: [4] <author> Berry, G. and Cosserat, L., </author> <title> "The Esterel synchronous programming language and its mathematical semantics" in Seminar in Concurrency, </title> <editor> S. D. Brookes, A. W. Roscoe, and G. Winskel, eds., </editor> <publisher> LNCS 197, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown. In particular, the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes <ref> [4] </ref>, string pattern matching [3], model checking [12], lexical scanning [2], and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20].
Reference: [5] <author> Berry, G. and Sethi, R., </author> <title> "From Regular Expressions to Deterministic Au--tomata" Theoretical Computer Science, </title> <journal> Vol. </journal> <volume> 48, </volume> <year> 1986, </year> <pages> pp. 117-126. </pages>
Reference-contexts: Throughout this paper we use a uniform cost sequential RAM [1] as our model of computaton. However, our algorithms will avoid any RAM operation with hidden costs (that might show up under a logarithmic cost criterion). We report the following four results. 1. Berry and Sethi <ref> [5] </ref> used results of Brzozowski [7] to formally derive and improve McNaughton and Yamada's algorithm [16] for turning regular expressions into NFA's. NFA's produced by this algorithm have fewer states than NFA's produced by Thompson's algorithm [24], and are believed to outperform Thompson's NFA's for acceptance testing.
Reference: [6] <author> Bruggemann-Klein, A., </author> <title> "Regular Expressions into Finite Automata", </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 120, </volume> <year> 1993, </year> <pages> 197-213. </pages>
Reference-contexts: Nevertheless, they knew that their algorithm could be implemented in worst case time fi (m + r)[21], where r is the length of the regular expression accepted as input, and m is the number of edges in the NFA produced. More recently, Bruggemann-Klein <ref> [6] </ref> presented another algorithm to compute McNaughton and Yamada's NFA, and she provided the full details and a convincing analysis that it does run in fi (m + r) time and fi (r) auxiliary space. <p> It has the same asymptotic resource bounds as Bruggemann-Klein's algorithm <ref> [6] </ref>, but has the advantage of using only one pass. 5 Improving Space for McNaughton and Yamada's NFA As was remarked earlier, McNaughton and Yamada's NFA has certain theoretical disadvantages over Thompson's simpler NFA.
Reference: [7] <author> Brzozowski, J., </author> <title> "Derivatives of Regular Expressions", </title> <journal> JACM, </journal> <volume> Vol. 11, Num. 4., </volume> <month> Oct. </month> <year> 1964, </year> <pages> pp. 481-494. </pages>
Reference-contexts: However, our algorithms will avoid any RAM operation with hidden costs (that might show up under a logarithmic cost criterion). We report the following four results. 1. Berry and Sethi [5] used results of Brzozowski <ref> [7] </ref> to formally derive and improve McNaughton and Yamada's algorithm [16] for turning regular expressions into NFA's. NFA's produced by this algorithm have fewer states than NFA's produced by Thompson's algorithm [24], and are believed to outperform Thompson's NFA's for acceptance testing.
Reference: [8] <author> Cai, J. and Paige, R., </author> <title> "Using multiset discrimination to solve language processing problems without hashing," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 145, </volume> <year> 1995, </year> <pages> 189-228. </pages>
Reference-contexts: This is achieved in O (jffi R (V; )j) time using a depth-first-search through I Rsucc starting from I image (V ), marking all unmarked leaves. The set of marked leaves is ffi R (V; ). Multiset discrimination <ref> [8] </ref> can be used to separate out all of the sets fq 2 ffi R (V; ) j A (q) = ag for each a 2 in time O (jffi R (V; )j).
Reference: [9] <author> Chang, C., Ph. D. </author> <title> Thesis, "From Regular Expressions to DFA's Using Compressed NFA's", </title> <year> 1992. </year>
Reference-contexts: We end this section with the following theoretical result, originally proved by Chang <ref> [9] </ref>, which improves the auxiliary space given in Theorems 4.3 and 5.2. Theorem 5.6 Given any regular expression R with length r and with s occurrences of alphabet symbols, its equivalent CNNFA can be computed in time O (r) and auxiliary space O (s). <p> We also need to assign the set fA (q i ) : i = 1; :::; kg of symbols to A (z) (cf. <ref> [9] </ref> for details). Finally, if q 1 ; :::; q k are all final states (they must be all final or none final), then they must be replaced in the set F R of final states by z. <p> The CNNFA achieves linear speedup and constructs a linearly smaller DFA in many of the test cases. See Fig.'s 12 and 13 for benchmark summaries. The raw timing data is found in <ref> [9] </ref>. All the tests described in this paper are performed on a lightly loaded SUN 3/250 server. We used getitimer () and setitimer () primitives [23] to measure program execution time. It is interesting to note that the CNNFA has a better speedup ratio on SUN Sparc-based computers. <p> Aho's heuristic constructs McNaughton and Yamada's NFA first, and subsequently builds a DFA specialized to the input string incrementally as the string is scanned from left to right. Benchmarks showing substantial computational improvement in adapting the CNNFA to Aho's heuristic are found in <ref> [9] </ref>. 7 Conclusion Theoretical analysis and confirming empirical evidence demonstrates that our proposed CNNFA leads to a substantially more efficient way of turning regular expressions into DFA's than other NFA's in current use.
Reference: [10] <author> Chang, C. and Paige, R., </author> <title> "From Regular Expressions to DFA's Using Compressed NFA's," </title> <note> LNCS Num. 644, Springer-Verlag, </note> <author> eds. A. Apostolico, M. Crochemore, Z. Galil, and U. Manber, </author> <year> 1992, </year> <pages> pp. 88-108. </pages>
Reference-contexts: That algorithm was discovered by Chang and Paige independently of Bruggemann-Klein, and reported in the short form <ref> [10] </ref> of the current paper. 2. One disadvantage of McNaughton and Yamada's NFA is that its worst case number of edges is m = fi (s 2 ). More specifically, its adjacency list representation takes up 3s + s 2 space in the worst case.
Reference: [11] <author> Driscoll, J., Sarnak, N., Sleator, D., and Tarjan, R., </author> <title> "Making Data Structures Persistent", </title> <booktitle> Proc. 8th ACM STOC, </booktitle> <month> May, </month> <year> 1986, </year> <pages> pp. 109 - 121. </pages>
Reference-contexts: Fortunately, since, by Lemma 3.6, Rules (2) - (6) only use copy operations and disjoint unions to construct F T J K , we can overcome this problem by using a binary forest as a simple space-efficient persistent data structure (in the sense of <ref> [11] </ref>) that stores all intermediate values of sets F T K and I T J in the order in which they are computed by Rules (2) - (6) in the construction of ffi T R .
Reference: [12] <author> Emerson, E. and Lei, C., </author> <title> "Model Checking in the Propositional Mu-Calculus", </title> <booktitle> Proc. IEEE Conf. on Logic in Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 86 - 106. </pages>
Reference-contexts: Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown. In particular, the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes [4], string pattern matching [3], model checking <ref> [12] </ref>, lexical scanning [2], and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20].
Reference: [13] <author> Hopcroft, J. and Ullman, J., </author> <title> "Formal Languages and Their Relation to Automata",Reading, </title> <publisher> Addison-Wesley, </publisher> <year> 1969. </year>
Reference-contexts: This observation runs counter to the judgment of those using McNaughton and Yamada's NFA throughout UNIX. 2 Terminology and Background With few exceptions the following basic definitions and terminology can be found in <ref> [2, 13] </ref>. By an alphabet we mean a finite nonempty set of symbols. If is an alphabet, then fl denotes the set of all finite strings of symbols in . The empty string is denoted by .
Reference: [14] <author> Kleene, S., </author> <title> "Representation of events in nerve nets and finite automata", in Automata Studies, </title> <journal> Ann. Math. Studies Num. </journal> <volume> 34, </volume> <publisher> Princeton U. Press, </publisher> <year> 1956, </year> <pages> pp. 3 - 41. </pages>
Reference-contexts: Kleene <ref> [14] </ref> characterized a subclass of languages called regular languages in terms of regular expressions. 4 Definition 2.3 The regular expressions over alphabet and the languages they denote are defined inductively as follows. * ; is a regular expression that denotes the empty set * is a regular expression that denotes set
Reference: [15] <author> Knuth, D., </author> <title> "On the translation of languages from left to right", </title> <journal> Information and Control, </journal> <volume> Vol. 8, Num. 6, </volume> <year> 1965, </year> <pages> pp. 607 - 639. </pages>
Reference-contexts: the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes [4], string pattern matching [3], model checking [12], lexical scanning [2], and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing <ref> [15] </ref>; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20]. Throughout this paper we use a uniform cost sequential RAM [1] as our model of computaton.
Reference: [16] <author> McNaughton, R. and Yamada, H. </author> <title> "Regular Expressions and State Graphs for Automata", </title> <journal> IRA Trans. on Electronic Computers, Vol. EC-9, Num. </journal> <volume> 1, </volume> <month> Mar. </month> <year> 1960, </year> <pages> pp 39-47. </pages>
Reference-contexts: However, our algorithms will avoid any RAM operation with hidden costs (that might show up under a logarithmic cost criterion). We report the following four results. 1. Berry and Sethi [5] used results of Brzozowski [7] to formally derive and improve McNaughton and Yamada's algorithm <ref> [16] </ref> for turning regular expressions into NFA's. NFA's produced by this algorithm have fewer states than NFA's produced by Thompson's algorithm [24], and are believed to outperform Thompson's NFA's for acceptance testing. <p> Regular expressions and NFA's that represent the same regular language are said to be equivalent. There are two main practical approaches for turning regular expressions into equivalent NFA's. Thompson's approach [24] turns regular expressions into NFA's with -edges as described above. McNaughton and Yamada's approach <ref> [16] </ref> turns regular expressions into a slightly different kind of NFA described in the next section. There is one main approach for turning NFA's (constructed by either the method of Thompson or McNaughton and Yamada) into equivalent DFA's. <p> There is one main approach for turning NFA's (constructed by either the method of Thompson or McNaughton and Yamada) into equivalent DFA's. This is by Rabin and Scott's subset construction [19]. 3 McNaughton and Yamada's NFA It is convenient to reformulate McNaughton and Yamada's transformation <ref> [16] </ref> from regular expressions to NFA's in the following way. Definition 3.1 A normal NFA (abbr. NNFA) is an NFA in which no edge can be labeled , and all edges leading into the same state have the same label. <p> To explain how the construction is done, we use the notational convention that M R denotes an MYN-NFA equivalent to regular expression R. Because of its importance in Rule (1), null R will be regarded as an essential component of M T R . Theorem 3.5 (McNaughton and Yamada <ref> [16] </ref>) Given any regular expression R with s occurrences of alphabet symbols from , an MYNNFA M R with s + 1 states can be constructed.
Reference: [17] <author> Myhill, J., </author> <title> "Finite automata and representation of events," WADC, </title> <type> Tech. Rep. </type> <pages> 57-624, </pages> <year> 1957. </year>
Reference-contexts: Of special significance was their construction of the canonical minimum-state DFA that had been described non-constructively in the proof of the Myhill-Nerode Theorem <ref> [17, 18] </ref>. Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown.
Reference: [18] <author> Nerode, A., </author> <title> "Linear automaton transformations," </title> <journal> Proc. Amer. Math Soc., </journal> <volume> Vol. 9, </volume> <pages> pp. 541 - 544, </pages> <year> 1958. </year>
Reference-contexts: Of special significance was their construction of the canonical minimum-state DFA that had been described non-constructively in the proof of the Myhill-Nerode Theorem <ref> [17, 18] </ref>. Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown.
Reference: [19] <author> Rabin, M. and Scott, D., </author> <title> "Finite automata and their decision problems" IBM J. </title> <journal> Res. Develop., </journal> <volume> Vol. 3, Num. 2, </volume> <month> Apr., </month> <year> 1959, </year> <pages> pp. 114 - 125. 40 </pages>
Reference-contexts: 1 Introduction The growing importance of regular languages and their associated computational problems in languages and compilers is underscored by the granting of the Tur-ing Award to Rabin and Scott in 1976, in part, for their ground-breaking logical and algorithmic work in regular languages <ref> [19] </ref>. Of special significance was their construction of the canonical minimum-state DFA that had been described non-constructively in the proof of the Myhill-Nerode Theorem [17, 18]. Rabin and Scott's work, which was motivated by theoretical considerations, has gained in importance as the number of practical applications has grown. <p> It supports acceptance testing in worst-case time O (sjxj) for arbitrary string x, and a faster way to construct DFA's using an improved implementation of the classical subset construction of Rabin and Scott <ref> [19] </ref>. 3. When using McNaughton and Yamada's NFA to perform either acceptance testing or NFA-to-DFA conversion, it is necessary to repeatedly compute the set of states U one edge away from an arbitrary set of states V . <p> We give more dramatic empirical evidence that constructing a DFA from the CNNFA using our implementation of next-states in the classical Rabin and Scott subset construction <ref> [19] </ref> (cf. Chapter 3 of [2]) can be achieved in time one order of magnitude faster than starting from either Thompson's NFA or McNaughton and Yamada's NFA. Our benchmarks 3 also indicate better performance using Thompson's NFA over McNaughton and Yamada's NFA for acceptance testing and subset construction. <p> Kleene also characterized the regular languages in terms of languages accepted by DFA's. Rabin and Scott <ref> [19] </ref> showed that NFA's also characterize the regular languages, and their work led to algorithms to decide whether an arbitrary string is accepted by an NFA. Regular expressions and NFA's that represent the same regular language are said to be equivalent. <p> There is one main approach for turning NFA's (constructed by either the method of Thompson or McNaughton and Yamada) into equivalent DFA's. This is by Rabin and Scott's subset construction <ref> [19] </ref>. 3 McNaughton and Yamada's NFA It is convenient to reformulate McNaughton and Yamada's transformation [16] from regular expressions to NFA's in the following way. Definition 3.1 A normal NFA (abbr.
Reference: [20] <author> Ritchie, D. and Thompson, K. </author> <booktitle> "The UNIX Time-Sharing System" Com--munications of the ACM, </booktitle> <volume> Vol. 17, Num. 7, </volume> <month> Jul., </month> <year> 1974, </year> <pages> pp. 365 - 375. </pages>
Reference-contexts: [4], string pattern matching [3], model checking [12], lexical scanning [2], and VLSI layout design [25]; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system <ref> [20] </ref>. Throughout this paper we use a uniform cost sequential RAM [1] as our model of computaton. However, our algorithms will avoid any RAM operation with hidden costs (that might show up under a logarithmic cost criterion). We report the following four results. 1.
Reference: [21] <author> Sethi, R., </author> <title> private communication, </title> <year> 1989. </year>
Reference: [22] <author> Smith, D., </author> <title> "KIDS A Knowledge-Based Software Development System", </title> <booktitle> in Proc. Workshop on Automating Software Design, AAAI-88, </booktitle> <year> 1988. </year> <title> [23] "SunOS Reference Manual VOL. II", Programmer's Manual, SUN mi-crosystems, </title> <year> 1989. </year>
Reference-contexts: This method has been mechanized and used extensively by Douglas Smith within his program transformation system called KIDS (see for example <ref> [22] </ref>). Lemma 4.1 Rules (9) - (13) satisfy Invariant (7). Each union operation oc curring within Rules (9) - (13) and Rule (8) is disjoint.
Reference: [24] <author> Thompson, K., </author> <title> "Regular Expression search Algorithm", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 11, Num. 6, </volume> <year> 1968, </year> <pages> pp. 419-422. </pages>
Reference-contexts: We report the following four results. 1. Berry and Sethi [5] used results of Brzozowski [7] to formally derive and improve McNaughton and Yamada's algorithm [16] for turning regular expressions into NFA's. NFA's produced by this algorithm have fewer states than NFA's produced by Thompson's algorithm <ref> [24] </ref>, and are believed to outperform Thompson's NFA's for acceptance testing. Berry and Sethi did not publish the resource bounds of their algorithm or the details for an efficient implementation. <p> Regular expressions and NFA's that represent the same regular language are said to be equivalent. There are two main practical approaches for turning regular expressions into equivalent NFA's. Thompson's approach <ref> [24] </ref> turns regular expressions into NFA's with -edges as described above. McNaughton and Yamada's approach [16] turns regular expressions into a slightly different kind of NFA described in the next section.
Reference: [25] <author> Ullman, J., </author> <title> "Computational Aspects of VLSI", </title> <publisher> Computer Science Press, </publisher> <year> 1984. </year>
Reference-contexts: In particular, the construction of finite automata from regular expressions is of central importance to the compilation of communicating processes [4], string pattern matching [3], model checking [12], lexical scanning [2], and VLSI layout design <ref> [25] </ref>; unit-time incremental acceptance testing in a DFA is also a crucial step in LR k parsing [15]; algorithms for acceptance testing and DFA construction from regular expressions are implemented in the UNIX operating system [20].
Reference: [26] <author> Winskel, G., </author> <title> "The Formal Semantics of Programming Languages", </title> <publisher> MIT Press, </publisher> <year> 1993. </year> <month> 41 </month>
Reference-contexts: Then the call computes record N P in time O (r P ) and auxiliary space O (1 + s P ). Proof: The proof uses rule induction <ref> [26] </ref> with respect to grammar rules (37).
References-found: 25

