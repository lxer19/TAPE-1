URL: http://http.cs.berkeley.edu/~jfoster/papers/pldi98.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~jfoster/
Root-URL: 
Email: fmanuel,jfoster,zhendong,aikeng@cs.berkeley.edu  
Title: Partial Online Cycle Elimination in Inclusion Constraint Graphs  
Author: Manuel Fahndrich Jeffrey S. Foster Zhendong Su Alexander Aiken 
Address: 387 Soda Hall #1776 Berkeley, CA 94720-1776  
Affiliation: EECS Department University of California, Berkeley  
Abstract: Many program analyses are naturally formulated and implemented using inclusion constraints. We present new results on the scalable implementation of such analyses based on two insights: first, that online elimination of cyclic constraints yields orders-of-magnitude improvements in analysis time for large problems; second, that the choice of constraint representation affects the quality and efficiency of online cycle elimination. We present an analytical model that explains our design choices and show that the model's predictions match well with results from a substantial experiment. 
Abstract-found: 1
Intro-found: 1
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> DIKU report 94/19. </type>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations. <p> Our measurements show that this standard form (SF), which is the one described in [Hei92] for use in set-based analysis (SBA), can also substantially benefit from partial online cycle elimination. As our benchmark we study a points-to analysis for C <ref> [And94, SH97] </ref> implemented using both SF and IF. For large programs (more than 10000 lines), online cycle elimination reduces the execution time of our SF implementation by up to a factor of 13. <p> Andersen's analysis computes a points-to graph <ref> [And94] </ref>. Graph nodes represent abstract memory locations, and there is an edge from a node x to a node y if x may contain a pointer to y. <p> Their system performs simplifications similar to [FA96, FF97] for every function declaration. They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis <ref> [And94] </ref>. Recent work by Shapiro and Horwitz [SH97] contrasts Andersen's set based points-to analysis with the unification based points-to analysis of Steensgaard [Ste96]. They conclude that while Andersen's analysis is substantially more precise than Steensgaard's, its running time is impractical.
Reference: [AW92] <author> A. Aiken and E. Wimmers. </author> <title> Solving Systems of Set Constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Section 5 studies an analytical model that explains why IF can outperform SF. Finally, Section 6 presents related work, and Section 7 concludes. 2 Definitions 2.1 Set Constraints In this paper we use a small subset of the full language of set constraints <ref> [HJ90, AW92] </ref>. Constraints in our constraint language are of the form L R, where L and R are set expressions.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type Inclusion Constraints and Type Inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 3141, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Our contribution is to show that partial online cycle detection can be performed cheaply by traversing only certain paths during the search for cycles. This approach is inspired by a non-standard graph representation called inductive form (IF) introduced in <ref> [AW93] </ref>. In practice, our approach requires constant time overhead on every edge addition and finds and eliminates about 80% of all variables involved in cycles. For our benchmarks, this approach radically improves the scaling behavior, making analysis of large programs practical. <p> We study two distinct solved forms: Standard form SF represents the least solution explicitly and is commonly used for implementing SBA [Hei92]. Inductive form IF computes a representation of all solutions and is usually used with more expressive constraints and in type-based analyses <ref> [AW93, MW97] </ref>. As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. <p> As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. For the purposes of 1 Standard models are the termset model [Hei92, Koz93] or the ideal model <ref> [AW93] </ref>. 2 The interpretation of 0 and 1 depends on the model and is not shown. <p> edges between variables. (This is not to say that the closure of SF does not produce new edges between variables, but for SF such edges always involve the resolution rules R of Figure 1.) The closure rule combined with the resolution rules R produces a final graph in inductive form <ref> [AW93] </ref>. The least solution of the constraints is not explicit in the closed inductive form. <p> the desired effect, namely ref (l b ; X l b ; X l b ) X l a . 4 Measurements In this section we compare the commonly used implementation strategy of set-based analysis [Hei92], which represents constraint graphs in standard form (SF), with the inductive form (IF) of <ref> [AW93] </ref>. We give empirical evidence that cycles in the constraint graph are the key inhibitors to scalability for both forms and that our online cycle elimination is cheap and improves the running times of both forms significantly.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [FA96] <author> M. Fahndrich and A. Aiken. </author> <title> Making SetConstraint Based Program Analyses Scale. </title> <booktitle> In First Workshop on Set Constraints at CP'96, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1996. </year> <note> Available as Technical Report CSD-TR-96-917, </note> <institution> University of California at Berkeley. </institution>
Reference-contexts: In this example, the transitive edge (X ; Z) represents the implied constraint X Z. The performance of constraint resolution can be improved by simplifying the constraint graph. Periodic simplification performed during resolution helps to scale to larger analysis problems <ref> [FA96, FF97, MW97] </ref>, but performance is still unsatisfactory. One problem is deciding the frequency at which to perform simplifications to keep a well-balanced cost-benefit tradeoff. <p> The importance of simplifications on constraint graphs has been recognized before. In contrast to our online approach, prior work has focused on periodic simplification. In <ref> [FA96] </ref> the authors describe several simplifications to reduce the heap requirements of graphs for a more complex constraint language. They give performance results obtained through simplifications at regular depths in the abstract syntax tree traversal. Simplification cost outweighs potential benefits when simplifications are performed frequently. <p> Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times. Marlow and Wadler use set constraints in a type system for Erlang [MW97]. Their system performs simplifications similar to <ref> [FA96, FF97] </ref> for every function declaration. They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis [And94].
Reference: [FF97] <author> C. Flanagan and M. Felleisen. </author> <note> Componential SetBased Analysis. In PLDI'97 [PLD97]. </note>
Reference-contexts: In this example, the transitive edge (X ; Z) represents the implied constraint X Z. The performance of constraint resolution can be improved by simplifying the constraint graph. Periodic simplification performed during resolution helps to scale to larger analysis problems <ref> [FA96, FF97, MW97] </ref>, but performance is still unsatisfactory. One problem is deciding the frequency at which to perform simplifications to keep a well-balanced cost-benefit tradeoff. <p> They give performance results obtained through simplifications at regular depths in the abstract syntax tree traversal. Simplification cost outweighs potential benefits when simplifications are performed frequently. Several papers explore the theoretical foundations of constraint simplification <ref> [TS96, Pot96, FF97] </ref>. Among these, [FF97] implemented several simplifications in the context of a static debugger for Scheme. Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times. <p> They give performance results obtained through simplifications at regular depths in the abstract syntax tree traversal. Simplification cost outweighs potential benefits when simplifications are performed frequently. Several papers explore the theoretical foundations of constraint simplification [TS96, Pot96, FF97]. Among these, <ref> [FF97] </ref> implemented several simplifications in the context of a static debugger for Scheme. Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times. <p> Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times. Marlow and Wadler use set constraints in a type system for Erlang [MW97]. Their system performs simplifications similar to <ref> [FA96, FF97] </ref> for every function declaration. They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis [And94].
Reference: [FFA97] <author> J. Foster, M. Fahndrich, and A. Aiken. </author> <title> FlowInsensitive Points-to Analysis with Term and Set Constraints. </title> <type> Technical Report UCB//CSD-97964, </type> <institution> U. of California, Berkeley, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: In our implementation we avoid using the location names l i and the variables Y l i , and instead derive the points-to graph directly from the constraints. 3.2 Constraint Generation Andersen's analysis. For the full set of rules, see <ref> [FFA97] </ref>. The rules assign a set expression to each program expression and generate a system of set constraints as side conditions. The solution to the set constraints describes the points-to graph of the program. We write t for set expressions denoting locations.
Reference: [FFK + 96] <author> C. Flanagan, M. Flatt, S. Krishnamurthi, S. Weirich, and M. Felleisen. </author> <title> Catching Bugs in the Web of Program Invariants. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification, </title> <booktitle> chapter 10, </booktitle> <pages> pages 199-200. </pages> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: ) (Addr) e : t t ref (1; T ; 0) T fresh fle : T (Deref ) e 1 : t 1 e 2 : t 2 T 2 T 1 T 1 ; T 2 fresh e 1 =e 2 : t 2 (Asst) operations (e.g., Java arrays <ref> [GJS96] </ref>). A sound approach is to turn inclusions between references into equality for their contents: ref (X ) ref (Y ) , X = Y. We adapt this technique to a purely inclusion-based system using a novel approach.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: For example, the constraint X Y, between variables X and Y, is represented as a successor edge from node X to node Y. Our measurements show that this standard form (SF), which is the one described in <ref> [Hei92] </ref> for use in set-based analysis (SBA), can also substantially benefit from partial online cycle elimination. As our benchmark we study a points-to analysis for C [And94, SH97] implemented using both SF and IF. <p> We study two distinct solved forms: Standard form SF represents the least solution explicitly and is commonly used for implementing SBA <ref> [Hei92] </ref>. Inductive form IF computes a representation of all solutions and is usually used with more expressive constraints and in type-based analyses [AW93, MW97]. As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. <p> As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. For the purposes of 1 Standard models are the termset model <ref> [Hei92, Koz93] </ref> or the ideal model [AW93]. 2 The interpretation of 0 and 1 depends on the model and is not shown. <p> Note that in this case, L is always of the form c (: : : ). This closure rule combined with rules R of Figure 1 produces a final graph containing an explicit form of the least solution LS of the constraints <ref> [Hei92] </ref>. SF makes the least solution explicit by propagating sources forward to all reachable variables via the closure rule. The particular choice of successor and predecessor representation is motivated by the need to implement the closure rule locally. <p> The final constraint T 2 T 1 implies the desired effect, namely ref (l b ; X l b ; X l b ) X l a . 4 Measurements In this section we compare the commonly used implementation strategy of set-based analysis <ref> [Hei92] </ref>, which represents constraint graphs in standard form (SF), with the inductive form (IF) of [AW93].
Reference: [Hei94] <author> N. Heintze. </author> <title> Set Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 30617, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of Herbrand set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Section 5 studies an analytical model that explains why IF can outperform SF. Finally, Section 6 presents related work, and Section 7 concludes. 2 Definitions 2.1 Set Constraints In this paper we use a small subset of the full language of set constraints <ref> [HJ90, AW92] </ref>. Constraints in our constraint language are of the form L R, where L and R are set expressions.
Reference: [HM97] <author> N. Heintze and D. McAllester. </author> <title> Linear-Time Subtransitive Control Flow Analysis. </title> <booktitle> In PLDI'97 [PLD97]. </booktitle>
Reference-contexts: Steensgaard's system is an example of the former; the linear time closure- analysis algorithm for functional programs with bounded type size is an example of the latter <ref> [Mos96, HM97] </ref>. We plan to study the impact of online cycle elimination on the performance of closure analysis in future work. 7 Conclusions We have shown that online elimination of cyclic constraints in inclusion constraint based program analyses yields orders- of-magnitude improvements in execution time.
Reference: [JM79] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow Analysis and Optimization of LISP-like Structures. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [Knu73] <author> D. Knuth. </author> <booktitle> The Art of Computer Programming, Fundamental Algorithms, volume 1. </booktitle> <address> AddisonWesley, Reading, Mass., 2 edition, </address> <year> 1973. </year>
Reference-contexts: In practice, initial constraint graphs are sparse; all our benchmark programs produce initial graphs of approximately this density. We have the following approximation <ref> [Knu73] </ref> n X i i! 1 i r 2 Using equation (2) we simplify E (X SF ) and E (X IF ) as follows E (X ) m n 1 + n n = m + n n m IF m (m 1) r 2 To obtain Theorem 5.1, we
Reference: [Koz93] <author> D. Kozen. </author> <title> Logical Aspects of Set Constraints. </title> <editor> In E. Borger, Y. Gurevich, and K. Meinke, editors, </editor> <booktitle> Proc. 1993 Conf. Computer Science Logic (CSL '93), volume 832 of Lecture Notes in Computer Science, </booktitle> <pages> pages 175-188. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. For the purposes of 1 Standard models are the termset model <ref> [Hei92, Koz93] </ref> or the ideal model [AW93]. 2 The interpretation of 0 and 1 depends on the model and is not shown.
Reference: [Mos96] <author> C. Mossin. </author> <title> Flow Analysis of Typed Higher-Order Programs. </title> <type> PhD thesis, </type> <institution> DIKU, Department of Computer Science, University of Copenhagen, </institution> <year> 1996. </year>
Reference-contexts: Steensgaard's system is an example of the former; the linear time closure- analysis algorithm for functional programs with bounded type size is an example of the latter <ref> [Mos96, HM97] </ref>. We plan to study the impact of online cycle elimination on the performance of closure analysis in future work. 7 Conclusions We have shown that online elimination of cyclic constraints in inclusion constraint based program analyses yields orders- of-magnitude improvements in execution time.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We model locations by pairing location names and points-to set variables with a constructor ref (fl i g; X l i ) akin to reference types in languages like ML <ref> [MTH90] </ref>. Unlike the type system of ML, which is equality-based, we need inclusion constraints.
Reference: [MW97] <author> S. Marlow and P. Wadler. </author> <title> A Practical Subtyping System For Erlang. </title> <booktitle> In Proceedings of the International Conference on Functional Programming (ICFP '97), </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations. <p> In this example, the transitive edge (X ; Z) represents the implied constraint X Z. The performance of constraint resolution can be improved by simplifying the constraint graph. Periodic simplification performed during resolution helps to scale to larger analysis problems <ref> [FA96, FF97, MW97] </ref>, but performance is still unsatisfactory. One problem is deciding the frequency at which to perform simplifications to keep a well-balanced cost-benefit tradeoff. <p> We study two distinct solved forms: Standard form SF represents the least solution explicitly and is commonly used for implementing SBA [Hei92]. Inductive form IF computes a representation of all solutions and is usually used with more expressive constraints and in type-based analyses <ref> [AW93, MW97] </ref>. As an aside, it is worth noting that for some analysis problems we require a representation of all solutions because no least solution exists. <p> Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times. Marlow and Wadler use set constraints in a type system for Erlang <ref> [MW97] </ref>. Their system performs simplifications similar to [FA96, FF97] for every function declaration. They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis [And94].
Reference: [PLD97] <institution> Proceedings of the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, </institution> <month> June </month> <year> 1997. </year>
Reference: [Pot96] <author> F. Pottier. </author> <title> Simplifying Subtyping Constraints. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming (ICFP '96), </booktitle> <pages> pages 122-133, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: They give performance results obtained through simplifications at regular depths in the abstract syntax tree traversal. Simplification cost outweighs potential benefits when simplifications are performed frequently. Several papers explore the theoretical foundations of constraint simplification <ref> [TS96, Pot96, FF97] </ref>. Among these, [FF97] implemented several simplifications in the context of a static debugger for Scheme. Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times.
Reference: [PS91] <author> J. Palsberg and M. I. Schwartzbach. </author> <title> ObjectOriented Type Inference. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented program-ming: Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [Rey69] <author> J. C. Reynolds. </author> <title> Automatic Computation of Data Set Definitions, </title> <booktitle> pages 456-461. Information Processing 68. </booktitle> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and Accurate Flow-Insensitive Points-To Analysis. </title> <booktitle> In Proceedings of the 24th Annual ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Our measurements show that this standard form (SF), which is the one described in [Hei92] for use in set-based analysis (SBA), can also substantially benefit from partial online cycle elimination. As our benchmark we study a points-to analysis for C <ref> [And94, SH97] </ref> implemented using both SF and IF. For large programs (more than 10000 lines), online cycle elimination reduces the execution time of our SF implementation by up to a factor of 13. <p> Our measurement methodology uses a single well- engineered constraint solver to perform a number of exper <p>- 1 iments using SF and IF with and without cycle elimination. We validate our results by comparing with Shapiro and Hor- witz's SF implementation (SH) of the same points-to analysis <ref> [SH97] </ref>. Experiments show that our implementation of points-to analysis using SF without cycle elimination closely matches SH on our benchmarks. In Section 2, we define a language for set constraints, the particular constraint formalism we shall use. <p> We use a single well-engineered constraint resolution library to compare SF and IF. To validate that our results are not a product of our particular implementation, we compare our implementation of standard form to an independent implementation of points-to analysis written in C by Shapiro and Horwitz <ref> [SH97] </ref>. Their implementation corresponds to SF without cycle elimination, and we empirically verify that our implementation of SF produces the same trend on our benchmark suite. <p> Their system performs simplifications similar to [FA96, FF97] for every function declaration. They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis [And94]. Recent work by Shapiro and Horwitz <ref> [SH97] </ref> contrasts Andersen's set based points-to analysis with the unification based points-to analysis of Steensgaard [Ste96]. They conclude that while Andersen's analysis is substantially more precise than Steensgaard's, its running time is impractical. However, our implementation of Andersen's points-to analysis is generally competitive with [SH97]'s implementation of Steensgaard's algorithm.
Reference: [Shi88] <author> O. Shivers. </author> <title> Control Flow Analysis in Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Inclusion constraints are a natural vehicle for expressing a wide range of program analyses including shape analysis, closure analysis, soft typing systems, receiver-class prediction for object-oriented programs, and points-to analysis for pointer-based programs, among others <ref> [Rey69, JM79, Shi88, PS91, AWL94, Hei94, And94, FFK + 96, MW97] </ref>. Such analyses are efficient for small to medium size programs, but they are known to be impractical for large analysis problems. Inclusion constraint systems have natural graph representations.
Reference: [Shm83] <author> O. Shmueli. </author> <title> Dynamic Cycle Detection. </title> <journal> Information Processing Letters, </journal> <volume> 17(4) </volume> <pages> 185-188, </pages> <month> 8 November </month> <year> 1983. </year>
Reference-contexts: At first glance, this approach seems overly expensive, since the best known algorithm for online cycle detection performs a full depth- first search for half of all edge additions <ref> [Shm83] </ref>. Our contribution is to show that partial online cycle detection can be performed cheaply by traversing only certain paths during the search for cycles. This approach is inspired by a non-standard graph representation called inductive form (IF) introduced in [AW93].
Reference: [Ste96] <author> B. Steensgaard. </author> <title> Points-to Analysis in Almost Linear Time. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: They report that performance is poor for large sets of mutually recursive functions, which must be analyzed together. Points-to analysis with set constraints is in Andersen's thesis [And94]. Recent work by Shapiro and Horwitz [SH97] contrasts Andersen's set based points-to analysis with the unification based points-to analysis of Steensgaard <ref> [Ste96] </ref>. They conclude that while Andersen's analysis is substantially more precise than Steensgaard's, its running time is impractical. However, our implementation of Andersen's points-to analysis is generally competitive with [SH97]'s implementation of Steensgaard's algorithm. Inclusion constraint resolution algorithms usually have at least O (n 3 ) time complexity.
Reference: [TS96] <author> V. Trifonov and S. Smith. </author> <title> Subtyping Constrained Types. </title> <booktitle> In Proceedings of the 3rd International Static Analysis Symposium, </booktitle> <pages> pages 349365, </pages> <month> September </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: They give performance results obtained through simplifications at regular depths in the abstract syntax tree traversal. Simplification cost outweighs potential benefits when simplifications are performed frequently. Several papers explore the theoretical foundations of constraint simplification <ref> [TS96, Pot96, FF97] </ref>. Among these, [FF97] implemented several simplifications in the context of a static debugger for Scheme. Constraint graphs are generated separately for each module, simplified, and finally merged. They report substantial reduction in constraint graph sizes and speedups of analysis times.
References-found: 28

