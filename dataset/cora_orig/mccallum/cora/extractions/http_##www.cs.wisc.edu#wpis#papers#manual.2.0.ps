URL: http://www.cs.wisc.edu/wpis/papers/manual.2.0.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Wisconsin Program-Integration System 2.0 Reference Manual  
Address: Madison, WI  
Affiliation: University of Wisconsin  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> D Binkley. </author> <title> Multi-procedure program integration. </title> <type> Technical report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> August </month> <year> 1991. </year> <type> Ph.D TR-1038. </type>
Reference-contexts: result system) until the most recent integration record is reached. * Done Pops down the dialog box, leaving the current integration-record set for next invocation of the command. 2.3.2 Illustrating interferences The command show-interference helps the user diagnose the cause of interference when integration fails due to Type I interference <ref> [1, 4] </ref>. A description of the analysis performed in conjunction with this command can be found in [14]. If integration is unsuccessful because of Type I interference, the action buttons in the show-interference dialog box permit the user to navigate among the list of interference vertices. <p> When these commands are invoked, a special display style with a distinctive color and/or type-face is used to distinguish the relevant components from other components of the program. The type of components are: directly affected, strongly affected, affected, preserved, delta, preserved+affected, and preserved+delta (See <ref> [1] </ref> for the definitions of these concepts). display-affected Base Variant Display If Display is DAP, use DIRECTLY AFFECTED POINTS style to display the components of the Variant system that are directly affected with respect to the Base system.
Reference: [2] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> In ACM Trans. Program. Lang. Syst., </journal> <pages> pages 319-349, </pages> <month> July </month> <year> 1987. </year> <pages> TOPLAS. </pages>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs <ref> [2, 5, 9] </ref> and an extension of program dependence graphs, called system dependence graphs [8]. The primary operations that the system provides fall into three different classes, depending on whether one program, two programs, or three (or more) programs are involved.
Reference: [3] <author> S. Horwitz. </author> <title> Identifying the semantic and textual differences between two versions of a program. </title> <booktitle> ACM SIGPLAN 90 Conference on Programming Language Design a nd Implementation, </booktitle> <volume> 25(6) </volume> <pages> 234-245, </pages> <month> June </month> <year> 1990. </year> <note> PLDI. </note>
Reference-contexts: Slicing (one program) Slicing operations help the user to gain an understanding of how ele ments in a given program interact. Differencing (two programs) Differencing operations help the user to gain an understanding of how one program differs from another <ref> [3] </ref>. Integration (three or more programs) The integration operation lets the user merge different variants of a base program into a version that exhibits the changes that were made 2 CHAPTER 1. INTRODUCTION AND BACKGROUND in each of the variants [5]. <p> CHAPTER 2 Integration Tool Commands All commands in this chapter operate on consistent systems and will return an error if one of the system used to perform the command is not consistent. 2.1 Program Slicing The integration system includes commands to display the components of program slices <ref> [10, 5, 3] </ref>. A special display style (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program. Components of backward slices are displayed in BACKWARD SLICE style; components of forward slices are displayed in FORWARD SLICE style.
Reference: [4] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-145, </pages> <address> New York, NY, </address> <month> January </month> <year> 1988. </year> <booktitle> ACM. </booktitle> <address> POPL San Diego, CA, </address> <month> January 13-15. </month>
Reference-contexts: result system) until the most recent integration record is reached. * Done Pops down the dialog box, leaving the current integration-record set for next invocation of the command. 2.3.2 Illustrating interferences The command show-interference helps the user diagnose the cause of interference when integration fails due to Type I interference <ref> [1, 4] </ref>. A description of the analysis performed in conjunction with this command can be found in [14]. If integration is unsuccessful because of Type I interference, the action buttons in the show-interference dialog box permit the user to navigate among the list of interference vertices.
Reference: [5] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year> <pages> TOPLAS. </pages>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs <ref> [2, 5, 9] </ref> and an extension of program dependence graphs, called system dependence graphs [8]. The primary operations that the system provides fall into three different classes, depending on whether one program, two programs, or three (or more) programs are involved. <p> Integration (three or more programs) The integration operation lets the user merge different variants of a base program into a version that exhibits the changes that were made 2 CHAPTER 1. INTRODUCTION AND BACKGROUND in each of the variants <ref> [5] </ref>. If integration fails, the system incorporates a facility to help interactively diagnose the cause of interference [14]. This document describes the basic command set of the Wisconsin Program-Integration System. An overview of the system's theoretical underpinnings can be found in [7]. <p> CHAPTER 2 Integration Tool Commands All commands in this chapter operate on consistent systems and will return an error if one of the system used to perform the command is not consistent. 2.1 Program Slicing The integration system includes commands to display the components of program slices <ref> [10, 5, 3] </ref>. A special display style (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program. Components of backward slices are displayed in BACKWARD SLICE style; components of forward slices are displayed in FORWARD SLICE style.
Reference: [6] <author> S. Horwitz and T. Reps. </author> <title> Efficient comparison of program slices. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 713-732, </pages> <year> 1991. </year>
Reference-contexts: Semantically different components are displayed using the SEMANTIC CHANGE style. In addition, for the differencing commands that use comparison techniques based on isomorphism with renaming <ref> [6] </ref>, semantically identical but textually different components are displayed using the TEXTUAL CHANGE style. difference-by-vertex old-sys proc new-sys proc Display a safe approximation to the set of semantically changed com 10 CHAPTER 2.
Reference: [7] <author> S. Horwitz and T. Reps. </author> <title> The use of program dependence graphs in software engineering. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Software Engineerin g, </booktitle> <pages> pages 392-411, </pages> <address> New York, NY, 1992. </address> <publisher> ACM. </publisher> <address> ICSE, May 11-15, 1992, Melbourne, Australia. </address>
Reference-contexts: INTRODUCTION AND BACKGROUND in each of the variants [5]. If integration fails, the system incorporates a facility to help interactively diagnose the cause of interference [14]. This document describes the basic command set of the Wisconsin Program-Integration System. An overview of the system's theoretical underpinnings can be found in <ref> [7] </ref>. A tutorial introduction to an earlier version of the system can be found in [13].
Reference: [8] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs [2, 5, 9] and an extension of program dependence graphs, called system dependence graphs <ref> [8] </ref>. The primary operations that the system provides fall into three different classes, depending on whether one program, two programs, or three (or more) programs are involved. Slicing (one program) Slicing operations help the user to gain an understanding of how ele ments in a given program interact. <p> is invoked: the program's procedure dependence graphs are first constructed from their corresponding control flow graphs; the system dependence graph proper is then constructed by linking together all of the program's procedure dependence graphs with call-graph information and introducing some additional information that summarizes transitive dependences due to procedure calls <ref> [8] </ref>. Commands added to the editor make use of system dependence graphs to perform various actions, as documented in the other sections of this manual. <p> a parameter, the selection represents either the in vertex, the out vertex, or both. * Slice phase Choice of whether the next slicing operation invoked is to perform a phase I slice, a phase II slice, or both (i.e., a phase I slice followed by a phase II slice). (See <ref> [8] </ref> for a description of the different phases of the interprocedural slicing algorithm.) The Phase I button indicates that either a b1 slice (backward phase I slice) or an f1 slice (forward phase I slice) should be performed; the Phase II button indicates that either a b2 slice (backward phase II <p> The eight radio buttons refer to loop-independent flow edges (Lif), loop 14 CHAPTER 2. INTEGRATION TOOL COMMANDS carried flow edges (Lcf), control edges (Con), def-order edges (Do), summary edges (Sum), call edges (Call), parameter-in edges (Pin), and parameter-out edges (Pout), respectively. (See <ref> [8] </ref> for the definitions of the kinds of dependences that these edges represent.) An edge is only displayed if it is in the symmetric difference of the edges incident on the current interference vertex and if it is in one of the chosen edge classes. <p> Current values of parameters are highlighted. The eight radio buttons for edge classes refer to loop-independent flow edges (Lif), loop-carried flow edges (Lcf), control edges (Con), def-order edges (Do), summary edges (Sum), call edges (Call), parameter-in edges (Pin), and parameter-out edges (Pout), respectively. (See <ref> [8] </ref> for the definitions of the kinds of dependences that these edges represent.) The edge class choices are the same as those provided in the edge-selection dialog box for the show-interference command. An edge is only displayed if it is in one of the chosen edge classes. <p> Output is directed to the tty from which wpis was invoked. show-system-ag List information about the linkage grammar for the selected system; the grammar is used to compute the interprocedural summary edges of the program's system dependence graph <ref> [8] </ref>.
Reference: [9] <author> D.J. Kuck, R.H. Kuhn, B. Leasure, D.A. Padua, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In Conference Record of the Eighth ACM Symposium on Principles of Programming La nguages, </booktitle> <pages> pages 207-218, </pages> <address> New York, NY, </address> <year> 1981. </year> <booktitle> ACM. POPL, </booktitle> <address> Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981. </year>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs <ref> [2, 5, 9] </ref> and an extension of program dependence graphs, called system dependence graphs [8]. The primary operations that the system provides fall into three different classes, depending on whether one program, two programs, or three (or more) programs are involved.
Reference: [10] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> Proceedings of the ACM SIG 26 BIBLIOGRAPHY SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <volume> 19(5) </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year> <title> Pitts-burgh, </title> <address> PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <booktitle> 1984) ACM SIGPLAN Notices. </booktitle>
Reference-contexts: CHAPTER 2 Integration Tool Commands All commands in this chapter operate on consistent systems and will return an error if one of the system used to perform the command is not consistent. 2.1 Program Slicing The integration system includes commands to display the components of program slices <ref> [10, 5, 3] </ref>. A special display style (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program. Components of backward slices are displayed in BACKWARD SLICE style; components of forward slices are displayed in FORWARD SLICE style.
Reference: [11] <author> William Pugh. </author> <title> The omega test: a fast and pratical integer programming algorithm for dependence analysis. </title> <booktitle> Supercomputing, </booktitle> <year> 1991. </year>
Reference-contexts: The Synthesizer Generator's external store facility [16] is used to pass this information to an external package written in C that builds and maintains control flow graphs and call graphs. A control flow graph is maintained for each procedure. Array data dependences are determined with the Omega Test <ref> [11, 12] </ref>. <p> Some editor commands of the Synthesizer Generator have been modified to preserve the integrity and consistency of systems (see Chapter 3 for the description of these changes). In addition, some improvements to the tool includes: * Array data dependence analysis performed with the Omega test <ref> [11, 12] </ref>. * Extension of the language to comments. * The result of an integration operation can now consist of several compilation units.
Reference: [12] <author> William Pugh. </author> <title> Eliminating false data dependences using the omega test. </title> <booktitle> ACM SIGPLAN, </booktitle> <year> 1992. </year>
Reference-contexts: The Synthesizer Generator's external store facility [16] is used to pass this information to an external package written in C that builds and maintains control flow graphs and call graphs. A control flow graph is maintained for each procedure. Array data dependences are determined with the Omega Test <ref> [11, 12] </ref>. <p> Some editor commands of the Synthesizer Generator have been modified to preserve the integrity and consistency of systems (see Chapter 3 for the description of these changes). In addition, some improvements to the tool includes: * Array data dependence analysis performed with the Omega test <ref> [11, 12] </ref>. * Extension of the language to comments. * The result of an integration operation can now consist of several compilation units.
Reference: [13] <author> T. Reps. </author> <title> Demonstration of a prototype tool for program integration. </title> <type> Technical report, </type> <institution> Computer Sciences Department, University of Wis-consin, Madison, WI, </institution> <month> January </month> <year> 1989. </year> <month> TR-819. </month>
Reference-contexts: This document describes the basic command set of the Wisconsin Program-Integration System. An overview of the system's theoretical underpinnings can be found in [7]. A tutorial introduction to an earlier version of the system can be found in <ref> [13] </ref>.
Reference: [14] <author> T. Reps and T. Bricker. </author> <title> Illustrating interference in interfering versions of programs. </title> <booktitle> In Proceedings of the Second International Workshop on Software Configuration Management, </booktitle> <volume> volume 17, </volume> <pages> pages 46-55, </pages> <address> Prince-ton, NJ, </address> <month> November </month> <year> 1989. </year> <booktitle> ACM SIGSOFT Software Engineering Notes. </booktitle>
Reference-contexts: INTRODUCTION AND BACKGROUND in each of the variants [5]. If integration fails, the system incorporates a facility to help interactively diagnose the cause of interference <ref> [14] </ref>. This document describes the basic command set of the Wisconsin Program-Integration System. An overview of the system's theoretical underpinnings can be found in [7]. A tutorial introduction to an earlier version of the system can be found in [13]. <p> A description of the analysis performed in conjunction with this command can be found in <ref> [14] </ref>. If integration is unsuccessful because of Type I interference, the action buttons in the show-interference dialog box permit the user to navigate among the list of interference vertices. Suppose that the integration command that failed attempted to integrate system A and system B with respect to system Base. <p> distinctive colors and/or type-faces are used to display these edges: to distinguish edge sources from edge targets, sources are displayed in CULPRIT TAIL style whereas targets are displayed in CULPRIT HEAD style. show-interference Pops up a dialog box that allows the user to navigate through the list of interference vertices <ref> [14] </ref>.
Reference: [15] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: A tutorial introduction to an earlier version of the system can be found in [13]. The user interface for the integration system incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems <ref> [15, 16] </ref> As with all editors created with the Synthesizer Generator, the integration system's editor exhibits characteristics that are specific to the language being edited, while at the same time sharing the generic user interface described in Chapter 3 of The Synthesizer Generator Reference Manual [16].

References-found: 15

