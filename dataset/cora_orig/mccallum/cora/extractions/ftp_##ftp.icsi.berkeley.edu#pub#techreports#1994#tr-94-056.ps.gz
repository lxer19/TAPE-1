URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1994/tr-94-056.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1994.html
Root-URL: http://www.icsi.berkeley.edu
Title: Multi-level Architecture of object-oriented Operating Systems  
Phone: (510) 643-9153 FAX (510) 643-7684  
Author: Sven Graupner, Winfried Kalfa, Frank Schubert 
Date: November 1994  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  
Pubnum: TR-94-056  
Abstract: Applications should be provided with optimal infrastructures at their run time. The proposed architecture encourages to structure a system into sets of interacting instances supported by optimal infrastructures at multiple levels. Infrastructures are organized as sets of instances as well, but of more elementary quality. Thus, a recursive architecture results with related infrastructures and instance areas that forms an n-ary tree. Each instance area provides the infrastructure for higher instance areas and needs itself a lower level infrastructure. Processing is considered as performing services among instances. Object-orientation is proved to be suitable for structuring instance areas and infrastructures. Instances performing services are objects. A discussion of general principles of object-orientation gives the background to apply it to this architecture. Most existing object-oriented systems only consider one kind or "quality" of objects, which is however inadequate for operating systems. The paper discusses what essentially makes different "qualities of objects" at different levels and how activities are related to them. In the last section the design and the implementation of a lowest level infrastructure is presented which is taken from an operating system prototype that follows the proposed architecture and which is under development in our group. 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta86] <author> Accetta,M., Baron,R., Golub,D., Rashid,R., Tevanian,A., Young,M.: </author> <title> 'Mach: A New Kernel Foundation for UNIX Development', </title> <booktitle> Proc. Summer 1986 USENIX Conference, </booktitle> <address> pp.93-112, </address> <year> 1986. </year>
Reference-contexts: All DCE services are realized by processes, mostly running on UNIX. Instances providing services are objects. All these approaches provide extensions for insufficient application environments of traditional operating systems, they are layers or infrastructures built upon these systems. (3.) The MACH-kernel <ref> [Accetta86] </ref> of CMU does only provide the (minimal) infrastructure for the existence and communication of server-processes that actually provide the operating system functionality. Such processes are instances providing services and can therefore be termed as objects. Some commercial systems are based on such sets of instances, as OSF/1 or NextStep.
Reference: [Assenmacher93] <author> Assenmacher,H., Breitbach,T., Buhler,P., Hubsch,V., Schwarz,R.: </author> <title> 'PANDA Supporting Distributed Programming in C++', </title> <type> Technical Report, </type> <institution> University of Kaiserslautern, Dep.of CS, </institution> <address> 23 p., </address> <year> 1993. </year>
Reference-contexts: It provides run time support for distributed objects (fragmented objects) in C++ concerning communication and location. The SOS features are integrated at the language level by extending C++ by additional keywords and using a translator to automatically produce the native code (proxies). A similar direction has PANDA <ref> [Assenmacher93] </ref> of the University of Kaiserslautern by extending the run time environment of C++ to distribution, persistence, object migration and multithreading. The work of [Muller92] also extends the C++ run time system for distribution of objects across a network of heterogeneous machines.
Reference: [Bershad88] <author> Bershad,B.N., Lazowska,E.D., Levy,H.M.: </author> <title> 'PRESTO: A System for Object-oriented Parallel Programming', </title> <journal> Software-Practice & Experience., Vol.18, No.8, </journal> <volume> pp.713-732, </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: Although, there are many proposals for introducing concurrency to object-oriented languages by creating new concurrent languages as ABCL/1 [Yonezawa86], by extending existing languages as PRESTO <ref> [Bershad88] </ref>, and C++ [Buhr92], or just providing libraries with fork ()-like routines, as C-Threads [Cooper87], pThreads [Graupner94] or other.
Reference: [Buhr92] <author> Buhr,P.A., Ditchfield,G., Stroobosscher,R.A., Younger,B.M.: </author> <title> 'C++: Concurrency in the Object-oriented Language C++', </title> <journal> Software-Practice & Experience, Vol.22, No.2, </journal> <volume> pp.137-172, </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: Although, there are many proposals for introducing concurrency to object-oriented languages by creating new concurrent languages as ABCL/1 [Yonezawa86], by extending existing languages as PRESTO [Bershad88], and C++ <ref> [Buhr92] </ref>, or just providing libraries with fork ()-like routines, as C-Threads [Cooper87], pThreads [Graupner94] or other.
Reference: [Chrobot94] <author> Chrobot,S., Stras,A., Stras,R.: </author> <title> 'Needles and Links or Dealing with Interrupts', </title> <type> Technical Report, </type> <institution> Kuwait University, Department of Mathematics, Safat, 11p., </institution> <year> 1994. </year>
Reference-contexts: Concerning the costs there in no substantial difference between creating a new or awaking an already existing iproc at the occurrence of an interrupt. However, the solution of iproc's is more general. Another discussion for structuring interrupts is in <ref> [Chrobot94] </ref>. 4.2 Advantages Abstraction always causes costs. But limiting costs to a minimum can prove abstractions to be applicable. The presented scheme of a process-oriented interrupt handling is based on dedicated interrupt processes called iproc's and is more general and equally efficient compared to conventional solutions of handling interrupts.
Reference: [Cooper87] <institution> Cooper,E.C., Draves,R.P.: 'C-Threads', Carnegie Mellon University, </institution> <type> Technical Report, </type> <institution> CS-88-154, 16p., </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: Although, there are many proposals for introducing concurrency to object-oriented languages by creating new concurrent languages as ABCL/1 [Yonezawa86], by extending existing languages as PRESTO [Bershad88], and C++ [Buhr92], or just providing libraries with fork ()-like routines, as C-Threads <ref> [Cooper87] </ref>, pThreads [Graupner94] or other.
Reference: [Creasy81] <author> Creasy, </author> <title> R.J.: 'The Origin of the VM/370 Time-Sharing Systems', </title> <journal> IBM Journal of Research and Development, Vol.25, No.5, </journal> <volume> pp.483-490, </volume> <year> 1981. </year> <title> [CSA90] : 'CSA: Communications Systems Architecture Architectural Description', </title> <institution> MARI Applied Technologies Ltd, 236p., </institution> <year> 1990. </year>
Reference-contexts: Well understood structuring principles were developed, such as the concept of processes and their hierarchical order (THE, [Dijkstra68], [Dijkstra71]), the virtualization of system resources (virtual memory, Multics, [Bensoussan72]) for hiding machine resource limitations and providing idealized, abstract machines for applications (VM, <ref> [Creasy81] </ref>) to make them independently from proprietary hardware by providing standardized interfaces for common services (open systems, UNIX, [Ritchie74]).
Reference: [Dijkstra68] <author> Dijkstra,E.W.: </author> <title> 'The Structure of the THE Multiprogramming System', </title> <journal> CACM, Vol.11, </journal> <volume> No.5, </volume> <month> May </month> <year> 1968. </year>
Reference-contexts: The separation of applications and the operating system was essential to cope with the complex control of machines, like multi-processing to exploit parallelism between the CPU and I/O-devices. Well understood structuring principles were developed, such as the concept of processes and their hierarchical order (THE, <ref> [Dijkstra68] </ref>, [Dijkstra71]), the virtualization of system resources (virtual memory, Multics, [Bensoussan72]) for hiding machine resource limitations and providing idealized, abstract machines for applications (VM, [Creasy81]) to make them independently from proprietary hardware by providing standardized interfaces for common services (open systems, UNIX, [Ritchie74]).
Reference: [Dijkstra71] <author> Dijkstra,E.W.: </author> <title> 'Hierarchical Ordering of Sequential Processes', </title> <journal> Acta Informatica, Vol.1, </journal> <volume> pp.115-138, </volume> <year> 1971. </year>
Reference-contexts: The separation of applications and the operating system was essential to cope with the complex control of machines, like multi-processing to exploit parallelism between the CPU and I/O-devices. Well understood structuring principles were developed, such as the concept of processes and their hierarchical order (THE, [Dijkstra68], <ref> [Dijkstra71] </ref>), the virtualization of system resources (virtual memory, Multics, [Bensoussan72]) for hiding machine resource limitations and providing idealized, abstract machines for applications (VM, [Creasy81]) to make them independently from proprietary hardware by providing standardized interfaces for common services (open systems, UNIX, [Ritchie74]). <p> But, the unpredictable insertion of instruction sequences, that is not previously considered at (2)-control, may be insidious because of critical sections that may occur by manipulating common resources between the interrupted and the inserted sequence. This violates the sequential paradigm. The paradigm of parallel processes was early introduced <ref> [Dijkstra71] </ref> to cope with such complex processing and it should be a must to apply it. However, many today's operating systems only provide it for the application level, where it was necessary for users to virtually achieve sequential behavior.
Reference: [Draves91] <author> Draves,R.P., et al.: </author> <title> 'Using Continuations to Implement thread Management and Communication in Operating Systems', </title> <booktitle> Proc. 13th ACM Symposium on Operating System Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: as described above (allocate an entry and plug in the appropriate SP and PC values), * return from the basic CPU-interrupt cycle, but don't resume the previously preempted activity, instead transfer to the control instance for iproc's (see figure 2), this is similar to the mechanism of continuations discussed in <ref> [Draves91] </ref>. 23 2. the control instance calls the policy which decides on the further transfer of control, 3. the control instance transfers the control to the selected iproc that runs the code of the service routine and returns to the control instance after it has done this.
Reference: [Gittinger92] <author> Gittinger,J., Kruger,U.: 'Prozesignalisierung statt Unterbrechungen', </author> <title> (in German), </title> <type> Interner Bericht 11/92, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, 37 S., </institution> <month> Mai </month> <year> 1992. </year>
Reference-contexts: In the early years of computers programmers thought in terms of processors, not processes. This is reflected in the interrupt system of today's computers. The interrupt system is processor-oriented, not process-oriented. In <ref> [Gittinger92] </ref> a proposal is made to support process-orientation at the CPU-level and to apply signaling of processes replacing interrupts, but it relies on a new type of CPU. The interrupt system of today's CPU-architectures is not only used for coordination with other active units in the system.
Reference: [Golub90] <author> Golub,D., Dean,R., Forin,A., Rashid,R.: </author> <title> 'Unix as an Application Program', </title> <booktitle> Proceedings of the USENIX Summer Conference, </booktitle> <month> June </month> <year> 1990. </year> <month> 26 </month>
Reference-contexts: Such processes are instances providing services and can therefore be termed as objects. Some commercial systems are based on such sets of instances, as OSF/1 or NextStep. The UNIX interface (or other) can fully be provided by sets of servers, as shown in <ref> [Golub90] </ref>. CHORUS [Rozier88] is very close to MACH. NT of Microsoft has a similar direction. The practical need for compatibility of interfaces to older or other systems is covered by providing their interfaces but with a different internal structure.
Reference: [Graupner94] <author> Graupner,S.: </author> <title> 'Coroutinen und preemptive Threads in C - Mechanismen und Realisierung', (in German), </title> <type> Bericht, </type> <institution> TU Chemnitz, Fakultat fur Informatik, 50S., </institution> <month> Februar </month> <year> 1994, </year>
Reference-contexts: Although, there are many proposals for introducing concurrency to object-oriented languages by creating new concurrent languages as ABCL/1 [Yonezawa86], by extending existing languages as PRESTO [Bershad88], and C++ [Buhr92], or just providing libraries with fork ()-like routines, as C-Threads [Cooper87], pThreads <ref> [Graupner94] </ref> or other.
Reference: [Hartig90] <editor> Hartig,H., Kuhnhauser,W.E., Lux,W., Reck,W.: </editor> <booktitle> 'Architecture of the BirliX Operating System', GMD, </booktitle> <address> St.Augustin, 6 p., </address> <month> Marz </month> <year> 1990. </year>
Reference-contexts: The interface of a layer can directly be reflected as the interface of a class. Orthogonally to the hierarchy of layers a hierarchy of specializations is applied to put the system to different hardware. However, there is just the language level considered. (2.a) BirliX <ref> [Hartig90] </ref> was developed at the GMD, Bonn. It is a full operating system running on bare hardware and supports distributed applications that are structured as collections of "ADT-instances", or objects, which run each in a "team"-environment, which is a multithreaded process with its own address space.
Reference: [Hills93] <author> Hills,T.: </author> <title> 'Structured Interrupts', Operating Systems Review, </title> <address> Vol.27, No.1, pp.51-68, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Similarly to preempting other kinds of activities, the preemption state of a running iproc must be saved in a location that is statically reserved in the representation of the iproc. The preemption state consists of the register set of the CPU. 24 That's a different approach compared to <ref> [Hills93] </ref> using cyclic processes, each for one interrupt type which block in a wait on signal condition and wake up if an interrupt has occurred. Interleaved handling of interrupts of the same type is not possible with this scheme.
Reference: [Kalfa88] <author> Kalfa,W.: 'Betriebssysteme', </author> <title> (in German), </title> <publisher> Akademie-Verlag, </publisher> <address> Berlin, 400 S., </address> <year> 1988. </year>
Reference-contexts: The first is unappropriately for operating systems due to their multiple activities. The second is unsuitable because of complexity, although this is the most general form. This form closely corresponds to the classical separation of processes and resources in operating systems <ref> [Kalfa88] </ref>. The other imply restrictions to achieve a better structure. The advantage of the third and fourth form only arises in combination with object-orientation. Objects do not only encapsulate their private state and the descriptions of behavior (methods), they also encapsulate activities.
Reference: [Kalfa92] <author> Kalfa,W.: </author> <title> 'Proposal on an External Processor Scheduling in Micro-Kernel based Operating Systems', </title> <type> Technical Report, </type> <institution> TR-92-028, ICSI, Berkeley, 14p., </institution> <month> May </month> <year> 1992. </year>
Reference: [Kiczales91] <author> Kiczales,G., Rivieres,J., Bobrow,D.G.: </author> <title> 'The Art of the Metaobject Protocol', </title> <publisher> The MIT Press, </publisher> <address> 335p., </address> <year> 1991. </year>
Reference-contexts: These properties form the infrastructural interface which instances can explicitly use. If objects of the instance area make use of infrastructural services that influence their own constitution this is called reflection following a similar mechanism which is applied to systems of artificial intelligence [Maes88], <ref> [Kiczales91] </ref>. The above points are a proposal to summarize the various facets of object-orientation in computer science.
Reference: [Kleinoder92] <author> Kleinoder,J.: </author> <title> 'PM Systemarchitektur', (in German), </title> <type> Technical Report, </type> <institution> TR-14-14-92, FAU Erlangen-Nurnberg, </institution> <month> Oktober </month> <year> 1992. </year>
Reference-contexts: A set of instances share the same meta-space. Other sets may have other meta-spaces. Infrastructural services are accessed by a so called "meta-of-link" to a "reflector" which is the visible proxy of a meta space for instances. Other examples for this structural approach are PM <ref> [Kleinoder92] </ref> of the University of Erlangen and PEACE [Schroder93] of GMD. But both of them do not enforce multi-level structuring. In PM everything are objects at the same level.
Reference: [Maes88] <author> Maes,P., Nardi,D.: </author> <title> 'Meta-Level Architecture and Reflection', </title> <publisher> North-Holland, </publisher> <address> 355p., </address> <year> 1988. </year>
Reference-contexts: These properties form the infrastructural interface which instances can explicitly use. If objects of the instance area make use of infrastructural services that influence their own constitution this is called reflection following a similar mechanism which is applied to systems of artificial intelligence <ref> [Maes88] </ref>, [Kiczales91]. The above points are a proposal to summarize the various facets of object-orientation in computer science.
Reference: [Marty89] <author> Marty,R.: 'Von der Subroutinentechnik zu Klassenhierarchien', </author> <title> (in German), </title> <institution> Berichte des Instituts fur Informatik, Nr.88.04, Universitat Zurich, 41 S., </institution> <year> 1989. </year>
Reference-contexts: This is the origin and (still unsatisfied) idea of object orientation. Object-orientation came up in programming languages as the consequence of their improvement towards higher abstractions to reflect "real world things" closer in programs. This development was very well outlined in <ref> [Marty89] </ref>. Object-orientation is also becoming popular in structuring running systems, as databases and operating systems. Its is evident that this is another background for object-orientation as the production of software. An operating system is running on a machine providing an abstract machine to run applications.
Reference: [Muller91] <author> Muller,K.: </author> <title> 'Techniken der objektorientierten Programmierung', (in German), </title> <publisher> GUUG-Nachrichten, Springer Verlag, </publisher> <address> Heft 25, S.19-33, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Activities or processes, which are essential for operating systems, are not covered by reducing object-orientation to the means of a sequential object-oriented language. ETHOS [Szyperski92] is another example for this approach. ETHOS was developed at the ETH Zurich and is implemented in OBERON [Wirth88]. In <ref> [Muller91] </ref> a proposal is made to represent different layers of an operating system as instances of classes representing one layer each. All components of a layer are aggregates of this class. The interface of a layer can directly be reflected as the interface of a class. <p> Formal approaches for describing semantics by sets of rules mostly fail on complexity. By the way, C++ classes are not truly ADT's because they also include the implementation additionally to the interface. Although, interface inheritance may be applied to simulate ADT's <ref> [Muller91] </ref>. Encapsulation is often distinguished from protection. But, if encapsulation really hides internal properties (e.g. states) then protection is guaranteed by encapsulation. If not, there is no real encapsulation, or it is enforced only at the language level, but not at run time, as in C++.
Reference: [Muller92] <author> Muller,K.: </author> <title> 'Realisierung verteilter Objektstrukturen mit C++', (in German), </title> <type> Bericht, </type> <institution> TU Chemnitz, Fakultat fur Informatik, 83 S., </institution> <year> 1992. </year> <title> [OMA92] : 'Object Management Architecture Guide', OMG Document No. </title> <editor> 92.11.1, Revision2.0, OMG, 98p., </editor> <year> 1992. </year>
Reference-contexts: A similar direction has PANDA [Assenmacher93] of the University of Kaiserslautern by extending the run time environment of C++ to distribution, persistence, object migration and multithreading. The work of <ref> [Muller92] </ref> also extends the C++ run time system for distribution of objects across a network of heterogeneous machines.
Reference: [Parnas72] <author> Parnas,D.L.: </author> <title> 'On the Criteria To Be Used in Decomposing Systems into Modules', </title> <journal> CACM, Vol.15, No.12, </journal> <volume> pp.1053-1058, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: For their use there are only those properties visible which are important for interaction. These properties constitute the interface of the object. All other properties are internal or private and hidden. That's the idea of modularization <ref> [Parnas72] </ref> (information hiding = property hiding). Providing encapsulation allows viewing a system at a higher, less complex level, that directly reflects abstraction as detailed in section 2.2.2.
Reference: [Ritchie74] <author> Ritchie,D., Thompson,K.: </author> <title> 'The UNIX Time-Sharing System', </title> <journal> CACM, Vol.17, No.7, </journal> <volume> pp.365-375, </volume> <month> July </month> <year> 1974. </year>
Reference-contexts: concept of processes and their hierarchical order (THE, [Dijkstra68], [Dijkstra71]), the virtualization of system resources (virtual memory, Multics, [Bensoussan72]) for hiding machine resource limitations and providing idealized, abstract machines for applications (VM, [Creasy81]) to make them independently from proprietary hardware by providing standardized interfaces for common services (open systems, UNIX, <ref> [Ritchie74] </ref>). Operating systems are complex, thus several structuring techniques were investigated and realized, such as layered structuring (THE), virtual machine structuring (VM), kernel structuring (UNIX), -kernel structuring (MACH, CHORUS), proxy structuring (SOS) and other.
Reference: [Rozier88] <editor> Rozier,M., Abrossimov,V., Boule,I., Gien,M., Guillemont,M., Herrmann,F., Kaiser,C., Langlois,S., Leonard,P., Neuhauser,W.: </editor> <booktitle> 'Chorus Distributed Operating Systems', Computing Systems, Vol.1, </booktitle> <address> No.4, pp.305-370, </address> <month> Fall </month> <year> 1988. </year>
Reference-contexts: Such processes are instances providing services and can therefore be termed as objects. Some commercial systems are based on such sets of instances, as OSF/1 or NextStep. The UNIX interface (or other) can fully be provided by sets of servers, as shown in [Golub90]. CHORUS <ref> [Rozier88] </ref> is very close to MACH. NT of Microsoft has a similar direction. The practical need for compatibility of interfaces to older or other systems is covered by providing their interfaces but with a different internal structure.
Reference: [Russo91] <author> Russo,V.F.: </author> <title> 'An Object-Oriented Operating System', </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois, 154p., </institution> <year> 1991. </year>
Reference-contexts: objects) and a -kernel forms the infrastructure, operating system functionality is provided by server processes, 4. the multi-level approach: the integration of application- and system-levels within a homogeneous, recursively structured architecture of multiple levels of instances and infrastructures in a running system. 4 Examples for these approaches are: (1.) Choices <ref> [Russo91] </ref>, which is implemented as a framework of C++-classes. It was developed at the University of Illinois. Applications use services of the system by creating instances of system classes (e.g. files) and accessing them by their methods. A proxy mechanism is used to cross the user/system barrier.
Reference: [Schill93] <author> Schill,A.: </author> <title> 'DCE: The OSF distributed computing environment', </title> <booktitle> Proc., </booktitle> <publisher> LNCS No.731, </publisher> <address> 283 p., </address> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: The work of [Muller92] also extends the C++ run time system for distribution of objects across a network of heterogeneous machines. An example for a language independent commercial system in this category is DCE of the OSF <ref> [Schill93] </ref> which provides run time and development support for distributed applications in a large-scale, heterogeneous network of workstations. All DCE services are realized by processes, mostly running on UNIX. Instances providing services are objects.
Reference: [Schroder93] <author> Schroder-Preikschat,W.: </author> <title> 'A PEACE Case Study', </title> <type> Technical Report, </type> <institution> TR-93-020, ICSI, Berkeley, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Other sets may have other meta-spaces. Infrastructural services are accessed by a so called "meta-of-link" to a "reflector" which is the visible proxy of a meta space for instances. Other examples for this structural approach are PM [Kleinoder92] of the University of Erlangen and PEACE <ref> [Schroder93] </ref> of GMD. But both of them do not enforce multi-level structuring. In PM everything are objects at the same level.
Reference: [Shapiro89] <author> Shapiro,M., Gourhant,Y., Habert,S., Mosseri,L., Ruffin,M., Valot,C.,: </author> <title> 'SOS: An Object-Oriented Operating System Assessment and Perspectives', </title> <booktitle> Computing Systems, Vol.2, </booktitle> <address> No.4, pp.287-337, </address> <month> Fall </month> <year> 1989. </year>
Reference-contexts: Instances communicate via RPC. (2.b) The origin of the SOS system is the INRIA, France <ref> [Shapiro89] </ref>. It provides run time support for distributed objects (fragmented objects) in C++ concerning communication and location. The SOS features are integrated at the language level by extending C++ by additional keywords and using a translator to automatically produce the native code (proxies).
Reference: [Snyder93] <author> Snyder,A.: </author> <title> 'The Essence of Objects: Concepts and Terms', </title> <journal> IEEE Software, Vol.10, No.1, </journal> <volume> pp.31-42, </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: But there is also a lack of understanding the general concepts, principles and methods which are behind all that different spheres where object-orientation is applied today. The first part of this section will therefore concentrate on this topic. Some related discussions are in <ref> [Snyder93] </ref>, [OMA92], and [OMG91]. Finding generalized concepts of object-orientation requires the analyzing of different approaches, beside the already known principles from programming languages. Three cycles will be presented here.
Reference: [Sonntag94] <author> Sonntag,S.: </author> <title> 'Adaptierbarkeit durch Reflexion', (in German), </title> <type> Dissertation, </type> <institution> TU Chemnitz, Fakultat fur Informatik, 103S., </institution> <month> Februar </month> <year> 1994. </year>
Reference-contexts: If a message is sent to one object or if it is redirected to another one after reconfiguration does not affect the requestor in any way. The infrastructure fully provides it. This feature was exploited for introducing dynamic adaptability in the BirliX operating system <ref> [Sonntag94] </ref>. But if there is procedural interaction in a monolithic kernel, the infrastructure relates to the fixed CPU-"hardware". The identification and addressing of objects is based on the addresses 20 in the call instructions at the side of the requestor.
Reference: [Stoustrup90] <author> Stoustrup,B.: </author> <title> 'The Annotated C++ Reference Manual', </title> <publisher> Addison-Wesley, </publisher> <address> 447p., </address> <year> 1991. </year>
Reference: [Szyperski92] <author> Szyperski,C.A.: </author> <title> 'Insight ETHOS: On object-orientation in operating systems', </title> <type> Ph.D. Thesis, </type> <institution> ETH Zurich, 232p., </institution> <year> 1992. </year>
Reference-contexts: The running kernel is monolithic where objects are just "portions of data in memory", as it is defined for C++ in [Stroustrup90]. Activities or processes, which are essential for operating systems, are not covered by reducing object-orientation to the means of a sequential object-oriented language. ETHOS <ref> [Szyperski92] </ref> is another example for this approach. ETHOS was developed at the ETH Zurich and is implemented in OBERON [Wirth88]. In [Muller91] a proposal is made to represent different layers of an operating system as instances of classes representing one layer each.
Reference: [Tanenbaum90] <institution> Tanenbaum,A.: 'Betriebssysteme: Entwurf und Realisierung (Teile 1/2)', Hanser-Verlag, Munchen, 322 S., </institution> <year> 1990. </year> <title> [Web88] : 'Webb Webster's New World Dictionary', Third College Edition, </title> <publisher> Simon & Schusters, Inc., </publisher> <year> 1988. </year>
Reference-contexts: CHORUS [Rozier88] is very close to MACH. NT of Microsoft has a similar direction. The practical need for compatibility of interfaces to older or other systems is covered by providing their interfaces but with a different internal structure. Own experiences were made in our group by restructuring MINIX <ref> [Tanenbaum90] </ref> in an object-oriented fashion. The new system was called MINIX++ [Wiatrowski92] and also follows the -kernel approach. 5 (4.) Whereas other examples could easily be found for the above approaches, there are only a few systems covering this point.
Reference: [Wegner90] <author> Wegner,P.: </author> <title> 'Concepts and Paradigms of Object-Oriented Programming', OOP Messenger, </title> <type> 1(1), </type> <institution> pp.8-85, </institution> <year> 1990. </year>
Reference-contexts: Relations among objects and properties are restricted to relations to classified property sets. In programming languages this is reflected by the object model (point 1) and the class hierarchy (points 2,3,4). <ref> [Wegner90] </ref> terms the classification of property sets of equal objects as "functional abstraction", the classification of property sets as "super abstraction". Properties are mostly represented by variables (states) and methods (behavior) there. In a running system there are additional things to be considered, such as activities and their interaction.
Reference: [Wettstein93] <author> Wettstein,H.: 'Systemarchitektur', </author> <title> (in German), </title> <publisher> Carl Hanser Verlag Munchen Wien, </publisher> <address> 514 S., </address> <year> 1993. </year> <month> 27 </month>
Reference-contexts: The flexibility of having more such forms could be integrated by creating different qualities, which naturally applies to the multi-level architecture. 16 Objects encapsulate activities performing services. (2)-control is given for activities by the meth-ods of objects. Performing services also requires interaction among objects <ref> [Wettstein93] </ref> that primarily concerns two basic mechanisms: control, for the coordination of two or more activities, that may be centralized in the infrastructure ( (1)-control) or may be decentralized among the involved activities in their (2)-control, and data shipping, either via commonly accessible memory (cooperation) or via a channel with no
Reference: [Wiatrowski92] <author> Wiatrowski,J.: </author> <title> 'Entwurf und Implementierung eines objektorientierten Betriebssystems', (in German), </title> <institution> Diplomarbeit, TU Chemnitz, Fakultat fur Informatik, </institution> <year> 1992. </year>
Reference-contexts: The practical need for compatibility of interfaces to older or other systems is covered by providing their interfaces but with a different internal structure. Own experiences were made in our group by restructuring MINIX [Tanenbaum90] in an object-oriented fashion. The new system was called MINIX++ <ref> [Wiatrowski92] </ref> and also follows the -kernel approach. 5 (4.) Whereas other examples could easily be found for the above approaches, there are only a few systems covering this point. The most advanced operating system here is Apertos [Yokote92] of Sony CSL and Keio University, Tokio.
Reference: [Wirth88] <author> Wirth,N.: </author> <title> 'Oberon', </title> <journal> Software-Practice & Experience., Vol.18, No.7, </journal> <volume> pp.671-690, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Activities or processes, which are essential for operating systems, are not covered by reducing object-orientation to the means of a sequential object-oriented language. ETHOS [Szyperski92] is another example for this approach. ETHOS was developed at the ETH Zurich and is implemented in OBERON <ref> [Wirth88] </ref>. In [Muller91] a proposal is made to represent different layers of an operating system as instances of classes representing one layer each. All components of a layer are aggregates of this class. The interface of a layer can directly be reflected as the interface of a class.
Reference: [Yokote92] <author> Yokote,Y.: </author> <title> 'The Apertos Reflective Operating System: The Concept and its Impementation', </title> <address> Proc.of OOPSLA'92, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: The new system was called MINIX++ [Wiatrowski92] and also follows the -kernel approach. 5 (4.) Whereas other examples could easily be found for the above approaches, there are only a few systems covering this point. The most advanced operating system here is Apertos <ref> [Yokote92] </ref> of Sony CSL and Keio University, Tokio. The basic structuring principle is object-meta-object separation. All infrastructure for instances (objects) is provided by meta-objects forming a meta-space. A set of instances share the same meta-space. Other sets may have other meta-spaces.
Reference: [Yonezawa86] <editor> Yonezawa,A., Briot,J.P., Shibayama,E.: </editor> <booktitle> 'Object-Oriented Concurrent Programming in ABCL/1', Proc.of OOPSLA'86, ACM, September-October 1986. </booktitle> <pages> 28 </pages>
Reference-contexts: The active structure of an operating system cannot fully be grasped at this level, because the language has no means for expressing things like multiple activities, even not at different levels. Although, there are many proposals for introducing concurrency to object-oriented languages by creating new concurrent languages as ABCL/1 <ref> [Yonezawa86] </ref>, by extending existing languages as PRESTO [Bershad88], and C++ [Buhr92], or just providing libraries with fork ()-like routines, as C-Threads [Cooper87], pThreads [Graupner94] or other.
References-found: 41

