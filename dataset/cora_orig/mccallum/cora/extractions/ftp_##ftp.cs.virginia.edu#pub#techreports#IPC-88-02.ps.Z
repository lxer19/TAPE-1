URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-88-02.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: RELIABILITY MECHANISMS FOR ADAMS  
Author: Sang H. Son John L. Pfaltz 
Note: To appear Proceedings of third conference on Hypercube concurrent Computers and Applications Pasadena, Califor-nia  This research was supported in part by JPL under contract #957721.  
Address: Charlottesville, VA 22903  
Affiliation: Institute for Parallel Computation School of Engineering and Applied Science University of Virginia  
Date: March 20, 1988  (January 1988)  
Pubnum: IPC-TR-88-002  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Attar, R., Bernstein, P. A. and Goodman, N., </author> <title> Site Initialization, Recovery, and Backup in a Distributed Database System, </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> November </month> <year> 1984, </year> <pages> pp 645-650. </pages>
Reference-contexts: Therefore the granularity of a data object should be determined carefully by considering all such trade-offs, and we cannot minimize the size of the CTV file by simply minimizing the data object granularity. There is no extra storage requirement in intrusive checkpointing mechanisms <ref> [1, 8, 15] </ref>. However this property is balanced by the cases in which the system must block ACPT or abort half-way done global transactions because of the checkpointing process.
Reference: [2] <author> Chandy, K. M., Lamport, L., </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems, </title> <journal> ACM Trans. on Computer Systems, </journal> <month> February </month> <year> 1985, </year> <pages> pp 63-75. </pages>
Reference-contexts: Recently, the possibility of having a checkpoint-ing mechanism that does not interfere with the transaction processing, and yet achieves the global con-sistency of the checkpoints, has been studied <ref> [2, 5, 19] </ref>. The motivation of non-interfering checkpointing is to improve the system availability, that is, the system must be able to execute user transactions concurrently with the checkpointing process. <p> We also assume that network partitioning never occurs. This assumption is reasonable for most local area networks and some long-haul networks. 3. Non-Interfering Checkpoint Creation 3.1. Motivation of Noninterference The motivation of having a checkpointing scheme which does not interfere with transaction processing is well explained in <ref> [2] </ref> by using the analogy of migrating birds and a group of photographers. Suppose a group of photographers observe a sky filled with migrating birds.
Reference: [3] <author> Dadam, P. and Schlageter, G., </author> <title> Recovery in Distributed Databases Based on Non-synchronized Local Checkpoints, </title> <booktitle> Information Processing 80, </booktitle> <publisher> North-Holland Publishing Company, </publisher> <address> Amster-dam, </address> <year> 1980, </year> <pages> pp 457-462. </pages>
Reference: [4] <author> Eswaran, K. P. et al, </author> <title> The Notion of Consistency and Predicate Locks in a Database System, </title> <booktitle> Com-mun. of ACM, </booktitle> <month> Nov. </month> <year> 1976, </year> <pages> pp 624-633. </pages>
Reference-contexts: The set of data objects in a parallel database system is partitioned among its nodes. A database is said to be consistent if the values of data objects satisfy a set of assertions. The assertions that characterize the consistent states of the database are called the consistency constraints <ref> [4] </ref>. The basic units of user activity in database systems are transactions. Each transaction represents a complete and correct computation, i.e., if a transaction is executed alone on an initially consistent database, it would terminate in a finite time and produce correct results, leaving the database consistent. <p> Note that only one checkpointing process can be active at a time because the checkpointing coordinator is not allowed to issue another checkpointing request before the termination of the previous one. A database state is consistent if the set of data objects satisfies the consistency constraints <ref> [4] </ref>.
Reference: [5] <author> Fischer, M. J., Griffeth, N. D. and Lynch, N. A., </author> <title> Global States of a Distributed System, </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> May </month> <year> 1982, </year> <pages> pp 198-202. </pages>
Reference-contexts: Recently, the possibility of having a checkpoint-ing mechanism that does not interfere with the transaction processing, and yet achieves the global con-sistency of the checkpoints, has been studied <ref> [2, 5, 19] </ref>. The motivation of non-interfering checkpointing is to improve the system availability, that is, the system must be able to execute user transactions concurrently with the checkpointing process.
Reference: [6] <author> Gelenbe, E., </author> <title> On the Optimum Checkpoint Interval, </title> <journal> Journal of ACM, </journal> <month> April </month> <year> 1979, </year> <pages> pp 259-270. </pages>
Reference: [7] <author> Hammer, M. and Shipman, D., </author> <title> Reliability Mechanisms for SDD-1: A System for Distributed Databases, </title> <journal> ACM Trans. on Database Systems, </journal> <month> December </month> <year> 1980, </year> <pages> pp 431-466. </pages>
Reference-contexts: These backup processes are in fact checkpointing subordinates. If the coordinator fails before it broadcasts the GCPN message, one of the backups takes the control. A similar mechanism is used in SDD-1 <ref> [7] </ref> for reliable commitment of transactions. Proper coordination among the backup processes is crucial here. In the event of the failure of the coordinator, one, and only one backup process has to assume the control.
Reference: [8] <author> Jouve, M., </author> <title> Reliability Aspects in a Distributed Database Management System, </title> <booktitle> Proc. of AICA, </booktitle> <year> 1977, </year> <pages> pp 199-209. </pages>
Reference-contexts: Therefore the granularity of a data object should be determined carefully by considering all such trade-offs, and we cannot minimize the size of the CTV file by simply minimizing the data object granularity. There is no extra storage requirement in intrusive checkpointing mechanisms <ref> [1, 8, 15] </ref>. However this property is balanced by the cases in which the system must block ACPT or abort half-way done global transactions because of the checkpointing process.
Reference: [9] <author> Kuss, H., </author> <title> On Totally Ordering Checkpoints in Distributed Databases, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1982, </year> <pages> pp 293-302. </pages>
Reference-contexts: Complete recovery mechanisms based on the special time-stamp of checkpoints (e.g., GCPN) have been proposed in <ref> [9, 20] </ref>. 6. Concluding Remarks During normal operation of the database system, checkpointing is performed to save information necessary for recovery from a failure. For better recoverabil-ity and availability of parallel database systems, check-pointing must be able to generate a globally consistent database state, without interfering with transaction processing.
Reference: [10] <author> Lamport, L., </author> <title> Time, Clocks and Ordering of Events in Distributed Systems, </title> <journal> Commun. ACM, </journal> <month> July </month> <year> 1978, </year> <pages> pp 558-565. </pages>
Reference-contexts: We assume that the database system runs a correct transaction control mechanism (e.g., atomic commit algorithm [17] and concurrency control algorithm [18]), and hence assures the atomicity and the serializability of transactions. Each transaction has a time-stamp associated with it <ref> [10] </ref>. A time-stamp is a number that is assigned to a transaction when initiated and is kept by the transaction. <p> Once a checkpoint has started, the coordinator does not issue the next checkpoint request until the first one has terminated. The variables used in the algorithm are as follows: (1) Local Clock (LC): a clock maintained at each node which is manipulated by the clock rules of Lamport <ref> [10] </ref>. (2) Local Checkpoint Number (LCPN): a number determined locally for the current checkpoint. (3) Global Checkpoint Number (GCPN): a globally unique number for the current checkpoint. (4) CONVERT: a Boolean variable showing the completion of the conversion of all the eligible transactions at the node.
Reference: [11] <author> McDermid, J., </author> <title> Checkpointing and Error Recovery in Distributed Systems, </title> <booktitle> 2nd International Conference on Distributed Computing Systems, </booktitle> <month> April </month> <year> 1981, </year> <pages> pp 271-282. </pages>
Reference: [12] <author> Mohan, C., Strong, R., and Finkelstein, S., </author> <title> Method for Distributed Transaction Commit and Recovery Using Byzantine Agreement Within Clusters of Processors, </title> <booktitle> 2nd ACM SIGACT/SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1983. </year>
Reference: [13] <author> Ricart, G. and Agrawala, A. K., </author> <title> An Optimal Algorithm for Mutual Exclusion in Computer Networks, </title> <journal> Commun. of ACM, </journal> <month> Jan. </month> <year> 1981, </year> <pages> pp 9-17. </pages>
Reference: [14] <author> Ries, D., </author> <title> The Effect of Concurrency Control on The Performance of A Distributed Data Management System, </title> <booktitle> 4th Berkeley Conference on Distributed Data Management and Computer Networks, </booktitle> <month> Aug. </month> <year> 1979, </year> <pages> pp 221-234. </pages>
Reference-contexts: By doing so, however, the overhead of normal transaction processing (e.g., locking and unlocking, deadlock detection, etc) will be increased. Also, there is a trade-off between the degree of concurrency and the lock granularity <ref> [14] </ref>. Therefore the granularity of a data object should be determined carefully by considering all such trade-offs, and we cannot minimize the size of the CTV file by simply minimizing the data object granularity. There is no extra storage requirement in intrusive checkpointing mechanisms [1, 8, 15].
Reference: [15] <author> Schlageter, G. and Dadam, P., </author> <title> Reconstruction of Consistent Global States in Distributed Databases, </title> <booktitle> International Symposium on Distributed Databases, </booktitle> <publisher> North-Holland Publishing Company, INRIA, </publisher> <year> 1980, </year> <pages> pp 191-200. </pages>
Reference-contexts: Therefore the granularity of a data object should be determined carefully by considering all such trade-offs, and we cannot minimize the size of the CTV file by simply minimizing the data object granularity. There is no extra storage requirement in intrusive checkpointing mechanisms <ref> [1, 8, 15] </ref>. However this property is balanced by the cases in which the system must block ACPT or abort half-way done global transactions because of the checkpointing process. <p> Thus a checkpoint-ing will terminate in a finite time once it begins. 5.3. Recovery The recovery from node crashes is called the node recovery. The complexity of the node recovery varies in parallel database systems according to the failure situation <ref> [15] </ref>. If the crashed node has no replicated data objects and if all the recovery information is available at the crashed node, local recovery is enough. Global recovery is necessary because of failures which require the global database to be restored to some earlier consistent state.
Reference: [16] <author> Shin, K. G., Lin, T.-H., Lee, Y.-H., </author> <title> Optimal Checkpointing of Real-Time Tasks, </title> <booktitle> 5th Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <month> January </month> <year> 1986, </year> <pages> pp 151-158. </pages>
Reference: [17] <author> Skeen, D., </author> <title> Nonblocking Commit Protocols, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1981, </year> <pages> pp 133-142. </pages>
Reference-contexts: When a transaction is committed, the output values are finalized and made available to all subsequent transactions. We assume that the database system runs a correct transaction control mechanism (e.g., atomic commit algorithm <ref> [17] </ref> and concurrency control algorithm [18]), and hence assures the atomicity and the serializability of transactions. Each transaction has a time-stamp associated with it [10]. A time-stamp is a number that is assigned to a transaction when initiated and is kept by the transaction. <p> This implies that all the eligible BCPT will become BCPT before local checkpointing begins in step 6. Therefore, updates of all BCPT are reflected in the current checkpoint. &gt;From the atomic property of transactions provided by the transaction control mechanism (e.g. commit protocol in <ref> [17] </ref>), it can be assured that if a transaction is committed at a participating node then it is committed at all other participating nodes.
Reference: [18] <author> Son, S. H., </author> <title> On Multiversion Replication Control in Distributed Systems, </title> <journal> Computer Systems Science and Engineering, </journal> <volume> Vol. 2, No. 2, </volume> <month> April </month> <year> 1987, </year> <pages> pp 76-84. </pages>
Reference-contexts: When a transaction is committed, the output values are finalized and made available to all subsequent transactions. We assume that the database system runs a correct transaction control mechanism (e.g., atomic commit algorithm [17] and concurrency control algorithm <ref> [18] </ref>), and hence assures the atomicity and the serializability of transactions. Each transaction has a time-stamp associated with it [10]. A time-stamp is a number that is assigned to a transaction when initiated and is kept by the transaction. <p> Since we have a finite number of BCPT when the checkpointing is initiated, all of them will terminate in a finite time, and hence the checkpointing itself will terminate in a finite time. Concurrency control mechanisms based on time-stamp ordering as in <ref> [18] </ref> can ensure the termination of transactions in a finite time. 4. Consistency of Checkpoints In this section we give an informal proof of the correctness of the algorithm.
Reference: [19] <author> Son, S. H. and Agrawala, A., </author> <title> Practicality of Non-Interfering Checkpoints in Distributed Database Systems, </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <address> New Orleans, Louisiana, </address> <month> December </month> <year> 1986, </year> <pages> pp 234-241. </pages>
Reference-contexts: Recently, the possibility of having a checkpoint-ing mechanism that does not interfere with the transaction processing, and yet achieves the global con-sistency of the checkpoints, has been studied <ref> [2, 5, 19] </ref>. The motivation of non-interfering checkpointing is to improve the system availability, that is, the system must be able to execute user transactions concurrently with the checkpointing process. <p> This property reduces the work required in the actual recovery, which is discussed in Section 5. A longer and more thorough discussion on the correctness of the algorithm is given in <ref> [19] </ref>. The properties of the algorithm we want to show are (1) a set of all local checkpoints with the same GCPN represents a consistent database state, and (2) all the updates of the committed transactions with earlier time-stamps than the GCPN are reflected in the current checkpoint. <p> Therefore, as far as the values of these variables can be maintained within a certain threshold level, non-interfering checkpointing would not severely degrade the performance of the system. A detailed discussion on the practicality of non-interfering checkpointing is given in <ref> [19] </ref>. 5.2. Node Failures So far, we assumed that no failure occurs during checkpointing. This assumption can be justified if the probability of failures during a single checkpoint is extremely small.
Reference: [20] <author> Son, S. H. and Agrawala, A., </author> <title> An Algorithm for Database Reconstruction in Distributed Environments, </title> <booktitle> 6th International Conference on Distributed Computing Systems, </booktitle> <address> Cambridge, Mas-sachusetts, </address> <month> May </month> <year> 1986, </year> <pages> pp 532-539. </pages>
Reference-contexts: Given our space limitations, our objective is to intuitively explain this approach and not to provide details. The details are given in separate papers <ref> [20, 21] </ref>. 2. Model of Computation 2.1. Data Objects and Transactions A database consists of a set of data objects. Each data object has a value and represents the smallest unit of the database accessible to the user. <p> Complete recovery mechanisms based on the special time-stamp of checkpoints (e.g., GCPN) have been proposed in <ref> [9, 20] </ref>. 6. Concluding Remarks During normal operation of the database system, checkpointing is performed to save information necessary for recovery from a failure. For better recoverabil-ity and availability of parallel database systems, check-pointing must be able to generate a globally consistent database state, without interfering with transaction processing.
Reference: [21] <author> Son, S. H., </author> <title> "An Adaptive Checkpointing Scheme for Distributed Databases with Mixed Types of Transactions," </title> <booktitle> Fourth International Conference on Data Engineering, </booktitle> <address> Los Angeles, </address> <month> February </month> <year> 1988, </year> <pages> pp 528-535. </pages>
Reference-contexts: Given our space limitations, our objective is to intuitively explain this approach and not to provide details. The details are given in separate papers <ref> [20, 21] </ref>. 2. Model of Computation 2.1. Data Objects and Transactions A database consists of a set of data objects. Each data object has a value and represents the smallest unit of the database accessible to the user.
References-found: 21

