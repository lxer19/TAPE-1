URL: http://www.cse.psu.edu/~keefe/publications/ifip98.ps
Refering-URL: http://www.cse.psu.edu/~keefe/star-dbs.html
Root-URL: http://www.cse.psu.edu
Title: 1 VERSION MANAGEMENT IN THE STAR MLS DATABASE SYSTEM  
Author: Ramprasad Sripada Thomas F. Keefe 
Note: 1.1 INTRODUCTION  
Abstract: This paper describes version management in the Secure TransActional Resources Database System (*-DBS) currently being developed at Penn State. This system employs concurrency control based on a secure multiversion timestamp ordering protocol. Efficient version management is critical to the performance of such a system. This paper describes a method of version management that requires no trust, adapts effectively to skewed access patterns, provides access to any version with at most one disk access and supports tuple level concurrency control. Based on our implementation, we report on the performance of this method. Multiversion databases are used as part of the design for Secure TransActional Resources-Database System (*-DBS) project currently being developed at Penn State. This paper addresses issues related to secure and efficient version management. The methods developed are implemented and the results and insights obtained are presented. Secure version management methods often assign high-level transactions smaller timestamps than those of low-level transactions forcing them to access older versions. This bias can lead to performance penalties on high-level transaction. We attempt to improve performance of these transactions and at the same time improve performance for transactions that update or modify databases at their own security level. In this paper, we propose a dynamic on-page caching scheme and an in-memory version directory that reduces and 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta et al., 1986] <author> Accetta, M., Robert Baron, W. B., Golub, D., Rashid, R., Tevanian, A., and Young, M. </author> <year> (1986). </year> <title> Mach: A new kernel foundation for unix development. </title> <booktitle> Proceedings of the Summer 1986 USENIX Conference. </booktitle>
Reference-contexts: The prototype is hosted on Distributed Trusted Operating System (DTOS) [Minear, 1995]. DTOS is an experimental prototype operating system developed at Secure Computing Corporation. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel <ref> [Accetta et al., 1986] </ref> [Golub et al., 1990]) and provides policy-based control over all Mach services. components are shown shaded. The prototype adopts a client/server architecture. A transaction executing at a client begins by contacting a transaction manager (TM) which assigns it a timestamp.
Reference: [Baskaran, 1996] <author> Baskaran, A. </author> <year> (1996). </year> <title> Buffer management for a multilevel secure dbms. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science and Engineering, The Pennsylvania State University, University Park, </institution> <address> PA 16802. </address>
Reference-contexts: The RM implements a restricted SQL-like RPC level interface (i.e., no nested queries, no aggregates, no sortby, and no support for groups). The RM makes pin/unpin requests to the buffer manager (BM) <ref> [Baskaran, 1996] </ref>. The buffer manager controls the movement of data between the persistent and volatile portions of the database for all security levels. 8 It also coordinates logging with page flushes to enforce the write ahead logging (WAL) protocol [Gray and Reuter, 1993]. <p> Transactions at higher level thus retrieve the buffer containing the entry they wish to access. In case, a subject at the lower security level tries to pin this page in write mode, the page is copied to another buffer <ref> [Baskaran, 1996] </ref>. Retrieval and traversal through the hash list are done transparently through an interface implemented within the RM. This interface abstracts away the security related issues and provides functionality allowing all standard operations on a hash table.
Reference: [Bell and LaPadula, 1976] <author> Bell, D. E. and LaPadula, L. J. </author> <year> (1976). </year> <title> Secure computer systems: Unified exposition and multics interpretations. </title> <type> Technical Report MTR-2997, </type> <institution> Mitre Corp. </institution>
Reference-contexts: This paper considers mandatory security only. In systems enforcing multilevel security, objects represent elements of information and subjects represent active entities such as processes. Subjects and Objects are assigned security levels. The Bell-LaPadula model <ref> [Bell and LaPadula, 1976] </ref> provides a concrete method of enforcing mandatory access control policy. It defines allowable read and write accesses to data objects in the form of the simple security and *-property [Bell and LaPadula, 1976]. <p> Subjects and Objects are assigned security levels. The Bell-LaPadula model <ref> [Bell and LaPadula, 1976] </ref> provides a concrete method of enforcing mandatory access control policy. It defines allowable read and write accesses to data objects in the form of the simple security and *-property [Bell and LaPadula, 1976]. The simple security requires that a subject be allowed to read an object only if the security level of the subject dominate that of the object. The *-property requires that a subject only be allowed to write objects with security levels dominating its own. <p> Any such transactions are aborted. For more details refer to [Sripada, 1997]. Storing version information in memory improves the performance of transactions at dominating security levels. We use a secure timestamp generator based on the protocol described in [Keefe and Tsai, 1993]. As explained earlier, due to the *-property <ref> [Bell and LaPadula, 1976] </ref>, a database can only be queried by transactions at dominating security levels. Combined with our timestamp generation method this forces high-level transactions to access older versions.
Reference: [Bernstein et al., 1987] <author> Bernstein, P., Hadzilacos, V., </author> <title> and N.Goodman (1987). Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: A similar idea for storing timestamp information in a single versioned system is proposed in <ref> [Bernstein et al., 1987] </ref>. After the tuple identifier for a key value is located using the index, we can use the in-memory structure to determine where the appropriate version resides with no additional I/O operations.
Reference: [Bober and Carey, 1992] <author> Bober, P. and Carey, M. </author> <year> (1992). </year> <title> On mixing queries and transactions via multiversion locking. </title> <booktitle> Proceedings of the Eight IEEE Data Engineering Conference. </booktitle>
Reference-contexts: An implication of this is that transactions accessing a database at a lower security level appear to the lower database as a query. 1.1.2 Multiversion Databases Versions are retained not for the sake of satisfying temporal queries but for concurrency purposes. This type of versioning is called transient versioning <ref> [Bober and Carey, 1992] </ref>. This means that at startup the database is single versioned. After recovery, the database is single-versioned once again. In a multiversioned system, transactions are assigned a timestamp value when they enter the system. <p> The files containing the secondary versions is referred to as the version pool. However, in view of the inefficiencies arising from this storage arrangement, Bober and Carey suggested on-page caching <ref> [Bober and Carey, 1992] </ref>. In this approach, part of the version pool resides in the data pages of the main database itself. On-page caching as suggested by [Bober and Carey, 1992] assigns a fixed portion of every data page to hold the cache. <p> However, in view of the inefficiencies arising from this storage arrangement, Bober and Carey suggested on-page caching <ref> [Bober and Carey, 1992] </ref>. In this approach, part of the version pool resides in the data pages of the main database itself. On-page caching as suggested by [Bober and Carey, 1992] assigns a fixed portion of every data page to hold the cache. Consider for example, an update to a record. When this record is updated, the current primary version is copied into the cache before the new primary is created. <p> One side effect of on-page caching is an improvement in data page utilization in the main database. This is because, more versions are made to reside in the main database itself using the space already available. The effect of on-page caches on performance is discussed in detail in <ref> [Bober and Carey, 1992] </ref>. Let us examine how a record is typically accessed using a B + -tree. When a record has to be accessed by, say, a query operation, the location of the primary version is obtained from the leaf page in the B + -tree. <p> The size of on-page cache is allowed to grow dynamically to accommodate the workload requirements. Versions are pushed to the version pool only when the data page is full as opposed to the on-page cache as recommended in <ref> [Bober and Carey, 1992] </ref>. However, we still retain a version pool that would be used when a data page becomes full. Whenever a page becomes full, we check if any of the versions can be collected. If not, then the oldest version is selected for replacement. <p> This would store the updates to the databases before the transaction commits. This makes it unnecessary to flush the versions pool writes to disk before committing a transaction. Dynamic on-page caching allows the benefits of on-page caching described above to be more fully utilized. Results in <ref> [Bober and Carey, 1992] </ref> suggest that queries execute faster as the size of the on-page cache is increased. By allowing this size to be determined dynamically, we can accommodate secondary versions more efficiently. <p> On average, for every ten tuples in the database, one update operation was applied. This means the average size of a version chain is 1.1 versions. This value was motivated by results of a performance study described in <ref> [Bober and Carey, 1992] </ref>. Page size for the database was 4096 bytes. Tuple size was chosen to allow 30 tuples per page. Tuples were inserted until the database consisted of about 100 data pages.
Reference: [Bober and Carey, 1993] <author> Bober, P. and Carey, M. </author> <year> (1993). </year> <title> Indexing alternatives for multiversion locking. </title> <type> Technical Report 1184, </type> <institution> Dept. of Computer Science, University of Wisconsin-Madison. </institution>
Reference-contexts: For example, without on-page caching all secondary versions would reside in the version pool. However, even with on-page caching, overflow from on-page cache causes secondary versions to be pushed to the version pool. Alternative storage arrangements for faster access to a version were proposed in <ref> [Bober and Carey, 1993] </ref>. Three techniques were proposed and the performance of these techniques were evaluated using simulation. The method with the best overall performance was data page version selection (DP). <p> Another test was devised to observe the savings in disk I/O due to the version table. The scheme we compare our savings against is Data Page scheme (DP) <ref> [Bober and Carey, 1993] </ref>. In this method, all of the version information is stored with the primary version. <p> This was done with support from DTOS and the buffer manager. The combined effects of dynamic on-page caching and the version table show a reduction in I/O of between 32 and 47% over the DP method of <ref> [Bober and Carey, 1993] </ref>.
Reference: [Chan et al., 1982] <author> Chan, A., S.Fox, Lin, W., Nori, A., and Ries, D. </author> <year> (1982). </year> <title> The implementation of an integrated concurrency control and recovery scheme. </title> <booktitle> Proceedings of ACM SIGMOD Conference. </booktitle>
Reference-contexts: Implementation issues are dealt with in Section 1.5. Experimental results obtained from the implementation are presented in the Section 1.6 followed by concluding remarks in Section 1.7. 1.2 RELATED WORK Early multiversioned systems stored primary and secondary versions in two different database files <ref> [Chan et al., 1982] </ref>. The files containing the secondary versions is referred to as the version pool. However, in view of the inefficiencies arising from this storage arrangement, Bober and Carey suggested on-page caching [Bober and Carey, 1992]. <p> However, the model did not address on-page caching. It was assumed that all secondary versions were maintained in the version pool. Both [Warner and Keefe, 1995] and <ref> [Chan et al., 1982] </ref> assume versions at the granularity of pages. In this work, we adopt a tuple- level granularity and maintain version location information in memory. 1.3 DYNAMIC ON-PAGE CACHING In our scheme, no space is dedicated to an on-page cache.
Reference: [Golub et al., 1990] <author> Golub, D., Dean, R., Forin, A., and Rashid, R. </author> <year> (1990). </year> <title> Unix as an application program. </title> <booktitle> Proceedings of the USENIX Conference. </booktitle>
Reference-contexts: The prototype is hosted on Distributed Trusted Operating System (DTOS) [Minear, 1995]. DTOS is an experimental prototype operating system developed at Secure Computing Corporation. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [Accetta et al., 1986] <ref> [Golub et al., 1990] </ref>) and provides policy-based control over all Mach services. components are shown shaded. The prototype adopts a client/server architecture. A transaction executing at a client begins by contacting a transaction manager (TM) which assigns it a timestamp.
Reference: [Gray and Reuter, 1993] <author> Gray, J. and Reuter, A. </author> <year> (1993). </year> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA. </address>
Reference-contexts: The RM makes pin/unpin requests to the buffer manager (BM) [Baskaran, 1996]. The buffer manager controls the movement of data between the persistent and volatile portions of the database for all security levels. 8 It also coordinates logging with page flushes to enforce the write ahead logging (WAL) protocol <ref> [Gray and Reuter, 1993] </ref>. Each RM is multithreaded allowing it to service requests from multiple clients concurrently.
Reference: [Keefe and Tsai, 1993] <author> Keefe, T. F. and Tsai, W. T. </author> <year> (1993). </year> <title> Multiversion transaction scheduler for centralized multilevel secure database systems. </title> <type> Technical Report TR-93-116, </type> <institution> Department of Computer Science and Engineering, The Pennsylvania State University. </institution>
Reference-contexts: Any such transactions are aborted. For more details refer to [Sripada, 1997]. Storing version information in memory improves the performance of transactions at dominating security levels. We use a secure timestamp generator based on the protocol described in <ref> [Keefe and Tsai, 1993] </ref>. As explained earlier, due to the *-property [Bell and LaPadula, 1976], a database can only be queried by transactions at dominating security levels. Combined with our timestamp generation method this forces high-level transactions to access older versions. <p> The prototype adopts a client/server architecture. A transaction executing at a client begins by contacting a transaction manager (TM) which assigns it a timestamp. For details on the protocol governing secure timestamp generation refer to <ref> [Keefe and Tsai, 1993] </ref>. The TM provides timestamps to transactions at all security levels. The transaction then proceeds to make service requests to one or more resource managers (RM). When the transaction is complete, it contacts the transaction manager again to request that its work be committed.
Reference: [Kumar, 1996] <author> Kumar, V., </author> <title> editor (1996). Performance of Concurrency Control mechanisms in Centralized Database Dystems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ. </address>
Reference-contexts: For pages that see little or no update activity, the portion of the page that otherwise would be set aside for the cache is available for primary versions. However, when a page is updated frequently it becomes a hotspot <ref> [Kumar, 1996] </ref>. In this case, with a fixed cache size, cache overflow would occur frequently and the performance benefits of on-page caching are reduced. To address this problem, the size of the dynamic on-page cache is controlled dynamically based on the update frequency of the page. <p> We characterize the amount of nonuniformity or access skew as x%, implying that x% of access requests are directed to 100 x% of the data elements in the database <ref> [Kumar, 1996] </ref>. The database is divided into two parts, the first constitutes x% of the data items and the second represents the reminder (100x%). With probability 100x 100 a transaction accesses the first part. An element of this set is chosen based on a uniform distribution.
Reference: [Minear, 1995] <author> Minear, S. E. </author> <year> (1995). </year> <title> Providing policy control over object operations in a mach based system. </title> <booktitle> Proceedings of USENIX Conference, </booktitle> <pages> pages 1-15. </pages> <note> VERSION MANAGEMENT IN THE STAR MLS DATABASE SYSTEM 13 </note>
Reference-contexts: During garbage collection, versions in a page can be collected by looking at one hash chain. 1.5 IMPLEMENTATION ASPECTS The design discussed above was implemented as part of the *-DBS project. The prototype is hosted on Distributed Trusted Operating System (DTOS) <ref> [Minear, 1995] </ref>. DTOS is an experimental prototype operating system developed at Secure Computing Corporation. It provides mechanisms to implement multilevel security on the CMU Mach Microkernel [Accetta et al., 1986] [Golub et al., 1990]) and provides policy-based control over all Mach services. components are shown shaded.
Reference: [Pesati et al., 1997] <author> Pesati, V. R., Keefe, T. F., and Pal, S. </author> <year> (1997). </year> <title> The design and implementation of a multilevel secure log manager. </title> <booktitle> Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <pages> page 55 64. </pages>
Reference: [Sripada, 1997] <author> Sripada, R. </author> <year> (1997). </year> <title> The design of a multiversion database file manager for multilevel secure systems. </title> <type> Master's thesis, </type> <institution> Deptartment of Computer Science and Engineering, The Pennsylvania State University. </institution>
Reference-contexts: When the default timestamp is changed, all versions with smaller timestamps can be removed from the version directory. We ensure that no active transaction exists with a timestamp below the default timestamp. Any such transactions are aborted. For more details refer to <ref> [Sripada, 1997] </ref>. Storing version information in memory improves the performance of transactions at dominating security levels. We use a secure timestamp generator based on the protocol described in [Keefe and Tsai, 1993].
Reference: [Warner and Keefe, 1995] <author> Warner, A. C. and Keefe, T. F. </author> <year> (1995). </year> <title> Version pool management in a multilevel secure multiversion transaction manager. </title> <booktitle> Proceedings of IEEE Symposium on Research in Security and Privacy. </booktitle>
Reference-contexts: We propose to store this information in memory thereby reducing the number of disk accesses to one. In this regard, we assume a B + -tree with clustering index. A feasibility study of multiversioned databases enforcing MLS was reported in <ref> [Warner and Keefe, 1995] </ref>. The focus was on mechanisms to provide efficient access to multiple versions of data. In this regard, the authors studied in detail the storage and access costs associated with multiversioning. <p> However, the model did not address on-page caching. It was assumed that all secondary versions were maintained in the version pool. Both <ref> [Warner and Keefe, 1995] </ref> and [Chan et al., 1982] assume versions at the granularity of pages. In this work, we adopt a tuple- level granularity and maintain version location information in memory. 1.3 DYNAMIC ON-PAGE CACHING In our scheme, no space is dedicated to an on-page cache.
References-found: 15

