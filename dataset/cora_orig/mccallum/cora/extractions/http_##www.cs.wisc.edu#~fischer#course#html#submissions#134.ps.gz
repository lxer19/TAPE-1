URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/134.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: E-mail: onodera@trl.vnet.ibm.com  
Phone: Tel: +81-462-73-4645 Fax: +81-462-74-4282  
Title: Optimizing Smalltalk by Selector Code Indexing Can Be Practical  
Author: Tamiya Onodera and Hiroaki Nakamura 
Address: 1623-14, Shimo-tsuruma, Yamato-shi, Kanagawa-ken 242 Japan  
Affiliation: IBM Research, Tokyo Research Laboratory  
Abstract: Selector code indexing is a promising way of optimizing Smalltalk, since it can reduce the cost of a message send to that of an indirect procedure call. However, the technique has not been practically applied yet, because the space overhead is prohibitively high. A new technique called double caching maintains a small number of method tables indexed by a small number of selector colors. An initial experiment shows that, in the terms of the uses of classes and selectors, Smalltalk programs show enough locality for our technique to be effective. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agesen, O. el al. </author> <title> Type Inference of SELF: Analysis of Objects with Dynamic and Multiple Inheritance. </title> <booktitle> ECOOP'93 Conference Proceedings pp. </booktitle> <pages> 247-267. </pages>
Reference-contexts: There have been proposed a variety of techniques following these lines, which differ from each other in how to obtain type information. Type inference performs data and control flow analysis [11] or solves a bunch of constraints involving type variables assigned to expressions <ref> [1] </ref>. Type declaration [10] extends Smalltalk to specify types of variables and methods, while type annotation exploits type information specified in comments.
Reference: [2] <author> Andre, P. and J. C. </author> <title> Royer Optimizing Method search with Lookup Caches and Incremental Coloring. </title> <booktitle> OOPSLA'92 Conference Proceedings pp. </booktitle> <pages> 110-126. </pages>
Reference-contexts: As described later, the most important concern about selector code indexing is the total size of method tables. Two approaches, one using graph coloring <ref> [6, 2] </ref> and the other applying trie structures [7], have been proposed, but the results are still enough prohibitive; both end up with tripling the size of the virtual image of a commercial Smalltalk system. <p> However, it requires the memories proportional the number of different selectors multiplied by the average number of conflicts. Unfortunately, graphs handled by selector coloring are special in the sense that they contains enormous conflicts. Andre <ref> [2] </ref> proposed an incremental coloring algorithm in order to reduce the space requirements. The space overhead is decreased to be proportional to the number of different selectors multiplied by the number of colors.
Reference: [3] <author> Atkinson, R. G. </author> <title> Hurricane: An Optimizing Compiler for Smalltalk. </title> <booktitle> OOPSLA'86 Conference Proceedings pp. </booktitle> <pages> 151-158. </pages>
Reference-contexts: Customization gets receiver types from the lookup routine, and splitting recovers type information by copying message sends upwards along control flow [4]. Note that these techniques can, and should, be combined; for instance, type inference and type declaration are applied together in Hurricane <ref> [3] </ref>. Selector code indexing reduces the cost of a message send to that of an indirect procedure call, almost the same as that of a virtual function call in C++; it attempts to make the performance of Smalltalk closer to that of C++. <p> We then store into each method the card of the selector, and check it before we make an indirect call. Thus, the above pseudo-C code is now as follows, where we assume that the selector quo: is assigned the card of 26. method = aNumber-&gt;selectorTable <ref> [3] </ref>; if (method-&gt;selectorCard == 26/* card of quo:*/) (*method)(aNumber,7) else SelectorMismatchHandler (...); The SelectorMismatch handler simply raises the DoesNotUnderstand exception here.
Reference: [4] <author> Chambers, C. and D. Ungar. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation pp. </booktitle> <pages> 146-180. </pages>
Reference-contexts: Customization gets receiver types from the lookup routine, and splitting recovers type information by copying message sends upwards along control flow <ref> [4] </ref>. Note that these techniques can, and should, be combined; for instance, type inference and type declaration are applied together in Hurricane [3].
Reference: [5] <author> Deutsch, L. P. and A. M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> Proceeding of the 11th Symposium on the Principles of Programming Languages 1984, </booktitle> <pages> pp. 297-302. </pages>
Reference-contexts: The purpose of caching is to accelerate method lookup. For instance, a hash table per system is used in early Smalltalk-80 systems in order to cache lookup results. The remarkable techniques of inline caches <ref> [5] </ref> and PIC (polymorphic inline cache) [8] are variants of cache per send, although these are also considered to be applications of static binding using type feedback. Between the two could we imagine a cache per method and a cache per class, though we have not seen them yet.
Reference: [6] <author> Dixon, R. et al. </author> <title> A Fast Method Dispatcher for Compiled Languages with Multiple Inheritance. </title> <booktitle> OOPSLA'89 Conference Proceedings pp. </booktitle> <pages> 211-214. </pages>
Reference-contexts: As described later, the most important concern about selector code indexing is the total size of method tables. Two approaches, one using graph coloring <ref> [6, 2] </ref> and the other applying trie structures [7], have been proposed, but the results are still enough prohibitive; both end up with tripling the size of the virtual image of a commercial Smalltalk system. <p> Thus, the method tables in the naive numbering are very sparsely filled. 2 colors selectors 1 basicAt: 2 abs select: 3 quo: do: 2.1 Selector Coloring Dixon et al. <ref> [6] </ref> proposed the technique of selector coloring to improve space efficiency. We do not necessarily have to assign different numbers to different selectors. Two selectors must be assigned different numbers if and only if both belong to the same receivable set of some class. <p> We have computed the lower bounds for three commercial Smalltalk systems. As Figure 1 shows, these lower bounds are too large for the selector coloring to be practically applicable. 2.3 Coloring Algorithm Dixon et al. <ref> [6] </ref> colors selectors one by one with the general technique of sequential coloring. If a reasonable ordering is chosen, this simple algorithm mostly gives an optimal or nearly optimal coloring. However, it requires the memories proportional the number of different selectors multiplied by the average number of conflicts. <p> Since a Collection is being sent to the message with quo:, the DoesNotUnderstand exception must be raised. However, the compiled code totally overlooks this, and causes the do: method of Collection to be invoked. Dixon et al. <ref> [6] </ref> suggests to use unique selector code for detecting, and recovering from selector mismatch. 3 System Number Number Cardinality Lower Bound Size of of of of of Classes Selectors the Largest Space Virtual Receivable Overhead Image Set (MBytes) (MBytes) VisualSmalltalk 3.0 1,596 10,025 1,114 7.11 3.81 VisualAge 2.0 3,241 17,509 977
Reference: [7] <author> Driesen, K. </author> <title> Selector Table Indexing & Sparse Arrays. </title> <booktitle> OOPSLA'93 Conference Proceedings pp. </booktitle> <pages> 259-270. </pages>
Reference-contexts: As described later, the most important concern about selector code indexing is the total size of method tables. Two approaches, one using graph coloring [6, 2] and the other applying trie structures <ref> [7] </ref>, have been proposed, but the results are still enough prohibitive; both end up with tripling the size of the virtual image of a commercial Smalltalk system. What we propose here is a combination of caching and selector indexing, aimed at being practically applicable. <p> As seen later, we can use the handler to field other significant system events. 2.5 Method Tables Folding Before we conclude the section, we touch on another approach to alleviate the space inefficiency in the naive selector numbering. Driesen <ref> [7] </ref> proposed to fold those sparse method tables into a single long array by applying what are called trie structures.
Reference: [8] <author> Holzle, U et al. </author> <title> Optimizing Dynamically -Typed Object-Oriented languages With Polymorphic Inline Caches. </title> <booktitle> ECOOP'91 Conference Proceedings </booktitle>
Reference-contexts: The purpose of caching is to accelerate method lookup. For instance, a hash table per system is used in early Smalltalk-80 systems in order to cache lookup results. The remarkable techniques of inline caches [5] and PIC (polymorphic inline cache) <ref> [8] </ref> are variants of cache per send, although these are also considered to be applications of static binding using type feedback. Between the two could we imagine a cache per method and a cache per class, though we have not seen them yet. <p> However, such advanced techniques as type feedback are not necessarily easy to apply Smalltalk system. In addition, some message sends are unlikely to be optimized by static binding and inlining. According to Holzle et al. <ref> [8] </ref>, most message sends are grouped into three - monomorphic (only one receiver type), polymorphic (a few receiver types), and megamorphic (very many receiver types). An example of a megamor-phic message send is the one built of the printOn: selector.
Reference: [9] <author> Holzle, U and D. Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation pp. </booktitle> <pages> 146-180. </pages>
Reference-contexts: Type declaration [10] extends Smalltalk to specify types of variables and methods, while type annotation exploits type information specified in comments. Type prediction uses static profile, such as the message + is very likely to be sent to an Integer, while type feedback <ref> [9] </ref> recompiles methods from time to time, using type profile dynamically accumulated. Customization gets receiver types from the lookup routine, and splitting recovers type information by copying message sends upwards along control flow [4].
Reference: [10] <author> Johnson, R. E. et al. </author> <title> TS: An Optimizing Compiler for Smalltalk. </title> <booktitle> OOPSLA'88 Conference Proceedings pp. </booktitle> <pages> 18-26. </pages>
Reference-contexts: There have been proposed a variety of techniques following these lines, which differ from each other in how to obtain type information. Type inference performs data and control flow analysis [11] or solves a bunch of constraints involving type variables assigned to expressions [1]. Type declaration <ref> [10] </ref> extends Smalltalk to specify types of variables and methods, while type annotation exploits type information specified in comments.
Reference: [11] <author> Suzuki, N. </author> <title> Inferring Types in Smalltalk. </title> <booktitle> Proceeding of the 8th Symposium on the Principles of Programming Languages 1981, </booktitle> <pages> pp. 187-199. 12 </pages>
Reference-contexts: In short, static binding attempts to make the performance of Smalltalk closer to that of C. There have been proposed a variety of techniques following these lines, which differ from each other in how to obtain type information. Type inference performs data and control flow analysis <ref> [11] </ref> or solves a bunch of constraints involving type variables assigned to expressions [1]. Type declaration [10] extends Smalltalk to specify types of variables and methods, while type annotation exploits type information specified in comments.
References-found: 11

