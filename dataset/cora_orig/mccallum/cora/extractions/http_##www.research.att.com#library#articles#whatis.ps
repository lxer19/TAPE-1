URL: http://www.research.att.com/library/articles/whatis.ps
Refering-URL: http://www.research.att.com/library/articles/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: What is ``Object-Oriented Programming''? (1991 revised version)  
Author: Bjarne Stroustrup 
Address: Murray Hill, New Jersey 07974  
Affiliation: AT&T Bell Laboratories  
Abstract: Object-Oriented Programming'' and ``Data Abstraction'' have become very common terms. Unfortunately, few people agree on what they mean. I will offer informal definitions that appear to make sense in the context of languages like Ada, C ++ , Modula-2, Simula, and Smalltalk. The general idea is to equate ``support for data abstraction'' with the ability to define and use new types and equate ``support for object-oriented programming'' with the ability to express type hierarchies. Features necessary to support these programming styles in a general purpose programming language will be discussed. The presentation centers around C ++ but is not limited to facilities provided by that lan guage.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Birtwistle, Graham et.al.: </author> <title> SIMULA BEGIN. </title> <institution> Studentlitteratur, Lund, Sweden. 1971. Chartwell Bratt Ltd, UK. </institution> <year> 1980. </year>
Reference-contexts: There are many example to the contrary. The important issue is not so much what features a language possesses but that the features it does possess are sufficient to support the desired programming styles in the desired application areas: <ref> [1] </ref> All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be <p> In particular, the techniques for designing ``good procedures'' are now applied for each procedure in a module. The most common example is a defi nition of a stack module. The main problems that have to be solved are: <ref> [1] </ref> Provide a user interface for the stack (for example, functions push () and pop ()). [2] Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. [3] Ensure that the stack is initialized before its first use. <p> In languages such as C ++ and Simula, where static type checking is extensively used, the type system can be employed to select between different calling mechanisms. In C ++ , two alternatives are available: <ref> [1] </ref> A normal function call: the member function to be called is determined at compile time (through a lookup in the compiler's symbol tables) and called using the standard function call mechanism with an argument added to identify the object for which the function is called. <p> data abstraction are typically deficient in their support of object-oriented programming. - 19 - 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must <ref> [1] </ref> Run on traditional machines. [2] Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [2] <author> Dahl, O-J. and Hoare, </author> <title> C.A.R.: Hierarchical Program Structures. In Structured Programming. </title> <publisher> Academic Press 1972. </publisher>
Reference-contexts: The important issue is not so much what features a language possesses but that the features it does possess are sufficient to support the desired programming styles in the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. <ref> [2] </ref> It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that <p> The most common example is a defi nition of a stack module. The main problems that have to be solved are: [1] Provide a user interface for the stack (for example, functions push () and pop ()). <ref> [2] </ref> Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. [3] Ensure that the stack is initialized before its first use. <p> In this way, one can achieve the efficiency of a macro expansion without compromising the standard function semantics. This optimization is - 15 - equally valuable as a support for data abstraction. <ref> [2] </ref> A virtual function call: The function to be called depends on the type of the object for which it is called. This type cannot in general be determined until run time. <p> in their support of object-oriented programming. - 19 - 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. <ref> [2] </ref> Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [3] <author> Cargill, Tom A.: </author> <title> PI: A Case Study in Object-Oriented Programming. </title> <journal> SIGPLAN Notices, </journal> <month> November </month> <year> 1986, </year> <pages> pp 350-360. - 20 </pages> - 
Reference-contexts: features it does possess are sufficient to support the desired programming styles in the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. <ref> [3] </ref> There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that do not require it. [5] A user need only know about the subset of the language explicitly used to write a <p> The main problems that have to be solved are: [1] Provide a user interface for the stack (for example, functions push () and pop ()). [2] Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. <ref> [3] </ref> Ensure that the stack is initialized before its first use. <p> For attempts to explain what object-oriented programming is without recourse to specific programming language constructs see Nygaard [14] and Kerr [10]. For a case study in object-oriented programming see Cargill <ref> [3] </ref>. <p> In languages with weak static type checking a more elaborate mechanism must be employed. What is done in a language like Smalltalk is to store a list of the names of all member functions (methods) of a class so that they can be found at run time: <ref> [3] </ref> A method invocation: First the appropriate table of method names is found by examining the object pointed to by p. In this table (or set of tables) the string "f" is looked up to see if the object has an f (). <p> - 19 - 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. [2] Coexist with traditional operating systems. <ref> [3] </ref> Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [4] <author> C.C.I.T.T Study Group XI: </author> <title> CHILL User's Manual. </title> <journal> CHILL Bulletin no 1. </journal> <volume> vol 4. </volume> <month> March </month> <year> 1984. </year>
Reference-contexts: the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. <ref> [4] </ref> A feature should be such that its implementation does not impose significant overheads on programs that do not require it. [5] A user need only know about the subset of the language explicitly used to write a program. <p> language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. [2] Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. <ref> [4] </ref> Cope with every major application area. This implies that facilities must be available for effective numerical work (floating point arithmetic without overheads that would make Fortran appear attractive), and that facilities must be available for access to memory in a way that allows device drivers to be written.
Reference: [5] <author> Ellis, M.A and Stroustrup, B. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley 1990. </publisher>
Reference-contexts: It also appeared in the May 1988 issue of IEEE Software Magazine. This version has been revised to reflect the latest version of C ++ as described in The Annotated C ++ Reference Manual <ref> [5] </ref> approved by the ANSI C++ committee (X3J16) as the basis of formal standardization. Copyright (c) AT&T. - 2 - Examples will be presented in C ++ . <p> to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that do not require it. <ref> [5] </ref> A user need only know about the subset of the language explicitly used to write a program. The last two principles can be summarized as ``what you don't know won't hurt you.'' If there are any doubts about the usefulness of a feature it is better left out.
Reference: [6] <author> Goldberg, A. and Robson, D.: </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison Wesley 1983. </publisher>
Reference: [7] <author> Ichbiah, J.D. et.al.: </author> <title> Rationale for the Design of the Ada Programming Language. </title> <journal> SIGPLAN Notices, </journal> <month> June </month> <year> 1979. </year>
Reference: [8] <author> Kernighan, B.W. and Ritchie, </author> <title> D.M.: The C Programming Language. </title> <booktitle> Prentice-Hall 1978. 2nd Edition 1988. </booktitle>
Reference: [9] <author> Keene, Sonya E.: </author> <title> Object-Oriented Programming in COMMON LISP Addison-Wesley 1988. </title>
Reference: [10] <author> Kerr, Ron: </author> <title> Object-Based Programming: A Foundation for Reliable Software. </title> <booktitle> Proceedings of the 14th SIMULA Users' Conference. </booktitle> <month> August </month> <year> 1986, </year> <pages> pp 159-165. </pages> <note> An abbreviated version of this paper can be found under the title A Materialistic View of the Software ``Engineering'' Analogy in SIGPLAN Notices, </note> <month> March </month> <year> 1987, </year> <pages> pp 123-125. </pages>
Reference-contexts: For attempts to explain what object-oriented programming is without recourse to specific programming language constructs see Nygaard [14] and Kerr <ref> [10] </ref>. For a case study in object-oriented programming see Cargill [3].
Reference: [11] <author> Liskov, Barbara et. al.: </author> <title> Clu Reference Manual. </title> <address> MIT/LCS/TR-225, </address> <month> October </month> <year> 1979. </year>
Reference: [12] <author> Liskov, Barbara et. al.: </author> <title> Abstraction Mechanisms in Clu. </title> <journal> CACM vol 20, </journal> <volume> no 8, </volume> <month> August </month> <year> 1977, </year> <pages> pp 564-576. </pages>
Reference-contexts: Typically, object-oriented programming offers superior facilities for adding to a system without modifying existing code. In this case, however, data abstraction facilities provide a better solution. Iterators It has been claimed that a language supporting data abstraction must provide a way of defining control structures <ref> [12] </ref>. In particular, a mechanism that allows a user to define a loop over the elements of some type containing elements is often needed. This must be achieved without forcing a user to depend on details of the implementation of the user-defined type.
Reference: [13] <author> Milner, Robert: </author> <title> A Proposal for Standard ML. </title> <booktitle> ACM Symposium on Lisp and Functional Pro gramming. </booktitle> <year> 1984, </year> <pages> pp 184-197. </pages>
Reference: [14] <author> Nygaard, Kristen: </author> <title> Basic Concepts in Object Oriented Programming. </title> <journal> SIGPLAN Notices, </journal> <month> October </month> <year> 1986, </year> <pages> pp 128-132. </pages>
Reference-contexts: For attempts to explain what object-oriented programming is without recourse to specific programming language constructs see Nygaard <ref> [14] </ref> and Kerr [10]. For a case study in object-oriented programming see Cargill [3].
Reference: [15] <author> Rovner, Paul: </author> <title> Extending Modula-2 to Build Large, Integrated Systems. </title> <journal> IEEE Software, </journal> <volume> Vol. 3. No. 6. </volume> <month> November </month> <year> 1986, </year> <pages> pp 46-57. </pages>
Reference: [16] <author> Shopiro, Jonathan: </author> <title> Extending the C ++ Task System for Real-Time Applications. </title> <booktitle> Proc. USENIX C ++ Workshop, </booktitle> <address> Santa Fe, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: An iterator is a rather simple control structure. More general mechanisms can also be defined. For example, the C ++ standard library provides a co-routine class <ref> [16] </ref>. For many ``container'' types, such as vector, one can avoid introducing a separate iterator type by defining an iteration mechanism as part of the type itself.
Reference: [17] <institution> SIMULA Standards Group, </institution> <year> 1984: </year> <title> SIMULA Standard. ASU Secretariat, Simula a.s. Post Box 150 Refstad, </title> <type> 0513 Oslo 5, </type> <institution> Norway. </institution>
Reference: [18] <author> Snyder, Alan: </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <journal> SIG PLAN Notices, </journal> <month> November </month> <year> 1986, </year> <pages> pp 38-45. </pages>
Reference-contexts: This idea captures only part of the expressive power of inheritance, but it is strongly encouraged by languages where every member function is virtual (or a method). Given suitable controls of what is inherited (see Snyder <ref> [18] </ref> and Stroustrup [19]), class derivation can be a powerful tool for creating new types. Given a class, derivation can be used to add and/or subtract features. <p> Encapsulation issues increase dramatically in importance with the size of the program and with the number and geographical dispersion of its users. See Snyder <ref> [18] </ref> and Stroustrup [19] for more detailed discussions of language support for encapsulation. Implementation Issues The support needed for object-oriented programming is primarily provided by the run-time system and by the programming environment.
Reference: [19] <author> Stroustrup, Bjarne: </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> 2nd Edition 1991. </note>
Reference-contexts: This idea captures only part of the expressive power of inheritance, but it is strongly encouraged by languages where every member function is virtual (or a method). Given suitable controls of what is inherited (see Snyder [18] and Stroustrup <ref> [19] </ref>), class derivation can be a powerful tool for creating new types. Given a class, derivation can be used to add and/or subtract features. The relation of the resulting class to its base cannot always be completely described in terms of specialization; factoring may be a better term. <p> Encapsulation issues increase dramatically in importance with the size of the program and with the number and geographical dispersion of its users. See Snyder [18] and Stroustrup <ref> [19] </ref> for more detailed discussions of language support for encapsulation. Implementation Issues The support needed for object-oriented programming is primarily provided by the run-time system and by the programming environment.
Reference: [20] <author> Stroustrup, Bjarne: </author> <title> Multiple Inheritance for C ++ . Proceedings of the Spring'87 EUUG Confer ence. </title> <publisher> Helsinki, </publisher> <month> May </month> <year> 1987. </year>
Reference-contexts: This leads to either code replication or loss of flexibility - and typically both. In C ++ this example can be handled as shown above with to no significant overheads (in time or space) compared to single inheritance and without sacrificing static type checking <ref> [20] </ref>.
Reference: [21] <author> Stroustrup, Bjarne: </author> <title> The Evolution of C ++ : 1985-1989. </title> <booktitle> USENIX Computer Systems, </booktitle> <volume> Vol 2 No 3, </volume> <month> Summer </month> <year> 1989. </year>
Reference: [22] <author> Stroustrup, Bjarne: </author> <title> Possible Directions for C ++ : 1985-1987. </title> <booktitle> Proc. USENIX C ++ Workshop, </booktitle> <address> Santa Fe, </address> <month> November </month> <year> 1987. </year> <month> - 21 </month> - 
Reference: [23] <author> Weinreb, D. and Moon, D.: </author> <title> Lisp Machine Manual. Symbolics, </title> <publisher> Inc. </publisher> <year> 1981. </year>
Reference-contexts: Given this explanation it seems obvious that it might be useful to have a class B inherit from two base classes A1 and A2. This is called multiple inheritance <ref> [23] </ref>. A fairly standard example of the use of multiple inheritance would be to provide two library classes displayed and task for representing objects under the control of a display manager and co-routines under the control of a scheduler, respectively.
Reference: [24] <author> Wirth, Niklaus: </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference: [25] <author> Woodward, P.M. and Bond, S.G.: </author> <title> Algol 68-R Users Guide. </title> <address> Her Majesty's Stationery Office, London. </address> <year> 1974. </year>
References-found: 25

