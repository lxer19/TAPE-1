URL: ftp://ftp.cs.washington.edu/tr/PRE-1991/UW-CSE-90-09-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Extending The Mach External Pager Interface To Accommodate User-Level Page Replacement Policies  
Author: Dylan McNamee and Katherine Armstrong 
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: The Mach external pager interface allows applications to supply their own routines for moving pages to and from second-level store. Mach doesn't allow applications to choose their own page replacement policy, however. Some applications have access patterns that may make least recently used page replacement inappropriate. In this paper, we describe an extension to the external pager interface that allows the programmer to specify the page replacement policy as well as the backing storage for a region of virtual memory.
Abstract-found: 1
Intro-found: 1
Reference: [Baron et al. 89] <author> Robert V. Baron, David Black, William Bolosky, Jonathan Chew, Richard P. Draves, David B. Golub, Richard F. Rashid, Avadis Tevanian, Jr., and Michael Wayne Young. </author> <title> Mach Kernel Interface Manual Technical Report, </title> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> June </month> <year> 1989. </year>
Reference: [Denning 70] <author> P. J. Denning, </author> <title> Virtual Memory, </title> <journal> Computing Surveys, </journal> <volume> Volume 2, Number 3, </volume> <year> 1970. </year>
Reference-contexts: Clearly either extreme has major drawbacks. Providing information too 5 An adaptive paging policy can adjust to the memory needs of the application. An example is the working set model <ref> [Denning 70] </ref> of page replacement. Its goal is to reduce the thrashing that occurs when a task cannot acquire enough physical memory to run efficiently.
Reference: [Draves et al. 89] <author> Richard P. Draves, Michael B. Jones, Mary R. </author> <title> Thompson MIG The MACH Interface Generator Technical Report, </title> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: Communication between memory objects and the Mach kernel is through Mach RPC. RPC stubs are generated using the Mach Interface Generator (MIG) <ref> [Draves et al. 89] </ref>. This means that a memory object may be transparently connected to a remote kernel. Any number of tasks may map a particular memory object. Two tasks on the same machine may map the same portion of a memory object in order to share virtual memory.
Reference: [Eppinger 89] <author> Jeffrey L. Eppinger. </author> <title> Virtual Memory Management for Transaction Processing Systems. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1989. </year> <month> 8 </month>
Reference-contexts: Using user-level page replacement, an external pager could implement a strategy more appropriate for database accesses. As a final motivating example we discuss Camelot <ref> [Eppinger 89] </ref>, a transaction facility built on top of Mach using Mach's existing external pager interface. Transaction managers need to ensure that changes to virtual memory are also recorded on permanent storage. <p> A dirty hot page has a log of all updates to it since its last write. Paging out a hot page to disk erases the log for that page <ref> [Eppinger 89] </ref>. 2 them. With our extension to the Mach external memory management interface, Camelot could define an external pager that performed this action. Along with providing more modular system design, performance could be improved if a page replacement policy could be found that outperforms LRU in this setting.
Reference: [Forin et al. 89] <author> Alessandro Forin, Joseph Barrera, and Richard Sanzi. </author> <booktitle> The Shared Memory Server 1989 Winter USENIX Conference, </booktitle> <year> 1989. </year>
Reference: [Kearns & DeFazio 89] <author> John P. Kearns and Samuel DeFazio. </author> <title> Diversity in Database Reference Behavior Performance Evaluation Review. </title> <journal> Volume 17, </journal> <volume> Number 1, </volume> <year> 1989. </year>
Reference-contexts: Stonebraker [Stonebraker 81] has observed that database systems access pages in a manner that makes LRU replacement inappropriate. Locality, a concept upon which the LRU policy is based, tends not to be as strong in the access patterns of database applications <ref> [Kearns & DeFazio 89] </ref>. An implication of this observation is that recency of access may not be the appropriate reference property upon which to base a page replacement scheme for database applications. Using user-level page replacement, an external pager could implement a strategy more appropriate for database accesses.
Reference: [Levy & Eckhouse 88] <author> Henry M. Levy and Richard H. Eckhouse, Jr. </author> <title> Computer Programming and Archi tecture: The VAX. 2nd Ed. </title> <publisher> Digital Press, </publisher> <year> 1988. </year>
Reference: [Ousterhout 84] <author> John K. Ousterhout. </author> <title> Scheduling Techniques for Concurrent Systems Proc. </title> <booktitle> 3rd IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1984. </year>
Reference-contexts: Since then, most page replacement policies implemented by operating systems have been variants of LRU. Understanding how to structure and use memory efficiently in parallel and distributed environments is still very much a topic of research. Features such as coresident task forces <ref> [Ousterhout 84] </ref>, data replication, and coherence for distributed shared memory could be facilitated by extensions to the virtual memory system. Further, the growing gap between processor speeds and the speed of memory and I/O makes the choice of page replacement policy an important issue even in a uniprocessor environment.
Reference: [Peterson & Silberschatz 85] <author> James L. Peterson and Abraham Silberschatz. </author> <title> Operating System Concepts. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference: [Stonebraker 81] <author> Michael Stonebraker. </author> <booktitle> Operating System Support for Database Management Communi cations of the ACM. </booktitle> <volume> Volume 24, Number 7, </volume> <year> 1981. </year>
Reference-contexts: This policy is certainly preferable to LRU, which would have kept the garbage collected pages in longer, since they were more recently touched. Another application area that could make good use of the ability to choose its own page replacement strategy is databases. Stonebraker <ref> [Stonebraker 81] </ref> has observed that database systems access pages in a manner that makes LRU replacement inappropriate. Locality, a concept upon which the LRU policy is based, tends not to be as strong in the access patterns of database applications [Kearns & DeFazio 89].
Reference: [Tevanian et al. 87] <author> Avadis Tevanian, Richard Rashid, Michael W. Young, David B. Golub, Mary R. Thomp son, William Bolosky, Richard Sanzi. </author> <title> A Unix Interface for Shared Memory and Memory Mapped Files Under Mach Technical Report, </title> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> July </month> <year> 1987. </year>
Reference: [Young et al. 87] <author> Michael Young, Avadis Tevanian, Richard Rashid, David Golub, Jeffrey Eppinger, Jonathan Chew, William Bolosky, David Black, and Robert Baron. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System Proc. </title> <booktitle> 11th Symposium on Operating Systems Principles, </booktitle> <year> 1987. </year>
Reference-contexts: In order to prevent the number of log entries from growing without bound, Camelot must explicitly check for hot pages and periodically force Mach to flush 1 A memory object is an abstract object representing a collection of data bytes on which several operations (e.g. read, write) are defined <ref> [Young et al. 87] </ref>. Memory objects are discussed more fully in the next section. 2 A hot page is a page that is used (either written or read) frequently. A dirty hot page has a log of all updates to it since its last write.
Reference: [Young 89] <institution> Michael Young Exporting a User Interface to Memory Management from a Communication-Oriented Operating System. </institution> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1989. </year>
Reference-contexts: When the kernel removes dirty pages from memory, it makes requests of the external pagers responsible for those pages to write their contents to the appropriate backing store. 3 The terms external memory manager, external pager, and memory object all refer to a server implementing the external memory management interface <ref> [Young 89] </ref>. 3 The vm allocate call allocates a region of virtual memory backed by the default pager. Vm map maps an external memory object into a task's address space.
References-found: 13

