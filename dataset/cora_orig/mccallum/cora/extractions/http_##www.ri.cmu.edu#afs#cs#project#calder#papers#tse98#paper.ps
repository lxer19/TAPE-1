URL: http://www.ri.cmu.edu/afs/cs/project/calder/papers/tse98/paper.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/tinker/www/tse98.html
Root-URL: 
Title: Respectful Type Converters  
Author: Jeannette M. Wing and John Ockerbloom 
Date: May 7, 1998  
Address: Pittsburgh, PA 15213-3890  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: In converting an object of one type to another, we expect some of the original object's behavior to remain the same, and some to change. How can we state the relationship between the original object and converted object to characterize what information is preserved and what is lost after the conversion takes place? We answer this question by introducing the new relation, respects, and say that a type converter function C : A ! B respects a type T . We formally define respects in terms of the Liskov and Wing behavioral notion of subtyping; types A and B are subtypes of T . We explain in detail the applicability of respectful type converters in the context of the Typed Object Model (TOM) Conversion Service, built at Carnegie Mellon and used on a daily basis throughout the world. We also briefly discuss how our respects relation addresses a similar question in two other contexts: type evolution and interoperability.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Frank Bamberger, Peter Ford, and Jeannette M. Wing. </author> <title> Interoperability, </title> <booktitle> chapter C.8, </booktitle> <pages> pages 67-71. </pages> <publisher> Interuniversity Communications Council, Inc. </publisher> <address> (EDUCOM), </address> <year> 1994. </year>
Reference-contexts: (p) ^ 8i; j : Integer : g [i; j] = BLACK if gc (p [i; j]; gamma (p); ST DG) = BLACK WHITE otherwise Composing the abstractions functions, ff BM P M ffi ff P M P , we get a bitmap, b, for a given PNG image p: <ref> [1] </ref> 8i; j : Integer : b [i; j] = 8 : set if xmin (p) i xmax (p) ^ ymin (p) j ymax (p) ^ gc (p [i; j]; gamma (p); ST DG) 6= BLACK clear otherwise Composing the abstractions functions, ff BM P M ffi ff P M G <p> G , we get a bitmap, b, for a given GIF image C (p): [2] 8i; j : Integer : b [i; j] = set overlay (C (p)[i; j]) 6= BLACK clear otherwise By substituting the definition of overlay, given the definition of C above, we get that [2] = <ref> [1] </ref>. <p> The abstraction function ff: istr ! int is atoi, i.e., the standard C library function. The abstraction function fi: ibytes ! int is defined as follows for a given ibytes value b: b [0] + 256 fl b <ref> [1] </ref> + :::256 n1 fl b [n 1] where n is the number of bytes in b. Then fi 1 ffi ff is a conversion from istr to ibytes that respects int. <p> Our respects relation gives type evolution a correctness condition to satisfy because it is defined in terms of a type, not just the evolution (conversion) function. 6.2 Reuse for Interoperability At the heart of the interoperability problem <ref> [1] </ref> is resolving mismatches among heterogeneous components.
Reference: [2] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: The inclusion of pre- and post-conditions in the specification of a type's methods allows us to relate the behaviors of two different types; this is the main difference between the Liskov and Wing definition of subtyping and those that rely on just signature information (e.g., Cardelli <ref> [2] </ref>). For example, two methods with the same signature (e.g., addition and exponentiation for integers) may have dramatically different behavior. <p> xmin (p) i xmax (p) ^ ymin (p) j ymax (p) ^ gc (p [i; j]; gamma (p); ST DG) 6= BLACK clear otherwise Composing the abstractions functions, ff BM P M ffi ff P M G , we get a bitmap, b, for a given GIF image C (p): <ref> [2] </ref> 8i; j : Integer : b [i; j] = set overlay (C (p)[i; j]) 6= BLACK clear otherwise By substituting the definition of overlay, given the definition of C above, we get that [2] = [1]. <p> P M G , we get a bitmap, b, for a given GIF image C (p): <ref> [2] </ref> 8i; j : Integer : b [i; j] = set overlay (C (p)[i; j]) 6= BLACK clear otherwise By substituting the definition of overlay, given the definition of C above, we get that [2] = [1].
Reference: [3] <author> Stewart Clamen. </author> <title> Type evolution and instance adaptation. </title> <type> Technical Report CMU-CS-92-133R, </type> <institution> Carnegie Mellon Computer Science Department, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: respects relationship and we show how respectful type converters enable reuse in the context of interoperability. 6.1 Type Evolution In Clamen's survey on type evolution he states that object-oriented databases tend to rely on two adaptation strategies for handling the evolution of database schemas (which can be modeled as types) <ref> [3] </ref>. The first strategy converts instances from old types to new ones. The second strategy uses emulation to allow instances 15 of old types to be used through interfaces of both the new types and the old type. Respectful type converters play a role in both strategies.
Reference: [4] <author> S.J. Garland and J.V. Guttag. </author> <title> An overview of LP, the Larch Prover. </title> <booktitle> In Proceedings of the Third International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 137-151, </pages> <address> Chapel Hill, NC, </address> <month> April </month> <year> 1989. </year> <note> Lecture Notes in Computer Science 355. </note>
Reference-contexts: Since these specifications are formal we can do formal proofs, possibly with machine assistance like with the Larch Prover <ref> [4] </ref>, to show that a subtype relation holds [11]. The GIFImage Larch Shared Language trait and the invariant clause in the Larch interface type specification for GIF images together describe the set of values over which GIF image objects can range.
Reference: [5] <author> Daniel C. Halbert and Patrick D. O'Brien. </author> <title> Using types and inheritance in object-oriented programming. </title> <journal> IEEE Software, </journal> <volume> 4(5) </volume> <pages> 71-79, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: The behavior of the subtype methods is identical to that of the corresponding supertype methods and new methods (defined on the extra state) have no corresponding supertype method. For example, bordered windows, colored windows, and scrollable windows are all extended subtypes of 12 a more generic window type <ref> [5] </ref>. In their paper, Liskov and Wing call these extension subtypes since the subtype extends the supertype by providing additional state and correspondingly additional methods. Case 2.
Reference: [6] <author> C.A.R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(1) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: type. 5.1 Extending the Definition of Respects To extend our definition of respects to accommodate converters from concrete type to concrete type, we borrow from the programming language community: we use the very same abstraction function used to prove the correctness of data representations first introduced by Hoare in 1974 <ref> [6] </ref>. Let converter C : A conc ! B conc be defined on two concrete types A conc and B conc .
Reference: [7] <author> J.J. Horning, J.V. with S.J. Garland Guttag, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch : Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: (g; i; j) frame get frame (i: int) requires 1 i len (g) ensures result = g [i] bool is set (i, j: int) ensures result = (overlay (g; i; j) 6= BLACK) bool equal (a: GIF) ensures result = (a = g) end GIF in the style of Larch <ref> [7] </ref>, but we could just as easily have written informal specifications. Since these specifications are formal we can do formal proofs, possibly with machine assistance like with the Larch Prover [4], to show that a subtype relation holds [11].
Reference: [8] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In OOPSLA'87: Addendum to the Proceedings, </booktitle> <year> 1987. </year>
Reference-contexts: subtypes so that users will not encounter any surprises: No Surprises Requirement: Properties that users rely on to hold of an object of a type T should hold even if the object is actually a member of a subtype S of T . which guarantees Liskov's substitutability principle of subtypes <ref> [8] </ref>. 3 In their 1994 TOPLAS paper "A Behavioral Notion of Subtyping" Liskov and Wing [9] formalized this requirement in their definition of subtyping. The novel aspect of their subtype definition is the ability to handle mutable types.
Reference: [9] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: If the converter respects a type, then it preserves that type's observable behavior. This paper formalizes this novel notion of respectful type converters. Our particular formalization of respects exploits the subtype relationship that holds among types of objects. The Liskov and Wing notion of behavioral subtyping <ref> [9] </ref> conveniently characterizes semantic differences between types. If S is a subtype of T , users of T objects cannot perceive when objects of type S are substituted for T objects. <p> We first review in Section 2 how we specify types and determine when one type is a subtype of another, borrowing directly from Liskov and Wing's behavioral notion of subtyping <ref> [9] </ref>. In Section 3 we exploit this notion of subtyping to define the respects relation between a converter and a type. <p> rely on to hold of an object of a type T should hold even if the object is actually a member of a subtype S of T . which guarantees Liskov's substitutability principle of subtypes [8]. 3 In their 1994 TOPLAS paper "A Behavioral Notion of Subtyping" Liskov and Wing <ref> [9] </ref> formalized this requirement in their definition of subtyping. The novel aspect of their subtype definition is the ability to handle mutable types. In this paper, we present a simplified version of their definition since for all our applications we can ignore mutable objects. <p> Implementation problems that arise because of multiple inheritance are irrelevant; subtyping is a relationship between specifications, not implementations. we define the following abstraction function: 2 It is a simplification of Liskov and Wing's "constraint" rule definition, Fig. 4 of <ref> [9] </ref>, by omission of the constraint rule condition. 6 Definition of the subtype relation, &lt;: = hO ; S; M i is a subtype of t = hO t ; T; N i if there exists an abstraction function, ff : S ! T , and a renaming map, - : <p> To apply our ideas in practice, we typically identify some common supertype, even if it means defining a virtual supertype <ref> [9] </ref>, T , such that the use of these existing converters guarantee that T 's behavior is preserved. Thus we can provide stronger, formalizable guarantees to users of these off-the-shelf converters. Our TOM type hierarchy illustrates a real case of this scenario. There already exist zipfile2tarfile and tarfile2zipfile type converters.
Reference: [10] <author> John Ockerbloom. </author> <title> Mediating among diverse data formats. </title> <type> Technical Report CMU-CS-98-102, </type> <institution> Carnegie Mellon Computer Science Department, </institution> <address> Pittsburgh, PA, </address> <month> January </month> <year> 1998. </year> <type> Ph.D. thesis. </type>
Reference-contexts: Since the two bitmaps are the same, the converter C respects bitmap. 2 4 An Application: The TOM Conversion Service 4.1 Overview of TOM As part of his Ph.D. thesis, Ockerbloom (the second author) invented a Typed Object Model <ref> [10] </ref>, a data model involving objects, types, and their associated metadata. The thesis includes definitions and explanations of intersubstitutability, which is like our respects relation, though formulated differently.
Reference: [11] <author> Amy M. Zaremski. </author> <title> Signature and specification matching. </title> <type> Technical Report CS-CMU-96-103, </type> <institution> CMU Computer Science Department, </institution> <month> January </month> <year> 1996. </year> <type> Ph.D. thesis. 19 </type>
Reference-contexts: Since these specifications are formal we can do formal proofs, possibly with machine assistance like with the Larch Prover [4], to show that a subtype relation holds <ref> [11] </ref>. The GIFImage Larch Shared Language trait and the invariant clause in the Larch interface type specification for GIF images together describe the set of values over which GIF image objects can range. GIF images are sequences of frames where each frame is a bounded two-dimensional array of colors.
References-found: 11

