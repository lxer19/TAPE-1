URL: http://www.cs.clemson.edu/~ihcho/protocol/icm.ps.gz
Refering-URL: http://www.cs.clemson.edu/~ihcho/inter.html
Root-URL: http://www.cs.clemson.edu
Email: Email: fihcho, johnmcg@cs.clemson.edu  Email: lkrause@sps.com  
Title: Interoperable Software Modules  
Author: Il-Hyung Cho John D. McGregor Lee Krause 
Address: Clemson, SC 29634  122 Fourth Ave. Indialantic, FL 32903  
Affiliation: Department of Computer Science Clemson University  Software Productivity Solutions, Inc.  
Abstract: Interoperability is the ability of two or more software modules to communicate and cooperate with each other. The interoperability problem arises when software developers want to reuse legacy software systems, or when software systems are componentized and these components need to be connected in order to work together. The problem occurs in both heterogeneous (multi-lingual) and homogeneous environments. Software modules can be functions, objects, or components which consist of multiple functions or objects. In this paper we focus on the specification of software components in object oriented systems. Traditionally, interoperability checking is performed by signature matching between an invoking function and a function being invoked. Function level signature matching techniques are not sufficient for software components in object oriented systems since an object encapsulates a set of data and functions, and a component may contain more than one object. In this paper we first describe the interoperability problems of software modules both in the procedural and object oriented paradigms, and then review current approaches and compare them. Based on the review, we propose a new interoperable component model (ICM) that enhances software reusability and maintainability. 1 keywords: protocols, protocol analysis, protocol in
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan, </author> <title> "Formal Connectors," </title> <type> CMU Tech Report CMU-CS-94-115 </type>
Reference-contexts: It does not support inheritance, but delegation is being investigated to replace inheritance. 4.7 Formal Connectors The Formal Connector technique <ref> [1] </ref> is used at an architectural level in a software system. The main goal is to provide a complete theory of architectural descriptions which had been previously described informally by using boxes and lines.
Reference: [2] <author> D. Barrett, A. Kaplan and J. Wileden, </author> <title> "Automated Support for Seamless Interoperability in Polylingual Software Systems," </title> <booktitle> 4th Symposium on the Foundations of Software Engineering, </booktitle> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: As will be seen, some of the approaches discussed in this section consider only syntactic level interoperability, and others consider both syntactic and semantic levels of interoperability. In this section, we consider Zaremski and Wing's protocol specification approach [18], Polylith system [11, 12], PolySPIN <ref> [2] </ref>, CORBA IDL, and Soft ware Adaptor approach [16]. <p> Programmers are responsible for specifying the application structure in terms of MIL (Module Interconnection Language) which is similar to IDL (Interface Definition Language). Only procedural languages are supported by the Polylith system. 5 4.3 PolySPIN The main focus of PolySPIN (Support for Persistence, Interoperability and Naming in POLYlingual) system <ref> [2] </ref> is resolving interoperability problems arising in systems written in different programming languages without requiring the programmer to construct any additional specification. <p> Both operations return void, but the return type can be any other type. (Specifically, CORBA-defined primitive types or interface object types like foo. These types are also used in the parameter list.) A shortcoming, according to <ref> [2] </ref>, is seamless-ness. Like MIL, similar problems occur when a component changes. IDL only defines the interface of the service provider. Thus, the relationship is master/slave, or client/server. The interoperation is one way: from client to server.
Reference: [3] <author> J. Bos and C. Laffra, </author> <title> "PROCOL A Parallel Object Language with Protocols," </title> <booktitle> OOPSLA, </booktitle> <year> 1989. </year>
Reference-contexts: Once built, the adaptor will intercept the outgoing messages for a component and adjust the message to the incoming message of the other component. 4.6 PROCOL PROCOL (PROtocol-constrained Concurrent Object Language) is a concurrent object oriented language <ref> [3] </ref>. PROCOL defines a protocol within each object definition. The protocol constrains sequences of message communications, and controls access to methods of the object through guards. (A method is called an action in PROCOL.) An object definition consists of several parts.
Reference: [4] <author> L. Cardelli, </author> <title> "A semantics of multiple inheritance," </title> <journal> Info. and Computation, </journal> <month> 76 </month> <year> (1988) </year> <month> 138-164. </month>
Reference-contexts: A subtype object can be used anywhere its supertype object can be. Type checking using specification matching captures only a small part of what it means for a program to be correct; the same is true for the co-/contra-variance rules <ref> [4] </ref>. For example, both stacks and queues might have put and get methods. According to the signature matching technique and contra-variance rules, either can be a valid subtype of the other.
Reference: [5] <author> John Guttag and James Horning, </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The main purpose of their matching definition is for retrieval of software components from a library. They formally define Signature Matching using the Standard ML notation [14], and implement the matching techniques using Larch <ref> [5] </ref> for exact matches, and for various kinds of relaxed matches. An exact match does not require the same variable names, but requires that each variable has the same type.
Reference: [6] <author> R. Helm, I.M. Holland, and D. Gangopadhyay, </author> <title> "Contracts: Specifying Behavioral Compositions in Object-Oriented Systems," </title> <booktitle> OOPSLA, </booktitle> <year> 1990. </year>
Reference-contexts: This technique can be added into our model where the method signatures are listed in the interface. These conditions can be used for testing the functionality of interoperation. However, we don't attempt to specify the interface and protocol in every possible detail. Helm et. el. <ref> [6] </ref> suggest a form referred to as a Contract to specify behavioral compositions and the responsibilities on participating objects. A contract defines a set of communicating participants and their contractual obligations. Classes conforming to the contract can interact with each other. This is a lot like our approach.
Reference: [7] <author> JavaSoft, </author> <title> J avaBeans T M 1.0 API Specification, </title> <address> http://java.sun.com/beans. </address>
Reference-contexts: The third area can be built on top of the ICM specification and will be the subject of future research. Some of the working component models in the industry are CORBA IDL, Microsoft COM, and Jav-aBeans <ref> [7] </ref>. CORBA IDL was reviewed in this paper, but the other two were not because they follow the same profile as CORBA. All three models utilize an interface specification on the service module.
Reference: [8] <author> B.H. Liskov and J.M. </author> <title> Wing "A New Definition of the Subtype Relation," </title> <booktitle> Lecture Notes in Computer Science 707 Springer-Verlag, </booktitle> <year> 1993. </year>
Reference-contexts: Neither do they have a mechanism to check for a behavioral (or se mantic) mismatch nor component interoperability. 3 3.2 Behavioral Subtyping Signature matching is not sufficient to ensure a sub-typing relationship as shown by Liskov and Wing <ref> [8] </ref>. They cover a semantics of the subtype relation in object oriented languages and propose a behavioral notion of subtyping. A subtype object can be used anywhere its supertype object can be. <p> According to the signature matching technique and contra-variance rules, either can be a valid subtype of the other. However, a program written with the expectation that x is a stack, may not work correctly if x actually denotes a queue, and vice versa. Liskov and Wing <ref> [8] </ref> propose a stronger requirement that constrains the behavior of subtypes: Subtype Requirement: Let (x) be a property provable about objects x of type T. Then (y) should be true for objects y of type S where S is a subtype of T. <p> Specification matching goes a step beyond signature matching: it provides a behavior of its component. They use pre- and post-conditions for the specification, similar to pre- and post-conditions specified in <ref> [8] </ref>.
Reference: [9] <author> D.R. Musser and A. Saini, </author> <title> C++ Programming with the Standard Template Library, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [10] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification., </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Components written to IDL are portable across languages, operating systems, and networks. CORBA IDL <ref> [10] </ref> covers both procedural languages and object oriented languages. Following is a simple IDL example. interface foo - void operation1 (...); void operation2 (...); - A component which implements the foo interface has to provide an implementation of each operation.
Reference: [11] <author> J. Purtilo and J.M. Atlee, </author> <title> "Module Reuse by Interface Adaptation," </title> <journal> Software Practice and Experience, </journal> <volume> 21(6), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: As will be seen, some of the approaches discussed in this section consider only syntactic level interoperability, and others consider both syntactic and semantic levels of interoperability. In this section, we consider Zaremski and Wing's protocol specification approach [18], Polylith system <ref> [11, 12] </ref>, PolySPIN [2], CORBA IDL, and Soft ware Adaptor approach [16]. <p> As described in the Section 3.1, this technique provides both exact matching and relaxed matching. 4.2 Polylith In the Polylith interconnection system <ref> [11] </ref>, a language called NIMBLE is used to map the type mismatches between two interoperating modules written in the same language. An invoking module may not signature-match to an invoked module, but they may be functionally compatible.
Reference: [12] <author> J. Purtilo, </author> <title> "The Polylith software bus," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1), </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: As will be seen, some of the approaches discussed in this section consider only syntactic level interoperability, and others consider both syntactic and semantic levels of interoperability. In this section, we consider Zaremski and Wing's protocol specification approach [18], Polylith system <ref> [11, 12] </ref>, PolySPIN [2], CORBA IDL, and Soft ware Adaptor approach [16]. <p> Thus, two syntactically matching software modules may not be able to interoperate, i.e., may give a run time error, if they are not semantically compatible aspecification/protocol mismatch, according to [18]. To work within a multi-language environment, the software bus <ref> [12] </ref> technique was introduced to interconnect software components written in different programming languages. Heterogeneity in language is accommodated since program units are prepared to interface directly to the bus, not to other program units. The software bus is responsible for message delivery and resolving mismatch.
Reference: [13] <author> SPS, </author> <title> Domain Oriented Software Analysis and Engineering Environment, </title> <address> www.sps.com/ company/techfocus/modeling/dosaee.html. </address>
Reference: [14] <author> Jeffrey D. Ullman, </author> <title> Elements of ML Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The same matching techniques used for primitive functions are applied repetitively to test the compatibility of two components. The main purpose of their matching definition is for retrieval of software components from a library. They formally define Signature Matching using the Standard ML notation <ref> [14] </ref>, and implement the matching techniques using Larch [5] for exact matches, and for various kinds of relaxed matches. An exact match does not require the same variable names, but requires that each variable has the same type.
Reference: [15] <institution> Rational Software Corporation, </institution> <note> UML Semantics, http://www.rational.com/uml/semantics/. </note>
Reference-contexts: We will focus on the protocol specification syntax in the interest of space. The protocol specification is a constrained form of an interaction, as defined in the UML meta-model <ref> [15] </ref>. In the UML meta-model, an interaction contains a set of messages specifying the communication between a set of instances. A protocol is more constrained in the sense that it contains a set of messages between exactly two instances.
Reference: [16] <author> D. Yellin, and R. Strom, </author> <title> "Interfaces, Protocols, and Semi-Automatic Construction of Software Adaptors," </title> <booktitle> OOPSLA, </booktitle> <year> 1994. </year>
Reference-contexts: In this section, we consider Zaremski and Wing's protocol specification approach [18], Polylith system [11, 12], PolySPIN [2], CORBA IDL, and Soft ware Adaptor approach <ref> [16] </ref>. <p> The interoperation is one way: from client to server. Server only returns results to the client, but there is no information specified in server IDL for the server to invoke methods of the 6 client. Also, there is no message sequence informa-tion. In <ref> [16] </ref>, Yellin and Strom argue that this is not a true sense of interoperation. 4.5 Software Adaptor As with CORBA IDL, this work concerns component level programming: how well will two software components work together if connected? If two components match perfectly, they can be simply connected together without any additional <p> For two components with functionally compatible but type incompatible interfaces, Yellin and Strom <ref> [16] </ref> present Software Adaptor as a bridge between the components. An adaptor is a piece of code that compensates for the differences between their interfaces: different message and parameter names, different parameter orders, and even different numbers of states. <p> To be symmetric and to support encapsulation of its implementation, the Receiver has to exercise access control on its methods. This issue has been raised by Yellin and Strom in <ref> [16] </ref> | having the specification on the service module only does not support the true sense of interoperability. The interface specification of an OO system has to be provided for both the sender and receiver sides.
Reference: [17] <author> A.M. Zaremski and J.M. Wing, </author> <title> "Signature Matching: A Key to Reuse," </title> <booktitle> Proc. ACM SIG-SOFT Symp. on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Once the module is identified, it can be checked for compatibility with other components that have already been selected. In this section we survey a number of techniques for determining whether two components are type compatible. 3.1 Signature Matching Zaremski and Wing <ref> [17] </ref> implemented a signature matching technique for software modules. The signature of a function is simply its type; however, the signature of a component is a multiset of user-defined types and a multiset of function signatures.
Reference: [18] <author> A.M. Zaremski and J.M. Wing, </author> <title> "Specification Matching of Software Components," </title> <booktitle> Proc. ACM SIGSOFT Symp. on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1995. </year> <month> 13 </month>
Reference-contexts: To be reused, a module has to provide behaviors that are needed in the new application environment. In other words, the module must "match" the other modules with which it will interact. There are a number of definitions of "match" in the literature. In <ref> [18] </ref>, a number of issues have been raised regarding software reuse: retrieval, reuse, substitution, subtype, and interoperation. In retrieval, we want to retrieve a component from a software library that satisfies a given query. <p> In interoper-ation, we want one component to interact properly with the other <ref> [18] </ref>. All these issues are related; however, in this paper, we will focus on interoperation. The simplest, and possibly original, technique for organizing reusable software modules is a subroutine library (e.g., a function library in C). <p> The behavioral subtyping requirement is satisfied by specifying the type of objects with not only the type's name and signatures, but its method's behavior in terms of pre-and post- conditions. 3.3 Specification Matching In <ref> [18] </ref>, Zaremski and Wing extended their earlier work by proposing a specification matching scheme. Specification matching is a way of comparing two software components. In object oriented programming, it can help determine when one type is a behavioral subtype of another. <p> As will be seen, some of the approaches discussed in this section consider only syntactic level interoperability, and others consider both syntactic and semantic levels of interoperability. In this section, we consider Zaremski and Wing's protocol specification approach <ref> [18] </ref>, Polylith system [11, 12], PolySPIN [2], CORBA IDL, and Soft ware Adaptor approach [16]. <p> component be specified so that it can interoperate to the other? * How can we identify a module with which we 4 want our application to interoperate? * How can we make one module interoperate with the other if they are not compatible? 4.1 Specification Matching Protocol Zaremski and Wing <ref> [18] </ref> recognize that signature matching and pre-/post-condition is not enough to check for components interoperability. Consider that components C and S communicate via a communication channel. Their specifications are an exact match. <p> To specify the message sequences, <ref> [18] </ref> adds a protocol specification to a component's interface specification, adding a match protocol predicate to the definition of Interop-erates as follows: Interoperates: Component, Component ! Bool Interoperates (C; C 0 ) = M atch (C; C 0 ) ^ match protocol (C protocol ; C 0 protocol ) In the <p> Thus, two syntactically matching software modules may not be able to interoperate, i.e., may give a run time error, if they are not semantically compatible aspecification/protocol mismatch, according to <ref> [18] </ref>. To work within a multi-language environment, the software bus [12] technique was introduced to interconnect software components written in different programming languages. Heterogeneity in language is accommodated since program units are prepared to interface directly to the bus, not to other program units.
References-found: 18

