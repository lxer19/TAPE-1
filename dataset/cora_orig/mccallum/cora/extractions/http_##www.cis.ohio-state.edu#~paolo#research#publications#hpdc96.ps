URL: http://www.cis.ohio-state.edu/~paolo/research/publications/hpdc96.ps
Refering-URL: http://www.cis.ohio-state.edu/~paolo/research/
Root-URL: http://www.cis.ohio-state.edu
Email: fadam,mani,paolog@cs.caltech.edu  
Title: A World-Wide Distributed System Using Java and the Internet  
Author: K. Mani Chandy, Adam Rifkin, Paolo A.G. Sivilotti, Jacob Mandelson, Matthew Richardson, Wesley Tanaka, and Luke Weisman 
Keyword: Key words: Distributed systems, collaborative environments, program composition, distributed objects, multithreaded objects, World Wide Web, Java.  
Web: http://www.cs.caltech.edu/adam/CALTECH/infospheres.html  
Address: Pasadena, California 91125  
Affiliation: Computer Science Department 256-80 California Institute of Technology  
Abstract: This paper describes the design of a distributed system built using Java that supports peer-to-peer communication among processes spread across a network. We identify the requirements of a software layer that supports distributed computing, and we propose a design that meets those requirements. Our primary concerns are (1) the identification, specification, and implementation of software components that can be composed in different ways to develop correct distributed applications; (2) reasoning about the components systematically; and (3) providing services to the components. This paper deals with the last of these concerns. Though our implementation uses Java, the fundamental ideas apply to any object-oriented language that supports messaging and threads. Alternative implementations use such languages coupled with object request brokers or remote procedure invocation mechanisms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Birrell. </author> <title> An introduction to programming with threads. </title> <type> Technical Report Report 35, </type> <institution> Digital Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2. Overall Distributed System Design Our distributed system implementation is written in the Java language [7], and uses Java socket classes [8] and thread primitives (like the ones described in <ref> [1] </ref>). The initial implementation uses UDP [13, 15], and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for develop-ing distributed applications.
Reference: [2] <author> K. Chandy and C. Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation. In Research Directions in Concurrent Object-Oriented Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Communication Features. Our simple communication layer, when used with objects and threads, can provide features present in more complex systems. Some languages, such as CC++ <ref> [2] </ref>, have a two-level hierarchy of address spaces: a global address space and a collection of local address spaces. So, pointers are of two kinds: global and local. A global pointer in one local address space can point to an object in any local address space.
Reference: [3] <author> K. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining the global states of distributed systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> Feb </month> <year> 1985. </year>
Reference-contexts: The problem is that dapplets do not share a global clock. Though local clocks are quite accurate they are not perfectly synchronized. We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion <ref> [3] </ref>. The global snapshot criterion is satisfied, provided every message that is sent when the sender's clock is T , is received when the receiver's clock exceeds T .
Reference: [4] <author> K. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: Research issues for the two classes of distributed systems are somewhat different. The former class of distributed systems, the class on which human lives depend, is extremely important and has benefited from a great deal of research (c.f., the surveys of critical distributed systems issues in <ref> [4, 10] </ref>). This paper, however, deals with facilitating the development of the latter class of applications. The class of collaborative Web-based applications has interesting engineering challenges that differ from those in traditional distributed applications, Structuring Collaborative Applications: Compositional Units. <p> A consortium of institutions forms a research center, and the executive committee of the center has members from its component institutions. The director of the center wants to pick a date and place for a meeting of the executive committee. Several algorithms (c.f., <ref> [4, 10] </ref>) can be used to solve this problem. The traditional approach has one individual call each member of the committee repeatedly, and negotiate with each one in turn until an agreement is reached.
Reference: [5] <author> K. Chandy and A. Rifkin. </author> <title> Systematic composition of objects in distributed internet applications: </title> <booktitle> Processes and sessions. In Submission to 30th Hawaii International Conference on System Sciences, </booktitle> <month> Jan. </month> <year> 1997. </year> <note> Also available as Caltech Computer Science Tech Report 96-15. </note>
Reference-contexts: This work constitutes part of the Caltech Infospheres Project; more in formation is available in <ref> [5] </ref> and in the Web page http://www.cs.caltech.edu/adam/CALTECH/infospheres.html
Reference: [6] <author> K. Chandy and E. Schooler. </author> <title> Designing directories in distributed systems: A systematic framework. </title> <booktitle> In Proceedings of the Fifth Workshop on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: Other Services Previous subsections have described some session services we would like to provide for dapplets: tokens, logical clocks, and synchronization mechanisms. Other servlets we might want to consider include incorporation of directory services <ref> [6] </ref> (e.g., for finding mobile dapplets), distributed data structures (e.g., for diffusing computations), and stacked layering of groups of dapplets (e.g., for creating a resource-allocation layer). 5.
Reference: [7] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley Developers Press, Sun-soft Java Series, </publisher> <year> 1996. </year>
Reference-contexts: We postpone consideration of which actions the initiator could take if a session cannot be established. When a session terminates, component dapplets unlink themselves from each other. 3.2. Overall Distributed System Design Our distributed system implementation is written in the Java language <ref> [7] </ref>, and uses Java socket classes [8] and thread primitives (like the ones described in [1]). The initial implementation uses UDP [13, 15], and it includes a layer to ensure that messages are delivered in the order they were sent.
Reference: [8] <author> J. Gosling, F. Yellin, </author> <title> and the Java Team. The Java Application Programming Interface. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: We postpone consideration of which actions the initiator could take if a session cannot be established. When a session terminates, component dapplets unlink themselves from each other. 3.2. Overall Distributed System Design Our distributed system implementation is written in the Java language [7], and uses Java socket classes <ref> [8] </ref> and thread primitives (like the ones described in [1]). The initial implementation uses UDP [13, 15], and it includes a layer to ensure that messages are delivered in the order they were sent. <p> Dapplet designers can separate the generic concerns of clock synchronization from other concerns specific to their application. 4.3. Synchronization Constructs Java provides constructs for synchronizing threads within a dapplet using something like a monitor <ref> [8] </ref>. We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a dapplet [14]. We are extending these designs to allow synchronizations between threads in different dapplets in different address spaces. 4.4.
Reference: [9] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> Jul </month> <year> 1978. </year>
Reference-contexts: We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion [3]. The global snapshot criterion is satisfied, provided every message that is sent when the sender's clock is T , is received when the receiver's clock exceeds T . A simple algorithm <ref> [9] </ref> to establish this criterion is: every message is timestamped with the sender's clock; upon receiving a message, if the receiver's clock value does not exceed the timestamp of the message, then the receiver's clock is set to a value greater than the timestamp.
Reference: [10] <author> N. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference-contexts: Research issues for the two classes of distributed systems are somewhat different. The former class of distributed systems, the class on which human lives depend, is extremely important and has benefited from a great deal of research (c.f., the surveys of critical distributed systems issues in <ref> [4, 10] </ref>). This paper, however, deals with facilitating the development of the latter class of applications. The class of collaborative Web-based applications has interesting engineering challenges that differ from those in traditional distributed applications, Structuring Collaborative Applications: Compositional Units. <p> A consortium of institutions forms a research center, and the executive committee of the center has members from its component institutions. The director of the center wants to pick a date and place for a meeting of the executive committee. Several algorithms (c.f., <ref> [4, 10] </ref>) can be used to solve this problem. The traditional approach has one individual call each member of the committee repeatedly, and negotiate with each one in turn until an agreement is reached.
Reference: [11] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA). OMG, </title> <booktitle> 1995. Revision 2.0. </booktitle>
Reference-contexts: Alternate Implementation Platforms Although our vision for support of distributed systems is presented here in the context of Java, the ideas proposed are consistent with other platforms, such as CORBA-compliant Object Request Brokers <ref> [11] </ref>. These platforms are well suited for client-server applications, but designing and building peer-to-peer distributed object computations is relatively difficult. Nevertheless, we anticipate a proliferation of such sys-tems for the reasons outlined in Section 1.
Reference: [12] <editor> Object Management Group and World Wide Web Consortium. </editor> <booktitle> Proceedings of the Workshop on Distributed Objects and Mobile Code. </booktitle> <address> OMG/W3C, Boston, MA, </address> <month> Jun </month> <year> 1996. </year>
Reference-contexts: This interface definition provides a convenient framework in which to specify servlet behavior. Many other research groups are presently working on distributed systems in which distributed (and possibly mobile) objects interact over the Internet <ref> [12] </ref>; our focus, by contrast, is on specifying, building, and reasoning the compositional units. 6. Summary This paper identifies a class of distributed systems that is different from the traditional variety, and gives an analysis of the requirements of such systems.
Reference: [13] <author> J. Postel. </author> <title> User Datagram Protocol. </title> <type> RFC 768, </type> <month> Aug </month> <year> 1980. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2. Overall Distributed System Design Our distributed system implementation is written in the Java language [7], and uses Java socket classes [8] and thread primitives (like the ones described in [1]). The initial implementation uses UDP <ref> [13, 15] </ref>, and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for develop-ing distributed applications.
Reference: [14] <author> P. Sivilotti and K. Chandy. </author> <title> Toward high confidence distributed programming with java: Reliable thread libraries. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <address> Las Vegas, NV, </address> <month> Jul </month> <year> 1996. </year>
Reference-contexts: We focus our discussion here on inter-dapplet services. Methods for coordination within a dapplet use standard Java classes <ref> [14] </ref>. The questions we address are: How can objects associated with a service be bound into a dapplet in a straightforward way, and, what sorts of services are helpful for dapplet designers? There are complementary ways of providing services to dapplets. <p> Synchronization Constructs Java provides constructs for synchronizing threads within a dapplet using something like a monitor [8]. We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a dapplet <ref> [14] </ref>. We are extending these designs to allow synchronizations between threads in different dapplets in different address spaces. 4.4. Other Services Previous subsections have described some session services we would like to provide for dapplets: tokens, logical clocks, and synchronization mechanisms.
Reference: [15] <author> W. Stevens. </author> <title> Unix Network Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2. Overall Distributed System Design Our distributed system implementation is written in the Java language [7], and uses Java socket classes [8] and thread primitives (like the ones described in [1]). The initial implementation uses UDP <ref> [13, 15] </ref>, and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for develop-ing distributed applications.
Reference: [16] <author> A. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year>
Reference-contexts: Composition of Services. Traditional distributed systems (e.g., systems described in <ref> [16] </ref>) are architected in a series of well-defined layers, with each layer providing services to the layer above it and using services of the layer below. <p> Our focus in this paper is on the former approach; we give a few examples of service objects and show how these services can be used within a dapplet. 4.1. Tokens and Capabilities Distributed operating systems manage indivisible resources shared by processes <ref> [16] </ref>; we would like to provide service objects with this functionality, which a dapplet designer can incorporate as needed. A problem is that generic service objects do not have information about the specific resources used in a given application. A solution is to treat indivisible resources in a generic way.
References-found: 16

