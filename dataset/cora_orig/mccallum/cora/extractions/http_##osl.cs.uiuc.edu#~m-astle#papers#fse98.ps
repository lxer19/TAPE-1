URL: http://osl.cs.uiuc.edu/~m-astle/papers/fse98.ps
Refering-URL: http://osl.cs.uiuc.edu/~m-astle/
Root-URL: http://www.cs.uiuc.edu
Email: fastley, aghag@cs.uiuc.edu  
Title: Customization and Composition of Distributed Objects: Middleware Abstractions for Policy Management  
Author: Mark Astley and Gul A. Agha 
Address: 1304 W. Springfield, Urbana, IL, 61801, USA  
Affiliation: Department of Computer Science Univ. of Illinois at Urbana-Champaign  
Abstract: Current middleware solutions such as CORBA and Java's RMI emphasize compositional design by separating functional aspects of a system (e.g. objects) from the mechanisms used for interaction (e.g. remote procedure call through stubs and skeletons). While this is an effective solution for handling distributed interactions, higher-level requirements such as heterogeneity, availability, and adaptability require policies for resource management as well as interaction. We describe the Distributed Connection Language (dcl): an architecture description language based on the Actor model of distributed objects. System components and the policies which govern an architecture are specified as encapsulated groups of actors. Composition operators are used to build connections between components as well as customize their behavior. This customization is realized using a meta-architecture. We describe the syntax and semantics of dcl, and illustrate the language by way of several examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agha, G. </author> <title> Actors: A Model of Concurrent Computation. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: We then describe customization of modules and protocols using architectural policies in Section 3. Finally, in Section 4, we summarize our results and discuss topics for future research. 1.1 Actors We use Actors <ref> [1] </ref> as a basis for modeling distributed software architectures. Actors provide a general and flexible model of concurrency. As an atomic unit of computation, actors may be used to build typical architectural elements including procedural, functional, and object-oriented components.
Reference: [2] <author> Agha, G., Frtlund, S., Kim, W., Panwar, R., Pat-terson, A., and Sturman, D. </author> <title> Abstraction and modularity mechanisms for concurrent computing. </title> <journal> IEEE Parallel and Distributed Technology (May 1993). </journal>
Reference-contexts: As an atomic unit of computation, actors may be used to build typical architectural elements including procedural, functional, and object-oriented components. Moreover, actor interactions may be used to model standard distributed coordination mechanisms such as remote procedure call (RPC), transactions, and other forms of synchronization <ref> [2] </ref>. Conceptually, an actor encapsulates a state, a thread of control, and a set of procedures which manipulate the state. Actors coordinate by asynchronously sending messages to one another. Each actor has a unique mail address and a mail buffer to receive messages.
Reference: [3] <author> Allen, R., and Garlan, D. </author> <title> Formalizing architectural connection. </title> <booktitle> In International Conference on Software Engineering (ICSE '94) (1994), IEEE Computer Society, </booktitle> <pages> pp. 71-80. </pages>
Reference-contexts: In many instances, this mechanism may be used to incorporate legacy software into dcl architectures. 1.2 Related Work Recently, several architecture description languages have been proposed in the literature. Of these languages, Rapide [8] and Wright <ref> [3] </ref> are useful representatives due to their formal nature and the scope of their specifications. We describe Rapide and Wright here, and refer the reader to [5] for an interesting survey of architecture description languages in general. Rapide is an object-oriented language designed for event-based prototyping of distributed software architectures.
Reference: [4] <author> Astley, M. </author> <title> An actor semantics for component-based software. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> March </month> <year> 1998. </year> <note> Available at http://osl.cs.uiuc.edu/~m-astle. </note>
Reference-contexts: If one group represents a module while the other represents a policy, then the interaction semantics may be used to verify conformance to an interface. Likewise, interaction semantics may be used to verify non-interference between a collection of policies. The interested reader is referred to <ref> [4] </ref> for a complete description of the semantics. We are in the final stages of completing a prototype implementation which compiles dcl specifications into executable systems. Our prototype outputs a system of actors based on a literal interpretation of a dcl specification.
Reference: [5] <author> Clements, P. C. </author> <title> A survey of architecture description languages. </title> <booktitle> In Eighth International Workshop on Software Specification and Design (Paderborn, </booktitle> <address> Germany, </address> <month> March </month> <year> 1996). </year>
Reference-contexts: Of these languages, Rapide [8] and Wright [3] are useful representatives due to their formal nature and the scope of their specifications. We describe Rapide and Wright here, and refer the reader to <ref> [5] </ref> for an interesting survey of architecture description languages in general. Rapide is an object-oriented language designed for event-based prototyping of distributed software architectures. A Rapide architecture contains a set of module specifications called interfaces which define a collection of named entry points.
Reference: [6] <author> Hoare, C. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM 21, </journal> <month> 8 (August </month> <year> 1978), </year> <pages> 666-677. </pages>
Reference-contexts: This represents the simplest form of connection policy between two modules: that implied by their respective local constraints. In contrast, the Wright language defines architectural structure in terms of extensions to Communicating Sequential Processes (CSP) <ref> [6] </ref>. A Wright architecture consists of an interlinked set of components and connectors. Wright components are specified by an interface and a computation. An interface describes a fixed set of ports and their behavior. A computation describes component behavior in terms of interactions triggered at ports.
Reference: [7] <author> Hutchinson, N. C., and Peterson, L. L. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering 17, </journal> <month> 1 (January </month> <year> 1991), </year> <pages> 64-75. </pages>
Reference-contexts: Although we believe our approach to be novel in the realm of architecture description languages, our abstractions for meta-architecture and composition are similar to techniques for protocol development in systems such as the x-Kernel <ref> [7] </ref> and Horus [16]. In particular, our methods for protocol composition are essentially protocol stacks as modeled in these systems.
Reference: [8] <author> Luckham, D. C., Kenney, J. J., Augustin, L. M., Vera, J., Bryan, D., and Mann, W. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering 21, </journal> <volume> 4 (1995), </volume> <pages> 336-355. </pages> <note> Special Issue on Software Architecture. </note>
Reference-contexts: Note that modern sequential languages are readily extended with the actor primitives (c.f. [15]). In many instances, this mechanism may be used to incorporate legacy software into dcl architectures. 1.2 Related Work Recently, several architecture description languages have been proposed in the literature. Of these languages, Rapide <ref> [8] </ref> and Wright [3] are useful representatives due to their formal nature and the scope of their specifications. We describe Rapide and Wright here, and refer the reader to [5] for an interesting survey of architecture description languages in general.
Reference: [9] <author> Object Management Group. </author> <title> CORBA services: Common object services specification version 2. </title> <type> Tech. rep., </type> <institution> Object Management Group, </institution> <month> June </month> <year> 1997. </year> <note> Available at http://www.omg.org/corba. </note>
Reference-contexts: 1 Introduction The complexity of modern distributed systems has lead to an emphasis on compositional system development. For example, middleware solutions such as the Common Object Request Broker Architecture (CORBA) <ref> [9] </ref> and Java's Remote Method Invocation (RMI) [14] have incorporated compositional design by separating functional aspects of a system (e.g. objects) from the mechanisms used for interconnection (e.g. remote procedure call through stubs and skeletons). Separating objects from the policies which govern their interaction simplifies debugging and makes reuse feasible.
Reference: [10] <author> Shaw, M., DeLine, R., Klein, D. V., Ross, T. L., Young, D. M., and Zelesnik, G. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering (April 1995). </journal>
Reference-contexts: To verify correctness and reason about composability, researchers have introduced the notion of architecture description languages (ADLs). An ADL specification defines a software architecture in terms of a collection of components, which encapsulate computation, and a collection of connectors, which describe how components are integrated into the architecture <ref> [10] </ref>. Current ADLs emphasize modular specification of components and their interaction. While this emphasis has demonstrated advantages for system development, in general, distributed systems entail more complicated behavior. In particular, heterogeneity, failure, and the potential for open (i.e. unpredictable) interactions yield evolving systems which require complex management policies.
Reference: [11] <author> Sturman, D. C. </author> <title> Modular Specification of Interaction Policies in Distributed Computing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Separating objects from the policies which govern their interaction simplifies debugging and makes reuse feasible. In particular, the protocols required for interaction need not be hard-coded in objects <ref> [11] </ref>. This allows objects and protocols to be independently tested and later composed into runnable systems. Moreover, as requirements change, existing architectural elements may be modularly replaced by new elements with appropriate properties.
Reference: [12] <author> Talcott, C. </author> <title> An actor rewriting theory. </title> <booktitle> In Workshop on Rewriting Logic (1996), vol. 4 of Electronic Notes in Theoretical Computer Science. </booktitle>
Reference-contexts: Policies are composed by composing policy actors. We have provided a high-level description of the semantics of dcl abstractions. A more complete semantics is based on a concurrent rewriting extension of actor semantics <ref> [12] </ref>. In particular, we extend this semantics by adding the notion of an actor group, which represents an encapsulated collection of actors. Composition such as that defined by the connection of protocols to modules is supported by allowing actor groups to overlap and exchange messages.
Reference: [13] <author> Talcott, C. </author> <title> Interaction semantics for components of distributed systems. </title> <booktitle> In First IFIP workshop on Formal Methods for Open Object-based Distributed Systems (FMOODS '96) (Paris, </booktitle> <address> France, </address> <month> March </month> <year> 1996). </year>
Reference-contexts: Similarly, the composition of policies on other dcl elements is supported by allowing actor groups to exchange signals and notifications. The interactions between two groups defines an interaction semantics <ref> [13] </ref> which may be used to determine if two groups are compatible. If one group represents a module while the other represents a policy, then the interaction semantics may be used to verify conformance to an interface.
Reference: [14] <author> The Java Team. </author> <title> RMI specification. </title> <note> Available at ftp://ftp.javasoft.com/docs/jdk1.1/rmi-spec.ps. </note>
Reference-contexts: 1 Introduction The complexity of modern distributed systems has lead to an emphasis on compositional system development. For example, middleware solutions such as the Common Object Request Broker Architecture (CORBA) [9] and Java's Remote Method Invocation (RMI) <ref> [14] </ref> have incorporated compositional design by separating functional aspects of a system (e.g. objects) from the mechanisms used for interconnection (e.g. remote procedure call through stubs and skeletons). Separating objects from the policies which govern their interaction simplifies debugging and makes reuse feasible.
Reference: [15] <author> Tomlinson, C., Cannata, P., Meredith, G., and Woelk, D. </author> <title> The extensible services switch in Carnot. </title> <booktitle> IEEE Parallel and Distributed Technology 1, </booktitle> <month> 2 (May </month> <year> 1993), </year> <pages> 16-20. </pages> <note> [16] van Renesse, </note> <author> R., Birman, K. P., Friedman, R., Hayden, M., and Karr, D. A. </author> <title> A framework for protocol composition in horus. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing (August 1995). </booktitle> <pages> 9 </pages>
Reference-contexts: Upon invoking ready, the calling actor either begins processing the next available message, or blocks until a new message arrives. Note that modern sequential languages are readily extended with the actor primitives (c.f. <ref> [15] </ref>). In many instances, this mechanism may be used to incorporate legacy software into dcl architectures. 1.2 Related Work Recently, several architecture description languages have been proposed in the literature.
References-found: 15

