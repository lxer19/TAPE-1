URL: ftp://ftp.cs.umd.edu/pub/realtime/rtoss93-TCEL.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: sshong@cs.umd.edu rich@cs.umd.edu  
Title: Scheduling with Compiler Transformations: The TCEL Approach  
Author: Seongsoo Hong and Richard Gerber 
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Date: 80-84, May 1993  
Note: In Proc. of IEEE Workshop on Real-Time Operating Systems and Software, pp.  
Abstract: We present TCEL (Time-Constrained Event Language), which possesses first-class timing constructs, and whose semantics is based on time-constrained relationships between observable events. Since the only timing constraints are imposed by observable events, the unobservable code can be automatically moved to achieve consistency between the program's worst-case execution time and its real-time requirements. Based on our initial success in applying compiler transformations to sequential programs, we present a task transformation technique for control domain applications driven by rate monotonic scheduling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ron Cytron, Andy Lowry, and Kenneth Zadeck. </author> <title> Code motion of control structures in high-level languages. </title> <booktitle> In Conference Record 13th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-85. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers <ref> [1, 3, 4] </ref>. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in [16, 18, 17], since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions.
Reference: [2] <author> B. Dasarathy. </author> <title> Timing constraints of real-time systems: Constructs for expressing them, method for validating them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 80-86, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Thus, their timing constructs have not been adopted in any production-level programming languages. On reason is that language constructs such as "within 10ms do B" establish constraints on blocks of code. However, "true" real-time properties establish constraints between the occurrences of events <ref> [2, 7] </ref>. These constraints typically arise from a requirements specification, or from a detailed analysis of the application environment. While language-based constraints are very sensitive to a program's execution time, specification-based constraints must be maintained regardless of the platform's CPU characteristics, memory cycle times, bus arbitration delays, etc.
Reference: [3] <author> Joseph A Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computer, </journal> <volume> 30 </volume> <pages> 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers <ref> [1, 3, 4] </ref>. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in [16, 18, 17], since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions.
Reference: [4] <author> Franco Gasperoni. </author> <title> Compilation techniques for VLIW architectures. </title> <type> Technical Report RC 14915(#66741), </type> <institution> IBM T. J. Watson Research Center, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers <ref> [1, 3, 4] </ref>. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in [16, 18, 17], since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions.
Reference: [5] <author> Seongsoo Hong and Richard Gerber. </author> <title> Compiling real-time programs into schedulable code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 166-176. </pages>
Reference-contexts: Second, this decoupling of timing constraints from code blocks enables a more straightforward implementation of an event-based specification. But of most importance, much of the arduous, assembly-language level hand-tuning can now be accomplished automatically by compiler optimization techniques. We present in <ref> [5] </ref> several such techniques, most of which rely on code-motion methods similar to those used in instruction scheduling. Our objective is to achieve consistency between the real-time constraints and the execution characteristics of the code. <p> Since either block may contain conditionals, depending on the program's state there may be several such events executed either "first" or "last." In <ref> [5] </ref> we show how our compiler handles such uncertainty. TCEL also provides an "every" construct to denote a statement with cyclic behavior of positive periodicity. During each period, the interpretation of "every" construct is similar to that of "do" [5]. Program Synthesis. <p> may be several such events executed either "first" or "last." In <ref> [5] </ref> we show how our compiler handles such uncertainty. TCEL also provides an "every" construct to denote a statement with cyclic behavior of positive periodicity. During each period, the interpretation of "every" construct is similar to that of "do" [5]. Program Synthesis. While an event-based semantics makes sense at the source-program level, most real time schedulers only accept timing constraints on the start and finish times of tasks. Thus, the role of the compiler is to transform event-driven source programs into constrained blocks of code.
Reference: [6] <author> Y. Ishikawa, H. Tokuda, and C. W. Mercer. </author> <title> Object-oriented real-time language design: Constructs for timing constraints. </title> <booktitle> In Proceedings of OOPSLA-90, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive.
Reference: [7] <author> F. Jahanian and Al Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> Septem-ber </month> <year> 1986. </year>
Reference-contexts: Thus, their timing constructs have not been adopted in any production-level programming languages. On reason is that language constructs such as "within 10ms do B" establish constraints on blocks of code. However, "true" real-time properties establish constraints between the occurrences of events <ref> [2, 7] </ref>. These constraints typically arise from a requirements specification, or from a detailed analysis of the application environment. While language-based constraints are very sensitive to a program's execution time, specification-based constraints must be maintained regardless of the platform's CPU characteristics, memory cycle times, bus arbitration delays, etc.
Reference: [8] <author> E. Kligerman and A. D. Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12 </volume> <pages> 941-949, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive.
Reference: [9] <author> James M. Krause. </author> <title> GN&C domain modeling: Functionality requirements for fixed rate algorithms. </title> <type> Technical Report (DRAFT) version 0.2, </type> <institution> Honeywell Systems and Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: In the example that follows, we show how our transformations can be applied to the domain of guidance, navigation and control. Properties of Control Software. One of the major properties of control algorithms is that computations fit a fixed-rate algorithm paradigm <ref> [9] </ref>. (Fixed-rate algorithms are those which execute repetitively with fixed periods.) During each period, the physical world measurement data is sampled, and then actuator commands 2 3:02ms = 0:22ms + 1:0ms + 1:0ms + 0:4ms + 0:4ms 3 2:1ms = S3:finish S3:start = 3:6ms 1:5ms are computed.
Reference: [10] <author> Insup Lee and Vijay Gehlot. </author> <title> Language constructs for real-time programming. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive. <p> The constructs are syntactic descendents of the temporal scope, first introduced in <ref> [10] </ref>. However, as we have stated, our semantics is quite different, in that it relies on constrained relationships between observable events. The "do" construct, used in Section 1, establishes several types of relative timing constraints.
Reference: [11] <author> J. P. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166-171, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Rate Monotonic Scheduling. Rate monotonic scheduling is well suited for control domain applications, not only because they possesses the fixed-rate property, but also because an efficient schedulability test can be applied. An exact schedulability test was presented in <ref> [11] </ref> by Lehoczky et el., which is based on the critical instant analysis 5 [13]. The analysis requires checking if each task meets its first deadline in its critical instant. To do so, we only need to check scheduling points 6 for a task.
Reference: [12] <author> K. J. Lin and S. Natarajan. </author> <title> Expressing and maintaining timing constraints in FLEX. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive. <p> The program of Figure 1 (c) shows three sections labeled with S1, S2, and S3 each. Second, code based timing constraints are derived from the language based timing constraints, and annotated at the constrained section. We have chosen a Flex like <ref> [12] </ref> constraint mechanism, since it provides a highly expressive means of denoting code-based constraints. The derived code based timing constraints must be strong enough to guarantee the original event based timing constraints.
Reference: [13] <author> C. L. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Rate monotonic scheduling is well suited for control domain applications, not only because they possesses the fixed-rate property, but also because an efficient schedulability test can be applied. An exact schedulability test was presented in [11] by Lehoczky et el., which is based on the critical instant analysis 5 <ref> [13] </ref>. The analysis requires checking if each task meets its first deadline in its critical instant. To do so, we only need to check scheduling points 6 for a task.
Reference: [14] <author> V. Nirkhe, S. Tripathi, and A. Agrawala. </author> <title> Language support for the Maruti real-time system. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <month> De-cember </month> <year> 1990. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive.
Reference: [15] <author> Alan C. Shaw. </author> <title> Reasoning about time in higher level language software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: That is, observable events occur instantaneously during the executions of these operations. The timing parameters are the minimum and maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as that found in <ref> [15] </ref>. Program synthesis is actually a four-step process. First, a "do" statement is decomposed into several code blocks, called sections. The program of Figure 1 (c) shows three sections labeled with S1, S2, and S3 each.
Reference: [16] <author> A. D. Stoyenko. </author> <title> A schedulability analyzer for real-time Euclid. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1987. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers [1, 3, 4]. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in <ref> [16, 18, 17] </ref>, since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions. In fact, many of our techniques can be harnessed by these efforts as well.
Reference: [17] <author> A. D. Stoyenko and T. J. Marlowe. </author> <title> Schedulability, program transformations and real-time programming. </title> <booktitle> In 8th Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 33-41. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers [1, 3, 4]. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in <ref> [16, 18, 17] </ref>, since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions. In fact, many of our techniques can be harnessed by these efforts as well.
Reference: [18] <author> H. F. Wedde, B. Korel, and D. M. Huizinga. </author> <title> Static analysis of timing properties for distributed real-time programs. </title> <booktitle> In Proceedings IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 88-95. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Our synthesis phase depends heavily on the technique of code motion, one of the most frequently used transformations in optimizing compilers [1, 3, 4]. Such a technique proves quite fruitful when attempting to achieve real-time feasibility. The core of our synthesis approach is orthogonal to techniques found in <ref> [16, 18, 17] </ref>, since we apply our algorithm to sequential programs, whereas they analyze concurrent tasks in the presence of mutual interactions. In fact, many of our techniques can be harnessed by these efforts as well.
Reference: [19] <author> Victor Wolfe. </author> <title> Supporting Real-Time Concurrency. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Real-time performance is subsequently achieved by manually counting instruction-cycle times, hand-optimizing the code, and experimenting with various orderings of operations to help achieve schedulability. Recently, experimental languages have been proposed which provide first-class, real-time constructs <ref> [6, 8, 10, 12, 14, 19] </ref>. An example of such a construct is "within 10ms do B," where the block of code "B" must be executed within 10 milliseconds. This constraint is, in turn, conveyed to the real-time scheduler as a directive.
References-found: 19

