URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1099/CS-TR-92-1099.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1099/
Root-URL: http://www.cs.wisc.edu
Title: Pointer-based Join Techniques for Object-Oriented Databases  
Author: Daniel F. Lieuwen David J. DeWitt Manish Mehta 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: In this paper, we describe and analyze four parallel pointer-based joins for set-valued attributes. These joins will be common in next-generation object-oriented database systems, so efficiently supporting them is crucial to the performance of such systems. Pointer-based join algorithms based on Hybrid-hash provide good performance, but algorithms that require less replication will often produce as good or better performance, especially if each set-valued attribute references a small number of nodes. 
Abstract-found: 1
Intro-found: 1
Reference: [AGRA89] <author> R. Agrawal and N. H. Gehani. </author> <title> ODE (Object Database and Environment): The Language and the Data Model. </title> <booktitle> Proc. 1989 SIGMOD, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ <ref> [AGRA89] </ref>, ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [BORA90] <author> Haran Boral, William Alexander, Larry Clay, George Copeland, Scott Danforth, Michael Franklin, Brian Hart, Marc Smith, and Patrick Valduriez. </author> <title> Prototyping Bubba, A Highly Parallel Database System. </title> <journal> IEEE Trans. Knowledge and Data Engineering 2,1 (March 1990), </journal> <pages> 4-24. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba <ref> [BORA90] </ref>, E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [BUTT91] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The GemStone Object Database Management System. </title> <journal> CACM 34,10 (October 1991), </journal> <pages> 64-77. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone <ref> [BUTT91] </ref>, Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [CARE90] <author> Michael Carey, Eugene Shekita, George Lapis, Bruce Lindsay, and John McPherson. </author> <title> An Incremental Join Attachment for Starburst. </title> <booktitle> Proc. 1990 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: algorithm, and showed that a more elaborate join algorithm using join indices could frequently produce better performance than Hybrid-hash in a uniprocessor system. [OMIE89] compared the two algorithms in a parallel environment and showed that Hybrid-hash will almost always outperform join indices except when the join selectivity is very high. <ref> [CARE90] </ref> describes an incremental join facility added to Starburst to enable a relational DBMS to efficiently handle many-to-one relationships. The set representation employed is similar to the representation provided by network database systems.
Reference: [CHIM90] <author> Danette Chimenti, Ruben Gamboa, Ravi Krishnamurthy, Shamim Naqvi, Shalom Tsur, and Carlo Zaniolo. </author> <title> The LDL System Prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering 2,1 (March 1990), </journal> <pages> 76-90. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL <ref> [CHIM90] </ref>, O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [DEWI84] <author> David DeWitt, Randy Katz, Frank Olken, Leonard Shapiro, Michael Stonebraker, and David Wood. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> Proc. 1984 SIGMOD, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Tuples in the first bucket are inserted into a main hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 A variant of this algorithm would only keep parents that have unseen children. This requires a write of such parents during step (b). The variant has some similarities to the Simple-Hash join algorithm <ref> [DEWI84] </ref>. In both, the tuples that need to be processed later are written to a new file and that new file is used for the next iteration. The actual Probe-child join algorithm, however, proceeds in much the same way as the Hashed Loops join algorithm for centralized databases [GERB86]. <p> Thus, M i pages are available for the hash table and the output buffers at node i . Using reasoning from <ref> [DEWI84] </ref>, B i R J M i P i HH hhhhhhhhhhhhhhhh H J output buffers are needed and the fraction q i I J 1.0, HH-H . <p> Since the space requirements of step (1) of Hybrid-hash/page-pointer and step (2) of Hybrid-hash/node pointer for redeclustering Set1 are identical, M i HH pages are available for the hash table and the output buffers at node i . Using analysis in <ref> [DEWI84] </ref>, B i R J M i P i HH hhhhhhhhhhhhhh H J output buffers will be needed, and the fraction - 18 - q i I J 1.0, HH .
Reference: [DEUX91] <editor> O. Deux et al. </editor> <title> The O 2 System. </title> <journal> CACM 34,10 (October 1991), </journal> <pages> 34-48. - 26 </pages> - 
Reference-contexts: Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 <ref> [DEUX91] </ref>. Set-valued attributes often contain the object identifiers (oids) of other objects. Such a structure can be used to naturally model the relationship between a composite part and its subparts, between a program module and its functions, and between a department and its employeesto name just a few examples.
Reference: [DEWI92a] <author> David DeWitt and Jim Gray. </author> <title> Parallel Database Systems: The Future of High Performance Database Sys--tems. </title> <journal> CACM 35,6 (June 1992), </journal> <pages> 85-98. </pages>
Reference-contexts: Such back-pointers will frequently not exist in an OODBS. This section describes and analyzes four execution strategies for loops like (2): the Hash-loops, the Probe-children, the Hybrid-hash/node-pointer, and the Hybrid-hash/page-pointer join algorithms. It also contains the Find-children algorithm which allows algorithms like <ref> [GERB86, SCHN91, DEWI92a] </ref>'s parallel Hybrid-hash and our Probe-children join algorithm to be used even when an explicit extent of children of Set1 objects does not exist. <p> Otherwise, it will be better to replicate each Set1 object once per child pointer, redecluster both Set1 and Set2 (tagging each Set2-tuple with its oid), and use a standard parallel Hybrid-hash algorithm <ref> [GERB86, SCHN89, DEWI92a] </ref> with the oids as join attributesin which case we would expect performance similar to Hybrid-hash/node-pointer in Figure 7 after shift - 22 - ing it up about 19 seconds everywhere to account for having approximately twice as much to read to partition Set2 at the node with tuple-placement-skew.
Reference: [DEWI92b] <author> David DeWitt, Jeffrey Naughton, Donovan Schneider, and S. Seshadri. </author> <title> Practical Skew Handling Algorithms For Parallel Joins. </title> <booktitle> Proc. 1992 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: A hash function that ignores the node but uses the page and slot identifier from the pointer should produce fairly uniformly sized partitions. Alternatively, a skew resistant join technique <ref> [KITS90, WOLF90, HUA91, WALT91, DEWI92b] </ref> might be used after producing Set1-tuples. Note that the Find-children algorithm must be used to allow either of these techniques if Set2 is not an explicit extent.
Reference: [FISH87] <author> D. Fishman, D. Beech, H. Cate, E. Chow, T. Connors, J. Davis, N. Derrett, C. Hoch, W. Kent, P. Lyng-baek, B. Mahbod, M. Neimat, T. Ryan, and M. Shan. </author> <title> Iris: An Object-Oriented Database Management System. </title> <journal> ACM Trans. Office Information Systems 5,1 (January 1987), </journal> <pages> 48-69. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris <ref> [FISH87] </ref>, LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [GERB86] <author> Robert Gerber. </author> <title> Ph.D Thesis. Dataflow Query Processing using Multiprocessor Hash-partitioned Algorithms. </title> <institution> University of Wisconsin (1986). </institution>
Reference-contexts: Such back-pointers will frequently not exist in an OODBS. This section describes and analyzes four execution strategies for loops like (2): the Hash-loops, the Probe-children, the Hybrid-hash/node-pointer, and the Hybrid-hash/page-pointer join algorithms. It also contains the Find-children algorithm which allows algorithms like <ref> [GERB86, SCHN91, DEWI92a] </ref>'s parallel Hybrid-hash and our Probe-children join algorithm to be used even when an explicit extent of children of Set1 objects does not exist. <p> In both, the tuples that need to be processed later are written to a new file and that new file is used for the next iteration. The actual Probe-child join algorithm, however, proceeds in much the same way as the Hashed Loops join algorithm for centralized databases <ref> [GERB86] </ref>. Both build a memory-sized hash table for some fraction of the inner set Set2. They read the whole (local partition of the) set of Set1-tuples to probe the hash table. This continues until all of Set2 has been processed. <p> Otherwise, it will be better to replicate each Set1 object once per child pointer, redecluster both Set1 and Set2 (tagging each Set2-tuple with its oid), and use a standard parallel Hybrid-hash algorithm <ref> [GERB86, SCHN89, DEWI92a] </ref> with the oids as join attributesin which case we would expect performance similar to Hybrid-hash/node-pointer in Figure 7 after shift - 22 - ing it up about 19 seconds everywhere to account for having approximately twice as much to read to partition Set2 at the node with tuple-placement-skew.
Reference: [GHAN90] <author> Shahram Ghandeharizadeh. </author> <type> Ph.D Thesis. </type> <institution> Physical Database Design in Multiprocessor Database Systems. University of Wisconsin (1990). </institution>
Reference-contexts: In (2), we will call the (implicit) set of all children objects Set2. We assume that Set1 and Set2 are declustered <ref> [GHAN90] </ref> across n nodes, and that exactly those n nodes will be used to execute the join. The children of a Set1 object may be located on different nodes.
Reference: [HUA91] <author> Kien Hua and Chiang Lee. </author> <title> Handling Data Skew in Multiprocessor Database Computers Using Partition Tuning. </title> <booktitle> Proc. 1991 Conf. Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: A hash function that ignores the node but uses the page and slot identifier from the pointer should produce fairly uniformly sized partitions. Alternatively, a skew resistant join technique <ref> [KITS90, WOLF90, HUA91, WALT91, DEWI92b] </ref> might be used after producing Set1-tuples. Note that the Find-children algorithm must be used to allow either of these techniques if Set2 is not an explicit extent.
Reference: [KHOS86] <author> Setrag Khoshafian and George Copeland. </author> <title> Object Identify. </title> <booktitle> Proc. 1986 OOPSLA, </booktitle> <month> September </month> <year> 1986. </year>
Reference: [KIM90] <author> Won Kim, Jorge Garza, Nathaniel Ballou, and Darrell Woelk. </author> <title> Architecture of the ORION Next-Generation Database System. </title> <journal> IEEE Trans. Knowledge and Data Engineering 2,1 (March 1990), </journal> <pages> 109-124. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION <ref> [KIM90] </ref>, and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [KITS90] <author> Masaru Kitsuregawa and Yasushi Ogawa. </author> <title> Bucket Spreading Parallel Hash: A New, Robust, Parallel Hash Join Method for Data Skew in the Super Database Computer (SDC). </title> <booktitle> Proc. 1990 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: A hash function that ignores the node but uses the page and slot identifier from the pointer should produce fairly uniformly sized partitions. Alternatively, a skew resistant join technique <ref> [KITS90, WOLF90, HUA91, WALT91, DEWI92b] </ref> might be used after producing Set1-tuples. Note that the Find-children algorithm must be used to allow either of these techniques if Set2 is not an explicit extent.
Reference: [LAMB91] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> CACM 34,10 (October 1991), </journal> <pages> 50-63. </pages>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E [RICH92], GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore <ref> [LAMB91] </ref>, ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [LIEU92a] <author> Daniel Lieuwen and David DeWitt, </author> <title> A Transformation-based Approach to Optimizing Loops in Database Programming Languages. </title> <booktitle> Proc. 1992 SIGMOD, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: We would like to simulate the algorithms described in this paper to validate our cost formulas. Finally, we would like to build a parallel version of a DBPL (probably O++) that employs our algorithms (and our program transformations <ref> [LIEU92a, LIEU92b] </ref>).
Reference: [LIEU92b] <author> Daniel Lieuwen. </author> <title> Ph.D Thesis. Optimizing and Parallelizing Loops in Object-Oriented Database Programming Languages. </title> <institution> University of Wisconsin (1992). </institution>
Reference-contexts: Thus, Probe-children and Hybrid-hash/node-pointer can be used for parallel relational database systems that support range and/or hash partitioning. We will ignore statement S21 in query (2) in the following discussion. S21 will be executed once for each result tuple produced. <ref> [LIEU92b] </ref> discusses the conditions under which the join algorithms can be modified to execute S21 at the join nodes. Otherwise, S21 must be executed centrally by the application program. Leaving out S21 will make it clearer that the algorithms are equally applicable to OODBSs and DBPLs. <p> set-valued attribute contains 32 oids, a i r is expected to be 1.57 even if no clustering was attempted and references are randomly distributed across the n nodes. 6 When a join is expressed using a nested iterator and the enclosed statement S21 does not fit certain patterns described in <ref> [LIEU92b] </ref>, parti tioning is needed. <p> We would like to simulate the algorithms described in this paper to validate our cost formulas. Finally, we would like to build a parallel version of a DBPL (probably O++) that employs our algorithms (and our program transformations <ref> [LIEU92a, LIEU92b] </ref>).
Reference: [OMIE89] <author> Edward Omiecinski and Eileen Tien Lin. </author> <title> Hash-Based and Index-Based Join Algorithms for Cube and Ring Connected Multicomputers. </title> <journal> IEEE Trans. Knowledge and Data Engineering 1,3 (September 1989), </journal> <pages> 329-343. </pages>
Reference-contexts: In a uni-processor system, the basic algorithm scans the index, reading the referenced tuples. [VALD87] compared the performance of join indices to the Hybrid-hash join algorithm, and showed that a more elaborate join algorithm using join indices could frequently produce better performance than Hybrid-hash in a uniprocessor system. <ref> [OMIE89] </ref> compared the two algorithms in a parallel environment and showed that Hybrid-hash will almost always outperform join indices except when the join selectivity is very high. [CARE90] describes an incremental join facility added to Starburst to enable a relational DBMS to efficiently handle many-to-one relationships.
Reference: [RICH92] <author> Joel Richardson, Michael Carey, and Daniel Schuh. </author> <title> The Design of the E Programming Language. </title> <journal> ACM Trans. Programming Languages and Syst. </journal> <note> (1992), to appear. </note>
Reference-contexts: 1. Introduction Set-valued attributes are an important feature of next-generation database systems, both for Database Programming Languages (DBPLs) and Object-Oriented Database Systems (OODBSs). Examples of systems with data-modeling facilities for set-valued attributes include Bubba [BORA90], E <ref> [RICH92] </ref>, GemStone [BUTT91], Iris [FISH87], LDL [CHIM90], O++ [AGRA89], ObjectStore [LAMB91], ORION [KIM90], and O 2 [DEUX91]. Set-valued attributes often contain the object identifiers (oids) of other objects.
Reference: [SCHN89] <author> Donovan Schneider and David DeWitt. </author> <title> A Performance Evaluation of Four Parallel Join Algorithms in a Shared-Nothing Multiprocessor Environment. </title> <booktitle> Proc. 1989 SIGMOD, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Otherwise, it will be better to replicate each Set1 object once per child pointer, redecluster both Set1 and Set2 (tagging each Set2-tuple with its oid), and use a standard parallel Hybrid-hash algorithm <ref> [GERB86, SCHN89, DEWI92a] </ref> with the oids as join attributesin which case we would expect performance similar to Hybrid-hash/node-pointer in Figure 7 after shift - 22 - ing it up about 19 seconds everywhere to account for having approximately twice as much to read to partition Set2 at the node with tuple-placement-skew.
Reference: [SHEK90] <author> Eugene Shekita and Michael J. Carey. </author> <title> A Performance Evaluation of Pointer-Based Joins. </title> <booktitle> Proc. 1990 SIGMOD, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: We also assume a different set representationone where each parent contains a list of all its children's oids. The children objects are not linked and do not necessarily have pointers to their parents. We employed the same set representation used in <ref> [SHEK90] </ref> which presented an analytical evaluation of pointer-based join algorithms. [SHEK90] describes, analyzes, and compares uni-processor versions of the pointer-based Hybrid-hash and Hash-loops join algorithms assuming no sharing of objects. We analyze a parallel version of Hash-loops and two parallel versions of pointer-based Hybrid-hash. <p> The children objects are not linked and do not necessarily have pointers to their parents. We employed the same set representation used in <ref> [SHEK90] </ref> which presented an analytical evaluation of pointer-based join algorithms. [SHEK90] describes, analyzes, and compares uni-processor versions of the pointer-based Hybrid-hash and Hash-loops join algorithms assuming no sharing of objects. We analyze a parallel version of Hash-loops and two parallel versions of pointer-based Hybrid-hash. We compare their performance to a new algorithm, the Probe-child join algorithm. [SHEK90] implicitly assumed that all <p> of pointer-based join algorithms. <ref> [SHEK90] </ref> describes, analyzes, and compares uni-processor versions of the pointer-based Hybrid-hash and Hash-loops join algorithms assuming no sharing of objects. We analyze a parallel version of Hash-loops and two parallel versions of pointer-based Hybrid-hash. We compare their performance to a new algorithm, the Probe-child join algorithm. [SHEK90] implicitly assumed that all objects mentioned in the query could be accessed through an extent. We do not make this assumption, but instead propose the Find-children algorithm to compute an implicit extent when an explicit extent does not exist. The spirit of our Hash-loops analysis was influenced by [SHEK90]. <p> algorithm. <ref> [SHEK90] </ref> implicitly assumed that all objects mentioned in the query could be accessed through an extent. We do not make this assumption, but instead propose the Find-children algorithm to compute an implicit extent when an explicit extent does not exist. The spirit of our Hash-loops analysis was influenced by [SHEK90]. However, changes were required to account for the effects of sharing, of selection and projection, and of declustering objects. [SHEK90] did not take space overhead for a hash table into account; replacing [SHEK90]'s assumption that a hash table for c pages of persistent data requires c pages of main memory <p> The spirit of our Hash-loops analysis was influenced by <ref> [SHEK90] </ref>. However, changes were required to account for the effects of sharing, of selection and projection, and of declustering objects. [SHEK90] did not take space overhead for a hash table into account; replacing [SHEK90]'s assumption that a hash table for c pages of persistent data requires c pages of main memory also required a number of changes. - 2 - Other proposed pointer-based join algorithms include pointer-based nested loops [SHEK90], pointer-based <p> objects. <ref> [SHEK90] </ref> did not take space overhead for a hash table into account; replacing [SHEK90]'s assumption that a hash table for c pages of persistent data requires c pages of main memory also required a number of changes. - 2 - Other proposed pointer-based join algorithms include pointer-based nested loops [SHEK90], pointer-based sort-merge [SHEK90], and pointer-based PID-partitioning [SHEK91]. These three algorithms are analyzed in [SHEK91]. 3. <p> not take space overhead for a hash table into account; replacing <ref> [SHEK90] </ref>'s assumption that a hash table for c pages of persistent data requires c pages of main memory also required a number of changes. - 2 - Other proposed pointer-based join algorithms include pointer-based nested loops [SHEK90], pointer-based sort-merge [SHEK90], and pointer-based PID-partitioning [SHEK91]. These three algorithms are analyzed in [SHEK91]. 3. <p> Analysis of the - 3 - algorithms can be found in Section 4. 3.1. Hash-loops This algorithm is a parallel version of the Hash-loops join algorithm. We will first present the uni-processor version <ref> [SHEK90] </ref>, and then examine a parallel version. Both require physical oids. Let S i be the subset of set S at node i . <p> Find-children If the implicit set Set2 is not maintained as an explicit extent, one must use a parallel version of the Hash-loops, pointer-based nested loops, or pointer-based Hybrid-hash join algorithm <ref> [SHEK90] </ref>. Alternatively, an extent can be explicitly computedwhich is what the Find-children algorithm does. Find-children computes which of each node's pages contain elements of the implicit set Set2. <p> Thus, the Probe-children algorithm will potentially produce fewer Set1-tuples. Third, Probe-children may reread the same Set1-tuples multiple times; Hybrid-hash/node-pointer will reread Set1-tuples at most once because it partitions Set1- and Set2- tuples into buckets. 3.5. Hybrid-hash/page-pointer This algorithm is almost identical to the pointer-based Hybrid-hash join algorithm of <ref> [SHEK90] </ref>. Only step (1) which redistributes Set1 is different. The algorithm proceeds as follows at each node i "i 1in: (1) Scan Set1 i and distribute Set1-tuples, each of which contains exactly one Set2 (child) oid, to the relevant Set2 node. <p> This section also demonstrated that algorithms that avoid replication can produce significant performance advantages. Hash-loops looks much more attractive in an environment where using Hybrid-hash requires replication than it did in <ref> [SHEK90] </ref> provided that most of the Set1 objects reference Set2 objects on a small number of nodes 5 and that data is relatively uniformly distributed across nodes. [SHEK90] only examined the performance of algorithms that have sets of pointers from parents-to-children when there was a corresponding child-to-parent pointer; this gave more <p> Hash-loops looks much more attractive in an environment where using Hybrid-hash requires replication than it did in <ref> [SHEK90] </ref> provided that most of the Set1 objects reference Set2 objects on a small number of nodes 5 and that data is relatively uniformly distributed across nodes. [SHEK90] only examined the performance of algorithms that have sets of pointers from parents-to-children when there was a corresponding child-to-parent pointer; this gave more options and made Hash-loops look less attractive. However, in an OODBS, child-to-parent pointers frequently do not exist, and each child may potentially have many parents. <p> However, in an OODBS, child-to-parent pointers frequently do not exist, and each child may potentially have many parents. Thus, even in a centralized system, replication may be required in order to use Hybrid-hash algorithmsmaking Hash-loops a better choice more often than it was in <ref> [SHEK90] </ref>. We also showed that using Find-children and a load-child algorithm can be a clear winner at moderate memory sizes. In the presence of tuple-placement-skew, Find-children can be indispensable to improving performance because it allows Set2 to be redistributed across the nodes. <p> The comparisons demonstrate that the Hash-loops and Probe-children join algorithms can be very competitive with parallel pointer-based Hybrid-hash join algorithms. These pointer-based join algorithms show great promise for parallelizing a DBPL. Since some of the pointer-based joins were originally proposed for centralized relational database systems with referential integrity support <ref> [SHEK90] </ref>, these algorithms should also be useful for such relational systems. We are currently developing techniques to parallelize a wider class of programs written in a DBPL. We are interested in developing new parallel algorithms for processing the bulk-data structures of OODBSs and DBPLs.
Reference: [SHEK91] <author> Eugene Shekita. </author> <title> Ph.D Thesis. High-Performance Implementation Techniques for Next-Generation Database Systems. </title> <institution> University of Wisconsin (1991). </institution>
Reference-contexts: for a hash table into account; replacing [SHEK90]'s assumption that a hash table for c pages of persistent data requires c pages of main memory also required a number of changes. - 2 - Other proposed pointer-based join algorithms include pointer-based nested loops [SHEK90], pointer-based sort-merge [SHEK90], and pointer-based PID-partitioning <ref> [SHEK91] </ref>. These three algorithms are analyzed in [SHEK91]. 3. Four Pointer-based Join Algorithms Consider the following loop where each element of Set1 contains a set-valued attribute named "set": (2) for (X1 of Set1; X2 of X1-&gt;set) suchthat (Pred2 (X1,X2)) S21; This section describes parallel execution strategies for query (2). <p> [SHEK90]'s assumption that a hash table for c pages of persistent data requires c pages of main memory also required a number of changes. - 2 - Other proposed pointer-based join algorithms include pointer-based nested loops [SHEK90], pointer-based sort-merge [SHEK90], and pointer-based PID-partitioning <ref> [SHEK91] </ref>. These three algorithms are analyzed in [SHEK91]. 3. Four Pointer-based Join Algorithms Consider the following loop where each element of Set1 contains a set-valued attribute named "set": (2) for (X1 of Set1; X2 of X1-&gt;set) suchthat (Pred2 (X1,X2)) S21; This section describes parallel execution strategies for query (2). <p> The children of a Set1 object may be located on different nodes. We do not consider the case where children have back-pointers to their parents; this eliminates a number of the execution strategies that <ref> [SHEK91] </ref> presented for uni-processor systems. Such back-pointers will frequently not exist in an OODBS. This section describes and analyzes four execution strategies for loops like (2): the Hash-loops, the Probe-children, the Hybrid-hash/node-pointer, and the Hybrid-hash/page-pointer join algorithms.
Reference: [VALD87] <author> Patrick Valduriez. </author> <title> Join Indices. </title> <journal> ACM Trans. Database Syst. </journal> <month> 12,2 (June </month> <year> 1987), </year> <pages> 218-246. </pages>
Reference-contexts: Section 3 describes four pointer-based join algorithms for joins like (1). Section 4 analyses the four algorithms; Section 5 compares them. Section 6 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh This research was partially supported by a grant from Bell Laboratories. - 1 - contains our conclusions and future work. 2. Related Work In <ref> [VALD87] </ref>, auxiliary data structures called join indices that can be used to speedup join processing are described. A join index for relations R and S essentially precomputes the join between those two relations by storing pairs of tuple identifiers (tids). <p> Each pair contains a tid from both R and S such that the corresponding tuples join with one another. In a uni-processor system, the basic algorithm scans the index, reading the referenced tuples. <ref> [VALD87] </ref> compared the performance of join indices to the Hybrid-hash join algorithm, and showed that a more elaborate join algorithm using join indices could frequently produce better performance than Hybrid-hash in a uniprocessor system. [OMIE89] compared the two algorithms in a parallel environment and showed that Hybrid-hash will almost always outperform
Reference: [VAND91] <author> Scott Vandenberg and David DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> Proc. 1991 SIGMOD, </booktitle> <month> May </month> <year> 1991. </year>
Reference: [WALT91] <author> Christopher Walton, Alfred Dale, and Roy Jenevein. </author> <title> A Taxonomy and Performance Model of Data Skew Effects in Parallel Joins. </title> <booktitle> Proc. 1991 Conf. Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Assumptions for Analysis We assume that the selection predicates on Set1 and Set2 are equally selective at each node (i.e. no Selec tivity Skew <ref> [WALT91] </ref>). We define two functions for use in the analysis. <p> Since our examples used to compare algorithms do not select Set1, this assumption does not affect our performance results. We do not include CPU time in our analysis because the CPU work required is proportional to the larger of the I/O and CPU times in the algorithms considered. <ref> [WALT91] </ref> included CPU time, but none of the queries were CPU boundthe CPU time was always lost in the overlap with I/O and communication. Thus, we feel it is safe to neglect CPU time in the analysis. Originally, we used [WALT91]'s style of capturing overlapped communication and I/O. <p> We assume in all our algorithm comparisons that selection predicates are equally selective at each node (i.e. no Selectivity Skew <ref> [WALT91] </ref>). 5.1. Poorly Clustered Database In the first comparisons, the system defaults from the Section 4.1 were used. Data was uniformly distributed across n=32 nodes, with | Set1 i | =6080, and | Set2 i | =30,400 "i 1in. <p> Also, in reality the load-child algorithms should perform better relative to the load-parent (i.e. Hybrid-hash/page-pointer and Hash-loops) algorithms than the graph indicates because the load-child algorithms read Set2 pages sequentially (since Find-children sorts the page identifiers) while the load-parent algorithms read them randomly. However, following <ref> [WALT91] </ref>, our analysis did not take the different types of I/O into account. - 20 - Hybrid-hash/node-pointer outperforms Probe-children at low memory sizes because it must perform I/Os for only a fraction of the Set1-tuples sent to each node, while Probe-children must write and read them all (several times). <p> Probe-children receives fewer so its performance improves. By avoiding replication, its performance can exceed that of the Hybrid-hash algorithms. 5.3. Database with Tuple Placement Skew In our next algorithm comparison, we considered a well-clustered database with tuple-placement skew <ref> [WALT91] </ref>. Since the performance of the whole query is determined by the slowest node, we use 31 evenly balanced nodes, each of which has 29,488 Set2 objects, and one node with 58,672 Set2 objects. Set2 has the same number of elements as in the past comparisonsit is just differently distributed. <p> A hash function that ignores the node but uses the page and slot identifier from the pointer should produce fairly uniformly sized partitions. Alternatively, a skew resistant join technique <ref> [KITS90, WOLF90, HUA91, WALT91, DEWI92b] </ref> might be used after producing Set1-tuples. Note that the Find-children algorithm must be used to allow either of these techniques if Set2 is not an explicit extent.
Reference: [WOLF90] <author> Joel Wolf, Daniel Dias, Philip Yu, and John Turek. </author> <title> An effective algorithm for parallelizing hash joins in the presence of data skew. </title> <institution> IBM T. J. Watson Research Center Technical Report RC 15510, </institution> <year> 1990. </year>
Reference-contexts: A hash function that ignores the node but uses the page and slot identifier from the pointer should produce fairly uniformly sized partitions. Alternatively, a skew resistant join technique <ref> [KITS90, WOLF90, HUA91, WALT91, DEWI92b] </ref> might be used after producing Set1-tuples. Note that the Find-children algorithm must be used to allow either of these techniques if Set2 is not an explicit extent.
Reference: [YAO77] <author> S. B. Yao. </author> <title> Approximating Block Accesses in Database Organizations. </title> <journal> Comm. of the ACM 20,4 (April 1977), </journal> <pages> 260-261. </pages>
Reference-contexts: To calculate the number of page reads for Set2 i objects, we use a formula from <ref> [YAO77] </ref> for calculating the expected fraction of pages of a set with cardinality | S | that must be read to examine a subset of size | S s | provided O S objects fit on a page.
References-found: 29

