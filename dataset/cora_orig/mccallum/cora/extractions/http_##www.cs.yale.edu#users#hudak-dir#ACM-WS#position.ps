URL: http://www.cs.yale.edu/users/hudak-dir/ACM-WS/position.ps
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/hudak-dir/ACM-WS/citation.html
Root-URL: http://www.cs.yale.edu
Title: Building Domain-Specific Embedded Languages  
Author: Paul Hudak 
Date: June 3, 1996  
Affiliation: Department of Computer Science Yale University  
Abstract: I have believed for a very long time that abstraction is the most important factor in writing good software. As programming language researchers we design, and as software engineers we are trained to use, a variety of abstraction mechanisms: abstract data types, higher-order functions, monads, continuations, modules, classes, objects, etc. Particular languages support some of these mechanisms well, others not so well. An important point about these mechanisms is that they are fairly general|for example, most algorithmic strategies and computational structures can be implemented using either functional or object-oriented abstraction techniques. Although generality is good, we might ask what the "ideal" abstraction for a particular application is. In my opinion, it is a programming language that is designed precisely for that application: one in which a person can quickly and effectively develop a complete software system. It is not general at all; it should capture precisely the semantics of the application domain|no more and no less. In my opinion, a domain-specific language is the "ultimate abstraction." But we know all too well how difficult designing and implementing languages is, and we can be pretty sure that we won't get it right the first time; it will evolve, and we will experience all of the difficulties associated with that evolution. So in fact the notion of a domain specific language might not be very practical. Or is it? In this position paper I will outline several techniques that I believe can lead to the effective use of this methodology. It begins with the assumption that we really don't want to build a programming language from scratch. Better, let's inherit the infrastructure of some other language|tailoring it in special ways to the domain of interest|thus yielding a domain-specific embedded language (DSEL). Building on this base, we can then concentrate on semantical issues: viz. the interpreter of the language. Interestingly, we'll see that abstraction now kicks in at this leta-level: we can use abstraction techniques to build interpreters that are themselves easy to understand, highly modular, and straightforward to evolve. In the remainder of this paper I will describe the results of using the functional language Haskell to build DSELs. Haskell has several features that make it particularly suitable for this, but other languages could also be used. On the other hand, there are features that don't exist in any language (to my knowledge) that would make things even easier; there is much more work to be done. Domain Specific Semantics It is surprisingly straightforward to design a DSEL for many specific applications. We have done so already using Haskell in several domains: parser generation, graphics, animation, simulation, music composition, and geometric region analysis, to 
Abstract-found: 1
Intro-found: 0
Reference: [Car93] <author> J. Caruso. </author> <title> Prototyping Demonstration Problem for the Prototech HiPer-D Joint Prototyping Demonstration Project. </title> <type> CCB Report 0.2, </type> <institution> Naval Surface Warfare Center, </institution> <month> August </month> <year> 1993. </year> <title> Last modified October 27, 1993; further changes specified by J. Caruso are described in "Addendum to Prototyping Demonstration Problem for the Prototech HiPer-D Joint Prototyping Demonstration Project," </title> <month> November 9, </month> <year> 1993. </year>
Reference: [CHJ93] <author> W.E. Carlson, P. Hudak, and M.P. Jones. </author> <title> An Experiment Using Haskell To Prototype 5 "Geometric Region Servers" for Navy Command And Control. </title> <type> Research Report 1031, </type> <institution> Department of Computer Science, Yale University, </institution> <month> November </month> <year> 1993. </year>
Reference: [Esp93] <author> David Espinosa. </author> <title> Modular Denotational Semantics. </title> <type> Unpublished manuscript, </type> <month> Decem-ber </month> <year> 1993. </year>
Reference: [LBK fl 94] <author> J.A.N. Lee, B. Blum, P. Kanellakis, H. </author> <title> Crisp, and J.A. Caruso. ProtoTech HiPer-D Joint Prototyping Demonstration Project, </title> <month> February </month> <year> 1994. </year> <pages> Unpublished; 400 pages. </pages>
Reference: [LH96] <author> Sheng Liang and Paul Hudak. </author> <title> Modular Denotational Semantics for Compiler Construction. </title> <booktitle> In European Symposium on Programming, </booktitle> <month> April </month> <year> 1996. </year>
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad Transformers and Modular Interpreters. </title> <booktitle> In Proceedings of 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <address> New York, </address> <month> January </month> <year> 1995. </year> <note> ACM Press. </note>
Reference: [Lia96] <author> Sheng Liang. </author> <title> Modular Monadic Semantics and Compilation. </title> <type> PhD thesis, </type> <institution> Yale University, Department of Computer Science, </institution> <month> November </month> <year> 1996. </year>
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational Lambda-Calculus and Monads. </title> <booktitle> In Proceedings of Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1989. </year>
Reference: [PJW93] <author> S. Peyton Jones and P. Wadler. </author> <title> Imperative Functional Programming. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year> <note> (to appear). </note>
Reference: [Ste94] <author> Guy L. Steele Jr. </author> <title> Building Interpreters by Composing Monads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 472-492, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference: [Wad90] <author> P. Wadler. </author> <title> Comprehending Monads. </title> <booktitle> In Proceedings of Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year> <journal> ACM. </journal> <volume> 6 </volume>
References-found: 11

