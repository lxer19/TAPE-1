URL: ftp://ftp.cs.kun.nl/pub/SoftwEng.InfSyst/articles/DesMod.ps.Z
Refering-URL: http://www.sci.kun.nl/afdis/publist.html
Root-URL: 
Title: Database Design Modifications based on Conceptual Modelling Database Design Modifications based on Conceptual Mod-elling. In
Author: Patrick van Bommel P. van Bommel. H. Jaakkola, H. Kangassalo, T. Kitahashi, and A. Markus, 
Note: Published as:  pages 275-286, Amsterdam, The Netherlands, 1994. IOS Press.  
Date: June 21, 1994  
Abstract: In this paper we consider the solution space for the following problem. Let I be the information structure of a conceptual data model. Then the set S is defined as the set of alternative database implementations, representing the information structure I. In this view the problem of database design is: choose an appropriate element from S. We discuss the notion of design modifications, a means for `walking' through S. Such modifications have been implemented in EDO: an Evolutionary Database Optimizer. This tool allows a database designer to activate evolution strategies within S. Two kinds of evolution strategies are distinguished: profile-based strategies and constraint-based strate gies.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. van Bommel. </author> <title> A Randomised Schema Mutator for Evolutionary Database Optimisa-tion. </title> <journal> The Australian Computer Journal, </journal> <volume> 25(2) </volume> <pages> 61-69, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Although we focus on the relational model in this paper, the same strategy can be used for other models. As an example, an intermediate language for conceptual models and nested-relational (NF 2 ) models was extensively discussed in [5], [6], <ref> [1] </ref> and [3]. fl Dept. of Information Systems, Faculty of Mathematics and Computing Science, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The organization of this paper is as follows. In section 1.2 we give a short introduction on conceptual modelling. <p> In the sequel we will use the term `internal representation' as a generic term for internal database representations of a given conceptual information structure. 3.2 An Evolutionary Database Optimizer In this section we shortly discuss the tool EDO: an Evolutionary Database Optimizer ([6], <ref> [1] </ref>, [4]). This tool is a research prototype for database design, developed at the University of Nijmegen. <p> In order to interrelate the values of the conflicting criteria Space and Time, we use the parameters shown in figure 12. parameter explanation fi weight coefficient for storage space fl s the average cost of storage media fl t the average cost of processing time The parameter fi 2 <ref> [0; 1] </ref> is a weight coefficient for storage space. It expresses the importance of space minimization for the database application under development. As a consequence, the importance of minimization of access times is expressed by 1 fi. <p> The main contributions of this paper are the following. Firstly, an inductive definition of the solution space S was given. In previous research the solution space S was defined by characterizing its elements in wellformedness conditions (see e.g. [5], [6] and <ref> [1] </ref>). An inductive definition has several advantages. For instance, in order to prove that a specific property holds for all internal representations in S, the following scheme for structural induction can be used: Inductor: Show that the property holds for the direct relational design.
Reference: [2] <author> P. van Bommel, A.H.M. ter Hofstede, and Th.P. van der Weide. </author> <title> Semantics and verification of object-role models. </title> <journal> Information Systems, </journal> <volume> 16(5) </volume> <pages> 471-495, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Furthermore, we discuss a research prototype for database design, developed at the University of Nijmegen. 1.2 Introduction on conceptual modelling In this paper it is assumed that the reader is familiar with conceptual data modelling in general, and with object-role models in particular (see e.g. <ref> [2] </ref>, [18], [21], [25]). A conceptual model usually consists of (1) an information structure and (2) constraints on the possible populations of the information structure. <p> The combination between an object type and a role in a fact type is called a predicator (see <ref> [2] </ref>, [15], [27]). The example information structure in figure 1 contains 7 predicators p; :::; v, where a fact type is formally defined as a set of predicators: e.g. g = fr; s; tg. Information structures can be populated (also called instantiated). Details on populations are found in [2] and [18]. <p> predicator (see <ref> [2] </ref>, [15], [27]). The example information structure in figure 1 contains 7 predicators p; :::; v, where a fact type is formally defined as a set of predicators: e.g. g = fr; s; tg. Information structures can be populated (also called instantiated). Details on populations are found in [2] and [18]. An example population of the information structure from figure 1 is shown in figure 2.
Reference: [3] <author> P. van Bommel, Gy. Kovacs, and A. Micsik. </author> <title> Transformation of database populations and operations from the conceptual to the internal level. </title> <journal> Information Systems, </journal> <volume> 19(2) </volume> <pages> 175-191, </pages> <year> 1994. </year>
Reference-contexts: Although we focus on the relational model in this paper, the same strategy can be used for other models. As an example, an intermediate language for conceptual models and nested-relational (NF 2 ) models was extensively discussed in [5], [6], [1] and <ref> [3] </ref>. fl Dept. of Information Systems, Faculty of Mathematics and Computing Science, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The organization of this paper is as follows. In section 1.2 we give a short introduction on conceptual modelling. <p> This will provide a better understanding of the design under consideration. Also it may be desirable to examine the (dynamic) behaviour of that design, by simulating update transactions. This kind of update simulation was discussed in <ref> [3] </ref> in the context of the NF 2 data model. For related work we refer to [23]. 3 Design modifications In this section we discuss the notion of design modifications. <p> Other types of internal representations are for instance hierarchic- or network-natured. As an example, if a relation type is defined as a tree of attribute types, rather than a set of attribute types, that relation type corresponds to the non-first-normal-form (NF 2 ) data model (see e.g. [5], <ref> [3] </ref>). In the sequel we will use the term `internal representation' as a generic term for internal database representations of a given conceptual information structure. 3.2 An Evolutionary Database Optimizer In this section we shortly discuss the tool EDO: an Evolutionary Database Optimizer ([6], [1], [4]).
Reference: [4] <author> P. van Bommel, C.B. Lucasius, and Th.P. van der Weide. </author> <title> Genetic Algorithms for Optimal Database Design. </title> <type> Technical Report 93-01, </type> <institution> Information Systems Group, Computing Science Institute, University of Nijmegen, Nijmegen, </institution> <address> The Netherlands, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: In the sequel we will use the term `internal representation' as a generic term for internal database representations of a given conceptual information structure. 3.2 An Evolutionary Database Optimizer In this section we shortly discuss the tool EDO: an Evolutionary Database Optimizer ([6], [1], <ref> [4] </ref>). This tool is a research prototype for database design, developed at the University of Nijmegen.
Reference: [5] <author> P. van Bommel and Th.P. van der Weide. </author> <title> Reducing the search space for conceptual schema transformation. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 8 </volume> <pages> 269-292, </pages> <year> 1992. </year>
Reference-contexts: Although we focus on the relational model in this paper, the same strategy can be used for other models. As an example, an intermediate language for conceptual models and nested-relational (NF 2 ) models was extensively discussed in <ref> [5] </ref>, [6], [1] and [3]. fl Dept. of Information Systems, Faculty of Mathematics and Computing Science, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The organization of this paper is as follows. In section 1.2 we give a short introduction on conceptual modelling. <p> In <ref> [5] </ref> it was illustrated how these notions can be incorporated in our approach. Furthermore we will ignore more advanced concepts, such as generalization, powertyping and decomposition (see e.g. [15], [14]). 2 Formal foundations In this section the formal foundations of our approach are discussed. <p> Other types of internal representations are for instance hierarchic- or network-natured. As an example, if a relation type is defined as a tree of attribute types, rather than a set of attribute types, that relation type corresponds to the non-first-normal-form (NF 2 ) data model (see e.g. <ref> [5] </ref>, [3]). In the sequel we will use the term `internal representation' as a generic term for internal database representations of a given conceptual information structure. 3.2 An Evolutionary Database Optimizer In this section we shortly discuss the tool EDO: an Evolutionary Database Optimizer ([6], [1], [4]). <p> The main contributions of this paper are the following. Firstly, an inductive definition of the solution space S was given. In previous research the solution space S was defined by characterizing its elements in wellformedness conditions (see e.g. <ref> [5] </ref>, [6] and [1]). An inductive definition has several advantages. For instance, in order to prove that a specific property holds for all internal representations in S, the following scheme for structural induction can be used: Inductor: Show that the property holds for the direct relational design.
Reference: [6] <author> P. van Bommel and Th.P. van der Weide. </author> <title> Towards Database Optimization by Evolution. In A.K. </title> <editor> Majumdar and N. Prakash, editors, </editor> <booktitle> Proceedings of the International Conference on Information Systems and Management of Data (CISMOD 92), </booktitle> <pages> pages 273-287, </pages> <address> Bangalore, India, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Although we focus on the relational model in this paper, the same strategy can be used for other models. As an example, an intermediate language for conceptual models and nested-relational (NF 2 ) models was extensively discussed in [5], <ref> [6] </ref>, [1] and [3]. fl Dept. of Information Systems, Faculty of Mathematics and Computing Science, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The organization of this paper is as follows. In section 1.2 we give a short introduction on conceptual modelling. <p> The main contributions of this paper are the following. Firstly, an inductive definition of the solution space S was given. In previous research the solution space S was defined by characterizing its elements in wellformedness conditions (see e.g. [5], <ref> [6] </ref> and [1]). An inductive definition has several advantages. For instance, in order to prove that a specific property holds for all internal representations in S, the following scheme for structural induction can be used: Inductor: Show that the property holds for the direct relational design.
Reference: [7] <author> E.F. Codd. </author> <title> Extending the database relational model to capture more meaning. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(4) </volume> <pages> 397-434, </pages> <year> 1979. </year>
Reference: [8] <editor> L. Davis, editor. </editor> <booktitle> Handbook of genetic algorithms. </booktitle> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Searching through S for an appropriate internal representation can be supported by simple evolution strategies, such as a random walk or a hill-climbing walk, or by more advanced strategies, such as Simmulated Annealing and Genetic Algorithms (see e.g. <ref> [8] </ref>, [11], [19]). These strategies are guided by the abovementioned value of Space and Time, and attempt to find an optimal internal representation. However, since Space and Time are conflicting objectives, we have to define clearly in what sense an internal representation can be called `optimal'.
Reference: [9] <author> O.M.F. De Troyer, R. Meersman, and P. Verlinden. </author> <title> RIDL* on the CRIS Case: A Workbench for NIAM. </title> <editor> In T.W. Olle, A.A. Verrijn-Stuart, and L. Bhabuta, editors, </editor> <booktitle> Computerized Assistance during the Information Systems Life Cycle, </booktitle> <pages> pages 375-459, </pages> <address> Amsterdam, The Netherlands, </address> <year> 1988. </year> <month> North-Holland/IFIP. </month>
Reference-contexts: These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. [17], [22], <ref> [9] </ref>). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. [13], [12], [29]).
Reference: [10] <author> J. Diederich and J. Milton. </author> <title> New Methods and Fast Algorithms for Database Normalization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(3) </volume> <pages> 339-365, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: As a consequence, we have to examine in what sense current database design approaches can be interpreted as evolution strategies. In order to get a better understanding how different design approaches are related to the solution space S of internal representations, the following distinction is made: Normalization algorithms (e.g. <ref> [10] </ref>, [24], [28]). These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types.
Reference: [11] <author> D.E. Goldberg. </author> <title> Genetic algorithms in search, optimization, and machine learning. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Searching through S for an appropriate internal representation can be supported by simple evolution strategies, such as a random walk or a hill-climbing walk, or by more advanced strategies, such as Simmulated Annealing and Genetic Algorithms (see e.g. [8], <ref> [11] </ref>, [19]). These strategies are guided by the abovementioned value of Space and Time, and attempt to find an optimal internal representation. However, since Space and Time are conflicting objectives, we have to define clearly in what sense an internal representation can be called `optimal'.
Reference: [12] <author> T.A. Halpin. </author> <title> A Fact-Oriented Approach to Schema Transformation. </title> <editor> In B. Thalheim, J. Demetrovics, and H.-D. Gerhardt, editors, </editor> <booktitle> MFDBS 91, volume 495 of Lecture Notes in Computer Science, </booktitle> <pages> pages 342-356, </pages> <address> Rostock, Germany, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. [13], <ref> [12] </ref>, [29]). The input and output of these algorithms is a conceptual data model. <p> As an example, for the ONF algorithm [17] a join rule would be to join unique single predicators (see definition 2.4). Following the approach from [13], <ref> [12] </ref> and [29], the evolution strategies resulting from grouping algorithms may be improved by preparatory transformations of the conceptual model. 4 Conclusions In this paper we considered the problem of finding suitable internal representations for a given conceptual data model.
Reference: [13] <author> T.A. Halpin. WISE: </author> <title> a Workbench for Information System Engineering. </title> <editor> In V.-P. Tah-vanainen and K. Lyytinen, editors, </editor> <title> Next Generation CASE Tools, </title> <booktitle> volume 3 of Studies in Computer and Communication Systems, </booktitle> <pages> pages 38-49. </pages> <publisher> IOS Press, </publisher> <year> 1992. </year>
Reference-contexts: Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. <ref> [13] </ref>, [12], [29]). The input and output of these algorithms is a conceptual data model. <p> As an example, for the ONF algorithm [17] a join rule would be to join unique single predicators (see definition 2.4). Following the approach from <ref> [13] </ref>, [12] and [29], the evolution strategies resulting from grouping algorithms may be improved by preparatory transformations of the conceptual model. 4 Conclusions In this paper we considered the problem of finding suitable internal representations for a given conceptual data model.
Reference: [14] <author> A.H.M. ter Hofstede, H.A. Proper, and Th.P. van der Weide. </author> <title> Data Modelling in Complex Application Domains. </title> <editor> In P. Loucopoulos, editor, </editor> <booktitle> Proceedings of the Fourth International 11 Conference CAiSE'92 on Advanced Information Systems Engineering, volume 593 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-377, </pages> <address> Manchester, United Kingdom, May 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In [5] it was illustrated how these notions can be incorporated in our approach. Furthermore we will ignore more advanced concepts, such as generalization, powertyping and decomposition (see e.g. [15], <ref> [14] </ref>). 2 Formal foundations In this section the formal foundations of our approach are discussed. We show how conceptual data models and the traditional relational model (e.g. [24]) can be synthesized.
Reference: [15] <author> A.H.M. ter Hofstede and Th.P. van der Weide. </author> <title> Expressiveness in conceptual data mod-elling. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 10(1) </volume> <pages> 65-100, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: The combination between an object type and a role in a fact type is called a predicator (see [2], <ref> [15] </ref>, [27]). The example information structure in figure 1 contains 7 predicators p; :::; v, where a fact type is formally defined as a set of predicators: e.g. g = fr; s; tg. Information structures can be populated (also called instantiated). Details on populations are found in [2] and [18]. <p> In [5] it was illustrated how these notions can be incorporated in our approach. Furthermore we will ignore more advanced concepts, such as generalization, powertyping and decomposition (see e.g. <ref> [15] </ref>, [14]). 2 Formal foundations In this section the formal foundations of our approach are discussed. We show how conceptual data models and the traditional relational model (e.g. [24]) can be synthesized.
Reference: [16] <author> H. van der Lek. </author> <title> Note on the structure of joins. </title> <journal> Information Systems, </journal> <volume> 17(4) </volume> <pages> 343-346, </pages> <year> 1992. </year>
Reference-contexts: rg fsg ftg fug fvg Example 2.4 The result of joining predicators r and u is shown in figure 6. fpg fqg fr; ug fsg ftg fvg Note that the sets fq; rg in figure 5 and fr; ug in figure 6 correspond to the structure of joins (see e.g. <ref> [16] </ref>). Note furthermore that definition 2.4 only considers joining on the type level. As a consequence, it does not prescribe how joining affects the database contents (i.e. the population of a relational design). This transformation of population will now be defined.
Reference: [17] <author> C.M.R. Leung and G.M. Nijssen. </author> <title> Relational database design using the NIAM conceptual schema. </title> <journal> Information Systems, </journal> <volume> 13(2) </volume> <pages> 219-227, </pages> <year> 1988. </year>
Reference-contexts: As a consequence, these strategies ignore the integrity rules (constraints) specified in the conceptual data model. Profile-based evolution strategies are thus unable to find internal representations in a specific normal form, such as BCNF (e.g. [29]) and ONF (e.g. <ref> [17] </ref>). Although we are interested in finding efficient internal representations, rather than internal representations in a specific normal form, it is desirable allowing a database designer to combine profile-based evolution strategies with evolution strategies converging to normal forms. Therefore EDO must be extended with constraint-based evolution strategies. <p> These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. <ref> [17] </ref>, [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. [13], [12], [29]). <p> The grouping of fact types in relation types can be considered a walk from the direct relational design upwards in S, guided by join rules. As an example, for the ONF algorithm <ref> [17] </ref> a join rule would be to join unique single predicators (see definition 2.4).
Reference: [18] <author> G.M. Nijssen and T.A. Halpin. </author> <title> Conceptual Schema and Relational Database Design: a fact oriented approach. </title> <publisher> Prentice-Hall, </publisher> <address> Sydney, Australia, </address> <year> 1989. </year>
Reference-contexts: Furthermore, we discuss a research prototype for database design, developed at the University of Nijmegen. 1.2 Introduction on conceptual modelling In this paper it is assumed that the reader is familiar with conceptual data modelling in general, and with object-role models in particular (see e.g. [2], <ref> [18] </ref>, [21], [25]). A conceptual model usually consists of (1) an information structure and (2) constraints on the possible populations of the information structure. <p> The example information structure in figure 1 contains 7 predicators p; :::; v, where a fact type is formally defined as a set of predicators: e.g. g = fr; s; tg. Information structures can be populated (also called instantiated). Details on populations are found in [2] and <ref> [18] </ref>. An example population of the information structure from figure 1 is shown in figure 2.
Reference: [19] <author> C.R. Reeves, </author> <title> editor. Modern heuristic techniques for combinatorial problems. </title> <publisher> Blackwell Scientific Publications, Oxford, </publisher> <address> United Kingdom, </address> <year> 1993. </year>
Reference-contexts: Searching through S for an appropriate internal representation can be supported by simple evolution strategies, such as a random walk or a hill-climbing walk, or by more advanced strategies, such as Simmulated Annealing and Genetic Algorithms (see e.g. [8], [11], <ref> [19] </ref>). These strategies are guided by the abovementioned value of Space and Time, and attempt to find an optimal internal representation. However, since Space and Time are conflicting objectives, we have to define clearly in what sense an internal representation can be called `optimal'.
Reference: [20] <author> D. Schaffer. </author> <title> Multiple objective optimization with vector evaluated genetic algorithms. </title> <booktitle> In Proceedings of the International Conference on Genetic Algorithms and their Applications, </booktitle> <year> 1985. </year>
Reference-contexts: In our case, the Pareto optimal set is the set of internal representations that are nondominated. An internal representation is called nondominated, if there is no other internal representation which is better on both Space and Time. The use of Pareto optimality in evolutionary algorithms was discussed in e.g. <ref> [20] </ref>. 3.3 Constraint-based evolution strategies In section 3.2, the intention of the design tool EDO was discussed and it was mentioned that EDO focusses on profile-based evolution strategies, combined with constraint-based evolution strategies. The latter kind of strategies will be considered in this section.
Reference: [21] <author> C. Sernadas, J. Fiadeiro, R. Meersman, and A. Sernadas. </author> <title> Proof-theoretic Conceptual Modelling: the NIAM Case Study. </title> <editor> In E.D. Falkenberg and P. Lindgreen, editors, </editor> <booktitle> Information System Concepts: An In-depth Analysis, </booktitle> <pages> pages 1-30, </pages> <address> Amsterdam, The Netherlands, </address> <year> 1989. </year> <month> North-Holland/IFIP. </month>
Reference-contexts: Furthermore, we discuss a research prototype for database design, developed at the University of Nijmegen. 1.2 Introduction on conceptual modelling In this paper it is assumed that the reader is familiar with conceptual data modelling in general, and with object-role models in particular (see e.g. [2], [18], <ref> [21] </ref>, [25]). A conceptual model usually consists of (1) an information structure and (2) constraints on the possible populations of the information structure.
Reference: [22] <author> P. Shoval and M. Even-Chaime. </author> <title> ADDS: A system for automatic database schema design based on the binary-relationship model. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 3(2) </volume> <pages> 123-144, </pages> <year> 1987. </year>
Reference-contexts: These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. [17], <ref> [22] </ref>, [9]). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. [13], [12], [29]).
Reference: [23] <author> L. Tucherman, M.A. Casanova, and A.L. Furtado. </author> <title> The CHRIS consultant A tool for database design and rapid prototyping. </title> <journal> Information Systems, </journal> <volume> 15(2) </volume> <pages> 187-195, </pages> <year> 1990. </year>
Reference-contexts: Also it may be desirable to examine the (dynamic) behaviour of that design, by simulating update transactions. This kind of update simulation was discussed in [3] in the context of the NF 2 data model. For related work we refer to <ref> [23] </ref>. 3 Design modifications In this section we discuss the notion of design modifications.
Reference: [24] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, volume I. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: Furthermore we will ignore more advanced concepts, such as generalization, powertyping and decomposition (see e.g. [15], [14]). 2 Formal foundations In this section the formal foundations of our approach are discussed. We show how conceptual data models and the traditional relational model (e.g. <ref> [24] </ref>) can be synthesized. This synthesis is obtained by relating attributes from the relational model to predicators from the conceptual model. 2.1 Basics Definition 2.1 Relational design Let I be an information structure. A relational design for I is a set of relation types. <p> In order to get a better understanding how different design approaches are related to the solution space S of internal representations, the following distinction is made: Normalization algorithms (e.g. [10], <ref> [24] </ref>, [28]). These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types.
Reference: [25] <author> G.M.A. Verheijen and J. van Bekkum. </author> <title> NIAM: an Information Analysis Method. </title> <editor> In T.W. Olle, H.G. Sol, and A.A. Verrijn-Stuart, editors, </editor> <booktitle> Information Systems Design Methodologies: A Comparative Review, </booktitle> <pages> pages 537-590. </pages> <address> North-Holland/IFIP, Amsterdam, The Netherlands, </address> <year> 1982. </year>
Reference-contexts: Furthermore, we discuss a research prototype for database design, developed at the University of Nijmegen. 1.2 Introduction on conceptual modelling In this paper it is assumed that the reader is familiar with conceptual data modelling in general, and with object-role models in particular (see e.g. [2], [18], [21], <ref> [25] </ref>). A conceptual model usually consists of (1) an information structure and (2) constraints on the possible populations of the information structure.
Reference: [26] <author> T.L. Vincent and W.J. Grantham. </author> <title> Optimality in Parametric Systems. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: However, it may be argued that defining such a function has practical difficulties. In that case, optimality cannot be defined in terms of a single fitness function. This problem can be solved using the notion of Pareto optimality (see e.g. <ref> [26] </ref>). In our case, the Pareto optimal set is the set of internal representations that are nondominated. An internal representation is called nondominated, if there is no other internal representation which is better on both Space and Time.
Reference: [27] <author> Th.P. van der Weide, A.H.M. ter Hofstede, and P. van Bommel. Uniquest: </author> <title> Determining the Semantics of Complex Uniqueness Constraints. </title> <journal> The Computer Journal, </journal> <volume> 35(2) </volume> <pages> 148-156, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: The combination between an object type and a role in a fact type is called a predicator (see [2], [15], <ref> [27] </ref>). The example information structure in figure 1 contains 7 predicators p; :::; v, where a fact type is formally defined as a set of predicators: e.g. g = fr; s; tg. Information structures can be populated (also called instantiated). Details on populations are found in [2] and [18].
Reference: [28] <author> Y. Zhang and M.E. Orlowska. </author> <title> An improvement on the automatic tool for relational databes design. </title> <journal> Information Systems, </journal> <volume> 15(6) </volume> <pages> 647-651, </pages> <year> 1990. </year> <month> 12 </month>
Reference-contexts: In order to get a better understanding how different design approaches are related to the solution space S of internal representations, the following distinction is made: Normalization algorithms (e.g. [10], [24], <ref> [28] </ref>). These algorithms are initialized with a set of dependencies, e.g. functional dependencies. They result in a set of relation types in a specific normal form. Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types.
Reference: [29] <author> Y. Zhang and M.E. Orlowska. </author> <title> A new polynomial time algorithm for BCNF relational database design. </title> <journal> Information Systems, </journal> <volume> 17(2) </volume> <pages> 185-193, </pages> <year> 1992. </year> <month> 13 </month>
Reference-contexts: As a consequence, these strategies ignore the integrity rules (constraints) specified in the conceptual data model. Profile-based evolution strategies are thus unable to find internal representations in a specific normal form, such as BCNF (e.g. <ref> [29] </ref>) and ONF (e.g. [17]). Although we are interested in finding efficient internal representations, rather than internal representations in a specific normal form, it is desirable allowing a database designer to combine profile-based evolution strategies with evolution strategies converging to normal forms. <p> Grouping algorithms (e.g. [17], [22], [9]). The input of these algorithms is a conceptual data model consisting of fact types. These fact types are grouped together in relation types, thus producing a set of relation types in a specific normal form. Preparatory algorithms (e.g. [13], [12], <ref> [29] </ref>). The input and output of these algorithms is a conceptual data model. <p> As an example, for the ONF algorithm [17] a join rule would be to join unique single predicators (see definition 2.4). Following the approach from [13], [12] and <ref> [29] </ref>, the evolution strategies resulting from grouping algorithms may be improved by preparatory transformations of the conceptual model. 4 Conclusions In this paper we considered the problem of finding suitable internal representations for a given conceptual data model.
References-found: 29

