URL: ftp://ftp.cs.utah.edu/techreports/1996/UUCS-96-004.ps.Z
Refering-URL: ftp://ftp.cs.utah.edu/techreports/1996/index.html
Root-URL: 
Email: flux@cs.utah.edu  
Title: D R A F T UUCS-96-004 Microkernels Meet Recursive Virtual Machines  
Author: Bryan Ford Mike Hibler Jay Lepreau Patrick Tullmann Godmar Back Shantanu Goel Steven Clawson 
Date: May 10, 1996  
Web: http://www.cs.utah.edu/projects/flux/  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: This paper describes a novel approach to providing modular and extensible operating system functionality, and encapsulated environments, based on a synthesis of micro-kernel and virtual machine concepts. We have developed a virtualizable architecture that allows recursive virtual machines (virtual machines running on other virtual machines) to be efficiently implemented, in software, by a microkernel running on generic hardware. A complete virtual machine interface is provided at each level; efficiency derives from needing to implement only new functionality at each level. This infrastructure allows common OS functionality, such as process management, demand paging, fault tolerance, and debugging support, to be provided by cleanly modularized, independent, stackable virtual machine monitors, implemented as ordinary user processes. It can also provide uncommon or unique OS features, including the above features specialized for particular applications' needs, or virtual machines transparently distributed cross-node, or security monitors that allow arbitrary untrusted binaries to be safely executed. Our prototype implementation of this model indicates that it is practical to modularize operating systems this way: some types of virtual machine layers impose almost no overhead at all, while others impose some overhead (typically 10-20%), but only on certain classes of applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Batlivala, B. Gleeson, J. Hamrick, S. Lurndal, D. Price, and J. Soddy. </author> <title> Experience with SVR4 over Chorus. </title> <booktitle> In Proc. of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 223-241, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [2, 13, 30, 35, 6]. Microkernels <ref> [18, 1] </ref> attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode.
Reference: [2] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fiuczynski, D. Becker, C. Chambers, and S. Eg-gers. </author> <title> Extensibility, safety, and performance in the SPIN operating system. </title> <booktitle> In Proc. of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [2, 13, 30, 35, 6] </ref>. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode.
Reference: [3] <author> A. C. Bomberger and N. </author> <title> Hardy. </title> <booktitle> The KeyKOS nanok-ernel architecture. In Proc. of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 95-112, </pages> <address> Seattle, WA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: We believe that the careful working out of domain-specific inter-layer protocols is complementary to our RVM work: the high-level component of our VM (the common protocols) could use those protocols for each class of functionality it provides. A few existing operating systems, such as KeyKOS <ref> [3] </ref> and L3 [34] have implemented checkpointing on a whole-machine basis in the kernel. <p> or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 [33, 35], and KeyKOS <ref> [20, 3] </ref>. This API is designed to support recursive virtual machines efficiently by ensuring that it is not necessary for every virtual machine layer to interpose on and simulate primitive operations such as I/O instructions, page table management, etc.
Reference: [4] <author> T. C. Bressoud and F. B. Schneider. </author> <title> Hyporvisor-based fault-tolerance. </title> <booktitle> In Proc. of the Fifteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 1-11, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: In fact, in their heyday, VMs were not driven by modularity issues at all. They were created to make better use of scarce, expensive hardware resources. 3 Recently, a hypervisor was used to provide fault toler-ance (replication) on a whole-machine basis on PA-RISC machines <ref> [4] </ref>. This application of virtual machines can be approximately compared with our application of RVMs to provide a different form of fault tolerance (checkpointing). <p> Limiting the instruction set this way avoids the need to emulate instructions, and makes it possible to implement the virtualizable architecture even on processor architectures such as the PA-RISC, x86, or MIPS, which don't fully support virtual machines based on raw hardware interfaces <ref> [4] </ref>. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 [33, 35], and KeyKOS [20, 3].
Reference: [5] <author> M. I. Bushnell. </author> <title> Towards a new strategy of OS design. </title> <booktitle> In GNU's Bulletin, </booktitle> <address> Cambridge, MA, </address> <month> Jan. </month> <year> 1994. </year> <note> Also http://www.cs.pdx.edu/trent/gnu/hurd-paper.html. </note>
Reference-contexts: Our kernel object model, in which kernel objects are associated with chunks of user memory, are reminiscent of tagged processor architectures such as System 38 [31] and the Intel i960XA. The design of our high-level Unix emulation environment borrows heavily from existing Mach-based multiservers, especially the GNU Hurd <ref> [5] </ref>. 3 Machine Architecture Our virtualizable architecture consists of three components: First, the extended architecture incorporates only the unprivileged, non-sensitive [17] subset of an existing instruction set architecture. <p> Filesystem interface. The file system interface in our system is similar to those of other microkernel-based operating systems that support independent file servers, such as Spring [27] and the GNU Hurd <ref> [5] </ref>. It provides methods closely corresponding to POSIX file I/O calls, such as open, link, unlink, rename, mkdir, etc. Memory Management interface. The Common Protocols memory interface exports memory segment and pool abstractions.
Reference: [6] <author> P. Cao, E. W. Felten, and K. Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, Nov. 1994. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [2, 13, 30, 35, 6] </ref>. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode.
Reference: [7] <author> J. Carter, J. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proc. of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <address> Asilomar, CA, </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: DMMs could be implemented to support different coherency models; however, the kernel architecture is designed to be able to support release-consistent DSM <ref> [7] </ref> particularly well. Since all of the kernel objects in use by its subtasks, such as mutexes and condition variables, are fully visible to it, the DMM should have the perfect tools.
Reference: [8] <author> J. Carter, D. Khandekar, and L. Kamb. </author> <title> Distributed shared memory: Where we are and where we should be headed. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 119-122, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Specialized memory managers are easy to provide in our system. Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory <ref> [8, 26] </ref> (DSM) and security against untrusted applications [43]. However, these systems only directly support applications running in a single logical protection domain.
Reference: [9] <author> D. R. Cheriton and K. J. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 179-193. </pages> <publisher> USENIX Association, </publisher> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. The ability to export and re-create all kernel object state appears very similar to the Cache Kernel's <ref> [9] </ref> abilities in that area. Our kernel object model, in which kernel objects are associated with chunks of user memory, are reminiscent of tagged processor architectures such as System 38 [31] and the Intel i960XA. <p> architectures such as the PA-RISC, x86, or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel <ref> [9] </ref>, L3/L4 [33, 35], and KeyKOS [20, 3]. This API is designed to support recursive virtual machines efficiently by ensuring that it is not necessary for every virtual machine layer to interpose on and simulate primitive operations such as I/O instructions, page table management, etc.
Reference: [10] <author> G. Deconinck, J. Vounckx, R. Cuyvers, and R. Lauw-ereins. </author> <title> Survey of checkpointing and rollback techniques. </title> <institution> Technical Report O3.1.8 and O3.1.12, ESAT-ACCA Laboratory Katholieke Universiteit Leuven, Belgium, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This algorithm, of course, will not scale well to large checkpointed applications or environments, or to distributed environments. However, more efficient single process checkpointers based on well-known algorithms <ref> [12, 10] </ref> could also be implemented in our environment, in the same way. Checkpointing memory Because the checkpointer interposes on the memory allocation interface, it has specific knowledge of what memory the application has asked for and what memory it is using.
Reference: [11] <author> R. P. Draves. </author> <title> A revised ipc interface. </title> <booktitle> In Proc. of the USENIX Mach Workshop, </booktitle> <pages> pages 101-121, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 <ref> [11] </ref>. The ability to export and re-create all kernel object state appears very similar to the Cache Kernel's [9] abilities in that area.
Reference: [12] <author> E. N. Elnoxzahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 39-47, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This algorithm, of course, will not scale well to large checkpointed applications or environments, or to distributed environments. However, more efficient single process checkpointers based on well-known algorithms <ref> [12, 10] </ref> could also be implemented in our environment, in the same way. Checkpointing memory Because the checkpointer interposes on the memory allocation interface, it has specific knowledge of what memory the application has asked for and what memory it is using.
Reference: [13] <author> D. R. Engler, M. F. Kaashoek, and J. O. Jr. Exoker-nel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proc. of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [2, 13, 30, 35, 6] </ref>. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode. <p> Furthermore, although file system access and other system call-based activity can be monitored and virtualized this way, it would be difficult to virtualize other resources such as CPU and memory. The Exokernel <ref> [13] </ref> project's work is orthogonal, and possibly complementary, to ours. They're defining where the supervisor boundary is; we don't care where that boundary is, but only about the compositional functionality above it.
Reference: [14] <author> B. Ford and M. Hibler. Fluke: </author> <title> Flexible -kernel environment application programming interface reference (draft). </title> <type> 121 pp. </type> <institution> University of Utah. </institution> <note> Available as ftp://mancos.cs.utah.edu/papers/sa-flukeref.ps.gz and http://www.cs.utah.edu/projects/flux/fluke/html/- sa-flukeref/ (HTML format), </note> <year> 1996. </year>
Reference-contexts: Limiting the instruction set this way avoids the need to emulate instructions, and makes it possible to implement the virtualizable architecture even on processor architectures such as the PA-RISC, x86, or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API <ref> [14] </ref> (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 [33, 35], and KeyKOS [20, 3].
Reference: [15] <author> B. A. Ford and S. Susarla. </author> <title> Flexible multi-policy scheduling based on cpu inheritance. </title> <note> Submitted for publication., </note> <month> May </month> <year> 1996. </year>
Reference-contexts: The scheduling hierarchy normally follows the virtual machine hierarchy, in a loose sense, but is not required to. The higher-level common protocols determine the actual scheduling hierarchy. The details of scheduling under Fluke <ref> [15] </ref> are beyond the scope of this paper; only its relative, hierarchical nature is important to the RVM model.
Reference: [16] <author> R. P. Goldberg. </author> <title> Architecture of virtual machines. </title> <booktitle> In AFIPS Conf. Proc., </booktitle> <month> June </month> <year> 1973. </year>
Reference-contexts: For example, the most well-known virtual machine system, VM/370 [22, 23], provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. However, special virtualiz-able (firmware/hardware) architectures <ref> [16, 29] </ref> have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. This paper presents a new approach to OS extensibility which combines both microkernel and virtual machine concepts in one system. <p> For example, our hierarchical memory remapping mechanism has similarities to (and is inspired by) that of L4 [35], and appears to provide precisely the f-map semantics defined in the recursive virtual machine literature <ref> [16, 17] </ref>, our hierarchical scheduling mechanism is comparable to KeyKOS's meters [20], or lottery/stride scheduling's currencies [44]. The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. <p> This composition mechanism is similar to the f-maps described in the recursive virtual machine literature <ref> [16] </ref>. The kernel's memory remapping mechanism provides the basic relative memory support needed to implement nested processes.
Reference: [17] <author> R. P. Goldberg. </author> <title> Survey of virtual machine reseach. </title> <journal> IEEE Computer Magazine, </journal> <pages> pages 34-45, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [2, 13, 30, 35, 6]. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode. Recursive virtual machines <ref> [17] </ref>, on the other hand, allow operating systems to be decomposed vertically, by implementing OS functionality in stackable virtual machine monitors, each of which exports a virtual machine interface compatible with the real machine interface on which they themselves run. <p> For example, our hierarchical memory remapping mechanism has similarities to (and is inspired by) that of L4 [35], and appears to provide precisely the f-map semantics defined in the recursive virtual machine literature <ref> [16, 17] </ref>, our hierarchical scheduling mechanism is comparable to KeyKOS's meters [20], or lottery/stride scheduling's currencies [44]. The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. <p> The design of our high-level Unix emulation environment borrows heavily from existing Mach-based multiservers, especially the GNU Hurd [5]. 3 Machine Architecture Our virtualizable architecture consists of three components: First, the extended architecture incorporates only the unprivileged, non-sensitive <ref> [17] </ref> subset of an existing instruction set architecture. <p> Since demand paging is implemented as a separate component instead of being lumped with other features such as multiuser security, it is much easier to avoid problems with traditional virtual machine monitors related to duplication of effort, such as double paging <ref> [17, 37] </ref>. Our prototype memory manager (MM) is implemented as an ordinary user-space application program, which loads and runs another application program (specified on the MM's command line) in a virtual memory environment.
Reference: [18] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> Unix as an application program. </title> <booktitle> In Proc. of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 87-96, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [2, 13, 30, 35, 6]. Microkernels <ref> [18, 1] </ref> attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode.
Reference: [19] <author> G. Hamilton, M. L. Powell, and J. J. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: Sub-systems supporting stackable and interposable functionality in a particular domain have been an active area of research and development for many years: Jones [24] gives a long list of them. Recent work has benefited from object-oriented structuring, including work on Spring's subcontracts <ref> [19] </ref> and filesystems [27]. We believe that the careful working out of domain-specific inter-layer protocols is complementary to our RVM work: the high-level component of our VM (the common protocols) could use those protocols for each class of functionality it provides.
Reference: [20] <author> N. </author> <title> Hardy. </title> <booktitle> The keykos architecture. Operating Systems Review, </booktitle> <month> September </month> <year> 1985. </year>
Reference-contexts: For example, our hierarchical memory remapping mechanism has similarities to (and is inspired by) that of L4 [35], and appears to provide precisely the f-map semantics defined in the recursive virtual machine literature [16, 17], our hierarchical scheduling mechanism is comparable to KeyKOS's meters <ref> [20] </ref>, or lottery/stride scheduling's currencies [44]. The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. <p> or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 [33, 35], and KeyKOS <ref> [20, 3] </ref>. This API is designed to support recursive virtual machines efficiently by ensuring that it is not necessary for every virtual machine layer to interpose on and simulate primitive operations such as I/O instructions, page table management, etc. <p> The higher-level common protocols determine the actual scheduling hierarchy. The details of scheduling under Fluke [15] are beyond the scope of this paper; only its relative, hierarchical nature is important to the RVM model. Other hierarchical schedulers, such as the meter system in KeyKos <ref> [20] </ref>, and lottery/stride scheduling [44], should also work in our RVM model. 4.6 Security The Fluke kernel currently contains no special security mechanisms; all low-level support for security is integrated into the other primitives exported by the kernel.
Reference: [21] <author> K. Harty and D. Cheriton. </author> <title> Application-controled physical memory using external page-cache management. </title> <booktitle> In Proc. of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 187-199, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Application-specific specialization is often desirable; it has been shown that specialized virtual memory management can yield substantially better performance <ref> [30, 21, 25] </ref> for certain applications which access memory in an unusual fashion (garbage collectors, object stores, relational database systems, some numeric applications). Specialized memory managers are easy to provide in our system.
Reference: [22] <institution> Ibm virtual machine facility /370 planning guide. </institution> <type> Technical Report GC20-1801-0, </type> <institution> IBM Corporation, </institution> <year> 1972. </year>
Reference-contexts: Traditionally, virtual machines have been implemented on and export existing hardware architectures so they can support existing naive operating systems. (see Figure 1). For example, the most well-known virtual machine system, VM/370 <ref> [22, 23] </ref>, provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. However, special virtualiz-able (firmware/hardware) architectures [16, 29] have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently.
Reference: [23] <institution> Ibm virtual machine facility /370: </institution> <note> Release 2 planning guide. Technical Report GC20-1814-0, </note> <institution> IBM Corporation, </institution> <year> 1973. </year> <month> 14 </month>
Reference-contexts: Traditionally, virtual machines have been implemented on and export existing hardware architectures so they can support existing naive operating systems. (see Figure 1). For example, the most well-known virtual machine system, VM/370 <ref> [22, 23] </ref>, provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. However, special virtualiz-able (firmware/hardware) architectures [16, 29] have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently.
Reference: [24] <author> M. Jones. </author> <title> Interposition agents: Transparently inter-posing user code at the system interface. </title> <booktitle> In Proc. of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 80-93, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: System call emulation and interposition have been used in the past to interpose special software modules between an application and the OS on which it is running. This form of interposition can be used, for example, to trace system calls or change the process's view of the file system <ref> [24] </ref>, or to provide security against an untrusted application [43]. However, these mechanisms can only be applied easily in the scope of a single application process, and generally cannot be used together (i.e., only one interposition module can be used for a given application). <p> Both systems support the ability for applications to have specialized environments, but in ExOS the application binary is modified by linking in OS library code. Sub-systems supporting stackable and interposable functionality in a particular domain have been an active area of research and development for many years: Jones <ref> [24] </ref> gives a long list of them. Recent work has benefited from object-oriented structuring, including work on Spring's subcontracts [19] and filesystems [27].
Reference: [25] <author> A. V. K. Krueger, D. Loftesness and T. Anderson. </author> <title> Tools for the development of application-specific virtual memory management. </title> <booktitle> In Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Application-specific specialization is often desirable; it has been shown that specialized virtual memory management can yield substantially better performance <ref> [30, 21, 25] </ref> for certain applications which access memory in an unusual fashion (garbage collectors, object stores, relational database systems, some numeric applications). Specialized memory managers are easy to provide in our system.
Reference: [26] <author> P. Keleher, A. L. Cox, S. Dwarkadas, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> In Proc. of hte 1994 Winter USENIX Conference, </booktitle> <pages> pages 115-132, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Specialized memory managers are easy to provide in our system. Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory <ref> [8, 26] </ref> (DSM) and security against untrusted applications [43]. However, these systems only directly support applications running in a single logical protection domain.
Reference: [27] <author> Y. A. Khalidi and M. N. Nelson. </author> <title> Extensible file systems in Spring. </title> <booktitle> In Proc. of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 1-14, </pages> <year> 1993. </year>
Reference-contexts: Sub-systems supporting stackable and interposable functionality in a particular domain have been an active area of research and development for many years: Jones [24] gives a long list of them. Recent work has benefited from object-oriented structuring, including work on Spring's subcontracts [19] and filesystems <ref> [27] </ref>. We believe that the careful working out of domain-specific inter-layer protocols is complementary to our RVM work: the high-level component of our VM (the common protocols) could use those protocols for each class of functionality it provides. <p> Filesystem interface. The file system interface in our system is similar to those of other microkernel-based operating systems that support independent file servers, such as Spring <ref> [27] </ref> and the GNU Hurd [5]. It provides methods closely corresponding to POSIX file I/O calls, such as open, link, unlink, rename, mkdir, etc. Memory Management interface. The Common Protocols memory interface exports memory segment and pool abstractions.
Reference: [28] <author> C. Landau. </author> <title> The checkpoint mechanism in keykos. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: By loading a checkpointer in the root virtual machine immediately on top of the microkernel, a whole-machine check-pointed system can be created similar to that provided in the kernel by KeyKOS <ref> [28] </ref> and L3 [33]. To our knowledge this is the first checkpointer that can operate over arbitrary domains in this way.
Reference: [29] <author> H. C. Lauer and D. Wyeth. </author> <title> A recursive virtual machine architecture. </title> <booktitle> In ACM SIGARCH-SIGOPS Workshop on Virtual Computer Systems, </booktitle> <pages> pages 113-116, </pages> <month> March </month> <year> 1973. </year>
Reference-contexts: For example, the most well-known virtual machine system, VM/370 [22, 23], provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. However, special virtualiz-able (firmware/hardware) architectures <ref> [16, 29] </ref> have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. This paper presents a new approach to OS extensibility which combines both microkernel and virtual machine concepts in one system.
Reference: [30] <author> C. H. Lee, M. C. Chen, and R. C. Chang. </author> <title> HiPEC: High performance external virtual memory caching. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 153-164, </pages> <address> Monterey, CA, Nov. 1994. </address> <publisher> USENIX Association. </publisher>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [2, 13, 30, 35, 6] </ref>. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode. <p> Application-specific specialization is often desirable; it has been shown that specialized virtual memory management can yield substantially better performance <ref> [30, 21, 25] </ref> for certain applications which access memory in an unusual fashion (garbage collectors, object stores, relational database systems, some numeric applications). Specialized memory managers are easy to provide in our system.
Reference: [31] <author> H. M. Levy. </author> <title> Capability Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: The capability model we use for communication is of course extremely well-known <ref> [31] </ref>; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. The ability to export and re-create all kernel object state appears very similar to the Cache Kernel's [9] abilities in that area. <p> The ability to export and re-create all kernel object state appears very similar to the Cache Kernel's [9] abilities in that area. Our kernel object model, in which kernel objects are associated with chunks of user memory, are reminiscent of tagged processor architectures such as System 38 <ref> [31] </ref> and the Intel i960XA.
Reference: [32] <editor> J. Liedtke. Clans and chiefs. </editor> <booktitle> In Proceedings 12. GI/ITG-Fachtagung Architektur von Rechensys-temen, </booktitle> <year> 1992. </year>
Reference-contexts: It is worth noting that some other kernel-level security models are likely also to be compatible with the RVM model, such as the Clan/Chief model used in L3 <ref> [32] </ref>, or the hierarchical subject-based security model used in VSTa [42]. 5 High-level Protocols In order to demonstrate how our model can be applied to real systems, we have implemented a partial POSIX environment on top of the Fluke kernel, using VMMs to provide traditional Unix kernel features, such as process
Reference: [33] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: as the PA-RISC, x86, or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 <ref> [33, 35] </ref>, and KeyKOS [20, 3]. This API is designed to support recursive virtual machines efficiently by ensuring that it is not necessary for every virtual machine layer to interpose on and simulate primitive operations such as I/O instructions, page table management, etc. <p> By loading a checkpointer in the root virtual machine immediately on top of the microkernel, a whole-machine check-pointed system can be created similar to that provided in the kernel by KeyKOS [28] and L3 <ref> [33] </ref>. To our knowledge this is the first checkpointer that can operate over arbitrary domains in this way.
Reference: [34] <author> J. Liedtke. </author> <title> A persistent system in real use experiences of the first 13 years. </title> <booktitle> In Proc. of the Third International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 2-11, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: We believe that the careful working out of domain-specific inter-layer protocols is complementary to our RVM work: the high-level component of our VM (the common protocols) could use those protocols for each class of functionality it provides. A few existing operating systems, such as KeyKOS [3] and L3 <ref> [34] </ref> have implemented checkpointing on a whole-machine basis in the kernel.
Reference: [35] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proc. of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 237-250, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [2, 13, 30, 35, 6] </ref>. Microkernels [18, 1] attempt to decompose operating systems horizontally, by moving traditional kernel functionalityinto servers running in user mode. <p> Our system borrows many design concepts and abstractions from other systems, suitably modified to support the RVM model, as described in the following sections. For example, our hierarchical memory remapping mechanism has similarities to (and is inspired by) that of L4 <ref> [35] </ref>, and appears to provide precisely the f-map semantics defined in the recursive virtual machine literature [16, 17], our hierarchical scheduling mechanism is comparable to KeyKOS's meters [20], or lottery/stride scheduling's currencies [44]. <p> as the PA-RISC, x86, or MIPS, which don't fully support virtual machines based on raw hardware interfaces [4]. 1 Second, a low-level API [14] (implemented by the mi-crokernel) provides simple memory management, scheduling, and IPC primitives similar to those of conventional small microkernels such as the V++ CacheKernel [9], L3/L4 <ref> [33, 35] </ref>, and KeyKOS [20, 3]. This API is designed to support recursive virtual machines efficiently by ensuring that it is not necessary for every virtual machine layer to interpose on and simulate primitive operations such as I/O instructions, page table management, etc.
Reference: [36] <author> M. Litzkow and M. Solomon. </author> <title> Supporting checkpoint-ing and process migration outside the unix kernel. </title> <booktitle> In Proc. of the Winter 1992 USENIX Conference, </booktitle> <year> 1992. </year>
Reference-contexts: A checkpointer can choose to interpose on as many potential external references as it likes. Our implementation chooses to interpose on those things necessary for a minimal complete checkpoint, comparable to the functionality offered by other user-level checkpointers <ref> [36, 40] </ref>. These are library-based checkpointers, which require re-linking of the application in order to interpose on its system calls. Standard I/O.
Reference: [37] <author> J. H. </author> <month> March. </month> <title> The design and implementation of a virtual machine operating system using a virtual access method. </title> <booktitle> In AFIPS Conf. Proc., </booktitle> <month> June </month> <year> 1973. </year>
Reference-contexts: Since demand paging is implemented as a separate component instead of being lumped with other features such as multiuser security, it is much easier to avoid problems with traditional virtual machine monitors related to duplication of effort, such as double paging <ref> [17, 37] </ref>. Our prototype memory manager (MM) is implemented as an ordinary user-space application program, which loads and runs another application program (specified on the MM's command line) in a virtual memory environment.
Reference: [38] <author> L. McVoy and C. Staelin. lmbench: </author> <title> Portable tools for performance analysis. </title> <booktitle> In Proc. of 1996 USENIX Conference, </booktitle> <pages> page xxx, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: words, the CP conventions provide information as to how much memory must be synchronized when a given mutex or condition variable is used. 7 Experimental Results In order to evaluate the performance effects of recursive virtual machines in our system, we used micro benchmarks, some drawn from the lmbench suite <ref> [38] </ref>. These benchmarks are designed to reveal the performance properties of operating systems that directly affect real-world applications. <p> For reference, we also show lmbench performance results for Linux, taken from the original lmbench paper <ref> [38] </ref>. Note that the Linux tests were made on a faster machine (120MHz Pentium) than we used in our tests (100MHz Pentium). Also, since Linux is a mature, well-optimized monolithic kernel while Fluke is a mostly unoptimized microkernel, the performance results for OS-intensive tests are not very comparable.
Reference: [39] <institution> National Computer Security Center. Department of Defense Trusted Computer System Evaluation Criteria. </institution> <year> 1985. </year> <note> DoD 5200.28-STD. </note>
Reference-contexts: This suffices for many environments. However, to satisfy the most demanding security-assurance needs such as the most stringent of the TCSEC <ref> [39] </ref> classes, it appears important to provide explicit support for traditional subject-based security. We are working with others who are adding such support to Fluke. Our intent is to provide a means to virtualize the ensuing security identifiers, preserving the relativistic property of the interface.
Reference: [40] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. Libckpt: </author> <title> Transparent checkpointing under unix. </title> <booktitle> In Proc. of the Winter 1995 USENIX Technical Conference, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: A checkpointer can choose to interpose on as many potential external references as it likes. Our implementation chooses to interpose on those things necessary for a minimal complete checkpoint, comparable to the functionality offered by other user-level checkpointers <ref> [36, 40] </ref>. These are library-based checkpointers, which require re-linking of the application in order to interpose on its system calls. Standard I/O.
Reference: [41] <author> G. J. Popek and C. Kline. </author> <title> Verifiable secure operating systems software. </title> <booktitle> In AFIPS Conf. Proc., </booktitle> <month> June </month> <year> 1973. </year>
Reference-contexts: However, Java requires the use of a special language, and recently uncovered bugs have demonstrated that the implementation of the runtime security mechanisms is error prone. Virtual machines can provide strong isolation guarantees between subsystems <ref> [41] </ref>, addressing denial-of-service attacks and information leaks through covert channels as well as providing a clean separation between different pieces of mobile code (Applets). Such isolation can also be useful for resource reservation, such as guaranteeing a certain amount of physical memory to real-time applications.
Reference: [42] <author> A. </author> <title> Valencia. An overview of the vsta micro-kernel. </title> <address> http://www.igcom.net/ jeske/VSTa/- vsta intro.html. </address>
Reference-contexts: It is worth noting that some other kernel-level security models are likely also to be compatible with the RVM model, such as the Clan/Chief model used in L3 [32], or the hierarchical subject-based security model used in VSTa <ref> [42] </ref>. 5 High-level Protocols In order to demonstrate how our model can be applied to real systems, we have implemented a partial POSIX environment on top of the Fluke kernel, using VMMs to provide traditional Unix kernel features, such as process management and demand-paged memory, although in a more flexible way.
Reference: [43] <author> D. Wagner, I. Goldberg, and R. Thomas. </author> <title> A secure environment for untrusted helper applications. </title> <booktitle> In Proc. of the 6th USENIX Unix Security Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: Specialized memory managers are easy to provide in our system. Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory [8, 26] (DSM) and security against untrusted applications <ref> [43] </ref>. However, these systems only directly support applications running in a single logical protection domain. In a recursive virtual machine, any process can create further nested subprocesses which are com 2 pletely encapsulated within the parent's virtual machine, making them invisible to entities outside the parent. <p> This form of interposition can be used, for example, to trace system calls or change the process's view of the file system [24], or to provide security against an untrusted application <ref> [43] </ref>. However, these mechanisms can only be applied easily in the scope of a single application process, and generally cannot be used together (i.e., only one interposition module can be used for a given application).
Reference: [44] <author> C. Waldspurger. </author> <title> Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management. </title> <type> PhD thesis, </type> <institution> Massachusettes Institute of Technology, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: For example, our hierarchical memory remapping mechanism has similarities to (and is inspired by) that of L4 [35], and appears to provide precisely the f-map semantics defined in the recursive virtual machine literature [16, 17], our hierarchical scheduling mechanism is comparable to KeyKOS's meters [20], or lottery/stride scheduling's currencies <ref> [44] </ref>. The capability model we use for communication is of course extremely well-known [31]; many of the details of 4 the design and the terminology we use are borrowed from Mach 3.0 [11]. <p> The higher-level common protocols determine the actual scheduling hierarchy. The details of scheduling under Fluke [15] are beyond the scope of this paper; only its relative, hierarchical nature is important to the RVM model. Other hierarchical schedulers, such as the meter system in KeyKos [20], and lottery/stride scheduling <ref> [44] </ref>, should also work in our RVM model. 4.6 Security The Fluke kernel currently contains no special security mechanisms; all low-level support for security is integrated into the other primitives exported by the kernel.
Reference: [45] <author> M. V. Wilkes and R. M. Needham. </author> <title> The Cambridge CAP Computer and its Operating System. </title> <publisher> North Hol-land, </publisher> <address> NY, </address> <year> 1979. </year> <month> 15 </month>
Reference-contexts: This doesn't mean that the Unix process model isn't usefulin fact, it is very useful, but cannot provide the control needed for the extensibility provided by RVMs. The Cambridge CAP computer <ref> [45] </ref> implements a hardware (microcode) architecture that comes fairly close to providing a nested process model. It supports an arbitrarily-deep process hierarchy, in which parent processes can completely virtualize the memory and CPU usage of their child processes, as well as trap and system call handlers for their children. <p> Since these are microkernel-mediated capabilities and therefore not directly accessible to any user process, they can be passed freely between RVM layers, without compromising anyone's security. This contrasts with the Cam-bridge CAP computer <ref> [45] </ref>, for example, in which capabilities could not be passed between process hierarchy layers because the bits representing a capability in one process are directly accessible to the code running in its parent process.
References-found: 45

