URL: http://http.cs.berkeley.edu/~zhendong/ps/tacas98.ps
Refering-URL: http://http.cs.berkeley.edu/~zhendong/links/papers.html
Root-URL: 
Title: Detecting Races in Relay Ladder Logic Programs  
Author: Alexander Aiken Manuel Fahndrich and Zhendong Su 
Note: RLL programs that are difficult to find by other techniques.  
Address: Berkeley  
Affiliation: EECS Department University of California,  
Abstract: Relay Ladder Logic (RLL) [4] is a programming language widely used for complex embedded control applications such as manufacturing and amusement park rides. The cost of bugs in RLL programs is extremely high, often measured in millions of dollars (for shutting down a factory) or human safety (for rides). In this paper, we describe our experience in applying constraint-based program analysis techniques to analyze production RLL programs. Our approach is an interesting combination of probabilistic testing and program analysis, and we show that our system is able to detect bugs with high probability, up to the approximations made by the conservative program analysis. We demonstrate that our analysis is useful in detecting some flaws in production 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers, Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Relay races are particularly difficult to detect by traditional testing techniques, as races can depend on the timing of external events and the scan rate. Our analysis generalizes traditional data flow analyses <ref> [1] </ref>. Instead of data flow equations, set constraints [16, 2, 3] are used. Set constraints are more expressive than data flow equations because the constraints can model not only data flow but also control flow of a program. Our analysis consists of two steps. <p> Data Flow Analysis Data flow analysis is used primarily in optimizing compilers to collect variable usage information for optimizations such as dead code elimination and register allocation <ref> [1] </ref>. It has also been applied for ensuring software reliability [14, 15]. Our approach differs from classical data flow analysis in two points. First, we use conditional constraints [3], which are essential for modeling both the boolean instructions and control flow instructions.
Reference: 2. <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Tested on real RLL programs, the analysis found several such races, including one known bug that originally costed approximately $750,000 in factory down-time [5]. Our analysis is constraint-based, meaning that the information we wish to know about a program is expressed as constraints <ref> [16, 2, 3] </ref>. The solutions of these constraints yield the desired information. Our analysis is built using a general constraint resolution engine, which allows us to implement the analysis directly in the same natural form it is specified. Constraint-based program analysis is discussed further in Section 2. <p> Relay races are particularly difficult to detect by traditional testing techniques, as races can depend on the timing of external events and the scan rate. Our analysis generalizes traditional data flow analyses [1]. Instead of data flow equations, set constraints <ref> [16, 2, 3] </ref> are used. Set constraints are more expressive than data flow equations because the constraints can model not only data flow but also control flow of a program. Our analysis consists of two steps.
Reference: 3. <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Tested on real RLL programs, the analysis found several such races, including one known bug that originally costed approximately $750,000 in factory down-time [5]. Our analysis is constraint-based, meaning that the information we wish to know about a program is expressed as constraints <ref> [16, 2, 3] </ref>. The solutions of these constraints yield the desired information. Our analysis is built using a general constraint resolution engine, which allows us to implement the analysis directly in the same natural form it is specified. Constraint-based program analysis is discussed further in Section 2. <p> Relay races are particularly difficult to detect by traditional testing techniques, as races can depend on the timing of external events and the scan rate. Our analysis generalizes traditional data flow analyses [1]. Instead of data flow equations, set constraints <ref> [16, 2, 3] </ref> are used. Set constraints are more expressive than data flow equations because the constraints can model not only data flow but also control flow of a program. Our analysis consists of two steps. <p> The domain is a finite lattice with " and [ being the meet and join respectively. The semantics of the expression language is given in Figure 2. Conditional expressions deserve some discussion. Conditional expressions are used for accurately modeling flow-of-control (see e.g., <ref> [3] </ref>). In the context of RLL, they can be used to express boolean relations very directly. <p> It has also been applied for ensuring software reliability [14, 15]. Our approach differs from classical data flow analysis in two points. First, we use conditional constraints <ref> [3] </ref>, which are essential for modeling both the boolean instructions and control flow instructions. Second, the use of constraints gives us the flexibility to analyze many input configurations by adding constraints to a base system, instead of performing a global dataflow analysis repeatedly.
Reference: 4. <author> Allen-Bradley, </author> <title> Rockwell Automation. SLC 500 and MicroLogix 1000 Instruction Set. </title>
Reference: 5. <author> A. Barrett. </author> <title> Private communication. </title>
Reference-contexts: Relay Ladder Logic (RLL) is the most widely used PLC programming language; approximately 50% of the manufacturing capacity in the United States is programmed in RLL <ref> [5] </ref>. RLL has long been criticized for its low level design, which makes it difficult to write correct programs [18]. Moreover, validation of RLL programs is extremely expensive, often measured in millions of dollars (for factory down-time) or human safety (for rides). <p> Our most interesting result is an analysis to detect certain race conditions in RLL programs. Tested on real RLL programs, the analysis found several such races, including one known bug that originally costed approximately $750,000 in factory down-time <ref> [5] </ref>. Our analysis is constraint-based, meaning that the information we wish to know about a program is expressed as constraints [16, 2, 3]. The solutions of these constraints yield the desired information.
Reference: 6. <author> M. Browne, E.M. Clarke, and D. Dill. </author> <title> Checking the correctness of sequential circuits. </title> <booktitle> In Proc. IEEE Internat. Conf. on Computer Design, </booktitle> <pages> pages 545-548, </pages> <year> 1985. </year>
Reference-contexts: Model Checking Model checking [9, 10] is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols <ref> [6, 7, 12, 17, 11] </ref>. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches. Because even these finite state spaces may be huge, model checking is usually applied to some abstract models of the actual system.
Reference: 7. <author> M. Browne, E.M. Clarke, D. Dill, and B. Mishra. </author> <title> Automatic verification of sequential circuits using temporal logic. </title> <journal> IEEE Trans. Comput., </journal> <volume> 35(12) </volume> <pages> 1035-1044, </pages> <year> 1986. </year>
Reference-contexts: Model Checking Model checking [9, 10] is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols <ref> [6, 7, 12, 17, 11] </ref>. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches. Because even these finite state spaces may be huge, model checking is usually applied to some abstract models of the actual system.
Reference: 8. <author> R.H. Carver and R. Durham. </author> <title> Integrating formal methods and testing for concurrent programs. </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance, </booktitle> <pages> pages 25-33, </pages> <address> New York, NY, USA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: An abstract model is also advantageous when it is very difficult or very expensive to test the actual system. Both of these advantages of abstract modeling apply in the case of detecting relay races in RLL programs. <ref> [8] </ref> discusses some other tradeoffs of using the actual system and abstract models of the system for testing. 7 Conclusion In this paper, we have described a relay race analysis for RLL programs to help RLL programmers detect some common programming mistakes.
Reference: 9. <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logics of Programs, </booktitle> <volume> volume 131, </volume> <pages> pages 52-71, </pages> <address> Berlin, 1981. </address> <publisher> Springer. </publisher>
Reference-contexts: Our approach is more efficient because the base system can be solved and simplified once and then used repeatedly on different input configurations. Model Checking Model checking <ref> [9, 10] </ref> is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols [6, 7, 12, 17, 11]. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches.
Reference: 10. <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Our approach is more efficient because the base system can be solved and simplified once and then used repeatedly on different input configurations. Model Checking Model checking <ref> [9, 10] </ref> is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols [6, 7, 12, 17, 11]. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches.
Reference: 11. <author> E.M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D.E. Long, K.L. McMillan, and L.A. Ness. </author> <title> Verification of the futurebus+ cache coherence protocol. </title> <editor> In L. Claesen, editor, </editor> <booktitle> Proceedings of the Eleventh International Symposium on Computer Hardware Description Languages and their Applications, </booktitle> <publisher> North-Holland, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: Model Checking Model checking [9, 10] is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols <ref> [6, 7, 12, 17, 11] </ref>. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches. Because even these finite state spaces may be huge, model checking is usually applied to some abstract models of the actual system.
Reference: 12. <author> D. Dill and E.M. Clarke. </author> <title> Automatic verification of asynchronous circuits using temporal logic. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <volume> volume 133, </volume> <pages> pages 276-282, </pages> <year> 1986. </year>
Reference-contexts: Model Checking Model checking [9, 10] is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols <ref> [6, 7, 12, 17, 11] </ref>. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches. Because even these finite state spaces may be huge, model checking is usually applied to some abstract models of the actual system.
Reference: 13. <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint based program analyses scale. </title> <type> Technical Report UCB/CSD-96-917, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: For example, the number of trials required to find races involving 5 inputs with 95% probability is 200 whether there are 100, 1000, or 10,000 inputs to the program. 5 Experimental Results We have implemented our analysis using a general constraint solver <ref> [13] </ref>. Inputs to our analysis are abstract syntax tree (AST) representations of RLL programs. The ASTs are parsed into internal representations, and constraints are generated using the rules in Figure 3.
Reference: 14. <author> L.D. Fosdick and L.J. Osterweil. </author> <title> Data flow analysis in software reliability. </title> <journal> ACM Computing Surveys, </journal> <volume> 8(3) </volume> <pages> 305-330, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: Data Flow Analysis Data flow analysis is used primarily in optimizing compilers to collect variable usage information for optimizations such as dead code elimination and register allocation [1]. It has also been applied for ensuring software reliability <ref> [14, 15] </ref>. Our approach differs from classical data flow analysis in two points. First, we use conditional constraints [3], which are essential for modeling both the boolean instructions and control flow instructions.
Reference: 15. <author> M.J. Harrold. </author> <title> Using data flow analysis for testing. </title> <type> Technical Report 93-112, </type> <institution> Department of Computer Science, Clemson University, </institution> <year> 1993. </year>
Reference-contexts: Data Flow Analysis Data flow analysis is used primarily in optimizing compilers to collect variable usage information for optimizations such as dead code elimination and register allocation [1]. It has also been applied for ensuring software reliability <ref> [14, 15] </ref>. Our approach differs from classical data flow analysis in two points. First, we use conditional constraints [3], which are essential for modeling both the boolean instructions and control flow instructions.
Reference: 16. <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Tested on real RLL programs, the analysis found several such races, including one known bug that originally costed approximately $750,000 in factory down-time [5]. Our analysis is constraint-based, meaning that the information we wish to know about a program is expressed as constraints <ref> [16, 2, 3] </ref>. The solutions of these constraints yield the desired information. Our analysis is built using a general constraint resolution engine, which allows us to implement the analysis directly in the same natural form it is specified. Constraint-based program analysis is discussed further in Section 2. <p> Relay races are particularly difficult to detect by traditional testing techniques, as races can depend on the timing of external events and the scan rate. Our analysis generalizes traditional data flow analyses [1]. Instead of data flow equations, set constraints <ref> [16, 2, 3] </ref> are used. Set constraints are more expressive than data flow equations because the constraints can model not only data flow but also control flow of a program. Our analysis consists of two steps.
Reference: 17. <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall International Editions, </publisher> <year> 1991. </year>
Reference-contexts: Model Checking Model checking [9, 10] is a branch of formal verification that can be fully automated. Model checking has been used successfully for verifying finite state systems such as hardware and communication protocols <ref> [6, 7, 12, 17, 11] </ref>. Model checkers exploit the finite nature of these systems by performing exhaustive state space searches. Because even these finite state spaces may be huge, model checking is usually applied to some abstract models of the actual system.
Reference: 18. <author> A. Krigman. </author> <title> Relay ladder diagrams: we love them, we love them not. </title> <booktitle> In Tech, </booktitle> <pages> pages 39-47, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Relay Ladder Logic (RLL) is the most widely used PLC programming language; approximately 50% of the manufacturing capacity in the United States is programmed in RLL [5]. RLL has long been criticized for its low level design, which makes it difficult to write correct programs <ref> [18] </ref>. Moreover, validation of RLL programs is extremely expensive, often measured in millions of dollars (for factory down-time) or human safety (for rides). One solution is to replace RLL with a higher-level, safer programming language. An alternative is to provide better programming support directly for RLL.
Reference: 19. <author> D. Lee and M. Yannakakis. </author> <title> Principles and methods of testing finite state machines-a survey. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <pages> pages 1090-1123, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Testing Testing is one of the most commonly used methods for assuring hardware and software quality. The I/O behaviors of the system on input instances are used to deduce whether the given system is faulty or not <ref> [19] </ref>. Testing is non-exhaustive in most cases due to a large or infinite number of test cases. One distinction of our approach from testing is that we work with an abstract model of the actual system. There are advantages and disadvantages to using an abstract model.
Reference: 20. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: However, any relay races the analyzer detects are indeed relay races, and we can prove that a large class of relay races is detected with high probability. We have implemented the race analysis in Standard ML of New Jersey (SML) <ref> [20] </ref>. Our analyzer is accurate and fast enough to be practical|production RLL programs can be analyzed.
Reference: 21. <author> Z. Su. </author> <title> Automatic analysis of relay ladder logic programs. </title> <type> Technical Report UCB/CSD-97-969, </type> <institution> University of California at Berkeley, </institution> <year> 1997. </year>
Reference-contexts: Theorem 1 and Theorem 2 are proven in <ref> [21] </ref>. 4 Relay Race Analysis In this section, we describe our analysis for detecting relay races in RLL programs. In RLL programs, it is desirable if the values of outputs depend solely on the values of inputs and the internal states of timers and counters.
References-found: 21

