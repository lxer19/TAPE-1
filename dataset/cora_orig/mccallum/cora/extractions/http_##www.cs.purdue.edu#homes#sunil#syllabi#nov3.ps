URL: http://www.cs.purdue.edu/homes/sunil/syllabi/nov3.ps
Refering-URL: http://www.cs.purdue.edu/homes/sunil/syllabi/CS690D_Fall98.html
Root-URL: http://www.cs.purdue.edu
Title: Abstract  
Abstract: Spatial joins are one of the most important operations for combining spatial objects of several relations. The efficient processing of a spatial join is extremely important since its execution time is super-linear in the number of spatial objects of the participating relations, and this number of objects may be very high. In this paper, we present a first detailed study of spatial join processing using R-trees, particularly R*-trees. R-trees are very suitable for supporting spatial queries and the R*-tree is one of the most efficient members of the R-tree family. Starting from a straightforward approach, we present several techniques for improving its execution time with respect to both, CPU- and I/O-time. Eventually, we end up with an algorithm whose total execution time is improved over the first approach by an order of magnitude. Using a buffer of reasonable size, I/O-time is almost optimal, i.e. it almost corresponds to the time for reading each required page of the relations exactly once. The performance of the various approaches is investigated in an experimental performance comparison where several large data sets from real applications are used. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Becker, L. A.: </author> <title> A New Algorithm and a Cost Model for Join Processing with Grid Files, </title> <institution> PhD-thesis, University of Siegen, </institution> <year> 1992. </year>
Reference-contexts: However, our basic assumption is that a spatial access method efficiently supports access to the spatial relations. Thus, we are interested in exploiting the spatial access method for an efficient join processing. There are several other approaches for performing joins using multidimensional point access methods, e.g. grid files <ref> [1] </ref> and kd-trees [11]. These methods can be used for spatial joins, if spatial objects are transformed to higher-dimensional points. However, the most serious disadvantage is that the use of transformation does not preserve proximity.
Reference: [2] <author> Beckmann N., Kriegel H.-P., Schneider R., Seeger B.: </author> <title> The R*-tree: An Efficient and Robust Access Method for Points and Rectangles, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Atlantic City, N.J., </address> <year> 1990, </year> <pages> pp. 322-331. </pages>
Reference-contexts: An efficient processing of the window query is important for the efficiency of the spatial join. In the following, we restrict our considerations to R-trees [10], particularly R*-trees <ref> [2] </ref>, used as the underlying spatial access method for processing spatial joins. It has been shown in [2] that the R*-tree is one of the most efficient members of the R-tree family with respect to several single-scan queries. Since several geographic information systems, e.g. Intergraphs GIS, and DBSs, e.g. <p> An efficient processing of the window query is important for the efficiency of the spatial join. In the following, we restrict our considerations to R-trees [10], particularly R*-trees <ref> [2] </ref>, used as the underlying spatial access method for processing spatial joins. It has been shown in [2] that the R*-tree is one of the most efficient members of the R-tree family with respect to several single-scan queries. Since several geographic information systems, e.g. Intergraphs GIS, and DBSs, e.g. <p> R-trees have the advantage to represent objects uniquely. However, R-trees cannot guarantee a disjoint decomposition, i.e. rectangles of directory entries may overlap. A high overlap results in poor query performance. Nevertheless, in <ref> [2] </ref> it has been shown that the R*-tree is very efficient for spatial query processing, particularly in comparison to other members of the R-tree family. 2.1 Joins with Spatial Objects In the following, we consider two sets A = -a 1 ,,a n - and B = -b 1 ,,b m <p> Until now the most efficient variant of the R-trees is experimentally shown to be the R*-tree <ref> [2] </ref>. The R*-tree uses more sophisticated insertion and splitting algorithms than the original R-tree. <p> Similar to B-trees, R-trees guarantee that storage utilization is at least m/M and that the height grows logarithmically in the number of data records. The reader is referred to the original papers [10] and <ref> [2] </ref> for a more detailed discussion. 3.2 Basic Algorithms Following the similarities in the data structure, there is almost no difference between R-tree and R*-tree with respect to specific queries, like the window query. Let S be a query rectangle of a window query.
Reference: [3] <author> Burrough P. A.: </author> <title> Principles of Geographical Information Systems for Land Resources Assessment, </title> <publisher> Oxford University Press, </publisher> <year> 1986. </year>
Reference-contexts: For example, a join-operation in a relational DBS is a multiple-scan query. The most important multiple-scan queries in a spatial DBS are the spatial join [18] and the map overlay <ref> [3] </ref>. The spatial join operation is used to combine spatial objects of two sets according to some spatial properties. For example, consider the spatial relations Forests and Cities where an attribute in each relation represents the borders of forests and cities, respectively.
Reference: [4] <institution> Bureau of the Census: Tiger/Line Precensus Files: 1990 technical documentation, Bureau of the Census, </institution> <address> Washington, DC, </address> <year> 1989. </year>
Reference-contexts: In the following, we investigate spatial joins in an empirical comparison using carthographic maps from real applications. We consider two files with 131,461 and 128,971 line objects in an area of California. The data is drawn from the TIGER/Line files used by the US Bureau of the Census <ref> [4] </ref>. The first map represents streets whereas the second map represents rivers and railway tracks. For each of the maps, the minimum bounding rectangles of the polygonal objects are stored in an R*-tree. The join of R and S results in a response set of 86,094 pairs of intersecting rectangles.
Reference: [5] <author> Bentley J.L., Wood D.: </author> <title> An Optimal Worst Case Algorithm for Reporting Intersections of Rectangles, </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. C-29, No. 7, </volume> <year> 1980, </year> <pages> pp. 571-577. </pages>
Reference-contexts: There are several computational geometry algorithms that can solve the same problem in O ((||R||+||S||) log (max (||R||,||S||)) + k) time where k denotes the size of the response set. However, these approaches require rather complex data structures, see [20] and <ref> [5] </ref>. Moreover, several (but a constant number of) sweeps over the data are necessary which leads to rather high constants.
Reference: [6] <author> Faloutsos, C.: </author> <title> Gray Codes for Partial Match and Range Queries, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 14, No. 10, </volume> <year> 1988, </year> <pages> pp. 1381-1393. </pages>
Reference-contexts: Most popular with respect to spatial data handling are access methods based on linear quadtrees [8] or, almost equivalently, z-ordering [17] and other space-filling curves <ref> [6] </ref>. The basic idea of these methods is to decompose the data space into non-overlapping cells which can be computed by recursively cutting the space into two or four parts of equal size. Cells can be identified by a location code, called z-value, and a size code, called level.
Reference: [7] <author> Fotouhi F., Pramanik S.: </author> <title> Optimal Secondary Storage Access Sequence for Performing Relational Join, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> Vol. 1, No. 3, </volume> <year> 1989, </year> <pages> pp. 318-328. </pages>
Reference-contexts: In [16] the problem of determining the optimal read schedule for a fixed size buffer has been shown to be NP-hard. Thus, we are interested in a heuristic solution that comes close to the optimum. In a similar setting, heuristic solutions have already been discussed in <ref> [7] </ref>. However, these solutions assume that the required pairs of (data) pages are known before performing the join. Moreover, expensive preprocessing steps are necessary to build up some additional data structures. We call this approach a global optimization policy. <p> Thus, the read schedule is &lt;r 1 , s 2 , r 4 , r 3 , s 1 , r 2 &gt;. A similar idea to make use of the degree of an entry was already presented in <ref> [7] </ref>. The local plane-sweep order approach extended by pinning works like algorithm SpatialJoin3 with the following exception: If a pair of intersecting pages is in the directory, we compute the degree of the corresponding rectangles after joining the pair.
Reference: [8] <author> Gargantini, I. </author> : <title> An Effective Way to Represent Quadtrees, </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 25, No. 12, </volume> <year> 1982, </year> <pages> pp. 905-910. </pages>
Reference-contexts: Most popular with respect to spatial data handling are access methods based on linear quadtrees <ref> [8] </ref> or, almost equivalently, z-ordering [17] and other space-filling curves [6]. The basic idea of these methods is to decompose the data space into non-overlapping cells which can be computed by recursively cutting the space into two or four parts of equal size.
Reference: [9] <author> Gnther, O.: </author> <title> Efficient Computations of Spatial Joins, </title> <booktitle> Proc. 9th Int. Conf. on Data Engineering, </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: For a class of tree structures, Gnther <ref> [9] </ref> has presented a gen-eral model for estimating the cost of spatial joins. In a different setting, Rotem [21] has discussed the issue of spatial join indices. The paper is organized as follows. We first introduce to the basic ideas of spatial access methods and spatial joins in section 2.
Reference: [10] <author> Guttman A.: R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Boston, MA., </address> <year> 1984, </year> <pages> pp. 47-57. </pages>
Reference-contexts: An efficient processing of the window query is important for the efficiency of the spatial join. In the following, we restrict our considerations to R-trees <ref> [10] </ref>, particularly R*-trees [2], used as the underlying spatial access method for processing spatial joins. It has been shown in [2] that the R*-tree is one of the most efficient members of the R-tree family with respect to several single-scan queries. Since several geographic information systems, e.g. <p> Consequently, the number of objects participating in the refinement step is low and, the cost for the filter step is high. A detailed discussion on the effect of redundancy is given in [19]. Other access methods, such as R-trees <ref> [10] </ref>, represent an object only once generally using a MBR as an approximation. Then, a data entry of an access method consists of the MBR and a pointer to the corresponding object. An R-tree is a balanced tree built up in a similar way as a B + -tree. <p> To avoid redundancy, objects must be uniquely represented as suggested for R-trees. It is still an open question which type of access method is most suitable for performing spatial joins and for other operations [12]. 3 R*-tree An R-tree <ref> [10] </ref> is a B + -tree like access method that stores multidimensional rectangles as complete objects without clipping them or transforming them to higher dimensional points. Until now the most efficient variant of the R-trees is experimentally shown to be the R*-tree [2]. <p> Similar to B-trees, R-trees guarantee that storage utilization is at least m/M and that the height grows logarithmically in the number of data records. The reader is referred to the original papers <ref> [10] </ref> and [2] for a more detailed discussion. 3.2 Basic Algorithms Following the similarities in the data structure, there is almost no difference between R-tree and R*-tree with respect to specific queries, like the window query. Let S be a query rectangle of a window query.
Reference: [11] <author> Harada L., Nakano M., Kitsuregawa M., Takagi M.: </author> <title> Query Processing Methods for Multi-Attribute Clustered Relations, </title> <booktitle> Proc. 16th Int. Conf. on Very Large Data Bases, </booktitle> <address> Brisbane, </address> <year> 1990, </year> <pages> pp. 59-70. </pages>
Reference-contexts: Thus, we are interested in exploiting the spatial access method for an efficient join processing. There are several other approaches for performing joins using multidimensional point access methods, e.g. grid files [1] and kd-trees <ref> [11] </ref>. These methods can be used for spatial joins, if spatial objects are transformed to higher-dimensional points. However, the most serious disadvantage is that the use of transformation does not preserve proximity. Methods for computing the spatial join are discussed in great detail for quadtrees and similar access methods [18].
Reference: [12] <author> Hoel E. G., Samet H.: </author> <title> A Qualitative Comparison Study of Data Structures for Large Line Segment Databases, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> San Diego, CA., </address> <year> 1992, </year> <pages> pp. 205-214. </pages>
Reference-contexts: To avoid redundancy, objects must be uniquely represented as suggested for R-trees. It is still an open question which type of access method is most suitable for performing spatial joins and for other operations <ref> [12] </ref>. 3 R*-tree An R-tree [10] is a B + -tree like access method that stores multidimensional rectangles as complete objects without clipping them or transforming them to higher dimensional points. Until now the most efficient variant of the R-trees is experimentally shown to be the R*-tree [2].
Reference: [13] <author> Kriegel H.-P., Brinkhoff T., Schneider R.: </author> <title> An Efficient Map Overlay Algorithm based on Spatial Access Methods and Computational Geometry, </title> <booktitle> Proc. Int. Workshop on Database Management Systems for Geographical Applications, </booktitle> <address> Capri, Italy, </address> <year> 1991, </year> <title> in: Geographic Database Management Systems, </title> <publisher> Springer, </publisher> <year> 1992, </year> <pages> pp. 194-211. </pages>
Reference-contexts: A third optimization policy is the algorithm-driven optimization. In this approach, the read schedule is determined by the algorithm processing the spatial data. An example is the plane-sweep map overlay presented in <ref> [13] </ref>. But the algorithm-driven optimization is not generally applicable because it is restricted to a class of algorithms exploiting spatial order. Our solution presented here uses a local optimization policy based on spatial locality as a main criterion for computing the read schedule.
Reference: [14] <author> Kamel, I., Faloutsos, C.: </author> <title> Parallel R-Trees, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> San Diego, CA., </address> <year> 1992, </year> <pages> pp. 195-204. </pages>
Reference-contexts: Until now, all our approaches assume a conventional computer architecture. However, parallel computer systems and disk arrays are very interesting for performing spatial joins and window queries, for example using parallel R-trees <ref> [14] </ref>.
Reference: [15] <author> Mishra P., Eich M.H.: </author> <title> Join Processing in Relational Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 24, No. 1, </volume> <year> 1992, </year> <pages> pp. 63-113. </pages>
Reference-contexts: The problem of spatial joins with more than two spatial relations is similarly defined and its solution can make use of the techniques that will be presented in this paper. Almost all methods designed for an efficient join processing of non-spatial relations, see <ref> [15] </ref> for a survey, cannot be used for spatial joins. Using the simple nested loop approach, every object of the one relation has to be checked against all objects of the other relation.
Reference: [16] <author> Merret T., Kambayashi Y., Yasuura H.: </author> <title> Scheduling of Page-Fetches in Join-Operations, </title> <booktitle> Proc. 7th Int. Conf. on Very Large Data Bases, </booktitle> <address> Cannes, </address> <year> 1981, </year> <pages> pp. 488-498. </pages>
Reference-contexts: The read schedule determines the sequence how the pages are read form disk into the buffer. In <ref> [16] </ref> the problem of determining the optimal read schedule for a fixed size buffer has been shown to be NP-hard. Thus, we are interested in a heuristic solution that comes close to the optimum. In a similar setting, heuristic solutions have already been discussed in [7].
Reference: [17] <author> Orenstein J. A., Merrett T. H.: </author> <title> A Class of Data Structures for Associative Searching, </title> <booktitle> Proc. 3rd ACM SIGACT/SIGMOD Symp. on Principles of Database Systems, </booktitle> <year> 1984, </year> <pages> pp. 181-190. </pages>
Reference-contexts: Most popular with respect to spatial data handling are access methods based on linear quadtrees [8] or, almost equivalently, z-ordering <ref> [17] </ref> and other space-filling curves [6]. The basic idea of these methods is to decompose the data space into non-overlapping cells which can be computed by recursively cutting the space into two or four parts of equal size. <p> Then, we sort the rectangles according to the spatial location of their centers. Thus, the problem occurs to sort two-dimensional points. A common way for sorting multidimensional points is based on space-filling curves, for example the Peano-curve, also called z-ordering <ref> [17] </ref>. The basic idea is to decompose the underlying space into cells of equal size and provide an ordering on this set of cells. An example is given in Figure 7. First, all intersections are computed between the rectangles (r 1 ,,r 4 ) and (s 1 ,,s 3 ).
Reference: [18] <author> Orenstein J. A.: </author> <title> Spatial Query Processing in an Object-Oriented Database System, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Washington D.C., </address> <year> 1986, </year> <pages> pp. 326-333. </pages>
Reference-contexts: For example, a join-operation in a relational DBS is a multiple-scan query. The most important multiple-scan queries in a spatial DBS are the spatial join <ref> [18] </ref> and the map overlay [3]. The spatial join operation is used to combine spatial objects of two sets according to some spatial properties. For example, consider the spatial relations Forests and Cities where an attribute in each relation represents the borders of forests and cities, respectively. <p> With respect to the authors knowledge, spatial joins supported by R-trees have not been examined until now. Previous approaches for processing joins are based on access methods others than R-trees or address the problem in a quite different context. Orenstein <ref> [18] </ref> has proposed B + -trees in combination with z-ordering as the underlying access method for performing spatial Efficient Processing of Spatial Joins Using R-trees Thomas Brinkhoff Hans-Peter Kriegel Bernhard Seeger Institute of Computer Science, University of Munich Leopoldstr. 11 B, W-8000 Mnchen 40, Germany e-mail: -brink,kriegel,bseeger-@dbs.informatik.uni-muenchen.de joins. <p> The minimum bounding rectilinear rectangle (MBR) of an object is a very common approach for an approximation. Then the window query is processed in two steps, called filter and refinement step in <ref> [18] </ref>: (i) filter step: Find all objects whose MBR intersects the query rectangle. (ii) refinement step: For those objects, check whether they really fulfil the query condition (if necessary, make use of the exact representation). <p> These methods can be used for spatial joins, if spatial objects are transformed to higher-dimensional points. However, the most serious disadvantage is that the use of transformation does not preserve proximity. Methods for computing the spatial join are discussed in great detail for quadtrees and similar access methods <ref> [18] </ref>. The cells of quadtrees can be represented in a linear fashion in order of z-value and level. A spatial join of two quadtrees can be performed by an almost linear scan through the corresponding sequences of cells.
Reference: [19] <author> Orenstein J. A.: </author> <title> Redundancy in Spatial Databases, </title> <booktitle> Proc. ACM SIG-MOD Int. Conf. on Management of Data, </booktitle> <address> Portland, Oreg., </address> <year> 1989, </year> <pages> pp. 294-305. </pages>
Reference-contexts: Note, that a high redundancy factor implies an accurate approximation of the object. Consequently, the number of objects participating in the refinement step is low and, the cost for the filter step is high. A detailed discussion on the effect of redundancy is given in <ref> [19] </ref>. Other access methods, such as R-trees [10], represent an object only once generally using a MBR as an approximation. Then, a data entry of an access method consists of the MBR and a pointer to the corresponding object.
Reference: [20] <author> Preparata F. P., Shamos M. I.: </author> <title> Computational Geometry, </title> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: Second, entries are sorted according to their spatial location and thereafter, an algorithm based on the plane-sweep paradigm <ref> [20] </ref> is used to compute the desired pairs of intersecting entries. Restricting the search space In algorithm SpatialJoin1, each entry of the one node is tested for the join condition against all entries of the other node. <p> For example, a sorted sequence of 6 rectangles is depicted in Figure 4 is &lt;r 1 , r 4 , r 2 , r 5 , r 3 , r 6 &gt;. Plane sweep is a common technique for computing intersections <ref> [20] </ref>. The basic idea is to move a line, the so-called sweep-line, perpendicular to one of the axes, e.g. the x-axis, from left to right. Given two sequences of rectangles Rseq and Sseq, we exploit the plane-sweep technique without the overhead of building up any additional dynamic data structure. <p> There are several computational geometry algorithms that can solve the same problem in O ((||R||+||S||) log (max (||R||,||S||)) + k) time where k denotes the size of the response set. However, these approaches require rather complex data structures, see <ref> [20] </ref> and [5]. Moreover, several (but a constant number of) sweeps over the data are necessary which leads to rather high constants.
Reference: [21] <author> Rotem D.: </author> <title> Spatial Join Indices, </title> <booktitle> Proc. Int. Conf. on Data Engineering, </booktitle> <year> 1991, </year> <pages> pp. 500-509. </pages>
Reference-contexts: For a class of tree structures, Gnther [9] has presented a gen-eral model for estimating the cost of spatial joins. In a different setting, Rotem <ref> [21] </ref> has discussed the issue of spatial join indices. The paper is organized as follows. We first introduce to the basic ideas of spatial access methods and spatial joins in section 2. Next in section 3, we review the most important design goals of the R*- tree.
Reference: [22] <author> Samet H.: </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Add-ison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction During the last decade, spatial database systems have become more and more important for industry and researchers. For example, substantial progress has been made with respect to developing spatial data models and designing efficient spatial access methods <ref> [22] </ref>. Spatial data consists of points, lines, rectangles, polygons, surfaces and even more complex objects composed from simple ones. In order to support spatial queries such as find all objects which intersect a given window, spatial access methods cluster objects on disks according to their spatial location in space. <p> Window queries and point queries are prime examples for single-scan queries in a spatial database. Several approaches for an efficient processing of such queries are discussed in great detail. Samet provides an excellent survey <ref> [22] </ref> of almost all of these methods. The other type of queries are multiple scan queries where objects have to be accessed several times and therefore, execution time is generally not linear but superlinear in the number of objects.
Reference: [23] <author> Stonebraker M., Rowe L., Hirohama M.: </author> <title> The Implementation of POSTGRES, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> Vol. 2, No. 1, </volume> <year> 1990, </year> <pages> pp. 125-142. </pages>
Reference-contexts: It has been shown in [2] that the R*-tree is one of the most efficient members of the R-tree family with respect to several single-scan queries. Since several geographic information systems, e.g. Intergraphs GIS, and DBSs, e.g. Postgres <ref> [23] </ref>, use R-trees as their basic spatial access method. there is also considerable interest in efficient join algorithms using R-trees. In this paper, we focus on exploiting R-trees for the efficient processing of spatial joins.
Reference: [24] <institution> Statistical Office of the European Communities: Regions, </institution> <year> 1990. </year>
Reference-contexts: For test (D), we have performed a spatial join with two identical R*-trees. Nevertheless, our algorithms treated the R*-trees as if they would be different. For test (E), region data instead of line data was used for performing spatial joins <ref> [24] </ref>. page size: 1 KByte 2 KByte 4 KByte 8 KByte time (sec) buffer size (KByte) time (sec) page size CPU-time I/O-time buffer size = 128 KByte page size: 1 KByte 2 KByte 4 KByte 8 KByte factor buffer size (KByte) 10 SJ4 in comparison to SJ1 page size: 1 KByte
References-found: 24

