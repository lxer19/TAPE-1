URL: http://www.cs.indiana.edu/l/www/ftp/pierce/copc.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Email: bcp@dcs.ed.ac.uk dnt@dcs.gla.ac.uk  
Title: Concurrent Objects in a Process Calculus  
Author: Benjamin C. Pierce David N. Turner 
Address: Glasgow  
Affiliation: Department of Computer Science Department of Computer Science University of Edinburgh University of  
Abstract: A programming style based on concurrent objects arises almost inevitably in languages where processes communicate by exchanging data on channels. Using the pict language as an experimental testbed, we introduce a simple object-based programming style and compare three techniques for controlling concurrency between methods in this setting: explicit locking, a standard choice operator, and a more refined replicated choice operator.
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> Gul A. Agha. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: (i.e. a description of a choice to be performed) and yields a process (the running choice itself). 6.1 Objects with Choice Using choice, all the service ports of an object may be handled by a single server process of the form, yielding a style of object definition similar to Actors <ref> [Hew77, Agh86] </ref>: def server [] &gt; sync!( c=&gt;abs x &gt; ... &lt;handle request c&gt; ... server![] end $ d=&gt;abs y &gt; ... &lt;handle request d&gt; ... server![] end ) For example, we can use choice to implement reference cell objects as follows: def ref [init] = let new set,get def server
Reference: [Bou92] <author> Gerard Boudol. </author> <title> Asynchrony and the -calculus (note). </title> <institution> Rapporte de Recherche 1702, INRIA Sofia-Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: For this investigation we use a fragment of pict, a programming language based on Milner, Parrow, and Walker's -calculus [MPW92, Mil91]. 1.1 Processes as Objects The -calculus is the best-known member of a family of "mobile" process calculi <ref> [MT91, Bou92, HT91, etc.] </ref>, in which communication topologies can evolve dynamically during evaluation. The primitive constructs in these systems include sending data along a channel, receiving data from a channel, creating channels, and running processes in parallel. Communication along channels is the primary means by which computations progress.
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year> <title> Influential description of a method for implementing distributed control structures: the ACTOR paradigm. </title>
Reference-contexts: (i.e. a description of a choice to be performed) and yields a process (the running choice itself). 6.1 Objects with Choice Using choice, all the service ports of an object may be handled by a single server process of the form, yielding a style of object definition similar to Actors <ref> [Hew77, Agh86] </ref>: def server [] &gt; sync!( c=&gt;abs x &gt; ... &lt;handle request c&gt; ... server![] end $ d=&gt;abs y &gt; ... &lt;handle request d&gt; ... server![] end ) For example, we can use choice to implement reference cell objects as follows: def ref [init] = let new set,get def server
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science, </booktitle> <address> Geneva CH, 1991. </address> <publisher> Springer-Verlag , Berlin, </publisher> <address> Heidelberg, New York, Tokyo. </address>
Reference-contexts: For this investigation we use a fragment of pict, a programming language based on Milner, Parrow, and Walker's -calculus [MPW92, Mil91]. 1.1 Processes as Objects The -calculus is the best-known member of a family of "mobile" process calculi <ref> [MT91, Bou92, HT91, etc.] </ref>, in which communication topologies can evolve dynamically during evaluation. The primitive constructs in these systems include sending data along a channel, receiving data from a channel, creating channels, and running processes in parallel. Communication along channels is the primary means by which computations progress.
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [KY94] <author> Naoki Kobayashi and Aki Yonezawa. </author> <title> Towards foundations for concurrent object-oriented programming | Types and language design. </title> <note> Submitted for publication, </note> <year> 1994. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: For example, the -calculus can be used to encode algebraic data-types [Mil91], higher-order processes [San92], and even -expressions <ref> [Mil90] </ref>. If we only consider the abstract behaviour of programs there is no difference in expressive power between these layers. For simplicity, we might therefore choose the smallest calculus as our theoretical core. However, we are interested in strongly typed programming languages, and this brings other concerns into play.
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: For this investigation we use a fragment of pict, a programming language based on Milner, Parrow, and Walker's -calculus <ref> [MPW92, Mil91] </ref>. 1.1 Processes as Objects The -calculus is the best-known member of a family of "mobile" process calculi [MT91, Bou92, HT91, etc.], in which communication topologies can evolve dynamically during evaluation. <p> Moreover, this packaging promotes a higher-order style of programming with objects, since the complete interface to an object may be manipulated as a single value. Some variants of the -calculus have included basic facilities for manipulating collections of channels. For example, Milner's polyadic -calculus <ref> [Mil91] </ref> includes simple syntax for constructing and transmitting tuples of channels. Operations on tuples may easily be encoded using the lower-level ("monadic") communication facilities, so the polyadic -calculus can be regarded as a simple syntactic sugaring of a monadic calculus. <p> For example, the -calculus can be used to encode algebraic data-types <ref> [Mil91] </ref>, higher-order processes [San92], and even -expressions [Mil90]. If we only consider the abstract behaviour of programs there is no difference in expressive power between these layers. For simplicity, we might therefore choose the smallest calculus as our theoretical core.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: For this investigation we use a fragment of pict, a programming language based on Milner, Parrow, and Walker's -calculus <ref> [MPW92, Mil91] </ref>. 1.1 Processes as Objects The -calculus is the best-known member of a family of "mobile" process calculi [MT91, Bou92, HT91, etc.], in which communication topologies can evolve dynamically during evaluation.
Reference: [MT91] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: For this investigation we use a fragment of pict, a programming language based on Milner, Parrow, and Walker's -calculus [MPW92, Mil91]. 1.1 Processes as Objects The -calculus is the best-known member of a family of "mobile" process calculi <ref> [MT91, Bou92, HT91, etc.] </ref>, in which communication topologies can evolve dynamically during evaluation. The primitive constructs in these systems include sending data along a channel, receiving data from a channel, creating channels, and running processes in parallel. Communication along channels is the primary means by which computations progress.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The full pict language uses several layers of desugarings to provide a high-level syntax reminiscent of the core language of Standard ML <ref> [MTH90] </ref>. The complete set of derived forms is listed in Appendix A; here, we explain just those used in the examples. First, pict allows conditional process expressions like if v then e else f, where v must evaluate to a boolean value.
Reference: [Nie92] <author> Oscar Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing, Lecture Notes in Computer Science number 612, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [Pap92] <author> Michael Papathomas. </author> <title> A unifying framework for process calculus semantics of concurrent object-oriented languages. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing, </booktitle> <volume> LNCS 612, </volume> <pages> pages 53-79. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [Pie94] <author> Benjamin C. Pierce. </author> <title> Programming in the pi-calculus: An experiment in programming language design. Tutorial notes on the Pict language. </title> <note> Available electronically, 1994. 25 </note>
Reference-contexts: Also like ml, the core calculus, and hence the derived forms, are statically typed. A uniprocessor implementation is publically available. The full pict language and type system are described elsewhere <ref> [Pie94, PT94a] </ref>. In this paper, we introduce just those constructs needed for the development of the examples; in particular, we shall not discuss the type system further.
Reference: [PT94a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict user manual. </title> <note> Available electronically, </note> <year> 1994. </year>
Reference-contexts: Also like ml, the core calculus, and hence the derived forms, are statically typed. A uniprocessor implementation is publically available. The full pict language and type system are described elsewhere <ref> [Pie94, PT94a] </ref>. In this paper, we introduce just those constructs needed for the development of the examples; in particular, we shall not discuss the type system further.
Reference: [PT94b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: In this section, we briefly discuss some simple techniques for reusing the code of object definitions. We do not discuss more powerful techniques for inheritance of method bodies and synchronization code here. Based on previous experience with foundational models of sequential objects <ref> [PT94b] </ref>, we believe that any reasonable high-level scheme for concurrent objects with inheritance can be expressed in the setting we have described.
Reference: [Rep88] <author> John Reppy. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 250-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: It is important to distinguish the description of a choice from the running choice process that is created when sync is applied to this description. Following Reppy <ref> [Rep92, Rep88, Rep91] </ref>, we call the description of a choice an event. <p> The identifiers sync, =&gt;, and $ form part of an events library, which provides selective communication in the style of CML <ref> [Rep92, Rep88, Rep91] </ref>. 6.3 Multi-State Objects For most of the examples we have considered so far, locks and choice can be used to build implementations of comparable clarity. The explicit locking idiom, being closer to the base language, is more efficient for these examples.
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: It is important to distinguish the description of a choice from the running choice process that is created when sync is applied to this description. Following Reppy <ref> [Rep92, Rep88, Rep91] </ref>, we call the description of a choice an event. <p> The identifiers sync, =&gt;, and $ form part of an events library, which provides selective communication in the style of CML <ref> [Rep92, Rep88, Rep91] </ref>. 6.3 Multi-State Objects For most of the examples we have considered so far, locks and choice can be used to build implementations of comparable clarity. The explicit locking idiom, being closer to the base language, is more efficient for these examples.
Reference: [Rep92] <author> John Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> June </month> <year> 1992. </year> <type> Technical Report TR 92-1285. </type>
Reference-contexts: It is important to distinguish the description of a choice from the running choice process that is created when sync is applied to this description. Following Reppy <ref> [Rep92, Rep88, Rep91] </ref>, we call the description of a choice an event. <p> The identifiers sync, =&gt;, and $ form part of an events library, which provides selective communication in the style of CML <ref> [Rep92, Rep88, Rep91] </ref>. 6.3 Multi-State Objects For most of the examples we have considered so far, locks and choice can be used to build implementations of comparable clarity. The explicit locking idiom, being closer to the base language, is more efficient for these examples.
Reference: [San92] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: For example, the -calculus can be used to encode algebraic data-types [Mil91], higher-order processes <ref> [San92] </ref>, and even -expressions [Mil90]. If we only consider the abstract behaviour of programs there is no difference in expressive power between these layers. For simplicity, we might therefore choose the smallest calculus as our theoretical core.
Reference: [Smo94] <author> Gert Smolka. </author> <title> A Foundation for Concurrent Constraint Programming. In Constraints in Computational Logics, </title> <booktitle> volume 845 of Lecture Notes in Computer Science, </booktitle> <address> Munich, Germany, </address> <month> September </month> <year> 1994. </year> <type> Invited Talk. </type>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Typed concurrent objects. </title> <booktitle> In Proceedings of the Eighth European Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach. <p> However, inheritance in the presence of concurrency seems necessarily to involve separating the interfaces of objects into external and internal parts (depending on whether messages are being sent by external clients or "through self"), and both typing and behavioral issues quickly become complex. See <ref> [Vas94] </ref> for a recent proposal along these lines and further citations. 8.1 Simple Delegation Probably the simplest way of reusing object definitions is writing new object constructors that act as "front ends" for other, perhaps more complex, objects. For example, suppose we have already implemented clearRef cells.
Reference: [VT93] <author> Vasco T. Vasconcelos and Mario Tokoro. </author> <title> A Typing System for a Calculus of Objects. </title> <booktitle> In First International Symposium on Object Technologies for Advanced Software, volume 742 of Lecture Notes in Computer Science, </booktitle> <pages> pages 460-474, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
Reference: [Wal94] <author> David Walker. </author> <title> Algebraic proofs of properties of objects. </title> <booktitle> In Proceedings of European Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Process calculi have become a popular vehicle for research on the foundations of concurrent object-oriented programming languages <ref> [Pap92, Nie92, VT93, Jon93, Wal94, Smo94, KY94, Vas94, etc.] </ref>. Their usual role is as a notation for the rigorous explanation of existing high-level language features. We propose that process calculi may also be viewed as design tools for high-level structures. approach.
References-found: 24

