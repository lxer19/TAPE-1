URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-292-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Title: GRASPA New Search Algorithm for Satisfiability  
Author: Joo P. Marques Silva Karem A. Sakallah - 
Date: April 10, 1996  
Address: Ann Arbor, Michigan 48109-2122 USA  
Affiliation: Computer Science and Engineering Division Department of Electrical Engineering and Computer Science  THE UNIVERSITY OF MICHIGAN  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abramovici, M. A. Breuer and A. D. Friedman, </author> <title> Digital Systems Testing and Testable Design Computer Science Press, </title> <year> 1990. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature <ref> [1] </ref>. Most of the recently proposed improvements to the basic Davis-Putnam procedure [2, 9, 10, 17, 28, 30] can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking.
Reference: [2] <author> C. E. Blair, R. G. Jeroslow and J. K. Lowe, </author> <title> Some Results and Experiments in Programming Techniques for Propositional Logic, </title> <journal> Computers and Operations Research , vol. </journal> <volume> 13, no. 5, </volume> <pages> pp. 633-645, </pages> <year> 1986. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking.
Reference: [3] <author> M. Bruynooghe, </author> <title> Analysis of Dependencies to Improve the Behaviour of Logic Programs, </title> <booktitle> in Proceedings of the 5th Conference on Automated Deduction </booktitle>
Reference-contexts: Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) [6, 12, 13, 21] and Automated Deduction <ref> [3] </ref>, in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28].
Reference: [4] <author> S. T. Chakradhar, V. D. Agrawal and S. G. Rothweiler, </author> <title> A Transitive Closure Algorithm for Test Generation, </title> <journal> IEEE Transactions on Computer-Aided Design , vol. </journal> <volume> 12, no. 7, </volume> <pages> pp. 1015-1028, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently <ref> [4, 17, 20, 28] </ref>. In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general [14, 16, 25]. <p> The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies [24, 25]. Finally, the framework is organized to allow easy adaptation of other algorithmic techniques, such as those in <ref> [4, 16] </ref>, whose operation is orthogonal to those described here. The remainder of this report is organized in four sections. In Section 2, we introduce the basics of backtracking search, particularly our implementation of BCP, and describe the overall architecture of GRASP. <p> Improvements to the BCP-based deduction engine are described in [26] and consist of different forms of probing the CNF formula for creating new clauses. This approach naturally adapts and extends other deduction procedures, e.g. recursive learning [16] and transitive closure <ref> [4] </ref>, since it completes the clause database with additional implicates, in addition to being able to identify as many necessary assignments. The actual practical usefulness of improved deduction engines needs to be experimentally validated.
Reference: [5] <author> M. Davis and H. Putnam, </author> <title> A Computing Procedure for Quantification Theory, </title> <journal> Journal of the Association for Computing Machinery vol. </journal> <volume> 7, </volume> <pages> pp. 201-215, </pages> <year> 1960. </year>
Reference-contexts: SAT belongs to the class of NP-complete problems whose algorithmic solutions are currently believed to have exponential worst case complexity [11]. Over the years, many algorithmic solutions have been proposed for SAT, the most well known being the different variations of the Davis-Putnam procedure <ref> [5] </ref>. The best known version of this procedure is based on a backtracking search algorithm that, at each node in the search tree, elects an assignment and prunes subsequent search by iteratively applying the unit clause pure literal rules [30]. <p> If , then the assignment is required; if then is required. Such assignments are referred to as logical implications (implications, for short) and correspond to the application of the unit clause rule proposed by M. Davis and H. Putnam <ref> [5] </ref>. BCP refers to the iterated application of this rule to a clause database until the set of unit clauses becomes empty or one or more clauses become unsatisfied. Let the assignment of a variable be implied due to a clause .
Reference: [6] <author> R. Dechter, </author> <title> Enhancement Schemes for Constraint Processing: Backjumping, Learning, and Cutset Decomposition, </title> <journal> Artificial Intelligence , vol. </journal> <volume> 41, </volume> <pages> pp. 273-312, </pages> <year> 1989/90. </year>
Reference-contexts: Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) <ref> [6, 12, 13, 21] </ref> and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) [6, 12, 13, 21] and Automated Deduction [3], in some cases with very promising experimental results <ref> [6, 13] </ref>. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28].
Reference: [7] <author> J. de Kleer, </author> <title> An Assumption-Based TMS, </title> <journal> Artificial Intelligence , vol. </journal> <volume> 28, </volume> <pages> pp. 127-162, </pages> <year> 1986. </year>
Reference-contexts: Only in [19] is a non-chronological backtracking procedure outlined for solving SAT, but it is only sketched and no experimental results are presented. Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) <ref> [7, 27] </ref>, Constraint Satisfaction Problems (CSP) [6, 12, 13, 21] and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> The conicting assignment is determined by a backward traversal of the implication graph starting at . Besides the decision assignment at the current decision level, only those assignments that occurred at previous decision levels 2. Conditions similar to these implicates are referred to as nogoods in TMS <ref> [7, 27] </ref> and in some algorithms for CSP [21]. Nev ertheless, the basic mechanism for creating conict-induced clauses differs.
Reference: [8] <institution> DIMACS Challenge benchmarks in ftp://Dimacs.Rutgers.EDU/pub/challenge/sat/benchmarks/cnf. </institution> <note> UCSC benchmarks in /pub/challenge/sat/contributed/UCSC. </note>
Reference-contexts: Finally, straightforward bookkeeping of the causality chains leading up to conicts allows GRASP to identify assignments that are necessary for a solution to be found. Experimental results obtained from a large number of benchmarks <ref> [8] </ref> indicate that application of the proposed conict analysis techniques to SAT algorithms can be extremely effective for a large number of representative classes of SAT instances. Several features distinguish the conict analysis procedure in GRASP from others used in TMSs and CSPs. <p> All programs were compiled with GCC 2.7.2 and run on a SUN SPARC 5/85 machine with 64 MByte of RAM. In order to evaluate the three programs, two different sets of benchmarks were tested: The UCSC benchmarks, available from <ref> [8] </ref>, that include instances of SAT commonly encountered in test pattern generation of combinational switching circuits for bridging and stuck-at faults. The DIMACS challenge benchmarks, also available from [8], that include instances of SAT from several authors and from different application areas. <p> In order to evaluate the three programs, two different sets of benchmarks were tested: The UCSC benchmarks, available from <ref> [8] </ref>, that include instances of SAT commonly encountered in test pattern generation of combinational switching circuits for bridging and stuck-at faults. The DIMACS challenge benchmarks, also available from [8], that include instances of SAT from several authors and from different application areas. <p> For example, for the SSA and BF benchmarks the optimal bound is near 30. 4.2 DIMACS Benchmark Results Finally, we illustrate the application of GRASP to other benchmarks, not directly related with EDA applications. For this purpose the DIMACS benchmarks are used <ref> [8] </ref>. The results of running GRASP and the other algorithms are shown in Table 4-2 and again are separated into classes of benchmarks.
Reference: [9] <author> J. W. Freeman, </author> <title> Improvements to Propositional Satisfiability Search Algorithms , Ph.D. </title> <type> Dissertation, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking. <p> Extensive experimental results on a wide range of benchmarks, including many from the field of ATPG, are presented and analyzed in Section 4. In particular, GRASP is shown to outperform two recent state-of-the-art SAT algorithms <ref> [9, 28] </ref> on most, but not all, benchmarks. <p> These conict diagnosis techniques are discussed further in Section 3. 2.4 Structure of the Search Process The basic mechanism for deriving implications from a given clause database is Boolean constraint propagation (BCP) <ref> [9, 30] </ref>. Consider a formula containing the clause and assume . For any satisfying assignment to , requires that be equal to 1, and we say that implies due to . <p> Choose the variable and the assignment that directly satisfies the largest number of clauses. Other decision making procedures have been implemented in the GRASP algorithmic framework, particularly those described in <ref> [9] </ref>. For these heuristics, preference is given to assignments that simplify the clauses the most, and can lead to more implications due to BCP. This is in explicit contrast with our heuristic which always attempts to satisfy the largest number of clauses. 2. <p> Several benchmarks are used and GRASP is compared with other state-of-the-art and publicly available SAT programs. In particular, we compare GRASP with TEGUS [28] and POSIT <ref> [9] </ref>. TEGUS is included in SIS [23]. It was adapted to read CNF formulas and augmented to continue searching when all its default options were exhausted . No changes were required with POSIT.
Reference: [10] <author> G. Gallo and G. Urbani, </author> <title> Algorithms for Testing the Satisfiability of Propositional Formulae, </title> <journal> Journal of Logic Programming , vol. </journal> <volume> 7, </volume> <pages> pp. 45-61, </pages> <year> 1989. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking.
Reference: [11] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness , W. </title> <editor> H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: Though well-researched and widely investigated, it remains the focus of continuing interest because efficient techniques for its solution can have great impact. SAT belongs to the class of NP-complete problems whose algorithmic solutions are currently believed to have exponential worst case complexity <ref> [11] </ref>. Over the years, many algorithmic solutions have been proposed for SAT, the most well known being the different variations of the Davis-Putnam procedure [5].
Reference: [12] <author> J. Gaschnig, </author> <title> Performance Measurement and Analysis of Certain Search Algorithms , Ph.D. </title> <type> Dissertation, </type> <institution> Department of Computer Science, Carnegie-Mellon University, CMU-CS-79-124, </institution> <month> May </month> <year> 1979. </year>
Reference-contexts: Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) <ref> [6, 12, 13, 21] </ref> and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28].
Reference: [13] <author> M. L. Ginsberg, </author> <title> Dynamic Backtracking, </title> <journal> Journal of Artificial Intelligence Research , vol. </journal> <volume> 1, </volume> <pages> pp. 25-46, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) <ref> [6, 12, 13, 21] </ref> and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) [6, 12, 13, 21] and Automated Deduction [3], in some cases with very promising experimental results <ref> [6, 13] </ref>. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> The pseudo-code for the diagnosis engine in GRASP is shown in Figure 3-2 and illustrates the main features of standard conict diagnosis described above. The GRASP search algorithm described in this report is sound and complete. General proofs of this claim can be found in <ref> [13, 26] </ref>. 3.2 Variations on the Standard Diagnosis Engine The standard conict diagnosis, described in the previous section, suffers from two drawbacks. First, conict analysis introduces significant overhead which, for some instances of SAT, can lead to large run times.
Reference: [14] <author> J. Giraldi and M. L. Bushnell, </author> <title> Search State Equivalence for Redundancy Identification and Test Generation, </title> <booktitle> in Proceedings of the International Test Conference </booktitle>
Reference-contexts: In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general <ref> [14, 16, 25] </ref>. This report introduces GRASP ( Generic seaRch Algorithm for the Satisfiability Problem ), an integrated algorithmic framework for SAT that unifies several previously proposed search-pruning techniques and facilitates identification of additional ones. <p> Exploiting the anatomy of conicts in this manner has no equivalent in other areas. CSE-TR-292-96: GRASPA New Search Algorithm for Satisfiability 2 Some of the proposed techniques have also been applied in structural ATPG algorithms <ref> [14, 18, 26] </ref>. The GRASP framework, however, permits a unified representation of all known search-pruning methods and introduces several others. The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies [24, 25].
Reference: [15] <author> J. P. Hayes, </author> <title> Introduction to Digital Logic Design , Addison-Wesley, </title> <year> 1993. </year>
Reference-contexts: A formula denotes a unique -variable Boolean function and each of its clauses corresponds to an implicate of <ref> [15, p. 288] </ref>. Clearly, a function can be represented by many equivalent CNF formulas. A formula is complete if it consists of the entire set of prime implicates for the corresponding function. In general, a complete formula will have an exponential number of clauses.
Reference: [16] <author> W. Kunz and D. K. Pradhan, </author> <title> Recursive Learning: An Attractive Alternative to the Decision Tree for Test Generation in Digital Cir cuits, </title> <booktitle> in Proceedings of the International Test Conference </booktitle>
Reference-contexts: In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general <ref> [14, 16, 25] </ref>. This report introduces GRASP ( Generic seaRch Algorithm for the Satisfiability Problem ), an integrated algorithmic framework for SAT that unifies several previously proposed search-pruning techniques and facilitates identification of additional ones. <p> The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies [24, 25]. Finally, the framework is organized to allow easy adaptation of other algorithmic techniques, such as those in <ref> [4, 16] </ref>, whose operation is orthogonal to those described here. The remainder of this report is organized in four sections. In Section 2, we introduce the basics of backtracking search, particularly our implementation of BCP, and describe the overall architecture of GRASP. <p> Another area for improving GRASP is related with the deduction engine. Improvements to the BCP-based deduction engine are described in [26] and consist of different forms of probing the CNF formula for creating new clauses. This approach naturally adapts and extends other deduction procedures, e.g. recursive learning <ref> [16] </ref> and transitive closure [4], since it completes the clause database with additional implicates, in addition to being able to identify as many necessary assignments. The actual practical usefulness of improved deduction engines needs to be experimentally validated.
Reference: [17] <author> T. Larrabee, </author> <title> Efficient Generation of Test Patterns Using Boolean Satisfiability , Ph.D. </title> <type> Dissertation, </type> <institution> Department of Computer Science, Stanford University, STAN-CS-90-1302, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking. <p> Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently <ref> [4, 17, 20, 28] </ref>. In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general [14, 16, 25]. <p> It considers the occurrence of a conict, which is unavoidable for an unsatisfiable instance unless the formula is complete, as an 1. Learning as defined in <ref> [17, 22] </ref> only yields implicates of size 2 (i.e. non-local implications) but the concept can be readily extended to implicates of arbitrary size.
Reference: [18] <author> S. Mallela and S. Wu, </author> <title> A Sequential Circuit Test Generation System, </title> <booktitle> in Proceedings of the International Test Conference 1985. </booktitle> <month> CSE-TR-292-96: </month> <title> GRASPA New Search Algorithm for Satisfiability 17 </title>
Reference-contexts: Exploiting the anatomy of conicts in this manner has no equivalent in other areas. CSE-TR-292-96: GRASPA New Search Algorithm for Satisfiability 2 Some of the proposed techniques have also been applied in structural ATPG algorithms <ref> [14, 18, 26] </ref>. The GRASP framework, however, permits a unified representation of all known search-pruning methods and introduces several others. The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies [24, 25].
Reference: [19] <author> D. A. McAllester, </author> <title> An Outlook on Truth Maintenance, </title> <type> AI Memo 551, </type> <institution> MIT AI Laboratory, </institution> <month> August </month> <year> 1980. </year>
Reference-contexts: Most of the recently proposed improvements to the basic Davis-Putnam procedure [2, 9, 10, 17, 28, 30] can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking. Only in <ref> [19] </ref> is a non-chronological backtracking procedure outlined for solving SAT, but it is only sketched and no experimental results are presented.
Reference: [20] <author> P. C. McGeer, A. Saldanha, P. R. Stephan, R. K. Brayton and A. L. Sangiovanni-Vincentelli, </author> <title> Timing Analysis and Delay-Fault Test Generation Using Path Recursive Functions, </title> <booktitle> in Proceedings of the International Conference on Computer-Aided Design 183, </booktitle> <year> 1991. </year>
Reference-contexts: Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently <ref> [4, 17, 20, 28] </ref>. In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general [14, 16, 25].
Reference: [21] <author> T. Schiex and G. Verfaillie, </author> <title> Nogood Recording for Static and Dynamic Constraint Satisfaction Problems, </title> <booktitle> in Proceedings of the International Conference on Tools with Artificial Intelligence </booktitle>
Reference-contexts: Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) [7, 27], Constraint Satisfaction Problems (CSP) <ref> [6, 12, 13, 21] </ref> and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> Besides the decision assignment at the current decision level, only those assignments that occurred at previous decision levels 2. Conditions similar to these implicates are referred to as nogoods in TMS [7, 27] and in some algorithms for CSP <ref> [21] </ref>. Nev ertheless, the basic mechanism for creating conict-induced clauses differs.
Reference: [22] <author> M. H. Schulz and E. Auth, </author> <title> Improved Deterministic Test Pattern Generation with Applications to Redundancy Identification, </title> <journal> IEEE Transactions on Computer-Aided Design , vol. </journal> <volume> 8, no. 7, </volume> <pages> pp. 811-816, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This is usually referred to as learning <ref> [22] </ref> and can be performed either as a preprocessing step (static learning) or during the search (dynamic learning) Our approach can be classified as a dynamic learning search mechanism based on diagnosing the causes of conicts. <p> It considers the occurrence of a conict, which is unavoidable for an unsatisfiable instance unless the formula is complete, as an 1. Learning as defined in <ref> [17, 22] </ref> only yields implicates of size 2 (i.e. non-local implications) but the concept can be readily extended to implicates of arbitrary size.
Reference: [23] <author> E. M. Sentovich et. al, </author> <title> SIS: An Environment to Sequential Circuit Synthesis, </title> <note> Memorandum no. </note> <institution> UCB/ERL M92/41, Department of Electrical Engineering and Computer Sciences, University of California at Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Several benchmarks are used and GRASP is compared with other state-of-the-art and publicly available SAT programs. In particular, we compare GRASP with TEGUS [28] and POSIT [9]. TEGUS is included in SIS <ref> [23] </ref>. It was adapted to read CNF formulas and augmented to continue searching when all its default options were exhausted . No changes were required with POSIT. GRASP and POSIT are implemented in the C++ programming language, whereas TEGUS is implemented in the C pro gramming language.
Reference: [24] <author> J. P. M. Silva and K. A. Sakallah, </author> <title> Efficient and Robust Test Generation-Based Timing Analysis, </title> <booktitle> in Proc. IEEE International Symposium on Circuits and Systems (ISCAS) , pp. </booktitle> <pages> 303-306, </pages> <address> June 1994, London, England. </address>
Reference-contexts: The GRASP framework, however, permits a unified representation of all known search-pruning methods and introduces several others. The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies <ref> [24, 25] </ref>. Finally, the framework is organized to allow easy adaptation of other algorithmic techniques, such as those in [4, 16], whose operation is orthogonal to those described here. The remainder of this report is organized in four sections.
Reference: [25] <author> J. P. M. Silva and K. A. Sakallah, </author> <title> Dynamic Search-Space Pruning Techniques in Path Sensitization, </title> <booktitle> in Proc. IEEE/ACM Design Automation Conference (DAC) , pp. </booktitle> <pages> 705-711, </pages> <address> June 1994, San Diego, California. </address>
Reference-contexts: In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general <ref> [14, 16, 25] </ref>. This report introduces GRASP ( Generic seaRch Algorithm for the Satisfiability Problem ), an integrated algorithmic framework for SAT that unifies several previously proposed search-pruning techniques and facilitates identification of additional ones. <p> The GRASP framework, however, permits a unified representation of all known search-pruning methods and introduces several others. The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies <ref> [24, 25] </ref>. Finally, the framework is organized to allow easy adaptation of other algorithmic techniques, such as those in [4, 16], whose operation is orthogonal to those described here. The remainder of this report is organized in four sections.
Reference: [26] <author> J. P. M. Silva, </author> <title> Search Algorithms for Satisfiability Problems in Combinational Switching Circuits , Ph.D. </title> <type> Dissertation, </type> <institution> Department of Electrical Engineering and Computer Science, University of Michigan, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Exploiting the anatomy of conicts in this manner has no equivalent in other areas. CSE-TR-292-96: GRASPA New Search Algorithm for Satisfiability 2 Some of the proposed techniques have also been applied in structural ATPG algorithms <ref> [14, 18, 26] </ref>. The GRASP framework, however, permits a unified representation of all known search-pruning methods and introduces several others. The basic SAT algorithm in GRASP is also customizable to take advantage of application-specific characteristics to achieve additional efficiencies [24, 25]. <p> The pseudo-code for the diagnosis engine in GRASP is shown in Figure 3-2 and illustrates the main features of standard conict diagnosis described above. The GRASP search algorithm described in this report is sound and complete. General proofs of this claim can be found in <ref> [13, 26] </ref>. 3.2 Variations on the Standard Diagnosis Engine The standard conict diagnosis, described in the previous section, suffers from two drawbacks. First, conict analysis introduces significant overhead which, for some instances of SAT, can lead to large run times. <p> Future research work will emphasize heuristic control of the rate of growth of the clause database. Another area for improving GRASP is related with the deduction engine. Improvements to the BCP-based deduction engine are described in <ref> [26] </ref> and consist of different forms of probing the CNF formula for creating new clauses.
Reference: [27] <author> R. M. Stallman and G. J. Sussman, </author> <title> Forward Reasoning and Dependency-Directed Backtracking in a System for Computer-Aided Circuit Analysis, </title> <journal> Artificial Intelligence , vol. </journal> <volume> 9, </volume> <pages> pp. 135-196, </pages> <month> October </month> <year> 1977. </year>
Reference-contexts: Only in [19] is a non-chronological backtracking procedure outlined for solving SAT, but it is only sketched and no experimental results are presented. Nevertheless, non-chronological backtracking techniques have been extensively studied and applied to different areas of Artificial Intelligence, particularly Truth Maintenance Systems (TMS) <ref> [7, 27] </ref>, Constraint Satisfaction Problems (CSP) [6, 12, 13, 21] and Automated Deduction [3], in some cases with very promising experimental results [6, 13]. Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently [4, 17, 20, 28]. <p> The conicting assignment is determined by a backward traversal of the implication graph starting at . Besides the decision assignment at the current decision level, only those assignments that occurred at previous decision levels 2. Conditions similar to these implicates are referred to as nogoods in TMS <ref> [7, 27] </ref> and in some algorithms for CSP [21]. Nev ertheless, the basic mechanism for creating conict-induced clauses differs.
Reference: [28] <author> P. R. Stephan, R. K. Brayton and A. L. Sangiovanni-Vincentelli, </author> <title> Combinational Test Generation Using Satisfiability, </title> <note> Memorandum no. </note> <institution> UCB/ERL M92/112, Department of Electrical Engineering and Computer Sciences, University of California at Berkeley, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking. <p> Interest in the direct application of SAT algorithms to electronic design automation (EDA) problems has been on the rise recently <ref> [4, 17, 20, 28] </ref>. In addition, improvements to the traditional structural (path sensitization) algorithms for some EDA problems, such as ATPG, include search-pruning techniques that are also applicable to SAT algorithms in general [14, 16, 25]. <p> Extensive experimental results on a wide range of benchmarks, including many from the field of ATPG, are presented and analyzed in Section 4. In particular, GRASP is shown to outperform two recent state-of-the-art SAT algorithms <ref> [9, 28] </ref> on most, but not all, benchmarks. <p> Several benchmarks are used and GRASP is compared with other state-of-the-art and publicly available SAT programs. In particular, we compare GRASP with TEGUS <ref> [28] </ref> and POSIT [9]. TEGUS is included in SIS [23]. It was adapted to read CNF formulas and augmented to continue searching when all its default options were exhausted . No changes were required with POSIT. <p> GRASP performs well in separate instances of SAT without knowledge of the circuit structure. In ATPG systems the structure of the circuit is known and can be used to improve efficiency. This is what is done with TEGUS when applied to ATPG <ref> [28] </ref>. Given the greater overhead of GRASP, TEGUS is likely to perform better on a larger number of easy faults. However, GRASP is ideal for the hard faults, for which TEGUS applies learning techniques and iterates over several decision making orderings.
Reference: [29] <author> R. E. Tarjan, </author> <title> Finding Dominators in Directed Graphs, </title> <journal> SIAM Journal on Computing , vol. </journal> <volume> 3, no. 1, </volume> <pages> pp. 62-89, </pages> <month> March </month> <year> 1974. </year>
Reference-contexts: With this modifica tion the worst case growth becomes a th-order polynomial in the number of variables. Further enhancements to the conict diagnosis engine involve generating stronger implicates (containing fewer literals) by more careful analysis of the structure of the implication graph. Such implicates correspond to the dominators <ref> [29] </ref> of the con ict vertex . These dominators, referred to as unique implication points (UIPs), can be identified in linear time with a single traversal of the implication graph. 4 Experimental Results In this section we present experimental results for GRASP.
Reference: [30] <author> R. Zabih and D. A. McAllester, </author> <title> A Rearrangement Search Strategy for Determining Propositional Satisfiability, </title> <booktitle> in Proceedings of the National Conference on Artificial Intelligence </booktitle>
Reference-contexts: The best known version of this procedure is based on a backtracking search algorithm that, at each node in the search tree, elects an assignment and prunes subsequent search by iteratively applying the unit clause pure literal rules <ref> [30] </ref>. Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. <p> Iterated application of the unit clause rule is commonly referred to as Boolean Constraint Propagation derivation of implications electronic CAD literature [1]. Most of the recently proposed improvements to the basic Davis-Putnam procedure <ref> [2, 9, 10, 17, 28, 30] </ref> can be distinguished based on their decision making heuristics or their use of preprocessing or relaxation techniques. Common to all these approaches, however, is the chronological nature of backtracking. <p> These conict diagnosis techniques are discussed further in Section 3. 2.4 Structure of the Search Process The basic mechanism for deriving implications from a given clause database is Boolean constraint propagation (BCP) <ref> [9, 30] </ref>. Consider a formula containing the clause and assume . For any satisfying assignment to , requires that be equal to 1, and we say that implies due to .
References-found: 30

