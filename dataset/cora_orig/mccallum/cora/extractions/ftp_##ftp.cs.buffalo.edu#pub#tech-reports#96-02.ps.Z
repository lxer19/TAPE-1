URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/96-02.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: Email: ravi@cs.cornell.edu.  Email: sivak-d@cs.buffalo.edu.  
Phone: 2  
Title: Efficient Self-Testing of Linear Recurrences  
Author: S. Ravikumar D. Sivakumar 
Web: N00014-93-1-0590.  
Note: This work was done when the author was visiting M.I.T. Research supported in part by ONR Young Inves tigator Award  Research supported in part by NSF grant CCR-9409104.  
Address: Ithaca, NY 14853.  NY 14260.  
Affiliation: 1 Department of Computer Science, Cornell University,  Department of Computer Science, State Univ. of New York at Buffalo, Buffalo,  
Abstract-found: 0
Intro-found: 1
Reference: [ABCG93] <author> S. Ar, M. Blum, B. Codenotti, and P. </author> <title> Gemmell. Checking approximate computations over the reals. </title> <booktitle> In Proc. 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 786-795, </pages> <year> 1993. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92].
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> In Proc. 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: Research in this area has progressed in two directions. First, influenced by developments in interactive proof systems, efficient testers were built for linear functions and for polynomials. These ideas were used extensively in obtaining the breakthrough results on probabilistically checkable proofs <ref> [BFLS91, FGL + 91, AS92, ALM + 92] </ref>. Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. <p> Some of the main developments along this line of research includes the work in [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95]. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of <ref> [ALM + 92] </ref>. In this paper, we continue the quest for identifying a larger class of self-testable functions.
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs. </title> <booktitle> In Proc. 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: Research in this area has progressed in two directions. First, influenced by developments in interactive proof systems, efficient testers were built for linear functions and for polynomials. These ideas were used extensively in obtaining the breakthrough results on probabilistically checkable proofs <ref> [BFLS91, FGL + 91, AS92, ALM + 92] </ref>. Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. <p> Some of the main developments along this line of research includes the work in [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95]. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from <ref> [AS92] </ref> and [RS92], culminating in the results of [ALM + 92]. In this paper, we continue the quest for identifying a larger class of self-testable functions.
Reference: [BFLS91] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylog-arithmic time. </title> <booktitle> In Proc. 23rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: Research in this area has progressed in two directions. First, influenced by developments in interactive proof systems, efficient testers were built for linear functions and for polynomials. These ideas were used extensively in obtaining the breakthrough results on probabilistically checkable proofs <ref> [BFLS91, FGL + 91, AS92, ALM + 92] </ref>. Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc.
Reference: [BLR93] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 47(3) </volume> <pages> 549-595, </pages> <year> 1993. </year> <note> An earlier version appeared in STOC 1990. </note>
Reference-contexts: 1 Introduction The concept of program self-testing, introduced by Blum, Luby, and Rubinfeld <ref> [BLR93] </ref>, is a radically different approach to testing the correctness of programs. In conventional program testing, the program is tested by comparing its output, say on many randomly chosen inputs, to the correct answer it is supposed to compute. <p> We identify, analyze, and solve the various cases of linear recurrences, each of which requires new and different ideas. First we show that if the recurrence yields a "convolution identity" over groups, then we can extend the technique of <ref> [BLR93] </ref> to design a self-tester. To handle the other cases, we present a very efficient reduction from the problem of self-testing recurrences to the problem of self-testing linearity over a multiplicative group of matrices. <p> Finally, we extend our work to the case of rational domains|sets of fixed point 1 rational numbers of pre-defined precision. To aid the exposition in the remainder of this Introduction, we present the formal definition of self-testers at this point. Definition 1 (Blum, Luby, and Rubinfeld <ref> [BLR93] </ref>) Let f be a function on a domain D. <p> As we show, this approach has many pay-offs, some of which we summarize briefly. (1) The matrix framework gives the first reduction from testing univariate polynomials to testing linear functions. From the point of view of self-testing, linear functions are fairly well-understood, and have extremely strong self-testers <ref> [BLR93] </ref> that can tolerate ffi up to 2=9. Since our reduction preserves efficiency, we obtain the first self-testers for univariate polynomials whose quality matches that of the linearity tester. Our proof is also much simpler than any currently known proof. <p> Moreover, if every function in F possesses some "random-self-reducibility," then using the program P that computes g correctly on most inputs, one can use P and compute g correctly on every input, with high probability. This process is called "self-correction" <ref> [BLR93, Lip91] </ref>. Linear functions and polynomials are random-self-reducible; in the next section, we point out the random-self-reducibility of convolution identities derived from recurrences. For the subsequent sections, this is irrelevant, since we reduce the testing of recurrences to testing linearity, which is clearly random-self-reducible. <p> The proof is similar in flavor to the proof of the Blum-Luby-Rubinfeld theorem attributed to Coppersmith (see <ref> [BLR93, RS93] </ref>), but requires an additional trick. The proof is presented in the Appendix, where we also show how to build self-testers for convolutions over groups, and obtain the following result. <p> What our reduction does is effectively make the linearity that is latent in the recurrence take an explicit form as the homomorphism ', which is more amenable to efficient testing, using the linearity tester of Blum, Luby, and Rubinfeld <ref> [BLR93] </ref>. The conceptual and technical advantage achieved stems from the fact that the Blum-Luby-Rubinfeld self-tester for linear functions (homomorphisms) is very efficient. Our matrix approach can be viewed another way.
Reference: [CL90] <author> R. Cleve and M. Luby. </author> <title> A note on self-testing/correcting methods for trigonometric functions. </title> <type> TR 90-032, ICSI, </type> <institution> Berkeley, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92].
Reference: [Erg95] <author> F. Ergun. </author> <title> Testing multivariate linear functions: Overcoming the generator bottleneck. </title> <booktitle> In Proc. 27th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 407-416, </pages> <year> 1995. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92].
Reference: [FGL + 91] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proc. 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: Research in this area has progressed in two directions. First, influenced by developments in interactive proof systems, efficient testers were built for linear functions and for polynomials. These ideas were used extensively in obtaining the breakthrough results on probabilistically checkable proofs <ref> [BFLS91, FGL + 91, AS92, ALM + 92] </ref>. Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc.
Reference: [FS95] <author> K. Friedl and M. Sudan. </author> <title> Some improvements to total degree tests. </title> <booktitle> In Proc. 3rd Israel Symposium on Theory of Computing and Systems, </booktitle> <pages> pages 190-198, </pages> <year> 1995. </year>
Reference-contexts: Since our reduction preserves efficiency, we obtain the first self-testers for univariate polynomials whose quality matches that of the linearity tester. Our proof is also much simpler than any currently known proof. Combining this with the work of Friedl and Sudan <ref> [FS95] </ref>, we obtain self-testers for multivariate polynomials over the finite field Z=(p), with better parameters than known before: ffi &lt; 1=8, and O (d) probes for a polynomial of total degree d. (2) The matrix approach lets us perform "bulk" testing of convolution identities (i.e., testing several instances of the identity <p> This gives us a new self-tester for univariate polynomials over the finite field Z=(p) that achieves the bound ffi &lt; 2=9, improving all previously known results for this case <ref> [RS92, RS93, FS95] </ref>. We note that effectively the test conducted by the self-tester is extremely simple: all it does is to check the convolution identity at multiple points simultaneously. The convolution identity, of course, was derived from the Lagrange interpolation identity. <p> The self-tester makes O (d) queries to the program, and computes O (d) matrix products over Z=(p). Combining this with the work of Friedl and Sudan <ref> [FS95] </ref>, we obtain 1 (see Appendix): Theorem 8 Multivariate polynomials over the field Z=(p) are *-self-testable for *=2 = ffi &lt; 1=8, provided p is large enough (as a function of 1=8 ffi).
Reference: [GLR + 91] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proc. 23rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: The main advantage of M being invertible, or equivalently, '(n) being defined on positive and negative values of n, is that we may appeal to a known adaptation of the BLR test, due to Rubinfeld [Rub94], building on ideas from <ref> [GLR + 91] </ref> and [RS92]. In this case, by careful choice of parameters, Rubinfeld's self-tester works for ffi up to 1=24, and guarantees that the program works correctly for a large fraction of D N , roughly the set fn j N=10 &lt; n &lt; N=10g.
Reference: [Lip91] <author> R. Lipton. </author> <title> New directions in testing. </title> <booktitle> In Proc. of DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <pages> pages 191-202, </pages> <year> 1991. </year>
Reference-contexts: Moreover, if every function in F possesses some "random-self-reducibility," then using the program P that computes g correctly on most inputs, one can use P and compute g correctly on every input, with high probability. This process is called "self-correction" <ref> [BLR93, Lip91] </ref>. Linear functions and polynomials are random-self-reducible; in the next section, we point out the random-self-reducibility of convolution identities derived from recurrences. For the subsequent sections, this is irrelevant, since we reduce the testing of recurrences to testing linearity, which is clearly random-self-reducible.
Reference: [PS94] <author> A. Polishchuk and D. Spielman. </author> <title> Nearly-linear size holographic proofs. </title> <booktitle> In Proc. 26th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 194-203, </pages> <year> 1994. </year> <month> 11 </month>
Reference-contexts: the program, and computes O (d) matrix products over the domain D dr 2d ;s 2d (only slightly larger than the required domain). 1 Madhu Sudan [personal communication] has pointed out to us that an (1)-self-tester with O (d) probes may be inferred from the work of Polishchuk and Spielman <ref> [PS94] </ref>. 10 Acknowledgments We thank Funda Ergun, Ronitt Rubinfeld, Madhu Sudan, and Ravi Sundaram for helpful conver sations, and Jing Huang for discussions that led us to thinking about recurrences.
Reference: [RS92] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proc. 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 23-43, </pages> <year> 1992. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92]. <p> Some of the main developments along this line of research includes the work in [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95]. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and <ref> [RS92] </ref>, culminating in the results of [ALM + 92]. In this paper, we continue the quest for identifying a larger class of self-testable functions. <p> The extension is non-trivial, and is combinatorially involved. (5) The application to rational domains has an interesting consequence. Previously, it was known how to self-test univariate polynomials over rational domains <ref> [RS92] </ref>, but this required that the program being tested work correctly on a rational domain of finer precision. Our work removes that requirement, transferring the overhead to the self-tester. <p> The main advantage of M being invertible, or equivalently, '(n) being defined on positive and negative values of n, is that we may appeal to a known adaptation of the BLR test, due to Rubinfeld [Rub94], building on ideas from [GLR + 91] and <ref> [RS92] </ref>. In this case, by careful choice of parameters, Rubinfeld's self-tester works for ffi up to 1=24, and guarantees that the program works correctly for a large fraction of D N , roughly the set fn j N=10 &lt; n &lt; N=10g. <p> This gives us a new self-tester for univariate polynomials over the finite field Z=(p) that achieves the bound ffi &lt; 2=9, improving all previously known results for this case <ref> [RS92, RS93, FS95] </ref>. We note that effectively the test conducted by the self-tester is extremely simple: all it does is to check the convolution identity at multiple points simultaneously. The convolution identity, of course, was derived from the Lagrange interpolation identity. <p> In the Appendix, we illustrate how to extend our scheme for testing univariate polynomials over rational domains. Our approach strengthens the result of Rubinfeld and Sudan <ref> [RS92] </ref> in two respects: the domain size on which the program is expected to be correct is much smaller, and the value of ffi we achieve is (1), whereas their result achieved only O (1=d). More details of the following theorem are given in the Appendix.
Reference: [RS93] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characterizations of polynomials and their applications to program testing. </title> <type> TR 93-1387, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <year> 1993. </year> <note> To appear in SIAM Journal of Computing. </note>
Reference-contexts: The proof is similar in flavor to the proof of the Blum-Luby-Rubinfeld theorem attributed to Coppersmith (see <ref> [BLR93, RS93] </ref>), but requires an additional trick. The proof is presented in the Appendix, where we also show how to build self-testers for convolutions over groups, and obtain the following result. <p> This gives us a new self-tester for univariate polynomials over the finite field Z=(p) that achieves the bound ffi &lt; 2=9, improving all previously known results for this case <ref> [RS92, RS93, FS95] </ref>. We note that effectively the test conducted by the self-tester is extremely simple: all it does is to check the convolution identity at multiple points simultaneously. The convolution identity, of course, was derived from the Lagrange interpolation identity.
Reference: [RS95] <author> S. Ravikumar and D. Sivakumar. </author> <title> On self-testing without the generator bottleneck. </title> <type> UBCS-TR 95-43, </type> <institution> Computer Science Dept., University at Buffalo, </institution> <year> 1995. </year> <note> To appear in Proc. 15th FST & TCS, </note> <institution> Bangalore, India, </institution> <year> 1995. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92].
Reference: [Rub90] <author> R. Rubinfeld. </author> <title> A Mathematical Theory of Self-Checking, Self-Testing, and Self-Correcting Programs. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1990. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92].
Reference: [Rub94] <author> R. Rubinfeld. </author> <title> Robust functional equations with applications to self-testing/correcting. </title> <booktitle> In Proc. 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 288-299, </pages> <year> 1994. </year>
Reference-contexts: Another main thrust of this research program has been to build realistic program self-testers that can be used, for example, in testing the correctness of VLSI chips designed to implement special functions, numerical algorithms, etc. Some of the main developments along this line of research includes the work in <ref> [Rub90, CL90, RS92, ABCG93, Rub94, Erg95, RS95] </ref>. These two lines of research have vastly benefited from each other, particularly exemplified by the combination of ideas from [AS92] and [RS92], culminating in the results of [ALM + 92]. <p> The main advantage of M being invertible, or equivalently, '(n) being defined on positive and negative values of n, is that we may appeal to a known adaptation of the BLR test, due to Rubinfeld <ref> [Rub94] </ref>, building on ideas from [GLR + 91] and [RS92].
References-found: 17

