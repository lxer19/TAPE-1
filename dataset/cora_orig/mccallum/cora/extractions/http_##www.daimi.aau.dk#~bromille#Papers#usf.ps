URL: http://www.daimi.aau.dk/~bromille/Papers/usf.ps
Refering-URL: http://www.daimi.aau.dk/~bromille/Papers/index.html
Root-URL: http://www.daimi.aau.dk
Email: Email: pbmilter@dcs.warwick.ac.uk  pbmiltersen@daimi.aau.dk  
Title: Lower bounds for Union-Split-Find related problems on random access machines  
Author: Peter Bro Miltersen 
Web: or  
Address: CV4 7AL, U.K.  
Note: This work was supported by a grant from the Danish Natural Science Research Council. It was partially supported by the ESPRIT II Basic Research Actions Program of the European Community under contract No. 7141 (project ALCOM II). Address:  
Affiliation: Aarhus University and University of Warwick  University of Warwick, Department of Computer Science, Coventry  
Abstract: We prove ( p log log n) lower bounds on the random access machine complexity of several dynamic, partially dynamic and static data structure problems, including the Union-Split-Find problem, dynamic prefix problems and one-dimensional range query problems. The proof techniques include a general technique using perfect hashing for reducing static data structure problems (with a restriction of the size of the structure) into partially dynamic data structure problems (with no such restriction), thus providing a way to transfer lower bounds. We use a generalization of a method due to Ajtai for proving the lower bounds on the static problems, but describe the proof in terms of communication complexity, revealing a striking similarity to the proof used by Karchmer and Wigderson for proving lower bounds on the monotone circuit depth of connectivity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal, J. Scott Vitter, </author> <title> The I/O complexity of sorting and related problems, </title> <booktitle> in: Proc. 14th International Colloquium on Automata, Languages and Programming (1987) 467-478. </booktitle>
Reference-contexts: larger than polylogarithmic) that the lower bound also becomes relevant as a lower bound for the complexity of implementing the data type on secondary storage, where data must be transferred to and from this secondary storage in large chunks, the number of such transferals being the I/O-complexity of the computation <ref> [1] </ref>. Previously, the following bounds on the complexity of Union-Split-Find and Split-Find were known: UNION-SPLIT-FIND (n) can be implemented on a random access computer so that all operations have worst case complexity O (log log n). <p> Given n such that log log n is an integer, and i log log n define [n] (i) to be the following set of intervals: [n] (i) = f <ref> [1; n 2 i +1; 2n 2 i +1; n] </ref>g For an interval I 2 [n] (i) , we note that I is the disjoint union of intervals in [n] (i+1) . We denote the set of these intervals by I 0 .
Reference: [2] <author> M. Ajtai, </author> <title> A lower bound for finding predecessors in Yao's cell probe model, </title> <note> Combinatorica 8 (1988) 235-247. </note>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free. <p> Previously known bounds: Willard [23] showed that there is a storage scheme using O (jM j) cells of size O (log n) such than any query can be answered in time O (log log n). Ajtai <ref> [2] </ref> showed a non-constant lower bound for cell size O (log n) and the set of queries "What is jM " [i; j]j?". <p> Since Pr (Z 0 ) Pr (Z 0 j:C) + Pr (C), we are done. 2 We need the following lemma by Ajtai <ref> [2] </ref> for the proof of Lemma 9. Lemma 12 (Ajtai) Let A [n] have density [n] (A) ae and let Q be any equivalence relation on A with d equivalence classes. Let I 2 [n] (k) for some k 1.
Reference: [3] <author> M. </author> <title> Ajtai, </title> <type> Personal communication. </type>
Reference-contexts: In his paper, Ajtai states that an (log log n) lower bound is achievable using his technique, but he has later reduced his claim to only ( p log log n) <ref> [3] </ref>, so Theorem 3 is a strict gen eralization of his lower bound. Outline of paper and proof techniques In Section 2 below, we show how all the lower bounds in the Introduction follows from a lower bound for a communication game.
Reference: [4] <author> M. Ajtai, M. Fredman, J. Komlos, </author> <title> Hash functions for priority queues, </title> <booktitle> in: Proc. 24th Ann. IEEE Symp. on Foundations of Computer Science (1983) 299-303. </booktitle>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free.
Reference: [5] <author> D. Angluin, L.G. Valiant, </author> <title> Fast Probabilistic Algorithms for Hamiltonian Circuits and Matchings, </title> <journal> J. Comput. System Sci. </journal> <month> 18 </month> <year> (1979) </year> <month> 155-193. </month>
Reference-contexts: O (log n) 2 (log n) 1* , the lower bound is also valid as a lower bound for the complexity of implementing the data type on a unit cost random access machine where each machine word is restricted to storing a polynomial sized integer (a random ac cess computer <ref> [5] </ref>), no matter what instruction set is used.
Reference: [6] <author> B. Chazelle, </author> <title> Lower bounds for orthogonal range searching, II: The arithmetic model, </title> <journal> J. Assoc. Comp. Mach. </journal> <month> 37 </month> <year> (1990) </year> <month> 439-463. </month>
Reference-contexts: One should note that good lower bounds for similar problems are available in natural, weaker, structured, algebraic models of computation <ref> [6, 21, 25] </ref>). A lower bound for the problem of polynomial evaluation with preprocessing of coefficients is obtained in [19] using the communication complexity method.
Reference: [7] <author> P. Elias, R.A. Flower, </author> <title> The complexity of some simple retrieval problems, </title> <journal> J. Assoc. Comp. Mach. </journal> <month> 22 </month> <year> (1975) </year> <month> 367-379. </month>
Reference: [8] <author> G.S. Frandsen, P.B. Miltersen, S. Skyum, </author> <title> Dynamic word problems, </title> <booktitle> in: Proc. 34th Ann. IEEE Symp. on Foundations of Computer Science (1993) 470-479. </booktitle>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free. <p> La Poutre [15] shows that any implementation of SPLIT-FIND (n) on a pointer machine has worst case complexity (log log n). Dynamic prefix problems Dynamic prefix problems in the decision assignment tree model were considered by Fredman and Saks [12] and Frandsen, Miltersen and Skyum <ref> [8] </ref>. Let M be a fixed finite monoid, i.e. a finite set equipped with an associative binary operation ffi and containing an identity element 1. <p> This result is due to Fredman and Saks [12]. * If M does not contain a group, then M -PREFIX (n) can be implemented on a random access computer with all operations having worst case complexity O (log log n). This result is due to Frandsen, Miltersen and Skyum <ref> [8] </ref>. <p> OR problem M -PREFIX (n) where M = (f0; 1g; _), or, equivalently, the "Union-Split-First" problem, where one, in addition to the union i and split i operations have an operation first i which reveals if i is smaller than the smallest element in S. * The dynamic word problem <ref> [8] </ref> for the carry-look-ahead monoid.
Reference: [9] <author> M.L. Fredman, </author> <title> Observations on the complexity of generating quasi-Gray codes, </title> <journal> SIAM J. Comput. </journal> <month> 7 </month> <year> (1978) </year> <month> 134-146. </month>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free.
Reference: [10] <author> M.L. Fredman, </author> <title> The complexity of maintaining an array and computing its partial sums, </title> <journal> J. Assoc. Comput. Mach. </journal> <month> 29 </month> <year> (1982) </year> <month> 250-260. </month>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free.
Reference: [11] <author> M.L. Fredman, J. Komlos, E. Szemeredi, </author> <title> Storing a sparse table with O(1) worst case access time, </title> <journal> J. Assoc. Comput. Mach. </journal> <month> 31 </month> <year> (1984) </year> <month> 538-544. </month>
Reference-contexts: This operation returns true if x 1 x 2 : : : x i =? 2 L and false otherwise. We need the following fact, due to Fredman, Komlos and Szemeredi <ref> [11] </ref>. By an n-dictionary, we mean a subset S [n] and a map d : S ! [n].
Reference: [12] <author> M.L. Fredman, </author> <title> M.E. Saks, The cell probe complexity of dynamic data structures, </title> <booktitle> in: Proc. 21st Ann. ACM Symp. on Theory of Computing (1989) 345-354. </booktitle>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free. <p> La Poutre [15] shows that any implementation of SPLIT-FIND (n) on a pointer machine has worst case complexity (log log n). Dynamic prefix problems Dynamic prefix problems in the decision assignment tree model were considered by Fredman and Saks <ref> [12] </ref> and Frandsen, Miltersen and Skyum [8]. Let M be a fixed finite monoid, i.e. a finite set equipped with an associative binary operation ffi and containing an identity element 1. <p> Previously known bounds on the complexity of M -PREFIX (n) are * If M contains a group as a subset, then the cell size b = polylogn cell probe complexity of M -PREFIX (n) is fi (log n= log log n). This result is due to Fredman and Saks <ref> [12] </ref>. * If M does not contain a group, then M -PREFIX (n) can be implemented on a random access computer with all operations having worst case complexity O (log log n). This result is due to Frandsen, Miltersen and Skyum [8].
Reference: [13] <author> T. Imai, T. Asano, </author> <title> Dynamic segment intersection with applications, </title> <booktitle> in: Proc. 25th Ann. IEEE Symp. on Foundations of Computer Science (1984) 393-402. </booktitle>
Reference-contexts: Furthermore, if we allow the complexities of union and split operations to be n * , then find can be performed in constant time. This is due to Van Emde Boas, Kaas and Zijlstra [22]. Imai and Asano <ref> [13] </ref> prove that SPLIT-FIND (n) can be implemented on a random access computer so that the amortized complexity of the operations is O (1) (i.e. for any m, m operations can be performed in time O (m)). On the pointer machine model, some more bounds were known.
Reference: [14] <author> M. Karchmer, A. Wigderson, </author> <title> Monotone circuits for connectivity require super-logarithmic depth, </title> <booktitle> in: Proc. 18th Ann. ACM Symp. on Theory of Computing (1988) 539-550. </booktitle>
Reference-contexts: Furthermore, readers familiar with the proof used by Karchmer and Wigderson for proving lower bounds on the monotone circuit depth of connectivity <ref> [14] </ref> will appreciate the striking similarity between the two proofs. 2 Reductions In this section we show how all the results stated in the introduction follow from Theorem 4 below. We need some definitions. Let be a finite alphabet and let L fl be a language.
Reference: [15] <author> J.A. La Poutre, </author> <title> Lower bounds for the Union-Find and the Split-Find problem on pointer machines, </title> <booktitle> in: Proc. 20th Ann. ACM Symp. on Theory of Computing (1990) 34-44. </booktitle>
Reference-contexts: In that case, Mehlhorn and Naher [16] show that UNION-SPLIT-FIND (n) can be implemented so that all operations have worst case complexity O (log log n). Mehlhorn, Naher and Alt [17] show that any implementation on a pointer machine has amortized complexity (log log n). La Poutre <ref> [15] </ref> shows that any implementation of SPLIT-FIND (n) on a pointer machine has worst case complexity (log log n). Dynamic prefix problems Dynamic prefix problems in the decision assignment tree model were considered by Fredman and Saks [12] and Frandsen, Miltersen and Skyum [8].
Reference: [16] <author> K. Mehlhorn, S. Naher, </author> <title> Dynamic fractional cascading, </title> <note> Algorithmica 5 (1990). </note>
Reference-contexts: The statement of the problem must be modified slightly so that it becomes meaningful for pointer machines, see Mehlhorn, Naher and Alt [17]. The original and the modified problem are equivalent for random access computers. In that case, Mehlhorn and Naher <ref> [16] </ref> show that UNION-SPLIT-FIND (n) can be implemented so that all operations have worst case complexity O (log log n). Mehlhorn, Naher and Alt [17] show that any implementation on a pointer machine has amortized complexity (log log n).
Reference: [17] <author> K. Mehlhorn, S. Naher, H. Alt, </author> <title> A lower bound on the complexity of the union-split-find problem, </title> <journal> SIAM J. Comput. </journal> <pages> 17(1988) 1093-1102. </pages>
Reference-contexts: The statement of the problem must be modified slightly so that it becomes meaningful for pointer machines, see Mehlhorn, Naher and Alt <ref> [17] </ref>. The original and the modified problem are equivalent for random access computers. In that case, Mehlhorn and Naher [16] show that UNION-SPLIT-FIND (n) can be implemented so that all operations have worst case complexity O (log log n). Mehlhorn, Naher and Alt [17] show that any implementation on a pointer <p> pointer machines, see Mehlhorn, Naher and Alt <ref> [17] </ref>. The original and the modified problem are equivalent for random access computers. In that case, Mehlhorn and Naher [16] show that UNION-SPLIT-FIND (n) can be implemented so that all operations have worst case complexity O (log log n). Mehlhorn, Naher and Alt [17] show that any implementation on a pointer machine has amortized complexity (log log n). La Poutre [15] shows that any implementation of SPLIT-FIND (n) on a pointer machine has worst case complexity (log log n).
Reference: [18] <author> P.B. Miltersen, </author> <title> The bit probe complexity measure revisited, </title> <booktitle> in: Proc. 10th Symp. on Theoretical Aspects of Computer Science (1993) 662-671. </booktitle>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free. <p> We then show how to reduce static problems to (partially) dynamic problems using constant time static dictionaries. This technique is implicitly present in the paper of Willard [23] and was used in a weaker form in <ref> [18] </ref>. In Section 3, we prove the lower bound for the communication game. The proof technique is a generalization of the one used by Ajtai for proving the lower bound on the static problem mentioned above, but in our opinion, the communication complexity framework makes its structure much clearer.
Reference: [19] <author> P.B. Miltersen, </author> <title> On the cell probe complexity of polynomial evaluation, </title> <type> Manuscript 1994. </type>
Reference-contexts: One should note that good lower bounds for similar problems are available in natural, weaker, structured, algebraic models of computation [6, 21, 25]). A lower bound for the problem of polynomial evaluation with preprocessing of coefficients is obtained in <ref> [19] </ref> using the communication complexity method.
Reference: [20] <author> P.B. Miltersen, S. Subramanian, J.S. Vit-ter, R. Tamassia, </author> <title> Complexity models for incremental computation, </title> <note> Theoretical Computer Science, to appear. </note>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free.
Reference: [21] <author> P.M. Vaidya, </author> <title> Space-time tradeoffs for orthogonal range queries, </title> <journal> SIAM J. Comput. </journal> <month> 18 </month> <year> (1989) </year> <month> 748-458. </month>
Reference-contexts: One should note that good lower bounds for similar problems are available in natural, weaker, structured, algebraic models of computation <ref> [6, 21, 25] </ref>). A lower bound for the problem of polynomial evaluation with preprocessing of coefficients is obtained in [19] using the communication complexity method.
Reference: [22] <author> P. Van Emde Boas, R. Kaas, E. Zijlstra, </author> <title> Design and implementation of an efficient priority queue, </title> <journal> Math. </journal> <note> Systems Theory 10 (1977) 99-127. </note>
Reference-contexts: Furthermore, if we allow the complexities of union and split operations to be n * , then find can be performed in constant time. This is due to Van Emde Boas, Kaas and Zijlstra <ref> [22] </ref>. Imai and Asano [13] prove that SPLIT-FIND (n) can be implemented on a random access computer so that the amortized complexity of the operations is O (1) (i.e. for any m, m operations can be performed in time O (m)).
Reference: [23] <author> D.E. Willard, </author> <title> Log-logarithmic worst case range queries are possible in space fi(n), </title> <journal> Inform. Process. Lett. </journal> <month> 17 </month> <year> (1983) </year> <month> 81-84. </month>
Reference-contexts: Previously known bounds: Willard <ref> [23] </ref> showed that there is a storage scheme using O (jM j) cells of size O (log n) such than any query can be answered in time O (log log n). <p> This reduction is really a rather trivial observation, but we find it illuminating and useful. We then show how to reduce static problems to (partially) dynamic problems using constant time static dictionaries. This technique is implicitly present in the paper of Willard <ref> [23] </ref> and was used in a weaker form in [18]. In Section 3, we prove the lower bound for the communication game.
Reference: [24] <author> A.C. Yao, </author> <title> Should tables be sorted?, </title> <journal> J. Assoc. Comput. Mach. </journal> <month> 28 </month> <year> (1981) </year> <month> 615-628. </month>
Reference-contexts: The Split-Find problem SPLIT-FIND (n) is defined in the same way, except that union i operations are not allowed. In this paper, we consider implementing data types in the cell probe or decision assignment tree model, studied in several papers <ref> [2, 4, 8, 9, 10, 12, 18, 20, 24] </ref>. In this model, the complexity of a computation is the number of cells accessed in the random access memory containing the data structure during the computation, while the computation itself is for free.
Reference: [25] <author> A.C. Yao, </author> <title> On the complexity of maintaining partial sums, </title> <journal> SIAM J. Comput. </journal> <month> 14 </month> <year> (1985) </year> <month> 277-288. </month>
Reference-contexts: One should note that good lower bounds for similar problems are available in natural, weaker, structured, algebraic models of computation <ref> [6, 21, 25] </ref>). A lower bound for the problem of polynomial evaluation with preprocessing of coefficients is obtained in [19] using the communication complexity method.
References-found: 25

