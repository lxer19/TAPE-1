URL: http://www.cs.arizona.edu/people/tods/accepted/1997/StolboushkinSafe.ps
Refering-URL: http://www.cs.arizona.edu/people/tods/Upcoming.html
Root-URL: http://www.cs.arizona.edu
Note: This is a preliminary release of an article accepted by ACM Transactions on Database Systems. The definitive version is currently in production at ACM and, when released, will supersede this version.  
Abstract: Copyright 1997 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to Post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or permissions@acm.org. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: This means that the result of one program, or its negation, can be used as input for another program. This leads to the notion of Datalog with stratified negation, or Datalog :;&lt; z , where negations are allowed, but only w.r.t. the intensional predicates whose computation already terminated (cf. <ref> [1] </ref>). This machinery only works well, however, if the Datalog program terminates. If it does not, the construction collapses. One remedy is to consider only those Datalog :;&lt; z -programs whose termination is guaranteed for all inputs. Such programs often are called safe.
Reference: [2] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proc. 14th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: This process is much more efficient than the tuple-based evaluation. However, the expressive power of first-order queries in this domain is severely limited. This motivated research into using constraint logic programs (see <ref> [2, 3] </ref>) for querying finitely representable databases over the integer order. Logic programs without negation, when they terminate, result in f.r. answers too. This means that the result of one program, or its negation, can be used as input for another program.
Reference: [3] <author> J. Jaffar and M.J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:503-581, </volume> <year> 1994. </year>
Reference-contexts: This process is much more efficient than the tuple-based evaluation. However, the expressive power of first-order queries in this domain is severely limited. This motivated research into using constraint logic programs (see <ref> [2, 3] </ref>) for querying finitely representable databases over the integer order. Logic programs without negation, when they terminate, result in f.r. answers too. This means that the result of one program, or its negation, can be used as input for another program.
Reference: [4] <author> P.C. Kanellakis and D.Q. Goldin. </author> <title> Constraint programming and database query languages. </title> <booktitle> In Proc. International Symposium on Theoretical Aspects of Computer Software (TACS'94), </booktitle> <pages> pages 96-120, </pages> <year> 1994. </year>
Reference: [5] <author> P.C. Kanellakis, G.M. Kuper, and P.Z. Revesz. </author> <title> Constraint query languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(1) </volume> <pages> 26-52, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: For domains that admit elim-ination of quantifiers in first-order formulas, Kanellakis et al. <ref> [5] </ref> suggested using finitely representable (f.r.) database states, where extensional database predicates are defined as quantifier-free first-order formulas. Because of the elimination of quantifiers, answers to first-order queries in f.r. states are, again, f.r.
Reference: [6] <author> P.Z. Revesz. </author> <title> A closed form evaluation for Datalog queries with integer (gap)- order constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> 116(1) </volume> <pages> 117-149, </pages> <year> 1993. </year> <month> 10 </month>
Reference-contexts: Although by appearance, the result looks similar to the one by P. Revesz (Proposition 2.3 in <ref> [6] </ref>) that any Turing-computable function is expressible by a query of Datalog :;&lt; z , a closer look reveals that the the two results are altogether different. To emphasize only one distinction, the programs that express (total) Turing-computable functions in [6] need not terminate under the bottom-up semantics, hence, they may <p> Revesz (Proposition 2.3 in <ref> [6] </ref>) that any Turing-computable function is expressible by a query of Datalog :;&lt; z , a closer look reveals that the the two results are altogether different. To emphasize only one distinction, the programs that express (total) Turing-computable functions in [6] need not terminate under the bottom-up semantics, hence, they may not be safe. 1 Definitions Throughout this paper, we deal with the domain Z of integer numbers together with the relations = of equality, &lt; of the integer linear order, and &lt; g of the integer gap order, for all
Reference: [7] <author> P.Z. Revesz. </author> <title> Safe stratified Datalog with integer order programs. </title> <type> Manuscript, </type> <month> August </month> <year> 1995. </year>
Reference-contexts: If it does not, the construction collapses. One remedy is to consider only those Datalog :;&lt; z -programs whose termination is guaranteed for all inputs. Such programs often are called safe. Notice that this definition is semantical in nature. 1 Revesz <ref> [7] </ref> introduced a syntactical notion of safety for Datalog :;&lt; z -programs, which guarantees semantical safety. The syntax is remarkably powerful|queries expressible in this syntax may have non-elementary complexity|and yet easy (=PTime) to check. <p> In this paper, we ultimately settle this problem by showing that no syntax exists for all semantically safe queries of Datalog :;&lt; z . In particular, the syntax introduced in <ref> [7] </ref> is incomplete. Formally, we show that any recursively enumerable set of Datalog :;&lt; z -programs either contains infinitely many unsafe programs, or does not contain any program for infinitely many safe Datalog :;&lt; z -definable queries.
Reference: [8] <author> H. Rogers Jr. </author> <title> Theory of recursive functions and effective computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year> <month> 11 </month>
Reference-contexts: Such enumeration is known to be impossible (see <ref> [8] </ref>). Q.E.D.
References-found: 8

