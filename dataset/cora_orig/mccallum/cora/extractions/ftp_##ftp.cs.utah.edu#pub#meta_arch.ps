URL: ftp://ftp.cs.utah.edu/pub/meta_arch.ps
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: The Design of Object-Oriented Meta-Architectures For Programming Languages  
Author: Guruduth Banavar and Gary Lindstrom 
Address: Salt Lake City  
Affiliation: Department of Computer Science University of Utah,  
Abstract: This paper is a survey of the design of four object-oriented meta-level architectures for programming languages. We present overviews and compare the salient features of the architectures of Smalltalk, Metaobject Protocols for CLOS and Scheme Compilers, and Etyma, our framework for modular systems. This comparison clarifies important architectural aspects of the surveyed systems, such as the abstractions that embody similar language concepts across the architectures, and the capture of crucial O-O semantics. We find that there are considerable differences in the goals, application requirements, and conceptions of these architectures, yet they can all be used for similar applications. Finally, we point out some strengths and weaknesses of the architectures surveyed.
Abstract-found: 1
Intro-found: 1
Reference: [BBC + 94] <author> Guruduth Banavar, Gilad Bracha, Charles F. Clark, Gary Lindstrom, and Douglas B. Orr. </author> <title> Evolutionary support for modular software architectures. </title> <type> Unpublished report, </type> <month> February </month> <year> 1994. </year>
Reference-contexts: Etyma is being used as the meta-architectural framework for a larger initiative for evolutionary support for modular architectures <ref> [BBC + 94] </ref>, in which a module-based server-style linker/loader is being designed as an extension.
Reference: [BL92] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: On the other hand, if a language is compiled, meta-code can be processed at compile-time and/or at run-time. In this paper, we contrast the three meta-architectures mentioned above, Smalltalk, CLOS MOP, and the Scheme compiler MOP, along side our own meta-architecture based on a language called Jigsaw <ref> [BL92] </ref>. Smalltalk and CLOS are general-purpose O-O languages that enjoy significant followings. Smalltalk was built ground-up based on a remarkably coherent meta-architecture, while the meta-architecture for CLOS was retrofitted onto the language. <p> In [BL93], we have described a preliminary C++ prototype implementation of Etyma. The client language is in general unrelated to the framework implementation language | an extension of Modula-3, Modula-, is presented in <ref> [BL92] </ref>, and examples of a simple applicative language, and a simple imperative language based on C++ are given in [BL93].
Reference: [BL93] <author> Guruduth Banavar and Gary Lindstrom. </author> <title> A framework for module-based language processors. </title> <institution> Computer Science Department Technical Report UUCS-93-006, University of Utah, </institution> <month> March 5, </month> <year> 1993. </year>
Reference-contexts: In fact, Etyma can be used to describe and build processors for almost any system that can be construed to be module-based, as described above. In <ref> [BL93] </ref>, we have described a preliminary C++ prototype implementation of Etyma. <p> The client language is in general unrelated to the framework implementation language | an extension of Modula-3, Modula-, is presented in [BL92], and examples of a simple applicative language, and a simple imperative language based on C++ are given in <ref> [BL93] </ref>. Etyma is being used as the meta-architectural framework for a larger initiative for evolutionary support for modular architectures [BBC + 94], in which a module-based server-style linker/loader is being designed as an extension.
Reference: [BLO94] <author> Guruduth Banavar, Gary Lindstrom, and Douglas Orr. </author> <title> Type-safe composition of object modules. </title> <booktitle> In Proc. International Conference on Computer Systems and Education, </booktitle> <address> Bangalore, India, </address> <month> June 22-25, </month> <year> 1994. </year> <note> Also available as Technical Report UUCS-94-001. </note>
Reference-contexts: In this extension, UNIX ".o" and ".so" object files are regarded as specializations of class Module, thus enabling the use of comprehensive inheritance semantics [OM92] and type checking <ref> [BLO94] </ref> in their composition. 6 A MOP for Scheme Compilers Like the CLOS MOP, this MOP carefully chooses a useful portion of the internal functionality of a scheme compiler in order to provide the Scheme programmer with the desirable attributes of flexibility and control over layout and access over run-time data.
Reference: [Bra92] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw : Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp. </note>
Reference-contexts: Also, the requirements of static typing and separate compilation make it impossible to express the Jigsaw language (on which Etyma is based) using itself. The details of this are beyond the scope of this paper <ref> [Bra92] </ref>. Hence, Smalltalk and CLOS MOP can be said to support run-time reflection, whereas the Scheme MOP and Etyma support compile-time reflection. We now turn to a more detailed treatment of specific meta-architectures. 3 Smalltalk Smalltalk is based on a uniform model of communicating objects.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A recently proposed O-O model for a compiler for a non O-O language, Scheme, [LKRR92] is another example. One of the earliest O-O programming systems, Smalltalk-80 <ref> [GR83] </ref>, was itself built upon an intricately interconnected group of meta-classes.
Reference: [JR91] <author> Ralph E. Johnson and Vincent F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: 1 Introduction Object-orientation is a popular design technique that has been used to model application domains of all varieties <ref> [JR91] </ref>. A recently emerging trend is to apply the object-oriented (O-O) method to the design of O-O language processors themselves, thereby harnessing the touted advantages of abstraction and reuse in this domain also. <p> The CLOS MOP designers deal with this tradeoff by explicitly specifying restrictions on the usage of the MOP. A language meta-architecture supports reuse of design and code just as a domain specific O-O framework does. O-O frameworks for several domains have been constructed <ref> [JR91] </ref>. An O-O framework can be used as a reusable domain model for O-O languages and systems | indeed, this is a primary goal of Etyma. Another design issue is the execution time of program fragments that access the meta-architecture. <p> These include specialized classes such as counted classes and encapsulated classes. CLOS MOP has also been utilized to provide a significant persistence facility [Lee92]. 5 Etyma Etyma is a general meta-level architecture for O-O languages realized as a C++ framework (in the sense of <ref> [JR91] </ref>). The primary abstractions of Etyma are based on a language called Jigsaw, a module manipulation language intended to model the semantic foundations of object-orientation, especially inheritance, in all its forms.
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: A recently emerging trend is to apply the object-oriented (O-O) method to the design of O-O language processors themselves, thereby harnessing the touted advantages of abstraction and reuse in this domain also. For example, the Meta Object Protocol for the Common LISP Object System (CLOS) <ref> [KdRB91] </ref> is an O-O model of certain useful concepts in CLOS. A recently proposed O-O model for a compiler for a non O-O language, Scheme, [LKRR92] is another example. One of the earliest O-O programming systems, Smalltalk-80 [GR83], was itself built upon an intricately interconnected group of meta-classes. <p> For instance, a top layer protocol concerned with inheritance is the generic function finalize-inheritance, which delegates to the next layer, compute-class-precedence-list and compute-slots, which further delegates to compute-effective-slot-definition. A large number of applications that the CLOS MOP can be put to are illustrated in <ref> [KdRB91] </ref>. These include specialized classes such as counted classes and encapsulated classes. CLOS MOP has also been utilized to provide a significant persistence facility [Lee92]. 5 Etyma Etyma is a general meta-level architecture for O-O languages realized as a C++ framework (in the sense of [JR91]).
Reference: [Kee89] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: Furthermore, a protocol (MOP) has been carefully designed and documented to access this meta-architecture usefully. The CLOS object system supports the standard concept of classes, which can be instantiated into instances <ref> [Kee89] </ref>. Class attributes are called slots. A distinguishing feature of the CLOS model is the notion of generic functions which are defined independent of any class, and can be specialized into methods that are applicable to specific classes. Generic functions can be dispatched based on multiple arguments (multi-methods).
Reference: [Kic93] <author> Gregor Kiczales. </author> <title> Traces (a cut at the "make isn't generic" problem). </title> <booktitle> In Proc. of Int'l Symposium on Object Technologies for Advanced Software, volume 742 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This architecture decouples the language of the static processor (compiler), and hence the meta-architecture, from the source language itself | thus it is not meta-circular. The meta-architecture is expressed in an O-O extension of LISP called Traces <ref> [Kic93] </ref>. This meta-architecture attempts to capture certain aspects, such as procedures and pairs, of a non O-O base language, Scheme.
Reference: [KLM94] <author> Gregor Kiczales, John Lamping, and Anurag Mendhekar. </author> <title> What a metaobject protocol based compiler can do for lisp. </title> <type> Unpublished report., </type> <year> 1994. </year>
Reference-contexts: Many of the details of this MOP 10 are still under development <ref> [LKRR92, KLM94] </ref>, so we only give a general description of it. Unlike the CLOS MOP, this is a compile-time MOP, i.e. the accessible meta-architecture is specializable to control the static bahavior of the compiler. Such static specialization can, and will, be utilized at run-time. <p> For instance, when a function application is required to generate code, it delegates the job to its contract metaobject, which further requests the appropriate program graph metaobjects to generate RTL metaobjects. A few applications of the Scheme MOP are illustrated in <ref> [KLM94] </ref>. These include extending the base Scheme language to support procedures with extra data attached to them, immutable data structures, and procedures that are dispatched based on the number of input parameters. 7 Summary and Conclusions In this section, we attempt a summary of the meta-architectures surveyed.
Reference: [Lee92] <author> Arthur H. Lee. </author> <title> The Persistent Object System MetaStore: Persistence Via Metaprogramming. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> June </month> <year> 1992. </year> <note> Technical report UUCS-92-027; 171 pp. </note>
Reference-contexts: A large number of applications that the CLOS MOP can be put to are illustrated in [KdRB91]. These include specialized classes such as counted classes and encapsulated classes. CLOS MOP has also been utilized to provide a significant persistence facility <ref> [Lee92] </ref>. 5 Etyma Etyma is a general meta-level architecture for O-O languages realized as a C++ framework (in the sense of [JR91]).
Reference: [LKRR92] <author> John Lamping, Gregor Kiczales, Luis Rodriquez, and Erik Ruf. </author> <title> An architecture for an open compiler. </title> <booktitle> In Proc. of the IMSA '92 Workshop on Reflection and Meta-level Architectures, </booktitle> <year> 1992. </year>
Reference-contexts: For example, the Meta Object Protocol for the Common LISP Object System (CLOS) [KdRB91] is an O-O model of certain useful concepts in CLOS. A recently proposed O-O model for a compiler for a non O-O language, Scheme, <ref> [LKRR92] </ref> is another example. One of the earliest O-O programming systems, Smalltalk-80 [GR83], was itself built upon an intricately interconnected group of meta-classes. <p> Many of the details of this MOP 10 are still under development <ref> [LKRR92, KLM94] </ref>, so we only give a general description of it. Unlike the CLOS MOP, this is a compile-time MOP, i.e. the accessible meta-architecture is specializable to control the static bahavior of the compiler. Such static specialization can, and will, be utilized at run-time.
Reference: [OM92] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. 14 </note>
Reference-contexts: In this extension, UNIX ".o" and ".so" object files are regarded as specializations of class Module, thus enabling the use of comprehensive inheritance semantics <ref> [OM92] </ref> and type checking [BLO94] in their composition. 6 A MOP for Scheme Compilers Like the CLOS MOP, this MOP carefully chooses a useful portion of the internal functionality of a scheme compiler in order to provide the Scheme programmer with the desirable attributes of flexibility and control over layout and
References-found: 14

