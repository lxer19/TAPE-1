URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-005-91.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Email: calton@cs.columbia.edu  
Title: A Lock-Free Multiprocessor OS Kernel  
Author: Henry Massalin and Calton Pu 
Date: Revised June 19, 1991  
Address: New York, NY 10027  
Affiliation: Department of Computer Science Columbia University  
Pubnum: Technical Report No. CUCS-005-91  
Abstract: Typical shared-memory multiprocessor OS kernels use interlocking, implemented as spin-locks or waiting semaphores. We have implemented a complete multiprocessor OS kernel (including threads, virtual memory, and I/O including a window system and a file system) using only lock-free synchronization methods based on Compare-and-Swap. Lock-free synchronization avoids many serious problems caused by locks: considerable overhead, concurrency bottlenecks, deadlocks, and priority inversion in real-time scheduling. Measured numbers show the low overhead of our implementation, competitive with user-level thread management systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.E. Anderson. </author> <title> The performance of spin lock alternatives for shared-memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Mutual exclusion is commonly accepted as the standard synchronization technique in OS kernels. In multiprocessors, mutual exclusion may be achieve through waiting locks and spin-locks. Anderson <ref> [1] </ref> analyzed the performance and overhead trade-offs of spin-locks for multiprocessor systems, finding considerable potential for system performance degradation due to mutual exclusion.
Reference: [2] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levey. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <type> Technical Report 90-04-02, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Synthesis has a general-purpose kernel-threads system with performance an order-of-magnitude greater than other comparable kernel-threads systems such as Mach, and similar in performance to user-level threads <ref> [2] </ref> from University of Washington. 4.1 Scheduling and Dispatching Each thread is described by a thread table entry (TTE). V.0 had a single run-queue with round-robin scheduling. <p> Another paper describing concurrent access to queues is by Stone [12], who used Compare-and-Double-Swap involving two double words. In contrast, Synthesis use of lock-free synchronization is much more general since we have applied these techniques to implement an entire OS kernel. Anderson et al. <ref> [2] </ref> have argued that kernel implementation of threads are necessarily more expensive than user-level thread management systems.
Reference: [3] <author> D.L. Black. </author> <title> Scheduling support for concurrency and parallelism in the Mach operating system. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: However, there has been no empirical evidence that OS kernels using this kind of lock-free synchronization methods achieve better performance than state-of-art multiprocessor OS kernel implementations using lock-based synchronization (e.g., spin-locks and semaphores), such as Mach <ref> [3] </ref> and Psyche [11]. The version 1 (abbreviated V.1) of Synthesis kernel implemented on a dual-68030 Sony NEWS workstation is based entirely on lock-free synchronization, developed from the optimistic synchronization methods developed for the single-processor version 0 of Synthesis [8]. The implementation of Synthesis V.1 shows three things. <p> For example, Mach uses a single lock for the global run-queue. This can cause significant contention if several processors try to access the queue at the same time, as would occur when the scheduler clocks are synchronized <ref> [3] </ref>. One way to reduce the lock contention in Mach relies on scheduling "hints" from the programmer. For example, hand-off hints may give control directly to the destination thread, bypassing the run queue. Although hints may decrease lock contention for specific cases, their use is difficult and their benefits uncertain. <p> The ramdisk is independent of architecture (works on both the Sony machine and Quamachine) and fully debugged. 7 Related Work Synthesis V.1 kernel differs from production multiprocessor OS kernels such as Mach <ref> [3] </ref>, Topaz [13], and Psyche [11] in being lock-free. All the synchronization problems in a shared-memory multiprocessor are solved using lock-free synchronization methods based on Compare-and-Swap. A small number of lock-free objects such as packed flags, stacks, FIFO queues and linked lists connect all of Synthesis kernel components.
Reference: [4] <author> P.M. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1), </volume> <month> January </month> <year> 1991. </year> <note> To appear. 18 </note>
Reference-contexts: In multiprocessors, mutual exclusion may be achieve through waiting locks and spin-locks. Anderson [1] analyzed the performance and overhead trade-offs of spin-locks for multiprocessor systems, finding considerable potential for system performance degradation due to mutual exclusion. Herlihy <ref> [4] </ref> has shown that in wait-free and non-blocking synchronization, atomic read-modify-write instructions such as compare-and-swap are more powerful than test-and-set, the instruction commonly used in the implementation of spin-locks. <p> Two-word Compare-and-Swap lets us efficiently implement many basic data structures such as stacks, queues, and linked lists because we can atomically update both a pointer and the location being pointed to. Herlihy <ref> [4] </ref> defines an object to be wait-free if it guarantees that each process will complete an operation in a finite number of steps. An object is non-blocking if it guarantees that some process will complete an operation in a finite number of steps. <p> In this paper, we use the term lock-free as a synonymous with 2 non-blocking. We have chosen to use lock-free synchronization instead of wait-free because the cost of wait-free is higher and the probability of starvation in an OS kernel is low. Herlihy introduced a general methodology <ref> [4] </ref> to transform a sequential implementation of any data structure into a wait-free, concurrent one using Compare-and-Swap. His concurrent data structures, however, carry relatively high CPU and memory overhead even when there is no interference. <p> If a deleted node is the allocated and reused for some other purpose, its new pointer values may cause invalid memory references by the other thread still traversing it. Herlihy's solution <ref> [4] </ref> uses reference counts (Figure 3). Visiting a node uses a two-word Compare-and-Swap to load the pointer and increment the reference count. Leaving a node similarly decrements the reference count. A node is not actually freed until the reference count reaches zero.
Reference: [5] <author> S. F. Hummel and E Schonberg. </author> <title> Low-overhead scheduling of nested parallelism. </title> <type> Technical Report RC 16424, T.J. </type> <institution> Watson Research Center, IBM Research Division, </institution> <year> 1990. </year>
Reference-contexts: To the best of our knowledge, this has not been attempted even in experimental multiprocessor OS kernels such as Elmwood [7]. From the lock-free data structure point of view, our work is most close related to that of NYU Ultracomputer by Hummel [6, 14] and IBM RP3 <ref> [5] </ref>. Even though the algorithms are not exactly the same, in particular due to our use of double-word Compare-and-Swap, the objectives are the same applying lock-free synchronization to increase concurrency and decrease overhead. They have described practical and useful solutions for particular concurrent data structures in the context of scheduling.
Reference: [6] <author> Susan Flynn Hummel. </author> <title> SMARTS Shared-memory Multiprocessor Ada Run-Time Supervisor. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, </institution> <address> New York University, </address> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, this has not been attempted even in experimental multiprocessor OS kernels such as Elmwood [7]. From the lock-free data structure point of view, our work is most close related to that of NYU Ultracomputer by Hummel <ref> [6, 14] </ref> and IBM RP3 [5]. Even though the algorithms are not exactly the same, in particular due to our use of double-word Compare-and-Swap, the objectives are the same applying lock-free synchronization to increase concurrency and decrease overhead.
Reference: [7] <author> T.J. LeBlanc, J.M. Mellor-Crummey, N.M. Gafter, L.A. Crowl, </author> <title> and P.C. Dibble. The elm-wood multiprocessor operating system. </title> <journal> Software Practice and Experience, </journal> 19(11) 1039-1055, November 1989. 
Reference-contexts: A small number of lock-free objects such as packed flags, stacks, FIFO queues and linked lists connect all of Synthesis kernel components. To the best of our knowledge, this has not been attempted even in experimental multiprocessor OS kernels such as Elmwood <ref> [7] </ref>. From the lock-free data structure point of view, our work is most close related to that of NYU Ultracomputer by Hummel [6, 14] and IBM RP3 [5].
Reference: [8] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: The version 1 (abbreviated V.1) of Synthesis kernel implemented on a dual-68030 Sony NEWS workstation is based entirely on lock-free synchronization, developed from the optimistic synchronization methods developed for the single-processor version 0 of Synthesis <ref> [8] </ref>. The implementation of Synthesis V.1 shows three things. First, lock-free synchronization is sufficient for all synchronization needs of a multiprocessor OS kernel supporting threads, virtual memory and all the usual I/O. Second, a lock-free multiprocessor OS kernel is practical. Third, such an OS kernel achieves very high performance. <p> Before a criti-cal section, a kernel call disables signals. The signal delivery routine must test whether that particular signal is currently allowed. If not, take the appropriate action to stack up the signal processing at the end of the critical section. (One example is procedure chaining in Synthesis <ref> [8] </ref>.) After each critical section, the system must test and execute any pending signals. More serious than kernel overhead, disabling signals may cause processes to become stuck when expected events do not happen. <p> But to perform two stores with Compare-and-Swap we also have to perform two tests, so we have to read the old value above the top-of-stack into a third private variable to have something to test against. 3.2 FIFO Queues In a previous paper <ref> [8] </ref> we described an array implementation of FIFO queues using lock-free synchronization (called optimistic synchronization in that paper). We summarize here the properties of these queues to make this paper self-contained. FIFO queues support two main operations, Q_put and Q_get. <p> The "Synthesis V.1" column shows the numbers for Synthesis V.1 on the Sony NeWS 1850 machine, a dual 68030 each at 25 Mhz. These numbers were measured on the Quamachine (see Section A.2) and calculated for the NeWS. For comparison, we also list the numbers from V.0 <ref> [8] </ref> under the column "Synthesis V.0". Those numbers are scaled by 16=25 to make up for the different clock rate of the machine (a SUN-3/260) on which they were obtained. <p> The main advantage of counting machine cycles directly is the avoidance of spurious code when doing the measurements in software. Another reason is the relative independence of these numbers with respect to architectural differences. The Quamachine has a MC68030 CPU (converted from 68020 since the last SOSP <ref> [8] </ref>), 2.5 MB no-wait state main memory, 390 MB hard disk, 3 1 2 inch floppy drive. The Quamachine is designed and instrumented to aid systems research.
Reference: [9] <author> H. Massalin and C. Pu. </author> <title> Fine-grain adaptive scheduling using feedback. </title> <journal> Computing Systems, </journal> <volume> 3(1) </volume> <pages> 139-173, </pages> <month> Winter </month> <year> 1990. </year> <booktitle> Special Issue on selected papers from the Workshop on Experiences in Building Distributed Systems, </booktitle> <address> Florida, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: When a CPU quantum expires, the clock interrupt handler (the exiting thread's switch-out routine) stores the thread's context and branches into the next ready thread's switch-in routine. V.0 had only a single run-queue that contained all the TTEs. A fine-grain scheduling mechanism based on software feedback <ref> [9] </ref> changes the CPU quantum of each thread according to its need. For example, if a thread's input queue is full, the software feedback increases its quantum.
Reference: [10] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Although the primary reason for efficiency in I/O processing is kernel code synthesis <ref> [10] </ref>. 14 Quaject Create (microseconds) Write (microseconds) TTY-Cooker 27 2.3 + 2.1 per char VT-100 terminal emulator 532 14.2 + 1.3 per char Text window 71 23.9 + 27.7 per char Table 5: Selected Window System operations 6.1 Terminal and Display A terminal window is a pipeline composed of primarily three
Reference: [11] <author> M.L. Scott, T.J. LeBlanc, B.D. Marsh, T.G. Becker, C. Dubnicki, E.P. Markatos, and N.G. Smithline. </author> <title> Implementation issues for the Psyche multiprocessor operating system. </title> <journal> Computing Systems, </journal> <volume> 3(1) </volume> <pages> 101-138, </pages> <month> Winter </month> <year> 1990. </year>
Reference-contexts: However, there has been no empirical evidence that OS kernels using this kind of lock-free synchronization methods achieve better performance than state-of-art multiprocessor OS kernel implementations using lock-based synchronization (e.g., spin-locks and semaphores), such as Mach [3] and Psyche <ref> [11] </ref>. The version 1 (abbreviated V.1) of Synthesis kernel implemented on a dual-68030 Sony NEWS workstation is based entirely on lock-free synchronization, developed from the optimistic synchronization methods developed for the single-processor version 0 of Synthesis [8]. The implementation of Synthesis V.1 shows three things. <p> Kernel quaspace size can be reduced to 16MBytes without negative impact on system performance. We chose to make the kernel quaspace present in every address space for three reasons: 1. This avoids the switching between kernel and user spaces during kernel calls (Psyche <ref> [11] </ref> had this problem). 2. Kernel quaspace is so small (16 MB expected) and grows so slowly (as a function of number of processors and threads) that there is no need to allocate an entire address space. 3. <p> The ramdisk is independent of architecture (works on both the Sony machine and Quamachine) and fully debugged. 7 Related Work Synthesis V.1 kernel differs from production multiprocessor OS kernels such as Mach [3], Topaz [13], and Psyche <ref> [11] </ref> in being lock-free. All the synchronization problems in a shared-memory multiprocessor are solved using lock-free synchronization methods based on Compare-and-Swap. A small number of lock-free objects such as packed flags, stacks, FIFO queues and linked lists connect all of Synthesis kernel components.
Reference: [12] <author> J.M. Stone. </author> <title> Managing a shared FIFO queue with Compare-and-Swap. </title> <booktitle> In Proceedings of the 1990 Supercomputing Conference. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: They have described practical and useful solutions for particular concurrent data structures in the context of scheduling. Another paper describing concurrent access to queues is by Stone <ref> [12] </ref>, who used Compare-and-Double-Swap involving two double words. In contrast, Synthesis use of lock-free synchronization is much more general since we have applied these techniques to implement an entire OS kernel.
Reference: [13] <author> C.P. Thacker, L.C. Stewart, and E.H. Satterthwaite, Jr. Firefly: </author> <title> A multiprocessor workstation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37(8):909-920, </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: The ramdisk is independent of architecture (works on both the Sony machine and Quamachine) and fully debugged. 7 Related Work Synthesis V.1 kernel differs from production multiprocessor OS kernels such as Mach [3], Topaz <ref> [13] </ref>, and Psyche [11] in being lock-free. All the synchronization problems in a shared-memory multiprocessor are solved using lock-free synchronization methods based on Compare-and-Swap. A small number of lock-free objects such as packed flags, stacks, FIFO queues and linked lists connect all of Synthesis kernel components.
Reference: [14] <author> James M. Wilson. </author> <title> Operating System Data Structures for Shared-Memory MIMD Machines with Fetch-and-Add. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, </institution> <address> New York University, </address> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, this has not been attempted even in experimental multiprocessor OS kernels such as Elmwood [7]. From the lock-free data structure point of view, our work is most close related to that of NYU Ultracomputer by Hummel <ref> [6, 14] </ref> and IBM RP3 [5]. Even though the algorithms are not exactly the same, in particular due to our use of double-word Compare-and-Swap, the objectives are the same applying lock-free synchronization to increase concurrency and decrease overhead.
References-found: 14

