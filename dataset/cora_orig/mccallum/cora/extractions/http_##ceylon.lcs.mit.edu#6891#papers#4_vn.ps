URL: http://ceylon.lcs.mit.edu/6891/papers/4_vn.ps
Refering-URL: http://ceylon.lcs.mit.edu/6891/reading_list.html
Root-URL: 
Email: vas@hpl.hp.com rubin@sousa.enet.dec.com  
Title: Efficient Instruction Scheduling Using Finite State Automata  
Author: Vasanth Bala Norman Rubin 
Affiliation: Hewlett Packard Labs Digital Equipment Corp.  
Date: Nov 1995  
Address: (MICRO-28), Ann Arbor,  
Note: To appear in The 28th Annual Intl. Symp. on Microarchitecture  
Abstract: Modern compilers employ sophisticated instruction scheduling techniques to shorten the number of cycles taken to execute the instruction stream. In addition to correctness, the instruction scheduler must also ensure that hardware resources are not oversubscribed in any cycle. For a contemporary processor implementation with multiple pipelines and complex resource usage restrictions, this is not an easy task. The complexity involved in reasoning about such resource hazards is one of the primary factors that constrain the instruction scheduler from performing many aggressive transformations. For example, the ability to do code motion or instruction replacement in the middle of an already scheduled block would be a very powerful transformation if it could be performed efficiently. We extend a technique for detecting pipeline resource hazards based on finite state automata, to support the efficient implementation of such transformations that are essential for aggressive instruction scheduling beyond basic blocks. Although similar code transformations can be supported by other schemes such as reservation tables, our scheme is superior in terms of space and time. A global instruction scheduler that used these techniques was implemented in the KSR compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> DecChip TM 21064 Microprocessor Hardware Reference Manual EC-N0079-72. Digital Equipment Corp., Maynard, </institution> <address> MA. </address>
Reference-contexts: Both methods derive the automaton from a description of the hardware resource usage vectors for the instruction set for a particular processor implementation. For example, the following are the resource usage vectors we used for the 21064 implementation of the DEC Alpha architecture <ref> [1] </ref>: instrunction pipeline cycle class 0 1 2 3 4 int/nop0 ib0 flt-st ib0+l loads ibx+l imull ib0+m m^15 m+r m^2 imulq ib0+m m^17 m+r m^2 stx C ib1+l l l fdivs ib1+f f^24 f+x f^4 fdivq ib1+f f^52 f+x f+x f^4 Each row is a resource usage vector corresponding to
Reference: [2] <author> J.C. Dehnert, and R.A. Towle. </author> <title> Compiling for the Cydra-5. </title> <journal> In The Journal of Supercomputing, </journal> <volume> 7, </volume> <pages> pp. 181-227, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The instruction is legal to issue only if there are no resource conflicts. This method is used in many production compilers today, though only occasional references can be found in the literature (for example, see <ref> [4, 2, 11] </ref>). The problem with using resource reservation tables is that the size of the bit matrix used to represent the table is #resources fi length of the longest pipeline, and every test for a resource hazard requires an OR operation on bit matrices.
Reference: [3] <author> E.S. Davidson, L.E. Shar, A.T. Thomas, and J.H. Patel. </author> <title> Effective Control for Pipelined Computers. </title> <booktitle> In Spring COMPCON-75 digest of papers. IEEE Computer Society, </booktitle> <month> Feb </month> <year> 1975. </year>
Reference-contexts: In order to support such a feature, the resource reservation table after the issue of each instruction will have to be recorded, which could result in significant space overhead. An alternative method to using resource reservation tables was suggested by Davidson, Shar, Thomas and Patel <ref> [3] </ref>. In their method, the processor pipeline is modeled using a finite state automaton, which can be built automatically from the instruction resource 1 usage vectors for a given processor implementation.
Reference: [4] <author> J.A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction. </title> <booktitle> In IEEE Transaction on Computers, C-30(7), </booktitle> <pages> pp. 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: The instruction is legal to issue only if there are no resource conflicts. This method is used in many production compilers today, though only occasional references can be found in the literature (for example, see <ref> [4, 2, 11] </ref>). The problem with using resource reservation tables is that the size of the bit matrix used to represent the table is #resources fi length of the longest pipeline, and every test for a resource hazard requires an OR operation on bit matrices.
Reference: [5] <author> J. Hartmanis and R. Stearns. </author> <title> Algebraic Structure Theory of Sequential Machines. See Chapter 2 "Partitions and the Substitution Property". </title> <publisher> Prentice-Hall, </publisher> <year> 1966. </year>
Reference-contexts: For instance, the size of the minimal Alpha 21064 automaton is 13,524 states. Instead of building one large automaton, a factoring scheme can be used to create multiple smaller automata, the sum total of whose states is less than the number of states in the original (see <ref> [5] </ref> for a detailed treatment of the theory behind automata factoring). The factoring scheme is based on the observation that processor implementations typically divide the instruction set into different categories, and each category is executed by a different functional unit on the chip.
Reference: [6] <author> J.E. Hopcroft, and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Therefore, a state may need an additional bit indicating if the next instruction will be placed at a multi-issue boundary. The Muller technique may not produce a minimal 2 automaton. A finite state minimization algorithm <ref> [6] </ref> has to be applied as a postpass step to produce the minimal automaton. Many modern processor implementations often have very large automata to begin with, and considerable memory may be required to build a non-minimal automaton. <p> The proof can be found in most standard automata theory texts <ref> [6] </ref> and is not given here. Consider the forward automaton F shown in figure 1. Note that it is deterministic by construction: each state has at most one output transition with a given label.
Reference: [7] <author> R. Lo, S. Chan, F. Chow, and S-M. Liu. </author> <title> Improving Resource Utilization of the MIPS R8000 via Post-Scheduling Global Instruction Distribution. </title> <booktitle> In The 27th Annual Symposium on Microarchitec-ture, </booktitle> <address> San Jose, </address> <month> Dec </month> <year> 1994. </year>
Reference-contexts: What could potentially 10 have been a software hack in the instruction sched--uler was handled elegantly, without touching any of the compiler code. The dual automata are generally useful in most scenarios where scheduled code needs to be manipulated, such as in post-scheduling instruction distribution <ref> [7] </ref>. 7 Conclusions We have presented algorithms for building a forward and reverse automaton from a table of instruction resource usage vectors for a processor implementation.
Reference: [8] <author> P.G. Lowney, S.M. Freudenberger, T.J. Karzes, W.D. Lichtenstein, R.P. Nix, J.S. O'Donnel, and J.C. Ruttenberg. </author> <title> The Multiflow Trace Scheduling Compiler. </title> <journal> In The Journal of Supercomputing, </journal> <volume> 7, </volume> <pages> pp. 51-142, </pages> <year> 1993. </year>
Reference-contexts: This copy is refered to as compensation code. Naive insertion of compensation code penalizes the off-trace path in order to speed up the current trace, because it produces sparsely scheduled cycles at the trace join point <ref> [8] </ref>. The ideal solution is to somehow absorb the compensation code into the side trace, without lenghening the side trace. One way to do this is to schedule the side trace (if it isn't already) and then replace any NOP instructions in its schedule with the compensation instructions.
Reference: [9] <author> T. Muller. </author> <title> Employing Finite Automata for Resource Scheduling. </title> <booktitle> In The 26th Annual International Symposium on Microarchitecture, </booktitle> <address> Austin, </address> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Muller used the table of states and transitions comprising such a finite state automaton in the compiler, effectively reducing the problem of structural hazard detection to fast table lookups <ref> [9] </ref>. Muller reports an 18-fold speedup compared to the resource reservation table method when the structural hazard detection in the instruction scheduler was done using the automaton. <p> This feature allows more efficient placement of compensation code that gets generated when an instruction is speculatively scheduled above a branch upon which it is control dependent. 2 Building the Automaton Our method for constructing the finite state automaton is based on the techniques described in earlier work by Muller <ref> [9] </ref>, and by Proebsting and Fraser [10]. Both methods derive the automaton from a description of the hardware resource usage vectors for the instruction set for a particular processor implementation. <p> In such cases we can apply an automaton factoring technique, discussed in Section 2.4, to isolate the modeling of such long latency instructions in a separate automaton. 2.1 States and Transitions In the Muller automaton <ref> [9] </ref>, each state corresponds to a resource reservation table. The reservation table explicitly models each resource. It is represented by a bit matrix of size number of resources fi length of the longest pipe.
Reference: [10] <author> T.A. Proebsting, and C.W. Fraser. </author> <title> Detecting Pipeline Hazards Quickly. </title> <booktitle> In The 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Muller reports an 18-fold speedup compared to the resource reservation table method when the structural hazard detection in the instruction scheduler was done using the automaton. Proebsting and Fraser <ref> [10] </ref> improved on Muller's technique for constructing the finite state machine by directly computing a minimal state machine from the instruction resource usage vectors. These methods have the advantage that the finite state automaton in built only once for a given processor implementation. <p> of compensation code that gets generated when an instruction is speculatively scheduled above a branch upon which it is control dependent. 2 Building the Automaton Our method for constructing the finite state automaton is based on the techniques described in earlier work by Muller [9], and by Proebsting and Fraser <ref> [10] </ref>. Both methods derive the automaton from a description of the hardware resource usage vectors for the instruction set for a particular processor implementation. <p> For instance, the theoretical maximum number of states possible for the MIPS R3000 processor is 2 22fi37 states, whereas the minimal automaton has only 6; 175 states. The Proebsting and Fraser automaton <ref> [10] </ref> overcomes this problem by representing each state S as a collision matrix. The collision matrix is a bit matrix of size number of instruction classes fi length of the longest pipeline.
Reference: [11] <author> B.R. Rau, </author> <title> M.S. Schlansker, and P.P. Tirumalai. Code Generation Schemas for Modulo Scheduled Loops. </title> <booktitle> In The 25th Annual International Symposium on Microarchitecture, </booktitle> <month> Dec </month> <year> 1992. </year>
Reference-contexts: The instruction is legal to issue only if there are no resource conflicts. This method is used in many production compilers today, though only occasional references can be found in the literature (for example, see <ref> [4, 2, 11] </ref>). The problem with using resource reservation tables is that the size of the bit matrix used to represent the table is #resources fi length of the longest pipeline, and every test for a resource hazard requires an OR operation on bit matrices.
Reference: [12] <author> P-C Wu, F-J Wang, and K-R Young. </author> <title> Scanning Regular Languages by Dual Finite Automata. </title> <journal> In ACM Sigplan Notices, </journal> <volume> 27(4), </volume> <pages> pp. 12-16, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: These can be implemented efficiently (constant time feasability test, linear time updates), and incur substantially less space overhead than traditional methods. Dual forward and reverse automata have been used for scanning regular languages <ref> [12] </ref>, but we are not aware of other work that discusses their use in global instruction scheduling.
References-found: 12

