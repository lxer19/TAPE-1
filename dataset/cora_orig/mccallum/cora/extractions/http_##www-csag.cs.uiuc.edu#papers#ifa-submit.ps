URL: http://www-csag.cs.uiuc.edu/papers/ifa-submit.ps
Refering-URL: http://www-csag.cs.uiuc.edu/projects/concert/implementation.html
Root-URL: http://www.cs.uiuc.edu
Email: fjplevyak,achieng@cs.uiuc.edu  
Title: Iterative Flow Analysis  
Author: John Plevyak Andrew A. Chien 
Address: 1304 W. Springfield Avenue Urbana, IL 61801  
Affiliation: Department of Computer Science  
Abstract: Control and data flow information is vital for the optimization of high level programming languages. Language features such as object-orientation and first class functions and selectors link data flow and control flow. For example, in an object-oriented program an object's run time type is used to determine the function (method) executed at an invocation point via dynamic dispatch. We present an iterative analysis which derives control and data flow information simultaneously. This analysis adapts to the structure of the program, efficiently deriving flow information at a cost proportional to the precision of the information obtained. The analysis results are directly applicable to such optimizations as static binding, inlining and unboxing. This analysis has been implemented in the Illinois Concert compiler, and we report quantitative results for a number of object-oriented programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Agesen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of Self: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP '93, </booktitle> <year> 1993. </year> <month> 19 </month>
Reference-contexts: Contours represent the calling environments of a function; for example 0CFA uses one contour per function while 1CFA uses one for each call site [32]. Other flow analyses [20, 22] have used a fixed contour representation or adapted the representation with respect to the values of function arguments <ref> [1] </ref>. However, shallow fixed representations can require excessive amounts of memory [21] and imperative update of memory locations introduce cycles into the flow graph which can invalidate adaptive decisions after they have been made. <p> The absolute numbers are reported in Appendix A. 18 Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in [23, 22]. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen <ref> [1, 2] </ref> extended the basic one level approach to handle the features of SELF [37]. However, this approach uses a single pass, limiting it to eager splitting.
Reference: [2] <author> Ole Agesen and Urs Holzle. </author> <title> Type feedback vs. concrete type analysis: A comparison of optimization techniques for object-oriented languages. </title> <type> Technical Report TRCS 95-04, </type> <institution> Computer Science Department, University of California, Santa Barbara, </institution> <year> 1995. </year>
Reference-contexts: The absolute numbers are reported in Appendix A. 18 Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in [23, 22]. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen <ref> [1, 2] </ref> extended the basic one level approach to handle the features of SELF [37]. However, this approach uses a single pass, limiting it to eager splitting.
Reference: [3] <author> Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Twenty First Symposium on Principles of Programming Languages, </booktitle> <pages> pages 151-162, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: However, this approach uses a single pass, limiting it to eager splitting. The soft typing system of Cartwright and Fagan [5] extends a Hindley-Milner style type inference to support union and recursive types as well as insert type checks. To this Aiken, Wimmers, and Lakshman <ref> [3] </ref> add conditional and intersection types enabling the incorporation of flow sensitive information. However, these systems are for languages which are purely functional where the question of types involving assignment does not arise and extensions to imperative languages are not fully developed. <p> This information has enabled us to achieve C-like performance for object-oriented programs on numerical codes [29] and to specialize the calling conventions for distributed programs [28]. We are currently expanding the framework for more interprocedural analyses, and looking at ways to enable summarization <ref> [3] </ref> and to characterize the precision of the algorithm. 10 Acknowledgements We would like to thank Vijay Karamcheti, Xingbin Zhang, Julian Dolby and Mahesh Subramaniam for their work on the Concert System and Tony Ng, Jesus Izaguirre and Doug Beeferman for writing applications and for working with early versions of the
Reference: [4] <author> R. A. Ballance, A. B. Maccabe, and K. J. Ottenstein. </author> <title> The program dependence web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 257-271. </pages> <booktitle> ACM SIGPLAN, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: It is similar to <ref> [4] </ref> and is computed through a simple extension of the SSA conversion algorithm [13, 34]. 4 4 Analysis Iterative Flow Analysis (IFA) consists of two phases: analysis and incremental precision extension (discussed in Section 5). The analysis phase constructs the flow graph, while continuously updating the node values.
Reference: [5] <author> Robert Cartwright and Mike Fagan. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <address> Ontario, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Agesen [1, 2] extended the basic one level approach to handle the features of SELF [37]. However, this approach uses a single pass, limiting it to eager splitting. The soft typing system of Cartwright and Fagan <ref> [5] </ref> extends a Hindley-Milner style type inference to support union and recursive types as well as insert type checks. To this Aiken, Wimmers, and Lakshman [3] add conditional and intersection types enabling the incorporation of flow sensitive information.
Reference: [6] <author> C. Chambers and D. Ungar. </author> <title> Customization: Optimizing compiler technology for Self, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-60, </pages> <year> 1989. </year>
Reference-contexts: The unoptimized code represents the lower bound on efficiency, indicating the number of methods and messages required by a naive implementation. The optimized 0CFA version uses customization <ref> [6] </ref> to create specialized versions of methods for each receiver (target object) class. The optimized IFA version further clones and specializes methods based on the classes of all arguments [26, 14, 15]. 7.2.1 Dynamic Dispatch Sites Removed dispatch sites in the program code. The unoptimized code provides the baseline. <p> Recently, Stefanescu and Zhou [35] as well as Jagannathan and Weeks [20] have provided simplified frameworks for flow analysis. Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler <ref> [6, 7, 8] </ref>. However, iterative type analysis does not type an entire program, only small regions. Later work by Holzle [19] on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs.
Reference: [7] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-60, </pages> <year> 1990. </year>
Reference-contexts: Recently, Stefanescu and Zhou [35] as well as Jagannathan and Weeks [20] have provided simplified frameworks for flow analysis. Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler <ref> [6, 7, 8] </ref>. However, iterative type analysis does not type an entire program, only small regions. Later work by Holzle [19] on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs.
Reference: [8] <author> C. Chambers and D. Ungar. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In OOPSLA '91 Conference Proceedings, </booktitle> <pages> pages 1-15, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Recently, Stefanescu and Zhou [35] as well as Jagannathan and Weeks [20] have provided simplified frameworks for flow analysis. Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler <ref> [6, 7, 8] </ref>. However, iterative type analysis does not type an entire program, only small regions. Later work by Holzle [19] on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs.
Reference: [9] <author> Craig Chambers. </author> <title> The Design and Implementation of the Self Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining <ref> [9, 19] </ref>, type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. <p> 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization <ref> [9] </ref>, specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values.
Reference: [10] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concurrent aggregates language report 2.0. </title> <note> Available via anonymous ftp from cs.uiuc.edu in /pub/csag or from http://www-csag.cs.uiuc.edu/, September 1993. </note>
Reference-contexts: Finally, the contents of arrays can be analyzed homogeneously as a single instance variable, using a special Label to represent array contents. 7 Implementation and Empirical Results We have implemented the analysis algorithm and tested it on more than 40,000 lines of Concurrent Aggregates (CA) <ref> [10] </ref>. CA is a single dispatch and single inheritance object-oriented language similar to the simple language described in Section 3, but extended for concurrency and including first class continuations and messages. The implementation is fully integrated into the compiler and complete; no language features were excluded. <p> We compared these algorithms based on precisions, time and space complexity. 3 The compiler, language manual <ref> [10] </ref> and codes are available via at http://www-csag.cs.uiuc.edu. 14 Algorithm Progs Progs Type Runtime Typed Failed Checks (secs) IFA 9 0 0 199 0CFA 0 9 718 34 7.1.1 Precision We use two criteria for precision: typing (assignment of types such that run time type checks are not required) and elimination
Reference: [11] <author> K. Cooper, K. Kennedy, and L. Torczon. </author> <title> The impact of interprocedural analysis and optimization in the R n environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 491-523, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations <ref> [11] </ref>. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values. As a result, control and data flow must be analyzed simultaneously if precise information is to be obtained.
Reference: [12] <author> Patrick Cousot and Radia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Fourth Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: Section 7 reports our empirical results. Finally, we cover related work in Section 8, and conclude in Section 9. 2 Background Context sensitive flow analysis of high level programming languages is a control and data flow analysis which combines elements of abstract interpretation <ref> [12] </ref> and data flow analysis [16]. Efficient implementations build the flow graph by abstract interpretation and update the values by propagation along the edges of the flow graph.
Reference: [13] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> An efficient method of computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: an integer or of the a instance variable of an object of class A can be defined as: (define double ((a A)) (+ (get-a a) (get-a a))) (define double ((a Integer)) (+ a a)) Before analysis the simple language is converted to a variant of Static Single Assignment (SSA) form <ref> [13, 34] </ref>. SSA form inserts -Nodes, essentially assignments with multiple right hand sides where control flow merges, for example after a conditional, and renames variables so that each variable appears on the left hand side of only one assignment. <p> It is similar to [4] and is computed through a simple extension of the SSA conversion algorithm <ref> [13, 34] </ref>. 4 4 Analysis Iterative Flow Analysis (IFA) consists of two phases: analysis and incremental precision extension (discussed in Section 5). The analysis phase constructs the flow graph, while continuously updating the node values.
Reference: [14] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Identifying profitable specialization in object-oriented languages. </title> <type> Technical Report TR 94-02-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, Washington, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The optimized 0CFA version uses customization [6] to create specialized versions of methods for each receiver (target object) class. The optimized IFA version further clones and specializes methods based on the classes of all arguments <ref> [26, 14, 15] </ref>. 7.2.1 Dynamic Dispatch Sites Removed dispatch sites in the program code. The unoptimized code provides the baseline.
Reference: [15] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programmin g Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization [9], specialization <ref> [15] </ref> and cloning [18, 26] and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values. <p> The optimized 0CFA version uses customization [6] to create specialized versions of methods for each receiver (target object) class. The optimized IFA version further clones and specializes methods based on the classes of all arguments <ref> [26, 14, 15] </ref>. 7.2.1 Dynamic Dispatch Sites Removed dispatch sites in the program code. The unoptimized code provides the baseline.
Reference: [16] <author> Kildal G. </author> <title> A unified approach to global program optimization. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <year> 1973. </year>
Reference-contexts: Section 7 reports our empirical results. Finally, we cover related work in Section 8, and conclude in Section 9. 2 Background Context sensitive flow analysis of high level programming languages is a control and data flow analysis which combines elements of abstract interpretation [12] and data flow analysis <ref> [16] </ref>. Efficient implementations build the flow graph by abstract interpretation and update the values by propagation along the edges of the flow graph. Such implementations have been called constraint-based [23] since the flow graph resembles a constraint network, where the edges are constraints and the nodes are variables.
Reference: [17] <author> J. Graver and R. Johnson. </author> <title> A type system for smalltalk. </title> <booktitle> In Proceedings of POPL, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: Later work by Holzle [19] on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs. Type inference in object-oriented languages in particular has been studied for many years <ref> [36, 17] </ref>. 4 This normalization is somewhat misleading since the absolute number of invocations within the optimized IFA code is less than that within optimized 0CFA code. As a result, the relative frequency of dynamic dispatches within optimized code exaggerates the absolute number in IFA relative to OPS.
Reference: [18] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning <ref> [18, 26] </ref> and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values.
Reference: [19] <author> Urs Holzle and David Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <month> June </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining <ref> [9, 19] </ref>, type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. <p> Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler [6, 7, 8]. However, iterative type analysis does not type an entire program, only small regions. Later work by Holzle <ref> [19] </ref> on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs.
Reference: [20] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order lan-guages. </title> <booktitle> In Twenty-second Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-407. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1995. </year>
Reference-contexts: The key to the precision of context sensitive flow analysis is the contour [33] representation. Contours represent the calling environments of a function; for example 0CFA uses one contour per function while 1CFA uses one for each call site [32]. Other flow analyses <ref> [20, 22] </ref> have used a fixed contour representation or adapted the representation with respect to the values of function arguments [1]. <p> The context sensitivity of flow analysis follows from the contour representation <ref> [33, 20] </ref>. In the theory of flow analysis, the language to be analyzed is first given an exact semantics which is essentially an interpreter. The contours for such a semantics represent the call frames, include call path and determine variable bindings. <p> The analysis phase constructs the flow graph, while continuously updating the node values. The simple language coupled with SSU form, which induces an explicit local data flow graph, greatly simplifies the abstract semantics over other analyses <ref> [20, 35] </ref> allowing us to concentrate on the iteration algorithm. In particular, the simple language binds all variables in the function or self argument's contours, preventing the capture of variables from surrounding scopes. <p> Since any given variable can only hold one value at one time, separate analysis is safe so long as each element of the cross product of values is represented by some contour (the cross product rule). This is achieved in the alternative contour representation of <ref> [20] </ref> by single-value based analysis of curried functions. 4.3 Imprecision and Polymorphism (define power (x y) (if (&gt; y 0) (* x (power x (- y 1))) (one x))) (power 1 2) (power 1.0 2)) (define tuple (l r) (define left ((self tuple)) l) self) (let () (left (tuple 1 2)) <p> In particular, it does not allow variables captured from surrounding lexical scopes (closures), and has neither first class continuations nor arrays. Closures can be handled by extending the notion of contours to include a map from the Labels of those variables to Contours <ref> [20] </ref> and by using data splitting to extend the precision of captured variables. First class continuations are handled by building a second flow graph with nodes for each primary flow graph node containing a continuation and edges which are the inverse of those in the primary graph. <p> In particular, the ideas of a call context cache to approximate interprocedural data flow and the reflow semantics to enable incremental improvements in the solution foreshadow this work. Recently, Stefanescu and Zhou [35] as well as Jagannathan and Weeks <ref> [20] </ref> have provided simplified frameworks for flow analysis. Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler [6, 7, 8]. However, iterative type analysis does not type an entire program, only small regions.
Reference: [21] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <type> Technical Report 95-3, </type> <institution> NEC Research Institute, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Other flow analyses [20, 22] have used a fixed contour representation or adapted the representation with respect to the values of function arguments [1]. However, shallow fixed representations can require excessive amounts of memory <ref> [21] </ref> and imperative update of memory locations introduce cycles into the flow graph which can invalidate adaptive decisions after they have been made.
Reference: [22] <author> N. Oxhtj, J. Palsberg, and M. Schwartzbach. </author> <title> Making type inference practical. </title> <booktitle> In Proceedings of OOPSLA '92, </booktitle> <year> 1992. </year>
Reference-contexts: The key to the precision of context sensitive flow analysis is the contour [33] representation. Contours represent the calling environments of a function; for example 0CFA uses one contour per function while 1CFA uses one for each call site [32]. Other flow analyses <ref> [20, 22] </ref> have used a fixed contour representation or adapted the representation with respect to the values of function arguments [1]. <p> Since abstract interpretation of the call sites (construction of the flow graph) uses the data flow values (the current solution) to determine the functions called <ref> [22] </ref>, the data flow values are updated concurrently with flow graph construction. The meet function for the data flow values is union and the transfer functions are derived by abstract interpretation. <p> All programs were compiled with the standard CA prologue (240 lines of code). 3 7.1 Analysis We implemented three different analysis algorithms: 0CFA with one flow graph node per program variable, OPS <ref> [22] </ref> with contours distinguished by their immediate caller (i.e. one level of caller-based splitting for functions and objects), and Iterative Flow Analysis (IFA). <p> As a result, the relative frequency of dynamic dispatches within optimized code exaggerates the absolute number in IFA relative to OPS. The absolute numbers are reported in Appendix A. 18 Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in <ref> [23, 22] </ref>. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen [1, 2] extended the basic one level approach to handle the features of SELF [37]. However, this approach uses a single pass, limiting it to eager splitting.
Reference: [23] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of OOPSLA '91, </booktitle> <pages> pages 146-61, </pages> <year> 1991. </year>
Reference-contexts: Efficient implementations build the flow graph by abstract interpretation and update the values by propagation along the edges of the flow graph. Such implementations have been called constraint-based <ref> [23] </ref> since the flow graph resembles a constraint network, where the edges are constraints and the nodes are variables. <p> As a result, the relative frequency of dynamic dispatches within optimized code exaggerates the absolute number in IFA relative to OPS. The absolute numbers are reported in Appendix A. 18 Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in <ref> [23, 22] </ref>. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen [1, 2] extended the basic one level approach to handle the features of SELF [37]. However, this approach uses a single pass, limiting it to eager splitting.
Reference: [24] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 175-180, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis <ref> [24] </ref>, customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values.
Reference: [25] <author> John Plevyak. </author> <title> Optimization of Object-Oriented and Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Urbana, Illinois. </institution> <note> In Preparation. </note>
Reference-contexts: the transfer function for the flow node corresponding to variable a would constrain the type of a to those classes supported by both functions. (if ... (... (+ a a))) (if ... (... (+ a 2 a 2 ))) The resulting program representation is called Static Single Use (SSU) form <ref> [25] </ref>. It is similar to [4] and is computed through a simple extension of the SSA conversion algorithm [13, 34]. 4 4 Analysis Iterative Flow Analysis (IFA) consists of two phases: analysis and incremental precision extension (discussed in Section 5). <p> The values in the secondary graph are those to which the continuations are applied. Appropriate transfer functions pass values between the two graphs <ref> [25] </ref> when the continuation is used.
Reference: [26] <author> John Plevyak and Andrew Chien. </author> <title> Efficient cloning to eliminate dynamic dispatch in object-oriented languages. </title> <note> Submitted for Publication, </note> <year> 1995. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning <ref> [18, 26] </ref> and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values. <p> Moreover, this additional information can be used directly for such optimizations as static binding, inlining, unboxing and data representation optimizations. We demonstrate this by showing that through IFA and cloning <ref> [26] </ref> approximately 99% of the methods in our test cases can be statically bound. This paper is organized as follows. Section 2 describes basic flow analysis and our notation. Section 3 describes the language and the internal representation to which it is converted for analysis. <p> The optimized 0CFA version uses customization [6] to create specialized versions of methods for each receiver (target object) class. The optimized IFA version further clones and specializes methods based on the classes of all arguments <ref> [26, 14, 15] </ref>. 7.2.1 Dynamic Dispatch Sites Removed dispatch sites in the program code. The unoptimized code provides the baseline. <p> Our empirical demonstrate that the algorithm produces information at a cost proportional to the amount obtained and that the information is valuable for optimizing compilers. Our compiler currently uses flow information with cloning <ref> [26] </ref> to eliminate dynamic dispatch, inline functions and methods, unbox variables, as well as for interprocedural constant propagation and locality approximation. This information has enabled us to achieve C-like performance for object-oriented programs on numerical codes [29] and to specialize the calling conventions for distributed programs [28].
Reference: [27] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference of object-oriented programs. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <year> 1994. </year>
Reference-contexts: Moreover, An early version of some of this material appeared in the Proceedings of the 1994 Conference on Object-Oriented Programming Systems, Languages and Applications <ref> [27] </ref>. 1 contours representing objects or closures can also benefit from representation adaption based on the values of their variables [27]. <p> Moreover, An early version of some of this material appeared in the Proceedings of the 1994 Conference on Object-Oriented Programming Systems, Languages and Applications <ref> [27] </ref>. 1 contours representing objects or closures can also benefit from representation adaption based on the values of their variables [27]. We present an iterative combined control and data flow analysis (IFA) which adapts the contour representation for both functions and objects to the program to derive information at a cost proportional to the amount of information obtained.
Reference: [28] <author> John Plevyak, Vijay Karamcheti, Xingbin Zhang, and Andrew Chien. </author> <title> A hybrid execution model for fine-grained languages on distributed memory multicomputers. </title> <note> Submitted for Publication, </note> <year> 1995. </year>
Reference-contexts: This information has enabled us to achieve C-like performance for object-oriented programs on numerical codes [29] and to specialize the calling conventions for distributed programs <ref> [28] </ref>.
Reference: [29] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency in concurrent object-oriented programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 311-321, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: SSA conversion prevents this problem by creating new variables for each use of a on the right side of Figure 1. Similarly, instance variables are converted to SSA as aliasing information permits <ref> [29] </ref>, or moved to temporaries before use to prevent interference. (set! a (new A)) (set! a 1) (set! a 1 (new A)) (set! a 2 1) However, SSA conversion alone is not sufficient since it handles conflicts only for variables which are assigned. <p> Our compiler currently uses flow information with cloning [26] to eliminate dynamic dispatch, inline functions and methods, unbox variables, as well as for interprocedural constant propagation and locality approximation. This information has enabled us to achieve C-like performance for object-oriented programs on numerical codes <ref> [29] </ref> and to specialize the calling conventions for distributed programs [28].
Reference: [30] <author> Bernhard Rytz and Marc Gengler. </author> <title> A polyvariant binding time analysis. </title> <type> Technical Report YALEU/DCS/RR-909, </type> <institution> Yale University, Department of Computer Science, </institution> <year> 1992. </year> <booktitle> Proceedings of the 1992 ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation. </booktitle>
Reference-contexts: However, these systems are for languages which are purely functional where the question of types involving assignment does not arise and extensions to imperative languages are not fully developed. Lastly, our algorithm shares some features of the closure analysis and binding time analysis phases used in self-applicative partial evaluators <ref> [30] </ref>, again for purely functional languages. 9 Conclusion We have developed and implemented an algorithm for context sensitive flow analysis of high level programming langugages. This algorithm uses a novel contour representation which is iteratively extended, enabling efficient analysis of many common programming structures.
Reference: [31] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University Department of Computer Science, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1991. </year> <note> also CMU-CS-91-145. </note>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation <ref> [31] </ref>, static binding, inlining and speculative inlining [9, 19], type recovery [33], safety analysis [24], customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. <p> Intuitively, the level of polymorphism is the depth of the polymorphic function call path or polymorphic reference 6 path (see Figures 5 and 6). Flow analyses typically produces precise results for up to a fixed level of polymorphism; for instance, 0CFA handles no polymorphism while 1CFA <ref> [31] </ref> handles one level. Since real programs use varying levels of polymorphism in different places, efficient analyses adapt locally to those levels.
Reference: [32] <author> Olin Shivers. </author> <title> The semantics of scheme control-flow analysis. </title> <booktitle> In Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 190-198, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The key to the precision of context sensitive flow analysis is the contour [33] representation. Contours represent the calling environments of a function; for example 0CFA uses one contour per function while 1CFA uses one for each call site <ref> [32] </ref>. Other flow analyses [20, 22] have used a fixed contour representation or adapted the representation with respect to the values of function arguments [1].
Reference: [33] <author> Olin Shivers. </author> <title> Topics in Advanced Language Implementation, chapter Data-Flow Analysis and Type Recovery in Scheme, </title> <address> pages 47-88. </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Control and data flow information is vital to optimizing compilers of high level languages. It is useful for constant, copy and lambda propagation [31], static binding, inlining and speculative inlining [9, 19], type recovery <ref> [33] </ref>, safety analysis [24], customization [9], specialization [15] and cloning [18, 26] and other interprocedural optimizations [11]. In high level languages, data values can determine the code which is executed through first class functions and selectors as well as dynamic dispatch, and the code determines the data values. <p> As a result, control and data flow must be analyzed simultaneously if precise information is to be obtained. The key to the precision of context sensitive flow analysis is the contour <ref> [33] </ref> representation. Contours represent the calling environments of a function; for example 0CFA uses one contour per function while 1CFA uses one for each call site [32]. <p> The context sensitivity of flow analysis follows from the contour representation <ref> [33, 20] </ref>. In the theory of flow analysis, the language to be analyzed is first given an exact semantics which is essentially an interpreter. The contours for such a semantics represent the call frames, include call path and determine variable bindings. <p> For IFA with cloning, in all but one case less than 3 percent of the remaining invocations require dynamic dispatch. 4 8 Related Work The use of non-standard abstract semantic interpretation for flow analysis in Scheme by Olin Shivers <ref> [33] </ref> provides a good basis for this and other work on practical type inference. In particular, the ideas of a call context cache to approximate interprocedural data flow and the reflow semantics to enable incremental improvements in the solution foreshadow this work.
Reference: [34] <author> Vugranam C. Sreedhar and Guang R. Gao. </author> <title> A linear time algorithm for placing -nodes. </title> <booktitle> In Twenty-second Symposium on Principles of Programming Languages, </booktitle> <pages> pages 62-73. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1995. </year>
Reference-contexts: an integer or of the a instance variable of an object of class A can be defined as: (define double ((a A)) (+ (get-a a) (get-a a))) (define double ((a Integer)) (+ a a)) Before analysis the simple language is converted to a variant of Static Single Assignment (SSA) form <ref> [13, 34] </ref>. SSA form inserts -Nodes, essentially assignments with multiple right hand sides where control flow merges, for example after a conditional, and renames variables so that each variable appears on the left hand side of only one assignment. <p> It is similar to [4] and is computed through a simple extension of the SSA conversion algorithm <ref> [13, 34] </ref>. 4 4 Analysis Iterative Flow Analysis (IFA) consists of two phases: analysis and incremental precision extension (discussed in Section 5). The analysis phase constructs the flow graph, while continuously updating the node values.
Reference: [35] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An equational framework for the flow analysis of higher-order functional programs. </title> <booktitle> In Proceedings of ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 318-327, </pages> <year> 1994. </year>
Reference-contexts: The analysis phase constructs the flow graph, while continuously updating the node values. The simple language coupled with SSU form, which induces an explicit local data flow graph, greatly simplifies the abstract semantics over other analyses <ref> [20, 35] </ref> allowing us to concentrate on the iteration algorithm. In particular, the simple language binds all variables in the function or self argument's contours, preventing the capture of variables from surrounding scopes. <p> In particular, the ideas of a call context cache to approximate interprocedural data flow and the reflow semantics to enable incremental improvements in the solution foreshadow this work. Recently, Stefanescu and Zhou <ref> [35] </ref> as well as Jagannathan and Weeks [20] have provided simplified frameworks for flow analysis. Iterative type analysis and message splitting using run time testing are conceptually similar techniques developed in the SELF compiler [6, 7, 8]. However, iterative type analysis does not type an entire program, only small regions.
Reference: [36] <author> Norihisa Suzuki. </author> <title> Inferring types in Smalltalk. </title> <booktitle> In Eighth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Later work by Holzle [19] on the SELF-93 compiler uses the results of polymorphic inline caches to determine likely run time types, inserting type tests to ensure that the expected actually occurs. Type inference in object-oriented languages in particular has been studied for many years <ref> [36, 17] </ref>. 4 This normalization is somewhat misleading since the absolute number of invocations within the optimized IFA code is less than that within optimized 0CFA code. As a result, the relative frequency of dynamic dispatches within optimized code exaggerates the absolute number in IFA relative to OPS.
Reference: [37] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of OOPSLA '87, </booktitle> <pages> pages 227-41. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen [1, 2] extended the basic one level approach to handle the features of SELF <ref> [37] </ref>. However, this approach uses a single pass, limiting it to eager splitting. The soft typing system of Cartwright and Fagan [5] extends a Hindley-Milner style type inference to support union and recursive types as well as insert type checks.
Reference: [38] <author> Tim A. Wagner, Vance Maverick, Susan L. Graham, and Michael A. Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <address> Orlando, Florida USA, </address> <month> June </month> <year> 1994. </year> <month> 21 </month>
Reference-contexts: We inline statically bound methods using heuristics based on static 17 frequency estimation <ref> [38] </ref>, the size of both the caller and callee method, and the inline depth. In For 0CFA, optimizations eliminate all but an average of about 30 percent, while for IFA the result is closer to 20 percent.
References-found: 38

