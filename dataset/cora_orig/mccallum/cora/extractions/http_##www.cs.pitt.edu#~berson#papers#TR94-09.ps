URL: http://www.cs.pitt.edu/~berson/papers/TR94-09.ps
Refering-URL: http://www.cs.pitt.edu/~berson/papers.html
Root-URL: 
Email: (berson@cs.pitt.edu)  
Phone: Fax: (412) 624-5249  
Title: Resource Spackling: A Framework for Integrating Register Allocation in Local and Global Schedulers yz  
Author: David A. Berson Rajiv Gupta Mary Lou Soffa 
Date: February 1994  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: Technical Report 94-09 y Partially supported by National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR 91090809 to the University of Pittsburgh z A shorter version of this technical report was presented at the IFIP WG 10.3 Working Conference on Parallel Architectures and Compliation Techniques, Montreal, Canada, August, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [AiN88] <author> A. Aiken and A. Nicolau, </author> <title> A Development Environment for Horizontal Microcode, </title> <journal> IEEE Trans. on Software Engineering 14 , 5(May 1988) pp. </journal> <pages> 584-594. </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available. The framework can be used in conjunction with commonly used methods for performing the code motions, such as Trace Scheduling [Fis81], Percolation Scheduling <ref> [AiN88] </ref>, and Region Scheduling [GuS90]. The Resource Spackling framework computes resource requirements for a program in two steps. First, a unified representation of functional unit and register uses is constructed. This representation identifies all resource uses that can temporally share the same instance of a resource. <p> In these situations the moved instructions make additional resources available which can be used by subsequent moves, resulting in a reduction in execution time. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [BeR91] <author> D. Bernstein and M. Rodeh, </author> <title> Global Instruction Scheduling for Superscalar Machines, </title> <booktitle> Proc. Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June 26-28, </month> <year> 1991, </year> <pages> pp. 241-255. </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93].
Reference: [BGS92] <author> D. A. Berson, R. Gupta and M. L. Soffa, </author> <title> URSA: A Unified ReSource Allocator for Registers and Functional Units in VLIW Architectures, </title> <type> Technical Report 92-21, </type> <institution> University of Pittsburgh, Computer Science Department, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: However, when R is a spanning resource, computing a Reuse R DAG that represents maximum resource requirements has been shown to be NP-Complete and heuristics that require O (N 3 ) time are used <ref> [BGS92] </ref>. These heuristics achieve a good approximation, but may result in underestimating the resource requirements. Resource requirements for resource R are measured from the partial order represented by the Reuse R DAG by finding sets of instructions that can reuse the same resource instance, called allocation chains.
Reference: [BGS93] <author> D. A. Berson, R. Gupta and M. L. Soffa, </author> <title> URSA: A Unified ReSource Allocator for Registers and Functional Units in VLIW Architectures, </title> <booktitle> Proc. IFIP WG 10.3 Working Conference on Architectures and Compliation Techniques for Fine and Medium Grain Parallelism, </booktitle> <address> Orlando, Florida, </address> <month> Jan. </month> <year> 1993, </year> <pages> pp. 243-254. </pages>
Reference-contexts: Preliminary experimentation is reported in Section 6. 2 Determining Resource Requirements using Allocation Chains This section summarizes the measurement of resource requirements used to locate excessive sets and resource holes. Details of the techniques are presented in <ref> [BGS93] </ref>. Measurement of resources demands depends on the usage characteristics of the resource. The two major types of resources considered in this work, functional units and registers, have different use properties.
Reference: [BGS94] <author> D. A. Berson, R. Gupta and M. L. Soffa, </author> <title> Representing Architecture Constraints in URSA, </title> <type> Technical Report 94-10, </type> <institution> University of Pittsburgh, Computer Science Department, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Pipelines, resource demands that can be satisfied by several types of resources, and implicit resource demands also can be modeled in Resource Spackling <ref> [BGS94] </ref>. Finally, the framework also shows promise for other research. These topics include predicting the impact of traditional optimizations and parallelizing transformations on the schedule, and studying interactions 15 between local and global schedulers, by providing a common representation of the under-utilized resources that they compete for.
Reference: [BEH91] <author> D. G. Bradlee, S. J. Eggers and R. R. Henry, </author> <title> Integrating Register Allocation and Instruction Scheduling for RISCs, </title> <booktitle> Proc. Fourth International Conf. on ASPLOS, </booktitle> <address> Santa Clara, CA, </address> <month> April 8-11, </month> <year> 1991, </year> <pages> pp. 122-131. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [DHB89] <author> J. C. Dehnert, P. Y. Hsu and J. P. Bratt, </author> <title> Overlapped Loop Support in the Cydra 5, </title> <booktitle> Proc. of ASPLOS-III, </booktitle> <year> 1989, </year> <pages> pp. 26-39. </pages>
Reference-contexts: Instructions can be moved below join points, from Bthen and/or Belse to B2, if the architecture supports guarded execution <ref> [DHB89, HsD86] </ref>.
Reference: [Dil50] <author> R. P. </author> <title> Dilworth, A Decomposition Theorem for Partially Ordered Sets, </title> <booktitle> Annuals of Mathematics 51 (1950) pp. </booktitle> <pages> 161-166. </pages>
Reference-contexts: The following theorem relates the maximum number of resources required to the number of chains in a minimum decomposition. Theorem 1 The maximum number of independent elements in a partial order is equal to the number of chains in a minimal decomposition. Proof: See <ref> [Dil50] </ref> Since the partial order is constructed from resource reuse information, the number of chains in a minimal decomposition represents the maximum number of instructions that can execute concurrently and simultaneously live values for Reuse F U DAGs and Reuse Reg DAGs respectively.
Reference: [EbN89] <author> K. Ebcioglu and A. Nicolau, </author> <title> A global Resource-Constrained Parallelization Technique, </title> <booktitle> Proc. ACM SIGARCH ICS-89: International Conf. on Supercomputing, </booktitle> <address> Crete, Greece, </address> <month> June 2-9, </month> <year> 1989. </year>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved [AiN88, BeR91, Fis81, GuS90, SHL92] by concentrating on functional unit constraints <ref> [EbN89, MGS92] </ref> in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93].
Reference: [Fis81] <author> J. A. Fisher, </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Trans. on Computers C-30 , 7(July 1981) pp. </journal> <pages> 478-490. </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available. The framework can be used in conjunction with commonly used methods for performing the code motions, such as Trace Scheduling <ref> [Fis81] </ref>, Percolation Scheduling [AiN88], and Region Scheduling [GuS90]. The Resource Spackling framework computes resource requirements for a program in two steps. First, a unified representation of functional unit and register uses is constructed. This representation identifies all resource uses that can temporally share the same instance of a resource. <p> In these situations the moved instructions make additional resources available which can be used by subsequent moves, resulting in a reduction in execution time. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [FoF65] <author> L. R. Ford and D. R. Fulkerson, </author> <title> Flows in Networks, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1965. </year>
Reference-contexts: Thus, the block in Figure 1 (a) requires four functional units and five registers to exploit all of its parallelism. A minimum decomposition of a partial order can be found by using a straightforward transformation to a bipartite graph matching problem <ref> [FoF65] </ref>. 3 Resource Holes Resource holes and their properties are located by analyzing the allocation chains for the resource of interest. To describe these holes precisely we introduce the following notation.
Reference: [GiM86] <author> P. B. Gibbons and S. S. Muchnick, </author> <title> Efficient Instruction Scheduling for Pipelined Architectures, </title> <booktitle> Proc. Sigplan '86 Symp. on Compiler Construction Sigplan Notices 21 , 7(July 1986) pp. </booktitle> <pages> 11-16. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [GoH88] <author> J. R. Goodman and W. Hsu, </author> <title> Code Scheduling and Register Allocation in Large Basic Blocks, </title> <booktitle> Proc. of the ACM Supercomputing Conference, </booktitle> <year> 1988, </year> <pages> pp. 442-452. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [GuS90] <author> R. Gupta and M. L. Soffa, </author> <title> Region Scheduling: An Approach for Detecting and Redistributing Parallelism, </title> <journal> IEEE Trans. on Software Engineering 16 , 4(April 1990) pp. </journal> <pages> 421-431. </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> The framework can be used in conjunction with commonly used methods for performing the code motions, such as Trace Scheduling [Fis81], Percolation Scheduling [AiN88], and Region Scheduling <ref> [GuS90] </ref>. The Resource Spackling framework computes resource requirements for a program in two steps. First, a unified representation of functional unit and register uses is constructed. This representation identifies all resource uses that can temporally share the same instance of a resource. <p> In these situations the moved instructions make additional resources available which can be used by subsequent moves, resulting in a reduction in execution time. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [HeG83] <author> J. L. Hennessy and T. Gross, </author> <title> Postpass Code Optimization of Pipeline Constraints, </title> <journal> ACM Trans. Prog. Lang. and Systems 5 , 3(July 1983) pp. </journal> <pages> 422-448. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [HsD86] <author> P. Y. T. Hsu and E. S. Davidson, </author> <title> Highly Concurrent Scalar Processing, </title> <booktitle> Proc. 13th Annual International Symp. on Computer Architecture, </booktitle> <month> June </month> <year> 1986, </year> <pages> pp. 386-395. </pages>
Reference-contexts: Instructions can be moved below join points, from Bthen and/or Belse to B2, if the architecture supports guarded execution <ref> [DHB89, HsD86] </ref>.
Reference: [HwP87] <author> W. W. Hwu and Y. N. Patt, </author> <title> Checkpoint Repair for Out-of-order Execution Machines, </title> <booktitle> Proc. 14th Annual International Symp. on Computer Architecture, </booktitle> <month> June </month> <year> 1987, </year> <pages> pp. 18-26. </pages>
Reference-contexts: Instructions can be moved above conditional branches, from Bthen and/or Belse to B1 if either the moved instructions do not violate data dependences or if the architecture supports speculative execution <ref> [HwP87, SHL92] </ref>. Instructions can be moved below join points, from Bthen and/or Belse to B2, if the architecture supports guarded execution [DHB89, HsD86].
Reference: [MGS92] <author> B. Malloy, R. Gupta and M. L. Soffa, </author> <title> A Shape Matching Approach for Scheduling Fine-Grained Parallelism, </title> <booktitle> Proc. 25th Annual International Symp. on Microarchitecture, </booktitle> <address> Portland, Oregon, </address> <month> Dec 1-4, </month> <year> 1992, </year> <pages> pp. 264-267. 16 </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved [AiN88, BeR91, Fis81, GuS90, SHL92] by concentrating on functional unit constraints <ref> [EbN89, MGS92] </ref> in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Such capability is an improvement over techniques that do attempt to consider resource demands [MoE92]. When holes occur only at the beginning or end of basic blocks the problem degenerates to Shape Matching <ref> [MGS92] </ref>. However, Shape Matching considers only functional units, while in this case Resource Spackling performs the equivalent of shape matching across all resources at once. A critical set being considered for filling holes in a destination block may have resource requirements that exceed the number of holes.
Reference: [MoE92] <author> S. Moon and K. Ebcioglu, </author> <title> An Efficient Resource-Constrained Global Scheduling Technique for Superscalar and VLIW Processors, </title> <note> Computer Science Research Report RC 17962 (#78691), </note> <institution> IBM Thomas J. Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Only recently has work on global scheduling begun to consider register allocation as a part of the problem <ref> [MoE92, NiG93] </ref>. Although Moon and Ebcioglu [MoE92] added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block. <p> Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. Although Moon and Ebcioglu <ref> [MoE92] </ref> added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block. Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available. <p> Such capability is an improvement over techniques that do attempt to consider resource demands <ref> [MoE92] </ref>. When holes occur only at the beginning or end of basic blocks the problem degenerates to Shape Matching [MGS92]. However, Shape Matching considers only functional units, while in this case Resource Spackling performs the equivalent of shape matching across all resources at once.
Reference: [NiG93] <author> Q. Ning and G. R. Gao, </author> <title> A Novel Framework of Register Allocation for Software Pipelining, </title> <booktitle> Conf. Rec. 20th ACM Symp. on Prin. of Programming Languages, </booktitle> <month> Jan. </month> <year> 1993, </year> <pages> pp. 29-42. </pages>
Reference-contexts: Only recently has work on global scheduling begun to consider register allocation as a part of the problem <ref> [MoE92, NiG93] </ref>. Although Moon and Ebcioglu [MoE92] added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block.
Reference: [Pin93] <author> S. S. Pinter, </author> <title> Register Allocation with Instruction Scheduling: A New Approach, </title> <booktitle> Proc. Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, NM., </address> <month> June 23-25, </month> <year> 1993, </year> <pages> pp. 248-257. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling. <p> These two features limit the direct assessment of the impact of register and functional unit allocation decisions on the availability of other resources and hence on the length of the schedule. Recent work has incorporated parallel live range information into register allocation, but still separates it from instruction scheduling <ref> [Pin93] </ref>. The approach presented in this paper unifies the allocation of registers and functional units in a single phase so that all resources are allocated at once. Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block.
Reference: [SHL92] <author> M. D. Smith, M. Horowitz and M. Lam, </author> <title> Efficient Superscalar Performance Through Boosting, </title> <booktitle> Proc. 5th International Conf. on ASPLOS, </booktitle> <address> Boston, Massachusetts, </address> <month> Oct. </month> <pages> 12-15, </pages> <year> 1992, </year> <pages> pp. 248-259. </pages>
Reference-contexts: Our approach is able to consider the impact of an allocation decision on all other instructions in the basic block. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Instructions can be moved above conditional branches, from Bthen and/or Belse to B1 if either the moved instructions do not violate data dependences or if the architecture supports speculative execution <ref> [HwP87, SHL92] </ref>. Instructions can be moved below join points, from Bthen and/or Belse to B2, if the architecture supports guarded execution [DHB89, HsD86].
Reference: [SwB90] <author> P. Sweany and S. Beaty, </author> <title> Post-Compaction Register Assignment in a Retargetable Compiler, </title> <booktitle> Proc. of the 23rd Annual Workshop on Microprogramming and Microarchitecture, </booktitle> <month> Nov. </month> <year> 1990, </year> <pages> pp. 107-116. </pages>
Reference-contexts: The framework allows all resources to be considered simultaneously during code motion. Previous work on local schedulers has examined this interaction <ref> [BEH91, GiM86, GoH88, HeG83, Pin93, SwB90] </ref> but treated register allocation and instruction scheduling as separate phases. In addition, the instruction scheduling phases have been based on list scheduling.
References-found: 23

