URL: http://www.eecs.umich.edu/~davidvc/publications/hldvt97_armasm.ps
Refering-URL: http://www.eecs.umich.edu/~davidvc/publications.html
Root-URL: http://www.cs.umich.edu
Email: jhuggins@gmi.edu davidvc@eecs.umich.edu  
Title: Specification and Verification of Pipelining in the ARM2 RISC Microprocessor (Extended Abstract)  
Author: James K. Huggins David Van Campenhout 
Address: Flint, MI 48504-4898 Ann Arbor, MI 48109-2122  
Affiliation: Department of Science Mathematics EECS Department GMI Engineering Management Institute University of Michigan  
Abstract: Gurevich Abstract State Machines (ASMs) provide a sound mathematical basis for the specification and verification of systems. In this paper we describe an application of the ASM methodology to the verification of a pipelined microprocessor (an ARM2 implementation). Both the sequential execution model and final pipelined model are formalized using ASMs. A series of intermediate models are introduced that gradually expose the complications of pipelining. The first intermediate model is proven equivalent to the sequential model in the absence of structural, control, and data hazards. In the following steps, these simplifying assumptions are lifted one by one, and the original proof is refined to establish the equivalence of each intermediate model with the sequential model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Acorn RISC machine (ARM) family data manual, </institution> <address> Englewood Cliffs, N.J. </address> : <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: See [2, 11] for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor <ref> [1, 4] </ref>. Key features of this processor include a load/store architecture, a 32-bit datapath, conditional execution of every instruction, and a small but powerful instruction set.
Reference: [2] <author> E. Borger, </author> <title> "Annotated Bibliography on Evolving Algebras", in Specification and Validation Meth 5 of 8 ods, </title> <editor> ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> 37-51. </pages> <note> (Available from [11].) </note>
Reference-contexts: ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See <ref> [2, 11] </ref> for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor [1, 4]. <p> Based upon this thesis, members of the ASM community have sought to develop a methodology based upon mathematics which would allow such systems to be modeled naturally; that is, described at their natural abstraction levels. See <ref> [2, 11] </ref> for a number of examples of ASMs applied to various real-world systems. ASMs (under their former name, evolving algebras) are described more fully in [6, 7]. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [3] <author> E. Borger and S. Mazzanti, </author> <title> "A Practical Method for Rigorously Controllable Hardware Design." </title> <editor> In J. Bowen, M.G. Hinchey, and D. Till, eds., "ZUM'97: </editor> <title> The Z Formal Specification Notation," </title> <booktitle> Springer Lecture Notes in Computer Science 1212, </booktitle> <year> 1997, </year> <pages> 151-187. </pages> <note> (Available from [11].) </note>
Reference-contexts: The induction hypothesis is derived automatically and is checked automatically with a validity checker [13]. Once a proper description of the pipelined and sequential model in terms of uninterpreted functions has been written, the method is highly automatic. Borger and Mazzanti <ref> [3] </ref> applied the ASM method ology for the first time to microprocessor verification. They proved the correctness of a pipelined version of the DLX processor [9] with respect to the sequential specification.
Reference: [4] <author> S.B. Furber, </author> <title> VLSI RISC architecture and organization, </title> <address> New York, </address> <publisher> M. Dekker, </publisher> <year> 1989. </year>
Reference-contexts: See [2, 11] for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor <ref> [1, 4] </ref>. Key features of this processor include a load/store architecture, a 32-bit datapath, conditional execution of every instruction, and a small but powerful instruction set.
Reference: [5] <author> Y. Gurevich, </author> <title> "Logic and the challenge of computer science." </title> <editor> In E. Borger, ed., </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <publisher> Computer Science Press, </publisher> <year> 1988, </year> <pages> 1-57. </pages>
Reference-contexts: 1 Introduction The Abstract State Machine (ASM) methodology, formerly known as the evolving algebra methodology and first proposed in <ref> [5] </ref>, is a simple yet powerful methodology for specifying and verifying software and hardware systems. ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See [2, 11] for numerous examples.
Reference: [6] <author> Y. Gurevich, </author> <title> "Evolving Algebras: An Attempt to Discover Semantics", </title> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <editor> eds. G. Rozenberg and A. Salomaa, </editor> <publisher> World Scientific, </publisher> <year> 1993, </year> <pages> 266-292. </pages> <note> (First published in Bull. EATCS 57 (1991), 264-284. Available from [11].) </note>
Reference-contexts: See [2, 11] for a number of examples of ASMs applied to various real-world systems. ASMs (under their former name, evolving algebras) are described more fully in <ref> [6, 7] </ref>. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [7] <author> Y. Gurevich, </author> <title> "Evolving Algebras 1993: Lipari Guide", in Specification and Validation Methods, </title> <editor> ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> 9-36. </pages> <note> (Available from [11].) </note>
Reference-contexts: See [2, 11] for a number of examples of ASMs applied to various real-world systems. ASMs (under their former name, evolving algebras) are described more fully in <ref> [6, 7] </ref>. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [8] <author> Y. Gurevich, "Platonism, </author> <title> Constructivism, and Computer Proofs vs. Proofs by Hand", </title> <type> Bull. </type> <institution> of Euro. Assoc. of Theor. Computer Science, </institution> <month> Oct. </month> <year> 1995, </year> <pages> 145-166. </pages>
Reference-contexts: Machine-verified proofs are certainly of great value; it may be more difficult, however, for readers to understand a machine-oriented proof than a human-oriented proof (since a different audience is addressed by such a proof) <ref> [8] </ref>. The ASM methodology does not contain a unique automated proof assistant; however, ASM specifications have been used as the starting point for mechanical verification using other proof assistants such as KIV [16], PVS [18], and SMV [17].
Reference: [9] <author> J.L. Hennessy and D.A. Patterson, </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year> <note> (Revised second edition, </note> <year> 1996.) </year>
Reference-contexts: Borger and Mazzanti [3] applied the ASM method ology for the first time to microprocessor verification. They proved the correctness of a pipelined version of the DLX processor <ref> [9] </ref> with respect to the sequential specification. The overall structure of the approach 4 of 8 is similar to our work, although the architecture and the micro-architecture (pipeline) of the DLX and the ARM differ significantly.
Reference: [10] <author> J. Hooman, </author> <title> "Using PVS for an Assertional Verification of the RPC-Memory Specification Problem", in "Formal Systems Specification; The RPC-Memory Specification Case Study," </title> <booktitle> Springer Lecture Notes in Computer Science 1169, </booktitle> <year> 1996, </year> <pages> 275-304. </pages>
Reference-contexts: In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification <ref> [10] </ref>; a hand-oriented specification and proof such as that presented here more than fulfills that need. Conclusion We applied the ASM methodology to the verification of a pipelined microprocessor, the ARM.
Reference: [11] <author> J. K. Huggins, ed., </author> <title> "Abstract State Machine Home Page", </title> <institution> EECS Department, University of Michigan, </institution> <note> http://www.eecs.umich.edu/gasm/. </note>
Reference-contexts: ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See <ref> [2, 11] </ref> for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor [1, 4]. <p> Based upon this thesis, members of the ASM community have sought to develop a methodology based upon mathematics which would allow such systems to be modeled naturally; that is, described at their natural abstraction levels. See <ref> [2, 11] </ref> for a number of examples of ASMs applied to various real-world systems. ASMs (under their former name, evolving algebras) are described more fully in [6, 7]. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [12] <author> J. K. Huggins and D. Van Campenhout, </author> <title> "Specification and Verification of Pipelining in the ARM2 RISC Microprocessor", </title> <institution> University of Michigan EECS Department Technical Report CSE-TR-321-96, </institution> <year> 1996. </year> <note> (Available from [11].) </note>
Reference-contexts: The rules defining E 1 , along with a listing of all functions and their types, are listed in the Appendix. The rules for the data transfer instructions are omitted but can be found in <ref> [12] </ref>. Notice that all rules fire simultaneously. 4.1 Definitions and Discussion Informally, an execution cycle of E 1 is a sequence of consecutive states in which an instruction moves through the fetch, decode, and execute stages. <p> Acknowledgements. An earlier but detailed version of this work is available as a technical report <ref> [12] </ref>. We thank Trevor Mudge for originally suggesting the project to us and supporting its development. We also thank several anonymous referees who made suggestions on earlier drafts of this paper.
Reference: [13] <author> R. B. Jones, D. L. Dill, and J. R. Burch, </author> <title> "Efficient validity checking for processor verification", </title> <booktitle> in Proceedings IEEE International Conference on Computer Aided Design, </booktitle> <year> 1995, </year> <pages> 2-6. </pages>
Reference-contexts: In each iteration, the equivalence between the old pipeline and the new pipeline is proved. As in our work, the proof is by induction on the number of execution cycles. The induction hypothesis is derived automatically and is checked automatically with a validity checker <ref> [13] </ref>. Once a proper description of the pipelined and sequential model in terms of uninterpreted functions has been written, the method is highly automatic. Borger and Mazzanti [3] applied the ASM method ology for the first time to microprocessor verification.
Reference: [14] <author> J. Levitt and K. Olukotun, </author> <title> "Scalable formal verification methodology for pipelined microprocessors", </title> <booktitle> Proceedings of the 33rd ACM/IEEE Design Automation Conference, </booktitle> <year> 1996, </year> <pages> 558-563. </pages>
Reference-contexts: These also methods tend to fail on real-life sized systems unless an abstracted system model is used, which often must be derived manually. On the opposite end, there are methods that require substantial user assistance, but offer richer expressiveness and facilitate hierarchical analysis. Levitt and Olukotun <ref> [14] </ref> proposed a methodology for verifying pipelined processors. The datapath functional units are assumed to be correct and are represented by uninterpreted functions. The methodology iteratively merges the two deepest pipeline stages until the sequential model is obtained.
Reference: [15] <author> M. C. McFarland. </author> <title> "Formal verification of sequential hardware: a tutorial." </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <month> May </month> <year> 1993, </year> <pages> 633-654. </pages>
Reference-contexts: Again, a small change to the Update Lemma is all that is required to transplant the equivalence proof. 6 Discussion Automated formal verification for microprocessors has become a popular area of research. The spectrum of methods <ref> [15] </ref> can be characterized as follows. On the one end, there are highly automated methods whose power is limited in the type of properties that can be expressed and handled.
Reference: [16] <author> G. Schellhorn and W. Ahrendt, </author> <title> "Reasoning about Abstract State Machines: The WAM Case Study", </title> <journal> Journal of Universal Computer Science, </journal> <volume> vol. 3, no. 4 (1997), </volume> <pages> 377-413. </pages> <note> (Available from [11].) </note>
Reference-contexts: The ASM methodology does not contain a unique automated proof assistant; however, ASM specifications have been used as the starting point for mechanical verification using other proof assistants such as KIV <ref> [16] </ref>, PVS [18], and SMV [17]. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [10]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
Reference: [17] <author> K. Winter, </author> <title> "Model Checking for Abstract State Machines", </title> <journal> Journal of Universal Computer Science, </journal> <volume> vol. 3, no. 5 (1997), </volume> <pages> 689-701. </pages> <note> (Available from [11].) 6 of 8 </note>
Reference-contexts: The ASM methodology does not contain a unique automated proof assistant; however, ASM specifications have been used as the starting point for mechanical verification using other proof assistants such as KIV [16], PVS [18], and SMV <ref> [17] </ref>. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [10]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
Reference: [18] <author> W. Zimmerman and T. Gaul, </author> <title> "On the Construc--tion of Correct Compiler Back-Ends: An ASM Approach", </title> <journal> Journal of Universal Computer Science, </journal> <volume> vol. 3, no. 5 (1997), </volume> <pages> 504-567. </pages> <note> (Available from [11].) </note>
Reference-contexts: The ASM methodology does not contain a unique automated proof assistant; however, ASM specifications have been used as the starting point for mechanical verification using other proof assistants such as KIV [16], PVS <ref> [18] </ref>, and SMV [17]. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [10]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
References-found: 18

