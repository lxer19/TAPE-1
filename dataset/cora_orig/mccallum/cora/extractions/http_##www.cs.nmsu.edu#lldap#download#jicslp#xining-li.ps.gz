URL: http://www.cs.nmsu.edu/lldap/download/jicslp/xining-li.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/xi.html
Root-URL: http://www.cs.nmsu.edu
Email: E-mail: xli@flash.lakeheadu.ca  
Title: Structure Sharing and Structure Copying Revisited new approach is very promising in both performance and
Author: Xining Li 
Keyword: Unification, Term Representation, Abstract Machine  
Note: 1 2 I have implemented an experimental LAM 2 -emulator in C. Benchmarks show that this  
Address: Thunder Bay, Canada  
Affiliation: Department of Computer Science Lakehead University  
Abstract: Various Prolog systems can be classified into two categories: Structure Sharing (SS) and Structure Copying (SC). The fundamental distinction of SS and SC is the way of representing structures. SS represents a structure instance by a two-pointer molecule with one to the structure skeleton and the other to a binding environment. On the other hand, SC makes a concrete copy of a structure whenever the structure is matched against a variable. SS was used in earlier Prolog implementations while SC has been accepted as the de facto standard in modern Prolog implementations. However, analysis and practical comparison of SS and SC shown that programs can be written which make any one method almost arbitrarily worse than the other. In this paper, I propose a new Prolog implementation approach Program Sharing (PS). The major contribution of this work is that PS has the advantages of both SC (representing terms of different types to fit in the size of a machine word) and SS (low overhead in constructing a dynamic structure instance), and the concept of program sharing could be used to realize all special-case instruction-driven unification. PS has been adopted in the design of a new Prolog abstract machine the LAM 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer and J. S. Moore. </author> <title> The Sharing of Structure in Theorem Proving Programs. </title> <booktitle> Machine Intelligence 7 (B. </booktitle> <editor> Meltzer and D. Miche, eds.), </editor> <publisher> Edinburgh University Press, </publisher> <year> 1972, </year> <pages> pp. 101-116. </pages>
Reference-contexts: 1. Introduction For more than twenty years, two very different methods Structure Sharing (SS) and Structure Copying (SC), have been used to implement term unification in various Prolog systems. SS was first introduced by Boyer and Moore <ref> [1] </ref> and used in earlier Prolog implementations, such as DEC-10 Prolog [2] and MProlog [3]. The first report of SC implementation came from Bruynooghe [4] and has been accepted as the de facto standard in modern Prolog implementations.
Reference: [2] <author> D. H. D. Warren. </author> <title> Logic Programming and Compiler Writing. </title> <type> Technique Report: DAI 44, </type> <institution> University of Edinburgh, </institution> <year> 1977. </year>
Reference-contexts: 1. Introduction For more than twenty years, two very different methods Structure Sharing (SS) and Structure Copying (SC), have been used to implement term unification in various Prolog systems. SS was first introduced by Boyer and Moore [1] and used in earlier Prolog implementations, such as DEC-10 Prolog <ref> [2] </ref> and MProlog [3]. The first report of SC implementation came from Bruynooghe [4] and has been accepted as the de facto standard in modern Prolog implementations.
Reference: [3] <author> Z. Farkas, P. Koves and P. Szeredi. MProlog: </author> <title> An Implementation Overview. Implementations of Logic Programming Systems, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994, </year> <pages> pp. 103-117. </pages>
Reference-contexts: SS was first introduced by Boyer and Moore [1] and used in earlier Prolog implementations, such as DEC-10 Prolog [2] and MProlog <ref> [3] </ref>. The first report of SC implementation came from Bruynooghe [4] and has been accepted as the de facto standard in modern Prolog implementations. The abstract machines dedicated to Prolog, such as the WAM [5][6] and the VAM [7], adopt SC as the fundamental component to implement efficient unification. <p> A dynamic instruction is one which can become the binding of a variable. Dereferencing operation terminates when a dynamic instruction is reached. Since PS is originated from SS, they face a same question: how many structure instances will be created during execution. Here I take remarks from <ref> [3] </ref> to answer this question:" In general it is impossible to know when, and how many molecules are created this considerably complicates the management of the global stack.
Reference: [4] <author> M. Bruynooghe. </author> <title> An Interpreter for Predicate Programs: Part 1. </title> <type> Technique Report CW 16, </type> <institution> Katholieke Universiteit Leuven, </institution> <year> 1976. </year>
Reference-contexts: SS was first introduced by Boyer and Moore [1] and used in earlier Prolog implementations, such as DEC-10 Prolog [2] and MProlog [3]. The first report of SC implementation came from Bruynooghe <ref> [4] </ref> and has been accepted as the de facto standard in modern Prolog implementations. The abstract machines dedicated to Prolog, such as the WAM [5][6] and the VAM [7], adopt SC as the fundamental component to implement efficient unification.
Reference: [5] <author> D. H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <note> Technical Note 209, SIR International, </note> <year> 1983. </year>
Reference: [6] <author> H. Ait-Kaci. </author> <title> Warren's Abstract Machine: a Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [7] <author> A. Krall and U. Neumerkel. </author> <title> The Vienna Abstract Machine. In PLILP'90, </title> <publisher> LNCS. Springer, </publisher> <year> 1990. </year>
Reference-contexts: The first report of SC implementation came from Bruynooghe [4] and has been accepted as the de facto standard in modern Prolog implementations. The abstract machines dedicated to Prolog, such as the WAM [5][6] and the VAM <ref> [7] </ref>, adopt SC as the fundamental component to implement efficient unification.
Reference: [8] <author> P. Van Roy and A. M. Despain. </author> <title> High-Performance Logic Programming with the Aquarius Prolog Compiler. </title> <journal> IEEE Computer, </journal> <volume> Vol. 25, No. 1, </volume> <year> 1992, </year> <pages> pp. 54-68. </pages>
Reference: [9] <author> A. Taylor. </author> <title> LIPS on a MIPS: Results from a Prolog compiler to RISC. </title> <booktitle> In 6th ICLP, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge , 1990, </address> <pages> pp. 174-185. </pages>
Reference: [10] <author> E. Tick and G. Succi. </author> <title> Implementations of Logic Programming Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference: [11] <author> P. Codognet and D. Diaz. wamcc: </author> <title> Compiling Prolog to C. </title> <publisher> PLILP'95, The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: First, the LAM 1 2 emulator is not a complete system. It does not perform stack-overflow checking. Adding this function could influence the empirical results. However, an idea proposed by <ref> [11] </ref> suggests to use UNIX memory manager to raise an exception signal in case of stack overflow, and therefore eliminates costly software tests. Secondly, benchmarks are small and hand-translated with optimizations based on annotated mode. This is unfair towards the compared systems because mode information helps to generate better code.
Reference: [12] <author> D. H. D. Warren. </author> <title> Foreword in Warren's Abstract Machine: a Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991, </year> <pages> pp. </pages> <month> xiii-xiv. </month>
Reference: [13] <author> C. S. Mellish. </author> <title> An Alternative to Structure Sharing in the Implementation of a Prolog Interpreter. Logic Programming, </title> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: oe oe oe oe - ? ? @ @R - off:0off:1off:0 cba a K1 R0 R0 K0:t/3 after A = Bbefore A = B 0 ENV ENV ENV MRF ENV MRF ENV B A W Y REF ENV REF ENV B A SC and SS have been thoroughly investigated in <ref> [13] </ref> [14]. It is faster to create terms in a SS system while it is faster to access (unify) terms in a SC system. Comparison between them shown that programs can be written which make any one method almost arbitrarily worse than the other. <p> Sharing a code pattern is not just on rare occasions in PS, and is of benefits to code locality. 4. Memory Utilization and Performance Analysis It is certain that both PS and SS consume less local space than SC, this has been discussed by <ref> [13] </ref>. As regards global space utilization, PS is clearly better than SS, because it uses one-cell stubs to replace two-cell molecules.
Reference: [14] <author> M. Bruynooghe. </author> <title> The Memory Management of Prolog Implementations. Logic Programming, </title> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: oe oe oe - ? ? @ @R - off:0off:1off:0 cba a K1 R0 R0 K0:t/3 after A = Bbefore A = B 0 ENV ENV ENV MRF ENV MRF ENV B A W Y REF ENV REF ENV B A SC and SS have been thoroughly investigated in [13] <ref> [14] </ref>. It is faster to create terms in a SS system while it is faster to access (unify) terms in a SC system. Comparison between them shown that programs can be written which make any one method almost arbitrarily worse than the other.
References-found: 14

