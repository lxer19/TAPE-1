URL: http://www.cs.ucsb.edu/oocsb/papers/pldi92.ps
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/oo-compilation-papers.html
Root-URL: 
Abstract: ACM SIGPLAN 92 Conference on Programming Language Design and Implementation, San Francisco, June 1992. Abstract: SELFs debugging system provides complete source-level debugging (expected behavior) with globally optimized code. It shields the debugger from optimizations performed by the compiler by dynamically deoptimizing code on demand. Deoptimization only affects the procedure activations that are actively being debugged; all other code runs at full speed. Deoptimization requires the compiler to supply debugging information at discrete interrupt points; the compiler can still perform extensive optimizations between interrupt points without affecting debuggability. At the same time, the inability to interrupt between interrupt points is invisible to the user. Our debugging system also handles programming changes during debugging. Again, the system provides expected behavior: it is possible to change a running program and immediately observe the effects of the change. Dynamic deoptimization transforms old compiled code (which may contain inlined copies of the old version of the changed procedure) into new versions reecting the current source-level state. To the best of our knowledge, SELF is the first practical system providing full expected behavior with globally optimized code. 
Abstract-found: 1
Intro-found: 1
Reference: [Cha87] <author> David Chase. </author> <title> Garbage Collection and Other Optimizations. </title> <type> Ph.D. dissertation, </type> <institution> Computer Science Department, Rice University, </institution> <year> 1987. </year>
Reference-contexts: Garbage collections can only occur at interrupt points, and so the compiler can generate Interrupt points have been used in other systems before; see section 8 for a discussion of the Deutsch-Schiffman Smalltalk-80 system. code between interrupt points that temporarily violates the invariants needed by the garbage collector <ref> [Cha87] </ref>. 4. Updating active methods During debugging, a programmer might not only change the value of a variable but also the definition of a method. <p> In many cases, the optimizations inhibited by garbage collection are very similar to those inhibited by debugging requirements, such as dead store elimination and some forms of common subexpression elimination <ref> [Cha87] </ref>. Thus, it would be difficult to separate the impact of garbage collection on optimization from the impact of full source-level debugging. However, we have measured some effects of source-level debugging in the SELF system.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. dissertation, 12 </type>
Reference-contexts: 1. Introduction SELF is a pure object-oriented language designed for rapid prototyping, increasing programmer productivity by maximizing expressiveness and malleability [US87]. SELFs pure message-based model of computation requires extensive optimization to achieve good performance [CU91, HCU91]. Without aggressive procedure integration (inlining), for example, performance would be abysmal <ref> [Cha92] </ref>. But an interactive programming environment also demands rapid turnaround time and complete source-level debugging. To make SELF practical, the system must provide interpreter semantics at compiled-code speed, combining expected behavior [Zel84] with global optimization. Most existing systems do not support the debugging of optimized code. <p> To determine the impact of debugger-visible names, the compiler was changed to release registers allocated to dead variables even if they were visible at an interrupt point. The performance improvement with the changed compiler was insignificant (less than 2%) for a wide range of programs <ref> [Cha92] </ref>. <p> This polling slows down typical programs by about 4%; some numerical programs with very tight loops are slowed down by up to 13% <ref> [Cha92] </ref>. With a more complicated run-time system using conditional traps, the overhead could be reduced to one cycle per check, and loop unrolling could further reduce the problem for tight loops. <p> As far as we know, most of the support for opti mized code in LOIPE was not actually implemented. current representation of the dependencies contains significant redundancies. An alternate implementation could probably reduce the space usage significantly <ref> [Cha92] </ref>. As a rough comparison, when compiling the SELF virtual machine, a standard commercial C++ 2.1 compiler generated 55 Mbytes of debugging information on top of an executable of 2.4 Mbytes, incurring an overhead of a factor of 24.
Reference: [TA90] <author> Andrew P. Tolmach and Andrew W. Appel. </author> <title> Debugging Standard ML Without Reverse Engineering. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990, </year> <pages> pp. 1-12. </pages>
Reference-contexts: In OOPSLA 88 Conference Proceedings, pp. 18-26, San Diego, CA, October, 1988. Published as SIGPLAN Notices 23 (11), November, 1988. [SW78] H. Schlaeppi and H. Warren. Design of the FDS Interactive Debugging System. IBM Research Report RC7214, IBM Yorktown Heights, July 1978. Tolmach and Appel <ref> [TA90] </ref> describe a debugger for ML where the compiler always performs optimizations, but where the program is automatically annotated with debugging statements before compilation. To debug an optimized program, the programmer has to manually recompile and re-execute the program.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: 1. Introduction SELF is a pure object-oriented language designed for rapid prototyping, increasing programmer productivity by maximizing expressiveness and malleability <ref> [US87] </ref>. SELFs pure message-based model of computation requires extensive optimization to achieve good performance [CU91, HCU91]. Without aggressive procedure integration (inlining), for example, performance would be abysmal [Cha92]. But an interactive programming environment also demands rapid turnaround time and complete source-level debugging.
Reference: [Zel83] <author> Polle T. Zellweger. </author> <title> An Interactive High-Level Debugger for Control-Flow Optimized Programs. </title> <note> Xerox PARC Technical Report CSL-83-1, </note> <month> January </month> <year> 1983. </year>
Reference-contexts: In contrast, we are not willing to accept any debugging failures and therefore do not perform optimizations which would create such situations at an interrupt point. Zellweger <ref> [Zel83, Zel84] </ref> describes an interactive source-level debugger for Cedar which handles two optimizations, procedure inlining and cross-jumping, to provide expected behavior in most cases.
Reference: [Zel84] <author> Polle T. Zellweger. </author> <title> Interactive Source-Level Debugging of Optimized Programs. </title> <type> Ph.D. dissertation, </type> <institution> Computer Science Department, University of California, Berkeley, </institution> <year> 1984. </year> <note> Also published as Xerox PARC Technical Report CSL-84-5, </note> <month> May </month> <year> 1984. </year>
Reference-contexts: Without aggressive procedure integration (inlining), for example, performance would be abysmal [Cha92]. But an interactive programming environment also demands rapid turnaround time and complete source-level debugging. To make SELF practical, the system must provide interpreter semantics at compiled-code speed, combining expected behavior <ref> [Zel84] </ref> with global optimization. Most existing systems do not support the debugging of optimized code. Programs can either be optimized for full speed, or they can be compiled without optimizations for full source-level debugging. <p> Most existing systems do not support the debugging of optimized code. Programs can either be optimized for full speed, or they can be compiled without optimizations for full source-level debugging. Recently, techniques have been developed that strive to make it possible to debug optimized code <ref> [Hen82, Zel84, CMR88] </ref>. However, none of these systems is able to provide full source-level debugging. For example, it generally is not possible to obtain the values of all source-level variables, to single-step through the program, or to change the value of a variable. <p> In contrast, neither single-step nor finish could generally be provided by previous systems for debugging optimized code <ref> [Zel84, CMR88] </ref>. 5.1 Single-step Because every source point has an interrupt point associated with it in a deoptimized method, the implementation of single-stepping becomes trivial. The system deoptimizes the current activation and restarts the process with the interrupt ag already set. <p> In contrast, we are not willing to accept any debugging failures and therefore do not perform optimizations which would create such situations at an interrupt point. Zellweger <ref> [Zel83, Zel84] </ref> describes an interactive source-level debugger for Cedar which handles two optimizations, procedure inlining and cross-jumping, to provide expected behavior in most cases.
Reference: [ZJ91] <author> Lawrence W. Zurawski and Ralph E. Johnson. </author> <title> Debugging Optimized Code With Expected Behavior. </title> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: Zurawski and Johnson <ref> [ZJ91] </ref> describe a model for a debugger (developed concurrently with this work) which closely resembles ours, using inspection points and dynamic deoptimization to provide expected behavior for optimized code. However, the system does not use lazy conversion.
References-found: 7

