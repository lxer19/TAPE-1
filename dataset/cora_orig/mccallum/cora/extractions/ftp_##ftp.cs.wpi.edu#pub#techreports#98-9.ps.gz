URL: ftp://ftp.cs.wpi.edu/pub/techreports/98-9.ps.gz
Refering-URL: http://cs.wpi.edu/Resources/techreports/index.html
Root-URL: 
Title: SERF: Schema Evolution through an Extensible, Re-usable and Flexible Framework  
Author: by Kajal T. Claypool Jin Jing Elke A. Rundensteiner 
Date: June 1998  
Pubnum: WPI-CS-TR-98-9  
Abstract: Computer Science Technical Report Series WORCESTER POLYTECHNIC INSTITUTE Computer Science Department 100 Institute Road, Worcester, Massachusetts 01609-2280 
Abstract-found: 1
Intro-found: 1
Reference: [Bea87] <author> J. Banerjee and et al. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM TOOIS, </journal> <volume> 1(5), </volume> <year> 1987. </year>
Reference-contexts: In order to effectively combine these primitives and to be able to perform arbitrary transformations on objects within a complex schema operation, we recognize the need of a language that allows such expressibility. Unlike previous research which resorted to the use of a programming language <ref> [Tec94, Bea87] </ref>, for this purpose, we now propose the use of a standard query language like OQL [Cea97]. OQL has been designed as a declarative language which 1 is powerful yet simple to use and understand. <p> OQL can query over these MetaObject and Property objects to gather system informations for use in the transformations. 15 5.4 Schema Evolution Primitive Module Heavily borrowing from the most commonly cited schema evolution taxonomy <ref> [Bea87, BKKK87] </ref>, we have developed our own taxonomy of schema evolution primitives.
Reference: [Ber92] <author> E. Bertino. </author> <title> A View Mechanism for Object-Oriented Databases. </title> <booktitle> In 3rd Int. Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views <ref> [RRL97, RR95, RR97, Ber92] </ref> and versions [SZ86, Lau97b]. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [BKKK87] <author> J. Banerjee, W. Kim, H.J. Kim, and H.F. Korth. </author> <title> Semantics and Implementation of Schema Evolution in Object-Oriented Databases. </title> <booktitle> In ACM SIGMOD Record, </booktitle> <pages> pages 311-322, </pages> <year> 1987. </year>
Reference-contexts: These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. The existing support for schema evolution provided by current OODBs <ref> [BKKK87, Tec94, BOS91, IS93, Inc93] </ref> is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96]. <p> One key issue in schema evolution is understanding the different ways of changing a schema. The first taxonomy of primitive schema evolution operations was defined by Banerjee et al. <ref> [BKKK87] </ref>. They defined consistency and correctness of these primitives in the context of the 1 PSE is registered trademark of Object Design Inc. 2 Orion system. <p> Also for object changes, the user is limited to using the object migration functions written in the programming language of O 2 . In summary, all previous research in this area tends to provide the users with a fixed set of schema evolution operations <ref> [FFM + 95, BKKK87] </ref>. No provision is made for the situation where this does not meet the user's specific needs. How to add extensibility to schema evolution is now the focus of our effort. <p> It can be used to express different semantics for primitives as well as to create new schema evolution operations. 4 By complete we mean a complete set of schema evolution primitives as defined by Banerjee et al. <ref> [BKKK87] </ref> in terms of achieving all possible basic types of schema graph manipulations. 6 We illustrate the steps involved in a transformation by using an example. We use the example of inlining which is defined as the replacement of a referenced type with its type definition [Ler96]. <p> An important property imposed on schema operations is thus that their application always results in a consistent new schema <ref> [BKKK87] </ref>. The consistency of a schema is defined by a set of so called schema invariants of each given object data model [Bre96] 6 . So it follows that similar to schema evolution primitives, the templates must also preserve the invariants described for an OODB. <p> template statements ::= template statement j template statement template statements template statement ::= define query j query define query ::= define identifier as query 6 While the invariants proposed in the literature are largely very similar, there are some slight differences based on the underlying object model of the OODB <ref> [Zic91, BKKK87] </ref>. <p> OQL can query over these MetaObject and Property objects to gather system informations for use in the transformations. 15 5.4 Schema Evolution Primitive Module Heavily borrowing from the most commonly cited schema evolution taxonomy <ref> [Bea87, BKKK87] </ref>, we have developed our own taxonomy of schema evolution primitives. <p> For instance, we have replaced the primitive drop-class defined by Orion <ref> [BKKK87] </ref> with destroy-leaf-class which removes a leaf class that has no local attributes. One reason for this is that the drop-leaf-class is not as simple as possible since the former behavior can be realized by composing the delete-attribute for all locally defined attributes followed by destroy-leaf-class.
Reference: [BOS91] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The Gemstone Object Database Management System. </title> <journal> Communications of the ACM, </journal> <volume> 10(1) </volume> <pages> 64-77, </pages> <year> 1991. </year>
Reference-contexts: These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. The existing support for schema evolution provided by current OODBs <ref> [BKKK87, Tec94, BOS91, IS93, Inc93] </ref> is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96]. <p> More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology <ref> [KGBW90, Tec94, BOS91, IS93, Inc93] </ref>. In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes [Bre96, Ler96]. <p> They defined consistency and correctness of these primitives in the context of the 1 PSE is registered trademark of Object Design Inc. 2 Orion system. Until now, current commercial OODBs such as Itasca [IS93], GemStone <ref> [BOS91] </ref>, ObjectStore [Inc93], and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's.
Reference: [Bre96] <author> Philippe Breche. </author> <title> Advanced Primitives for Changing Schemas of Object Databases. </title> <booktitle> In CAISE, </booktitle> <year> 1996. </year>
Reference-contexts: The existing support for schema evolution provided by current OODBs [BKKK87, Tec94, BOS91, IS93, Inc93] is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications <ref> [Bre96] </ref>. More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology [KGBW90, Tec94, BOS91, IS93, Inc93]. <p> In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes <ref> [Bre96, Ler96] </ref>. However, this new work is again limited by providing a fixed set of some selected now more complex operations. <p> Until now, current commercial OODBs such as Itasca [IS93], GemStone [BOS91], ObjectStore [Inc93], and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's. In recent years, the advent of more advanced applications has led to the need for support of complex schema evolution operations. <ref> [Bre96, Ler96, Cla92] </ref> have investigated the issue of more complex operations. [Ler96] has introduced compound type changes in a software environment, i.e., focusing on the type and not on the object instance changes. <p> She provides compound type changes like Inline, Encapsulate, Merge, Move, Duplicate, Reverse Link and Link Addition. <ref> [Bre96] </ref> proposed a similar list of complex evolution operations for O 2 , i.e., now considering both schema as well as object changes. [Bre96] claims that these advanced primitives can be formulated by composing the basic primitives that are provided by the O 2 system. <p> She provides compound type changes like Inline, Encapsulate, Merge, Move, Duplicate, Reverse Link and Link Addition. <ref> [Bre96] </ref> proposed a similar list of complex evolution operations for O 2 , i.e., now considering both schema as well as object changes. [Bre96] claims that these advanced primitives can be formulated by composing the basic primitives that are provided by the O 2 system. He shows the consistency of these advanced primitives. <p> In particular, our goal is to instead support arbitrary user-customized and possibly very complex schema evolution operations. Similar to <ref> [Bre96] </ref>, our first step in this direction is to allow users to build other schema transformations with different semantics using the set of schema evolution primitives provided by the underlying OODB system. <p> An important property imposed on schema operations is thus that their application always results in a consistent new schema [BKKK87]. The consistency of a schema is defined by a set of so called schema invariants of each given object data model <ref> [Bre96] </ref> 6 . So it follows that similar to schema evolution primitives, the templates must also preserve the invariants described for an OODB. This leads to the following axiom. Axiom 1 The schema invariants define the schema consistency for a given object model. <p> Rather than attempting a formal assessment of the appropriateness and sufficiency of OQL, we have conducted a comprehensive case study by examining all complex schema evolution transformations that are supported in current OODBs [FFM + 95] or proposed in the literature <ref> [Bre96, Ler96] </ref>. For each, we demonstrate that our framework can be used to achieve the desired transformation. The reader is referred to [Jin98] for a complete listing of these transformations.
Reference: [Bri97] <author> Patrick O. Brien. </author> <title> Making java objects persistent. Java Report, </title> (1):49-60, 1997. 
Reference-contexts: For details on PSE, we refer the user to <ref> [Bri97] </ref>. PSE offers very limited capabilities from the point of view of a database, for example it provides transactions and persistence by reachability, 11 , but it does not provide access to the metadata or any schema evolution facilities, nor does it have support for a query language.
Reference: [Cea97] <author> R.G.G. Cattell and et al. </author> <title> The Object Database Standard: ODMG 2.0. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction With current database technology, object-oriented database systems (OODBs) can support very complex object models like the ODMG object model <ref> [Cea97] </ref>. These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. <p> Unlike previous research which resorted to the use of a programming language [Tec94, Bea87], for this purpose, we now propose the use of a standard query language like OQL <ref> [Cea97] </ref>. OQL has been designed as a declarative language which 1 is powerful yet simple to use and understand. It is a superset of the standard SQL and as such is powerful enough to specify queries that move objects from any one or more types to any different type. <p> We use ODI's persistent storage engine (PSE 1 ) as our persistent system for our OQL-SERF system. In order to make it compliant with the ODMG standard we have built our own metadata repository in PSE <ref> [Cea97] </ref>. The rest of the paper is organized as follows. Section 2 talks about related research. Section 3 details our framework and Section 4 shows how the consistency of a schema is preserved by a template. In Section 5 we present an implementation of our framework. <p> This has the drawback of being both programming language and system dependent and also of not having any guarantee of schema consistency. In our framework, we therefore advocate the use of a declarative query language like OQL <ref> [Cea97] </ref> as ideally suited to meet the needs of our transformation language. The query language must have an interface for invoking the schema evolution primitives, as those provide the basic mechanism to syntactically change the type structure. <p> Most OODB systems indeed allow access to the meta data, i.e., the data dictionary. ODMG, who refers to this metadata as the ODL Schema Repository, explicitly states that this Repository should be accessible to tools and applications using the same operations that apply to the user-defined types <ref> [Cea97] </ref>. This implies that the metadata must be accessible through OQL. Thus our framework fits very nicely with any OODB system that is ODMG compliant. * Taxonomy of schema evolution primitives. The OODB needs to provide a set of schema evolution primitives that is complete 4 and consistent. <p> OQL-SERF prototype is fully based on the ODMG standard. In particular, we have used Java's binding of the ODMG object model, OQL as the query language, and we have built our own binding of the ODMG Schema Repository using Java <ref> [Cea97] </ref>. <p> Here we give a very brief description of the ODMG object model. For further details the reader is pointed to <ref> [Cea97] </ref>. Let O be an infinite set of object instances. Each object obj 2 O consists of state (the properties, i.e., attributes and relationships 9 ), behavior (the set of operations that can be executed on or by the object) and a unique object identifier. <p> It is also used by the OODB at runtime to guide its access to the database <ref> [Cea97] </ref>. In our prototype we term this as the meta space/ system space. Figure 8 shows our binding to the ODMG specification for the schema repository. There are three kinds of system classes, i.e., called the MetaSchema, MetaObject and Property. <p> Another advantage of this is the user is free to decide the fate of the classes that inherit from it. A complete taxonomy of our primitives and more implementation details appear in [Jin98]. 5.5 OQL Module OQL is a standard object-oriented query language which supports the ODMG 2.0 <ref> [Cea97] </ref>. It provides us with declarative access to the underlying objects and the functional property to invoke methods or functions defined on the objects. OQL which supports ODMG 2.0 [Cea97] is a complete, typed and functional language and has the following features: * standard: based on ODMG 2.0 Object Model [Cea97], <p> more implementation details appear in [Jin98]. 5.5 OQL Module OQL is a standard object-oriented query language which supports the ODMG 2.0 <ref> [Cea97] </ref>. It provides us with declarative access to the underlying objects and the functional property to invoke methods or functions defined on the objects. OQL which supports ODMG 2.0 [Cea97] is a complete, typed and functional language and has the following features: * standard: based on ODMG 2.0 Object Model [Cea97], OQL is a standard query language. <p> <ref> [Cea97] </ref>. It provides us with declarative access to the underlying objects and the functional property to invoke methods or functions defined on the objects. OQL which supports ODMG 2.0 [Cea97] is a complete, typed and functional language and has the following features: * standard: based on ODMG 2.0 Object Model [Cea97], OQL is a standard query language. <p> These data manipulation methods include constructing a new object of a given type, setting an attribute's value, and copying data values from one attribute to another. * expressiveness: whether OQL is able to express "any" or at least a wide range of schema evolution transformations. Based on ODMG 2.0 <ref> [Cea97] </ref>, the object query language is a functional language where operators can freely be composed and operations defined on the objects can be invoked as well.
Reference: [Cla92] <author> S.M. Clamen. </author> <title> Type Evolution and Instance Adaptation. </title> <type> Technical Report CMU-CS-92-133R, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Until now, current commercial OODBs such as Itasca [IS93], GemStone [BOS91], ObjectStore [Inc93], and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's. In recent years, the advent of more advanced applications has led to the need for support of complex schema evolution operations. <ref> [Bre96, Ler96, Cla92] </ref> have investigated the issue of more complex operations. [Ler96] has introduced compound type changes in a software environment, i.e., focusing on the type and not on the object instance changes.
Reference: [FFM + 95] <author> F. Ferrandina, G. Ferran, T. Meyer, J. Madec, and R. Zicari. </author> <title> Schema and Database Evolution in the O 2 Object Database System. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <year> 1995. </year>
Reference-contexts: Also for object changes, the user is limited to using the object migration functions written in the programming language of O 2 . In summary, all previous research in this area tends to provide the users with a fixed set of schema evolution operations <ref> [FFM + 95, BKKK87] </ref>. No provision is made for the situation where this does not meet the user's specific needs. How to add extensibility to schema evolution is now the focus of our effort. <p> Rather than attempting a formal assessment of the appropriateness and sufficiency of OQL, we have conducted a comprehensive case study by examining all complex schema evolution transformations that are supported in current OODBs <ref> [FFM + 95] </ref> or proposed in the literature [Bre96, Ler96]. For each, we demonstrate that our framework can be used to achieve the desired transformation. The reader is referred to [Jin98] for a complete listing of these transformations.
Reference: [FMZ94a] <author> F. Ferrandina, T. Meyer, and R. Zicari. </author> <title> Correctness of Lazy Database Updates for an Object Database System. </title> <booktitle> In Proc. of the 6th Int'l Workshop on Persistent Object Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Research on this issue has focused on providing mechanisms to make data and the system itself more available during the schema evolution process [Lau97a], in particular deferred and immediate propagation strategies <ref> [FMZ94b, FMZ94a] </ref>. In principle, either of these propagation strategies could be implemented for our framework. Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements.
Reference: [FMZ94b] <author> F. Ferrandina, T. Meyer, and R. Zicari. </author> <title> Implementing Lazy Database Updates for an Object Database System. </title> <booktitle> In Proc. of the 20th Int'l Conf. on Very Large Databases, </booktitle> <pages> pages 261-272, </pages> <year> 1994. </year>
Reference-contexts: Research on this issue has focused on providing mechanisms to make data and the system itself more available during the schema evolution process [Lau97a], in particular deferred and immediate propagation strategies <ref> [FMZ94b, FMZ94a] </ref>. In principle, either of these propagation strategies could be implemented for our framework. Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements.
Reference: [Inc93] <author> Object Design Inc. </author> <title> ObjectStore User Guide: DML. ObjectStore Release 3.0 for UNIX Systems. Object Design Inc., </title> <month> December </month> <year> 1993. </year>
Reference-contexts: These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. The existing support for schema evolution provided by current OODBs <ref> [BKKK87, Tec94, BOS91, IS93, Inc93] </ref> is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96]. <p> More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology <ref> [KGBW90, Tec94, BOS91, IS93, Inc93] </ref>. In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes [Bre96, Ler96]. <p> They defined consistency and correctness of these primitives in the context of the 1 PSE is registered trademark of Object Design Inc. 2 Orion system. Until now, current commercial OODBs such as Itasca [IS93], GemStone [BOS91], ObjectStore <ref> [Inc93] </ref>, and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's.
Reference: [IS93] <author> Inc. </author> <title> Itasca Systems. </title> <type> Itasca Systems Technical Report. Technical Report TM-92-001, </type> <institution> OODBMS Feature Checklist. Rev 1.1, Itasca Systems, Inc., </institution> <month> December </month> <year> 1993. </year> <month> 19 </month>
Reference-contexts: These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. The existing support for schema evolution provided by current OODBs <ref> [BKKK87, Tec94, BOS91, IS93, Inc93] </ref> is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96]. <p> More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology <ref> [KGBW90, Tec94, BOS91, IS93, Inc93] </ref>. In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes [Bre96, Ler96]. <p> The first taxonomy of primitive schema evolution operations was defined by Banerjee et al. [BKKK87]. They defined consistency and correctness of these primitives in the context of the 1 PSE is registered trademark of Object Design Inc. 2 Orion system. Until now, current commercial OODBs such as Itasca <ref> [IS93] </ref>, GemStone [BOS91], ObjectStore [Inc93], and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's.
Reference: [Jin98] <author> Jing Jin. </author> <title> An extensible schema evolution framework for object-oriented databases using OQL. </title> <type> Master's thesis, </type> <institution> Worcester Polytechnic Institute, </institution> <month> May </month> <year> 1998. </year>
Reference-contexts: Another advantage of this is the user is free to decide the fate of the classes that inherit from it. A complete taxonomy of our primitives and more implementation details appear in <ref> [Jin98] </ref>. 5.5 OQL Module OQL is a standard object-oriented query language which supports the ODMG 2.0 [Cea97]. It provides us with declarative access to the underlying objects and the functional property to invoke methods or functions defined on the objects. <p> For each, we demonstrate that our framework can be used to achieve the desired transformation. The reader is referred to <ref> [Jin98] </ref> for a complete listing of these transformations. For our implementation, since PSE does not have any support for OQL, we have built our own support for OQL on top of PSE. [Jin98] gives details on the implementation. 5.6 Template Module Through an interface to the template module, the user can <p> The reader is referred to <ref> [Jin98] </ref> for a complete listing of these transformations. For our implementation, since PSE does not have any support for OQL, we have built our own support for OQL on top of PSE. [Jin98] gives details on the implementation. 5.6 Template Module Through an interface to the template module, the user can create new templates, search the library for existing templates, edit and delete templates. When a template is created, the user can assign a name to it and also specify its parameters. <p> We have also presented an implementation of this template-based framework. We have used the ODMG standard as the foundation for this implementation. As part of this work we have also devised our own taxonomy of schema evolution primitives and in <ref> [Jin98] </ref> have formally shown this to be a minimally complete set. <p> Due to space restrictions, this case study is not included here but can be found in <ref> [Jin98] </ref>. We are in the process of finishing our prototype. In the future, we plan to develop tools that assist with the maintainance, search and consistency checking of templates. Acknowledgments.
Reference: [KGBW90] <author> W. Kim, J.F. Garza, N. Ballou, and D. Woelk. </author> <title> Architecture of the ORION Next-Generation Database System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <year> 1990. </year>
Reference-contexts: More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology <ref> [KGBW90, Tec94, BOS91, IS93, Inc93] </ref>. In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes [Bre96, Ler96].
Reference: [Lau97a] <author> Sven-Eric Lautemann. </author> <title> A Propagation Mechanism for Populated Schema Versions. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 67-78, </pages> <year> 1997. </year>
Reference-contexts: Research on this issue has focused on providing mechanisms to make data and the system itself more available during the schema evolution process <ref> [Lau97a] </ref>, in particular deferred and immediate propagation strategies [FMZ94b, FMZ94a]. In principle, either of these propagation strategies could be implemented for our framework.
Reference: [Lau97b] <author> Sven-Eric Lautemann. </author> <title> Schema Versions in Object-Oriented Database Systems. </title> <booktitle> In International Conference on Database Systems for Advanced Applications (DASFAA), </booktitle> <pages> pages 323-332, </pages> <year> 1997. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views [RRL97, RR95, RR97, Ber92] and versions <ref> [SZ86, Lau97b] </ref>. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [Ler96] <author> B.S. Lerner. </author> <title> A Model for Compound Type Changes Encountered in Schema Evolution. </title> <type> Technical Report UM-CS-96-044, </type> <institution> University of Massachusetts, Amherst, Computer Science Department, </institution> <year> 1996. </year>
Reference-contexts: In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes <ref> [Bre96, Ler96] </ref>. However, this new work is again limited by providing a fixed set of some selected now more complex operations. <p> Until now, current commercial OODBs such as Itasca [IS93], GemStone [BOS91], ObjectStore [Inc93], and O 2 [Tec94] all essentially handle a set of evolution primitives similar to Orion's. In recent years, the advent of more advanced applications has led to the need for support of complex schema evolution operations. <ref> [Bre96, Ler96, Cla92] </ref> have investigated the issue of more complex operations. [Ler96] has introduced compound type changes in a software environment, i.e., focusing on the type and not on the object instance changes. <p> In recent years, the advent of more advanced applications has led to the need for support of complex schema evolution operations. [Bre96, Ler96, Cla92] have investigated the issue of more complex operations. <ref> [Ler96] </ref> has introduced compound type changes in a software environment, i.e., focusing on the type and not on the object instance changes. <p> We use the example of inlining which is defined as the replacement of a referenced type with its type definition <ref> [Ler96] </ref>. For example, the Address type (the referenced type) are now added to the Person type resulting in a more complex Person class. Figure 3 shows the inline transformation expressed in our framework using OQL, schema primitives, and system-defined update methods. <p> Rather than attempting a formal assessment of the appropriateness and sufficiency of OQL, we have conducted a comprehensive case study by examining all complex schema evolution transformations that are supported in current OODBs [FFM + 95] or proposed in the literature <ref> [Bre96, Ler96] </ref>. For each, we demonstrate that our framework can be used to achieve the desired transformation. The reader is referred to [Jin98] for a complete listing of these transformations.
Reference: [LZS97] <author> E. A. Rundensteiner L. Zhou and K.G. Shin. </author> <title> An introduction to schema versioning in OODBMS. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 956-977, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction With current database technology, object-oriented database systems (OODBs) can support very complex object models like the ODMG object model [Cea97]. These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades <ref> [LZS97] </ref>. The existing support for schema evolution provided by current OODBs [BKKK87, Tec94, BOS91, IS93, Inc93] is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96].
Reference: [PO95] <author> Randall J. Peters and M. Tamer Ozsu. </author> <title> Axiomatization of dynamic schema evolution in object-bases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 156-164, </pages> <year> 1995. </year>
Reference-contexts: No provision is made for the situation where this does not meet the user's specific needs. How to add extensibility to schema evolution is now the focus of our effort. Peters and Ozsu <ref> [PO95] </ref> have introduced a sound and complete axiomatic model that can be used to formalize and compare schema evolution modules of OODBs.
Reference: [RR95] <author> Y. G. Ra and E. A. Rundegnsteiner. </author> <title> A Transparent Object-Oriented Schema Change Approach Using View Schema Evolution. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views <ref> [RRL97, RR95, RR97, Ber92] </ref> and versions [SZ86, Lau97b]. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [RR97] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A Transparent Schema Evolution System Based on Object-Oriented View Technology. </title> <month> September </month> <year> 1997. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views <ref> [RRL97, RR95, RR97, Ber92] </ref> and versions [SZ86, Lau97b]. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [RRL97] <author> Y.G. Ra, E. A. Rundensteiner, and A.J. Lee. </author> <title> A Practical Approach to Transparent Schema Evolution. </title> <type> Technical Report WPI-CS-TR-97-3, </type> <institution> Worcester Polytechnic Institute, Dept. of Computer Science, </institution> <year> 1997. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views <ref> [RRL97, RR95, RR97, Ber92] </ref> and versions [SZ86, Lau97b]. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [SZ86] <author> A. H. Skarra and S. B. Zdonik. </author> <title> The Management of Changing Types in an Object-Oriented Databases. </title> <booktitle> In Proc. 1st OOPSLA, </booktitle> <pages> pages 483-494, </pages> <year> 1986. </year>
Reference-contexts: Another important issue focuses on providing support for existing applications that depend on the old schema, when other applications change the shared schema according to their own requirements. Research to address this issue has followed along two possible directions, namely, views [RRL97, RR95, RR97, Ber92] and versions <ref> [SZ86, Lau97b] </ref>. Some of this on-going research may need to be re-examined in order to handle the complex notion of transformations as introduced by our templates. 3 The SERF Framework In this section we present the fundamental principles of our proposed transformation framework.
Reference: [Tec94] <institution> O 2 Technology. </institution> <note> O 2 Reference Manual, Version 4.5, Release November 1994. O 2 Technology, </note> <institution> Versailles, France, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: These complex object models have paved the road for modelling complex and dynamic applications which by their very nature have frequent schematic changes and upgrades [LZS97]. The existing support for schema evolution provided by current OODBs <ref> [BKKK87, Tec94, BOS91, IS93, Inc93] </ref> is limited to a pre-defined taxonomy of simple fixed-semantic schema evolution operations. However, such simple changes, typically to individual types only, are not sufficient for many advanced applications [Bre96]. <p> More radical changes of the schema, such as combining two types or redefining the relationship between two types, are either very difficult or even impossible to achieve with the current commercial database technology <ref> [KGBW90, Tec94, BOS91, IS93, Inc93] </ref>. In fact, most OODBs would typically require the user to write ad-hoc programs to accomplish such transformations. In the last two years, research has begun to look into this issue of complex changes [Bre96, Ler96]. <p> In order to effectively combine these primitives and to be able to perform arbitrary transformations on objects within a complex schema operation, we recognize the need of a language that allows such expressibility. Unlike previous research which resorted to the use of a programming language <ref> [Tec94, Bea87] </ref>, for this purpose, we now propose the use of a standard query language like OQL [Cea97]. OQL has been designed as a declarative language which 1 is powerful yet simple to use and understand. <p> They defined consistency and correctness of these primitives in the context of the 1 PSE is registered trademark of Object Design Inc. 2 Orion system. Until now, current commercial OODBs such as Itasca [IS93], GemStone [BOS91], ObjectStore [Inc93], and O 2 <ref> [Tec94] </ref> all essentially handle a set of evolution primitives similar to Orion's.
Reference: [Zic91] <author> Roberta Zicari. </author> <title> Primitives for schema updates in an object-oriented database system: A proposal. </title> <journal> Computer Standards & Interfaces, </journal> (12):271-284, 1991. <volume> 20 </volume>
Reference-contexts: template statements ::= template statement j template statement template statements template statement ::= define query j query define query ::= define identifier as query 6 While the invariants proposed in the literature are largely very similar, there are some slight differences based on the underlying object model of the OODB <ref> [Zic91, BKKK87] </ref>.
References-found: 26

