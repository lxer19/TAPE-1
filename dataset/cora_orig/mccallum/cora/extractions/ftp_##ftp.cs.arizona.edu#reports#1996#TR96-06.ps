URL: ftp://ftp.cs.arizona.edu/reports/1996/TR96-06.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: FTAG: A Functional and Attribute Based Model for Writing Fault-Tolerant Software  
Author: Masato Suzuki, Takuya Katayama, and Richard D. Schlichting 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Note: May  
Date: TR 96-6  21, 1996  
Abstract: Programs constructed using techniques that allow software or operational faults to be tolerated are typically written using an imperative computational model. Here, an alternative is described in which such programs are written using a functional and attribute based model called FTAG (Fault-Tolerant Attribute Grammars). The basic model is introduced first, followed by a description of mechanisms that allow a variety of standard fault-tolerance techniques to be realized in a straightforward way. Techniques that can be accommodated include replication and checkpointing to tolerate operational faults, and recovery blocks and N-version programming to tolerate software faults. Several examples are given to illustrate these techniques, including a replicated name server and a fault-tolerant sort that uses recovery blocks. A formal description of FTAG that precisely specifies the semantics of the model is also presented. Finally, a software architecture describing how FTAG can be implemented in a computer system containing multiple processors is given. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Randell, </author> <title> System structure for software fault tolerance, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-1, </volume> <pages> pp. 220-232, </pages> <month> Jun </month> <year> 1975. </year>
Reference-contexts: These include such things as recovery blocks <ref> [1] </ref> and N-version programming [2] for dealing with software faults, and checkpointing [3], atomic actions [4], and the replicated state machine approach [5] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> We assume that all failures of interest are manifested by incorrect attribute values 3 that can be tested by a conditional. Such an assumption is common for software faults <ref> [1] </ref>, while missing or incorrect attribute values caused by operational faults such as crashed processors can be translated into a distinguished value ? (bottom) that is assigned to the appropriate attributes by the underlying system. <p> The state rollback is implicit and automatic since the remaining parts of the tree contain all the input values needed to redo the calculation. To illustrate these points, we now describe how redoing can be used to implement recovery blocks, a technique used primarily to handle software faults <ref> [1] </ref>, and checkpointing, a technique used to recover from operational faults [3]. In the recovery block method, multiple implementations M 1 ; : : : ; M k are prepared for a module M .
Reference: [2] <author> A. Avizienis, </author> <title> The N-Version approach to fault-tolerant software, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-11, no. 12, </volume> <pages> pp. 1491-1501, </pages> <year> 1985. </year>
Reference-contexts: These include such things as recovery blocks [1] and N-version programming <ref> [2] </ref> for dealing with software faults, and checkpointing [3], atomic actions [4], and the replicated state machine approach [5] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> Replication. Replicating software and executing it in parallel is another standard approach to writing software that can tolerate software and/or operational faults <ref> [2, 5] </ref>. FTAG can be used to realize such replication in a straightforward and intuitive way.
Reference: [3] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: These include such things as recovery blocks [1] and N-version programming [2] for dealing with software faults, and checkpointing <ref> [3] </ref>, atomic actions [4], and the replicated state machine approach [5] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> To illustrate these points, we now describe how redoing can be used to implement recovery blocks, a technique used primarily to handle software faults [1], and checkpointing, a technique used to recover from operational faults <ref> [3] </ref>. In the recovery block method, multiple implementations M 1 ; : : : ; M k are prepared for a module M .
Reference: [4] <author> B. Liskov, </author> <title> The Argus language and system, in Distributed Systems: Methods and Tools for Specification, </title> <booktitle> Lecture Notes in Computer Science, Volume 190 (M. </booktitle> <editor> Paul and H. Siegert, eds.), ch. </editor> <volume> 7, </volume> <pages> pp. 343-430, </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: These include such things as recovery blocks [1] and N-version programming [2] for dealing with software faults, and checkpointing [3], atomic actions <ref> [4] </ref>, and the replicated state machine approach [5] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions.
Reference: [5] <author> F. Schneider, </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, </volume> <pages> pp. 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: These include such things as recovery blocks [1] and N-version programming [2] for dealing with software faults, and checkpointing [3], atomic actions [4], and the replicated state machine approach <ref> [5] </ref> for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. Despite the inherent differences in these approaches, one common thread is that they all have typically been conceived and expressed using an imperative computational model. <p> Replication. Replicating software and executing it in parallel is another standard approach to writing software that can tolerate software and/or operational faults <ref> [2, 5] </ref>. FTAG can be used to realize such replication in a straightforward and intuitive way. <p> That is, the stability of a workspace is approximated by having its values stored in the memory of multiple processors, so that they remain available as long as at least one such processor is functioning <ref> [5] </ref>. The probability of losing a value can then be reduced to something arbitarily close to zero by storing enough copies. Below, we assume that a workspace is implemented by storing two copies, one of which is the processor executing a module.
Reference: [6] <author> D. Knuth, </author> <title> Semantics of context-free languages, </title> <journal> Mathematical Systems Theory, </journal> <volume> vol. 2, no. 2, </volume> <pages> pp. 127-145, </pages> <year> 1968. </year>
Reference-contexts: In this paper, we describe FTAG (Fault-Tolerant Attribute Grammars), an alternative in which fault-tolerant software is written using a functional and attribute based model. The model is derived from an existing collection of models that use an attribute grammar formalism <ref> [6] </ref> for such diverse purposes as functional programming [7, 8], object-oriented programming [9], and modeling of the software development process [10]. This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation.
Reference: [7] <author> T. Katayama, HFP, </author> <title> a hierarchical and functional programming based on attribute grammars, </title> <booktitle> in Proceedings of the 5th Int. Conference on Software Engineering, </booktitle> <pages> pp. 343-353, </pages> <year> 1981. </year>
Reference-contexts: In this paper, we describe FTAG (Fault-Tolerant Attribute Grammars), an alternative in which fault-tolerant software is written using a functional and attribute based model. The model is derived from an existing collection of models that use an attribute grammar formalism [6] for such diverse purposes as functional programming <ref> [7, 8] </ref>, object-oriented programming [9], and modeling of the software development process [10]. This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. <p> The model is based on the HFP (Hierarchical and Functional Process) model <ref> [7] </ref>, which is in turn derived from attribute grammars. The basics of the model are outlined first, followed by a description of facilities for fault-tolerant software.
Reference: [8] <author> Y. Shinoda and T. Katayama, </author> <title> Attribute grammar based programming and its environment, </title> <booktitle> in Proceedings of the 21st Hawaii Int. Conf. on System Sciences, (Kailu-Kona), </booktitle> <pages> pp. 612-620, </pages> <month> Jan </month> <year> 1988. </year>
Reference-contexts: In this paper, we describe FTAG (Fault-Tolerant Attribute Grammars), an alternative in which fault-tolerant software is written using a functional and attribute based model. The model is derived from an existing collection of models that use an attribute grammar formalism [6] for such diverse purposes as functional programming <ref> [7, 8] </ref>, object-oriented programming [9], and modeling of the software development process [10]. This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation.
Reference: [9] <author> Y. Shinoda and T. Katayama, OOAG: </author> <title> An object-oriented extension of attribute grammar and its implementation using distributed attribute evaluation algorithm, </title> <booktitle> in Proceedings of WAGA Int. Workshop on Attribute Grammar and its Application, </booktitle> <volume> vol. 461, </volume> <pages> pp. 177-191, </pages> <publisher> LNCS Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The model is derived from an existing collection of models that use an attribute grammar formalism [6] for such diverse purposes as functional programming [7, 8], object-oriented programming <ref> [9] </ref>, and modeling of the software development process [10]. This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation.
Reference: [10] <author> T. Katayama, </author> <title> A hierarchical and functional software process description and its enaction, </title> <booktitle> in Proceedings of the 11th Int. Conf. on Software Engineering, </booktitle> <pages> pp. 343-352, </pages> <year> 1989. </year> <month> 21 </month>
Reference-contexts: The model is derived from an existing collection of models that use an attribute grammar formalism [6] for such diverse purposes as functional programming [7, 8], object-oriented programming [9], and modeling of the software development process <ref> [10] </ref>. This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation.
Reference: [11] <author> A. Bondavalli and L. Simoncini, </author> <title> Functional paradigm for designing dependable large-scale parallel computing systems, </title> <booktitle> in Proceedings of the Distributed Computing Systems, </booktitle> <pages> pp. 108-114, </pages> <year> 1993. </year>
Reference-contexts: This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. Others have also recognized the attraction of a functional model for this type of programming <ref> [11, 12, 13, 14] </ref>, although FTAG differs in how it provides support for fault tolerance and in its use of an attribute grammar formalism. This paper is organized as follows. <p> The possibility of incorrect values can be dealt with by issuing the value request multiple times and then using a collation function on the results. The advantages of referential transparency and composability for fault-tolerant parallel computing are also discussed in <ref> [11] </ref>. In that paper, a functional language and dataflow computing model for designing large-scale parallel computations are described. Redundancy schemes such as recovery blocks and N-version programming are then used as illustrative examples of how fault tolerance can be programmed using this approach. <p> For example, FTAG supports the handling of both software and operational failures within a single framework, whereas each of the others only handles one or the other. Also, when compared with <ref> [11] </ref>, FTAG promotes a more dynamic approach to failure handling since recovery procedures can be created incrementally at runtime, rather than being constrained to a static approach.
Reference: [12] <author> D. Grit, </author> <title> Towards fault tolerance in a distributed applicative multiprocessor, </title> <booktitle> in Proceedings of the 14th Symposium on Fault-Tolerant Computing, </booktitle> <address> (Orlando, FL), </address> <pages> pp. 272-277, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. Others have also recognized the attraction of a functional model for this type of programming <ref> [11, 12, 13, 14] </ref>, although FTAG differs in how it provides support for fault tolerance and in its use of an attribute grammar formalism. This paper is organized as follows.
Reference: [13] <author> R. Harper, , G. Nagle, and M. Serrano, </author> <title> Use of a functional programming model for fault tolerant parallel programming, </title> <booktitle> in Proceedings of the 19th Symposium on Fault-Tolerant Computing, </booktitle> <address> (Chicago, IL), </address> <pages> pp. 20-26, </pages> <month> Jun </month> <year> 1989. </year>
Reference-contexts: This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. Others have also recognized the attraction of a functional model for this type of programming <ref> [11, 12, 13, 14] </ref>, although FTAG differs in how it provides support for fault tolerance and in its use of an attribute grammar formalism. This paper is organized as follows. <p> Related work. Other researchers have also explored functional approaches to implementing fault tolerance in various situations. In <ref> [13] </ref>, a functional model is proposed as a means for implicitly implementing graceful degradation when processors fail in the custom Fault Tolerant Parallel Processor (FTPP) developed at Draper Labs. <p> In addition, unlike the other approaches, FTAG derives benefits from being based on attribute grammars, as well as from the functional aspect of the approach. Another difference is that both <ref> [13] </ref> and [14] provide fault tolerance implicitlyessentially, every module is treated as a checkpoint module using our terminologywhereas FTAG provides mechanisms such as redoing and replicated decomposition that the programmer can use to implement common fault-tolerance paradigms easily.
Reference: [14] <author> R. Jagannathan and E. Ashcroft, </author> <title> Fault tolerance in parallel implementations of functional languages, </title> <booktitle> in Proceedings of the 21st Symposium on Fault Tolerant Computing, </booktitle> <address> (Montreal, Canada), </address> <pages> pp. 256-263, </pages> <month> Jun </month> <year> 1991. </year>
Reference-contexts: This approach offers several advantages, including a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. Others have also recognized the attraction of a functional model for this type of programming <ref> [11, 12, 13, 14] </ref>, although FTAG differs in how it provides support for fault tolerance and in its use of an attribute grammar formalism. This paper is organized as follows. <p> The functional nature of the module ensures that the results will be the same as the original execution. A functional approach for implicit application-transparent fault tolerance is presented in <ref> [14] </ref>. The emphasis in this work is on dealing with operational faults using an intensional model in which an implicit context is associated with each value computed by the program. <p> In addition, unlike the other approaches, FTAG derives benefits from being based on attribute grammars, as well as from the functional aspect of the approach. Another difference is that both [13] and <ref> [14] </ref> provide fault tolerance implicitlyessentially, every module is treated as a checkpoint module using our terminologywhereas FTAG provides mechanisms such as redoing and replicated decomposition that the programmer can use to implement common fault-tolerance paradigms easily.
Reference: [15] <author> M. Suzuki, A. Iwai, and T. Katayama, </author> <title> A formal model of re-exection in software process, </title> <booktitle> in Proceedings of the 2nd Int. Conf. on Software Process, </booktitle> <address> (Berlin, Germany), </address> <pages> pp. 84-99, </pages> <month> Feb </month> <year> 1993. </year>
Reference-contexts: This paper is organized as follows. An introduction of FTAG is given in section 2, with the basic model being described first, followed by features like redoing <ref> [15] </ref> and replication that provide the fundamental basis for implementing recovery, N-version programming, and similar mechanisms.
Reference: [16] <author> M. Suzuki, T. Katayama, and R. D. Schlichting, </author> <title> Implementing fault-tolerance with an attribute and functional based model, </title> <booktitle> in Proceedings of the 24th Symposium on Fault-Tolerant Computing, </booktitle> <address> (Austin, TX), </address> <pages> pp. 244-253, </pages> <month> Jun </month> <year> 1994. </year>
Reference-contexts: Finally, section 6 discusses the advantages of the approach and related work, while section 7 contains conclusions and directions for future work. 2 An Overview of the FTAG Computational Model In this section, we summarize the FTAG computational model introduced in <ref> [16] </ref>. The model is based on the HFP (Hierarchical and Functional Process) model [7], which is in turn derived from attribute grammars. The basics of the model are outlined first, followed by a description of facilities for fault-tolerant software. <p> In this case, for example, p 0 multicasts the inherited attribute x to processors p 1 ; : : : ; p k . Upon receipt, each processor starts its computation using the value. This type of multicast mechanism is useful for managing both fail-stop and Byzantine failures <ref> [16] </ref>. In the case of fail-stop, all processors that generate results are considered to be working correctly. Thus, when one, say p 1 , finishes its computation, it sends the result y, which is used immediately.
Reference: [17] <author> M. Suzuki, T. Katayama, and R. D. Schlichting, </author> <title> A functional and attribute based computational model for fault-tolerant software, </title> <type> Tech. Rep. TR 93-8, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1993. </year>
Reference-contexts: Stable Object Access. Attribute values in this model are either stored in primary memory or in a stable object base depending on whether or not they might be needed after a failure <ref> [17] </ref>. Certain activities such as redoing are also facilitated if attribute values in the object base that would normally be overwritten are retained instead. <p> The decomposition is performed by the function Grow or Growiter, with attributes being calculated by Calculate or Calculateiter depending on the structure of decomposition. For details of these functions, see <ref> [17] </ref>. Execution Sequence. The program is executed by repeated applications of Exec, starting with an initial tree containing only a root node.
Reference: [18] <author> B. Lampson, </author> <title> Atomic transactions, </title> <booktitle> in Distributed SystemsArchitecture and Implementation, </booktitle> <pages> pp. 246-265, </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <month> 22 </month>
Reference-contexts: Hence, M 21 can be made a restartable action <ref> [18] </ref> as follows by having M 22 check its input attribute and redo M 2 should it have the value ?.
References-found: 18

