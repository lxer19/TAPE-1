URL: ftp://st.cs.uiuc.edu/pub/patterns/papers/mirror/plop94.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/patterns/papers/
Root-URL: http://www.cs.uiuc.edu
Email: Email: famund,gelia,mengag@polito.it  
Phone: ph. +39-11-564-(7012), fax (7099)  
Title: G++: A Pattern Language for the Object Oriented Design of Concurrent and Distributed Information Systems,
Author: Amund Aarsten, Gabriele Elia, Giuseppe Menga 
Note: The objective of this  This work has been supported by CNR under grant n. 92.01602.PF69 Progetto Finalizzato  Parallelo, grant n. 91.01940.PF67 Progetto Finalizzato Robotica and by the Chamber of Commerce of Turin Standards in CIM  
Address: Corso Duca degli Abruzzi n. 24 10129 Torino Italy  
Affiliation: Dept. of Automatica e Informatica Politecnico di Torino  Sistemi Informatici e Calcolo  
Abstract: This paper presents G++, an object oriented framework of reusable classes and a methodology for developing of distributed information systems. G++ is presented as a set of "design patterns" structured to form a "pattern language". Following the intuitions of the architect Christopher Alexander, a design has been considered formed by "patterns" of relationships between elements, where each pattern is by itself a rule to enable a design choice from a problem requirement. Indeed, these patterns always come from a language: a "pattern language ", with which a certain class of problems can be approached. These ideas have been transferred to the field of object oriented design, where elements are objects and "patterns" indicate clusters of cooperating objects linked by certain relationships that can repeatedly be found in the solution of a class of problems; this allows us to call G++ a pattern language, that is, patterns are ordered and structured in such a way to help the designer in his/her decision and to manage at the proper moment the different issues which he/she encounters. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Alexander. </author> <title> A Pattern Language: Towns, Buildings, Construction. </title> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: It is general opinion, in fact, that designers have always been driven by personal "patterns" when making choices. The architect Christopher Alexander <ref> [1, 2] </ref> has pursued this idea further. Alexander suggests that each "design" pattern : : : is a three-part rule, which expresses a relation between a certain context, a design problem and a solution.
Reference: [2] <author> C. Alexander. </author> <title> The Timeless Way of Building. </title> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: It is general opinion, in fact, that designers have always been driven by personal "patterns" when making choices. The architect Christopher Alexander <ref> [1, 2] </ref> has pursued this idea further. Alexander suggests that each "design" pattern : : : is a three-part rule, which expresses a relation between a certain context, a design problem and a solution.
Reference: [3] <author> G.R. Andrews, F.B. Schneider. </author> <title> Concepts and Notations for Concurrent Programming. </title> <journal> ACM Computer Surveys, </journal> <volume> vol. 15, </volume> <editor> n. </editor> <volume> 1, </volume> <month> March </month> <year> 1983, </year> <pages> pp. 3-43. 17 </pages>
Reference-contexts: CondCollection) can be derived by inheritance or encapsulation (see figure 6). Conditions, as a way of synchronizing threads, are discussed in <ref> [3] </ref>. Example: Blocking Objects in the FMS Cell In the FMS example, there are different blocking objects (see figure 5): * the storeIn and storeOut buffers are CondCltn, belonging to the MachiningCell class.
Reference: [4] <author> G.R. Andrews. </author> <title> An Overview of the SR Language and Implementation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 51-86, </pages> <year> 1988. </year>
Reference-contexts: Finally, modules of control should have the capability to encapsulate the resources and the services that manipulate them. 9 Solution These requirements are satisfied by the the Client/Server/Service model proposed in this pattern and derived by the programming paradigm of SR <ref> [4] </ref>. Two classes are needed to support it: the Service and the Server (see figure 7).
Reference: [5] <author> K. Beck and R. Johnson. </author> <title> Patterns generate architecture. </title> <booktitle> in ECOOP'94 Conference Proceedings, </booktitle> <address> Bologna, Italy July 1994. </address>
Reference-contexts: The template used to describe an OO pattern in inspired by the proposal of in literature <ref> [15, 10, 5, 16] </ref>, by the discussions on the "pattern mailing list" and by the works of Alexander himself and has the following fields: the pattern name; the context in which we have to discuss the pattern; the problems which the pattern addresses, related with the context; the solution offered by
Reference: [6] <author> B. W. Boehm. </author> <title> A Spiral Model of Software Development and Enhancement IEEE Computer, </title> <month> May </month> <year> 1988. </year>
Reference: [7] <author> G. Booch. </author> <title> Object-Oriented Design with Applications Benjamin/Cummings, </title> <year> 1991. </year>
Reference-contexts: 1 A lot is an administrative entity, representing a group of identical pieces manufactured together. 2 development process is evolutionary, and it is obtained by exploiting transformations which first map the analysis into a logical design to be locally prototyped, and then map the logical design into a physical design <ref> [7] </ref>. Patterns in this language are structured, following Alexander, as in the tree shown in figure 1; each oval denotes a pattern with arcs representing the relationship between larger and smaller patterns. <p> Context Complex system are developed during a relatively long period of time. Two possibilities are available: the first is building modules that will be plugged in pre-existing designs, the second is building "frameworks" that have to integrate preexisting control modules; in the former case, modules are build having "visibility" <ref> [7] </ref> of the environment in which they will operate, while in the latter this does not happen. In CIM systems the evolution is bottom-up.
Reference: [8] <author> R. S. Chin and S. T. Chanson. </author> <title> Distributed object-based programming system. </title> <journal> ACM Computing Surveys, </journal> <volume> 23 </volume> <pages> 91-124, </pages> <month> March </month> <year> 1991. </year>
Reference: [9] <author> D. Decouchant. </author> <title> Design of a distributed object manager for the Smalltalk-80 system. </title> <booktitle> OOPSLA'86 Proceedings, </booktitle> <pages> pp. 444-451. </pages>
Reference-contexts: Related Patterns This pattern follows the trend among C++ designers to separate an object definition into two distinct interface and implementation classes. The interface class is called a handle in [24] and proxy in <ref> [9] </ref>. It also corresponds to the Proxy of [10]. The switch from prototype to reality, as described by pattern 9, is usually enabled by the use of this pattern.
Reference: [10] <author> E. Gamma, R. Helm, R. Johnson, J. Vlissdes. </author> <title> Design Patterns: Abstraction and Reuse of Object Oriented Design. </title> <booktitle> In ECOOP '93 Conference Proceedings, </booktitle> <address> Kaiserlautern, Germany, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The template used to describe an OO pattern in inspired by the proposal of in literature <ref> [15, 10, 5, 16] </ref>, by the discussions on the "pattern mailing list" and by the works of Alexander himself and has the following fields: the pattern name; the context in which we have to discuss the pattern; the problems which the pattern addresses, related with the context; the solution offered by <p> Related Patterns This pattern follows the trend among C++ designers to separate an object definition into two distinct interface and implementation classes. The interface class is called a handle in [24] and proxy in [9]. It also corresponds to the Proxy of <ref> [10] </ref>. The switch from prototype to reality, as described by pattern 9, is usually enabled by the use of this pattern. Pattern 9 : Prototype and Reality Any complex application requires prototyping and simulation of the different elements which have to be integrated before an implementation is derived.
Reference: [11] <author> P.B. Gibbson. </author> <title> A Stub Generator for Multilanguage RPC in Heterogeneous Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 77-87, </pages> <month> January </month> <year> 1987. </year>
Reference: [12] <author> A. Goldberg and D. Robson. Smalltalk80: </author> <title> The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: between objects, here called caller/provider (C/P) and broadcaster/listeners (B/L) and described in figure 4. * The C/P mechanism is involved when an object invokes another object method and is deeply rooted in OO programming, so it will not be discussed further. * The B/L mechanism (Smalltalk dependencies, and X-Window callbacks) <ref> [12, 25] </ref> is achieved by giving all the objects of the framework the capability of broadcasting and listening to events.
Reference: [13] <author> R. Halstead, </author> <title> Multilisp: A language for concurrent symbolic computation ACM Transactions on Programming Languages and Systems, </title> <journal> vol.4, </journal> <volume> no 4, </volume> <month> October </month> <year> 1985. </year>
Reference: [14] <author> G.M. Htydalsvik and G. Sindre. </author> <title> On the purpose of Object Oriented Analysis. </title> <booktitle> OOPSLA'93 Proceedings, </booktitle> <address> Washington, D.C. </address> <month> September </month> <year> 1993 </year>
Reference-contexts: This has been made possible thanks to unambiguous rules which reduce the semantics gap between the problem and the software architecture. In fact patterns, as a media in which analysis evolves into design, are an answer to the problems of the seamless transition from analysis to design raised in <ref> [14] </ref> by Hoydalsvik and Sindre at the OOPSLA'93 Conference.
Reference: [15] <author> R.E. Johnson. </author> <title> Documenting Frameworks using Patterns. </title> <booktitle> OOPSLA`92 Proceedings, </booktitle> <address> Vancouver, B.C., Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Alexander's definition of a pattern fits perfectly into an OO software design where each pattern describes the translation of one aspect of the analysis into the design, elucidating, at the same time, the use of the framework of classes <ref> [15] </ref> which are the elements of the architecture. However, the whole set of patterns, together with their structuring principles, becomes a high level language and a design method which accompanies the software life cycle from the analysis to the final implementation. <p> The template used to describe an OO pattern in inspired by the proposal of in literature <ref> [15, 10, 5, 16] </ref>, by the discussions on the "pattern mailing list" and by the works of Alexander himself and has the following fields: the pattern name; the context in which we have to discuss the pattern; the problems which the pattern addresses, related with the context; the solution offered by <p> The others, i.e. Visibility and Communication between Control Modules, Implementation of Modules of Control, The Interface to Modules of Control, Distribution of Modules of Control are domain dependent and are very similar in concepts to <ref> [15] </ref>: they provide guidelines on using the framework's classes to solve specific problems. They obviously exploit in turn basic OO design patterns for their implementation. 4 Conclusion A set of patterns with which to design concurrent distributed systems exemplified by CIM applications, has been defined.
Reference: [16] <author> E. Gamma, R. Helm, R. Johnson and J. </author> <title> Vlissides "Design Patterns: Elements of Reusable Object-Oriented Software", </title> <publisher> Addison-Wesley. </publisher> <year> 1994 </year>
Reference-contexts: The template used to describe an OO pattern in inspired by the proposal of in literature <ref> [15, 10, 5, 16] </ref>, by the discussions on the "pattern mailing list" and by the works of Alexander himself and has the following fields: the pattern name; the context in which we have to discuss the pattern; the problems which the pattern addresses, related with the context; the solution offered by <p> This pattern is called Observer in <ref> [16] </ref> and it has the same logic of reusability as the changed: update: mechanism of Model-View-Controller mechanism which has already been documented in the Smalltalk browser [17]. <p> The representation of all service behaviors in the framework with the unique doService () method of the Server is an alternative design choice to the Command pattern of <ref> [16] </ref>. <p> Figures 9 and 10 present two alternative architectural solutions for this pattern, where interface and implementation are linked by "inheritance" and "use" relationships, respectively; in <ref> [16] </ref> both these solutions are considered in the Adapter pattern. In both cases the Interface object can be generated automatically by a CASE environment from the specification of the active object. <p> To maintain two distinct implementations of a certain conceptual entity and to switch from one to the other is an application of the Bridge pattern from <ref> [16] </ref>. A reality object which encapsulates an external functionality is an example of the Adapter pattern from [16]. Installation can be speeded up by switching from prototype to physical implementation in the same program, which is achieved by using a suitable design pattern such as the Abstract Factory of [16], which <p> To maintain two distinct implementations of a certain conceptual entity and to switch from one to the other is an application of the Bridge pattern from <ref> [16] </ref>. A reality object which encapsulates an external functionality is an example of the Adapter pattern from [16]. Installation can be speeded up by switching from prototype to physical implementation in the same program, which is achieved by using a suitable design pattern such as the Abstract Factory of [16], which allows the user to decide at run time the specific class he needs. <p> from <ref> [16] </ref>. A reality object which encapsulates an external functionality is an example of the Adapter pattern from [16]. Installation can be speeded up by switching from prototype to physical implementation in the same program, which is achieved by using a suitable design pattern such as the Abstract Factory of [16], which allows the user to decide at run time the specific class he needs. <p> Stub and RemoteContext are the natural interface between the large grain of concurrency, represented by separate modules, and the smaller one, represented by services inside modules, supported by the G++ model. Stub is an application of the Proxy pattern from <ref> [16] </ref>. Switching between a simulation object and the corresponding Stub is an application of the Bridge pattern, again from [16]. <p> Stub is an application of the Proxy pattern from <ref> [16] </ref>. Switching between a simulation object and the corresponding Stub is an application of the Bridge pattern, again from [16]. Example: Distribution of a Shop and a Cell 15 We assume that the Shop and MachiningCell control modules are installed on respective computers interconnected through a factory-wide backbone network and that cell peripherals, in particular the collection of machines, are connected to the cell computer through shop-floor LANs. <p> Elemental patterns determine the language (elements of the architecture) in which the whole application has to be written and include A Hierarchy of Control Layers, Concurrency, Actions Triggered by Events, Services "Waiting for", Prototype and Reality. Basic design patterns, similar to those discussed in <ref> [16] </ref>, and with the same level of abstraction, propose OO design solutions as intermediary building blocks, such as Client/Server/Service, which by their very nature, are fairly application independent. The others, i.e.
Reference: [17] <author> G.E. Krasner and S. T. Pope. </author> <title> A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> August/September </month> <year> 1988 </year>
Reference-contexts: This pattern is called Observer in [16] and it has the same logic of reusability as the changed: update: mechanism of Model-View-Controller mechanism which has already been documented in the Smalltalk browser <ref> [17] </ref>. <p> The Client/Server/Service pattern is fundamental to our pattern language; it contains the essential structuring solution for concurrent programs. Much in the same way that a Smalltalk programmer structures virtually all user-interface code after the Model-View-Controller pattern <ref> [17] </ref>, we use Client/Server/Service for concurrent programming at all levels. Moreover, since the control modules in the CIM reference model of figure 2 are active objects, the pattern applies throughout a CIM control system.
Reference: [18] <author> C. McLean, M. Mitchell, and E. Barkmeyer. </author> <title> A computer architecture for small-batch manufacturing. </title> <journal> IEEE Spectrum, </journal> <volume> 20(5) </volume> <pages> 59-64, </pages> <year> 1983. </year>
Reference-contexts: Any organization defines its own control modules which are shaped according to its internal principles, which can be functional, logical or simply dictated by tradition. In the manufacturing field, they are traditionally indicated either as business or technical processes, and are arranged as in figure 2 according to <ref> [18] </ref>. Modules should encompass functionalities in such a way that can be reused for different projects. A pattern language for the definition of modules of control will be highly application specific and it is not discussed here.
Reference: [19] <author> G. Menga, G. Elia, and M. Mancin. G++: </author> <title> An environment for object oriented design and prototyping of manufacturing systems. </title> <editor> In W. Gruver and G. Boudreaux, editors, </editor> <title> Intelligent Manufacturing: Programming Environments for CIM. </title> <publisher> Springer-Verlag Ltd., </publisher> <year> 1993. </year>
Reference-contexts: A pattern language for a domain leads naturally to a supporting CASE environment. We have implemented such an environment for G++, merging a framework of C++ classes and tools to automate the development. Examples of application of it can be found in <ref> [19] </ref>. 1.2 Paper organization The paper is organized as follows: section 2 describes the proposed patterns and their structure through the presentation of examples, section 3 compares the interpretation of patterns presented in this paper with other related results. 2 The Pattern Language The problem addressed by the pattern language presented
Reference: [20] <author> D.L. Parnas, </author> <title> P.C. Clements, and D.M.Weiss. The modular structure of complex systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(3) </volume> <pages> 259-266, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: That is, there is the necessity of representing a system as a structure of hierarchically layered virtual machines <ref> [20] </ref>. Finally, modules of control should have the capability to encapsulate the resources and the services that manipulate them. 9 Solution These requirements are satisfied by the the Client/Server/Service model proposed in this pattern and derived by the programming paradigm of SR [4].
Reference: [21] <author> A. Rockstroem and R. Saracco. </author> <title> SDL-CCITT specification and description language. </title> <journal> IEEE Transactions on Communication, </journal> <volume> COM-30, </volume> <month> June 82. </month>
Reference-contexts: A graphical notation aimed at specifying service behaviors will add expressiveness to the formalism and because it is possible to animate it, debugging will be easier. The specification of a Service behavior, obtained with an OO extension of SDL (the Specification and Description Language standardized by CCITT, <ref> [21] </ref>). Such a specification leads to the automatic generation of the behavior method by the CASE environment. * The Server::doService () method must be redefined in order to become a switch case, which is controlled by a name parameter, so as to access the different types of service.
Reference: [22] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design Prentice Hall, </title> <address> Englewood Cliffs, NJ (USA), </address> <year> 1991. </year>
Reference: [23] <author> R. M. Soley. </author> <title> Object Management Architecture Guide OMG, Inc. 492 Old Connecticut path Framingham, </title> <address> Ma 01701, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: The remote context supports listening for requests coming over the communication network from other nodes, unpacking these requests and forwarding them to the correct object. This functionality corresponds to that of the "server skeleton" and the "object adapter" of the OMG CORBA reference model <ref> [23] </ref>.
Reference: [24] <author> B. Stroustrup. </author> <title> The C++ Programming Language 2nd Ed Addison-Wesley, </title> <year> 1991. </year>
Reference-contexts: Related Patterns This pattern follows the trend among C++ designers to separate an object definition into two distinct interface and implementation classes. The interface class is called a handle in <ref> [24] </ref> and proxy in [9]. It also corresponds to the Proxy of [10]. The switch from prototype to reality, as described by pattern 9, is usually enabled by the use of this pattern.
Reference: [25] <author> D. A. Young. </author> <title> The X Window System Programming and Application with Xt. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: between objects, here called caller/provider (C/P) and broadcaster/listeners (B/L) and described in figure 4. * The C/P mechanism is involved when an object invokes another object method and is deeply rooted in OO programming, so it will not be discussed further. * The B/L mechanism (Smalltalk dependencies, and X-Window callbacks) <ref> [12, 25] </ref> is achieved by giving all the objects of the framework the capability of broadcasting and listening to events.
Reference: [26] <author> R. Wirfs-Brock, R. </author> <booktitle> Johnson Surveying current research issues on object oriented design. Communication of the ACM 33(9) 105-124 Sept. </booktitle> <year> 1990. </year> <month> 18 </month>
Reference-contexts: 1 Introduction The Object Oriented (OO) paradigm claims to promote reuse. Originally reusability was intended at the level of system components, and component reuse was achieved through libraries of reusable classes organized in hierarchies of inheritance: what is now called a framework of classes <ref> [26] </ref>. However, attention is now being shifted from component to architecture reuse by giving more importance to the fundamental role that patterns of relationships between the elements have in any design. It is general opinion, in fact, that designers have always been driven by personal "patterns" when making choices.
References-found: 26

