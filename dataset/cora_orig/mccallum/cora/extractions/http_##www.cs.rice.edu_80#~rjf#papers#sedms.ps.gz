URL: http://www.cs.rice.edu:80/~rjf/papers/sedms.ps.gz
Refering-URL: http://www.cs.rice.edu:80/~rjf/pubs.html
Root-URL: 
Email: fowler@cs.rochester.edu, kthanasi@cs.rochester.edu  
Title: Supporting User-Level Exception Handling on a Multiprocessor Micro-Kernel: Experiences with Platinum  
Author: Robert J. Fowler and Leonidas I. Kontothanassis 
Address: Rochester, New York 14627  
Affiliation: Department of Computer Science University of Rochester  
Abstract: We describe the facilities provided by PLATINUM, a multiprocessor micro-kernel, to support user-level exception handling. The principal design goal for these facilities is to provide a very simple mechanism with sufficient flexibility and efficiency to experiment with the implementation of a wide variety of exception-driven, user-level services in a parallel system. These services provide conventional exception handling, an interface between parallel programs and debugging or performance monitoring tools, user-level paging and I/O services, and support for user-level lightweight process packages. The exception handling facility is based on fast message passing using a reconfigurable hierarchy of mailboxes. The mechanisms we describe have performance comparable to their uniprocessor signal handling under Unix, and retain that performance when used on a multiprocessor to support the kind of exception-driven services demanded by a parallel programming environment.
Abstract-found: 1
Intro-found: 1
Reference: [ABLL91] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium in Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: One way of avoiding this is to handle the exception within the same kernel-scheduled entity that incurred the trap. The basic flavor and flexibility of the PLATINUMexception protocol could be retained if the kernel interface supported abstractions such as First-Class User-Level Threads [MSLM91] or Scheduler Activations <ref> [ABLL91] </ref> that would block only one lightweight thread on a trap. To test this, we hand-coded an experiment in which the target thread contains two lightweight threads. <p> Simulating the "two minute warning" preemption avoidance mechanisms of [MSLM91] is straightforward with the handler-scheduler performing exactly the same actions that are performed in the original implementation. Alternatively, the handler-scheduler can be set up to emulate the upcall mechanism of the Anderson et al Scheduler Activations <ref> [ABLL91] </ref>. In this case, preemption recovery would be implemented sending an appropriately encoded message to the suspended handler-scheduler's exception port.
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In ASPLOS IV, </booktitle> <pages> pages 96-108, </pages> <year> 1991. </year>
Reference-contexts: The Government has certain rights in this material. 1 3. Supporting user-level scheduling of lightweight process models [ABLL91,MSLM91], 4. Implementing virtual memory paging at user level [RTY + 87], 5. Using memory management operations for non-traditional purposes <ref> [AL91] </ref>, and 6. Constructing interfaces between debugging and performance monitoring tools and their target programs. <p> The Mach memory management system [RTY + 87] supports the installation of external pagers that operate outside the kernel. The kernel forwards page fault exceptions to these user-level programs that in turn can be used to implement multiple custom paging mechanisms and policies. Recently Appel and Li <ref> [AL91] </ref> have surveyed several applications of user-level virtual memory operations including garbage collection, checkpointing, distributed virtual memories, and persistent stores. They point out that exception handling will be a major component of the cost of their mechanisms.
Reference: [ALBL91] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In ASPLOS IV, </booktitle> <pages> pages 108-122, </pages> <year> 1991. </year>
Reference-contexts: Although the modularity of this approach yields software engineering advantages such as improved comprehensibility, ease of maintenance, and reliability, the increased number of inter-module control transfers in such a system can put it at a performance disadvantage with respect to more monolithic designs <ref> [ALBL91] </ref>. On a multiprocessor, however, the modularity of the micro-kernel approach can be exploited to take advantage of parallelism by replicating and distributing servers across multiple processors. <p> There are too many uncontrolled architectural variables to make a definitive comparison and the standard measures of system performance for application programs are notoriously optimistic and inaccurate predictors of operating system performance <ref> [ALBL91] </ref>. Nevertheless, the results of our measurements indicate that when operating on a single Butterfly node the times for the PLATINUMmechanisms are comparable to or better than timing figures for operations with similar functionality executing on machines with equal or greater power.
Reference: [BALL89] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium in Operating System Principles, </booktitle> <year> 1989. </year>
Reference-contexts: If the overhead of such a design is too great then it will not be used, so it is important to pay attention to performance. In this section we discuss measurements of the performance of the PLATINUMexception handling mechanism. We also present the implementation strategies, similar to those in <ref> [BALL89] </ref>, we used to improve the speed of the mechanism in those cases in which the full generality of the mechanism is not needed. <p> We believe that it is worth reimplementing our model for exception handling using new techniques for kernel and server structuring like continuation passing [DBRD91] and memory mapped message passing <ref> [BALL89] </ref> and exploring the possible performance benefits that our mechanism will have under these different models of communication and thread management. 8 Acknowledgements This work owes a lot to the help of Alan Cox whose innovative comments and suggestions based on his intimate knowledge of every detail of PLATINUM proved invaluable.
Reference: [BGH + 88] <author> D. L. Black, D. B. Golub, K. Hauth, A. Tevanian, and R. Sanzi. </author> <title> The Mach Exception Handling Facility. </title> <booktitle> In Workshop in Parallel and Distributed Debugging, </booktitle> <pages> pages 45-56, </pages> <year> 1988. </year>
Reference-contexts: The number of "reasonable" alternatives for exception reporting can be very large on a multiprocessor with multi-threaded and multiple address space applications. Some exceptions can be handled on a per-thread basis, some should be handled on a per-address space basis, and some should be handled on a per-application basis <ref> [BGH + 88] </ref>. In object-oriented programs a handler might be allocated to serve all instances of a particular class, a subset such as the instances on a particular processor, or even a single instance. <p> The cost of using Ptrace, however, is much higher than that of signals and many of the original deficiencies with respect to our intended applications still remain. 2.2.2 Mach The Mach exception handling mechanism <ref> [BGH + 88] </ref> was designed specifically with multiprocessing in mind. The origins of PLATINUM in Mach are reflected in the reliance of the exception handling mechanism on message passing, but there are many significant differences between the systems. <p> For debugging multiple threads the advantages will be much greater since the condition testing will be done in parallel. The integration of this technique into a production quality debugger as well as adding other primitives deemed useful or necessary for debugging multithreaded programs <ref> [BGH + 88] </ref> appears to be straightforward and is left for future work. 6.0.1 Supporting User-Level Threads. Several groups [ABLL91,MSLM91] have pointed out that efficient kernel support threads can be crucial to the performance user-level thread packages.
Reference: [Bla82] <author> A. R. Black. </author> <title> Exception Handling: The Case Against. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1982. </year>
Reference-contexts: Languages like ADA [Ich77], PL/I [Mac77] and Mesa [MMS79,GMS77] provide primitives for exception handling within the language. There has been, however, a strong debate on how useful these mechanisms are <ref> [Bla82] </ref> since they have an adverse impact on the simplicity and elegance of the language.
Reference: [CF89] <author> A. L. Cox and R. J. Fowler. </author> <title> The implementation of a coherent memory abstraction on a numa mutliprocessor: Experiences with PLATINUM. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 32-44, </pages> <month> December </month> <year> 1989. </year>
Reference: [Cox91] <author> A. L. Cox. </author> <title> The Implementation and Evaluation of a Coherent Memory Abstraction for NUMA Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of Rochester, </institution> <year> 1991. </year>
Reference: [DBRD91] <author> R. P. Draves, B. N. Bershad, R. F. Rashid, and R. W. Dean. </author> <title> Using continuations to implement thread management and communication in operating systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium in Operating System Principles, </booktitle> <year> 1991. </year>
Reference-contexts: We believe that it is worth reimplementing our model for exception handling using new techniques for kernel and server structuring like continuation passing <ref> [DBRD91] </ref> and memory mapped message passing [BALL89] and exploring the possible performance benefits that our mechanism will have under these different models of communication and thread management. 8 Acknowledgements This work owes a lot to the help of Alan Cox whose innovative comments and suggestions based on his intimate knowledge of
Reference: [Els88] <author> I. J. P. Elshoff. </author> <title> A distributed debugger for Amoeba. </title> <booktitle> In Workshop in Parallel and Distributed Debugging, </booktitle> <pages> pages 1-10, </pages> <year> 1988. </year>
Reference-contexts: In addition to the information recorded by the event detection and reporting mechanism, the handler also requires a means of examining and manipulating process state <ref> [Els88] </ref> as well as other resources in the system. * Continuation: If the target thread can be resumed it does so from the state established by the handler. The handlers of various types of exceptions require differing degrees of privilege and of isolation from the application program.
Reference: [FC88] <author> R. J. Fowler and A. Cox. </author> <title> An overview of PLATINUM: A platform for investigating non-uniform memory. </title> <type> Technical report, </type> <institution> Department of Computer Science University of Rochester, </institution> <year> 1988. </year>
Reference: [FLMC88] <author> R. J. Fowler, T. J. LeBlanc, and J. Mellor-Crummey. </author> <title> An integrated approach to par allel program debugging and performance analysis on large-scale multiprocessors. </title> <booktitle> In Workshop in Parallel and Distributed Debugging, </booktitle> <pages> pages 163-173, </pages> <year> 1988. </year>
Reference-contexts: For example, a conditional breakpoint in a thread of control can be implemented as an ordinary breakpoint in which a debugger agent passes control to the user interface part of the debugger only if the specified condition is satisfied <ref> [FLMC88] </ref>. Otherwise, the thread is resumed without any further communication.
Reference: [GMS77] <author> C. M. Geschke, J. H. Morris, and E. H. Satterthwaite. </author> <title> Early experiences with Mesa. </title> <journal> Coomunications of the ACM Vol. </journal> <volume> 20, </volume> <pages> pages 540-553, </pages> <year> 1977. </year>
Reference: [GSS87] <author> Edward F. Gehringer, Daniel P. Siewiorek, and Zary Segall. </author> <title> Parallel Processing: The Cm* Experience. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1987. </year>
Reference-contexts: From the perspective of our intended applications some details of the implementation pose serious problems. Medusa had a very small kernel that routed all exceptions in the system through a single, centralized system activity (called a "utility") known as the exception reporter (also called the exception manager in <ref> [GSS87] </ref>), from which they are dispatched to the correct handler (s). In addition to serializing exception reporting, this centralization makes it difficult to experiment with hierarchical exception handling.
Reference: [Ich77] <author> J. D. Ichbiah. </author> <title> Rationale for the design of the ADA programming language. </title> <journal> SIGPLAN Notices Vol. </journal> <volume> 20, </volume> <pages> pages 500-503, </pages> <year> 1977. </year>
Reference-contexts: Like Unix, Medusa provided a separate utility (called MACE) specifically to handle exceptions associated with debugging and tracing. 2.3 Programming Language Support for Exceptions Exception handling is also an issue in the design of a programming language and its runtime environment. Languages like ADA <ref> [Ich77] </ref>, PL/I [Mac77] and Mesa [MMS79,GMS77] provide primitives for exception handling within the language. There has been, however, a strong debate on how useful these mechanisms are [Bla82] since they have an adverse impact on the simplicity and elegance of the language.
Reference: [LE80] <author> Henry M. Levy and Richard H. Eckhouse, Jr. </author> <title> Computer Programming and Architecture, The VAX-11. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1980. </year>
Reference-contexts: As more applications for user-level exception handling are found this performance consideration will become more important. In a layered system there may be many potential layers of exception handling that will recursively perform variations on each of the above phases. For example, in VAX VMS <ref> [LE80] </ref> the handling of a single exception may be distributed across many levels including a low-level handler for the "hardware interrupt", a "software interrupt" handler in the operating system kernel, and another handler in user mode.
Reference: [Mac77] <author> M. D. MacLaren. </author> <title> Exception handling in PL/I. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation, Maynard, </institution> <address> Mass., </address> <year> 1977. </year>
Reference-contexts: Like Unix, Medusa provided a separate utility (called MACE) specifically to handle exceptions associated with debugging and tracing. 2.3 Programming Language Support for Exceptions Exception handling is also an issue in the design of a programming language and its runtime environment. Languages like ADA [Ich77], PL/I <ref> [Mac77] </ref> and Mesa [MMS79,GMS77] provide primitives for exception handling within the language. There has been, however, a strong debate on how useful these mechanisms are [Bla82] since they have an adverse impact on the simplicity and elegance of the language.
Reference: [MMS79] <author> J. G. Mitchell, W. Maybury, and R. Sweet. </author> <title> Mesa Language Manual Version 5.0. </title> <institution> Xerox Palo Alto research Center, Systems Development Department, </institution> <year> 1979. </year>
Reference: [MSLM91] <author> B. D. Marsh, M. L. Scott, T. J. LeBlanc, and E. P. Markatos. </author> <title> First-class user-level threads. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium in Operating System Principles, </booktitle> <pages> pages 110-121, </pages> <year> 1991. </year>
Reference-contexts: One way of avoiding this is to handle the exception within the same kernel-scheduled entity that incurred the trap. The basic flavor and flexibility of the PLATINUMexception protocol could be retained if the kernel interface supported abstractions such as First-Class User-Level Threads <ref> [MSLM91] </ref> or Scheduler Activations [ABLL91] that would block only one lightweight thread on a trap. To test this, we hand-coded an experiment in which the target thread contains two lightweight threads. <p> This proposed organization can be used to efficiently simulate several of the user-level thread management abstractions in the literature. Simulating the "two minute warning" preemption avoidance mechanisms of <ref> [MSLM91] </ref> is straightforward with the handler-scheduler performing exactly the same actions that are performed in the original implementation. Alternatively, the handler-scheduler can be set up to emulate the upcall mechanism of the Anderson et al Scheduler Activations [ABLL91].
Reference: [Mul87] <author> Sape J. Mulleneder. </author> <booktitle> The Amoeba distributed operating system : selected papers, </booktitle> <year> 1984 1987. </year> <institution> Centrum voor Wiskunde en Informatica, </institution> <year> 1987. </year>
Reference: [Ous81] <author> J. K. Ousterhout. </author> <title> Medusa: a distributed operating system. </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: sent to a single port, this design serializes the handling of debugging events, thus precluding our strategy of allocating one debugging agent per processor or per thread of control. 2.2.3 Medusa Many of the ideas in the Mach and PLATINUM exception handling mechanism were pioneered in the Medusa operating system <ref> [Ous81] </ref>. The exceptions caused by a process (called an "activity") could be handled by several entities. Each exception is reported to an "internal" handler responsible for cleaning up the control structures of the target activity and, optionally, to an "external" handler responsible for cleaning up the state of shared objects.
Reference: [Ras86] <author> R. Rashid. </author> <title> From RIG to Accent to Mach: The evolution of a network operating sys tem. </title> <booktitle> In Proceedings of the ACM/IEEE Computer Society 1986 Fall Joint Computer Conference., </booktitle> <month> November </month> <year> 1986. </year>
Reference: [RT78] <author> D. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <type> Technical report, </type> <institution> Bell System Technical Journal, </institution> <month> July </month> <year> 1978. </year>
Reference-contexts: We describe a few previous approaches to exception handling and we point out their strengths and weaknesses in meeting the requirements for our applications. 2.2.1 Unix Signals and Ptrace In Unix <ref> [RT78] </ref> the user-level exception handling mechanism is called signals, a form of software interrupt [SPG91] that allows a process to install within it handlers for events that it causes or that otherwise affect it. The signals mechanism has many drawbacks from the perspective of our intended applications.
Reference: [RTY + 87] <author> R. Rashid, A. Tevanian, M. Young, D. Golub, R. Baron, D. Black, W. Bolosky, and J. Chew. </author> <title> Machine-independent virtual memory management for paged uniprocessor and multiprocessor architectures. </title> <booktitle> In ASPLOS II, </booktitle> <pages> pages 31-41, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The Government has certain rights in this material. 1 3. Supporting user-level scheduling of lightweight process models [ABLL91,MSLM91], 4. Implementing virtual memory paging at user level <ref> [RTY + 87] </ref>, 5. Using memory management operations for non-traditional purposes [AL91], and 6. Constructing interfaces between debugging and performance monitoring tools and their target programs. <p> There are several uses for the user-level handling of exceptions associated with memory management. The Mach memory management system <ref> [RTY + 87] </ref> supports the installation of external pagers that operate outside the kernel. The kernel forwards page fault exceptions to these user-level programs that in turn can be used to implement multiple custom paging mechanisms and policies.
Reference: [SPG91] <author> A. Silberschatz, J. Peterson, and P. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: We describe a few previous approaches to exception handling and we point out their strengths and weaknesses in meeting the requirements for our applications. 2.2.1 Unix Signals and Ptrace In Unix [RT78] the user-level exception handling mechanism is called signals, a form of software interrupt <ref> [SPG91] </ref> that allows a process to install within it handlers for events that it causes or that otherwise affect it. The signals mechanism has many drawbacks from the perspective of our intended applications. Some of these are known problems on uniprocessors. It is possible to lose events.
Reference: [Sta87] <author> R. M. Stallman. </author> <title> GDB Manual: The GNU source-level Debugger. </title> <booktitle> Free Software Founda tion, </booktitle> <year> 1987. </year>
Reference-contexts: For example, for remote debugging we created a debugger host server that runs on a processor with an Ethernet interface. The host server manages communication, especially protocol translation, between the debugger agents that handle exceptions and a debugger (GDB <ref> [Sta87] </ref>) running on a remote workstation. 4.2 Defaults Although the mechanism is flexible, very few programmers will want to, or really need to, define their own scheme for exception handling. We therefore provide a reasonable default configuration. <p> Debugger Interface. In Figure 5 we illustrate in more detail how the exception handling mechanism is used to mediate between parallel applications on PLATINUMand an instance of the GNU Debugger <ref> [Sta87] </ref> running on a remote workstation. All of the exception handler/debugging agent threads share an address space with the debugging host server thread. The agents run on the same processors as their target threads and the host server runs on the processor with the Ethernet controller.
References-found: 26

