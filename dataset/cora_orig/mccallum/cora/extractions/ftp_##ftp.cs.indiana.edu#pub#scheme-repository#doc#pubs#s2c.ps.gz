URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/s2c.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/imp.html
Root-URL: http://www.cs.indiana.edu
Title: J A N U A R Y  a Portable Scheme-to-C Compiler  
Author: Joel F. Bartlett d i g i t a l 
Address: 100 Hamilton Avenue Palo Alto, California 94301 USA  
Affiliation: Western Research Laboratory  
Date: SCHEME-&gt;C  
Pubnum: 1 9 8 9 Research Report 89/1  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Harold Abelson and Gerald Jay Sussman with Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Specific attention is paid to those items which do not cleanly translate to C. Readers interested in going beyond this informal introduction to Scheme are encouraged to consult the standard [13] which was used to form this section, or the text <ref> [1] </ref>. 2.1. Identifiers, Variables, and Binding Scheme's identifiers are similar to those used in most languages. For example, A1 is a legal identifier in Scheme and C.
Reference: [2] <author> Joel F. Bartlett. </author> <title> Compacting Garbage Collection with Ambiguous Roots. </title> <type> Technical Report WRL Research Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <month> February, </month> <year> 1988. </year> <note> Also published in LISP Pointers, Vol. 1, No. 6. </note>
Reference-contexts: As a result, any algorithm that requires the garbage collector to know exactly where the pointers are cannot be used. 13 SCHEME-&gt;C A PORTABLE SCHEME-TO-C COMPILER To solve this problem, a new garbage collection algorithm called "mostly-copying" was devised <ref> [2] </ref>. Instead of requiring that the root set be a known set of cells containing pointers which define all accessible storage, the new algorithm only requires that the root set include pointers or values derived from pointers which define all accessible storage.
Reference: [3] <author> Frederick C. Chow and Mahadevan Ganapathi. </author> <title> Intermediate Languages in Compiler Construction - A Bibliography. </title> <journal> SIGPLAN Notices 18(11) </journal> <pages> 21-23, </pages> <month> November, </month> <year> 1983. </year>
Reference-contexts: Second, the UNCOL provides a common meeting point for all languages and thus facilitates the construction of programs written in multiple languages. Finally, the UNCOL compiler can simplify the individual language compilers by providing language-independent optimization. Unfortunately, while many efforts since then have used intermediate languages <ref> [3] </ref>, it is clear that they have not become widely accepted. Instead, standardization efforts have focussed on proprietary instruction set architectures, e.g. the Digitial VAX, and on industry wide standards for higher-level languages, e.g. FORTRAN-77.
Reference: [4] <author> William D. Clinger, Anne H. Hartheimer, and Eric M. </author> <title> Ost. Implementation Strategies for Continuations. </title> <booktitle> In 1988 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 124-131. </pages> <month> August, </month> <year> 1988. </year>
Reference-contexts: Continuations Various mechanisms have been used to create continuations in Scheme, as is summarized in <ref> [4] </ref>. Given the fact that we wish to avail ourselves of C's procedure call/return and local variable allocation mechanisms, it makes sense to implement continuations using the stack strategy.
Reference: [5] <author> Jacques Cohen. </author> <title> Garbage Collection of Linked Data Structures. </title> <journal> ACM Computing Surveys 13(3) </journal> <pages> 341-367, </pages> <month> September, </month> <year> 1981. </year>
Reference-contexts: Since objects have an indefinite lifetime, they must be allocated from a heap. As the objects are never explicitly freed, some mechanism must be provided for objects which are no longer referenced. A review of the literature on garbage collection <ref> [5] </ref> suggests that garbage collection might be quite difficult in the C environment. Virtually all collection algorithms start with information found in a root set of pointers which must be in known locations.
Reference: [6] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Performance in C While compiling Scheme to C may provide a very portable system, one's first inclination is to expect that there is a performance penalty. One test that was run suggests that this is not the case. The Gabriel benchmarks <ref> [6] </ref> were run on a MicroVax II and Scheme-&gt;C's performace was compared against that of a native Lisp implementation, VAX Common Lisp V2.2 as reported in [14].
Reference: [7] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Embedding Continuations in Procedural Objects. </title> <journal> ACM Transactions on Programming Languages 9(4) </journal> <pages> 582-598, </pages> <month> October, </month> <year> 1987. </year>
Reference-contexts: This ability to shift control is significantly more powerful than the upexit capability provided by UNIX's setjmp and longjmp [10], or Common LISP's catch and throw [16]. As a result, a large variety of control structures can be fabricated, as is shown in <ref> [7] </ref>. 2.7. Iteration is a Special Case of Function Call Using the concept of continuations (and ignoring the mechanism used for argument passing and value return), the procedure call and return mechanism of C can be informally described as follows.
Reference: [8] <author> Gerry Kane. </author> <title> MIPS R2000 RISC Architecture. </title> <publisher> Prentice Hall, Inc., </publisher> <year> 1987. </year>
Reference-contexts: Procedure Call: a Dilemma One of the strengths of a good C compiler is that it provides significant processor independent 4 and dependent optimization. While many move frequently used local variables to registers , compilers on RISC processors such as the MIPS R2000 <ref> [8] </ref> make a significant effort to optimize procedure calls. Some procedure arguments are passed in the registers and calls to leaf 5 procedures are optimized. By using C's procedure call and return mechanisms, one is able to take advantage of these optimizations.
Reference: [9] <author> Brian W. Kernighan, Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1978. </year>
Reference-contexts: Instead, standardization efforts have focussed on proprietary instruction set architectures, e.g. the Digitial VAX, and on industry wide standards for higher-level languages, e.g. FORTRAN-77. However, if one is willing to restrict one's view to workstations running UNIX [10] or its derivatives, one could consider C <ref> [9] </ref> as a possible UNCOL. All such systems have a C compiler, and as C was the first high-level language for UNIX, most other languages can call C procedures and use its data structures.
Reference: [10] <author> Brian W. Kernighan, Rob Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1984. </year>
Reference-contexts: Instead, standardization efforts have focussed on proprietary instruction set architectures, e.g. the Digitial VAX, and on industry wide standards for higher-level languages, e.g. FORTRAN-77. However, if one is willing to restrict one's view to workstations running UNIX <ref> [10] </ref> or its derivatives, one could consider C [9] as a possible UNCOL. All such systems have a C compiler, and as C was the first high-level language for UNIX, most other languages can call C procedures and use its data structures. <p> Every time repeat is called, it will return to that point in the computation and print the digits 123. This ability to shift control is significantly more powerful than the upexit capability provided by UNIX's setjmp and longjmp <ref> [10] </ref>, or Common LISP's catch and throw [16]. As a result, a large variety of control structures can be fabricated, as is shown in [7]. 2.7.
Reference: [11] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233. </pages> <month> July, </month> <year> 1986. </year>
Reference-contexts: Finally, Scheme introduces a new concept with its escape procedures which capture continuations. Before examining the solutions to these problems, a short overview of the compilation process is in order. The design of this process owes much to Steele's RABBIT compiler [15] done at MIT and the ORBIT compiler <ref> [11] </ref> done at Yale. 2 A pair is a type of Scheme object with two fields, the car and the cdr. Pairs are allocated by calls to the procedure cons which takes the values to place in the two fields as its arguments.
Reference: [12] <author> Michael J. K. Nielsen. </author> <title> Titan System Manual. </title> <type> Technical Report WRL Research Report 86/1, </type> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <month> September, </month> <year> 1986. </year> <note> 3 [13] Jonathan Rees, </note> <editor> William Clinger (Editors). </editor> <title> Revised Report on the Algorithmic Language Scheme. </title> <journal> SIGPLAN Notices 21(12) </journal> <pages> 37-79, </pages> <month> December, </month> <year> 1986. </year>
Reference-contexts: Instead, all work can be done on the target system: the machine-dependent parts of the run-time system are changed, and then the entire system is compiled using the system's C compiler. Following the initial implementation of the compiler on the Titan workstation developed by WRL <ref> [12] </ref>, it was ported to the Digital VAX, and the DECstation 3100 which uses a MIPS R2000 processor. Each of these ports took less than one week and required less than 100 lines of machine specific code.
Reference: [14] <author> Walter van Roggen. </author> <title> Lisp Implementations. </title> <booktitle> LISP Pointers 1(5) </booktitle> <pages> 37-42, </pages> <month> December, </month> <year> 1987. </year>
Reference-contexts: One test that was run suggests that this is not the case. The Gabriel benchmarks [6] were run on a MicroVax II and Scheme-&gt;C's performace was compared against that of a native Lisp implementation, VAX Common Lisp V2.2 as reported in <ref> [14] </ref>. When the benchmarks were compiled using the standard ULTRIX C compiler, the geometric mean of the run-times showed that they were 5% slower than VAX Common Lisp.
Reference: [15] <author> Guy L. Steele Jr. RABBIT: </author> <title> a Compiler for Scheme. </title> <type> Technical Report AI Memo No. 452, </type> <institution> Massachusetts Institute of Technology, </institution> <month> May, </month> <year> 1978. </year>
Reference-contexts: Finally, Scheme introduces a new concept with its escape procedures which capture continuations. Before examining the solutions to these problems, a short overview of the compilation process is in order. The design of this process owes much to Steele's RABBIT compiler <ref> [15] </ref> done at MIT and the ORBIT compiler [11] done at Yale. 2 A pair is a type of Scheme object with two fields, the car and the cdr. <p> 1)) Scheme-&gt;C converts all expressions to their equivalent primitive expressions: (define (sample x y z) (if ((lambda (x thunk) (if x x (thunk))) ((lambda (x thunk) (if x (thunk) x)) x (lambda () Y)) (lambda () Z)) 0 Following this all variables are uniquely named, a process known as alpha-conversion <ref> [15] </ref>, and each primitive form is replaced by an equivalent internal form: ($DEFINE S1000 ($LAMBDA L1001 ($IF (&lt;APPLY&gt; () L1005 (X1006 (&lt;APPLY&gt; () L1008 (X1009 &lt;- X1002) (T1010 &lt;- ($LAMBDA L1011 Y1003)) ($IF X1009 ($CALL () T1010) X1009))) (T1007 &lt;- ($LAMBDA L1012 Z1004)) ($IF X1006 X1006 ($CALL () T1007))) C1014 Lambda
Reference: [16] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Every time repeat is called, it will return to that point in the computation and print the digits 123. This ability to shift control is significantly more powerful than the upexit capability provided by UNIX's setjmp and longjmp [10], or Common LISP's catch and throw <ref> [16] </ref>. As a result, a large variety of control structures can be fabricated, as is shown in [7]. 2.7.

References-found: 15

