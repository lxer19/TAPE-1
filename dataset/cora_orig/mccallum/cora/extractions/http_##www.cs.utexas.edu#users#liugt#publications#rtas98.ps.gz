URL: http://www.cs.utexas.edu/users/liugt/publications/rtas98.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/liugt/publications/rtas98.html
Root-URL: 
Email: fliugt, mokg@cs.utexas.edu pkonana@mail.utexas.edu  
Title: A Unified Approach for Specifying Timing Constraints and Composite Events in Active Real-Time Database Systems  
Author: Guangtian Liu Aloysius K. Mok Prabhudev Konana 
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences Department of Management Science and Information Systems The University of Texas at Austin  
Abstract: In active database systems, events are used in ECA rules to specify the time to check the conditions of the rules. Composite events can be constructed in an intuitive way by applying event operators, such as and, or, sequence, etc., to primitive events. Where timing is important, these event operators may introduce ambiguity if there is no formal semantics defining the occurrence of the composite events. In this paper, we propose a formalism to specify a wider range of composite events with formal semantics in the logic RTL which is especially amenable for specifying timing constraints in real-time systems. The use of RTL to define the formal semantics also allows us to exploit compilation methods which can be used to translate the enabling conditions of ECA rules into timing constraints. Thus the detection of composite events can be handled by monitoring the corresponding timing constraints, a subject which has been explored in our previous work [18, 19]. A prototype implementation of this approach, a Java package for composite event specification, compilation and detection, will be discussed in the paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Berndtsson and J. Hansson, </author> <title> "Issues in Active Real-Time Databases", </title> <booktitle> Proc. of the First International Workshop on Active and Real-Time Database Systems (ARTDB-95), </booktitle> <month> June </month> <year> 1995, </year> <month> pp.142-157. </month>
Reference: [2] <author> S. Chakravarthy et. al, "HiPAC: </author> <title> A Research Project in Active, Time-Constrained Database Management", </title> <type> Technical Report XAIT-89-02, </type> <institution> Xe-rox Advanced Information Technology, </institution> <year> 1989. </year>
Reference-contexts: 1 Introduction Active database systems support reactive behavior by integrating rules into DBMSs (database management systems). The most popular rule model is the ECA model <ref> [2] </ref> which defines each rule by an event-condition-action pattern, meaning that whenever the specified event in the pattern happens, the condition (usually predicates or queries against the database) is evaluated, and the action part of the rule is executed if the evaluation returns true. <p> Section 6 concludes the paper. 2 Event Model The event model that we are using was first presented in [11, 16] and given semantics in RTL (Real Time Logic), which is quite similar with the event model <ref> [2, 3] </ref> used in active databases. Informally speaking, events represent state changes of interests that occur in some computation of a system. For example, "start inserting a tuple into relation R", "end of transaction T" can be defined as events.
Reference: [3] <author> S. Chakravarthy and D. Mishra, "Snoop: </author> <title> An Expressive Event Specification Language for Active Databases", </title> <journal> Data and Knowledge Engineering, </journal> <volume> 14(10), </volume> <month> Oct. </month> <year> 1994, </year> <month> pp1-26. </month>
Reference-contexts: Since the event part (event specification and detection) is what really makes such a system active, a lot of work <ref> [3, 8, 9] </ref> has been done to classify the primitive events and to compose complex events from simpler ones by using event operators such as disjunction, sequencing, conjunction. <p> At time 15, when the second instance of E 2 occurs, we face the same questions again. Although additional parameter contexts have been introduced in <ref> [3] </ref> to clarify some of these situations, different parameter contexts may apply to different event operators and as a result the semantics of composite events may not agree with the intuitive interpretation 1 of the programmer. <p> The event data collected at runtime monitoring are usually used for postmortem analysis. Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in <ref> [3, 8, 9, 22, 15] </ref> for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based [9] as well as graph-based [3], are proposed. <p> Various event operators, such as AND, OR, SEQUENCE, etc. have been used in [3, 8, 9, 22, 15] for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based [9] as well as graph-based <ref> [3] </ref>, are proposed. However, as shown in Example 1, composite events specified with these event operators often have different interpretations in terms of their occurrences. [22] proposes using Past Temporal Logic for specifying temporal conditions and events in active database systems. <p> Section 6 concludes the paper. 2 Event Model The event model that we are using was first presented in [11, 16] and given semantics in RTL (Real Time Logic), which is quite similar with the event model <ref> [2, 3] </ref> used in active databases. Informally speaking, events represent state changes of interests that occur in some computation of a system. For example, "start inserting a tuple into relation R", "end of transaction T" can be defined as events. <p> We find that many event operators proposed so far can be expressed in this way. The following example shows that the composite events using sequence (;) operator can be specified in our formalism with clearer semantics on their occurrences: Example 7 Sequence (;) operator <ref> [3] </ref>: By definition, event (E 1 ; E 2 ) occurs when E 2 occurs provided E 1 has already occurred within some interval. For various definitions of this interval, there might be different understanding regarding the occurrence of this composite event, such as a.
Reference: [4] <author> S. Chodrow, F. Jahanian, and M. Donner, </author> <title> "Run-Time Monitoring of Real-Time Systems", </title> <booktitle> Proc. Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1991, </year> <month> pp74-83. </month>
Reference-contexts: Then the action A will not be taken until time D+1000, at which event T commit occurs. But this timing constraint TC has been violated 990 time units earlier, at time D+10! Generally, monitoring a time constraint TC is not as simple as evaluating the truth value of TC <ref> [4, 18, 19] </ref>. More complex monitoring algorithms are needed to catch timing constraint violations as early as possible [18, 19]. <p> the enabling conditions of ECA rules in active real-time databases which (1) solves the ambiguity problems mentioned in the previous section and (2) permits the efficient detection algorithms in [18, 19] to be applied to active, real-time databases. 1.1 Related Work Runtime monitoring of timing constraints have been investigated in <ref> [4, 13, 17, 20, 18, 19] </ref>. In [17], an annotation method was introduced which marks the events of interests in Ada programs and uses RTL (Real Time Logic) formulas to specify the timing constraints to be enforced. <p> In [17], an annotation method was introduced which marks the events of interests in Ada programs and uses RTL (Real Time Logic) formulas to specify the timing constraints to be enforced. In FLEX [13], certain predefined timing constraints can be monitored for violation. <ref> [4] </ref> presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper. In [20], the model of [4] is extended to distributed systems and the problem of <p> certain predefined timing constraints can be monitored for violation. <ref> [4] </ref> presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper. In [20], the model of [4] is extended to distributed systems and the problem of detecting timing constraint violations in a distributed environment is discussed. It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. <p> Definition 2 At time t during a computation, 8 event e, we define #(e; t) = &lt; 0 0 t &lt; @(e; 1)j t t @(e; 1)j t <ref> [4, 12] </ref> extends the @-function to represent oc-currence time of current and past relative instances. We further extend it to represent future relative instances [18] as well as current and past relative ones. <p> Here we give a brief description of this specification method. More detailed discussion can be found in <ref> [4, 18, 19] </ref>. In general, event occurrences mark various time points during a computation, and we can specify timing constraints as a set of assertions that relate the occurrence times of various event instances to one another. <p> 1 ^ F 2 to indicate the fact that in some cases we can actually infer V (F 1 ^ F 2 ; t) = true and S (F 1 ^ F 2 ; t) = f alse instead of unknown because of the existence of the following implicit constraint <ref> [4, 18, 19] </ref>: Definition 7 Given a conjunction C of basic constraints, a basic constraint that does not appear in C but is logically implied by C is called an implicit constraint of C.
Reference: [5] <author> J. Chomicki, </author> <title> "History-less Checking of Dynamic Integrity Constraints", </title> <booktitle> Proc. IEEE International Conference on Data Engineering, </booktitle> <month> Feb. </month> <year> 1992. </year>
Reference: [6] <author> J. Chomicki, </author> <title> "Real-Time Integrity Constraints", </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference: [7] <author> S. Gatziu, A. Geppert, and K.R. Dittrich, </author> <title> "Integrating Active Concepts into an Object-Oriented Database System", </title> <booktitle> Proc. of the Third International Workshop on Database Programming Languages, </booktitle> <month> August </month> <year> 1991. </year>
Reference: [8] <author> S. Gatziu, A. Geppert, and K.R. Dittrich, </author> <title> "Detecting Composite Events in Active Database Systems Using Petri Nets", </title> <booktitle> Proc. of the Fourth International Workshop on Research Issues in Data Engineering, </booktitle> <month> Feb. </month> <year> 1994, </year> <month> pp.2-9. </month>
Reference-contexts: Since the event part (event specification and detection) is what really makes such a system active, a lot of work <ref> [3, 8, 9] </ref> has been done to classify the primitive events and to compose complex events from simpler ones by using event operators such as disjunction, sequencing, conjunction. <p> The event data collected at runtime monitoring are usually used for postmortem analysis. Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in <ref> [3, 8, 9, 22, 15] </ref> for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based [9] as well as graph-based [3], are proposed. <p> Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in [3, 8, 9, 22, 15] for specifying composite events. Different composite event detection approaches, e.g. Petri-net based <ref> [8] </ref>, finite-state-machine based [9] as well as graph-based [3], are proposed. However, as shown in Example 1, composite events specified with these event operators often have different interpretations in terms of their occurrences. [22] proposes using Past Temporal Logic for specifying temporal conditions and events in active database systems.
Reference: [9] <author> N. Gehani, H.V. Jagadish, and O. Shmueli, </author> <title> "Composite Event Specification in Active Databases: Model & Implementation", </title> <booktitle> Proc. of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1992, </year> <month> pp.327-338. </month>
Reference-contexts: Since the event part (event specification and detection) is what really makes such a system active, a lot of work <ref> [3, 8, 9] </ref> has been done to classify the primitive events and to compose complex events from simpler ones by using event operators such as disjunction, sequencing, conjunction. <p> The event data collected at runtime monitoring are usually used for postmortem analysis. Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in <ref> [3, 8, 9, 22, 15] </ref> for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based [9] as well as graph-based [3], are proposed. <p> Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in [3, 8, 9, 22, 15] for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based <ref> [9] </ref> as well as graph-based [3], are proposed. However, as shown in Example 1, composite events specified with these event operators often have different interpretations in terms of their occurrences. [22] proposes using Past Temporal Logic for specifying temporal conditions and events in active database systems.
Reference: [10] <author> J. Gomez, D.E. Weisman and V.B. Trevino, </author> <title> "Brokers and the Web", Money and Strategies The Forrester Report", </title> <type> 2(1), </type> <month> September </month> <year> 1996. </year>
Reference-contexts: It is estimated that the number of individual investors in the United States using e-brokerage will grow from 800,000 in 1996 to 10 million by the year 2001 <ref> [10] </ref>. The changing business environment and customer expectations will also require e-brokerages to offer more interactive and real-time services where complex customer preferences and actions can be specified, monitored and executed in a timely manner.
Reference: [11] <author> F. Jahanian and A.K. Mok, </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9), </volume> <month> Sept. </month> <year> 1986, </year> <month> pp.890-904. </month>
Reference-contexts: Section 5 discusses how this approach can be extended and applied in an electronic brokerage application and describes the composite event package that we are implementing in Java. Section 6 concludes the paper. 2 Event Model The event model that we are using was first presented in <ref> [11, 16] </ref> and given semantics in RTL (Real Time Logic), which is quite similar with the event model [2, 3] used in active databases. Informally speaking, events represent state changes of interests that occur in some computation of a system. <p> An event occurrence is a point of time at which an instance of the event happens during a computation. An occurrence function, denoted by @, is defined to represent the relationship between event instances and their occurrence time in <ref> [11, 16] </ref>. For example, @(e; 4) represents the occurrence time of the 4th instance of event e. However, at a time when the 4th instance of event e has not occurred, the original @-function of @(e; 4) is undefined.
Reference: [12] <author> F. Jahanian and A. Goyal, </author> <title> "A Formalism for Monitoring Real-Time Constraints at Runtime", </title> <booktitle> Proc. of Fault-Tolerant Computing Symposium(FTCS-20), </booktitle> <month> June, </month> <year> 1990. </year>
Reference-contexts: Definition 2 At time t during a computation, 8 event e, we define #(e; t) = &lt; 0 0 t &lt; @(e; 1)j t t @(e; 1)j t <ref> [4, 12] </ref> extends the @-function to represent oc-currence time of current and past relative instances. We further extend it to represent future relative instances [18] as well as current and past relative ones.
Reference: [13] <author> K.B. Kenny and K.-J. Lin, </author> <title> "Building Flexible Real-Time Systems using the FLEX Language", </title> <booktitle> Computer, </booktitle> <address> Vol.24, No.5, </address> <month> May </month> <year> 1991, </year> <month> pp.70-78. </month>
Reference-contexts: the enabling conditions of ECA rules in active real-time databases which (1) solves the ambiguity problems mentioned in the previous section and (2) permits the efficient detection algorithms in [18, 19] to be applied to active, real-time databases. 1.1 Related Work Runtime monitoring of timing constraints have been investigated in <ref> [4, 13, 17, 20, 18, 19] </ref>. In [17], an annotation method was introduced which marks the events of interests in Ada programs and uses RTL (Real Time Logic) formulas to specify the timing constraints to be enforced. <p> In [17], an annotation method was introduced which marks the events of interests in Ada programs and uses RTL (Real Time Logic) formulas to specify the timing constraints to be enforced. In FLEX <ref> [13] </ref>, certain predefined timing constraints can be monitored for violation. [4] presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper.
Reference: [14] <author> P.C. Konana, G.Liu, J.R. Durrett, A.K. Mok, </author> <title> A.B. Whinston, "Design of Time Cognizant Brokerages", </title> <year> 1997. </year>
Reference-contexts: ECA rules provide a natural way to express this type of user preference. As part of our on-going research on building time-cognizant electronic brokerages <ref> [14] </ref>, we are implementing an active rule manager in Java which can accept and compile user-defined business rules in ECA format and execute them when triggered in real time. Figure 2 shows the architecture of this rule manager. <p> Figure 2 shows the architecture of this rule manager. Detailed discussion of this e-brokerage project is out of the scope of this paper. Interested readers may see <ref> [14] </ref> for more details. 5.2 Extending the Specification Approach As shown in Figure 2, real-time market data feeds are received by our active rule manager as events.
Reference: [15] <author> M. Mansouri-Samani and M. Sloman, </author> <note> "GEM: </note>
Reference-contexts: The event data collected at runtime monitoring are usually used for postmortem analysis. Work on composite event specification and detection has been related mostly to the active database area. Various event operators, such as AND, OR, SEQUENCE, etc. have been used in <ref> [3, 8, 9, 22, 15] </ref> for specifying composite events. Different composite event detection approaches, e.g. Petri-net based [8], finite-state-machine based [9] as well as graph-based [3], are proposed. <p> Besides, the Past Temporal Logic does not distinguish between arbitrary event instances, while our approach uses occurrence time of various event instances for timing constraint specification. An interpreted Generalized Event Monitoring (GEM) language was presented in <ref> [15] </ref> which allows additional conditions, including timing constraints, to be combined with event operators for composite event specification.
References-found: 15

