URL: ftp://ftp.cs.umass.edu/pub/osl/papers/masplas96.ps.gz
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Email: (diwan@cs.umass.edu)  
Title: Goals and Design of the Whole Program Optimizer  
Author: Amer Diwan 
Affiliation: University of Massachusetts  
Abstract: We describe the design and implementation of the whole program optimizer (WPO) a framework for doing cross-module optimizations for Modula-3 programs. The WPO operates on a high-level intermediate representation and is thus able to take advantage of high-level information to get fast and efficient analysis and optimizations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen and Urs H olzle. </author> <title> Type feedback vs. concrete type inference: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 91-107, </pages> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: There are numerous other examples where type information gives valuable information to the optimizer which would otherwise have to be discovered by analysis. For example, type information has been used to resolve method invocations for object-oriented programs <ref> [1, 7, 6] </ref> and for doing alias analysis [5]. The implication of all this is that the optimizer must have high level information available to it.
Reference: [2] <author> Craig Chambers. </author> <title> The design and evaluation of the SELF compiler, an optimizing compiler for object-oriented programming languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Srivastava and Wall describe a system, OM, for doing executable editing. Executable editing suffers from the same problems as doing optimizations at link time: the high-level information is not present. Self and Cecil <ref> [2, 4] </ref> are dynamically-typed languages. Both Self and Cecil compilers generate code at run-time and have whole-program information present.
Reference: [3] <author> C. S. Collberg. </author> <title> Flexible Encapsulation. </title> <type> PhD thesis, </type> <institution> Lund University, Sweden, </institution> <year> 1992. </year>
Reference-contexts: The compiler generates directives to help the linker in rewriting code. Fernandez [7] describes a linker for doing cross-module optimizations of Modula-3 programs. Some of the optimizations she describes are similar to ones implemented in the WPO. Collberg's Zuse system <ref> [3] </ref> also does cross-module optimizations at link-time. Link-time optimizations are not suitable for us since we are concerned with optimizations based on high-level information which is usually absent at link time. Srivastava and Wall describe a system, OM, for doing executable editing.
Reference: [4] <author> Jeffery Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Srivastava and Wall describe a system, OM, for doing executable editing. Executable editing suffers from the same problems as doing optimizations at link time: the high-level information is not present. Self and Cecil <ref> [2, 4] </ref> are dynamically-typed languages. Both Self and Cecil compilers generate code at run-time and have whole-program information present.
Reference: [5] <author> Amer Diwan. </author> <title> Fast alias analysis using types. </title> <booktitle> Work in progress, </booktitle> <year> 1996. </year>
Reference-contexts: The WPO directly addresses the first two challenges. The WPO indirectly addresses the third challenge, that of having very fast analyses and optimizations, by making high-level information available to the analyses. We have demonstrated that analyses that use the high level information can be very fast and effective <ref> [6, 5] </ref>. 2.2 Availability of High-level information Modern programming languages, such as Modula-3 and Java, have rich type systems. All values and expressions are typed and type safety of expressions is enforced by the compiler and run-time system. The types contain valuable information that can be used by optimizations. <p> There are numerous other examples where type information gives valuable information to the optimizer which would otherwise have to be discovered by analysis. For example, type information has been used to resolve method invocations for object-oriented programs [1, 7, 6] and for doing alias analysis <ref> [5] </ref>. The implication of all this is that the optimizer must have high level information available to it. <p> * How many times is procedure p called from a given module? * How many times is a given call site executed? 1.7 5 Experience The WPO has been used as a testbed for implementing a range of analyses and optimizations and has proved to be a valuable research tool <ref> [6, 5] </ref>. Our experience has shown that it is relatively easy to add new analyses and transformations to the WPO.
Reference: [6] <author> Amer Diwan, Eliot Moss, and Kathryn McKin-ley. </author> <title> Simple and effective analysis of statically typed programs. </title> <note> Submitted for publication, </note> <month> March </month> <year> 1996. </year>
Reference-contexts: The WPO directly addresses the first two challenges. The WPO indirectly addresses the third challenge, that of having very fast analyses and optimizations, by making high-level information available to the analyses. We have demonstrated that analyses that use the high level information can be very fast and effective <ref> [6, 5] </ref>. 2.2 Availability of High-level information Modern programming languages, such as Modula-3 and Java, have rich type systems. All values and expressions are typed and type safety of expressions is enforced by the compiler and run-time system. The types contain valuable information that can be used by optimizations. <p> There are numerous other examples where type information gives valuable information to the optimizer which would otherwise have to be discovered by analysis. For example, type information has been used to resolve method invocations for object-oriented programs <ref> [1, 7, 6] </ref> and for doing alias analysis [5]. The implication of all this is that the optimizer must have high level information available to it. <p> * How many times is procedure p called from a given module? * How many times is a given call site executed? 1.7 5 Experience The WPO has been used as a testbed for implementing a range of analyses and optimizations and has proved to be a valuable research tool <ref> [6, 5] </ref>. Our experience has shown that it is relatively easy to add new analyses and transformations to the WPO.
Reference: [7] <author> Mary F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of Conference on Programming Language Design and Implementation, </booktitle> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <title> SIGPLAN, </title> <publisher> ACM Press. </publisher>
Reference-contexts: While this practice has many benefits, such as improved code reuse, it degrades performance if each module is compiled separately by making less information available to the optimizer. The solution to this problem is to use systems that can optimize multiple modules simultaneously <ref> [9, 7] </ref>. However, systems for doing cross-module optimizations for statically typed languages usually operate at link time and thus cannot benefit fully from the high level information traditionally available to compilers. <p> There are numerous other examples where type information gives valuable information to the optimizer which would otherwise have to be discovered by analysis. For example, type information has been used to resolve method invocations for object-oriented programs <ref> [1, 7, 6] </ref> and for doing alias analysis [5]. The implication of all this is that the optimizer must have high level information available to it. <p> Wall [9] describes a system for doing link time optimizations. The compiler generates directives to help the linker in rewriting code. Fernandez <ref> [7] </ref> describes a linker for doing cross-module optimizations of Modula-3 programs. Some of the optimizations she describes are similar to ones implemented in the WPO. Collberg's Zuse system [3] also does cross-module optimizations at link-time.
Reference: [8] <author> Bill Kalsow and Eric Muller. </author> <note> SRC Modula-3 Version 3.5. </note> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <address> Palo Alto, CA, </address> <year> 1995. </year> <month> 1.8 </month>
Reference-contexts: The stack gen generates code for a stack-based virtual machine with one module per file. The back end produces assembler code from the stack-based intermediate representation. The front end, stack gen, and back end are minor extensions of the components in the SRC Modula-3 compiler <ref> [8] </ref>. Our primary extension has been to modify the front end to generate our intermediate representation. The WPO reads in the intermediate representation for one or more modules, analyzes and optimizes them, and writes them out in the intermediate representation format.
Reference: [9] <author> David W. Wall. </author> <title> Register allocation at link time. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7) </volume> <pages> 264-275, </pages> <month> July </month> <year> 1986. </year> <month> 1.9 </month>
Reference-contexts: While this practice has many benefits, such as improved code reuse, it degrades performance if each module is compiled separately by making less information available to the optimizer. The solution to this problem is to use systems that can optimize multiple modules simultaneously <ref> [9, 7] </ref>. However, systems for doing cross-module optimizations for statically typed languages usually operate at link time and thus cannot benefit fully from the high level information traditionally available to compilers. <p> Wall <ref> [9] </ref> describes a system for doing link time optimizations. The compiler generates directives to help the linker in rewriting code. Fernandez [7] describes a linker for doing cross-module optimizations of Modula-3 programs. Some of the optimizations she describes are similar to ones implemented in the WPO.
References-found: 9

