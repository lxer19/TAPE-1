URL: http://www.csl.sri.com/reports/postscript/cses95.ps.gz
Refering-URL: http://www.csl.sri.com/fm-papers.html
Root-URL: 
Email: sree@csl.sri.com  
Phone: Phone: +1 (415) 859-2873 Fax: +1 (415) 859-2844  
Title: Formal Verification of Transformations on Dependency Graphs in Optimizing Compilers  
Author: P. Sreeranga Rajan 
Address: Menlo Park, CA 94025, USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: Dependency graphs are used as intermediate representations in optimizing compilers and software-engineering. In a transformational design approach, optimization and refinement transformations are used to transform dependency-graph-based specifications at higher abstraction levels to those at lower abstraction levels. An informal representation would lead to subtle errors, making it difficult to guarantee the correctness of the transformations. In this work, we investigated the formal specification and efficient mechanical verification of transformations on dependency graphs.
Abstract-found: 1
Intro-found: 1
Reference: [AC72] <author> Francis E. Allen and John Cocke. </author> <title> A catalogue of optimization transformations. </title> <editor> In Randall Rustin, editor, </editor> <booktitle> Design and Optimization of Compilers, Courant Computer Symposium 5. </booktitle> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <month> March </month> <year> 1972. </year>
Reference-contexts: If all the data flow edges to the join originate from sources whose data values are undefined, then the data value that can appear at the join is arbitrary. 3.3 Transformations on Dependency Graphs There are a variety of transformations described in literature <ref> [AC72, EMH + 93] </ref> for optimization and refinement of dependency graphs. Many of the optimization transformations are inspired by optimizing compiler techniques such as common subex-pression elimination, cross jumping tail merging and algebraic transformations involving commutativity, associativity, and distributivity. Other optimization transformations include loop transformations.
Reference: [Ang94] <author> C. Angelo. </author> <title> Formal Hardware Verification in a Silicon Compilation Environment by means of theorem proving. </title> <type> PhD thesis, K.U. </type> <address> Leuven/IMEC, Belgium, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: However, none of the other past work have dealt with transformations on dependency graphs in general. Most of the efforts have concentrated on specialized programming and specification languages languages <ref> [Ang94, McF93] </ref>. Many other efforts have provided a formal operational and denotational semantics for variations of dependency graph formalisms [dJ93,HK93,PBJ + 91,CBL92]. But, the operational and denotational semantics, unlike axiomatic semantics, are tied to a specific behavior model.
Reference: [ASU71] <author> A.V. Aho, Ravi Sethi, and J. D. Ullman. </author> <title> Code optimization and finite church-rosser systems. </title> <editor> In Randall Rustin, editor, </editor> <booktitle> Design and Optimization of Compilers, Courant Computer Symposium 5. </booktitle> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <month> March </month> <year> 1971. </year>
Reference-contexts: One of the earliest efforts on formalizing the correctness of 3 A more detailed treatment of specification and verification transformations is given in a forthcoming thesis [Raj]. 3 optimization of transformations is by Aho, Sethi and Ullman <ref> [ASU71] </ref>. They for-malized a restricted class of transformations known as Finite Church-Rosser (FCR) transformations, and provided simple tests to check properties of such transformations. However, none of the other past work have dealt with transformations on dependency graphs in general.
Reference: [CBL92] <author> R. Chapman, G. Brown, and M. Leeser. </author> <title> Verified high-level synthesis in BEDROC. </title> <booktitle> In Proceedings of the 1992 European Design Automation Conference. </booktitle> <publisher> IEEE Press, </publisher> <month> March </month> <year> 1992. </year>
Reference: [CRSS94] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In Ramayya Kumar and Thomas Kropf, editors, </editor> <booktitle> Preliminary Proceedings of the Second Conference on Theorem Provers in Circuit Design, </booktitle> <pages> pages 287-305, </pages> <address> Bad Herrenalb (Blackforest), Germany, </address> <month> September </month> <year> 1994. </year> <institution> Forschungszentrum Infor-matik an der Universitat Karlsruhe, </institution> <note> FZI Publication 4/94. 15 </note>
Reference: [Cyr93] <author> D. Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical report, </type> <institution> SRI International, </institution> <month> December </month> <year> 1993. </year> <note> Report CSL-93-12. </note>
Reference: [dJ93] <author> G.G de Jong. </author> <title> Generalized data flow graphs: theory and applications. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <address> The Netherlands, </address> <month> Oc-tober </month> <year> 1993. </year>
Reference: [EMH + 93] <author> W.J.A Engelen, P.F.A. Middelhoek, C. Huijs, J. Hofstede, and Th. Krol. </author> <title> Applying software transformations to SIL. </title> <type> Technical Report SPRITE deliverable Ls.a.5.2/UT/Y5/M6/1A, </type> <institution> Philips Research Laboratories, Eindhoven The Netherlands, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: In this work, we investigated the formal specification and efficient mechanical verification of transformations on dependency graphs. The specification and verification of the correctness of transformations we have presented here is independent of the behavior model underlying dependency graphs. A typical transformation employed in optimizing compilers is cross-jumping tail-merging <ref> [EMH + 93] </ref>, shown in Figure 2. In this transformation, two identical nodes on dependency paths that are never active at the same time are merged into one node. However, as we found out using our approach explained in this paper, the transformation does not preserve behavior. <p> If all the data flow edges to the join originate from sources whose data values are undefined, then the data value that can appear at the join is arbitrary. 3.3 Transformations on Dependency Graphs There are a variety of transformations described in literature <ref> [AC72, EMH + 93] </ref> for optimization and refinement of dependency graphs. Many of the optimization transformations are inspired by optimizing compiler techniques such as common subex-pression elimination, cross jumping tail merging and algebraic transformations involving commutativity, associativity, and distributivity. Other optimization transformations include loop transformations. <p> The details are omitted due to space limitation. 11 5 Formal Verification of Transformations In dependency-graph-based formalisms, there are a number of optimization and refinement transformations <ref> [EMH + 93, PBJ + 91] </ref>, such as optimization transformations are inspired by optimizing compiler techniques such as Common Subexpression Elimination, Cross-Jumping Tail-Merging, and algebraic transformations involving commutativity, associativity, and distributivity. Other optimization transformations include retiming.
Reference: [HK93] <author> C. Huijs and Th. Krol. </author> <title> A formal semantic model to fit SIL for transformational design. </title> <booktitle> In Proceedings of Euromicro Microprocessing and Microprogramming 39, </booktitle> <address> liverpool, </address> <month> September </month> <year> 1993. </year>
Reference: [KMN + 92] <author> Th. Krol, J.v. Meerbergen, C. Niessen, W. Smits, and J. Huisken. </author> <title> The SPRITE input language, an intermediate format for high level synthesis. </title> <booktitle> In Proceedings of European Design Automation Conference, </booktitle> <pages> pages 186-192, </pages> <address> Brussels, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: We show an example of such a graph in Figure 1. In this work, we have used a general notion of dependency graph based on an intermediate representation used in the SPRITE project at Philips Research Labs <ref> [KMN + 92] </ref>. fl To appear in the Proceedings of California Software Engineering Symposium, Irvine, CA, March 30, 1995 1 In literature, they are also known as control-flow/data-flow graphs, signal-flow graphs, and dependence graphs. 1 We use Prototype Verification System (PVS) [SOR93] from SRI International for mechanical verification.
Reference: [LOR + 93] <author> Patrick Lincoln, Sam Owre, John Rushby, N. Shankar, and Friedrich von Henke. </author> <title> Eight papers on formal verification. </title> <type> Technical Report SRI-CSL-93-4, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The process of verification involves checking relationships that are supposed to hold among entities. The checking is done by comparing the specified properties of the entities. PVS has been used for reasoning in many domains, such as in hardware verification [Cyr93,CRSS94,Raj94], protocol verification, and algorithm verification <ref> [LOR + 93, ORSvH95] </ref>.
Reference: [McF93] <author> M.C. McFarland. </author> <title> Formal analysis of correctness of behavioral transformations. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2(3) </volume> <pages> 231-257, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: However, none of the other past work have dealt with transformations on dependency graphs in general. Most of the efforts have concentrated on specialized programming and specification languages languages <ref> [Ang94, McF93] </ref>. Many other efforts have provided a formal operational and denotational semantics for variations of dependency graph formalisms [dJ93,HK93,PBJ + 91,CBL92]. But, the operational and denotational semantics, unlike axiomatic semantics, are tied to a specific behavior model.
Reference: [Mid94] <author> P.F.A. Middelhoek. </author> <title> Transformational design of digital signal processing applications. </title> <booktitle> In Proceedings of the ProRISC/IEEE workshop on CSSP, </booktitle> <pages> pages 175-180, </pages> <address> Eindhoven The Netherlands, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Other optimization transformations include loop transformations. Refinement transformations include type transformations such as real to integer, integer to Boolean, and implementing data relations of the nodes by concrete operators <ref> [Mid94] </ref>. 8 4 Formal Specification of Dependency Graphs At the level of abstraction we have chosen to specify behavior, we bring about high-level properties of dependency graphs, refinement and equivalence that should hold independent of a detailed behavior model 5 . <p> Other optimization transformations include retiming. Refinement transformations include type transformations such as real to integer, integer to Boolean, and implementing data relations of the nodes by concrete operators <ref> [Mid94] </ref>. The general method we employ to specify and verify transformations consists of the following steps: 1. Specify the structure of a dependency graph on which the transformation is to be applied. 2.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Further, it would not be possible to extend such concrete operational or denotational models to dependency graphs used in a multitude of formalisms such as in software engineering and real-time systems modeling. 2 Overview of PVS The Prototype Verification System 4 (PVS) <ref> [SOR93, ORSvH95] </ref> is an environment for specifying entities such as hardware/software models and algorithms, and verifying properties associated with the entities. An entity is usually specified by asserting a small number of general properties that are known to be true. <p> The process of verification involves checking relationships that are supposed to hold among entities. The checking is done by comparing the specified properties of the entities. PVS has been used for reasoning in many domains, such as in hardware verification [Cyr93,CRSS94,Raj94], protocol verification, and algorithm verification <ref> [LOR + 93, ORSvH95] </ref>.
Reference: [PBJ + 91] <author> Keshav Pingali, Micah Beck, Richard Johnson, Mayan Moudgill, and Paul Stodghill. </author> <title> Dependence flow graphs: An algebraic approach to program dependencies. </title> <booktitle> In 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 67-78, </pages> <month> January </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: The details are omitted due to space limitation. 11 5 Formal Verification of Transformations In dependency-graph-based formalisms, there are a number of optimization and refinement transformations <ref> [EMH + 93, PBJ + 91] </ref>, such as optimization transformations are inspired by optimizing compiler techniques such as Common Subexpression Elimination, Cross-Jumping Tail-Merging, and algebraic transformations involving commutativity, associativity, and distributivity. Other optimization transformations include retiming.
Reference: [Raj] <author> Sreeranga P. Rajan. </author> <title> Transformations on Dependency Graphs: Formal Specification and Efficient Mechanical Verification. </title> <type> PhD thesis, </type> <institution> University of British Columbia, </institution> <address> Vancouver, Canada, </address> <publisher> forthcoming. </publisher>
Reference-contexts: One of the earliest efforts on formalizing the correctness of 3 A more detailed treatment of specification and verification transformations is given in a forthcoming thesis <ref> [Raj] </ref>. 3 optimization of transformations is by Aho, Sethi and Ullman [ASU71]. They for-malized a restricted class of transformations known as Finite Church-Rosser (FCR) transformations, and provided simple tests to check properties of such transformations. <p> The transformations we have verified are being used in industry in optimizing 14 compilers and high-level synthesis of hardware. Applications of our work on depen-dency graphs in other fields such as real-time systems and software engineering have been described in a forthcoming thesis <ref> [Raj] </ref>. As part of future work, we would like to investigate the correctness of more complex transformations involving scheduling, and a tighter integration of formal methods in optimizing compilers and software engineering.
Reference: [Raj94] <author> P. Sreeranga Rajan. </author> <title> Transformations in high level synthesis: Specification and verification. </title> <type> Technical Report NL-TN 118/94, </type> <institution> Philips Research Laboratories, Eindhoven, </institution> <address> The Netherlands, </address> <month> April </month> <year> 1994. </year>
Reference: [SOR93] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: A Reference Manual (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: used in the SPRITE project at Philips Research Labs [KMN + 92]. fl To appear in the Proceedings of California Software Engineering Symposium, Irvine, CA, March 30, 1995 1 In literature, they are also known as control-flow/data-flow graphs, signal-flow graphs, and dependence graphs. 1 We use Prototype Verification System (PVS) <ref> [SOR93] </ref> from SRI International for mechanical verification. In this work, we investigated the formal specification and efficient mechanical verification of transformations on dependency graphs. The specification and verification of the correctness of transformations we have presented here is independent of the behavior model underlying dependency graphs. <p> Further, it would not be possible to extend such concrete operational or denotational models to dependency graphs used in a multitude of formalisms such as in software engineering and real-time systems modeling. 2 Overview of PVS The Prototype Verification System 4 (PVS) <ref> [SOR93, ORSvH95] </ref> is an environment for specifying entities such as hardware/software models and algorithms, and verifying properties associated with the entities. An entity is usually specified by asserting a small number of general properties that are known to be true.
References-found: 18

