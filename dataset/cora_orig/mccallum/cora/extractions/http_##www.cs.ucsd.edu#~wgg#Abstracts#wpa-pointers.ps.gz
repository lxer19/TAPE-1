URL: http://www.cs.ucsd.edu/~wgg/Abstracts/wpa-pointers.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/wpa-pointers.html
Root-URL: http://www.cs.ucsd.edu
Email: fatkinson,wggg@cs.ucsd.edu  
Title: Effective Whole-Program Analysis in the Presence of Pointers  
Author: Darren C. Atkinson and William G. Griswold 
Address: San Diego, CA 92093-0114  
Affiliation: Department of Computer Science Engineering, 0114 University of California, San Diego  
Abstract: Understanding large software systems is difficult. Traditionally, automated tools are used to assist program understanding. However, the representations constructed by these tools often require prohibitive time and space. Demand-driven techniques can be used to reduce these requirements. However, the use of pointers in modern languages introduces additional problems that do not integrate well with these techniques. We present new techniques for effectively coping with pointers in large software systems written in the C programming language and use our techniques to implement a program slicing tool. First, we use a fast, flow-insensitive, points-to analysis before traditional data-flow analysis. Second, we allow the user to parameterize the points-to analysis so that the resulting program slices more closely match the actual program behavior. Such information cannot easily be obtained by the tool or might otherwise be deemed unsafe. Finally, we present data-flow equations for dealing with pointers to local variables in recursive programs. These equations allow the user to select an arbitrary amount of calling context in order to better trade performance for precision. To validate our techniques, we present empirical results using our program slicer on large programs. The results indicate that cost-effective analysis of large programs with pointers is feasible using our techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Pointers to local variables are commonly used in C programs to emulate passing parameters by reference, which the language itself does not support. Pointers to local variables in the presence of recursion require changes to the traditional bit-vector equations for data-flow analysis <ref> [1] </ref>, since different activations of a local variable may be referenced in functions other than the function in which it is declared.
Reference: [2] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 1627, </pages> <address> Berlin, Germany, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Unfortunately, the use of pointers in modern programming languages hinders the construction of whole-program analysis tools that are both efficient and sufficiently precise. First, the use of pointers negates the performance benefits of demand-driven techniques <ref> [2, 3, 7] </ref> since determining the memory locations possibly referenced through a pointer typically requires a global analysis over the program. <p> in a language without point 1 extern int *p; main ( ) - int x; if (rand ( )) p = &x; g ( ); extern int *p; f ( ) - *p = 3; - g ( ) - - pointer variable p is referenced in all files. ers <ref> [2, 6] </ref>. The approach transparently demand-derives all representations. However, representations such as the abstract syntax tree (AST) that are infrequently used are discarded and recomputed when needed to reduce memory requirements. Representations such as the call-graph that are costly to compute, but inexpensive to store, are persistently retained on disk. <p> mostly insensitive to the improvement in precision, typically yielding a 3% decrease in the number of statements. 2 Integrating Points-To Analysis with Demand-Driven Analyses Demand-driven techniques attempt to save space and time by computing only those data-flow facts and portions of supporting representations that are necessary to perform the analysis <ref> [2, 3, 7] </ref>. In this way, large programs can be handled more economically since the amount of information computed and stored is greatly reduced. Effective demand-driven analysis depends upon quickly identifying which portions of a representation are required next and efficiently computing those portions. <p> Effective demand-driven analysis depends upon quickly identifying which portions of a representation are required next and efficiently computing those portions. In backward slicing, for example, it is necessary to quickly identify all the callers of a procedure and efficiently construct the CFG for those calling procedures <ref> [2] </ref>. Because determining the callers of a procedure requires a global analysis of the program, our demand-driven approach saves the call-graph to disk for future invocations of the slicing tool. <p> (3, &y); void f (int x) - y = x; int g (int x) - return x; - int h (int x, void *p) - return x + *(int *) p; - int i (int x, char *p) - return *p + x; - analysis may then become too expensive <ref> [2] </ref>. Furthermore, the increase in precision may be small [14] or may not yield substantially better data-flow information [16]. One way to improve precision without unacceptable cost is to permit the tool user to provide additional, easily specified information to improve the precision of the points-to analysis.
Reference: [3] <author> E. Duesterwald and M. L. Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Proceedings of the 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 3748, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Unfortunately, the use of pointers in modern programming languages hinders the construction of whole-program analysis tools that are both efficient and sufficiently precise. First, the use of pointers negates the performance benefits of demand-driven techniques <ref> [2, 3, 7] </ref> since determining the memory locations possibly referenced through a pointer typically requires a global analysis over the program. <p> mostly insensitive to the improvement in precision, typically yielding a 3% decrease in the number of statements. 2 Integrating Points-To Analysis with Demand-Driven Analyses Demand-driven techniques attempt to save space and time by computing only those data-flow facts and portions of supporting representations that are necessary to perform the analysis <ref> [2, 3, 7] </ref>. In this way, large programs can be handled more economically since the amount of information computed and stored is greatly reduced. Effective demand-driven analysis depends upon quickly identifying which portions of a representation are required next and efficiently computing those portions.
Reference: [4] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM '94 SIGPLAN Conference on Programming Language Design and Implementation, pages 2024, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This process is similar to the mapping and unmapping of nonvisible variables <ref> [4, 10] </ref>. Consider an assignment made by dereferencing a pointer variable p (Equation 5.5). If the points-to set of p overlaps with N , then a local variable declared in another function has been defined.
Reference: [5] <author> J. I. Gobat and D. C. Atkinson. </author> <title> The FElt system: User's guide and reference manual. </title> <institution> Computer Science Technical Report CS94-376, University of California, San Diego, Department of Computer Science & Engineering, </institution> <year> 1994. </year>
Reference-contexts: However, the prototypes option works well for all three programs. Strong prototype filtering works extremely well, so much so that the results do not improve further even if the arrays option is enabled. Since one of the co-authors is the author of BURLAP <ref> [5] </ref>, we verified its results by hand and found them to be near-perfect. 5.2 Program Slicing To evaluate the effectiveness of our approach in data-flow analysis, we have performed several program slices of our example programs.
Reference: [6] <author> W. G. Griswold and D. C. Atkinson. </author> <title> Managing the design trade-offs for a program understanding and transformation tool. </title> <journal> Journal of Systems and Software, </journal> <volume> 30(12):99116, </volume> <month> July August </month> <year> 1995. </year>
Reference-contexts: in a language without point 1 extern int *p; main ( ) - int x; if (rand ( )) p = &x; g ( ); extern int *p; f ( ) - *p = 3; - g ( ) - - pointer variable p is referenced in all files. ers <ref> [2, 6] </ref>. The approach transparently demand-derives all representations. However, representations such as the abstract syntax tree (AST) that are infrequently used are discarded and recomputed when needed to reduce memory requirements. Representations such as the call-graph that are costly to compute, but inexpensive to store, are persistently retained on disk.
Reference: [7] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedu-ral dataflow analysis. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 104 115, </pages> <address> Washington, DC, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Unfortunately, the use of pointers in modern programming languages hinders the construction of whole-program analysis tools that are both efficient and sufficiently precise. First, the use of pointers negates the performance benefits of demand-driven techniques <ref> [2, 3, 7] </ref> since determining the memory locations possibly referenced through a pointer typically requires a global analysis over the program. <p> mostly insensitive to the improvement in precision, typically yielding a 3% decrease in the number of statements. 2 Integrating Points-To Analysis with Demand-Driven Analyses Demand-driven techniques attempt to save space and time by computing only those data-flow facts and portions of supporting representations that are necessary to perform the analysis <ref> [2, 3, 7] </ref>. In this way, large programs can be handled more economically since the amount of information computed and stored is greatly reduced. Effective demand-driven analysis depends upon quickly identifying which portions of a representation are required next and efficiently computing those portions.
Reference: [8] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, 2nd edition, </address> <year> 1988. </year>
Reference-contexts: First, the use of pointers negates the performance benefits of demand-driven techniques [2, 3, 7] since determining the memory locations possibly referenced through a pointer typically requires a global analysis over the program. For example in the C programming language <ref> [8] </ref>, all files must be analyzed to account for the use of pointers in initializers for static variables, regardless of whether a file contains a function that might be reachable during subsequent data-flow analysis.
Reference: [9] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In Proceedings of the 4th International Conference on Compiler Construction, </booktitle> <pages> pages 125140, </pages> <address> Paderborn, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Proceeding backward through the function, the next statement examined is the recursive call to f (). When slicing into the recursive call, we need to remove local variables from the data-flow sets (Equations 3.1 and 3.2) <ref> [9] </ref>. This step is necessary to avoid finding a definition of the same local variable but with a different activation in the recursive call. Continuing our example, the data-flow sets become empty after removing x, resulting in no further information being added to the slice by the recursive call.
Reference: [10] <author> W. A. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 5667, </pages> <address> Albu-querque, NM, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This process is similar to the mapping and unmapping of nonvisible variables <ref> [4, 10] </ref>. Consider an assignment made by dereferencing a pointer variable p (Equation 5.5). If the points-to set of p overlaps with N , then a local variable declared in another function has been defined.
Reference: [11] <author> M. M. Lehman and L. A. Belady, </author> <title> editors. Program Evolution: Processes of Software Change. </title> <publisher> Academic Press, </publisher> <address> Orlando, FL, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Large software systems are difficult to understand. These systems have typically evolved over several years, and as systems evolve, their structure degrades <ref> [11] </ref>. This degenerated structure increases maintenance costs, since a single change may no longer be localized to a module, but rather is dispersed throughout the code [13].
Reference: [12] <author> G. N. Naumovich, L. A. Clarke, and L. J. Osterweil. </author> <title> Verifi--cation of communication protocols using data flow analysis. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 93105, </pages> <address> San Francisco, CA, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: As another example, an invariant checker infers facts about the state of the program and checks those facts against assertions provided by the programmer <ref> [12] </ref>. Unfortunately, the use of pointers in modern programming languages hinders the construction of whole-program analysis tools that are both efficient and sufficiently precise.
Reference: [13] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12):10531058, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: These systems have typically evolved over several years, and as systems evolve, their structure degrades [11]. This degenerated structure increases maintenance costs, since a single change may no longer be localized to a module, but rather is dispersed throughout the code <ref> [13] </ref>. Consequently, a maintainer needs global, rather than local, knowledge about the system in order to correctly reason about the effect of a proposed change. For large software systems, gathering this global knowledge can be a time-consuming activity.
Reference: [14] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13 22, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Furthermore, the increase in precision may be small <ref> [14] </ref> or may not yield substantially better data-flow information [16]. One way to improve precision without unacceptable cost is to permit the tool user to provide additional, easily specified information to improve the precision of the points-to analysis.
Reference: [15] <author> M. Shapiro and S. Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In Proceedings of the 4th International Symposium on Static Analysis, </booktitle> <pages> pages 1634, </pages> <address> Paris, France, </address> <month> Jan-uary </month> <year> 1997. </year>
Reference-contexts: required global analysis. 2 * We use Steensgaard's near-linear time, context-insensitive, flow-insensitive, points-to analysis, which models storage as equivalence classes of locations [18]. 1 Although not as precise as some techniques, its timespace characteristics are superior and the difference in precision is often not reflected in the subsequent data-flow analysis <ref> [15] </ref>. * To avoid an extra pass over the program to perform the global analysis, we piggyback the computation of points-to information with the construction of the portions of the CFG required for the subsequent data-flow analysis. <p> Table 5 shows the effects of user-parameterization of the points-to analysis on program slicing. The improvements due to the arrays, structs, and mallocs parameters are small (at most 3%), which suggests that the precision of the slicing algorithm is relatively insensitive to changes in the points-to classes <ref> [15] </ref>. This is in contrast to our original expectations, since we saw significant improvements in the number of points-to classes using these parameters. However, the slices performed using the prototypes option show a dramatic improvement.
Reference: [16] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 114, </pages> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Furthermore, the increase in precision may be small [14] or may not yield substantially better data-flow information <ref> [16] </ref>. One way to improve precision without unacceptable cost is to permit the tool user to provide additional, easily specified information to improve the precision of the points-to analysis. Our approach is to allow the user to parameterize several aspects of the analysis in terms of the language syntax.
Reference: [17] <author> B. Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In Proceedings of the 6th International Conference on Compiler Construction, </booktitle> <pages> pages 136150, </pages> <address> Linkoping, Sweden, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Since these objects are of different types, they are likely distinct. Although distinguishing structure members in points-to analysis can increase precision, sometimes the benefit is small and is not justified by the higher cost. In the worst case the analysis may require exponential time when structure members are distinguished <ref> [17] </ref>. To permit managing the time and space complexity of the analysis, our analysis distinguishes structure members only when chosen as an option by the user. Thus, references to a.x and a.y are normally treated as a reference to a. <p> For example in GCC, the array commutativity parameter prevents merging of separate arrays of structures, and the structure and prototype parameters distinguish the individual structure components. However, in some cases, the effects of one parameter will 3 The points-to analysis is similar to that described in <ref> [17] </ref>, but assumes that adjacent structure members are infinitely far apart and thus does not take into account the size of an access during the analysis. 4 subsume the effects of another.
Reference: [18] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 3241, </pages> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Second, how does the use of pointers in large systems impact the precision of an analysis? Third, how can data-flow analysis be performed in the presence of pointers to local variables and recursion? First, because points-to information cannot be demand-derived, we use Steensgaard's near-linear time, context-insensitive, flow-insensitive, points-to analysis algorithm <ref> [18] </ref>. To avoid the cost of an extra pass over the program, the points-to analysis is piggybacked with the demand construction of the control-flow graph (CFG). <p> Our approach is to demand all the points-to information on invocation of the first slice, employing three techniques to minimize the impact of the required global analysis. 2 * We use Steensgaard's near-linear time, context-insensitive, flow-insensitive, points-to analysis, which models storage as equivalence classes of locations <ref> [18] </ref>. 1 Although not as precise as some techniques, its timespace characteristics are superior and the difference in precision is often not reflected in the subsequent data-flow analysis [15]. * To avoid an extra pass over the program to perform the global analysis, we piggyback the computation of points-to information with <p> As a consequence, all pointers that are associated with a particular malloc () call site are treated as referencing the same memory address (assuming array indices are ignored). This approach, which we use, is simple to implement and often yields adequate precision <ref> [18] </ref>. For a program using the xmalloc () function described above, the program will contain several distinct calls to xmalloc (), but only one static call to malloc () (by xmalloc () itself).
Reference: [19] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1991. </year>
Reference-contexts: For example, although private memory allocators may not be used for performance reasons, they are often used for reasons of encapsulation and code reuse. The constructor and destructor functions in C++ <ref> [19] </ref> are obvious examples. Distinguishing structure members and filtering points-to classes based on their computed prototypes are also necessary in C++, since its classes are little more than structures composed of many function pointers and some data.
Reference: [20] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352357, </volume> <month> July </month> <year> 1984. </year> <month> 10 </month>
Reference-contexts: The combination of degraded structure and use of sophisticated language constructs makes large systems especially difficult to understand, maintain, and enhance. Automated semantic tools have been proposed as a solution to this maintenance problem since they can eliminate some tedious, error-prone tasks. For example, a program slicer <ref> [20] </ref> helps determine the effects of a proposed change by computing the set of statements that might affect the value of a given variable. As another example, an invariant checker infers facts about the state of the program and checks those facts against assertions provided by the programmer [12].
References-found: 20

