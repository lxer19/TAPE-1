URL: http://fmg-www.cs.ucla.edu/classes/239_2.fall98/papers/flexibility_in_OOOS.ps
Refering-URL: http://fmg-www.cs.ucla.edu/classes/239_2.fall98/weekly.html
Root-URL: http://www.cs.ucla.edu
Title: Flexibility in Object-Oriented Operating Systems: A Review  
Author: Vinny Cahill 
Note: Permission to copy without fee all or part of this material is granted provided that the TCD copyright notice and the title of the document appear. To otherwise copy or republish requires explicit permission in writing from TCD.  
Address: College Dublin  
Affiliation: Department of Computer Science Trinity  
Abstract: This report presents a review of recent research into flexible operating systems. In this context, flexible operating systems are taken to be those whose designs have been motivated to some degree by the desire to allow the system to be tailored, either statically or dynamically, to the requirements of specific applications or application domains. We begin by presenting a review of recent research into flexible system software with particular emphasis on the motivations for providing flexibility and the different approaches to achieving flexibility that are available. We then provide an overview of the main technologies for achieving flexibility in system software that have been employed. As it turns out, the use of object orientation is a common feature of many flexible operating systems. Thus, in order to more fully illustrate the use of object-orientation to achieve flexibility, we review a number of Document Identifier TCD-CS-96-05 Document Status Technical Report Created 12 July 1996 Revised 24 May 1996 Distribution Public c fl 1996 TCD CS the most influential object-oriented operating systems in detail.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Vadim Abrossimov, Marc Rozier, and Marc Shapiro. </author> <title> Generic virtual memory management for operating system kernels. </title> <booktitle> In Proceedings of the 12 th Symposium on Operating Systems Principles, </booktitle> <pages> pages 123-136. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> December </month> <year> 1989. </year> <note> Also Technical Report CS/TR-89-18.2, Chorus Systemes. </note>
Reference: [2] <editor> ACM Special Interest Group on Operating Systems. </editor> <booktitle> Proceedings of the 14 th Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1993. </year> <note> Also Operating Systems Review, 27(5). </note>
Reference: [3] <editor> ACM Special Interest Group on Operating Systems. </editor> <booktitle> Proceedings of the 6 th SIGOPS Euro-pean Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference: [4] <editor> ACM Special Interest Group on Operating Systems. </editor> <booktitle> Proceedings of the 15 th Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year> <note> Also Operating Systems Review, 29(5). </note>
Reference: [5] <author> Thomas E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Proceedings of the 3 rd Workshop on Workstation Operating Systems, </booktitle> <pages> pages 92-94. </pages> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: In particular, the Spin kernel and extensions are implemented in a type-safe language (Modula-3). As a result, extensions cannot access memory or execute privileged instructions unless they have been given explicit access through an interface. Application-Specific Operating Systems In <ref> [5] </ref>, Anderson put the case for what he termed "application-specific operating systems".
Reference: [6] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. Sched-uler activations: </author> <title> Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proceedings of the 13 th Symposium on Operating Systems Principles, </booktitle> <pages> pages 95-109. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> October </month> <year> 1991. </year> <note> Also Operating Systems Review, 25(5). </note>
Reference-contexts: All higher level operating-system mechanisms and policies, which could benefit from application-oriented specialisation, are intended to be implemented in user-level servers and libraries. Anderson's position was probably motivated by his earlier experience with scheduler activations <ref> [6] </ref> in which the implementation of kernel threads in Topaz was modified so that the kernel was only responsible for the allocation of processors to applications while the applications themselves were made responsible for actually scheduling threads (in user mode).
Reference: [7] <author> Holger Assenmacher, Thomas Breitbach, Peter Buhler, Volker Huebsch, and Reinhard Schwarz. </author> <title> The PANDA system architecture a pico-kernel approach. </title> <booktitle> In Proceedings of the REFERENCES 29 4 th Workshop on Future Trends of Distributed Computing Systems, </booktitle> <pages> pages 470-476. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: While Anderson did not describe a specific operating system implemented according to this principle, a number of other researchers have proposed operating system designs conforming to this general approach, most notably Panda <ref> [7] </ref>, V ++ [21], and ExOS/Aegis [29]. In each case, the designers have proposed kernels that are responsible only for mediating application requests for physical resources and enforcing hardware protection boundaries between applications as suggested by Anderson. <p> Moreover, system classes may be exposed to applications so that they can take advantage of inheritance and polymorphism to provide specialised implementations of some system services for their own needs as in Panda <ref> [7] </ref>. Choices is reviewed in detail in section 2.1 as being representative of this approach. Recent multi-server microkernel-based operating systems have also made extensive use of object orientation, in particular, to define the interfaces between the various servers making up the (distributed) operating system [32, 52].
Reference: [8] <author> Arindam Banerji and David L. Cohn. </author> <title> An infrastructure for application-specific customisa-tion. </title> <booktitle> In Proceedings of the 6 th SIGOPS European Workshop [3], </booktitle> <pages> pages 154-159. </pages>
Reference: [9] <author> Brian N. Bershad, Stefan Savage, Przemyslaw Pardyak, Emin Gun Sirer, Marc E. Fiuczyn-ski, David Becker, Craig Chambers, and Susan Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15 th Symposium on Operating Systems Principles [4], </booktitle> <pages> pages 267-284. </pages> <note> Also Operating Systems Review, 29(5). </note>
Reference-contexts: In that sense, Chorus may be said to provide an extensible kernel. This deficiency of previous microkernels was also addressed explicitly in the design of the Spin kernel <ref> [9] </ref>. The main goal of the Spin design was to make the kernel extensible and configurable by allowing applications to dynamically install so-called extensions into the kernel; such extensions may change both the interface and implementation of the kernel.
Reference: [10] <author> Andrew Black, Norman C. Hutchinson, Eric Jul, Henry M. Levy, and Larry Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: A number of different parameter passing modes for references and pointers are supported including standard modes such as call-by-value, call-by-result, and call-by-value-result but not call-by-reference. For references, call-by-value-result is the default. In addition to these standard parameter passing modes, call-by-copy and a variant of Emerald's call-by-move <ref> [10] </ref>, referred to as call-by-vanish, are supported. Call-by-vanish moves the target object but does not maintain local references to it at the source node. Finally, call-by-likeness allows a likeness to be sent in a remote invocation request.
Reference: [11] <author> David L. Black. </author> <title> Scheduling support for concurrency and parallelism in the Mach operating system. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference: [12] <author> David L. Black, David B. Golub, Daniel P. Julin, Richard F. Rashid, Richard P. Draves, Randall W. Dean, Alessandro Florin, Joseph Barrera, Hideyuki Tokuda, Gerald Malan, and David Bohman. </author> <title> Microkernel operating system architecture and Mach. </title> <booktitle> In Proceedings of theUsenix Workshop on Microkernels and Other Kernel Architectures [63], </booktitle> <pages> pages 11-30. </pages>
Reference-contexts: introduction of microkernels has been largely motivated by the promise of better support for distributed and multi-processor systems (i.e., a response to recent technological advances) as well as improved modularity and flexibility albeit at the cost of poorer performance in some cases <ref> [12] </ref>. However, the use of microkernel technology is not the only possible approach to improved flexibility. <p> For example, the Mach microkernel has been used to support various operating system personalities ranging from Ms-dos to 4.3Bsd Unix and Vms <ref> [12] </ref>. Likewise, the Chorus microkernel supports both Unix and an object-support operating system personality known as Cool [50]. In general, multiple versions of the same personality can coexist.
Reference: [13] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <address> Ben-jamin/Cummings, Redwood City, CA, </address> <year> 1994. </year>
Reference-contexts: Object-oriented operating systems are attractive for a number of reasons. Object orientation is currently the software engineering discipline of choice in the computer industry. The advantages from the software engineering point of view of using object-oriented analysis, design, and implementation techniques are well known <ref> [13] </ref> and include code reuse, improved portability, easier maintenance, and incremental extensibility. For these reasons, it seems only natural to use these same techniques in the design and implementation of operating systems.
Reference: [14] <author> Luis-Felipe Cabrera and Norman C. Hutchinson, </author> <title> editors. </title> <booktitle> Proceedings of the 3 rd International Workshop on Object-Orientation in Operating Systems. </booktitle> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year>
Reference: [15] <author> Luis-Felipe Cabrera and Eric Jul, </author> <title> editors. </title> <booktitle> Proceedings of the 2 nd International Workshop on Object-Orientation in Operating Systems. </booktitle> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> September </month> <year> 1992. </year>
Reference: [16] <author> Luis-Felipe Cabrera, Vincent Russo, and Marc Shapiro, </author> <title> editors. </title> <booktitle> Proceedings of the 1 st International Workshop on Object-Orientation in Operating Systems. </booktitle> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> October </month> <year> 1991. </year>
Reference: [17] <author> Vinny Cahill. </author> <title> Research projects in object-support, object-oriented, and extensible operating systems. </title> <note> WWW page http://www.dsg.cs.tcd.ie/research/os relwork.html, </note> <month> November </month> <year> 1995. </year>
Reference: [18] <author> Roy H. Campbell, John H. Hine, and Vincent F. Russo. </author> <title> Choices for mission critical computing. </title> <booktitle> Studies in Computer and Communication Systems, chapter 2, </booktitle> <pages> pages 11-20. </pages> <publisher> IOS Press, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1992. </year>
Reference-contexts: This section continues by reviewing a number of object-oriented operating systems that have been particularly influential or are otherwise noteworthy. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 10 2.1 Choices An Object-Oriented Operating System Framework Choices <ref> [18, 19] </ref> is an object-oriented operating system under development at the University of Illinois at Urbana-Champaign since 1987. Native implementations of Choices exist for the Sun SPARCstation 1 and 2, the Encore Multimax, Ibm-compatible Intel 386- and 486-based personal computers (pcs) and the Intel Hypercube. <p> The Choices design is intended to allow the construction of customised operating systems by permitting a high degree of application-specific specialisation including the provision of support for real-time and embedded systems <ref> [18] </ref>. A design methodology based on object-orientation and the use of frameworks was adopted in order to support customisation as well as to facilitate both design and code reuse between members of the operating system family through the use of inheritance. <p> Moreover, the Choices experience has provided valuable guidance to the developers of other object-oriented operating systems concerning the design, organisation, and use of frameworks. On the other hand, Choices is clearly deficient in a number of respects. Notwithstanding the fact that some support for embedded applications was provided <ref> [18] </ref>, Choices essentially provides a family of multi-user/multi-tasking operating systems based on a kernel architecture that is somewhere between a traditional monolithic kernel and a microkernel.
Reference: [19] <author> Roy H. Campbell, Nayeem Islam, and Peter Madany. </author> <title> Choices, Frameworks and Refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <month> Summer </month> <year> 1992. </year>
Reference-contexts: The use of object-oriented techniques to design an operating system provides the opportunity to build highly customisable systems. Object-oriented operating systems, such as Choices, that are based on frameworks support code reuse and customisation through the use of inheritance <ref> [19] </ref>. Moreover, system classes may be exposed to applications so that they can take advantage of inheritance and polymorphism to provide specialised implementations of some system services for their own needs as in Panda [7]. Choices is reviewed in detail in section 2.1 as being representative of this approach. <p> This section continues by reviewing a number of object-oriented operating systems that have been particularly influential or are otherwise noteworthy. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 10 2.1 Choices An Object-Oriented Operating System Framework Choices <ref> [18, 19] </ref> is an object-oriented operating system under development at the University of Illinois at Urbana-Champaign since 1987. Native implementations of Choices exist for the Sun SPARCstation 1 and 2, the Encore Multimax, Ibm-compatible Intel 386- and 486-based personal computers (pcs) and the Intel Hypercube. <p> Persistent C ++ objects are supported as a specialisation of the file system sub-framework. User 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 13 defined subclasses of the class AutoLoadPersistentObject support automatic activation (and deactivation) on demand <ref> [19] </ref>. References between such persistent C ++ objects are implemented as instances of subclasses of the class Reference. An instance of Reference stores a descriptor for the target persistent object that includes its location in the file system.
Reference: [20] <author> Roy H. Campbell and Peter W. Madany. </author> <title> Considerations of persistence and security in choices, an object-oriented operating system. </title> <editor> In John Rosenberg and J. Leslie Keedy, editors, </editor> <booktitle> Security and Persistence, Workshops in Computing, </booktitle> <pages> pages 289-300. </pages> <publisher> Springer-Verlag, </publisher> <address> REFERENCES 30 May 1990. </address> <booktitle> Proceedings of the International Workshop on Computer Architectures to Support Security and Persistence of Information. </booktitle>
Reference-contexts: Page-based dsm is supported by a specialisation of the memory-management sub-framework that allows a single memory object to be mapped in multiple address spaces on different nodes of a network. The dsm protocol employed supports a multiple-reader/single-writer policy using write invalidation <ref> [38, 20] </ref>. Access to remotely created C ++ objects is also supported by an extension of the kernel object proxy mechanism that allows access to remote objects using the underlying Choices message-passing primitives [22]. Persistent C ++ objects are supported as a specialisation of the file system sub-framework. <p> Use of Reference also allows the use of references to persistent C ++ objects to be syntactically identical to the use of references to ordinary C ++ objects. Garbage collection of acyclic persistent data structures based on reference counting is also supported <ref> [20] </ref>. Finally, dsm can be used to access remote persistent objects. 2.2 Lipto Orthogonality of Modularity and Protection Lipto [27, 28] is an object-oriented operating system developed at the University of Arizona between 1991 and 1993.
Reference: [21] <author> David R. Cheriton and Kenneth J. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 179-193. </pages> <publisher> Usenix Association, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: While Anderson did not describe a specific operating system implemented according to this principle, a number of other researchers have proposed operating system designs conforming to this general approach, most notably Panda [7], V ++ <ref> [21] </ref>, and ExOS/Aegis [29]. In each case, the designers have proposed kernels that are responsible only for mediating application requests for physical resources and enforcing hardware protection boundaries between applications as suggested by Anderson.
Reference: [22] <author> Amitabh Dave, Mohlalefi Sefika, and Roy H. Campbell. </author> <title> Proxies, application interfaces, </title> <booktitle> and distributed systems. In Cabrera and Jul [15], </booktitle> <pages> pages 212-220. </pages>
Reference-contexts: The dsm protocol employed supports a multiple-reader/single-writer policy using write invalidation [38, 20]. Access to remotely created C ++ objects is also supported by an extension of the kernel object proxy mechanism that allows access to remote objects using the underlying Choices message-passing primitives <ref> [22] </ref>. Persistent C ++ objects are supported as a specialisation of the file system sub-framework. User 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 13 defined subclasses of the class AutoLoadPersistentObject support automatic activation (and deactivation) on demand [19].
Reference: [23] <author> Thomas W. Doeppner. </author> <title> The Spring operating system: Internals overview. </title> <booktitle> Tutorial presented at 1 st Symposium on Operating Systems Design and Implementation, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Thus Spring was intended to improve "dramatically" on current systems and, in particular, to make distributed programming "significantly" easier while still supporting existing applications and interworking with existing networked systems <ref> [23] </ref>. The architecture of Spring is characterised by a strong emphasis on modularity. All the components of the system are defined by tightly-specified fully-abstract interfaces allowing multiple implementations of any component to coexist transparently to its clients. Most components of the operating system are thus regarded as replaceable parts.
Reference: [24] <author> Richard P. Draves. </author> <title> The case for run-time replaceable kernel modules. </title> <booktitle> In Proceedings of the 4 rd Workshop on Workstation Operating Systems [37], </booktitle> <pages> pages 160-164. </pages>
Reference: [25] <author> Peter Druschel. </author> <title> Efficient support for incremental customization of OS services. </title> <booktitle> In Cabrera and Hutchinson [14], </booktitle> <pages> pages 186-190. </pages>
Reference-contexts: Finally, although Lipto supports incremental configuration of operating system services via composition, actually carrying out such configuration requires that applications be provided with a meta-level interface allowing them to control the composition of the services that they use <ref> [25] </ref>. 2.3 Peace An Object-Oriented Operating System Family Peace [65] is the name given to a family of operating systems developed at the German National Research Center for Information Technology between 1990 and 1993.
Reference: [26] <author> Peter Druschel, Larry L. Peterson, and Norman C. Hutchinson. Lipto: </author> <title> A dynamically configurable object-oriented kernel. </title> <booktitle> IEEE Technical Committee on Operating Systems and Application Environments Newsletter, </booktitle> <volume> 5(1) </volume> <pages> 11-16, </pages> <month> Spring </month> <year> 1991. </year>
Reference-contexts: Moreover, Lipto specifically does not provide object support mechanisms such as persistence or migration, preferring to leave that task to higher-level subsystems. However, the designers do advocate that distributed applications be implemented in languages that support distributed and persistent objects <ref> [26] </ref>.
Reference: [27] <author> Peter Druschel, Larry L. Peterson, and Norman C. Hutchinson. </author> <title> Service composition in Lipto. </title> <editor> In Cabrera et al. </editor> <volume> [16], </volume> <pages> pages 108-111. </pages>
Reference-contexts: Garbage collection of acyclic persistent data structures based on reference counting is also supported [20]. Finally, dsm can be used to access remote persistent objects. 2.2 Lipto Orthogonality of Modularity and Protection Lipto <ref> [27, 28] </ref> is an object-oriented operating system developed at the University of Arizona between 1991 and 1993. Lipto was developed as a prototype implementation of an object-oriented architecture for a family of portable distributed operating systems.
Reference: [28] <author> Peter Druschel, Larry L. Peterson, and Norman C. Hutchinson. </author> <title> Beyond micro-kernel design: Decoupling modularity and protection in Lipto. </title> <booktitle> In Proceedings of the 12 th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Moreover, most still map a server to a protection domain. A notable exception that emphasises orthogonality between modularity and protection is Lipto <ref> [28] </ref>, which is reviewed in detail in section 2.2. Program Families An alternative approach to the design of (statically) flexible system software, which predates the recent interest in microkernels and object orientation, is based on the use of program families. <p> Garbage collection of acyclic persistent data structures based on reference counting is also supported [20]. Finally, dsm can be used to access remote persistent objects. 2.2 Lipto Orthogonality of Modularity and Protection Lipto <ref> [27, 28] </ref> is an object-oriented operating system developed at the University of Arizona between 1991 and 1993. Lipto was developed as a prototype implementation of an object-oriented architecture for a family of portable distributed operating systems.
Reference: [29] <author> Dawson R. Engler, M. Frans Kaashoek, and James W. O'Toole Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15 th Symposium on Operating Systems Principles [4], </booktitle> <pages> pages 251-266. </pages> <note> Also Operating Systems Review, 29(5). </note>
Reference-contexts: While Anderson did not describe a specific operating system implemented according to this principle, a number of other researchers have proposed operating system designs conforming to this general approach, most notably Panda [7], V ++ [21], and ExOS/Aegis <ref> [29] </ref>. In each case, the designers have proposed kernels that are responsible only for mediating application requests for physical resources and enforcing hardware protection boundaries between applications as suggested by Anderson.
Reference: [30] <author> Yvon Gourhant and Marc Shapiro. FOG/C++: </author> <title> A fragmented-object generator. </title> <booktitle> In Proceedings of theUsenix C++ Conference [62], </booktitle> <pages> pages 63-74. </pages>
Reference-contexts: Dual Objects To support the development of parallel (and distributed) applications as well as operating system services, Peace provides language support for distributed objects based on a novel object model supporting dual objects [42], which is reminiscent of the fragmented object model of Fog <ref> [30] </ref>. A dual object is a distributed object represented by a single prototype and one or more likenesses. The prototype maintains both the public and private state of the dual object and is typically located at a single node although it may migrate between nodes dynamically.
Reference: [31] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification. </title> <booktitle> Object Management Group, </booktitle> <month> July </month> <year> 1995. </year> <note> Revision 2.0. </note>
Reference-contexts: Most components of the operating system are thus regarded as replaceable parts. Interfaces are defined in an interface definition language (idl) that is both similar to, and a forerunner of that standardised by the Object Management Group (omg) in its Common Object Request Broker Architecture (corba) <ref> [31] </ref>. Use of an idl makes interfaces language-independent and hence contributes to the openness of the system. Spring idl also supports interface inheritance. Hence, at run-time a client expecting to use a component supporting some given interface may actually use a component supporting a derived interface.
Reference: [32] <author> Paulo Guedes and Daniel P. Julin. </author> <title> Object-oriented interfaces in the Mach 3.0 multi-server system. </title> <editor> In Cabrera et al. </editor> <volume> [16], </volume> <pages> pages 114-117. </pages>
Reference-contexts: Choices is reviewed in detail in section 2.1 as being representative of this approach. Recent multi-server microkernel-based operating systems have also made extensive use of object orientation, in particular, to define the interfaces between the various servers making up the (distributed) operating system <ref> [32, 52] </ref>. Use of object-oriented interfaces allows a clean separation of interface from implementation permitting multiple implementations of a service to coexist and, in particular, allowing applications to provide their own implementations of system services.
Reference: [33] <author> A.N. Habermann, Lawrence Flon, and Lee Cooprider. </author> <title> Modularization and hierarchy in a family of operating systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 266-272, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: Operating system designs based on the use of program families were proposed as early at the 1970s <ref> [33] </ref>. However, this approach was largely ignored by operating-systems researchers until the widespread adoption of object-oriented software engineering techniques and their application to operating systems in the late 1980s.
Reference: [34] <author> Graham Hamilton, Yousef A. Khalidi, and Michael N. Nelson. </author> <title> Why object oriented operating systems are boring. </title> <editor> In Cabrera et al. </editor> <volume> [16], </volume> <pages> pages 118-119. REFERENCES 31 </pages>
Reference-contexts: For these reasons, it seems only natural to use these same techniques in the design and implementation of operating systems. Indeed, this observation has lead some researchers to conclude that object-oriented operating systems are "boring" as a research topic <ref> [34] </ref>. However, object-oriented operating systems offer a number of other advantages in addition to those already mentioned. The use of object-oriented techniques to design an operating system provides the opportunity to build highly customisable systems. <p> Use of object-oriented interfaces allows a clean separation of interface from implementation permitting multiple implementations of a service to coexist and, in particular, allowing applications to provide their own implementations of system services. As <ref> [34] </ref> points out, such separation of interface and implementation blurs the distinction between applications and system services allowing users to acquire and install "shrink-wrapped" system services from multiple vendors and install them (possibly dynamically) as long as they conform to the appropriate interfaces.
Reference: [35] <author> Graham Hamilton and Panos Kougiouris. </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proceedings of the 1993 Summer Usenix Conference. Usenix Association, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Both the prototype and likeness classes can be individually named and are introduced as formal types. Hence it is possible to derive a dual object class from a likeness class resulting in a truly "distributed" object. 2.4 Spring An Object-Oriented, Multi-Server, Operating System Spring <ref> [52, 35] </ref> is an object-oriented multi-server operating system originally developed at Sun Microsystems Laboratories between 1989 and 1993 with subsequent development being undertaken at SunSoft. At the time of writing Spring runs on Sun SPARCstations 2, 5, 10, and 20. <p> Most components are provided as dynamically loadable modules. At boot time the operating system makes the decision as to which components are loaded into which address spaces so that related components can be grouped together <ref> [35] </ref>. The Spring microkernel consists of two major subcomponents: the nucleus and the virtual memory manager (vmm). The Spring nucleus provides domains (i.e., tasks) and threads, and supports secure cross-domain object invocation based on doors. A door is essentially a software capability for an entry point to a domain.
Reference: [36] <author> Graham Hamilton, Michael L. Powell, and James G. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In Proceedings of the 14 th Symposium on Operating Systems Principles [2], </booktitle> <pages> pages 69-79. </pages> <note> Also Operating Systems Review, 27(5). </note>
Reference-contexts: At this level the Spring object invocation mechanism is similar to many rpc implementations. However, in Spring the interface-specific stub code generated by the idl compiler makes use of a so-called subcontract to actually carry out an invocation <ref> [36] </ref>. Subcontracts are (replaceable) modules that implement the basic mechanisms to support object invocation and argument passing depending on the desired semantics of the invocation.
Reference: [37] <editor> IEEE Computer Society. </editor> <booktitle> Proceedings of the 4 rd Workshop on Workstation Operating Systems. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1993. </year>
Reference: [38] <author> Gary M. Johnston and Roy H. Campbell. </author> <title> An object-oriented implementation of distributed virtual memory. </title> <booktitle> In Proceedings of the Workshop on Experiences with Building Distributed and Multiprocessor Systems, </booktitle> <pages> pages 39-57. </pages> <publisher> Usenix Association, </publisher> <year> 1989. </year>
Reference-contexts: Page-based dsm is supported by a specialisation of the memory-management sub-framework that allows a single memory object to be mapped in multiple address spaces on different nodes of a network. The dsm protocol employed supports a multiple-reader/single-writer policy using write invalidation <ref> [38, 20] </ref>. Access to remotely created C ++ objects is also supported by an extension of the kernel object proxy mechanism that allows access to remote objects using the underlying Choices message-passing primitives [22]. Persistent C ++ objects are supported as a specialisation of the file system sub-framework.
Reference: [39] <author> Michael B. Jones. </author> <title> Interposition agents: Transparently interposing user code at the system interface. </title> <booktitle> In Proceedings of the 14 th Symposium on Operating Systems Principles [2], </booktitle> <pages> pages 80-93. </pages> <note> Also Operating Systems Review, 27(5). </note>
Reference: [40] <author> Jorg Cordsen and Wolfgang Schroder-Preikschat. </author> <title> Object-oriented operating system design and the revival of program families. </title> <editor> In Cabrera et al. </editor> <volume> [16], </volume> <pages> pages 24-28. </pages>
Reference-contexts: Operating system designs based on the use of program families were proposed as early at the 1970s [33]. However, this approach was largely ignored by operating-systems researchers until the widespread adoption of object-oriented software engineering techniques and their application to operating systems in the late 1980s. As described in <ref> [40] </ref>, the minimal subset of system functions is naturally implemented as a set of superclasses and minimal system extensions can be introduced by means of subclassing.
Reference: [41] <author> Jorg Cordsen and Wolfgang Schroder-Preikschat. </author> <title> Towards a scalable kernel architecture. </title> <booktitle> In Proceedings of the Autumn '92 Openforum Technical Conference, </booktitle> <pages> pages 15-33, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Nucleus separation also allows the operating mode of a node to be changed dynamically by replacing the kernel entity with a different version and changing the trap vector table entries that point to nucleus functions <ref> [41] </ref>. The must family members allow a multi-node machine to be partitioned among different users at the same time. Each node is assigned to a single user at a time and multiple users must be able to share the machine's interconnection network safely.
Reference: [42] <author> Jorg Nolte. </author> <title> Language level support for remote object invocation. </title> <type> Technical Report 654, </type> <institution> GMD, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: The responsibility for actually loading the required functions rests with pose. Dual Objects To support the development of parallel (and distributed) applications as well as operating system services, Peace provides language support for distributed objects based on a novel object model supporting dual objects <ref> [42] </ref>, which is reminiscent of the fragmented object model of Fog [30]. A dual object is a distributed object represented by a single prototype and one or more likenesses.
Reference: [43] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> An implementation of UNIX on an object-oriented operating system. </title> <booktitle> In Proceedings of the 1993 Winter Usenix Conference, </booktitle> <pages> pages 469-479. </pages> <publisher> Usenix Association, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: The naming services are also used to support persistence as described below. Finally, in line with the goal of supporting existing applications, Spring provides a Unix emulation service implemented by a library and associated server <ref> [43] </ref>. Although binary compatibility with Unix was not a goal of Spring, and is not supported, the Spring Unix emulation supports a large subset of the system calls provided by SunOS 4.1 and runs dynamically-linked SunOS 4.1 executables without modification.
Reference: [44] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> The Spring virtual memory system. </title> <type> Technical Report SMLI TR-93-9, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Invocations destined for remote domains are forwarded via user-mode network proxies that implement different protocol stacks. The vmm is also fairly conventional supporting demand-paged virtual memory and providing address spaces and memory objects representing memory that can be mapped into one or more address spaces <ref> [44] </ref>. The vmm manages local physical memory and page replacement, and caches pages of memory objects implemented by (external) pagers.
Reference: [45] <author> Gregor Kiczales. </author> <title> Towards a new model of abstraction in software engineering. </title> <editor> In Cabrera et al. </editor> <volume> [16], </volume> <pages> pages 127-128. </pages>
Reference-contexts: The design of the Peace object-oriented operating system is based on this principle and is reviewed in detail in section 2.3. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 9 Open Implementation and Reflection Recently Kiczales has proposed a new model of abstraction for software engineering known as the open implementation model <ref> [45, 48, 49, 47] </ref>. The basis of this model is the argument that while the traditional information hiding/black-box model of abstraction shields clients of an abstraction from having to know the details of how that abstraction is implemented, it also prevents them from altering those details when desirable.
Reference: [46] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: For example, the Mach external pager interface can be seen as a meta interface to the Mach virtual memory system. The model of open implementation was an outcome of work on the use of metaobject protocols in the implementation of object-oriented programming languages <ref> [46] </ref>. A metaobject protocol is essentially a meta interface to the implementation of a language's object model that allows the application programmer to control how certain aspects of the object model such as object invocation, dispatching, or inheritance are implemented.
Reference: [47] <author> Gregor Kiczales and John Lamping. </author> <title> Operating systems: </title> <booktitle> Why object-oriented? In Cabrera and Hutchinson [14], </booktitle> <pages> pages 25-30. </pages>
Reference-contexts: The design of the Peace object-oriented operating system is based on this principle and is reviewed in detail in section 2.3. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 9 Open Implementation and Reflection Recently Kiczales has proposed a new model of abstraction for software engineering known as the open implementation model <ref> [45, 48, 49, 47] </ref>. The basis of this model is the argument that while the traditional information hiding/black-box model of abstraction shields clients of an abstraction from having to know the details of how that abstraction is implemented, it also prevents them from altering those details when desirable.
Reference: [48] <author> Gregor Kiczales, John Lamping, Chris Maeda, David Keppel, </author> <title> and Dylan McNamee. The need for customisable operating systems. </title> <booktitle> In Proceedings of the 4 rd Workshop on Workstation Operating Systems [37], </booktitle> <pages> pages 165-169. </pages>
Reference-contexts: The design of the Peace object-oriented operating system is based on this principle and is reviewed in detail in section 2.3. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 9 Open Implementation and Reflection Recently Kiczales has proposed a new model of abstraction for software engineering known as the open implementation model <ref> [45, 48, 49, 47] </ref>. The basis of this model is the argument that while the traditional information hiding/black-box model of abstraction shields clients of an abstraction from having to know the details of how that abstraction is implemented, it also prevents them from altering those details when desirable.
Reference: [49] <author> Gregor Kiczales, Marvin Theimer, and Brent Welch. </author> <title> A new model of abstraction for operating system design. </title> <booktitle> In Cabrera and Jul [15], </booktitle> <pages> pages 346-349. REFERENCES 32 </pages>
Reference-contexts: The design of the Peace object-oriented operating system is based on this principle and is reviewed in detail in section 2.3. 2 INFLUENTIAL OBJECT-ORIENTED OPERATING SYSTEMS 9 Open Implementation and Reflection Recently Kiczales has proposed a new model of abstraction for software engineering known as the open implementation model <ref> [45, 48, 49, 47] </ref>. The basis of this model is the argument that while the traditional information hiding/black-box model of abstraction shields clients of an abstraction from having to know the details of how that abstraction is implemented, it also prevents them from altering those details when desirable.
Reference: [50] <author> Rodger Lea, Christian Jacquemot, and Eric Pillevesse. </author> <title> COOL: System support for distributed programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 37-46, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: For example, the Mach microkernel has been used to support various operating system personalities ranging from Ms-dos to 4.3Bsd Unix and Vms [12]. Likewise, the Chorus microkernel supports both Unix and an object-support operating system personality known as Cool <ref> [50] </ref>. In general, multiple versions of the same personality can coexist. This separation also allows application developers the choice of implementing directly on the microkernel interface as well as on an appropriate operating system personality thereby avoiding feature abundance.
Reference: [51] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the Mach external pager interface to support user-level page replacement policies. </title> <booktitle> In Proceedings of theUsenix Mach Workshop, </booktitle> <pages> pages 17-29. </pages> <publisher> Usenix Association, </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: Extensions to the external paging interface also allow applications to be involved in page replacement policy decisions <ref> [51] </ref>. Again, incrementality is poor since, in the absence of additional support, every pager has to be written from scratch.
Reference: [52] <author> James G. Mitchell, Jonathan J. Gibbons, Graham Hamilton, Peter B. Kessler, Yousef A. Khalidi, Panos Kougiouris, Peter W. Madany, Michael N. Nelson, Michael L. Powell, and Sanjay R. Radia. </author> <title> An overview of the Spring system. </title> <booktitle> In Proceedings of 39 th IEEE International Computer Conference. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> February </month> <year> 1994. </year>
Reference-contexts: Choices is reviewed in detail in section 2.1 as being representative of this approach. Recent multi-server microkernel-based operating systems have also made extensive use of object orientation, in particular, to define the interfaces between the various servers making up the (distributed) operating system <ref> [32, 52] </ref>. Use of object-oriented interfaces allows a clean separation of interface from implementation permitting multiple implementations of a service to coexist and, in particular, allowing applications to provide their own implementations of system services. <p> Both the prototype and likeness classes can be individually named and are introduced as formal types. Hence it is possible to derive a dual object class from a likeness class resulting in a truly "distributed" object. 2.4 Spring An Object-Oriented, Multi-Server, Operating System Spring <ref> [52, 35] </ref> is an object-oriented multi-server operating system originally developed at Sun Microsystems Laboratories between 1989 and 1993 with subsequent development being undertaken at SunSoft. At the time of writing Spring runs on Sun SPARCstations 2, 5, 10, and 20.
Reference: [53] <author> David L. Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(1):1-9, </volume> <month> March </month> <year> 1976. </year>
Reference-contexts: Program Families An alternative approach to the design of (statically) flexible system software, which predates the recent interest in microkernels and object orientation, is based on the use of program families. Parnas <ref> [53] </ref> defines program families as "sets of programs whose common properties are so extensive that it is advantageous to study the common properties of the programs before analysing individual members".
Reference: [54] <author> David L. Parnas. </author> <title> Designing software for ease of extension and contraction. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(2):128-137, </volume> <month> March </month> <year> 1979. </year>
Reference-contexts: different hardware configurations, because they embody different mapping decisions due to their intended use, or because some members of the family provide only a subset of the features of other members so that their clients do not have to pay the costs associated with the resources consumed by unused features <ref> [54] </ref>. In order to support fine-grained customisation of the members of a program family, its design begins by identifying a minimal subset of system functions that might conceivably perform a useful service. <p> Thereafter, further members of the family are implemented by making minimal extensions, which provide additional functionality, to the system. Essentially, each extension defines a new virtual machine that is available to clients. <ref> [54] </ref> claims that maximum flexibility is achieved when the smallest possible extensions are made in each iteration.
Reference: [55] <author> Calton Pu, Tito Autrey, Andrew Black, Charles Consel, Crispin Cowan, Jon Inouye, Lak-shmi Kethana, Jonathan Walpole, and Ke Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 15 th Symposium on Operating Systems Principles [4], </booktitle> <pages> pages 314-324. </pages> <note> Also Operating Systems Review, 29(5). </note>
Reference-contexts: While these systems offer the potential of being highly configurable, to date their performance has been poor. However, on-going research into the use of techniques such as dynamic code generation may alleviate these problems in the future <ref> [55] </ref>. 2 Influential Object-Oriented Operating Systems Section 1 reviewed a number of different approaches to achieving flexibility in systems software.
Reference: [56] <author> Sanjay R. Radia, Peter W. Madany, and Michael L. Powell. </author> <booktitle> Persistence in the Spring system. In Cabrera and Hutchinson [14], </booktitle> <pages> pages 12-23. </pages>
Reference-contexts: The framework defines the interface between the name service and an arbitrary object manager that allows persistence to be managed securely. However, as described in <ref> [56] </ref>, the framework does not provide support for handling inter-object references in persistent objects nor for garbage collection. 3 Perspectives on Object-Oriented Operating Systems Choices is probably the best known of the various object-oriented operating systems that have been developed to date and has consequently been highly influential.
Reference: [57] <author> Marc Rozier, Vadim Abrossimov, Fran~cois Armand, Ivan Boule, Michel Gien, Marc Guille-mont, Frederic Herrmann, Claude Kaiser, Sylvain Langlois, Pierre Leonard, and Will Neuhauser. </author> <title> Overview of the Chorus distributed operating system. </title> <booktitle> In Proceedings of theUsenix Workshop on Microkernels and Other Kernel Architectures [63], </booktitle> <pages> pages 39-69. </pages>
Reference-contexts: Moreover, the division of functionality between kernel and servers is typically fixed. The Chorus microkernel addresses this issue to some extent by allowing 1 TOWARDS FLEXIBLE OPERATING SYSTEMS 6 privileged servers to be loaded into the kernel's address space <ref> [57] </ref>. In that sense, Chorus may be said to provide an extensible kernel. This deficiency of previous microkernels was also addressed explicitly in the design of the Spin kernel [9].
Reference: [58] <author> Vincent F. Russo. </author> <title> Object-oriented operating system design. </title> <booktitle> IEEE Technical Committee on Operating Systems and Application Environments Newsletter, </booktitle> <volume> 5(1) </volume> <pages> 34-38, </pages> <month> Spring </month> <year> 1991. </year>
Reference-contexts: Object Orientation A complementary approach to the development of flexible system software is that based on the use of object-oriented techniques. While both traditional and microkernel-based operating systems have been implemented in object-oriented programing languages, Russo <ref> [58] </ref> characterises an object-oriented operating system as one that is both implemented using object-oriented techniques and provides its services via invocations on system objects. Object-oriented operating systems are attractive for a number of reasons. Object orientation is currently the software engineering discipline of choice in the computer industry.
Reference: [59] <author> Vincent F. Russo, Peter W. Madany, and Roy H. Campbell. </author> <title> C++ and Operating Systems Performance: a Case Study. </title> <booktitle> In Proceedings of theUsenix C++ Conference [62], </booktitle> <pages> pages 103-114. </pages>
Reference-contexts: The Choices project demonstrated that the well-known advantages of object-oriented design and implementation could be obtained in the context of an operating system without loss of performance <ref> [59] </ref>. The use of an object-oriented design allowed Choices to provide customisability and extensibility as expected. Moreover, the Choices experience has provided valuable guidance to the developers of other object-oriented operating systems concerning the design, organisation, and use of frameworks.
Reference: [60] <author> Henning Schmidt. </author> <title> Making Peace a dynamic alterable system. </title> <booktitle> In Proceedings of the 2 nd European Distributed Memory Computing Conference, volume 487 of Lecture Notes in Computer Science, </booktitle> <pages> pages 422-431. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: Entity loading (including loading of the kernel entity at a node to be bootstrapped) is supported by fundamental pose services that must be present at some node in the system <ref> [60] </ref>. Transient objects may be discarded explicitly by their clients or may shut themselves down as appropriate. Incremental loading can also be applied to a subset of the functions provided by the nucleus if required.
Reference: [61] <author> J. Mark Stevenson and Daniel P. Julin. Mach-US: </author> <title> UNIX on generic OS object servers. </title> <booktitle> In Proceedings of theUsenix Technical Conference, </booktitle> <pages> pages 119-130. </pages> <publisher> Usenix Association, </publisher> <month> January </month> <year> 1995. </year>
Reference-contexts: It is interesting to note that microkernel-based operating systems are now employing the kind of support offered by object-support operating systems such as roi, dynamic linking, and garbage collection to implement their servers <ref> [61] </ref>. Section 2.4 describes Spring as being representative of the application of object-orientation in a distributed multi-server operating system. <p> Spring represents a synthesis of previous work on object-oriented and microkernel-based operating systems. While the overall architecture of Spring is similar to that of other multi-server microkernel-based operating systems such as Chorus or Mach-US <ref> [61] </ref>, Spring is most interesting in that it employs a general-purpose object-support infrastructure, which provides location-transparent object invocation, to access (distributed) services. Thanks to its use of location-transparent object invocation, Spring supports the same degree of configurability of service placement as Lipto and Peace.
Reference: [62] <editor> Usenix Association. </editor> <booktitle> Proceedings of theUsenix C++ Conference, </booktitle> <month> April </month> <year> 1990. </year>
Reference: [63] <editor> Usenix Association. </editor> <booktitle> Proceedings of theUsenix Workshop on Microkernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year> <note> REFERENCES 33 </note>
Reference: [64] <author> Wolfgang Schroder-Preikschat. </author> <title> Peace a software backplane for parallel computing. </title> <booktitle> Parallel Computing, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Experience with the previous microkernel-based implementation of Peace showed that the major source of message-startup overhead is operating system software, particularly where message startup requires a protection boundary between kernel and user space to be crossed. Figures given in <ref> [64] </ref> show that multi-tasking overhead for nodes running a single application task contributed 74% of the message-startup time in that version of Peace.
Reference: [65] <editor> Wolfgang Schroder-Preikschat. </editor> <booktitle> The Logical Design of Parallel Operating Systems. </booktitle> <publisher> Prentice Hall, </publisher> <address> London, </address> <year> 1994. </year>
Reference-contexts: Essentially, each extension defines a new virtual machine that is available to clients. [54] claims that maximum flexibility is achieved when the smallest possible extensions are made in each iteration. However, as discussed in <ref> [65] </ref> there is a trade-off between taking such a pure bottom-up approach to the design of a program family in which a number of extensions may be needed before a system meeting the needs of any client emerges and taking a more pragmatic approach which is driven top-down by application requirements <p> Finally, although Lipto supports incremental configuration of operating system services via composition, actually carrying out such configuration requires that applications be provided with a meta-level interface allowing them to control the composition of the services that they use [25]. 2.3 Peace An Object-Oriented Operating System Family Peace <ref> [65] </ref> is the name given to a family of operating systems developed at the German National Research Center for Information Technology between 1990 and 1993. <p> In fact, a particular application can be seen as the final system extension. While the design of an operating system family does not imply any particular implementation technique, the Peace designers consider that it is "almost natural to construct program families by using an object-oriented framework" <ref> [65] </ref>. The minimal subset of system functions is implemented as a set of superclasses and minimal system extensions are introduced by means of subclassing. Moreover, polymorphism allows different implementations of the same interface to coexist.
Reference: [66] <author> Yasuhiko Yokote. </author> <title> The Apertos reflective operating system: The concept and its implementation. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> Proceedings of the 1992 Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 414-434. </pages> <booktitle> ACM Special Interest Group on Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <month> October </month> <year> 1992. </year> <note> Also SIGPLAN Notices 27(10), </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Parallel work has applied these same ideas to object-oriented operating systems leading to the development of reflective object-oriented operating systems, most notably Apertos <ref> [66] </ref>. While these systems offer the potential of being highly configurable, to date their performance has been poor.
Reference: [67] <author> Michael Young, Avadis Tevanian Jr., Richard F. Rashid, David B. Golub, Jeffrey Eppinger, Jonathan J. Chew, William J. Bolosky, David L. Black, and Robert Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the 11 th Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> November </month> <year> 1987. </year> <note> Also Technical Report CMU-CS-87-155. </note>
References-found: 67

