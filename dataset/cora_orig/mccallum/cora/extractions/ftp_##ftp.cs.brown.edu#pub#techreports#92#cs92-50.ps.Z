URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-50.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-50.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul, V. Vianu. </author> <title> Procedural and Declarative Database Update Languages. </title> <booktitle> Proc. 7th ACM PODS, </booktitle> <pages> 240-250, </pages> <year> 1988. </year>
Reference-contexts: For example: Relational calculus [13] + the theory of real closed fields [51] (Section 2); Inflationary Datalog : <ref> [1, 20, 31] </ref> + the theory of dense linear order with constants (Section 3); Inflationary Datalog : + the theory of equality on an infinite domain with constants (Section 4); and Datalog + boolean equations (Section 5). <p> The result (interpreting the generalized relation as an infinite set of points) of 9x:R (x; y) is the set fyjy 0g, which cannot be represented by polynomial equality constraints. 2 10 Datalog + constraints: We now consider Datalog with constraints. The syntax is that of Datalog (e.g., see <ref> [1, 27, 31, 52, 53] </ref>) but we allow the bodies of rules to contain constraints. Definition 1.10 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> We allow in a rule body expressions of the form :R 0 (x 1 ; . . . ; x k 0 ), where R 0 is some predicate symbol of arity k 0 . We give the language inflationary semantics <ref> [1, 20, 31] </ref>. In the inflationary semantics after each iteration the set of facts derived is added to the set of facts that were derived in the previous iterations. <p> Proof: As shown in [24] and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of <ref> [24, 20, 1] </ref> that Inflationary Datalog : with a finite discrete order expresses exactly PTIME.
Reference: [2] <author> A.V. Aho, Y. Sagiv, J.D. Ullman. </author> <title> Equivalences among Relational Expressions. </title> <journal> SIAM J. of Computing, </journal> <volume> 8:2:218-246, </volume> <year> 1979. </year>
Reference-contexts: Tableaux query programs form such a fragment. We provide definitions and examples for them in Section 2.2, and refer to <ref> [2, 10, 30, 52] </ref> for a more detailed treatment. <p> As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from <ref> [2, 10, 30] </ref>. Our interpretation is based on the simple geometric fact that, "an affine space is contained in a finite union of affine spaces iff it is contained in one member of this union" [45], p. 139. <p> We will now show that the homomorphism property holds when we have linear equations and is the key to proving containment in NP. This extends the basic technique of <ref> [2, 10] </ref>. Theorem 2.6 Given two query programs, each a tableau with a conjunction of linear equation constraints, deciding containment is NP-complete. Proof: NP-hardness is immediate, since it is NP-complete to determine containment for such queries just with equations of the form x = y [2, 10]. <p> extends the basic technique of <ref> [2, 10] </ref>. Theorem 2.6 Given two query programs, each a tableau with a conjunction of linear equation constraints, deciding containment is NP-complete. Proof: NP-hardness is immediate, since it is NP-complete to determine containment for such queries just with equations of the form x = y [2, 10]. The new part is showing membership in NP, given more general linear equations. We show that for two queries 1 and 2 in normal form: 1 is contained in 2 iff there is a homomorphism mapping 2 into 1 .
Reference: [3] <author> A.K. Aylamazyan, </author> <title> M.M. Gilula, A.P. Stolboushkin, G.F. Schwartz. Reduction of the Relational Model with Infinite Domain to the Case of Finite Domains. </title> <journal> Proc. USSR Acad. of Science (Doklady), </journal> <volume> 286(2) </volume> <pages> 308-311, </pages> <year> 1986. </year>
Reference-contexts: The analogue for the relational model is that relations are finite structures, and queries are supposed to preserve this finiteness. This is a requirement that creates various "safety" problems in relational databases [13, 52]. The precise analogue in relational databases is the notion of weak safety of <ref> [3] </ref>. In our framework, it is finiteness of representation of constraints that must be preserved. Evaluation of a query corresponds to an instance of a decision problem. Interestingly, many quantifier elimination procedures realize the goal of closed form. <p> Relational calculus (Inflationary Datalog : ) with equality constraints over an infinite domain can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data com plexity. This extends the approach to safe queries of <ref> [3, 23, 29, 42] </ref> (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and [8, 32, 38]. <p> However, in our generalized setting, the problem goes away. as long as the result has a finite representation of the appropriate kind. For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. <p> For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. <p> Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. In fact, the specific number of constants added in <ref> [3] </ref> and [23] to the "active domain" (the set of constants that appear in the database and in the query) corresponds precisely to the induction depth used in proving our evaluation method correct.
Reference: [4] <author> M. Baudinet, M. Niezette, P. Wolper. </author> <title> On the Representation of Infinite Temporal Data and Queries. </title> <booktitle> Proc. 10th ACM PODS, </booktitle> <pages> 280-290, </pages> <year> 1991. </year>
Reference-contexts: Remark A: The constraint theories that we investigate here are applicable to spatial databases. Temporal databases require the development of analogous frameworks for the theory of discrete linear order with constants, e.g., see [26]. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 44] </ref>. Our results on linear order only apply to dense linear order. <p> Discrete order can be used to model temporal databases. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 26] </ref>. In Section 2.2, we left open the complexity of tableau containment with dense linear order inequalities. This has been recently shown p 2 -complete in [54]. It would be very interesting to study the implementation of the "declarative and efficiently evaluable" languages outlined in this paper.
Reference: [5] <author> R. Bayer, E. McCreight. </author> <title> Organization of Large Ordered Indexes. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: Without the ability to perform such searches relational databases would have been impractical. Very efficient use of secondary storage is an additional requirement, beyond low data complexity, whose satisfaction greatly contributes to relational technology. B-trees and their variants B + -trees, <ref> [5, 16] </ref>, are examples of important data structures for implementing relational databases. In particular, let each secondary memory access transmit B units of data, let r be a relation with N tuples, and let us have a B + -tree on the attribute x of r.
Reference: [6] <author> M. Ben-Or, D. Kozen, J. Reif. </author> <title> The Complexity of Elementary Algebra and Geometry. </title> <journal> JCSS, </journal> <volume> 32 </volume> <pages> 251-264, </pages> <year> 1986. </year>
Reference-contexts: Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. This is a direct consequence of <ref> [6, 33, 51] </ref> and illustrates the potential applicability of the framework to spatial databases (Section 2.1). 2. As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from [2, 10, 30]. <p> If we have a fixed query on a generalized database, we have a fixed bound on the number of variables and on the quantifier depth. We can then use the results of <ref> [6, 33] </ref> to show that the data complexity is in NC. Theorem 2.3 Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: This is a direct application of [6, 33]. <p> We can then use the results of <ref> [6, 33] </ref> to show that the data complexity is in NC. Theorem 2.3 Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: This is a direct application of [6, 33]. To see this use the fixed dimension case of the theorem p. 263 in [6]. <p> Theorem 2.3 Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: This is a direct application of [6, 33]. To see this use the fixed dimension case of the theorem p. 263 in <ref> [6] </ref>.
Reference: [7] <author> A.H. Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM TOPLAS 3:4:353-387, </journal> <year> 1981. </year>
Reference-contexts: 1 Introduction 1.1 Motivation and Framework Q: What's in a tuple? A: Constraints. Constraint programming paradigms are inherently "declarative", since they describe compu tations by specifying how these computations are constrained <ref> [7, 34, 50] </ref>. A major recent development in logic programming systems is the integration of logic and constraint paradigms, fl A preliminary version of the results in this paper appeared in [28].
Reference: [8] <author> W. Buttner, H. Simonis. </author> <title> Embedding Boolean Expressions into Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <year> 1987. </year>
Reference-contexts: This extends the approach to safe queries of [3, 23, 29, 42] (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and <ref> [8, 32, 38] </ref>. The data complexity here is higher than in the previous cases and it depends on the use of free boolean algebras with m generators. <p> We present now the simple "adder circuit" example of Buttner and Simonis <ref> [8] </ref>, but in this case we use bottom-up evaluation to illustrate the previous method. 38 Example 5.4 An adder circuit can be built from two half-adder circuits. We define the oper-ation of the half-adder by a simple database fact using finite boolean equality constraints over B 0 .
Reference: [9] <author> A.K. Chandra, D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> JCSS, </journal> <volume> 25:1:99-128, </volume> <year> 1982. </year>
Reference-contexts: A key intuition comes from Constraint Logic Programming: a conjunction of constraints is the correct generalization of the ground fact. The technical tools for this integration are: data complexity <ref> [9, 57] </ref> from database theory, and quantifier elimination methods from mathematical logic. Let us provide some motivation for the integration of database and constraint solving methods. Manipulation of spatial data is an important application area (e.g., spatial or geographic databases) that requires both relational query language techniques and arithmetic calculations. <p> Codd defines safe formulas via syntactic restrictions on relational calculus. The LOGSPACE data complexity analysis is from <ref> [9] </ref>. We provide as evidence of the soundness of our design principles many variations of this observation in the context of constraints. The following table summarizes the main data complexity results: Polynomial Dense Order Equality Relational Calculus NC LOGSPACE LOGSPACE Datalog : Not closed PTIME PTIME In more detail: 1. <p> Theorem 3.15 Inflationary Datalog : with dense linear order inequality constraints can express any relational database query computable in PTIME (for a formal definition of these queries see <ref> [9] </ref>). Proof: As shown in [24] and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. <p> Theorem 3.15 Inflationary Datalog : with dense linear order inequality constraints can express any relational database query computable in PTIME (for a formal definition of these queries see <ref> [9] </ref>). Proof: As shown in [24] and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of [24, 20, 1] that Inflationary Datalog : with a finite discrete order expresses exactly PTIME.
Reference: [10] <author> A.K. Chandra, </author> <title> P.M. Merlin. Optimal Implementation of Conjunctive Queries in Relational Databases. </title> <booktitle> Proc. ACM STOC, </booktitle> <pages> 77-90, </pages> <year> 1976. </year>
Reference-contexts: Tableaux query programs form such a fragment. We provide definitions and examples for them in Section 2.2, and refer to <ref> [2, 10, 30, 52] </ref> for a more detailed treatment. <p> As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from <ref> [2, 10, 30] </ref>. Our interpretation is based on the simple geometric fact that, "an affine space is contained in a finite union of affine spaces iff it is contained in one member of this union" [45], p. 139. <p> We will now show that the homomorphism property holds when we have linear equations and is the key to proving containment in NP. This extends the basic technique of <ref> [2, 10] </ref>. Theorem 2.6 Given two query programs, each a tableau with a conjunction of linear equation constraints, deciding containment is NP-complete. Proof: NP-hardness is immediate, since it is NP-complete to determine containment for such queries just with equations of the form x = y [2, 10]. <p> extends the basic technique of <ref> [2, 10] </ref>. Theorem 2.6 Given two query programs, each a tableau with a conjunction of linear equation constraints, deciding containment is NP-complete. Proof: NP-hardness is immediate, since it is NP-complete to determine containment for such queries just with equations of the form x = y [2, 10]. The new part is showing membership in NP, given more general linear equations. We show that for two queries 1 and 2 in normal form: 1 is contained in 2 iff there is a homomorphism mapping 2 into 1 .
Reference: [11] <author> J. Chomicki. </author> <title> Polynomial Time Query Processing in Temporal Deductive Databases. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 379-391, </pages> <year> 1990. </year> <month> 47 </month>
Reference-contexts: Remark A: The constraint theories that we investigate here are applicable to spatial databases. Temporal databases require the development of analogous frameworks for the theory of discrete linear order with constants, e.g., see [26]. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 44] </ref>. Our results on linear order only apply to dense linear order. <p> Discrete order can be used to model temporal databases. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 26] </ref>. In Section 2.2, we left open the complexity of tableau containment with dense linear order inequalities. This has been recently shown p 2 -complete in [54]. It would be very interesting to study the implementation of the "declarative and efficiently evaluable" languages outlined in this paper.
Reference: [12] <author> J. Chomicki, T. Imielinski. </author> <title> Relational Specifications of Infinite Query Answers. </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <pages> 174-183, </pages> <year> 1989. </year>
Reference-contexts: Indeed, having such a language for ad-hoc database querying is a requirement today. It is rather surprising that constraint programming has not really influenced database query language design. There has been some previous research on the power of constraints for the implicit specification of temporal data <ref> [12] </ref>, for extending relational algebra [21], and for magic set evaluation [42], but no overall design principles. The bottom-up and set-at-a-time style of evaluation emphasized in databases, and more recently in knowledge bases, seems to contradict the top-down, depth-first intuition behind Constraint Logic Programming.
Reference: [13] <author> E.F. Codd. </author> <title> A Relational Model for Large Shared Data Banks. </title> <journal> CACM, </journal> <volume> 13:6:377-387, </volume> <year> 1970. </year>
Reference-contexts: For an example of "tight" integration of application, language paradigm, and implementation, let us review the relational data model. In the relational data model, <ref> [13] </ref>, an important application area (data processing) is described in a declarative style (relational calculus) so that it can be automatically and efficiently translated into procedural style (relational algebra). Program evaluation is bottom-up and set-at-a-time as opposed to top-down and tuple-at-a-time, because the applications involve massive amounts of structured data. <p> It contains at most k distinct variables and describes a possibly infinite set of arity k tuples (or points in k-dimensional space D k ). * The syntax of a CQL is the union of an existing database query language and a decidable logical theory. For example: Relational calculus <ref> [13] </ref> + the theory of real closed fields [51] (Section 2); Inflationary Datalog : [1, 20, 31] + the theory of dense linear order with constants (Section 3); Inflationary Datalog : + the theory of equality on an infinite domain with constants (Section 4); and Datalog + boolean equations (Section 5). <p> The analogue for the relational model is that relations are finite structures, and queries are supposed to preserve this finiteness. This is a requirement that creates various "safety" problems in relational databases <ref> [13, 52] </ref>. The precise analogue in relational databases is the notion of weak safety of [3]. In our framework, it is finiteness of representation of constraints that must be preserved. Evaluation of a query corresponds to an instance of a decision problem. <p> Relational calculus + constraints: We present a short but self-contained description of the relational calculus with a given a class of constraints. For more details on the relational calculus in database theory see <ref> [13, 27, 52] </ref>. 9 Definition 1.6 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> TM, PRAM) which given input generalized relations d produces some generalized relation representing the output of Q (d) and uses polynomial time (resp. logarithmic space on the work tape, polynomial number of processors running in polylogarithmic parallel time). 2 12 1.3 Overview of Contributions From Codd's original work <ref> [13] </ref> it follows that: safe relational calculus can be evaluated bottom-up in closed form and LOGSPACE data complexity. Codd defines safe formulas via syntactic restrictions on relational calculus. The LOGSPACE data complexity analysis is from [9].
Reference: [14] <author> J. Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> CACM, </journal> <volume> 33:7:52-68, </volume> <year> 1990. </year>
Reference-contexts: Watson Research Center, Yorktown Heights, NY. x Brown University, Providence, RI. Research was supported by NSF grant IRI-8617344 and by NSF-INRIA grant INT-8817874. 1 e.g., in CLP [25], in Prolog III [15], and in CHIP [17], for a recent survey see <ref> [14] </ref>. One intu-itive reason for this successful integration is as follows. A strength of Prolog is its top-down, depth-first search strategy. The operation of first-order term unification, at the forefront of this search, is a special form of efficient constraint solving.
Reference: [15] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 33:7:69-90, </volume> <year> 1990. </year>
Reference-contexts: Watson Research Center, Yorktown Heights, NY. x Brown University, Providence, RI. Research was supported by NSF grant IRI-8617344 and by NSF-INRIA grant INT-8817874. 1 e.g., in CLP [25], in Prolog III <ref> [15] </ref>, and in CHIP [17], for a recent survey see [14]. One intu-itive reason for this successful integration is as follows. A strength of Prolog is its top-down, depth-first search strategy.
Reference: [16] <author> D. Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> Computing Surveys, </journal> <volume> 11:2:121-137, </volume> <year> 1979. </year>
Reference-contexts: Without the ability to perform such searches relational databases would have been impractical. Very efficient use of secondary storage is an additional requirement, beyond low data complexity, whose satisfaction greatly contributes to relational technology. B-trees and their variants B + -trees, <ref> [5, 16] </ref>, are examples of important data structures for implementing relational databases. In particular, let each secondary memory access transmit B units of data, let r be a relation with N tuples, and let us have a B + -tree on the attribute x of r.
Reference: [17] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> Proc. Fifth Generation Computer Systems, </booktitle> <address> Tokyo Japan, </address> <year> 1988. </year>
Reference-contexts: Watson Research Center, Yorktown Heights, NY. x Brown University, Providence, RI. Research was supported by NSF grant IRI-8617344 and by NSF-INRIA grant INT-8817874. 1 e.g., in CLP [25], in Prolog III [15], and in CHIP <ref> [17] </ref>, for a recent survey see [14]. One intu-itive reason for this successful integration is as follows. A strength of Prolog is its top-down, depth-first search strategy. The operation of first-order term unification, at the forefront of this search, is a special form of efficient constraint solving.
Reference: [18] <author> J. Ferrante, J.R. Geiser. </author> <title> An Efficient Decision Procedure for the Theory of Rational Order. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 227-233, </pages> <year> 1977. </year>
Reference-contexts: Relational calculus (Inflationary Datalog : ) with dense linear order constraints can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data complexity. This is shown by adapting the proof of <ref> [18] </ref>. Also, by a slight modification of [24, 57] Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. <p> The proof of this result is based on the proof of <ref> [18] </ref>, which we extend to languages with constants and adapt for data complexity analysis. Our basic technical contribution is the appropriate definition of r-configuration (for rational-configuration). In order to use the decision procedure techniques of [18], we transform the query program applied to the input set of constraints into one semantically <p> The proof of this result is based on the proof of <ref> [18] </ref>, which we extend to languages with constants and adapt for data complexity analysis. Our basic technical contribution is the appropriate definition of r-configuration (for rational-configuration). In order to use the decision procedure techniques of [18], we transform the query program applied to the input set of constraints into one semantically equivalent formula of the theory of dense linear order with constants (see Section 1).
Reference: [19] <author> M.R. Garey, D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: By fixing the program size and letting the database grow, we can prove that the evaluation can be performed in PTIME or in NC or in LOGSPACE, depending on the constraints that we consider (for the various complexity classes see <ref> [19] </ref>). 4 (2) Let us motivate these design principles by a very common task from computational geometry and spatial databases; the problem of computing all rectangle intersections [41, 47].
Reference: [20] <author> Y. Gurevich, S. Shelah. </author> <title> Fixed-Point Extensions of First-Order Logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 32, </volume> <pages> 265-280, </pages> <year> 1986. </year>
Reference-contexts: For example: Relational calculus [13] + the theory of real closed fields [51] (Section 2); Inflationary Datalog : <ref> [1, 20, 31] </ref> + the theory of dense linear order with constants (Section 3); Inflationary Datalog : + the theory of equality on an infinite domain with constants (Section 4); and Datalog + boolean equations (Section 5). <p> We allow in a rule body expressions of the form :R 0 (x 1 ; . . . ; x k 0 ), where R 0 is some predicate symbol of arity k 0 . We give the language inflationary semantics <ref> [1, 20, 31] </ref>. In the inflationary semantics after each iteration the set of facts derived is added to the set of facts that were derived in the previous iterations. <p> Proof: As shown in [24] and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of <ref> [24, 20, 1] </ref> that Inflationary Datalog : with a finite discrete order expresses exactly PTIME.
Reference: [21] <author> M.R. Hansen, B.S. Hansen, P. Lucas, P. van Emde Boas. </author> <title> Integrating Relational Databases and Constraint Languages. </title> <booktitle> Computer Languages, </booktitle> <address> 14:2:63-82, </address> <year> 1989. </year>
Reference-contexts: It is rather surprising that constraint programming has not really influenced database query language design. There has been some previous research on the power of constraints for the implicit specification of temporal data [12], for extending relational algebra <ref> [21] </ref>, and for magic set evaluation [42], but no overall design principles. The bottom-up and set-at-a-time style of evaluation emphasized in databases, and more recently in knowledge bases, seems to contradict the top-down, depth-first intuition behind Constraint Logic Programming.
Reference: [22] <author> R. Helm, K. Marriott, M. Odersky. </author> <title> Constraint-based Query Optimization for Spatial Databases. </title> <booktitle> Proc. 10th ACM PODS, </booktitle> <pages> 181-191, </pages> <year> 1991. </year>
Reference-contexts: In particular, linear inequality constraints should be investigated in a CQL framework. (3) How do various optimization methods combine with our framework? This would involve extending [42]. For some recent research in this direction we refer to <ref> [22, 35, 40, 49] </ref>. 46 (4) Constraint query languages should be designed in an extendible way.
Reference: [23] <author> R. Hull, J. Su. </author> <title> Domain Independence and the Relational Calculus. </title> <type> Technical Report 88-64, </type> <institution> University of Southern California. </institution>
Reference-contexts: Relational calculus (Inflationary Datalog : ) with equality constraints over an infinite domain can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data com plexity. This extends the approach to safe queries of <ref> [3, 23, 29, 42] </ref> (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and [8, 32, 38]. <p> However, in our generalized setting, the problem goes away. as long as the result has a finite representation of the appropriate kind. For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. <p> For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. <p> Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. In fact, the specific number of constants added in [3] and <ref> [23] </ref> to the "active domain" (the set of constants that appear in the database and in the query) corresponds precisely to the induction depth used in proving our evaluation method correct.
Reference: [24] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Information and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: It is possible to combine them with relational calculus, but not with recursive formalisms. (b) Dense linear order constraints are also very general, since one may use them to simulate any PTIME computation (as in <ref> [24] </ref> and [57]). We devote a large part of our analysis to this case, because it best illustrates the desired integration with relational calculus and various recursive formalisms. <p> Relational calculus (Inflationary Datalog : ) with dense linear order constraints can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data complexity. This is shown by adapting the proof of [18]. Also, by a slight modification of <ref> [24, 57] </ref> Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. For Datalog with dense linear order constraints, we develop a bottom-up evaluation method that is closer to the classical foundations of logic programming [36] and knowledge bases [52, 53] (Section 3.2). <p> Theorem 3.15 Inflationary Datalog : with dense linear order inequality constraints can express any relational database query computable in PTIME (for a formal definition of these queries see [9]). Proof: As shown in <ref> [24] </ref> and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of [24, 20, 1] that Inflationary Datalog : with a finite discrete order expresses exactly PTIME. <p> Proof: As shown in [24] and [57] the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of <ref> [24, 20, 1] </ref> that Inflationary Datalog : with a finite discrete order expresses exactly PTIME.
Reference: [25] <author> J. Jaffar, J.L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM POPL, </booktitle> <pages> 111-119, </pages> <year> 1987. </year>
Reference-contexts: Sloan Fellowship, and by ONR grants N00014-83-K-0146 ARPA Order No. 4786 and N00014-91-J-4052 ARPA Order No. 8225. z IBM T.J. Watson Research Center, Yorktown Heights, NY. x Brown University, Providence, RI. Research was supported by NSF grant IRI-8617344 and by NSF-INRIA grant INT-8817874. 1 e.g., in CLP <ref> [25] </ref>, in Prolog III [15], and in CHIP [17], for a recent survey see [14]. One intu-itive reason for this successful integration is as follows. A strength of Prolog is its top-down, depth-first search strategy. <p> In Section 3.2, we provide an alternative bottom-up evaluation for Datalog, which emphasizes logic programming tools, as opposed to decision procedures for logical theories. The motivation for this is to gain more intuition about Herbrand atoms, minimal models, derivation trees, and the other machinery of constraint logic programming <ref> [25, 36] </ref>. <p> These simulation proofs can be easily modified, by making all programs use only constants appearing in the database. 2 3.2 Datalog Bottom-up Evaluation Revisited Let us now consider an alternative proof for the Datalog case of Theorem 3.14. The main idea comes from the semantics of Constraint Logic Programming <ref> [25] </ref>. It involves generalizing the notion of a Herbrand atom. The result is a "natural" bottom-up evaluation for Datalog with dense linear order constraints.
Reference: [26] <author> F. Kabanza, J-M. Stevenne, P. Wolper. </author> <title> Handling Infinite Temporal Data. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 392-403, </pages> <year> 1990. </year>
Reference-contexts: Remark A: The constraint theories that we investigate here are applicable to spatial databases. Temporal databases require the development of analogous frameworks for the theory of discrete linear order with constants, e.g., see <ref> [26] </ref>. For recent developments of constraint-based approaches to temporal databases we refer to [4, 11, 44]. Our results on linear order only apply to dense linear order. <p> Discrete order can be used to model temporal databases. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 26] </ref>. In Section 2.2, we left open the complexity of tableau containment with dense linear order inequalities. This has been recently shown p 2 -complete in [54]. It would be very interesting to study the implementation of the "declarative and efficiently evaluable" languages outlined in this paper.
Reference: [27] <author> P.C. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, chapter 17, </volume> <editor> (J. van Leeuwen editor), </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Relational calculus + constraints: We present a short but self-contained description of the relational calculus with a given a class of constraints. For more details on the relational calculus in database theory see <ref> [13, 27, 52] </ref>. 9 Definition 1.6 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> The result (interpreting the generalized relation as an infinite set of points) of 9x:R (x; y) is the set fyjy 0g, which cannot be represented by polynomial equality constraints. 2 10 Datalog + constraints: We now consider Datalog with constraints. The syntax is that of Datalog (e.g., see <ref> [1, 27, 31, 52, 53] </ref>) but we allow the bodies of rules to contain constraints. Definition 1.10 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> The definition is the same as in the case without constraints, the only difference being the use of unrestricted relational databases <ref> [27, 37, 52] </ref>. We present this definition by example. Example 1.11 Consider the Datalog query program with dense linear order constraints.
Reference: [28] <author> P. C. Kanellakis, G. M. Kuper, P. Z. Revesz. </author> <title> Constraint Query Languages. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 299-313, </pages> <year> 1990. </year>
Reference-contexts: Constraint programming paradigms are inherently "declarative", since they describe compu tations by specifying how these computations are constrained [7, 34, 50]. A major recent development in logic programming systems is the integration of logic and constraint paradigms, fl A preliminary version of the results in this paper appeared in <ref> [28] </ref>. This is also a revision, with additional material, of Brown University technical report CS-90-31. y Brown University, Providence, RI. Research was supported by IBM, by an Alfred P. Sloan Fellowship, and by ONR grants N00014-83-K-0146 ARPA Order No. 4786 and N00014-91-J-4052 ARPA Order No. 8225. z IBM T.J.
Reference: [29] <author> M. Kifer. </author> <title> On Safety, Domain Independence, and Capturability of Database Queries. </title> <booktitle> Proc. International Conference on Databases and Knowledge Bases, </booktitle> <address> Jerusalem Israel, </address> <year> 1988. </year>
Reference-contexts: Relational calculus (Inflationary Datalog : ) with equality constraints over an infinite domain can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data com plexity. This extends the approach to safe queries of <ref> [3, 23, 29, 42] </ref> (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and [8, 32, 38]. <p> However, in our generalized setting, the problem goes away. as long as the result has a finite representation of the appropriate kind. For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation. <p> For the relational calculus and Datalog : applied to finite relations there are similar results in the literature <ref> [3, 29, 23] </ref>. Our work extends some of the results of [3, 29, 23], by adding recursion and handling any input generalized relation.
Reference: [30] <author> A. Klug. </author> <title> On Conjunctive Queries Containing Inequalities. </title> <journal> JACM, </journal> <volume> 35:1:146-160, </volume> <year> 1988. </year> <month> 48 </month>
Reference-contexts: Tableaux query programs form such a fragment. We provide definitions and examples for them in Section 2.2, and refer to <ref> [2, 10, 30, 52] </ref> for a more detailed treatment. <p> As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from <ref> [2, 10, 30] </ref>. Our interpretation is based on the simple geometric fact that, "an affine space is contained in a finite union of affine spaces iff it is contained in one member of this union" [45], p. 139. <p> . ; x n (1 x n ) = 0 Note that 1 will have as output all possible x vectors, hence 1 2 if and only if the quantified boolean formula holds. 2 Containment in the presence of inequality constraints without + and fl is the problem examined in <ref> [30] </ref>. For containment of tableaux with inequalities and no +; fl, we can show that the homomorphism property fails even for semiinterval query programs. <p> Semiinterval query programs are those in which each variable is bounded by a constant from only one side i.e., left or right, and there are no other constraints. In <ref> [30] </ref> it is shown that the homomorphism property holds for left-semiinterval queries or right-semiinterval queries alone and does not work for interval queries, i.e., variables are bounded from both sides. Theorem 2.8 The homomorphism property fails for semiinterval query programs.
Reference: [31] <author> P. Kolaitis, C.H. Papadimitriou. </author> <title> Why not Negation by Fixpoint? Proc. </title> <booktitle> 7th ACM PODS, </booktitle> <pages> 231-239, </pages> <year> 1988. </year>
Reference-contexts: For example: Relational calculus [13] + the theory of real closed fields [51] (Section 2); Inflationary Datalog : <ref> [1, 20, 31] </ref> + the theory of dense linear order with constants (Section 3); Inflationary Datalog : + the theory of equality on an infinite domain with constants (Section 4); and Datalog + boolean equations (Section 5). <p> The result (interpreting the generalized relation as an infinite set of points) of 9x:R (x; y) is the set fyjy 0g, which cannot be represented by polynomial equality constraints. 2 10 Datalog + constraints: We now consider Datalog with constraints. The syntax is that of Datalog (e.g., see <ref> [1, 27, 31, 52, 53] </ref>) but we allow the bodies of rules to contain constraints. Definition 1.10 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> We allow in a rule body expressions of the form :R 0 (x 1 ; . . . ; x k 0 ), where R 0 is some predicate symbol of arity k 0 . We give the language inflationary semantics <ref> [1, 20, 31] </ref>. In the inflationary semantics after each iteration the set of facts derived is added to the set of facts that were derived in the previous iterations.
Reference: [32] <author> D. Kozen. </author> <title> Complexity of Boolean Algebras. Theo. </title> <journal> Comp. Sci., </journal> <volume> 10, </volume> <pages> 221-247, </pages> <year> 1980. </year>
Reference-contexts: This extends the approach to safe queries of [3, 23, 29, 42] (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and <ref> [8, 32, 38] </ref>. The data complexity here is higher than in the previous cases and it depends on the use of free boolean algebras with m generators.
Reference: [33] <author> D. Kozen, C. Yap. </author> <title> Algebraic Cell Decomposition in NC. </title> <booktitle> Proc. 26th IEEE FOCS, </booktitle> <pages> 515-521, </pages> <year> 1985. </year>
Reference-contexts: Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. This is a direct consequence of <ref> [6, 33, 51] </ref> and illustrates the potential applicability of the framework to spatial databases (Section 2.1). 2. As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from [2, 10, 30]. <p> If we have a fixed query on a generalized database, we have a fixed bound on the number of variables and on the quantifier depth. We can then use the results of <ref> [6, 33] </ref> to show that the data complexity is in NC. Theorem 2.3 Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: This is a direct application of [6, 33]. <p> We can then use the results of <ref> [6, 33] </ref> to show that the data complexity is in NC. Theorem 2.3 Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: This is a direct application of [6, 33]. To see this use the fixed dimension case of the theorem p. 263 in [6]. <p> Proof: This is a direct application of [6, 33]. To see this use the fixed dimension case of the theorem p. 263 in [6]. The cell decomposition method in sections 6-7 of <ref> [33] </ref> can be used to output a formula in DNF (of size polynomial in the input) that represents the output generalized database. 2 It is true that the general-purpose bottom-up evaluation based on geometric theorem proving is not as efficient as the various specialized computational geometry algorithms.
Reference: [34] <author> W. Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction 1.1 Motivation and Framework Q: What's in a tuple? A: Constraints. Constraint programming paradigms are inherently "declarative", since they describe compu tations by specifying how these computations are constrained <ref> [7, 34, 50] </ref>. A major recent development in logic programming systems is the integration of logic and constraint paradigms, fl A preliminary version of the results in this paper appeared in [28].
Reference: [35] <author> A. Levy, Y. Sagiv. </author> <title> Constraints and Redundancy in Datalog. </title> <booktitle> Proc. 11th ACM PODS, </booktitle> <pages> 67-81, </pages> <year> 1992. </year>
Reference-contexts: In particular, linear inequality constraints should be investigated in a CQL framework. (3) How do various optimization methods combine with our framework? This would involve extending [42]. For some recent research in this direction we refer to <ref> [22, 35, 40, 49] </ref>. 46 (4) Constraint query languages should be designed in an extendible way.
Reference: [36] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Also, by a slight modification of [24, 57] Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. For Datalog with dense linear order constraints, we develop a bottom-up evaluation method that is closer to the classical foundations of logic programming <ref> [36] </ref> and knowledge bases [52, 53] (Section 3.2). This allows us to show that piecewise linear Datalog with dense linear order constraints can be evaluated bottom-up in closed form and NC data complexity (Section 3.3). 5. <p> In Section 3.2, we provide an alternative bottom-up evaluation for Datalog, which emphasizes logic programming tools, as opposed to decision procedures for logical theories. The motivation for this is to gain more intuition about Herbrand atoms, minimal models, derivation trees, and the other machinery of constraint logic programming <ref> [25, 36] </ref>.
Reference: [37] <author> Y.N. Moschovakis. </author> <title> Elementary Induction on Abstract Structures. </title> <publisher> North Holland, </publisher> <year> 1974. </year>
Reference-contexts: However, the relational calculus and algebra can be developed without the finiteness assumption for relations. We will use the term unrestricted relation for finite or infinite sets of points in a k-dimensional space. It is possible to develop query languages using such unrestricted relations (e.g., see <ref> [37] </ref>). In order to be able to do something useful with such unrestricted relations, we need a finite representation that we can manipulate. This is exactly what the generalized tuples provide. <p> The definition is the same as in the case without constraints, the only difference being the use of unrestricted relational databases <ref> [27, 37, 52] </ref>. We present this definition by example. Example 1.11 Consider the Datalog query program with dense linear order constraints.
Reference: [38] <author> U. Martin, T. Nipkow. </author> <title> Unification in Boolean Rings. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 381-396, </pages> <year> 1988. </year>
Reference-contexts: This extends the approach to safe queries of [3, 23, 29, 42] (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and <ref> [8, 32, 38] </ref>. The data complexity here is higher than in the previous cases and it depends on the use of free boolean algebras with m generators. <p> Because of one-to-one correspondence between boolean algebras and boolean rings with unity the theory here can be developed in either setting <ref> [38] </ref>. In what follows we use algebras and, sometimes, the exclusive-or as an abbreviation. <p> Claim: The last formula is equivalent to V x2f0;1g n (x 1 ; . . .; x n ; c 1 ; . . .; c m ) = 0 is true in B m . (This claim is the basis of Martin and Nipkow's method <ref> [38] </ref>, but we can prove it in a simple way as follows). To prove the claim rewrite the term in the claim into disjunctive normal form. We get W V y 1 m .
Reference: [39] <author> E. McCreight. </author> <title> Priority Search Trees. </title> <journal> SIAM J. Computing, </journal> <volume> 14 </volume> <pages> 257-276, </pages> <year> 1985. </year>
Reference-contexts: This is a well-known problem with many elegant solutions from computational geometry [41]. It is a special case of 2-dimensional searching in relational databases, called 1.5-dimensional searching in <ref> [39] </ref>. For example, the priority search trees of [39] are a linear space data structure with logarithmic-time update and search algorithms for in-core processing. Grid-files, R-trees, and quad-trees have all been used for solving this problem with good secondary memory access performance. <p> This is a well-known problem with many elegant solutions from computational geometry [41]. It is a special case of 2-dimensional searching in relational databases, called 1.5-dimensional searching in <ref> [39] </ref>. For example, the priority search trees of [39] are a linear space data structure with logarithmic-time update and search algorithms for in-core processing. Grid-files, R-trees, and quad-trees have all been used for solving this problem with good secondary memory access performance.
Reference: [40] <author> I. N. Mumick, S. J. Finkelstein, H. Pirahesh, R. Ramakrishnan. </author> <title> Magic Conditions. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 314-330, </pages> <year> 1990. </year>
Reference-contexts: In particular, linear inequality constraints should be investigated in a CQL framework. (3) How do various optimization methods combine with our framework? This would involve extending [42]. For some recent research in this direction we refer to <ref> [22, 35, 40, 49] </ref>. 46 (4) Constraint query languages should be designed in an extendible way.
Reference: [41] <author> F.P. Preparata, M.I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: be performed in PTIME or in NC or in LOGSPACE, depending on the constraints that we consider (for the various complexity classes see [19]). 4 (2) Let us motivate these design principles by a very common task from computational geometry and spatial databases; the problem of computing all rectangle intersections <ref> [41, 47] </ref>. <p> The use of generalized 1-dimensional indexes reduces redundancy of representation and transforms 1-dimensional searching on generalized database attribute x into the problem of online intersections in a dynamic set of intervals. This is a well-known problem with many elegant solutions from computational geometry <ref> [41] </ref>. It is a special case of 2-dimensional searching in relational databases, called 1.5-dimensional searching in [39]. For example, the priority search trees of [39] are a linear space data structure with logarithmic-time update and search algorithms for in-core processing. <p> In the following examples N is the only parameter that grows asymptotically. In Example 1.1, we already illustrated this language using the problem of object intersection. It is interesting to note that most other basic operations of computational geometry (e.g., Convex Hull and Voronoi diagram see <ref> [41] </ref>) can be described in this declarative query language, which also happens to be efficiently bottom-up evaluable. Example 2.1 Convex hull : The database consists of an arity 2 relation r, that describes N points of the plane. <p> Although it cannot compete with various known O (N log N ) algorithms, it is still useful in combination with other convex hull techniques. 2 Example 2.2 Voronoi diagram: We can show how to find the graph called the dual of the Voronoi diagram <ref> [41] </ref>. To do this, note that two points u and v are adjacent in the Voronoi 14 dual iff all the points on the line from u to v are closer to u or to v than to any other point in the database.
Reference: [42] <author> R. Ramakrishnan. </author> <title> Magic Templates: A Spellbinding Approach to Logic Programs. </title> <booktitle> Proc. 5th International Conference on Logic Programming, </booktitle> <pages> 141-159, </pages> <year> 1988. </year>
Reference-contexts: It is rather surprising that constraint programming has not really influenced database query language design. There has been some previous research on the power of constraints for the implicit specification of temporal data [12], for extending relational algebra [21], and for magic set evaluation <ref> [42] </ref>, but no overall design principles. The bottom-up and set-at-a-time style of evaluation emphasized in databases, and more recently in knowledge bases, seems to contradict the top-down, depth-first intuition behind Constraint Logic Programming. <p> Relational calculus (Inflationary Datalog : ) with equality constraints over an infinite domain can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data com plexity. This extends the approach to safe queries of <ref> [3, 23, 29, 42] </ref> (Section 4). 6. Finally, Datalog with boolean equality constraints can be evaluated bottom-up and in closed form. For the definitions we refer to Section 5 and [8, 32, 38]. <p> In particular, linear inequality constraints should be investigated in a CQL framework. (3) How do various optimization methods combine with our framework? This would involve extending <ref> [42] </ref>. For some recent research in this direction we refer to [22, 35, 40, 49]. 46 (4) Constraint query languages should be designed in an extendible way.
Reference: [43] <author> J. Renegar. </author> <title> On the Computational Complexity and Geometry of the First-order Theory of the Reals: Parts I-III. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 13 </volume> <pages> 255-352, </pages> <year> 1992. </year>
Reference-contexts: In general, how can grid-files, R-trees, quad-trees and other such structures be used to speed-up CQL evaluation strategies? (2) The technology of algorithms for logical theories is still rather complex, but much progress has been accomplished in recent years. For example, see <ref> [43] </ref> for the state-of-the-art in real closed fields. Are there interesting special cases, for which simple algorithmic techniques can be used? These would be analogous to the special treatment of project-select-join query programs in the relational model.
Reference: [44] <author> P.Z. Revesz. </author> <title> A Closed Form for Datalog Queries with Integer Order. </title> <booktitle> Proc. 3rd International Conference on Database Theory, </booktitle> <year> 1990, </year> <note> (to appear in TCS). </note>
Reference-contexts: Remark A: The constraint theories that we investigate here are applicable to spatial databases. Temporal databases require the development of analogous frameworks for the theory of discrete linear order with constants, e.g., see [26]. For recent developments of constraint-based approaches to temporal databases we refer to <ref> [4, 11, 44] </ref>. Our results on linear order only apply to dense linear order. <p> For recent developments of constraint-based approaches to temporal databases we refer to [4, 11, 44]. Our results on linear order only apply to dense linear order. The case of discrete, or integer, linear order is analyzed in <ref> [44] </ref>. 2 Remark B: The key concept in CQL, illustrated by Example 1.1, is that constraints describe point-sets, such that all their points are in the database. With the appropriate constraint theory these point-sets are accurate (and perhaps the most intuitive) representations of spatial objects. <p> We devote a large part of our analysis to this case, because it best illustrates the desired integration with relational calculus and various recursive formalisms. Discrete linear order is much harder to combine with recursion <ref> [44] </ref>. (c) Equality constraints over an infinite domain were chosen as the simplest generalization of the relational data model. <p> A number of technical questions remain open. For example: What is the precise data complexity of Datalog with finite boolean equality constraints? Also, is it possible to develop a similar framework for discrete linear order with constants? Note that, progress has been made recently on this question in <ref> [44] </ref>. Discrete order can be used to model temporal databases. For recent developments of constraint-based approaches to temporal databases we refer to [4, 11, 26]. In Section 2.2, we left open the complexity of tableau containment with dense linear order inequalities.
Reference: [45] <author> H.L. Royden. </author> <title> Real Analysis. </title> <type> 2 nd Ed., </type> <year> 1983. </year>
Reference-contexts: Our interpretation is based on the simple geometric fact that, "an affine space is contained in a finite union of affine spaces iff it is contained in one member of this union" <ref> [45] </ref>, p. 139. We show that deciding containment between tableaux queries with linear equalities is NP-complete, but that with quadratic equalities it is p 2 -hard (Section 2.2). 3. <p> The new part is showing membership in NP, given more general linear equations. We show that for two queries 1 and 2 in normal form: 1 is contained in 2 iff there is a homomorphism mapping 2 into 1 . We use the previous lemma and from <ref> [45] </ref>, p. 139, the simple geometric fact: "an affine space is contained in a finite union of affine spaces iff it is contained in one member of this union".
Reference: [46] <author> H. Samet. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1990. </year>
Reference-contexts: features of the relational data model. (1) The language framework that we propose preserves the declarative style and the efficiency of relational database languages. (2) The possible applications of constraint databases include both data processing and numerical processing of spatial data. (3) The implementation technology of spatial access methods (see <ref> [46, 47] </ref>) naturally matches the new formalism. 2 - (db, constraints) - . . . query program database outputdatabase input tuple = V constraints 1. closed form 2. evaluated bottom-up 3. low data complexity We will now explain our new framework and give arguments in support of the above (1-3). (1) <p> It is a central problem in spatial databases for which there are many solutions with good secondary memory access performance, e.g., grid-files, quad-trees, R-trees (see the surveys <ref> [46, 47] </ref>).
Reference: [47] <author> H. Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1990. </year>
Reference-contexts: features of the relational data model. (1) The language framework that we propose preserves the declarative style and the efficiency of relational database languages. (2) The possible applications of constraint databases include both data processing and numerical processing of spatial data. (3) The implementation technology of spatial access methods (see <ref> [46, 47] </ref>) naturally matches the new formalism. 2 - (db, constraints) - . . . query program database outputdatabase input tuple = V constraints 1. closed form 2. evaluated bottom-up 3. low data complexity We will now explain our new framework and give arguments in support of the above (1-3). (1) <p> be performed in PTIME or in NC or in LOGSPACE, depending on the constraints that we consider (for the various complexity classes see [19]). 4 (2) Let us motivate these design principles by a very common task from computational geometry and spatial databases; the problem of computing all rectangle intersections <ref> [41, 47] </ref>. <p> It is a central problem in spatial databases for which there are many solutions with good secondary memory access performance, e.g., grid-files, quad-trees, R-trees (see the surveys <ref> [46, 47] </ref>).
Reference: [48] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mel-lon University, </institution> <year> 1989. </year>
Reference-contexts: Our framework is thus one of complete information. Constraint logic programming paradigms are currently attracting a great deal of attention in languages for operations research applications [55, 56] and have also impacted the field of concurrent programming language design <ref> [48] </ref>. The use of constraints for operations research and for concurrency is sometimes semantically different from their use in our framework. For example: Constraints can be used to represent the many possible states (of which one is true) of a set of concurrent processes.
Reference: [49] <author> D. Srivastava, R. Ramakrishnan. </author> <title> Pushing Constraint Selections. </title> <booktitle> Proc. 11th ACM PODS, </booktitle> <pages> 301-316, </pages> <year> 1992. </year>
Reference-contexts: In particular, linear inequality constraints should be investigated in a CQL framework. (3) How do various optimization methods combine with our framework? This would involve extending [42]. For some recent research in this direction we refer to <ref> [22, 35, 40, 49] </ref>. 46 (4) Constraint query languages should be designed in an extendible way.
Reference: [50] <author> G.L. Steele. </author> <title> The Definition and Implementation of a Computer Programming Language Based on Constraints. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <address> AI-TR 595, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction 1.1 Motivation and Framework Q: What's in a tuple? A: Constraints. Constraint programming paradigms are inherently "declarative", since they describe compu tations by specifying how these computations are constrained <ref> [7, 34, 50] </ref>. A major recent development in logic programming systems is the integration of logic and constraint paradigms, fl A preliminary version of the results in this paper appeared in [28].
Reference: [51] <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <publisher> University of Cali-fornia Press, </publisher> <address> Berkeley, California, </address> <year> 1951. </year>
Reference-contexts: For example: Relational calculus [13] + the theory of real closed fields <ref> [51] </ref> (Section 2); Inflationary Datalog : [1, 20, 31] + the theory of dense linear order with constants (Section 3); Inflationary Datalog : + the theory of equality on an infinite domain with constants (Section 4); and Datalog + boolean equations (Section 5). <p> Relational calculus with real polynomial inequality constraints can be evaluated bottom-up in closed form and NC data complexity. This is a direct consequence of <ref> [6, 33, 51] </ref> and illustrates the potential applicability of the framework to spatial databases (Section 2.1). 2. As part of our analysis of the relational calculus and real polynomial inequality constraints, we provide a new interpretation of the homomorphism theorem for tableau query containment from [2, 10, 30]. <p> The syntax is the union of relational calculus with that of the theory of real closed fields <ref> [51] </ref>. For the semantics, the database atomic formulas will be used as shorthands for large formulas of the theory of real closed fields, as described in Section 1. <p> This closure property follows immediately from the decision procedure of Tarski for the theory of real closed fields <ref> [51] </ref> and is one of its basic properties. One can think of Tarski's procedure as a generalized relational algebra, where all the operations are simple variants of the familiar database ones except for projection. Projection corresponds to quantifier elimination and is the nontrivial operation.
Reference: [52] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <address> 2 nd Ed., </address> <year> 1982. </year>
Reference-contexts: The analogue for the relational model is that relations are finite structures, and queries are supposed to preserve this finiteness. This is a requirement that creates various "safety" problems in relational databases <ref> [13, 52] </ref>. The precise analogue in relational databases is the notion of weak safety of [3]. In our framework, it is finiteness of representation of constraints that must be preserved. Evaluation of a query corresponds to an instance of a decision problem. <p> Relational calculus + constraints: We present a short but self-contained description of the relational calculus with a given a class of constraints. For more details on the relational calculus in database theory see <ref> [13, 27, 52] </ref>. 9 Definition 1.6 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> The result (interpreting the generalized relation as an infinite set of points) of 9x:R (x; y) is the set fyjy 0g, which cannot be represented by polynomial equality constraints. 2 10 Datalog + constraints: We now consider Datalog with constraints. The syntax is that of Datalog (e.g., see <ref> [1, 27, 31, 52, 53] </ref>) but we allow the bodies of rules to contain constraints. Definition 1.10 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> The definition is the same as in the case without constraints, the only difference being the use of unrestricted relational databases <ref> [27, 37, 52] </ref>. We present this definition by example. Example 1.11 Consider the Datalog query program with dense linear order constraints. <p> Tableaux query programs form such a fragment. We provide definitions and examples for them in Section 2.2, and refer to <ref> [2, 10, 30, 52] </ref> for a more detailed treatment. <p> Also, by a slight modification of [24, 57] Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. For Datalog with dense linear order constraints, we develop a bottom-up evaluation method that is closer to the classical foundations of logic programming [36] and knowledge bases <ref> [52, 53] </ref> (Section 3.2). This allows us to show that piecewise linear Datalog with dense linear order constraints can be evaluated bottom-up in closed form and NC data complexity (Section 3.3). 5.
Reference: [53] <author> J.D. Ullman, A. Van Gelder. </author> <title> Parallel Complexity of Logical Query Programs. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 5-42, </pages> <year> 1988. </year>
Reference-contexts: The result (interpreting the generalized relation as an infinite set of points) of 9x:R (x; y) is the set fyjy 0g, which cannot be represented by polynomial equality constraints. 2 10 Datalog + constraints: We now consider Datalog with constraints. The syntax is that of Datalog (e.g., see <ref> [1, 27, 31, 52, 53] </ref>) but we allow the bodies of rules to contain constraints. Definition 1.10 Let be a class of constraints. Let R 1 ; . . . ; R i ; . . . be predicate symbols, each with a fixed arity. <p> Also, by a slight modification of [24, 57] Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. For Datalog with dense linear order constraints, we develop a bottom-up evaluation method that is closer to the classical foundations of logic programming [36] and knowledge bases <ref> [52, 53] </ref> (Section 3.2). This allows us to show that piecewise linear Datalog with dense linear order constraints can be evaluated bottom-up in closed form and NC data complexity (Section 3.3). 5. <p> The (generalized) polynomial fringe property is a semantic notion. A natural class of queries can be described purely syntactically by piecewise linear programs|see <ref> [53] </ref> for the exact definition. Following [53] one can show that piecewise linear programs always have the (generalized) polynomial fringe property. Theorem 3.21 1. Datalog programs with dense linear order constraints that have the generalized polynomial fringe property can be evaluated bottom-up in closed form and NC data complexity. 2. <p> The (generalized) polynomial fringe property is a semantic notion. A natural class of queries can be described purely syntactically by piecewise linear programs|see <ref> [53] </ref> for the exact definition. Following [53] one can show that piecewise linear programs always have the (generalized) polynomial fringe property. Theorem 3.21 1. Datalog programs with dense linear order constraints that have the generalized polynomial fringe property can be evaluated bottom-up in closed form and NC data complexity. 2. <p> Piecewise linear Datalog with dense linear order constraints can be evaluated bottom-up in closed form and NC data complexity. Proof: Use the analysis of parallelism in Datalog programs by Ullman and van Gelder <ref> [53] </ref> by substituting "generalized derivation tree" for "derivation tree". 2 We close this section with the observation that our development of constraint logic programming machinery can have many applications.
Reference: [54] <author> R. van der Meyden. </author> <title> The Complexity of Querying Indefinite Data about Linearly Ordered Domains. </title> <booktitle> Proc. 11th ACM PODS, </booktitle> <pages> 331-346, </pages> <year> 1992. </year>
Reference-contexts: Discrete order can be used to model temporal databases. For recent developments of constraint-based approaches to temporal databases we refer to [4, 11, 26]. In Section 2.2, we left open the complexity of tableau containment with dense linear order inequalities. This has been recently shown p 2 -complete in <ref> [54] </ref>. It would be very interesting to study the implementation of the "declarative and efficiently evaluable" languages outlined in this paper. The results presented here should be properly viewed as positive arguments for the feasibility of such an effort.
Reference: [55] <author> P. Van Hentenryck. </author> <title> A Logic Language for Combinatorial Optimization. </title> <journal> Annals of Operations Research, </journal> <volume> 21, </volume> <pages> 247-274, </pages> <year> 1989. </year>
Reference-contexts: With the appropriate constraint theory these point-sets are accurate (and perhaps the most intuitive) representations of spatial objects. Our framework is thus one of complete information. Constraint logic programming paradigms are currently attracting a great deal of attention in languages for operations research applications <ref> [55, 56] </ref> and have also impacted the field of concurrent programming language design [48]. The use of constraints for operations research and for concurrency is sometimes semantically different from their use in our framework.
Reference: [56] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: With the appropriate constraint theory these point-sets are accurate (and perhaps the most intuitive) representations of spatial objects. Our framework is thus one of complete information. Constraint logic programming paradigms are currently attracting a great deal of attention in languages for operations research applications <ref> [55, 56] </ref> and have also impacted the field of concurrent programming language design [48]. The use of constraints for operations research and for concurrency is sometimes semantically different from their use in our framework.
Reference: [57] <author> M.Y. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> Proc. 14th ACM STOC, </booktitle> <pages> 137-146, </pages> <year> 1982. </year>
Reference-contexts: A key intuition comes from Constraint Logic Programming: a conjunction of constraints is the correct generalization of the ground fact. The technical tools for this integration are: data complexity <ref> [9, 57] </ref> from database theory, and quantifier elimination methods from mathematical logic. Let us provide some motivation for the integration of database and constraint solving methods. Manipulation of spatial data is an important application area (e.g., spatial or geographic databases) that requires both relational query language techniques and arithmetic calculations. <p> It is possible to combine them with relational calculus, but not with recursive formalisms. (b) Dense linear order constraints are also very general, since one may use them to simulate any PTIME computation (as in [24] and <ref> [57] </ref>). We devote a large part of our analysis to this case, because it best illustrates the desired integration with relational calculus and various recursive formalisms. <p> Relational calculus (Inflationary Datalog : ) with dense linear order constraints can be evaluated bottom-up in closed form and LOGSPACE (PTIME) data complexity. This is shown by adapting the proof of [18]. Also, by a slight modification of <ref> [24, 57] </ref> Inflationary Datalog : with dense linear order expresses exactly PTIME (Section 3.1). 4. For Datalog with dense linear order constraints, we develop a bottom-up evaluation method that is closer to the classical foundations of logic programming [36] and knowledge bases [52, 53] (Section 3.2). <p> Theorem 3.15 Inflationary Datalog : with dense linear order inequality constraints can express any relational database query computable in PTIME (for a formal definition of these queries see [9]). Proof: As shown in [24] and <ref> [57] </ref> the fixpoint queries of [9] together with a finite discrete linear order express exactly PTIME. It follows from the proofs of this fact, as well as the normal form results of [24, 20, 1] that Inflationary Datalog : with a finite discrete order expresses exactly PTIME.
References-found: 57

