URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-97-31.ps.gz
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Specifying Instructions' Semantics Using CSDL (Preliminary Report)  
Author: Norman Ramsey and Jack W. Davidson 
Date: November 24, 1997  
Address: Charlottesville, VA 22903  
Affiliation: Department of Computer Science University of Virginia  
Abstract-found: 0
Intro-found: 0
Reference: <author> Bailey, Mark W. and Jack W. Davidson. </author> <year> 1995 </year> <month> (January). </month> <title> A formal model and specification language for procedure calling conventions. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <address> San Francisco, CA. </address> . <year> 1996 </year> <month> (May). </month> <title> Target-sensitive construction of diagnostic programs for procedure calling sequence generators. </title> <booktitle> Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 31(5) </volume> <pages> 249-257. </pages>
Reference-contexts: These tools included an optimizer (Benitez and Davidson 1988), a debugger (Ramsey and Han-son 1992), an instruction scheduler (Proebsting and Fraser 1994), a call-sequence generator <ref> (Bailey and Davidson 1995) </ref>, a linker (Fernandez 1995), and an executable editor (Larus and Schnarr 1995). <p> The state of a machine can be described as the contents of a collection of storage spaces. We use storage spaces to model main memory, general-purpose registers, special-purpose registers, condition codes, and so on. Experience with CCL, a Calling Convention Language <ref> (Bailey and Davidson 1995) </ref>, shows that applications can be built from specifications that discuss only storage, with no reference to instructions. For example, calling conventions can be described by discussing the placement of parameters in storage cells and the the effects of calls and returns on storage. <p> For example, we want to make it easy to write an RTL that means "register rd is assigned an unspecified function of registers rs and rt." Languages in the CSDL family We consider SLED, for specifying representations of instructions (Ramsey and Fernandez 1997), and CCL, for specifying calling conventions <ref> (Bailey and Davidson 1995) </ref>, to be the first languages in the CSDL family. We are developing a new language, -RTL, for specifying instruction semantics. We expect that CSDL will expand to include languages for specifying properties of memory hierarchies and of pipelines.
Reference: <author> Bala, Vasanth and Norman Rubin. </author> <year> 1995 </year> <month> (November 29-December 1,). </month> <title> Efficient instruction scheduling using finite state automata. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 46-56, </pages> <address> Ann Arbor, Michigan. </address>
Reference: <author> Benitez, Manuel E. and Jack W. Davidson. </author> <year> 1988 </year> <month> (July). </month> <title> A portable global optimizer and linker. </title> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 23(7) </volume> <pages> 329-338. </pages>
Reference-contexts: Core aspects for CSDL To identify core aspects to be used throughout the CSDL family, we examined descriptions used to help retarget a variety of systems-level tools. These tools included an optimizer <ref> (Benitez and Davidson 1988) </ref>, a debugger (Ramsey and Han-son 1992), an instruction scheduler (Proebsting and Fraser 1994), a call-sequence generator (Bailey and Davidson 1995), a linker (Fernandez 1995), and an executable editor (Larus and Schnarr 1995). <p> Such graphs, together with the ability to match individual instructions, may suffice to build code-editing tools like EEL (Larus and Schnarr 1995) or ATOM (Srivastava and Eustace 1994). * Information about register-transfer semantics is enough to build code improvers in the style of PO (Davidson and Fraser 1980), vpo <ref> (Benitez and Davidson 1988) </ref>, and gcc (Stallman 1992). These code improvers work by pattern matching, so they need not know what all of the register-transfer operators do. <p> For use during compilation, we restrict RTLs to a subset of a full RTL language. Each RTL used in a back end based on the vpo optimizer <ref> (Benitez and Davidson 1988) </ref> must satisfy the vpo invariant for the target machine. An RTL satisfies that invariant if and only if it can be represented in a single instruction on the target machine.
Reference: <author> Davidson, Jack W. and Christopher W. Fraser. </author> <year> 1980 </year> <month> (April). </month> <title> The design and application of a retargetable peephole optimizer. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(2) </volume> <pages> 191-202. </pages>
Reference-contexts: Such graphs, together with the ability to match individual instructions, may suffice to build code-editing tools like EEL (Larus and Schnarr 1995) or ATOM (Srivastava and Eustace 1994). * Information about register-transfer semantics is enough to build code improvers in the style of PO <ref> (Davidson and Fraser 1980) </ref>, vpo (Benitez and Davidson 1988), and gcc (Stallman 1992). These code improvers work by pattern matching, so they need not know what all of the register-transfer operators do.
Reference: <author> Emmelmann, Helmut, Friedrich-Wilhelm Schroer, and Rudolf Landwehr. </author> <year> 1989 </year> <month> (July). </month> <title> BEG | a generator for efficient back ends. </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 24(7) </volume> <pages> 227-237. </pages>
Reference: <author> Fauth, Andreas, Johan Van Praet, and Markus Freericks. </author> <year> 1995 </year> <month> (March). </month> <title> Describing instruction set processors using nML. </title> <booktitle> In The European Design and Test Conference, </booktitle> <pages> pages 503-507. </pages>
Reference-contexts: It is determined by the machine, independent of any tool, so it should be useful in any specification language that deals with individual machine instructions. For example, the nML machine-description language <ref> (Fauth, Praet, and Freericks 1995) </ref> uses this structure, although nML is otherwise quite different from SLED. Properties of instructions Experience with the New Jersey Machine-Code Toolkit shows that many applications can be built from specifications that discuss only instructions and their properties, with no reference to storage.
Reference: <author> Fernandez, Mary F. </author> <year> 1995 </year> <month> (November). </month>
Reference-contexts: These tools included an optimizer (Benitez and Davidson 1988), a debugger (Ramsey and Han-son 1992), an instruction scheduler (Proebsting and Fraser 1994), a call-sequence generator (Bailey and Davidson 1995), a linker <ref> (Fernandez 1995) </ref>, and an executable editor (Larus and Schnarr 1995).
References-found: 7

