URL: http://www.cs.brown.edu/courses/cs295-8/toplas.ps
Refering-URL: http://www.cs.brown.edu/courses/cs295-8/
Root-URL: http://www.cs.brown.edu/
Title: Wait-Free Synchronization  
Author: Maurice Herlihy 
Date: January 11, 1993  
Address: One Kendall Square Cambridge, MA 02139  
Affiliation: Digital Equipment Corporation Cambridge Research Laboratory  
Abstract: A wait-free implementation of a concurrent data object is one that guarantees that any process can complete any operation in a finite number of steps, regardless of the execution speeds of the other processes. The problem of constructing a wait-free implementation of one data object from another lies at the heart of much recent work in concurrent algorithms, concurrent data structures, and multiprocessor architectures. In the first part of this paper, we introduce a simple and general technique, based on reduction to a consensus protocol, for proving statements of the form "there is no wait-free implementation of X by Y ." We derive a hierarchy of objects such that no object at one level has a wait-free implementation in terms of objects at lower levels. In particular, we show that atomic read/write registers, which have been the focus of much recent attention, are at the bottom of the hierarchy: they cannot be used to construct wait-free implementations of many simple and familiar data types. Moreover, classical synchronization primitives such as test&set and fetch&add , while more powerful than read and write, are also computationally weak, as are the standard message-passing primitives. Nevertheless, in the second part of the paper, we show that there do exist simple universal objects from which one can construct a wait-free implementation of any sequential object. A preliminary version of this paper appeared in the Proceedings of the Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, August 1988 [12]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.H. Anderson and M.G. Gouda. </author> <title> The virtue of patience: Concurrent programming with and without waiting. </title> <type> Private Communication. </type>
Reference-contexts: Similar results have been shown by Loui and Abu-Amara [21], Chor, Israeli, and Li [6], and Anderson and Gouda <ref> [1] </ref>. <p> The decision value is the input of the process whose enq occurs first. 19 decide (input: value) returns (value) prefer [P] := input 1 r [P,2] r [P,1] 2 r <ref> [i, 1] </ref> := 0 4 for i in n .. 1 do 6 then return prefer [i] 8 end if 9 end decide As usual, the protocol is wait-free, since it contains no loops. <p> Proof: An n-process consensus protocol appears in Figure 12. The processes share two arrays: prefer [1::n] and r [1::n; 1::2], where r <ref> [P; 1] </ref> is initialized to 1 and r [P; 2] to 0, for 1 P n. The protocol is clearly wait-free, since all loops are bounded. To show consistency, we use the following assertions: P (P ) r [P; 1] = 0 ^ r [P; 2] = 0 S (P ) <p> processes share two arrays: prefer [1::n] and r [1::n; 1::2], where r <ref> [P; 1] </ref> is initialized to 1 and r [P; 2] to 0, for 1 P n. The protocol is clearly wait-free, since all loops are bounded. To show consistency, we use the following assertions: P (P ) r [P; 1] = 0 ^ r [P; 2] = 0 S (P ) P (P ) _ Q (P ) It is easily checked that P (P ), Q (P ), and S (P ) are stable for each P , that P (P ) and Q (P ) are mutually <p> We claim that if P (P ) holds for some P , then Q (Q) holds for some Q &lt; P , and that every process between Q and P has stabilized. Let P be the least process for which P (P ) holds. Since r <ref> [P; 1] </ref> and r [P; 2] are both 0, some Q &lt; P must have assigned 0 to r [P; 1] (Statement #4) before P executed Statement #2. Q, however, executes Statement #2 before Statement #4, hence S (Q) holds. <p> Let P be the least process for which P (P ) holds. Since r <ref> [P; 1] </ref> and r [P; 2] are both 0, some Q &lt; P must have assigned 0 to r [P; 1] (Statement #4) before P executed Statement #2. Q, however, executes Statement #2 before Statement #4, hence S (Q) holds. Since P (Q) is false by hypothesis, Q (Q) must hold. Moreover, if Q has assigned to r [P; 1], then it has assigned to every r [P 0 ; <p> 0, some Q &lt; P must have assigned 0 to r <ref> [P; 1] </ref> (Statement #4) before P executed Statement #2. Q, however, executes Statement #2 before Statement #4, hence S (Q) holds. Since P (Q) is false by hypothesis, Q (Q) must hold. Moreover, if Q has assigned to r [P; 1], then it has assigned to every r [P 0 ; 1] for Q &lt; P 0 &lt; P , thus each such P 0 has stabilized. <p> Q, however, executes Statement #2 before Statement #4, hence S (Q) holds. Since P (Q) is false by hypothesis, Q (Q) must hold. Moreover, if Q has assigned to r [P; 1], then it has assigned to every r <ref> [P 0 ; 1] </ref> for Q &lt; P 0 &lt; P , thus each such P 0 has stabilized. Define the termination assertion as follows: T (P ) Q (P ) ^ (8Q &gt; P ) P (Q): T is stable, and it holds for at most one process.
Reference: [2] <author> J. Aspnes and M.P. Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <type> Technical Report CMU-CS-88-205, </type> <institution> CMU Computer Science Dept., </institution> <month> December </month> <year> 1988. </year> <note> To appear, Journal of Algorithms. </note>
Reference-contexts: Proof: An n-process consensus protocol appears in Figure 12. The processes share two arrays: prefer [1::n] and r [1::n; 1::2], where r [P; 1] is initialized to 1 and r <ref> [P; 2] </ref> to 0, for 1 P n. The protocol is clearly wait-free, since all loops are bounded. To show consistency, we use the following assertions: P (P ) r [P; 1] = 0 ^ r [P; 2] = 0 S (P ) P (P ) _ Q (P ) It <p> and r [1::n; 1::2], where r [P; 1] is initialized to 1 and r <ref> [P; 2] </ref> to 0, for 1 P n. The protocol is clearly wait-free, since all loops are bounded. To show consistency, we use the following assertions: P (P ) r [P; 1] = 0 ^ r [P; 2] = 0 S (P ) P (P ) _ Q (P ) It is easily checked that P (P ), Q (P ), and S (P ) are stable for each P , that P (P ) and Q (P ) are mutually exclusive, that S (P ) is <p> Let P be the least process for which P (P ) holds. Since r [P; 1] and r <ref> [P; 2] </ref> are both 0, some Q &lt; P must have assigned 0 to r [P; 1] (Statement #4) before P executed Statement #2. Q, however, executes Statement #2 before Statement #4, hence S (Q) holds. Since P (Q) is false by hypothesis, Q (Q) must hold. <p> The author [13] describes a universal construction using compare&swap that is currently being implemented on a multiprocessor. A randomized wait-free implementation of a concurrent object is one that guarantees that any process can complete any operation in a finite expected number of steps. Elsewhere <ref> [2] </ref>, we give a randomized consensus protocol using atomic registers whose expected running time is polynomial in the number of processes. This protocol has several important implications.
Reference: [3] <author> A. Bar-Noy and D. Dolev. </author> <title> Shared memory vs. message-passing in an asynchronous distributed environment. </title> <booktitle> In Eighth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 307-318, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: This protocol has several important implications. If the wait-free guarantee is allowed to be probabilistic in nature, then the hierarchy shown in Figure 1 collapses because atomic registers become universal. Moreover, combining the randomized consensus protocol with our universal construction yields a polynomial-time randomized universal construction. Bar-Noy and Dolev <ref> [3] </ref> have adapted our randomized consensus protocol to a message-passing model; that protocol can be used to manage randomized wait-free replicated data objects. 5 Conclusions Wait-free synchronization represents a qualitative break with the traditional locking-based techniques for implementing concurrent objects.
Reference: [4] <author> B. Bloom. </author> <title> Constructing two-writer atomic registers. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249-259, </pages> <year> 1987. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [5] <author> J.E. Burns and G.L. Peterson. </author> <title> Constructing multi-reader atomic values from non-atomic values. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 222-231, </pages> <year> 1987. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [6] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year> <month> 34 </month>
Reference-contexts: Similar results have been shown by Loui and Abu-Amara [21], Chor, Israeli, and Li <ref> [6] </ref>, and Anderson and Gouda [1].
Reference: [7] <author> D. Dolev, C. Dwork, and L Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A message-passing architecture (e.g., a hypercube, [28]) is a set of processors that communicate via shared FIFO queues. Theorem 12 implies that message-passing architectures cannot solve three-process consensus or implement any object that can. Dolev, Dwork, and Stockmeyer <ref> [7] </ref> give a related result: point-to-point FIFO message channels cannot solve two-process consensus. <p> That result does not imply Theorem 3, however, because atomic read/write registers lack certain commutativity properties of asynchronous message buffers. (In particular, Lemma 1 of [9] does not hold.) Dolev, Dwork, and Stockmeyer <ref> [7] </ref> give a thorough analysis of the circumstances under which consensus can be achieved by message-passing. They consider the effects of thirty-two combinations of parameters: synchronous vs. asynchronous processors, synchronous vs. asynchronous communication, FIFO vs. non-FIFO message delivery, broadcast vs. point-to-point transmission, and whether send and receive are distinct primitives.
Reference: [8] <author> G.H. Pfister et al. </author> <title> The ibm research parallel processor prototype (rp3): introduction and architecture. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <year> 1985. </year>
Reference-contexts: Our results also illustrate inherent limitations of certain multiprocessor architectures. The NYU Ultracomputer project [10] has investigated architectural support for wait-free implementations of common synchronization primitives. They use combining networks to implement fetch&add, a generalization of test&set. IBM's RP3 <ref> [8] </ref> project is investigating a similar approach. The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization [11, 14, 30]. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. [11].
Reference: [9] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: This common value is called the history's decision value. A wait-free lin-earizable implementation of a consensus object is called a consensus protocol (c.f., Fisher, Lynch, and Paterson <ref> [9] </ref>). We will investigate the circumstances under which it is possible to construct consensus protocols from particular objects. Most of the constructions presented in this paper use multi-reader/multi-writer registers in addition to the object of interest. <p> If it were possible, one could implement each individual 2m-process protocol using m 1-register assignment, yielding a 2n-process consensus protocol, contradicting Theorem 22. 3.7 Remarks Fischer, Lynch, and Paterson <ref> [9] </ref> have shown that there exists no two-process consensus protocol using message channels that permit messages to be delayed and reordered. That result does not imply Theorem 3, however, because atomic read/write registers lack certain commutativity properties of asynchronous message buffers. (In particular, Lemma 1 of [9] does not hold.) Dolev, <p> Fischer, Lynch, and Paterson <ref> [9] </ref> have shown that there exists no two-process consensus protocol using message channels that permit messages to be delayed and reordered. That result does not imply Theorem 3, however, because atomic read/write registers lack certain commutativity properties of asynchronous message buffers. (In particular, Lemma 1 of [9] does not hold.) Dolev, Dwork, and Stockmeyer [7] give a thorough analysis of the circumstances under which consensus can be achieved by message-passing.
Reference: [10] <author> A. Gottlieb, R. Grishman, C.P. Kruskal, K.P. McAuliffe, L. Rudolph, and M. Snir. </author> <title> The nyu ultracomputer designing an mimd parallel computer. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32(2):175-189, </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: These results suggest that further progress in understanding wait-free synchronization requires turning our attention from the conventional read and write operations to more fundamental primitives. Our results also illustrate inherent limitations of certain multiprocessor architectures. The NYU Ultracomputer project <ref> [10] </ref> has investigated architectural support for wait-free implementations of common synchronization primitives. They use combining networks to implement fetch&add, a generalization of test&set. IBM's RP3 [8] project is investigating a similar approach.
Reference: [11] <author> A. Gottlieb, B.D. Lubachevsky, and L. Rudolph. </author> <title> Basic techniques for the efficient coordination of very large numbers of cooperating sequential processors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 164-189, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks <ref> [11, 15] </ref>, and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> They use combining networks to implement fetch&add, a generalization of test&set. IBM's RP3 [8] project is investigating a similar approach. The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization <ref> [11, 14, 30] </ref>. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. [11]. We also show that message-passing architectures such as hypercubes [28] are not universal either. This paper is organized as follows. <p> IBM's RP3 [8] project is investigating a similar approach. The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization [11, 14, 30]. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. <ref> [11] </ref>. We also show that message-passing architectures such as hypercubes [28] are not universal either. This paper is organized as follows.
Reference: [12] <author> M.P. Herlihy. </author> <title> Impossibility and universality results for wait-free synchronization. </title> <booktitle> In Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 276-290, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: In either case, those cells cannot be reclaimed while P 's operation is in progress, since they must have at least one released bit unset. 4.3 Remarks The first universal construction <ref> [12] </ref> used unbounded memory. Plotkin [27] describes a universal construction employing "sticky-byte" registers, a kind of write-once memory. In Plotkin's construction, cells are allocated from a common pool, and reclaimed in a way similar to ours.
Reference: [13] <author> M.P. Herlihy. </author> <title> A methodology for implementing highly concurrent data structures. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> March </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: Plotkin [27] describes a universal construction employing "sticky-byte" registers, a kind of write-once memory. In Plotkin's construction, cells are allocated from a common pool, and reclaimed in a way similar to ours. The author <ref> [13] </ref> describes a universal construction using compare&swap that is currently being implemented on a multiprocessor. A randomized wait-free implementation of a concurrent object is one that guarantees that any process can complete any operation in a finite expected number of steps.
Reference: [14] <author> M.P. Herlihy and J.M. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects <ref> [14, 18, 20] </ref>. It is less clear how to show that such an implementation does not exist. <p> They use combining networks to implement fetch&add, a generalization of test&set. IBM's RP3 [8] project is investigating a similar approach. The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization <ref> [11, 14, 30] </ref>. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. [11]. We also show that message-passing architectures such as hypercubes [28] are not universal either. This paper is organized as follows. <p> Each process applies a sequence of operations to objects, issuing an invocation and receiving the associated response. The basic correctness condition for concurrent systems is linearizability <ref> [14] </ref>: although operations of concurrent processes may overlap, each operation appears to take effect instantaneously at some point between its invocation and response. <p> A triple (s 0 ; e; s) is in Steps (S) if and only if, for all component automata A, one of the following holds: (1) e is an event of A, and the projection of 1 To remain consistent with the terminology of <ref> [14] </ref>, we use "event" where Lynch and Tuttle use "operation," and "history" where they use "schedule." 5 the step onto A is a step of A, or (2) e is not an event of A, and A's state components are identical in s 0 and s. <p> Equivalently, each operation appears to take effect instantaneously at some point between its invocation and its response. A concurrent object A is linearizable <ref> [14] </ref> if, for every history H of every concurrent system fP 1 ; : : : ; P n ; A 1 ; : : :; A j ; : : : ; A m g, H jA j is linearizable. <p> Henceforth, all objects are assumed to be linearizable. Unlike related correctness conditions such as sequential consistency [17] or strict serializability [24], linearizability is a local property: a concurrent system is linearizable if and only if each individual object is linearizable <ref> [14] </ref>. We restrict our attention to linearizable concurrent systems. 2.3 Implementations An implementation of an object A is a concurrent system fF 1 ; : : : ; F n ; Rg, where the F i are called front-ends, and R is called the representation object. <p> A wait-free implementation is necessarily non-blocking, but not vice-versa, since a non-blocking implementation may permit individual processes to starve. The impossibility and universality results presented in this paper hold for non-blocking implementations as well as wait-free implementations. Elsewhere <ref> [14] </ref>, we give a non-blocking implementation of a FIFO queue, using read, fetch&add, and swap operations, that permits an arbitrary number of concurrent enq and deq operations.
Reference: [15] <author> C.P. Kruskal, L. Rudolph, , and M. Snir. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <booktitle> In Fifth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks <ref> [11, 15] </ref>, and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> wait-free implementation of any object with consensus number greater than 1 using atomic read/write registers. 3.2 Read-Modify-Write Operations 13 decide (input: value) returns (value) prefer [P] := input if RMW (r,f ) = v then return prefer [P] else return prefer [Q] end if end decide Kruskal, Rudolph, and Snir <ref> [15] </ref> have observed that many, if not all, of the classical synchronization primitives can be expressed as read-modify-write operations, defined as follows. Let r be a register, and f a function from values to values. <p> If f is the identity, RMW (r; f ) is simply a read operation. A read-modify-write operation is non-trivial if f is not the identity function. Examples of well-known nontrivial read-modify-write operations include test&set, swap, compare&swap, and fetch&add. Numerous others are given in <ref> [15] </ref>. Theorem 5 A register with any non-trivial read-modify-write operation has a consensus number at least 2. Proof: Since f is not the identity, there exists a value v such that v 6= f (v).
Reference: [16] <author> L. Lamport. </author> <title> Concurrent reading and writing. </title> <journal> Communications of the ACM, </journal> 20(11) 806-811, November 1977. <volume> 35 </volume>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [17] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: A linearizable object is thus "equivalent" to a sequential object, and its operations can also be specified by simple pre- and postconditions. Henceforth, all objects are assumed to be linearizable. Unlike related correctness conditions such as sequential consistency <ref> [17] </ref> or strict serializability [24], linearizability is a local property: a concurrent system is linearizable if and only if each individual object is linearizable [14].
Reference: [18] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects <ref> [14, 18, 20] </ref>. It is less clear how to show that such an implementation does not exist. <p> Loui and Abu-Amara [21] give a number of constructions and impossibility results for consensus protocols using shared read-modify-write registers, which they call "test&set" registers. Among other results, they show that n-process consensus for n &gt; 2 cannot be solved by read-modify-write operations on single-bit registers. Lamport <ref> [18] </ref> gives a queue implementation that permits one enqueuing process to execute concurrently with one dequeuing process. With minor changes, this implementation can be transformed into a wait-free implementation using atomic read/write registers.
Reference: [19] <author> L. Lamport. </author> <title> On interprocess communication, parts i and ii. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 77-101, </pages> <year> 1986. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers <ref> [19] </ref>, complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area. <p> Some of their results translate directly into our model: it is impossible to achieve two-process consensus by communicating through a shared channel that supports either broadcast with unordered delivery, or point-to-point transmission with FIFO delivery. Broadcast with ordered delivery, however, does solve n-process consensus. A safe read/write register <ref> [19] </ref> is one that behaves like an atomic read/write register as long as operations do not overlap. If a read overlaps a write, 25 however, no guarantees are made about the value read.
Reference: [20] <author> V. Lanin and D. Shasha. </author> <title> Concurrent set manipulation without locking. </title> <booktitle> In Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 211-220, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers [4, 5, 16, 23, 25, 26, 29, 31], read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects <ref> [14, 18, 20] </ref>. It is less clear how to show that such an implementation does not exist.
Reference: [21] <author> M.C. Loui and H.H. Abu-Amara. </author> <title> Memory Requirements for Agreement Among Unreliable Asynchronous Processes, </title> <booktitle> volume 4, </booktitle> <pages> pages 163-183. </pages> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: Similar results have been shown by Loui and Abu-Amara <ref> [21] </ref>, Chor, Israeli, and Li [6], and Anderson and Gouda [1]. <p> Since atomic reg-isters implement safe registers, safe registers cannot solve two-process consensus, and hence the impossibility results we derive for atomic registers apply equally to safe registers. Similar remarks apply to atomic registers that restrict the number of readers or writers. Loui and Abu-Amara <ref> [21] </ref> give a number of constructions and impossibility results for consensus protocols using shared read-modify-write registers, which they call "test&set" registers. Among other results, they show that n-process consensus for n &gt; 2 cannot be solved by read-modify-write operations on single-bit registers.
Reference: [22] <author> N.A. Lynch and M.R. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: In particular, operations that do not overlap take effect in their "real-time" order. 2.1 I/O Automata Formally, we model objects and processes using a simplified form of I/O automata <ref> [22] </ref>. Because the wait-free condition does not require any fairness or liveness conditions, and because we consider only finite sets of processes and objects, we do not make use of the full power of the I/O automata formalism.
Reference: [23] <author> R. Newman-Wolfe. </author> <title> A protocol for wait-free, atomic, multi-reader shared variables. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 232-249, </pages> <year> 1987. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [24] <author> C.H. Papadimitriou. </author> <title> The serializability of concurrent database updates. </title> <journal> Journal of the ACM, </journal> <volume> 26(4) </volume> <pages> 631-653, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: A linearizable object is thus "equivalent" to a sequential object, and its operations can also be specified by simple pre- and postconditions. Henceforth, all objects are assumed to be linearizable. Unlike related correctness conditions such as sequential consistency [17] or strict serializability <ref> [24] </ref>, linearizability is a local property: a concurrent system is linearizable if and only if each individual object is linearizable [14].
Reference: [25] <author> G.L. Peterson. </author> <title> Concurrent reading while writing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 46-55, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [26] <author> G.L. Peterson and J.E. Burns. </author> <title> Concurrent reading while writing ii: the multi-writer case. </title> <type> Technical Report GIT-ICS-86/26, </type> <institution> Georgia Institute of Technology, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [27] <author> S.A. Plotkin. </author> <title> Sticky bits and universality of consensus. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 159-176, </pages> <year> 1989. </year>
Reference-contexts: A consensus object provides a single operation: decide (input: value) returns (value) 9 A protocol's sequential specification is simple: all decide operations re-turn the argument value of the first decide (c.f., Plotkin's "sticky-bit" <ref> [27] </ref>). This common value is called the history's decision value. A wait-free lin-earizable implementation of a consensus object is called a consensus protocol (c.f., Fisher, Lynch, and Paterson [9]). We will investigate the circumstances under which it is possible to construct consensus protocols from particular objects. <p> In either case, those cells cannot be reclaimed while P 's operation is in progress, since they must have at least one released bit unset. 4.3 Remarks The first universal construction [12] used unbounded memory. Plotkin <ref> [27] </ref> describes a universal construction employing "sticky-byte" registers, a kind of write-once memory. In Plotkin's construction, cells are allocated from a common pool, and reclaimed in a way similar to ours. The author [13] describes a universal construction using compare&swap that is currently being implemented on a multiprocessor.
Reference: [28] <author> C.L. Seitz. </author> <title> The cosmic cube. </title> <journal> Communications of the ACM, </journal> <volume> 28(1), </volume> <month> January </month> <year> 1985. </year> <month> 36 </month>
Reference-contexts: The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization [11, 14, 30]. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. [11]. We also show that message-passing architectures such as hypercubes <ref> [28] </ref> are not universal either. This paper is organized as follows. <p> Trivial variations of this argument can be applied to show that many similar data types, such as sets, stacks, double-ended queues, and priority queues, all have consensus number 2. A message-passing architecture (e.g., a hypercube, <ref> [28] </ref>) is a set of processors that communicate via shared FIFO queues. Theorem 12 implies that message-passing architectures cannot solve three-process consensus or implement any object that can. Dolev, Dwork, and Stockmeyer [7] give a related result: point-to-point FIFO message channels cannot solve two-process consensus.
Reference: [29] <author> A.K. Singh, J.H. Anderson, and M.G. Gouda. </author> <title> The elusive atomic regis-ter revisited. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 206-221, </pages> <year> 1987. </year>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
Reference: [30] <author> H.S. Stone. </author> <title> Database applications of the fetch-and-add instruction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-33(7):604-612, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: They use combining networks to implement fetch&add, a generalization of test&set. IBM's RP3 [8] project is investigating a similar approach. The fetch&add operation is quite flexible: it can be used for semaphores, for highly concurrent queues, and even for database synchronization <ref> [11, 14, 30] </ref>. Nevertheless, we show that it is not universal, disproving a conjecture of Gottlieb et al. [11]. We also show that message-passing architectures such as hypercubes [28] are not universal either. This paper is organized as follows.
Reference: [31] <author> P. Vitanyi and B. Awerbuch. </author> <title> Atomic shared register access by asynchronous hardware. </title> <booktitle> In Proceedings of of the 27th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 223-243, </pages> <year> 1986. </year> <note> See also errata in SIGACT News 18(4), </note> <month> Summer, </month> <year> 1987. </year> <month> 37 </month>
Reference-contexts: Most of the current literature takes this approach. Examples include "atomic" registers from non-atomic "safe" registers [19], complex atomic registers from simpler atomic registers <ref> [4, 5, 16, 23, 25, 26, 29, 31] </ref>, read-modify-write operations from combining networks [11, 15], and typed objects such as queues or sets from simpler objects [14, 18, 20]. It is less clear how to show that such an implementation does not exist. <p> A machine architecture or programming language is computationally powerful enough to support arbitrary wait-free synchronization if and only if it provides a universal object as a primitive. Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [4, 5, 16, 19, 23, 25, 26, 29, 31] </ref>. Our results address a basic question: what are these registers good for? Can they be used to construct wait-free implementations of more complex data structures? We show that atomic registers have few, if any, interesting applications in this area.
References-found: 31

