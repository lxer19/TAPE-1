URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/able/ftp/intro_softarch.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/able/www/paper_abstracts/intro_softarch.html
Root-URL: http://www.cs.cmu.edu
Title: An Introduction to Software Architecture  
Author: David Garlan and Mary Shaw David Garlan and Mary Shaw 
Keyword: Software architecture, software design, software engineering  
Note: Also published as An Introduction to Software Architecture, Advances in Software Engineering and Knowledge Engineering, Volume I, edited by V.Ambriola and G.Tortora, World Scientific Publishing Company, New Jersey,  1994 by  
Address: Pittsburgh, PA 15213-3890  
Affiliation: School of Computer Science Carnegie Mellon University  
Pubnum: CMU-CS-94-166  
Date: January 1994  1993.  
Abstract: Also appears as CMU Software Engineering Institute Technical Report CMU/SEI-94-TR-21, ESC-TR-94-21. This work was funded in part by the Department of Defense Advanced Research Project Agency under grant MDA972-92-J-1002, by National Science Foundation Grants CCR-9109469 and CCR-9112880, and by a grant from Siemens Corporate Research. It was also funded in part by the Carnegie Mellon University School of Computer Science and Software Engineering Institute (which is sponsored by the U.S. Department of Defense). The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government, the Department of Defense, the National Science Foundation, Siemens Corporation, or Carnegie Mellon University. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Garlan, M. Shaw, C. Okasaki, C. Scott, and R. Swonger, </author> <title> Experience with a course on architectures for software systems, </title> <booktitle> in Proceedings of the Sixth SEI Conference on Software Engineering Education, </booktitle> <publisher> Springer-Verlag, LNCS 376, </publisher> <month> October </month> <year> 1992. </year>
Reference: [2] <author> M. Shaw, </author> <title> Toward higher-level abstractions for software systems, </title> <journal> in Data & Knowledge Engineering, </journal> <volume> vol. 5, </volume> <pages> pp. 119-128, </pages> <publisher> North Holland: Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference: [3] <author> M. Shaw, </author> <title> Heterogeneous design idioms for software architecture, </title> <booktitle> in Proceedings of the Sixth International Workshop on Software Specification and Design, IEEE Computer Society, Software Engineering Notes, (Como, Italy), </booktitle> <pages> pp. 158-165, </pages> <month> October 25-26, </month> <year> 1991. </year>
Reference: [4] <author> M. Shaw, </author> <title> Software architectures for shared information systems, in Mind Matters: Contributions to Cognitive and Computer Science in Honor of Allen Newell, </title> <publisher> Erlbaum, </publisher> <year> 1993. </year>
Reference: [5] <author> R. Allen and D. Garlan, </author> <title> A formal approach to software architectures, </title> <booktitle> in Proceedings of IFIP92 (J. </booktitle> <editor> van Leeuwen, ed.), </editor> <publisher> Elsevier Science Publishers B.V., </publisher> <month> September </month> <year> 1992. </year> <title> Garlan & Shaw: An Introduction to Software Architecture 38 </title>
Reference-contexts: Furthermore, the correctness of the output of a pipe and filter network should not depend on the order in which the filters perform their incremental processingalthough fair scheduling can be assumed. (See <ref> [5] </ref> for an in-depth discussion of this style and its formal properties.) Figure 1 illustrates this style.
Reference: [6] <author> D. Garlan and D. Notkin, </author> <title> Formalizing design spaces: Implicit invocation mechanisms, </title> <booktitle> in VDM91: Formal Software Development Methods. (Noordwijkerhout, The Netherlands), </booktitle> <pages> pp. 31-44, </pages> <publisher> Springer-Verlag, LNCS 551, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Case Study 2: Instrumentation Software Our second case study describes the industrial development of a software architecture at Tektronix, Inc. This work was carried out as a collaborative effort between several Tektronix product divisions and the Computer Research Laboratory over a three year period <ref> [6] </ref>. The purpose of the project was to develop a reusable system architecture for oscilloscopes. An oscilloscope is an instrumentation system that samples electrical signals and displays pictures (called traces) of them on a screen. Additionally, oscilloscopes perform measurements on the signals, and also display these on the screen.
Reference: [7] <author> D. Garlan, G. E. Kaiser, and D. Notkin, </author> <title> Using tool abstraction to compose systems, </title> <journal> IEEE Computer, </journal> <volume> vol. 25, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: For this reason, most implicit invocation systems also include explicit invocation (i.e., normal procedure call) as a complementary form of interaction. Examples of systems with implicit invocation mechanisms abound <ref> [7] </ref>. They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking [28, 29]. <p> Since its introduction, the problem has become well-known and is widely used as a teaching device in software engineering. Garlan, Kaiser, and Notkin also use the problem to illustrate modularization schemes based on implicit invocation <ref> [7] </ref>. While KWIC can be implemented as a relatively small system it is not simply of pedagogical interest. Practical instances of it are widely used by Garlan & Shaw: An Introduction to Software Architecture 17 computer scientists. <p> The main problem is that to add new functions to the system, the implementor must either modify the existing modulescompromising their simplicity and integrityor add new modules that lead to performance penalties. (See <ref> [7] </ref> for a detailed discussion.) Solution 3: Implicit Invocation The third solution uses a form of component integration based on shared data similar to the first solution. However, there are two important differences. First, the interface to the data is more abstract.
Reference: [8] <author> A. Z. Spector et al., Camelot: </author> <title> A distributed transaction facility for Mach and the Internet - an interim report, </title> <type> Tech. Rep. </type> <institution> CMU-CS-87-129, Carnegie Mellon University, </institution> <month> June </month> <year> 1987. </year>
Reference: [9] <author> M. Fridrich and W. </author> <title> Older, Helix: The architecture of the XMS distributed file system, </title> <journal> IEEE Software, </journal> <volume> vol. 2, </volume> <pages> pp. 21-29, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: In this application area each layer provides a substrate for communication at some level of abstraction. Lower levels define lower levels of interaction, the lowest typically being defined by hardware connections. Other application areas for this style include database systems and operating systems <ref> [9, 32, 33 ] </ref>. Layered systems have several desirable properties. First, they support design based on increasing levels of abstraction. This allows implementors to partition a complex problem into a sequence of incremental steps. Second, they support enhancement.
Reference: [10] <author> M. A. Linton, </author> <title> Distributed management of a software database, </title> <journal> IEEE Software, </journal> <volume> vol. 4, </volume> <pages> pp. 70-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: The architecture encourages a client server model for the structuring of applications.[9] We have chosen a distributed, objectoriented approach to managing information. <ref> [10] </ref> The easiest way to make the canonical sequential compiler into a concurrent compiler is to pipeline the execution of the compiler phases over a number of processors. . . .
Reference: [11] <author> V. Seshadri et al., </author> <title> Sematic analysis in a concurrent compiler, </title> <booktitle> in Proceedings of ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, ACM SIGPLAN Notices, </booktitle> <year> 1988. </year>
Reference: [12] <author> M. C. Paulk, </author> <title> The ARC Network: A case study, </title> <journal> IEEE Software, </journal> <volume> vol. 2, </volume> <pages> pp. 61-69, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Examples include the International Standard Organization's Open Systems Interconnection Reference Model (a layered network architecture) <ref> [12] </ref>, the NIST/ECMA Reference Model (a generic software engineering environment architecture based on layered communication substrates) [13, 14], and the X Window System (a distributed windowed user interface architecture based on event triggering and callbacks) [15].
Reference: [13] <author> M. Chen and R. J. Norman, </author> <title> A framework for integrated case, </title> <journal> IEEE Software, </journal> <volume> vol. 9, </volume> <pages> pp. 18-22, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Examples include the International Standard Organization's Open Systems Interconnection Reference Model (a layered network architecture) [12], the NIST/ECMA Reference Model (a generic software engineering environment architecture based on layered communication substrates) <ref> [13, 14] </ref>, and the X Window System (a distributed windowed user interface architecture based on event triggering and callbacks) [15]. We are still far from having a well-accepted taxonomy of such architectural paradigms, let alone a fully-developed theory of software architecture.
Reference: [14] <institution> NIST/ECMA reference model for frameworks of software engineering environments. </institution> <note> NIST Special Publication 500-201, </note> <month> December </month> <year> 1991. </year>
Reference-contexts: Examples include the International Standard Organization's Open Systems Interconnection Reference Model (a layered network architecture) [12], the NIST/ECMA Reference Model (a generic software engineering environment architecture based on layered communication substrates) <ref> [13, 14] </ref>, and the X Window System (a distributed windowed user interface architecture based on event triggering and callbacks) [15]. We are still far from having a well-accepted taxonomy of such architectural paradigms, let alone a fully-developed theory of software architecture.
Reference: [15] <author> R. W. Scheifler and J. Gettys, </author> <title> The X window system, </title> <journal> AACM Transactions on Graphics, </journal> <volume> vol. 5, </volume> <pages> pp. 79-109, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Examples include the International Standard Organization's Open Systems Interconnection Reference Model (a layered network architecture) [12], the NIST/ECMA Reference Model (a generic software engineering environment architecture based on layered communication substrates) [13, 14], and the X Window System (a distributed windowed user interface architecture based on event triggering and callbacks) <ref> [15] </ref>. We are still far from having a well-accepted taxonomy of such architectural paradigms, let alone a fully-developed theory of software architecture. But we can now clearly identify a number of architectural patterns, or styles, that currently form the basic repertoire of a software architect. 3.
Reference: [16] <author> M. J. Bach, </author> <title> The Design of the UNIX Operating System, ch. </title> <booktitle> 5.12, </booktitle> <pages> pp. 111-119. </pages> <booktitle> Software Series, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: In these systems pipes no longer serve the function of providing a stream of data, and therefore are largely vestigial. Hence such systems are best treated as instances of a separate architectural style. The best known examples of pipe and filter architectures are programs written in the Unix shell <ref> [16] </ref>. Unix supports this style by providing a notation for connecting components (represented as Unix processes) and by providing run time mechanisms for implementing pipes. As another well-known example, traditionally compilers have been viewed as a pipeline systems (though the phases are often not incremental).
Reference: [17] <author> N. Delisle and D. Garlan, </author> <title> Applying formal specification to industrial problems: A specification of an oscilloscope, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1990. </year>
Reference-contexts: The stages in the pipeline include lexical analysis, parsing, semantic analysis, code generation. (We return to this example in the case studies.) Other examples of pipes and filters occur in signal processing domains <ref> [17] </ref>, functional programming [18], and distributed systems [19]. Pipe and filter systems have a number of nice properties. First, they allow the designer to understand the overall input/output behavior of a system as a simple composition of the behaviors of the individual filters. <p> For example, the acquisition filter might have parameters that determine sample rate and waveform duration. These inputs serve as configuration parameters for the oscilloscope. Formally, the filters can be modelled as higher-order functions, for which the configuration parameters determine what data transformation the filter will perform. (See <ref> [17] </ref> for this interpretation of the architecture.) Figure 14 illustrates this architecture. Couple Acquire ClipTo-XY Measure Signal Waveform Trace Measurement Times Coupling Kind,Rate Trans Size Trigger subsystem The introduction of a control interface solves a large part of the user interface problem.
Reference: [18] <author> G. Kahn, </author> <title> The semantics of a simple language for parallel programming, </title> <booktitle> Information Processing, </booktitle> <year> 1974. </year>
Reference-contexts: The stages in the pipeline include lexical analysis, parsing, semantic analysis, code generation. (We return to this example in the case studies.) Other examples of pipes and filters occur in signal processing domains [17], functional programming <ref> [18] </ref>, and distributed systems [19]. Pipe and filter systems have a number of nice properties. First, they allow the designer to understand the overall input/output behavior of a system as a simple composition of the behaviors of the individual filters.
Reference: [19] <author> M. R. Barbacci, C. B. Weinstock, and J. M. Wing, </author> <booktitle> Programming at the processor-memory-switch level, in Proceedings of the 10th International Conference on Software Engineering, (Singapore), </booktitle> <pages> pp. 19-28, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1988. </year>
Reference-contexts: The stages in the pipeline include lexical analysis, parsing, semantic analysis, code generation. (We return to this example in the case studies.) Other examples of pipes and filters occur in signal processing domains [17], functional programming [18], and distributed systems <ref> [19] </ref>. Pipe and filter systems have a number of nice properties. First, they allow the designer to understand the overall input/output behavior of a system as a simple composition of the behaviors of the individual filters.
Reference: [20] <author> G. E. Kaiser and D. Garlan, </author> <title> Synthesizing programming environments from reusable features, in Software Reusability (T. </title> <editor> J. Biggerstaff and A. J. Perlis, eds.), </editor> <volume> vol. 2, </volume> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Garlan & Shaw: An Introduction to Software Architecture 9 The use of abstract data types, and increasingly the use of objectoriented systems, is, of course, widespread. There are many variations. For example, some systems allow objects to be concurrent tasks; others allow objects to have multiple interfaces <ref> [20, 21] </ref>. Objectoriented systems have many nice properties, most of which are well known. Because an object hides its representation from its clients, it is possible to change the implementation without affecting those clients.
Reference: [21] <author> W. Harrison, RPDE: </author> <title> A framework for integrating tool fragments, </title> <journal> IEEE Software, </journal> <volume> vol. 4, </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: Garlan & Shaw: An Introduction to Software Architecture 9 The use of abstract data types, and increasingly the use of objectoriented systems, is, of course, widespread. There are many variations. For example, some systems allow objects to be concurrent tasks; others allow objects to have multiple interfaces <ref> [20, 21] </ref>. Objectoriented systems have many nice properties, most of which are well known. Because an object hides its representation from its clients, it is possible to change the implementation without affecting those clients.
Reference: [22] <author> C. Hewitt, </author> <title> Planner: A language for proving theorems in robots, </title> <booktitle> in Proceedings of the First International Joint Conference in Artificial Intelligence, </booktitle> <year> 1969. </year>
Reference-contexts: However, recently there has been considerable interest in an alternative integration technique, variously referred to as implicit invocation, reactive integration, and selective broadcast. This style has historical roots in systems based on actors <ref> [22] </ref>, constraint satisfaction, daemons, and packetswitched networks. The idea behind implicit invocation is that instead of invoking a procedure directly, a component can announce (or broadcast) one or more events. Other components in the system can register an interest in an event by associating a procedure with the event. <p> For this reason, most implicit invocation systems also include explicit invocation (i.e., normal procedure call) as a complementary form of interaction. Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints <ref> [22, 25] </ref>, in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking [28, 29]. One important benefit of implicit invocation is that it provides strong support for reuse.
Reference: [23] <author> S. P. Reiss, </author> <title> Connecting tools using message passing in the field program development environment, </title> <journal> IEEE Software, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: When the event is announced the system itself invokes all of the procedures that have been registered for the event. Thus an event announcement ``implicitly'' causes the invocation of procedures in other modules. For example, in the Field system <ref> [23] </ref>, tools such as editors and variable monitors register for a debuggers breakpoint events. When a debugger stops at a breakpoint, it announces an event that allows the system to automatically invoke methods in those registered tools. <p> For this reason, most implicit invocation systems also include explicit invocation (i.e., normal procedure call) as a complementary form of interaction. Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools <ref> [23, 24] </ref>, in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking [28, 29].
Reference: [24] <author> C. Gerety, </author> <title> HP Softbench: A new generation of software development tools, </title> <type> Tech. Rep. </type> <institution> SESD-89-25, Hewlett-Packard Software Engineering Systems Division, Fort Collins, Colorado, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: For this reason, most implicit invocation systems also include explicit invocation (i.e., normal procedure call) as a complementary form of interaction. Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools <ref> [23, 24] </ref>, in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking [28, 29].
Reference: [25] <author> R. M. Balzer, </author> <title> Living with the next generation operating system, </title> <booktitle> in Proceedings of the 4th World Computer Conference, </booktitle> <month> September </month> <year> 1986. </year> <title> Garlan & Shaw: An Introduction to Software Architecture 39 </title>
Reference-contexts: For this reason, most implicit invocation systems also include explicit invocation (i.e., normal procedure call) as a complementary form of interaction. Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints <ref> [22, 25] </ref>, in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking [28, 29]. One important benefit of implicit invocation is that it provides strong support for reuse.
Reference: [26] <author> G. Krasner and S. Pope, </author> <title> A cookbook for using the model-view-controller user interface paradigm in Smalltalk-80, </title> <journal> Journal of Object Oriented Programming, </journal> <volume> vol. 1, </volume> <pages> pp. 26-49, </pages> <month> August/September </month> <year> 1988. </year>
Reference-contexts: Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data <ref> [26, 27] </ref>, and by syntax-directed editors to support incremental semantic checking [28, 29]. One important benefit of implicit invocation is that it provides strong support for reuse. Any component can be introduced into a system simply by registering it for the events of that system.
Reference: [27] <author> M. Shaw, E. Borison, M. Horowitz, T. Lane, D. Nichols, and R. Pausch, </author> <title> Descartes: A programming-language approach to interactive display interfaces, </title> <booktitle> Proceedings of SIGPLAN 83: Symposium on Programming Language Issues in Software Systems, ACM SIGPLAN Notices, </booktitle> <volume> vol. 18, </volume> <pages> pp. 100-111, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Examples of systems with implicit invocation mechanisms abound [7]. They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data <ref> [26, 27] </ref>, and by syntax-directed editors to support incremental semantic checking [28, 29]. One important benefit of implicit invocation is that it provides strong support for reuse. Any component can be introduced into a system simply by registering it for the events of that system.
Reference: [28] <author> A. N. Habermann and D. S. Notkin, </author> <title> Gandalf: Software development environments, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, </volume> <pages> pp. 1117-1127, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking <ref> [28, 29] </ref>. One important benefit of implicit invocation is that it provides strong support for reuse. Any component can be introduced into a system simply by registering it for the events of that system. A second benefit is that implicit invocation eases system evolution [30].
Reference: [29] <author> A. N. Habermann, D. Garlan, and D. Notkin, </author> <title> Generation of integrated taskspecific software environments, </title> <note> in CMU Computer Science: </note> <editor> A 25th Commemorative (R. F. Rashid, ed.), </editor> <booktitle> Anthology Series, </booktitle> <pages> pp. 69-98, </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: They are used in programming environments to integrate tools [23, 24], in database management systems to ensure consistency constraints [22, 25], in user interfaces to separate presentation of data from applications that manage the data [26, 27], and by syntax-directed editors to support incremental semantic checking <ref> [28, 29] </ref>. One important benefit of implicit invocation is that it provides strong support for reuse. Any component can be introduced into a system simply by registering it for the events of that system. A second benefit is that implicit invocation eases system evolution [30].
Reference: [30] <author> K. Sullivan and D. Notkin, </author> <title> Reconciling environment integration and component independence, </title> <booktitle> in Proceedings of ACM SIGSOFT90: Fourth Symposium on Software Development Environments, </booktitle> <pages> pp. 22-23, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: One important benefit of implicit invocation is that it provides strong support for reuse. Any component can be introduced into a system simply by registering it for the events of that system. A second benefit is that implicit invocation eases system evolution <ref> [30] </ref>. Components may be replaced by other components without affecting the interfaces of other components in the system. In contrast, in a system based on explicit invocation, whenever the identity of a that provides some system function is changed, all other modules that import that module must also be changed.
Reference: [31] <author> G. R. McClain, ed., </author> <title> Open Systems Interconnection Handbook. </title> <address> New York, NY: </address> <publisher> Intertext Publications McGraw-Hill Book Company, </publisher> <year> 1991. </year>
Reference-contexts: Topological constraints include limiting interactions to adjacent layers. Figure 3 illustrates this style. Core Level Basic Utility Useful Systems Users Composites of various elements Usually procecure calls The most widely known examples of this kind of architectural style are layered communication protocols <ref> [31] </ref>. In this application area each layer provides a substrate for communication at some level of abstraction. Lower levels define lower levels of interaction, the lowest typically being defined by hardware connections. Other application areas for this style include database systems and operating systems [9, 32, 33 ].
Reference: [32] <author> D. Batory and S. OMalley, </author> <title> The design and implementation of hierarchical software systems using reusable components, </title> <type> Tech. Rep. </type> <institution> TR-91-22, Department of Computer Science, University of Texas, Austin, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: In this application area each layer provides a substrate for communication at some level of abstraction. Lower levels define lower levels of interaction, the lowest typically being defined by hardware connections. Other application areas for this style include database systems and operating systems <ref> [9, 32, 33 ] </ref>. Layered systems have several desirable properties. First, they support design based on increasing levels of abstraction. This allows implementors to partition a complex problem into a sequence of incremental steps. Second, they support enhancement.
Reference: [33] <author> H. C. Lauer and E. H. Satterthwaite, </author> <title> Impact of MESA on system design, </title> <booktitle> in Proceedings of the Third International Conference on Software Engineering, </booktitle> <address> (Atlanta, GA), </address> <pages> pp. 174-175, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1979. </year>
Reference-contexts: In this application area each layer provides a substrate for communication at some level of abstraction. Lower levels define lower levels of interaction, the lowest typically being defined by hardware connections. Other application areas for this style include database systems and operating systems <ref> [9, 32, 33 ] </ref>. Layered systems have several desirable properties. First, they support design based on increasing levels of abstraction. This allows implementors to partition a complex problem into a sequence of incremental steps. Second, they support enhancement.
Reference: [34] <author> H. P. Nii, </author> <title> Blackboard systems Parts 1 & 2, </title> <journal> AI Magazine, </journal> <volume> vol. </volume> <pages> 7 nos 3 (pp. 38-53) and 4 (pp. 62-69), </pages> <year> 1986. </year>
Reference-contexts: Blackboard systems have traditionally been used for applications requiring complex interpretations of signal processing, such as speech and pattern recognition. Several of these are surveyed by Nii <ref> [34] </ref>. They have also appeared in other kinds of systems that involve shared access to data with loosely coupled agents [35]. There are, of course, many other examples of repository systems. Batch-sequential systems with global databases are a special case. <p> In this model, the solution space is organized into several application-dependent hierarchies and the domain knowledge is Garlan & Shaw: An Introduction to Software Architecture 34 partitioned into independent modules of knowledge that operate on knowledge within and between levels <ref> [34] </ref>.
Reference: [35] <author> V. Ambriola, P. Ciancarini, and C. Montangero, </author> <title> Software process enactment in oikos, </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, SIGSOFT Software Engineering Notes, </booktitle> <address> (Irvine, CA), </address> <pages> pp. 183-192, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Blackboard systems have traditionally been used for applications requiring complex interpretations of signal processing, such as speech and pattern recognition. Several of these are surveyed by Nii [34]. They have also appeared in other kinds of systems that involve shared access to data with loosely coupled agents <ref> [35] </ref>. There are, of course, many other examples of repository systems. Batch-sequential systems with global databases are a special case. Programming environments are often organized as a collection of tools together with a shared repository of programs and program fragments [36].
Reference: [36] <editor> D. R. Barstow, H. E. Shrobe, and E. Sandewall, eds., </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill Book Co., </publisher> <year> 1984. </year>
Reference-contexts: There are, of course, many other examples of repository systems. Batch-sequential systems with global databases are a special case. Programming environments are often organized as a collection of tools together with a shared repository of programs and program fragments <ref> [36] </ref>. Even applications that have been traditionally viewed as pipeline architectures, may be more accurately interpreted as repository systems.
Reference: [37] <author> G. R. Andrews, </author> <title> Paradigms for process interaction in distributed programs, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 23, </volume> <pages> pp. 49-90, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Some are widespread and others are specific to particular domains. While a complete treatment of these is beyond the scope of this paper, we briefly note a few of the important categories. Distributed processes: Distributed systems have developed a number of common organizations for multi-process systems <ref> [37] </ref>. Some can be characterized primarily by their topological features, such as ring and star organizations. Others are better characterized in terms of the kinds of inter-process protocols that are used for communication (e.g., heartbeat algorithms). One common form of distributed system architecture is a clientserver organization [38].
Reference: [38] <author> A. Berson, </author> <title> Client/Server Architecture. </title> <publisher> McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: Some can be characterized primarily by their topological features, such as ring and star organizations. Others are better characterized in terms of the kinds of inter-process protocols that are used for communication (e.g., heartbeat algorithms). One common form of distributed system architecture is a clientserver organization <ref> [38] </ref>. In these systems a server represents a process that provides services to other processes (the clients). Usually the server does not know in advance the identities or number of clients that will access it at run time.
Reference: [39] <author> E. Mettala and M. H. Graham, eds., </author> <title> The DomainSpecific Software Architecture Program. No. </title> <institution> CMU/SEI-92-SR-9, Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: The main program acts as the driver for the subroutines, typically providing a control loop for sequencing through the subroutines in some order. Domainspecific software architectures: Recently there has been considerable interest in developing reference architectures for specific domains <ref> [39] </ref>. These architectures provide an organizational structure tailored to a family of applications, such as avionics, command and control, or vehicle management systems. By specializing the architecture to the domain, it is possible to increase the descriptive power of structures.
Reference: [40] <author> D. Harel, Statecharts: </author> <title> A visual formalism for complex systems, </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 8, </volume> <pages> pp. 231-274, </pages> <year> 1987. </year>
Reference-contexts: Indeed, in many cases the architecture is sufficiently constrained that an executable system can be generated automatically or semiautomatically from the architectural description itself. State transition systems: A common organization for many reactive systems is the state transition system <ref> [40] </ref>. These systems are defined in terms a set of states and a set of named transitions that move a system from one state to another. Process control systems: Systems intended to provide dynamic control of a physical environment are often organized as process control systems [41].
Reference: [41] <author> K. J. strm and B. Wittenmark, </author> <title> Computer-Controlled Systems Design. </title> <publisher> Prentice Hall, </publisher> <editor> second ed., </editor> <year> 1990. </year>
Reference-contexts: These systems are defined in terms a set of states and a set of named transitions that move a system from one state to another. Process control systems: Systems intended to provide dynamic control of a physical environment are often organized as process control systems <ref> [41] </ref>. These systems are roughly characterized as a feedback loop in which inputs from sensors are used by the process control system to determine a set of outputs that will produce a new state of the environment. 3.8.
Reference: [42] <author> D. L. Parnas, </author> <title> On the criteria to be used in decomposing systems into modules, </title> <journal> Communications of the ACM, </journal> <volume> vol. 15, </volume> <pages> pp. 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: The third case study examines the familiar compiler architecture in a fresh light. The remaining three case studies present examples of the use of heterogeneous architectures. 4.1. Case Study 1: Key Word in Context In his paper of 1972, Parnas proposed the following problem <ref> [42] </ref>: The KWIC [Key Word in Context] index system accepts an ordered set of lines, each line is an ordered set of words, and each word is an ordered set of characters.
Reference: [43] <institution> PROVOX plus Instrumentation System: System overview, </institution> <year> 1989. </year>
Reference-contexts: Case 4: A Layered Design with Different Styles for the Layers The PROVOX system by Fisher Controls offers distributed process control for chemical production processes <ref> [43] </ref>. Process control capabilities range from simple control loops that control pressure, flow, or levels to complex strategies involving interrelated control loops. Provisions are made for integration with plant management and information systems in support of computer integrated manufacturing.
Reference: [44] <author> F. Hayes-Roth, </author> <title> Rule-based systems, </title> <journal> Communications of the ACM, </journal> <volume> vol. 28, </volume> <pages> pp. 921-932, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Since these rules are not directly executable by available computers, systems for interpreting such rules must be provided. Hayes-Roth surveyed the architecture and operation of rule-based systems <ref> [44] </ref>. The basic features of a rule-based system, shown in Hayes-Roths rendering as Figure 21, are essentially the features of a tabledriven interpreter, as outlined earlier.
References-found: 44

