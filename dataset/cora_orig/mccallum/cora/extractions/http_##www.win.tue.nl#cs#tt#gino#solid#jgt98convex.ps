URL: http://www.win.tue.nl/cs/tt/gino/solid/jgt98convex.ps
Refering-URL: http://www.win.tue.nl/cs/tt/gino/solid/index.html
Root-URL: http://www.win.tue.nl
Email: E-mail: gino@win.tue.nl  
Title: A Fast and Robust GJK Implementation for Collision Detection of Convex Objects  
Author: GINO VAN DEN BERGEN 
Date: August 28, 1998  
Address: P.O. Box 513, 5600 MB Eindhoven The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: This paper presents an implementation of the Gilbert-Johnson-Keerthi distance algorithm that has improved performance, robustness, and versatility over earlier implementations. The algorithm presented here is especially fit for use in collision detection of objects modeled using various types of primitives, such as spheres, cones, and cylinders, as used, for instance, in VRML. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <booktitle> In Proc. SIGGRAPH '90, </booktitle> <volume> volume 24, </volume> <pages> pages 19-28, </pages> <year> 1990. </year>
Reference-contexts: The idea of caching separating planes in-between frames for faster intersec-tion testing was introduced by Baraff <ref> [1] </ref>.
Reference: [2] <author> G. Bell, R. Carey, and C. Marrin. VRML97: </author> <title> The virtual reality modeling language. </title> <note> http://www.vrml.org/Specifications/VRML97, 1997. </note>
Reference-contexts: Finally, regarding versatility, we show how GJK can be applied to a large family of geometric primitives, which includes boxes, spheres, cones and cylinders, and their images under affine transformation, thus demonstrating the utility of GJK for collision detection of objects described in VRML <ref> [2] </ref>. The C ++ source code for the GJK implementation presented here is released as part of the Software Library for Interference Detection (SOLID) version 2.0 1 . The rest of this paper is organized as follows. Section 2 describes the generalized GJK distance algorithm. <p> In this section we discuss the computation of the support points for a number of geometric primitives and their images under affine transformation. Using the support mappings presented here, the GJK algorithm can be applied to distance computation and collision detection between objects described in VRML <ref> [2] </ref>. Given s A , a support mapping of a convex object A, and T.x/ D Bx C c, an affine transformation, we find a support mapping for T. A/, the image of A under T, as follows.
Reference: [3] <author> S. Cameron. </author> <title> Enhancing GJK: Computing minimum and penetration distances between convex polyhedra. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 3112-3117, </pages> <year> 1997. </year>
Reference-contexts: A/g, where vert. A/ is the set of vertices of A. A support point of a polytope is computed in time linear to the number of vertices of the polytope. However, it has been mentioned in a number of publications <ref> [4, 3, 9] </ref> that by exploiting frame coherence, the cost of computing a support point of a convex polyhedron can be reduced to almost constant time. For this purpose, an adjacency graph is maintained with each polytope. Each edge on the polytope is an edge in the graph. <p> This feature is convenient for exploiting frame coherence, as we will show next. Similar to closest point tracking algorithms, such as Lin and Canny's closest feature algorithm [7], or Cameron's Enhanced GJK algorithm <ref> [3] </ref>, an incremental version of the GJK collision detection algorithm shows almost constant time complexity per frame for convex objects of arbitrary complexity, by exploiting frame coherence. The incremental GJK collision detection algorithm exploits frame coherence by using the separating axis from the previous frame as initial vector for v.
Reference: [4] <author> K. Chung and W. Wang. </author> <title> Quick collision detection of polytopes in virtual environments. </title> <booktitle> In Proc. ACM Symposium on Virtual Reality Software and Technology, </booktitle> <pages> pages 125-131, </pages> <year> 1996. </year>
Reference-contexts: A/g, where vert. A/ is the set of vertices of A. A support point of a polytope is computed in time linear to the number of vertices of the polytope. However, it has been mentioned in a number of publications <ref> [4, 3, 9] </ref> that by exploiting frame coherence, the cost of computing a support point of a convex polyhedron can be reduced to almost constant time. For this purpose, an adjacency graph is maintained with each polytope. Each edge on the polytope is an edge in the graph.
Reference: [5] <author> E. G. Gilbert and C.-P. Foo. </author> <title> Computing the distance between general convex objects in three-dimensional space. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 6(1) </volume> <pages> 53-61, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The Gilbert-Johnson-Keerthi distance algorithm (GJK) is an iterative method for computing the distance between convex objects [6]. The original GJK distance algorithms was applicable to polytopes only, until Gilbert and Foo presented a generalized GJK algorithm to be used for general convex objects <ref> [5] </ref>. We will discuss the generalized algorithm here. This paper presents a GJK that has improved performance, robustness, and versatility over earlier implementations. <p> Section 4 discusses the performance improvements of our implementation. And finally, Section 5 shows what causes the numerical problems of GJK and how to tackle these problems. 2 Overview of GJK This section describes the extended GJK for general convex objects, first presented in <ref> [5] </ref>. Readers unfamiliar with the concepts and notations used here are referred to Appendix A. The GJK algorithm computes the distance between a pair of convex objects. The distance between objects A and B, denoted by d. A; B/, is defined by d.
Reference: [6] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between complex objects in three-dimensional space. </title> <journal> IEEE Journal of Robotics and Automation, </journal> <volume> 4(2) </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The Gilbert-Johnson-Keerthi distance algorithm (GJK) is an iterative method for computing the distance between convex objects <ref> [6] </ref>. The original GJK distance algorithms was applicable to polytopes only, until Gilbert and Foo presented a generalized GJK algorithm to be used for general convex objects [5]. We will discuss the generalized algorithm here. This paper presents a GJK that has improved performance, robustness, and versatility over earlier implementations. <p> Let w k D s AB .v k /, where s AB is a support mapping of A B, and let v kC1 D v.conv.W k [ fw k g//. It is shown in <ref> [6] </ref> that indeed kv kC1 k &lt; kv k k. The set of vertices of the new simplex W kC1 is constructed as the smallest set X W k [ fw k g such that v.conv.X // D v kC1 . <p> The dashed lines represent the support planes H .v k ; v k w k /. The points of W k are drawn in black. For polytopes, GJK arrives at v k D v. A B/ in a finite number of iterations <ref> [6] </ref>. For non-polytopes this may not be the case. For these type of objects, it is necessary that the algorithm terminates as soon as v k lies within a given tolerance from v. A B/. The error of v k is estimated by maintaining a lower bound for kv. <p> It is hinted in <ref> [6] </ref> that by caching and reusing results of dot products, a substantial performance improvement can be obtained. Since some or all vertices in W k reappear in W kC1 , many dot products from the k-th iteration are also needed in the k C 1-th iteration. <p> This results in a large relative error in the computed value of 1 i .X /, causing a number of irregularities in the GJK algorithm. 11 One of these irregularities was addressed in the original paper <ref> [6] </ref>. Due to a large relative error, the sign of the computed value of 1 i .X / may be incorrect. As a result of this, the subalgorithm will not be able to find a subset X that satisfies the stated criteria.
Reference: [7] <author> M. C. Lin and J. F. Canny. </author> <title> A fast algorithm for incremental distance computation. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 1008-1014, </pages> <year> 1991. </year>
Reference-contexts: This feature is convenient for exploiting frame coherence, as we will show next. Similar to closest point tracking algorithms, such as Lin and Canny's closest feature algorithm <ref> [7] </ref>, or Cameron's Enhanced GJK algorithm [3], an incremental version of the GJK collision detection algorithm shows almost constant time complexity per frame for convex objects of arbitrary complexity, by exploiting frame coherence.
Reference: [8] <author> J. Nagle. </author> <title> GJK collision detection algorithm wanted. </title> <booktitle> posted on the comp.graphics.algorithms newsgroup, </booktitle> <month> June </month> <year> 1998. </year> <month> 15 </month>
Reference-contexts: Regarding robustness, we present a solution to a termination problem in GJK due to rounding errors, which was noted by Nagle <ref> [8] </ref>. Finally, regarding versatility, we show how GJK can be applied to a large family of geometric primitives, which includes boxes, spheres, cones and cylinders, and their images under affine transformation, thus demonstrating the utility of GJK for collision detection of objects described in VRML [2]. <p> Should the algorithm continue iterating after this event, then it will infinitely loop, since each iteration will result in the same vector being computed. Despite these precautions, the algorithm may still encounter configurations of objects that cause it to loop infinitely, as noted by Nagle <ref> [8] </ref>. This problem may occur when two polytopes that differ a few orders of magnitude in size are in close proximity of each other. Due to the difference in size, the Minkowski difference of the objects has extremely oblong shaped facets.
Reference: [9] <author> C. J. Ong and E. G. Gilbert. </author> <title> The Gilbert-Johnson-Keerthi distance algorithm: A fast version for incremental motions. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 1183-1189, </pages> <year> 1997. </year>
Reference-contexts: A/g, where vert. A/ is the set of vertices of A. A support point of a polytope is computed in time linear to the number of vertices of the polytope. However, it has been mentioned in a number of publications <ref> [4, 3, 9] </ref> that by exploiting frame coherence, the cost of computing a support point of a convex polyhedron can be reduced to almost constant time. For this purpose, an adjacency graph is maintained with each polytope. Each edge on the polytope is an edge in the graph.
Reference: [10] <author> R. Rabbitz. </author> <title> Fast collision detection of moving convex polyhedra. </title> <editor> In P. Heck-bert, editor, </editor> <booktitle> Graphics Gems IV, </booktitle> <pages> pages 83-109. </pages> <publisher> Academic Press, </publisher> <address> Boston, MA, </address> <year> 1994. </year>
Reference-contexts: Hence, in these cases, a single iteration of GJK takes (almost) constant time. This approach differs from another GJK based incremental collision detection algorithm presented by Rabbitz in <ref> [10] </ref>, which uses GJK to find a separating plane, defined by a pair of closest points, as a witness of the separation of a pair of ob 10 jects. The idea of caching separating planes in-between frames for faster intersec-tion testing was introduced by Baraff [1].
References-found: 10

