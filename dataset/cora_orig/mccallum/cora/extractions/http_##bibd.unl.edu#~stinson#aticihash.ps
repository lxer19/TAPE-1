URL: http://bibd.unl.edu/~stinson/aticihash.ps
Refering-URL: http://bibd.unl.edu/~stinson/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: atici@ube.ege.edu.tr  stinson@bibd.unl.edu  rwei@cse.unl.edu  
Title: A New Practical Algorithm for the Construction of a Perfect Hash Function  
Author: M. Atici D. R. Stinson R. Wei 
Keyword: perfect hash family, perfect hash function, program size, complexity.  
Address: Ege, Izmir-Turkey  Lincoln, NE 68588  Lincoln, NE 68588  
Affiliation: International Computer Institute University of  Department of Computer Science and Engineering University of Nebraska,  Department of Mathematics and Statistics University of Nebraska,  
Abstract: A perfect hash function for a subset X of f0; 1; ; n 1g is an injection h from X into the set f0; 1; ; m 1g. Perfect hash functions are useful for the compact storage and fast retrieval of frequently used objects. In this paper, we discuss some new practical algorithms for efficient construction of perfect hash functions, and we analyze their complexity and program size.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Atici, S. S. Magliveras, D. R. Stinson and W.-D. Wei. </author> <title> Some Recursive Constructions for Perfect Hash Families. </title> <journal> Journal of Combinatorial Designs 4 (1996), </journal> <pages> 353-363. </pages>
Reference-contexts: These are simple "base" PHFs which will be used as initial families in our main recursive construction. The first construction is based on a finite affine plane (see <ref> [1, Corollary 3.2] </ref> ). Let q be a prime power such that q + 1 &gt; w . <p> In the case n = w + 1, we obtain a PHF 2 c + 1; n; w; w , which can be shown to be optimal. 2.2 A Recursive Construction In this section, we describe the recursive construction given in <ref> [1] </ref>. We begin with a specific type of difference matrix. Suppose that the integers n; w have the property that gcd (n; 2 !) = 1. <p> Using the difference matrices constructed above, and iterating Lemma 2.1, we have the following theorem. Theorem 2.3 <ref> [1] </ref> Suppose there exists a PHF (N 0 ; n 0 ; m; w), where gcd (n 0 ; w !) = 1.
Reference: [2] <author> C. J. Colbourn and J. H. Dinitz. </author> <title> CRC Handbook of Combinatorial Designs, </title> <publisher> CRC Press, </publisher> <year> 1996. </year>
Reference-contexts: 0 i w This is called an (n; w +1)-difference matrix, since for all i 1 ; i 2 such that 0 i 1 &lt; i 2 w we have fd i 1 ;j d i 2 ;j mod n : 0 j n 1g = Z n . (See <ref> [2] </ref> for more information about difference matrices.) The following lemma ([1, Theorem 4.1]) gives a recursive construction for PHF that uses difference matrices. Lemma 2.1 Suppose there is an (n 0 ; w + 1)-difference matrix and a PHF (N 0 ; n 0 ; m; w).
Reference: [3] <author> Z. J. Czech, G. Havas and B. S. Majewski. </author> <title> Perfect Hashing, </title> <booktitle> Theoretical Computer Science 182 (1997), </booktitle> <pages> 1-143. </pages>
Reference-contexts: Minimal perfect hash functions have applications in compilers, operating systems, language translation systems, hypertext, hypermedia, file managers, and information retrieval systems. For more information about perfect hash functions and minimal perfect hash functions, readers can consult the recent survey paper <ref> [3] </ref> and its references. The purpose of this paper is to present some new practical algorithms for construction of a perfect hash function. The efficiency of the algorithm is measured in three ways. <p> Thus the program size is bounded above by j log w 2 + log N 0 &lt; 2 log w log log n + w log w: It is known that any minimal PHF has program size that is (log log n + w) (see, e.g., [4, p. 129] or <ref> [3, p. 9] </ref>). So our construction is not much larger than an optimal one. In the encoding of PHF that we use, we have a sequence at most log log n d's (produced by Algorithm 3.5), where 0 d i q 1 for each i. <p> Now we briefly analyze the complexity of the algorithms to construct and evaluate a hash function. For simplicity, we use the "uniform cost" model which assumes that any arithmetic operation can be done in O (1) time (see, e.g., <ref> [3, p.10] </ref>). As above, we are considering the case w = m and we assume that q &lt; w 2 has been determined in a preprocessing step. Step (1) of Algorithm 3.5 requires O (log log n) iterations.
Reference: [4] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 1: Sorting and Searching, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year> <month> 13 </month>
Reference-contexts: We will use this representation in some small examples in the sequel. Let N (n; m; w) denote the smallest value of N for which a PHF (N ; n; m; w) exists. In <ref> [4] </ref>, N (n; m; w) is proved to be fi (log n). However, the proof of [4] is not constructive, and it seems difficult to give explicit constructions that are good asymptotically. Hence, it is interesting to find explicit constructions for PHFs. <p> Let N (n; m; w) denote the smallest value of N for which a PHF (N ; n; m; w) exists. In <ref> [4] </ref>, N (n; m; w) is proved to be fi (log n). However, the proof of [4] is not constructive, and it seems difficult to give explicit constructions that are good asymptotically. Hence, it is interesting to find explicit constructions for PHFs. We use some constructions where N is a polynomial function of log n (for fixed m and w). <p> = w w : Thus the program size is bounded above by j log w 2 + log N 0 &lt; 2 log w log log n + w log w: It is known that any minimal PHF has program size that is (log log n + w) (see, e.g., <ref> [4, p. 129] </ref> or [3, p. 9]). So our construction is not much larger than an optimal one. In the encoding of PHF that we use, we have a sequence at most log log n d's (produced by Algorithm 3.5), where 0 d i q 1 for each i.
References-found: 4

