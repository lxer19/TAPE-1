URL: ftp://ftp.cs.princeton.edu/pub/people/rjl/bio.ps
Refering-URL: http://theory.lcs.mit.edu/~rajiyer/Penn/reading_list.html
Root-URL: 
Email: rjl@princeton.edu  
Title: Speeding Up Computations via Molecular Biology  
Author: Richard J. Lipton 
Address: Princeton, NJ 08540  
Affiliation: Princeton University  
Abstract: We show how to extend the recent result of Adleman [1] to use biological experiments to directly solve any NP problem. We, then, show how to use this method to speedup a large class of important problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman, </author> <title> Molecular Computation of Solutions to Combinatorial Problems. </title> <journal> Science, </journal> <volume> vol. 266, </volume> <month> Nov. 11, </month> <year> 1994. </year>
Reference-contexts: 1. Introduction In a recent breakthrough Adleman <ref> [1] </ref> showed how to use biological experiments to solve instances of the famous Hamiltonian Path Problem (HPP). Since this problem is known to be NP-complete it follows that biology can be used to solve any problem from NP. <p> In particular, we can extend the method of Adleman in an essential way that allows biological computers to potentially radically change the way that we do all computations not just HPP's. Our main first point is that we can extend Adleman <ref> [1] </ref> to show that we can build a biological computer that can solve any NP problem directly. This is important since our biological machines will be limited in the amount of parallelism that they can perform. <p> If one used the standard reduction, then the best SAT problem one could solve in this way would be tiny. Our biological machines will also have some other technical advantages over the original method of <ref> [1] </ref>. <p> Call this problem the (n; s)-Formula Satisfaction Problem (FSP). Our main result is the following: Theorem 2: Any (n; n c ) FSP can be solved with at most O (n c ) biological steps. Note, the original result from <ref> [1] </ref> only works for the special case of HPP. There the formulas F are of a very simple form. The main advantage of our result is that the formula F can be arbitrary. <p> Biological Computations In this section we will give the exact model of biological computing. We will then show how to prove our main theorem about solving instances of FSP. The key issue is what is the model of biological computation? In this regard we follow <ref> [1] </ref> closely. We assume in particular the following simple model. The fundamental 2 concept of a biological computation is that of a set of DNA strands. Since this are usually kept in a test tube will say that a test tube is just a collection of pieces of DNA. <p> Clearly, this is an advantage over the method in <ref> [1] </ref>. The set of DNA in this test tube corresponds to the following simple graph G n . The test tube is formed in the same way that [1] forms the test tube of all paths to find the Hamitonian Path (see also Appendix). <p> Clearly, this is an advantage over the method in <ref> [1] </ref>. The set of DNA in this test tube corresponds to the following simple graph G n . The test tube is formed in the same way that [1] forms the test tube of all paths to find the Hamitonian Path (see also Appendix).
Reference: [2] <author> H. Cohen, </author> <title> A Course in Computational Algebraic Number Theory, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We can, however, say something about some problems that are not exactly search problems. Consider the problem of factoring integers. The inner loop of many fast methods is the search to find y = x 2 mod N so that y factors completely over a given "factor basis" (see <ref> [2] </ref> for details). It is clear that we can speedup the naiive search for such any y by a factor of 2 n .
References-found: 2

