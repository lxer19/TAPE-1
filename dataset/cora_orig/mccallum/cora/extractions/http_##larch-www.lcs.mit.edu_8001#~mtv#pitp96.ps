URL: http://larch-www.lcs.mit.edu:8001/~mtv/pitp96.ps
Refering-URL: http://larch-www.lcs.mit.edu:8001/~mtv/
Root-URL: 
Email: kapur@cs.albany.edu  mtv@lcs.mit.edu  
Phone: +1 518 442-4281,  2  +1 617 253-3538,  
Title: DLP: A Paradigm for Parallel Interactive Theorem Proving  
Author: Deepak Kapur and Mark T. Vandevoorde 
Address: New York, Albany, NY 12222.  Cambridge, MA 02139.  
Affiliation: 1 Dept. of Computer Science, State University of  Lab. for Computer Science, Massachusetts Institute of Technology,  
Abstract: A new paradigm for parallel interactive theorem proving is advocated using DLP, a distributed and parallel version of LP, the Larch Prover. The rewrite-rule based parallel prover runs on a network of workstations. The amount and nature of parallelism are under explicit user control, unlike other parallel theorem provers in which parallelism is hidden from the user. The main objective is to exploit parallelism for enhancing user productivity in finding proofs of conjectures by induction and other first-order inference methods. The user is encouraged to try different combinations of high-level inference steps automatically and in parallel, leading to multiple proof attempts. While some parallel attempts compete, others cooperate by doing subparts of a problem. When no attempt leads to a proof, the user gets a global view of all attempts on the conjecture with the theorem prover generating useful feedback. A parallel interface provides mechanisms for managing multiple proof attempts. The effectiveness of the proposed paradigm is reflected from the fact that DLP has been successfully used to easily prove a variety of problems from a wide source, including well-known and difficult problems. The proposed paradigm is contrasted with approaches supported in other parallel theorem provers.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Avenhaus, J., and Denzinger, D., </author> <title> "Distributed equational theorem proving," </title> <booktitle> Proc. 5th Conf. on Rewriting Techniques and Applications, </booktitle> <publisher> LNCS 690 (ed. Kirchner), </publisher> <address> Montreal, 62-76, </address> <year> 1993. </year> <month> 14 </month>
Reference-contexts: Once again, this level of hidden parallelism does not affect user's interaction with the theorem prover. An interesting approach is taken in the DISCOUNT system, a rewrite-rule, completion based prover <ref> [1] </ref>. The Knuth-Bendix completion procedure is run wth different strategies and heuristics to generate possibly different consequences by forward inference steps. A referee then decides based on some criterion, which results from the different attempts to include for future computations and which results to discard.
Reference: 2. <author> Bonacina, M. P., and Hsiang, J., </author> <title> "Distributed deduction by clause diffusion: the Aquarius Prover," </title> <booktitle> Proc. 3rd Intl. Symp. on Design and Implementation of Symbolic Computation Systems, </booktitle> <editor> (ed. Moila), </editor> <publisher> LNCS 722, </publisher> <address> Austria, 272-287, </address> <year> 1993. </year>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> Almost linear speed-ups are reported for a number of challenging theorem proving problems. Peers is another parallel prover built using OTTER using clause diffusion methodology [3] (see also <ref> [2] </ref>). Clauses get dynamically divided among loosely-coupled deduction processes possibly using different strategies and cooperating to prove a theorem. There is no master-slave type of organization. The user, however, has little control on the amount and nature of parallelism as the algorithm for allocating clauses to processes is fixed.
Reference: 3. <author> Bonacina, M. P., and McCune, W., </author> <title> "Distributed theorem proving by Peers," </title> <booktitle> Proc. 12th Intl. Conf. on Automated Deduction (CADE-12), </booktitle> <publisher> LNAI 814 (ed. Bundy), </publisher> <address> Nancy, France, </address> <year> 1994, </year> <pages> 841-845. </pages>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> The user has little control over the amount and nature of parallelism except for specifying the number of processors to be used. Almost linear speed-ups are reported for a number of challenging theorem proving problems. Peers is another parallel prover built using OTTER using clause diffusion methodology <ref> [3] </ref> (see also [2]). Clauses get dynamically divided among loosely-coupled deduction processes possibly using different strategies and cooperating to prove a theorem. There is no master-slave type of organization.
Reference: 4. <author> Bose, S., Clarke, E.M., Long, D.E., and Michaylov, S., "Parthenon: </author> <title> A parallel theorem prover for non-Horn clauses," </title> <editor> J. </editor> <booktitle> Automated Reasoning, </booktitle> <year> 1989. </year>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> There is no master-slave type of organization. The user, however, has little control on the amount and nature of parallelism as the algorithm for allocating clauses to processes is fixed. Parallel provers based on model elimination including Parthenon <ref> [4] </ref>, Meteor [7], and Partheo [20], support or-parallelism. The emphasis is to prove formulas in lesser time by using different processors searching independent parts of the search space.
Reference: 5. <author> Boyer, R.S., and Moore, J S. </author> <title> A Computational Logic Handbook. </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: This is evident, e.g., from the literature on applying formal methods to reason about complex systems usings provers such as LP, the Larch Prover [8], RRL, Rewrite Rule Laboratory [13], Nqthm, the Boyer-Moore prover <ref> [5] </ref>, etc. This paper proposes a new paradigm for parallel, interactive theorem proving with the main objective of enhancing user productivity. This is achieved by a parallel interface that supports a two-part approach to finding proofs. <p> The objective here is to provide the user quick feedback that is helpful in speculating such lemmas. The proposed approach, we believe, is also well suited for theorem provers employing sophisticated heuristics and in which intermediate lemmas are automatically speculated based on abstracting common subexpressions by variables <ref> [13, 5] </ref>, failure analysis of proof attempts, and analysis of plausible induction schemes. The proposed paradigm is illustrated using DLP, the Distributed Larch Prover, a distributed and parallel version of LP, the Larch Prover.
Reference: 6. <author> Chu, H., and Plaisted, D., </author> <title> "Semantically guided first-order theorem proving using hyper linking," </title> <booktitle> Proc. 12th Intl. Conf. on Automated Deduction (CADE-11), </booktitle> <publisher> LNAI 814 (ed. Bundy), </publisher> <address> Nancy, France, </address> <year> 1994, </year> <pages> 192-206. </pages>
Reference-contexts: He was curious whether DLP could prove the properties without much user guidance. 5 See <ref> [18, 6] </ref> for a discussion of the performance of various theorem provers on this problem 6 Our formalization is in http://larch-www.lcs.mit.edu:8001/%7Emtv/Checkerboard.html 11 When proving these lemmas, we discovered the following paradigm to be extremely useful: 1. Broadcast spec to all conjectures to see how many conjectures are proved automatically. 2. <p> Whenever we proved a conjecture, we were able to resume the paradigm above. Bledsoe's Intermediate Value Theorem This theorem is viewed as a major challenge for theorem provers <ref> [18, 6] </ref>. Without using specialized inference methods for transitive relations, this theorem is difficult to prove. 7 In [18], Nie and Plaisted discussed a problem reduction format strategy in which combining many heuristics including interpretations, case analysis, and semantic deletion, they reported proving two lemmas from which the theorem follows. <p> Without using specialized inference methods for transitive relations, this theorem is difficult to prove. 7 In [18], Nie and Plaisted discussed a problem reduction format strategy in which combining many heuristics including interpretations, case analysis, and semantic deletion, they reported proving two lemmas from which the theorem follows. In <ref> [6] </ref>, this problem is solved using semantic hyper-linking. The second author first tried to prove the first lemma in [18]. The default proof strategy of spec generated a single proof attempt by contradiction which did not succeed automatically.
Reference: 7. <editor> Fronhoefer, B., and Wrightson, G. (eds). </editor> <title> Parallelization in Inference Systems. </title> <booktitle> Proc. of Intl. Workshop, </booktitle> <address> Germany, Dec. 1990, </address> <publisher> Springer LNAI 590, </publisher> <year> 1992. </year>
Reference-contexts: Theorem proving tasks require search and are computationally intensive, thus making them a natural problem for applying parallelism. In <ref> [7] </ref>, a number of papers discussing different approaches for parallelizing theorem provers as well as descriptions of parallel theorem provers are given, including a paper surveying parallel theorem proving efforts until 1992. <p> The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. ROO is a parallel version of OTTER, one of the fastest resolution-based theorem prover, running on a shared-memory multiprocessors <ref> [14, 7] </ref>. ROO parallelizes the fundamental closure algorithm of OTTER for computing resolvents by considering many given clauses in 2 stead of only a single given clause in the sequential case. <p> There is no master-slave type of organization. The user, however, has little control on the amount and nature of parallelism as the algorithm for allocating clauses to processes is fixed. Parallel provers based on model elimination including Parthenon [4], Meteor <ref> [7] </ref>, and Partheo [20], support or-parallelism. The emphasis is to prove formulas in lesser time by using different processors searching independent parts of the search space. <p> The user has little control over the amount and kind of parallelism supported in proving a formula. One obvious approach towards parallelizing a rewrite-based prover is to exploit parallelism in low-level, primitive inference steps, e.g., rewriting, unification and normalization <ref> [7] </ref>, for instance, different subterms in a formula can be rewritten in parallel. In [24], a parallelization of a completion-based prover on shared memory architecture is described in which critical pair computations among different rules and inner-normalization in the Knuth-Bendix completion procedure are done in parallel.
Reference: 8. <author> Garland, S., and Guttag, J., </author> <title> "An overview of LP," </title> <booktitle> Proc. 3rd Intl. Conf. on Rewriting Techniques and Applications (RTA-89), </booktitle> <publisher> LNCS 355 (ed. Dershowitz), </publisher> <address> Chapel Hill, NC, </address> <year> 1989, </year> <pages> 137-151. </pages>
Reference-contexts: For most nontrivial theorems, however, even automatic theorem provers need considerable user interaction, guidance and experimentation for finding proofs. This is evident, e.g., from the literature on applying formal methods to reason about complex systems usings provers such as LP, the Larch Prover <ref> [8] </ref>, RRL, Rewrite Rule Laboratory [13], Nqthm, the Boyer-Moore prover [5], etc. This paper proposes a new paradigm for parallel, interactive theorem proving with the main objective of enhancing user productivity. This is achieved by a parallel interface that supports a two-part approach to finding proofs. <p> In DLP, it would not be sound for one proof attempt to make use of a fact derived by another. 3 Adding Automated Proof Strategies to LP We begin with a brief overview of LP, and discuss its main inference mechanisms. More details can be found in <ref> [8, 9] </ref>. Next, we discuss the proof finding process and how to speed it up with automated proof strategies. <p> We explain DLP's new commands, spec and find , used to support automated proof strategies. 3.1 Background: LP, the Larch Prover LP was developed at MIT by Steve Garland and John Guttag to reason about designs for circuits, concurrent algorithms, hardware, and software <ref> [8] </ref>.
Reference: 9. <author> Garland, S., and Guttag, J. </author> <title> A guide to LP, The Larch Prover. </title> <type> TR 82, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: In DLP, it would not be sound for one proof attempt to make use of a fact derived by another. 3 Adding Automated Proof Strategies to LP We begin with a brief overview of LP, and discuss its main inference mechanisms. More details can be found in <ref> [8, 9] </ref>. Next, we discuss the proof finding process and how to speed it up with automated proof strategies. <p> described in the following quote taken from the introduction for LP 3.1 documentation "Un-like most theorem provers, which attempt to find proofs automatically for correctly stated conjectures, LP is intended to assist users in finding and correcting flaws in conjectures|the predominant activity in the early stages of the design process." <ref> [9] </ref> Thus, LP gives the user considerable control in guiding the proof finding process. The theorem proving approach in LP is based on term rewriting techniques. LP automatically attempts to transform every formula into a terminating rewrite rule.
Reference: 10. <editor> Gordon, M.J.C. and Melham, T.F. (eds). </editor> <title> Introduction to HOL : a theorem proving environment for higher order logic, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: Other options are discussed in section 4. Proof strategies supported by spec are a bit like tactics in HOL <ref> [10] </ref> and related systems. Unlike HOL, in which intricate tactics can be expressed in a functional programming language to put together complex proof strategies for combining very primitive inference steps, DLP provides a fixed but programmable scheme for combining a few useful top-level backward and forward inference mechanisms.
Reference: 11. <author> Hasegawa, R., Koshimura, M., and Fujita, H., </author> <title> "MGTP: A parallel theorem prover based on lazy model generation," </title> <booktitle> Proc. 11th Intl. Conf. on Automated Deduction (CADE-11), </booktitle> <publisher> LNAI 607 (ed. Kapur), </publisher> <address> Saratoga Springs, NY, </address> <year> 1992, </year> <pages> 731-734. </pages>
Reference-contexts: Parallel provers based on model elimination including Parthenon [4], Meteor [7], and Partheo [20], support or-parallelism. The emphasis is to prove formulas in lesser time by using different processors searching independent parts of the search space. MGTP <ref> [11] </ref> is based on model generation paradigm with different processors generating model candidates in parallel to try to generate a model for non-Horn formulae. The user has little control over the amount and kind of parallelism supported in proving a formula.
Reference: 12. <author> Kapur, D., </author> <title> "What are the connections, inter-relations and antipathies between proof checking and automated theorem proving?" The QED II Workshop report (ed. </title> <institution> R. Matuszewski), L/1/95, Warsaw University, </institution> <month> Oct. </month> <year> 1995. </year>
Reference: 13. <author> Kapur, D., and Zhang, H., </author> <title> "An overview of Rewrite Rule Laboratory (RRL)," </title> <journal> J. Computer and Mathematics with Applications, </journal> <volume> 29, 2, </volume> <year> 1995, </year> <pages> 91-114, </pages>
Reference-contexts: For most nontrivial theorems, however, even automatic theorem provers need considerable user interaction, guidance and experimentation for finding proofs. This is evident, e.g., from the literature on applying formal methods to reason about complex systems usings provers such as LP, the Larch Prover [8], RRL, Rewrite Rule Laboratory <ref> [13] </ref>, Nqthm, the Boyer-Moore prover [5], etc. This paper proposes a new paradigm for parallel, interactive theorem proving with the main objective of enhancing user productivity. This is achieved by a parallel interface that supports a two-part approach to finding proofs. <p> The objective here is to provide the user quick feedback that is helpful in speculating such lemmas. The proposed approach, we believe, is also well suited for theorem provers employing sophisticated heuristics and in which intermediate lemmas are automatically speculated based on abstracting common subexpressions by variables <ref> [13, 5] </ref>, failure analysis of proof attempts, and analysis of plausible induction schemes. The proposed paradigm is illustrated using DLP, the Distributed Larch Prover, a distributed and parallel version of LP, the Larch Prover.
Reference: 14. <author> Lusk, E. L., McCune, W.W., and Slaney, J., "Roo: </author> <title> A parallel theorem prover," </title> <booktitle> Proc. 11th Intl. Conf. on Automated Deduction (CADE-11), </booktitle> <publisher> LNAI 607 (ed. Kapur), </publisher> <address> Saratoga Springs, NY, </address> <year> 1992, </year> <pages> 731-734. </pages>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. ROO is a parallel version of OTTER, one of the fastest resolution-based theorem prover, running on a shared-memory multiprocessors <ref> [14, 7] </ref>. ROO parallelizes the fundamental closure algorithm of OTTER for computing resolvents by considering many given clauses in 2 stead of only a single given clause in the sequential case.
Reference: 15. <author> McCarthy, J., </author> <title> "The mutilated checkerboard in set theory," in The QED II Work shop report (ed. </title> <institution> R. Matuszewski), L/1/95, Warsaw University, </institution> <month> Oct. </month> <year> 1995, </year> <note> http: //www.mcs.anl.gov/qed/index.html. </note>
Reference-contexts: McCarthy posed a specific version of this problem (with checkerboard of size 8 x 8) as a challenge to be proved automatically for automatic theorem provers <ref> [15] </ref>. Whereas we cannot hope for an interactive prover like DLP to meet McCarthy's challenge to automatically generate a proof, we decided to attempt a general version of this problem by proving the theorem for boards of any size using DLP.
Reference: 16. <author> McCune, W., </author> <title> "Otter 2.0," </title> <booktitle> Proc. 10th Intl. Conf. on Automated Deduction (CADE-10), </booktitle> <publisher> LNAI 449 (ed. Stickel), </publisher> <address> Kaiserslautern, Germany, </address> <year> 1990, </year> <pages> 663-664. </pages>
Reference-contexts: 1 Introduction and Motivation Despite considerable progress in the development of automated reasoning methods and systems, the dream of having a program automatically prove simple theorems needed, for instance, in design, analysis and verification of specifications, software and hardware, is quite far from being realized. Automatic theorem provers (e.g. OTTER <ref> [16] </ref> for first-order and equality reasoning) can prove many interesting, nontrivial theorems automatically. For most nontrivial theorems, however, even automatic theorem provers need considerable user interaction, guidance and experimentation for finding proofs.
Reference: 17. <author> Nelson, G., </author> <title> "Verifying Reachability Invariants of Linked Structures," </title> <booktitle> Proc. Tenth ACM Sym posium on Principles of Programming Languages, </booktitle> <year> 1983, </year> <pages> 38-47. </pages>
Reference-contexts: Other problems|e.g., insertion sort, properties of finite sets, sequences, double-ended queues, and natural numbers|require induction. At the suggestion of Jim Saxe, we also tried proving properties of the reachability relation of linked linear lists based on an axiomatization proposed in <ref> [17] </ref> (see Appendix). 4 We also experimented with problems never tried, to our knowledge, using LP before. This included some well-known and difficult first-order problems including Bledsoe's Intermediate Value Theorem, 5 McCarthy's mutilated checkerboard problem, and a problem involving equalities in non-unit clauses suggested by Ganzinger (personal communication). <p> similar to that of the Intermediate Value problem, the same proof strategy used for the Intermediate Value problem was tried, and it worked. 7 Ganzinger's Saturate system, which supports implementation of special rules for transitive rela tions, for instance, solves this problem fairly easily. 12 Reachability of Linked Lists In <ref> [17] </ref>, Nelson formalized the reachability theory of linear lists, and then reported hand proofs of many properties useful for reasoning about linear lists in programs (see Appendix for the axiomatization and properties of interest). All the proofs are done using first-order reasoning, and there is no induction involved. <p> At Jim Saxe's suggestion, we tried this problem soon after a first version of DLP was developed. Using DLP, we quickly managed to prove all of the goals except for Lemma L7. We did not consult proofs reported in <ref> [17] </ref>. This was especially rewarding since we were unfamiliar with the problem and at that stage, did not even understand the semantics. 8 We are aware of only one prover, SIMPLIFY developed at DEC-SRC by David Detlefs and Greg Nelson, which is able to prove all lemmas but L7 automatically.
Reference: 18. <author> Nie, X. and Plaisted, D.A., </author> <title> "A semantic backward chaining proof system," </title> <booktitle> Artificial Intelligence 55, </booktitle> <year> 1992, </year> <pages> 109-128. </pages>
Reference-contexts: He was curious whether DLP could prove the properties without much user guidance. 5 See <ref> [18, 6] </ref> for a discussion of the performance of various theorem provers on this problem 6 Our formalization is in http://larch-www.lcs.mit.edu:8001/%7Emtv/Checkerboard.html 11 When proving these lemmas, we discovered the following paradigm to be extremely useful: 1. Broadcast spec to all conjectures to see how many conjectures are proved automatically. 2. <p> Whenever we proved a conjecture, we were able to resume the paradigm above. Bledsoe's Intermediate Value Theorem This theorem is viewed as a major challenge for theorem provers <ref> [18, 6] </ref>. Without using specialized inference methods for transitive relations, this theorem is difficult to prove. 7 In [18], Nie and Plaisted discussed a problem reduction format strategy in which combining many heuristics including interpretations, case analysis, and semantic deletion, they reported proving two lemmas from which the theorem follows. <p> Whenever we proved a conjecture, we were able to resume the paradigm above. Bledsoe's Intermediate Value Theorem This theorem is viewed as a major challenge for theorem provers [18, 6]. Without using specialized inference methods for transitive relations, this theorem is difficult to prove. 7 In <ref> [18] </ref>, Nie and Plaisted discussed a problem reduction format strategy in which combining many heuristics including interpretations, case analysis, and semantic deletion, they reported proving two lemmas from which the theorem follows. In [6], this problem is solved using semantic hyper-linking. <p> In [6], this problem is solved using semantic hyper-linking. The second author first tried to prove the first lemma in <ref> [18] </ref>. The default proof strategy of spec generated a single proof attempt by contradiction which did not succeed automatically. Variations of the find command were tried, and a different proof strategy for spec that spawns proofs-by-cases based on the axioms rather than the conjecture was experimented with.
Reference: 19. <author> Saxe, J.B., Guttag, J.V., Horning, J.J., </author> <title> and Garland, S.J., "Using transformations and verifi cation in circuit design," Formal Methods in System Design, </title> <type> 3, 3, </type> <year> 1993, </year> <pages> 181-209. </pages>
Reference-contexts: We also proved SAM's lemma and some of the lemmas about Robbins' algebra discussed in [23]. We begin with summaries of several of the problems and then make some general observations. 6.1 Some Problem Summaries Correctness of pipeline processor The pipeline processor example <ref> [19] </ref> is showing that a pipelined implementation of a small processor is equivalent to a simpler, non-pipelined implementation. This problem had already been done by others using LP [19], so our goal was see we if could prove the conjectures easily using DLP starting with the same axioms but without looking <p> several of the problems and then make some general observations. 6.1 Some Problem Summaries Correctness of pipeline processor The pipeline processor example <ref> [19] </ref> is showing that a pipelined implementation of a small processor is equivalent to a simpler, non-pipelined implementation. This problem had already been done by others using LP [19], so our goal was see we if could prove the conjectures easily using DLP starting with the same axioms but without looking at the published proofs. Normalization was sufficient to prove nine of the conjectures automatically. <p> Using spec with its default settings, we were able to prove all five of the remaining conjectures in a matter of minutes without any user guidance. For three of the conjectures, DLP generated the same proofs as those done with LP in <ref> [19] </ref> under user guidance. For the other two conjectures, DLP generated longer proofs because spec 's heuristic for choosing cases for case proofs did not always make the best choice. While experimenting with spec (by increasing the breadth of case splits), we ended up finding a shorter proof than in [19] <p> <ref> [19] </ref> under user guidance. For the other two conjectures, DLP generated longer proofs because spec 's heuristic for choosing cases for case proofs did not always make the best choice. While experimenting with spec (by increasing the breadth of case splits), we ended up finding a shorter proof than in [19] for one of the conjectures. This came as a pleasant surprise to one of the coauthors of [19], who said they had spent considerable effort trying to find short proofs. <p> While experimenting with spec (by increasing the breadth of case splits), we ended up finding a shorter proof than in <ref> [19] </ref> for one of the conjectures. This came as a pleasant surprise to one of the coauthors of [19], who said they had spent considerable effort trying to find short proofs. McCarthy's mutilated checkerboard problem This example is that of showing the impossibility of covering a checkerboard missing two opposite corners by dominos of size 2.
Reference: 20. <author> Schumann, J.M., and Letz, R., "Partheo: </author> <title> A high-performance parallel theorem prover," </title> <booktitle> Proc. 10th Intl. Conf. on Automated Deduction (CADE-11), </booktitle> <publisher> LNAI 449 (ed. Stickel), </publisher> <address> Kaiserslautern, Germany, </address> <year> 1990, </year> <month> 4056. </month>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> There is no master-slave type of organization. The user, however, has little control on the amount and nature of parallelism as the algorithm for allocating clauses to processes is fixed. Parallel provers based on model elimination including Parthenon [4], Meteor [7], and Partheo <ref> [20] </ref>, support or-parallelism. The emphasis is to prove formulas in lesser time by using different processors searching independent parts of the search space. MGTP [11] is based on model generation paradigm with different processors generating model candidates in parallel to try to generate a model for non-Horn formulae.
Reference: 21. <author> Vandevoorde, M.T., and Kapur, D., </author> <title> Parallel User Interfaces for Parallel Applications. </title> <type> Unpub lished Manuscript, </type> <institution> Lab. for Computer Science, MIT, </institution> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: Interfaces for sequential theorem provers are usually not adequate for this. A broader goal while building DLP has been to investigate how user productivity can be enhanced by the use and power of parallel user interfaces for parallel interactive applications that involve tasks with non-negligible response times <ref> [21] </ref>. 4.1 Global and Local Feedback DLP communicates with the user though an Emacs front-end. This front-end creates two windows, one to display the and/or tree of goals and proof attempts, and one for the I/O of individual proof attempts. Fig. 1.
Reference: 22. <author> Vandevoorde, M.T., and Kapur, D., </author> <title> "Distributed Larch Prover (DLP): An experiment in par allelizing a rewrite-rule based prover," </title> <note> submitted as a system abstract to RTA'96. </note>
Reference: 23. <author> Winker, S., </author> <title> "Robbins algebra: conditions that make a near-boolean algebra boolean," </title> <journal> J. of Automated Reasoning, </journal> <volume> 6, 4, </volume> <year> 1990, </year> <pages> 465-489. </pages>
Reference-contexts: This included some well-known and difficult first-order problems including Bledsoe's Intermediate Value Theorem, 5 McCarthy's mutilated checkerboard problem, and a problem involving equalities in non-unit clauses suggested by Ganzinger (personal communication). We also proved SAM's lemma and some of the lemmas about Robbins' algebra discussed in <ref> [23] </ref>. We begin with summaries of several of the problems and then make some general observations. 6.1 Some Problem Summaries Correctness of pipeline processor The pipeline processor example [19] is showing that a pipelined implementation of a small processor is equivalent to a simpler, non-pipelined implementation. <p> We did not use find because at the time, it had not yet been implemented. Using find would likely produce a proof more quickly. Lemmas about Robbins's algebra In <ref> [23] </ref>, many lemmas and properties are proved using OTTER such that if Robbins' algebras satisfy those properties, they are boolean. Some of these properties involved both proofs by induction and first-order reasoning. Subgoals of an induction proof were done manually since OTTER does not support proofs by induction. <p> Some of these properties involved both proofs by induction and first-order reasoning. Subgoals of an induction proof were done manually since OTTER does not support proofs by induction. DLP was successfully used by the second author to prove a nontrivial property in <ref> [23] </ref> provable by induction, plus two lemmas suggested by Winker. This experiment shared many similarities with the previous experiment done using the reachability theory of linear lists. <p> The second author was totally unaware of the problem, and without understanding the problem and without outside help, he managed to do the proofs using DLP in a day. The proofs found with DLP are different from the ones reported in <ref> [23] </ref> primarily because they are done using case analysis and the heuristics employed are different from those in OTTER. 6.2 Discussion The paradigm advocated in the paper is helpful in quickly establishing conjectures and lemmas. The spec command often succeeded in finding a proof much faster than the user could.
Reference: 24. <author> Yelick, K., </author> <title> and Garland, S.J., "A parallel completion procedure for term rewriting systems," </title> <booktitle> Proc. 11th Intl. Conf. on Automated Deduction (CADE-11), </booktitle> <publisher> LNAI 607 (ed. Kapur), </publisher> <address> Saratoga Springs, </address> <year> 1992, </year> <pages> 109-123. </pages>
Reference-contexts: The main objective is to get an (almost) linear speedup in response time by searching parts of search space in parallel. One may also observe superlinear speedup in some cases arising due to rearranging of search space caused by nondeterminism <ref> [14, 2, 3, 4, 20, 24] </ref>. Unlike other parallel provers, DLP gives the user extensive control over how the search space is explored in parallel. The advantage is that if the search fails, the user can interactively diagnose the problem and amend the search. <p> One obvious approach towards parallelizing a rewrite-based prover is to exploit parallelism in low-level, primitive inference steps, e.g., rewriting, unification and normalization [7], for instance, different subterms in a formula can be rewritten in parallel. In <ref> [24] </ref>, a parallelization of a completion-based prover on shared memory architecture is described in which critical pair computations among different rules and inner-normalization in the Knuth-Bendix completion procedure are done in parallel. Once again, this level of hidden parallelism does not affect user's interaction with the theorem prover.
Reference: 25. <author> Zhang, H., and Kapur, D., </author> <title> "Unnecessary Inferences in Associative-Commutative Completion Procedures" J. </title> <journal> Mathematical System Theory, </journal> <volume> 23, </volume> <year> 1990, </year> <pages> 175-206. 15 </pages>
Reference-contexts: One of the rules must be ground, and further there should not be any boolean connectives. Boolean connectives are axiomatized in LP using boolean algebra axioms without using any special heuristics. Superpositions in which both rules have the boolean connectives /" and "/ can lead to many trivial consequences <ref> [25] </ref>. find is thus a compromise to make first-order reasoning more efficient. Many proofs, e.g., Bledsoe's Intermediate Value, would have taken far too long (&gt; an hour) using crit instead of find . The find command takes two names, possibly using *'s, as arguments.
References-found: 25

