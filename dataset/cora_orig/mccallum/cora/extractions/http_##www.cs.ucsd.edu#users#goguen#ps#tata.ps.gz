URL: http://www.cs.ucsd.edu/users/goguen/ps/tata.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: The Tatami System Design and its Motivation  
Author: Joseph A. Goguen 
Address: San Diego, La Jolla CA 92093-0114  
Affiliation: Dept. Computer Science Engineering University of California at  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Razvan Diaconescu. </author> <title> Behavioural coherence in object-oriented algebraic specification. </title> <type> Technical report, </type> <institution> Japan Institute of Science and Technology, </institution> <year> 1998. </year> <note> Submitted for publication. </note>
Reference-contexts: Equality is interpreted using initial algebra semantics for data, hidden (order sorted) semantics for objects, and loose semantics for theories. First order sentences can occur only in modules having loose semantics. As in CafeOBJ, behavioral modules support the notion of coherence, as introduced by Diaconescu <ref> [1] </ref>, but in a recently generalized form [17] called behavioral congruence. In the future, we expect to add higher order modules and views to BOBJ, along the lines of [15]; this will further enhance support for reuse and the ability to express software architectures.
Reference: [2] <author> Razvan Diaconescu and Kokichi Futatsugi. </author> <title> Logical semantics for CafeOBJ. </title> <type> Technical Report IS-RR-96-0024S, </type> <institution> Japan Institute of Science and Technology, </institution> <year> 1996. </year>
Reference-contexts: Akiyoshi Sato, helped to implement the tatami protocol. I thank them all, and also Prof. Kokichi Futatsugi for his encouragement and support through the CafeOBJ project in Japan. 2 BOBJ The BOBJ (for Behavioral OBJ) language is a variant dialect and extension of the CafeOBJ language <ref> [3, 2] </ref>.
Reference: [3] <author> Razvan Diaconescu and Kokichi Futatsugi. </author> <title> CafeOBJ Report: The Language, Proof Techniques, and Methodologies for Object-Oriented Algebraic Specification, volume 6. </title> <publisher> World Scientific, </publisher> <year> 1998. </year> <note> To appear, AMAST Series in Computing. </note>
Reference-contexts: Akiyoshi Sato, helped to implement the tatami protocol. I thank them all, and also Prof. Kokichi Futatsugi for his encouragement and support through the CafeOBJ project in Japan. 2 BOBJ The BOBJ (for Behavioral OBJ) language is a variant dialect and extension of the CafeOBJ language <ref> [3, 2] </ref>.
Reference: [4] <author> Kokichi Futatsugi, Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Principles of OBJ2. </title> <editor> In Brian Reid, editor, </editor> <booktitle> Proceedings, Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <institution> Association for Computing Machinery, </institution> <year> 1985. </year>
Reference-contexts: I thank them all, and also Prof. Kokichi Futatsugi for his encouragement and support through the CafeOBJ project in Japan. 2 BOBJ The BOBJ (for Behavioral OBJ) language is a variant dialect and extension of the CafeOBJ language [3, 2]. Like CafeOBJ, it extends OBJ3 <ref> [4, 16] </ref> with behavioral modules for the behavioral specification of objects (i.e., state machines), but it also adds first order sentences for modules 3 Of course, many proofs do not admit a picture or applet to illustrate the main ideas, or even the result. 2 that have loose semantics.
Reference: [5] <author> Joseph Goguen. </author> <title> The logic of inexact concepts. </title> <journal> Synthese, </journal> <volume> 19 </volume> <pages> 325-373, 1968-69. </pages>
Reference-contexts: To support work that is informal, and hence not fully reliable, we associate confidence values in the unit interval with tasks, instead of Boolean truth values; this also allows techniques like critical path analysis to aid with task allocation. The fuzzy logic described in <ref> [5] </ref> is used to compute these values. The most important entities in a software engineering project database are the requirements and specifications; code is less important, because it can be (relatively) quickly written, or even automatically generated, from specifications that are sufficiently modular and detailed.
Reference: [6] <author> Joseph Goguen. </author> <title> Suggestions for using and organizing libraries in software development. </title> <editor> In Steven Kar-tashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, First International Conference on Supercomputing Systems, </booktitle> <pages> pages 349-360. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1985. </year> <note> Also in Supercomputing Systems, </note> <editor> Steven and Svetlana Kartashev, Eds., </editor> <publisher> Elsevier, </publisher> <year> 1986. </year>
Reference-contexts: Validations are also stored in the tatami database; these may or may not be formal proofs. If the atomic specifications of a project have associated code, then the system can be generated from the module expression that describes it, as suggested in <ref> [6] </ref> and implemented in lileanna [19, 20]. Our short term plans for the tatami system do not include this capability, but we hope to provide it eventually; the SpecWare system [18] provides this capability, along with many optimizing transformations to improve the generated code.
Reference: [7] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The former says that more detail has been provided, e.g., a way to realize a behavior once certain other behaviors are given. Composition steps tell how a given description is realized from simpler specifications. Following the parameterized programming <ref> [7, 15] </ref> paradigm, the tatami system will use module expressions for this purpose; they describe how to put modules together to form systems, using a rich set of composition operations. Another important relation is satisfaction, which says that one requirement or specification satisfies another.
Reference: [8] <author> Joseph Goguen. </author> <title> Formality and informality in requirements engineering. </title> <booktitle> In Proceedings, International Conference on Requirements Engineering, </booktitle> <pages> pages 102-108. </pages> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: It is important to note that not everything can be formalized, and that not everything that can be formalized should be. For example, many requirements are inherently social in nature, and should be expressed in natural language <ref> [8, 9] </ref>. Even informal statements can be composed and refined. In this way, appropriate tools can integrate the early, middle and late phases of a project, as well as support different levels of formality in different phases of a project, and in different parts.
Reference: [9] <author> Joseph Goguen. </author> <title> Towards a social, ethical theory of information. </title> <editor> In Geoffrey Bowker, Leigh Star, William Turner, and Les Gasser, editors, </editor> <booktitle> Social Science, Technical Systems and Cooperative Work: Beyond the Great Divide, </booktitle> <pages> pages 27-56. </pages> <publisher> Erlbaum, </publisher> <year> 1997. </year>
Reference-contexts: It is important to note that not everything can be formalized, and that not everything that can be formalized should be. For example, many requirements are inherently social in nature, and should be expressed in natural language <ref> [8, 9] </ref>. Even informal statements can be composed and refined. In this way, appropriate tools can integrate the early, middle and late phases of a project, as well as support different levels of formality in different phases of a project, and in different parts.
Reference: [10] <author> Joseph Goguen. </author> <title> Hidden algebraic engineering. </title> <editor> In Chrystopher Nehaniv, editor, </editor> <booktitle> Proceedings, Conference on Semigroups and Algebraic Engineering (University of Aizu, </booktitle> <address> Japan, </address> <month> 24-26 March </month> <year> 1997). </year> <note> To appear, Springer, 1998. Also UCSD Technical Report CS97-569, </note> <month> December </month> <year> 1997. </year>
Reference-contexts: to go into details about the semantics of BOBJ, but briefly, we can say that its models are algebras having a fixed model of the data as a subalgebra, and satisfying the relevant sentences, with equality interpreted initially, behaviorally, or loosely, according to the type of the theory involved; see <ref> [13, 10] </ref> for more detail on hidden algebra, [12] for more on the language design, and [17] for more on coinduction proofs. 3 Duck The proof assistant aspect of Duck is a relatively simple command langauge for first order theorem proving; commands are provided for the usual proof rules, and are <p> Many clever implementation techniques used by software engineers have similar character, in that behavioral satisfaction is required for their correctness. Our validation method for such problems uses a new development in algebraic specification called hidden algebra <ref> [13, 10] </ref>, in which refinement proofs can be done in a particularly simple and elegant way using coinduction. 4 5 Summary and Further Ideas We believe there are significant advantages to an integrated, systems approach to building software engineering tools.
Reference: [11] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: This logic has no predicates as such, but this entails no loss of generality, because boolean valued functions provide the same power. The sophisticated form of induction described in Chapter 8 of <ref> [11] </ref> is supported, as are several forms of coinduction, including those described in [13]. The lemma introduction rule gives a way to do proofs that are not in top-down order. Some higher level commands are also provided, such as "simplify," which is similar to the "grind" command of PVS.
Reference: [12] <author> Joseph Goguen and Kokichi Futatsugi. </author> <title> Semiotic redesign of a specification language, </title> <note> in preparation. 5 </note>
Reference-contexts: BOBJ, but briefly, we can say that its models are algebras having a fixed model of the data as a subalgebra, and satisfying the relevant sentences, with equality interpreted initially, behaviorally, or loosely, according to the type of the theory involved; see [13, 10] for more detail on hidden algebra, <ref> [12] </ref> for more on the language design, and [17] for more on coinduction proofs. 3 Duck The proof assistant aspect of Duck is a relatively simple command langauge for first order theorem proving; commands are provided for the usual proof rules, and are usually used in a top-down problem reduction mode.
Reference: [13] <author> Joseph Goguen and Grant Malcolm. </author> <title> A hidden agenda. </title> <note> Theoretical Computer Science, to appear 1999. </note> <institution> Also UCSD Dept. Computer Science & Eng. </institution> <type> Technical Report CS97-538, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: to go into details about the semantics of BOBJ, but briefly, we can say that its models are algebras having a fixed model of the data as a subalgebra, and satisfying the relevant sentences, with equality interpreted initially, behaviorally, or loosely, according to the type of the theory involved; see <ref> [13, 10] </ref> for more detail on hidden algebra, [12] for more on the language design, and [17] for more on coinduction proofs. 3 Duck The proof assistant aspect of Duck is a relatively simple command langauge for first order theorem proving; commands are provided for the usual proof rules, and are <p> This logic has no predicates as such, but this entails no loss of generality, because boolean valued functions provide the same power. The sophisticated form of induction described in Chapter 8 of [11] is supported, as are several forms of coinduction, including those described in <ref> [13] </ref>. The lemma introduction rule gives a way to do proofs that are not in top-down order. Some higher level commands are also provided, such as "simplify," which is similar to the "grind" command of PVS. Particular strategies for term rewriting can also be described. <p> Many clever implementation techniques used by software engineers have similar character, in that behavioral satisfaction is required for their correctness. Our validation method for such problems uses a new development in algebraic specification called hidden algebra <ref> [13, 10] </ref>, in which refinement proofs can be done in a particularly simple and elegant way using coinduction. 4 5 Summary and Further Ideas We believe there are significant advantages to an integrated, systems approach to building software engineering tools.
Reference: [14] <author> Joseph Goguen, Akira Mori, and Kai Lin. </author> <title> Algebraic semiotics, ProofWebs and distributed cooperative proving. </title> <editor> In Yves Bartot, editor, </editor> <booktitle> Proceedings, User Interfaces for Theorem Provers, </booktitle> <pages> pages 25-34. </pages> <institution> INRIA, 1997. (Sophia Antipolis, </institution> <month> 1-2 September </month> <year> 1997). </year>
Reference-contexts: User interface design has been guided by algebraic semiotics and narratology, which are respectively theories of signs and of stories; see <ref> [14] </ref>. In particular, the "tatami conventions" have been developed to guide the design of documentation websites [14]. This is important in order to support users who are not experts in formal methods. <p> User interface design has been guided by algebraic semiotics and narratology, which are respectively theories of signs and of stories; see <ref> [14] </ref>. In particular, the "tatami conventions" have been developed to guide the design of documentation websites [14]. This is important in order to support users who are not experts in formal methods.
Reference: [15] <author> Joseph Goguen and William Tracz. </author> <title> An implementation-oriented semantics for module composition, </title> <note> 1998. Draft manuscript in preparation. </note>
Reference-contexts: As in CafeOBJ, behavioral modules support the notion of coherence, as introduced by Diaconescu [1], but in a recently generalized form [17] called behavioral congruence. In the future, we expect to add higher order modules and views to BOBJ, along the lines of <ref> [15] </ref>; this will further enhance support for reuse and the ability to express software architectures. BOBJ only exists in the context of its role in the tatami system. In particular, its type checking and execution are implemented by translation into some version of OBJ (currently OBJ3, but later CafeOBJ). <p> The former says that more detail has been provided, e.g., a way to realize a behavior once certain other behaviors are given. Composition steps tell how a given description is realized from simpler specifications. Following the parameterized programming <ref> [7, 15] </ref> paradigm, the tatami system will use module expressions for this purpose; they describe how to put modules together to form systems, using a rich set of composition operations. Another important relation is satisfaction, which says that one requirement or specification satisfies another.
Reference: [16] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouannaud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Algebraic Specification with OBJ: An Introduction with Case Studies. Academic, </title> <note> to appear. Also Technical Report SRI-CSL-88-9, August 1988, SRI International. </note>
Reference-contexts: I thank them all, and also Prof. Kokichi Futatsugi for his encouragement and support through the CafeOBJ project in Japan. 2 BOBJ The BOBJ (for Behavioral OBJ) language is a variant dialect and extension of the CafeOBJ language [3, 2]. Like CafeOBJ, it extends OBJ3 <ref> [4, 16] </ref> with behavioral modules for the behavioral specification of objects (i.e., state machines), but it also adds first order sentences for modules 3 Of course, many proofs do not admit a picture or applet to illustrate the main ideas, or even the result. 2 that have loose semantics.
Reference: [17] <author> Grigore Ro~su and Joseph Goguen. </author> <title> Behavioral congruent deduction. </title> <note> Submitted for publication. </note>
Reference-contexts: First order sentences can occur only in modules having loose semantics. As in CafeOBJ, behavioral modules support the notion of coherence, as introduced by Diaconescu [1], but in a recently generalized form <ref> [17] </ref> called behavioral congruence. In the future, we expect to add higher order modules and views to BOBJ, along the lines of [15]; this will further enhance support for reuse and the ability to express software architectures. BOBJ only exists in the context of its role in the tatami system. <p> models are algebras having a fixed model of the data as a subalgebra, and satisfying the relevant sentences, with equality interpreted initially, behaviorally, or loosely, according to the type of the theory involved; see [13, 10] for more detail on hidden algebra, [12] for more on the language design, and <ref> [17] </ref> for more on coinduction proofs. 3 Duck The proof assistant aspect of Duck is a relatively simple command langauge for first order theorem proving; commands are provided for the usual proof rules, and are usually used in a top-down problem reduction mode.
Reference: [18] <author> Y.V. Srinivas and Richard Jullig. </author> <title> SpecWare language manual, version 2.0. </title> <type> Technical report, </type> <institution> Kestrel, </institution> <year> 1996. </year>
Reference-contexts: Our short term plans for the tatami system do not include this capability, but we hope to provide it eventually; the SpecWare system <ref> [18] </ref> provides this capability, along with many optimizing transformations to improve the generated code. Specifications can be formal, semi-formal, or informal, as can arguments that a refinement step is valid.
Reference: [19] <author> William Tracz. lileanna: </author> <title> a parameterized programming language. </title> <booktitle> In Proceedings, Second International Workshop on Software Reuse, </booktitle> <pages> pages 66-78, </pages> <month> March </month> <year> 1993. </year> <pages> Lucca, </pages> <address> Italy. </address>
Reference-contexts: Validations are also stored in the tatami database; these may or may not be formal proofs. If the atomic specifications of a project have associated code, then the system can be generated from the module expression that describes it, as suggested in [6] and implemented in lileanna <ref> [19, 20] </ref>. Our short term plans for the tatami system do not include this capability, but we hope to provide it eventually; the SpecWare system [18] provides this capability, along with many optimizing transformations to improve the generated code.
Reference: [20] <author> William Tracz. </author> <title> Formal Specification of Parameterized Programs in lilleanna. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1997. </year> <month> 6 </month>
Reference-contexts: Validations are also stored in the tatami database; these may or may not be formal proofs. If the atomic specifications of a project have associated code, then the system can be generated from the module expression that describes it, as suggested in [6] and implemented in lileanna <ref> [19, 20] </ref>. Our short term plans for the tatami system do not include this capability, but we hope to provide it eventually; the SpecWare system [18] provides this capability, along with many optimizing transformations to improve the generated code.
References-found: 20

