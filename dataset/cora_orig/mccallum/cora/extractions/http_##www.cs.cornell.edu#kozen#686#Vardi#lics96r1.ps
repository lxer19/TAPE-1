URL: http://www.cs.cornell.edu/kozen/686/Vardi/lics96r1.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: Email: ok@research.att.com  Email: safra@math.tau.ac.il  Email: vardi@cs.rice.edu  
Title: Relating Word and Tree Automata  
Author: Orna Kupferman Shmuel Safra Moshe Y. Vardi 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: Mountain Avenue, Murray Hill, NJ 07974, U.S.A.  69978, Is-rael.  Hous-ton, TX 77005-1892, U.S.A.  
Note: Address: 600  Address:  Address:  
Affiliation: Bell Laboratories  Tel Aviv University  Rice University  School of Mathematics, Tel Aviv  Department of Computer Science,  
Abstract: In the automata-theoretic approach to verification, we translate specifications to automata. Complexity considerations motivate the distinction between different types of automata. Already in the 60's, it was known that deterministic Buchi word automata are less expressive than nondeterministic Buchi word automata. The proof is easy and can be stated in a few lines. In the late 60's, Rabin proved that Buchi tree automata are less expressive than Rabin tree automata. This proof is much harder. In this work we relate the expressiveness gap between deterministic and nondeterministic Buchi word automata and the expressiveness gap between Buchi and Rabin tree automata. We consider tree automata that recognize derived languages. For a word language L, the derived language of L, denoted L4, is the set of all trees all of whose paths are in L. Since often we want to specify that all the computations of the program satisfy some property, the interest in derived languages is clear. Our main result shows that L is recognizable by a nondeterministic Buchi word automaton but not by a deterministic Buchi word automaton iff L4 is recognizable by a Rabin tree automaton and not by a Buchi tree automaton. Our result provides a simple explanation to the expressiveness gap between Buchi and Rabin tree automata. Since the gap between deterministic and nondeterministic Buchi word automata is well understood, our result also provides a characterization of derived languages that can be recognized by Buchi tree automata. Finally, it also provides an exponential determinization of Buchi tree automata that recognize derived languages. 
Abstract-found: 1
Intro-found: 1
Reference: [Buc62] <author> J.R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> In Proc. Internat. Congr. Logic, Method and Phi-los. Sci. </booktitle> <year> 1960, </year> <pages> pages 1-12, </pages> <address> Stanford, 1962. </address> <publisher> Stanford University Press. </publisher>
Reference-contexts: For example, in the Buchi acceptance condition, some of the states are designated as accepting states and a run is accepting iff it visits states from the accepting set infinitely often <ref> [Buc62] </ref>. As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata).
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Ex-pressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <booktitle> pages 428-437. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In fact, this fragment, called strongly linear in [GK94], is a strict fragment of the universal fragment 8CTL ? of CTL ? . A necessary and sufficient condition for CTL ? formulas to be strongly-linear is given in <ref> [CD88] </ref>: a CTL ? formula is strongly linear iff omitting all its path quantifiers results in an LTL formula ~ such that and A~ are equivalent. Let us go back to automata. <p> Claim 3 follows from Lemma 4.2 and the fact that BW = RW . Finally, Claim 2 follows from Theorem 3.1. Given a CTL ? formula and a Buchi tree automaton U associated with , we can use the characterization in <ref> [CD88] </ref> in order to determine whether is strongly linear [GK94], in which case the language of U is derivable. <p> As the LTL formula F Gp can not be translated to a DBW , it follows from Theorem 4.3 that the CTL ? formula AF Gp can not be expressed in CTL [EH86] and that the CTL formula AF AGp is not strongly linear <ref> [CD88] </ref>. Acknowledgment We thank Anca Browne and Mihalis Yannakakis for carefully reading an early draft of this work.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: For example, while the branching temporal logic CTL ? permits an arbitrary combination of linear-time operators in its path formulas, its subset CTL restricts path formulas to have only a single linear-time operator. This restriction makes CTL less expressive than CTL ? <ref> [EH86] </ref>. We can also control the expressive power of automata. One way to do it is to restrict their transition relations to be deterministic. Every automaton on finite words can be determinized. This is not true for automata on infinite words. <p> It is known, for example, that formulas of CTL can be translated to BT [VW86b]. As the LTL formula F Gp can not be translated to a DBW , it follows from Theorem 4.3 that the CTL ? formula AF Gp can not be expressed in CTL <ref> [EH86] </ref> and that the CTL formula AF AGp is not strongly linear [CD88]. Acknowledgment We thank Anca Browne and Mihalis Yannakakis for carefully reading an early draft of this work.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT <ref> [Eme85, VS85, EJ88] </ref>. The interested readers can find more examples in [Eme90, Tho90]. In the automata-theoretic approach to verification, we translate specifications to automata. Which type of automata? The answer, obviously, should be "the weakest type that is still strong enough to express the required behaviors accurately".
Reference: [EJ91] <author> E.A. Emerson and C. Jutla. </author> <title> Tree automata, mu-calculus and determinacy. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> San Juan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [Eme85] <author> E.A. Emerson. </author> <title> Automata, tableaux, and temporal logics. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 79-87. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT <ref> [Eme85, VS85, EJ88] </ref>. The interested readers can find more examples in [Eme90, Tho90]. In the automata-theoretic approach to verification, we translate specifications to automata. Which type of automata? The answer, obviously, should be "the weakest type that is still strong enough to express the required behaviors accurately".
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in <ref> [Eme90, Tho90] </ref>. In the automata-theoretic approach to verification, we translate specifications to automata. Which type of automata? The answer, obviously, should be "the weakest type that is still strong enough to express the required behaviors accurately". In this paper we consider tree au tomata that describe derived languages.
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [GK94] <author> O. Grumberg and R.P. Kurshan. </author> <title> How linear can branching-time be. </title> <booktitle> In Proceedings of the First International Conference on Temporal Logic, volume 827 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 180-194, </pages> <address> Bonn, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Since often we want to specify that all the computations of the program satisfy some property, the interest in derived languages is clear. Branching temporal logic formulas that describe derived languages constitute a strict fragment of CTL ? . In fact, this fragment, called strongly linear in <ref> [GK94] </ref>, is a strict fragment of the universal fragment 8CTL ? of CTL ? . <p> Finally, Claim 2 follows from Theorem 3.1. Given a CTL ? formula and a Buchi tree automaton U associated with , we can use the characterization in [CD88] in order to determine whether is strongly linear <ref> [GK94] </ref>, in which case the language of U is derivable. When the language of U is derivable, it follows from Theorem 4.3 that the linear requirement that imposes on all computations can be specified by a deterministic Buchi word automaton and that the automaton U may be determinized as well.
Reference: [Kur87] <author> R.P. Kurshan. </author> <title> Complementing deterministic Buchi automata in polynomial time. </title> <journal> Journal of Compututer and System Science, </journal> <volume> 35 </volume> <pages> 59-71, </pages> <year> 1987. </year>
Reference-contexts: For example, the complexities of the model-checking and the satisfiability problems for the logic CTL ? are significantly higher than these for its less expressive subset CTL [SC85, VS85]. Similarly, while the containment problem for DBW can be solved in NLOGSPACE <ref> [WVS83, Kur87] </ref>, it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in [Eme90, Tho90].
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processesl. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [Lan69] <author> L.H. </author> <title> Landweber. Decision problems for !- automata. </title> <journal> Mathematical Systems Theory, </journal> <volume> 3 </volume> <pages> 376-384, </pages> <year> 1969. </year>
Reference-contexts: We can also control the expressive power of automata. One way to do it is to restrict their transition relations to be deterministic. Every automaton on finite words can be determinized. This is not true for automata on infinite words. In <ref> [Lan69] </ref>, Landweber proved that deterministic Buchi word automata are less expressive than nondeterministic Buchi word automata. That is, he showed that there exists a language of infinite words that is recognizable by a nondeterministic Buchi word automaton but not recognizable by any nondeterministic Buchi word automaton 1 . <p> While nondeterministic Buchi automata can describe any !-regular language, deterministic Buchi automata can describe an !-regular language L iff there exists a regular language W such that L contains exactly all words that have infinitely many prefixes in W <ref> [Lan69] </ref>. Another way to control the expressive power of automata is by defining various acceptance conditions. For example, one may wonder whether there exists an acceptance condition for which deterministic automata are as expressive as nondeterministic ones. In 1966, McNaughton answered this question to the positive.
Reference: [McN66] <author> R. McNaughton. </author> <title> Testing and generating infinite sequences by a finite automaton. </title> <journal> Information and Control, </journal> <volume> 9 </volume> <pages> 521-530, </pages> <year> 1966. </year>
Reference-contexts: McNaughton showed that deterministic Rabin word automata are as expressive as nondeterministic Rabin word automata and that they are both as expressive as nondeterministic Buchi word automata <ref> [McN66] </ref>. A different picture is drawn when we consider automata on infinite trees. In 1969, Rabin showed 1 It is easy to see that deterministic automata on infinite trees are less expressive than their nondeterministic counterpart.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> Jan-uary </month> <year> 1992. </year>
Reference-contexts: The first step in program verification is to come with a formal specification of the program. One of the more widely used specification languages for concurrent finite-state programs is temporal logic <ref> [Pnu77, MP92] </ref>. Temporal logic comes in two varieties: linear and branching. In linear temporal logics, formulas are interpreted over linear sequences and describe a behavior of a single infinite computation of a program.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: The first step in program verification is to come with a formal specification of the program. One of the more widely used specification languages for concurrent finite-state programs is temporal logic <ref> [Pnu77, MP92] </ref>. Temporal logic comes in two varieties: linear and branching. In linear temporal logics, formulas are interpreted over linear sequences and describe a behavior of a single infinite computation of a program.
Reference: [Rab69] <author> M.O. Rabin. </author> <title> Decidability of second order theories and automata on infinite trees. </title> <journal> Transaction of the AMS, </journal> <volume> 141 </volume> <pages> 1-35, </pages> <year> 1969. </year>
Reference-contexts: Indeed, only the latter can quantify over paths existentially [TW68]. that, though their expressive power with respect to words coincide, nondeterministic Buchi tree automata are less expressive than nondeterministic Rabin tree automata <ref> [Rab69] </ref>. That is, there exists a language of infinite trees that is recognizable by a Rabin tree automaton but not recognizable by any Buchi tree automaton. <p> The proof is simple and can be stated in a few lines. Much harder is the proof that BT &lt; RT . In <ref> [Rab69] </ref>, Rabin had to use a complicated construction and a complicated inductive argument. Interestingly, the language that Rabin used in his proof is the derived language of L 1 . That is, the set of all trees all of whose paths have only finitely many 0's.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: The more expressive a language is, the higher is the complexity of solving questions about it. For example, the complexities of the model-checking and the satisfiability problems for the logic CTL ? are significantly higher than these for its less expressive subset CTL <ref> [SC85, VS85] </ref>. Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88].
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: In both versions, formulas are generated with respect to a set AP of the program's atomic propositions. Each formula describes a language (of either infinite words or infinite trees) over the alphabet 2 AP . Automata on infinite objects also describe languages <ref> [Tho90] </ref>. As automata on finite objects, they either accept or reject an input object. Since a run on an infinite object does not have a final state, acceptance is determined with respect to the set of states visited infinitely often during the run. <p> Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in <ref> [Eme90, Tho90] </ref>. In the automata-theoretic approach to verification, we translate specifications to automata. Which type of automata? The answer, obviously, should be "the weakest type that is still strong enough to express the required behaviors accurately". In this paper we consider tree au tomata that describe derived languages.
Reference: [TW68] <author> J.W. Thatcher and J.B. Wright. </author> <title> Generalized finite automata theory with an application to a decision problem of second-order logic. </title> <journal> Mathematical System Theory, </journal> <volume> 2 </volume> <pages> 57-81, </pages> <year> 1968. </year>
Reference-contexts: A different picture is drawn when we consider automata on infinite trees. In 1969, Rabin showed 1 It is easy to see that deterministic automata on infinite trees are less expressive than their nondeterministic counterpart. Indeed, only the latter can quantify over paths existentially <ref> [TW68] </ref>. that, though their expressive power with respect to words coincide, nondeterministic Buchi tree automata are less expressive than nondeterministic Rabin tree automata [Rab69]. That is, there exists a language of infinite trees that is recognizable by a Rabin tree automaton but not recognizable by any Buchi tree automaton.
Reference: [Var96] <author> M.Y. Vardi. </author> <title> An automata-theoretic approach to linear temporal logic. In Logics for Concurrency: Structure versus Automata, </title> <booktitle> volume 1043 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: More specifically, questions such as sat-isfiability of specifications and correctness of programs with respect to their specifications can be reduced to questions such as nonemptiness and containment of automata. These reductions yield clean and optimal algorithms and are very helpful in implementing formal verification methods <ref> [Var96] </ref>. An important factor to be considered when we examine a specification language is its ability to describe behaviors accurately. We can control the expressive power of temporal logics by limiting their syntax.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: The more expressive a language is, the higher is the complexity of solving questions about it. For example, the complexities of the model-checking and the satisfiability problems for the logic CTL ? are significantly higher than these for its less expressive subset CTL <ref> [SC85, VS85] </ref>. Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. <p> Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT <ref> [Eme85, VS85, EJ88] </ref>. The interested readers can find more examples in [Eme90, Tho90]. In the automata-theoretic approach to verification, we translate specifications to automata. Which type of automata? The answer, obviously, should be "the weakest type that is still strong enough to express the required behaviors accurately".
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time <ref> [VW86b] </ref>, it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in [Eme90, Tho90]. In the automata-theoretic approach to verification, we translate specifications to automata. <p> Our results may also be used to obtain simple proofs for inexpressibility results for temporal logics. It is known, for example, that formulas of CTL can be translated to BT <ref> [VW86b] </ref>. As the LTL formula F Gp can not be translated to a DBW , it follows from Theorem 4.3 that the CTL ? formula AF Gp can not be expressed in CTL [EH86] and that the CTL formula AF AGp is not strongly linear [CD88].
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: As temporal logics, automata on infinite objects come in two varieties. Automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification, verification, and synthesis <ref> [ES84, VW86a, EJ91, VW94, BVW94, Kur94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata.
Reference: [Wol82] <author> P. Wolper. </author> <title> Synthesis of Communicating Processes from Temporal Logic Specifications. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1982. </year>
Reference-contexts: For example, the complexities of the model-checking and the satisfiability problems for the logic CTL ? are significantly higher than these for its less expressive subset CTL [SC85, VS85]. Similarly, while the containment problem for DBW can be solved in NLOGSPACE [WVS83, Kur87], it is PSPACE-complete for BW <ref> [Wol82] </ref>. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in [Eme90, Tho90]. In the automata-theoretic approach to verification, we translate specifications to automata.
Reference: [WVS83] <author> P. Wolper, M.Y. Vardi, and A.P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proc. 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: For example, the complexities of the model-checking and the satisfiability problems for the logic CTL ? are significantly higher than these for its less expressive subset CTL [SC85, VS85]. Similarly, while the containment problem for DBW can be solved in NLOGSPACE <ref> [WVS83, Kur87] </ref>, it is PSPACE-complete for BW [Wol82]. Finally, while the complexity of the nonemptiness problem for BT can be solved in quadratic time [VW86b], it is NP-complete for RT [Eme85, VS85, EJ88]. The interested readers can find more examples in [Eme90, Tho90].
References-found: 27

