URL: http://www.research.microsoft.com/~zorn/pubs/USITS97-BIT.ps
Refering-URL: http://www.research.microsoft.com/~zorn/
Root-URL: http://www.research.microsoft.com
Email: hanlee@cs.colorado.edu  zorn@cs.colorado.edu  
Title: BIT: A Tool for Instrumenting Java Bytecodes  
Author:  Benjamin G. Zorn 
Address: Boulder 80309  Boulder 80309  
Affiliation: Department of Computer Science University of Colorado,  Department of Computer Science University of Colorado,  
Abstract: 1 This work was supported in part by the National Science Foundation under grant IRI-95-21046. 2 This paper appeared in the USENIX Symposium on Internet Technologies and Systems Proceedings, pages 73-82, Monterey, California, December 1997. Copyright 1997 by the USENIX Association. All rights reserved. Abstract BIT (Bytecode Instrumenting Tool) is a collection of Java classes that allow one to build customized tools to instrument Java Virtual Machine (JVM) bytecodes. Because understanding program behavior is an essential part of developing effective optimization algorithms, researchers and software developers have built numerous tools that carry out program analysis. Although there are existing tools that analyze and modify executables on a variety of operating systems and machine architectures, there currently is no framework for carrying out the same task for JVM bytecodes. In this paper, we describe BIT, which allows the user to insert calls to analysis methods anywhere in the bytecode, so that information can be extracted from the user program while it is being executed. In this paper, we describe several simple tools built using BIT and also report on BITs performance. We found that the overhead for the execution speed and size were between 23% to 150%. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anant Agarwal, Richard L. Sites and Mark Horowitz. ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode. </title> <booktitle> Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <pages> pages 199-127, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM <ref> [1] </ref> generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures. Also, software testing and quality assurance tools that detect memory leaks and access errors such as Purify [15] catch programming errors by using these techniques. <p> User Program Data User Program Output Analysis Output import BIT.*; public class BranchPrediction - static DataOutputStream data_out = null; static Hashtable branch = null; static int pc = 0; public static void main (String argv []) - String infilename = new String (argv [0]); String outfilename = new String (argv <ref> [1] </ref>); ClassInfo ci = new ClassInfo (infilename); Vector routines = ci.getRoutines (); for (Enumeration e=routines.elements ();e.hasMoreElements (); )- Routine routine = (Routine) e.nextElement (); Vector instructions = routine.getInstructions (); for (Enumeration b = routine.getBasicBlocks ().elements (); b.hasMoreElements (); ) - BasicBlock bb = (BasicBlock) b.nextElement (); Instruction instr = (Instruction)instructions.elementAt (bb.getEndAddress
Reference: [2] <author> Glenn Ammons, Thomas Ball, and James R. Larus. </author> <title> Exploiting Hardware Performance Counters with Flow and Context Sensitive Profiling. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 85-108, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Possible candidates include a tool that performs hierarchical profiling of a class file such as gprof [13], HiProf [10], and mprof [34]. Recently, there have been other advances in profiling including flow and context sensitive profiling <ref> [2] </ref> and interprocedural dataflow analysis [11]. These advanced profiling techniques could also be applied to JVM programs with BIT. 7. Availability BIT source is freely available. If you would like to obtain a copy, please email hanlee@cs.colorado.edu or zorn@cs.colorado.edu.
Reference: [3] <author> Elliot Berk. JLex: </author> <title> A Lexical Analyzer Generator for Java. </title> <note> http://www.cs.princeton.edu/~appel/modern/java/J Lex. </note>
Reference-contexts: The characteristics measured were time required to instrument user programs, execution time of the instrumented programs, and the size of instrumented programs. For these measurements, Jmark 1.2.1 [8], a JVM benchmark suite from Ziff-Davis publishing company; JLex <ref> [3] </ref>, a lexical analyzer generator for Java; EspressoGrinder [24], a Java compiler; CUP [16], a parser generator; and BIT were used as user applications on which the custom tools mentioned above were run.
Reference: [4] <author> Brian Bershad et al. </author> <title> Etch Overview. </title> <address> http://www.cs.washington.edu/~bershad/Etch.html. </address>
Reference-contexts: There is another group of tools, sometimes called binary editing or executable editing tools, which have different design goals and offer a library of routines for modifying executable files. The tools in this group include the OM system [32], EEL [19], ATOM [30], and Etch <ref> [4] </ref>, which are explained in more detail below. These tools differ in that they offer a library of routines for modifying executable files. Users, in turn, can design and build their own customized tools to meet their needs using these tools.
Reference: [5] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook and William E. Weihl. PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator. </title> <institution> Massachusetts Institute of Technology technical report MIT/LCS/TR-516, </institution> <year> 1991. </year>
Reference-contexts: Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS <ref> [5] </ref> and Shade [7] emulate other architectures. Also, software testing and quality assurance tools that detect memory leaks and access errors such as Purify [15] catch programming errors by using these techniques. Purify inserts instructions directly into the object code produced by existing compilers.
Reference: [6] <author> Per Bothner. </author> <title> Kawa, the Java-based Scheme System. </title> <address> http://www.cygnus.com/~bothner/kawa.html. </address>
Reference-contexts: Because BIT is written in Java, tools written using it are portable across platforms. Also, there are other programming languages that can be compiled into JVM bytecodes such as Kawa <ref> [6] </ref>, which compiles Scheme code into JVM bytecodes and AppletMagic [17], which translates Ada 95 to JVM bytecodes. Furthermore, Hardwick and Sipelstein studied the feasibility of using Java as an intermediate language [14].
Reference: [7] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A Fast InstructionSet Simulator for Execution Profiling. </title> <booktitle> Proceedings of the 1994 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 128-137, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade <ref> [7] </ref> emulate other architectures. Also, software testing and quality assurance tools that detect memory leaks and access errors such as Purify [15] catch programming errors by using these techniques. Purify inserts instructions directly into the object code produced by existing compilers.
Reference: [8] <author> Richard V. Dragan and Larry Seltzer. </author> <title> Java Speed Trials. </title> <journal> PC Magazine, </journal> <volume> vol 15, no 18, </volume> <year> 1996. </year>
Reference-contexts: The characteristics measured were time required to instrument user programs, execution time of the instrumented programs, and the size of instrumented programs. For these measurements, Jmark 1.2.1 <ref> [8] </ref>, a JVM benchmark suite from Ziff-Davis publishing company; JLex [3], a lexical analyzer generator for Java; EspressoGrinder [24], a Java compiler; CUP [16], a parser generator; and BIT were used as user applications on which the custom tools mentioned above were run.
Reference: [9] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor. </title> <booktitle> SIGMETRICS Conference on Measurement and modeling of Computer Systems, </booktitle> <volume> vol 8, no 1, </volume> <month> May </month> <year> 1990. </year>
Reference: [10] <author> Janel Garvin. </author> <title> HiProf Advanced Code Performance Analysis Through Hierarchical Profiling. </title> <address> http://tracepoint.galatia.com/noframes/products/hip rof/profiling/overview. </address>
Reference-contexts: Exceptions are being ignored in the current implementation. 9 Larger customized tools using BIT need to be built to prove BITs usefulness. Possible candidates include a tool that performs hierarchical profiling of a class file such as gprof [13], HiProf <ref> [10] </ref>, and mprof [34]. Recently, there have been other advances in profiling including flow and context sensitive profiling [2] and interprocedural dataflow analysis [11]. These advanced profiling techniques could also be applied to JVM programs with BIT. 7. Availability BIT source is freely available.
Reference: [11] <author> David W. Goodwin. </author> <title> Interprocedural Dataflow Analysis in an Executable Optimizer. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 122-145, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Possible candidates include a tool that performs hierarchical profiling of a class file such as gprof [13], HiProf [10], and mprof [34]. Recently, there have been other advances in profiling including flow and context sensitive profiling [2] and interprocedural dataflow analysis <ref> [11] </ref>. These advanced profiling techniques could also be applied to JVM programs with BIT. 7. Availability BIT source is freely available. If you would like to obtain a copy, please email hanlee@cs.colorado.edu or zorn@cs.colorado.edu. Acknowledgments This work was supported in part by the National Science Foundation under grant IRI-95-21046.
Reference: [12] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference: [13] <author> Susan L. Graham, Peter B. Kessler and Marshall K. McKusick. </author> <title> An Execution Profiler for Modular Programs. </title> <journal> Software Practice and Experience, </journal> <pages> pages 671-685, </pages> <note> vol 13, </note> <year> 1983. </year>
Reference-contexts: However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE <ref> [13] </ref> and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures. Also, software testing and quality assurance tools that detect memory leaks and access errors such as Purify [15] catch programming errors by using these techniques. <p> Exceptions are being ignored in the current implementation. 9 Larger customized tools using BIT need to be built to prove BITs usefulness. Possible candidates include a tool that performs hierarchical profiling of a class file such as gprof <ref> [13] </ref>, HiProf [10], and mprof [34]. Recently, there have been other advances in profiling including flow and context sensitive profiling [2] and interprocedural dataflow analysis [11]. These advanced profiling techniques could also be applied to JVM programs with BIT. 7. Availability BIT source is freely available.
Reference: [14] <author> Jonathan C. Hardwick and Jay Sipelstein. </author> <title> Java as an Intermediate Language. </title> <type> Technical Report CMU-CS-96-161. </type> <institution> Department of Computer Science. Carnegie Mellon University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: Also, there are other programming languages that can be compiled into JVM bytecodes such as Kawa [6], which compiles Scheme code into JVM bytecodes and AppletMagic [17], which translates Ada 95 to JVM bytecodes. Furthermore, Hardwick and Sipelstein studied the feasibility of using Java as an intermediate language <ref> [14] </ref>. Because BIT instruments JVM bytecodes, it can be used to instrument programs written in any language that has been compiled to the JVM, and instrumentation does not require that the program source code be available.
Reference: [15] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast Detection of Memory Leaks and Access Errors. </title> <booktitle> Proceedings of the Winter USENIX Conference, </booktitle> <pages> Pages 125-136, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures. Also, software testing and quality assurance tools that detect memory leaks and access errors such as Purify <ref> [15] </ref> catch programming errors by using these techniques. Purify inserts instructions directly into the object code produced by existing compilers. These instructions, in turn, check the validity of every memory access performed by the program and report when there are errors.
Reference: [16] <author> Scott Hudson. </author> <title> Java Based Constructor of Useful Parsers (CUP). </title> <address> http://www.cc.gatech.edu/gvu/people/Faculty/huds on/java_cup/home.html. </address>
Reference-contexts: For these measurements, Jmark 1.2.1 [8], a JVM benchmark suite from Ziff-Davis publishing company; JLex [3], a lexical analyzer generator for Java; EspressoGrinder [24], a Java compiler; CUP <ref> [16] </ref>, a parser generator; and BIT were used as user applications on which the custom tools mentioned above were run.
Reference: [17] <author> Intermetrics. AppletMagic: </author> <title> Ada for Java Virtual Machine. </title> <address> http://www.appletmagic.com. </address>
Reference-contexts: Because BIT is written in Java, tools written using it are portable across platforms. Also, there are other programming languages that can be compiled into JVM bytecodes such as Kawa [6], which compiles Scheme code into JVM bytecodes and AppletMagic <ref> [17] </ref>, which translates Ada 95 to JVM bytecodes. Furthermore, Hardwick and Sipelstein studied the feasibility of using Java as an intermediate language [14].
Reference: [18] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting Executable Files to Measure Program Behavior. </title> <journal> Software, Practice and Experience, </journal> <volume> vol 24, no. 2, </volume> <pages> pages 197-218, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Techniques based on program instrumentation have also been used in optimizations [31, 32]. However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT <ref> [18] </ref>, Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures.
Reference: [19] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-Independent Executable Editing. </title> <booktitle> In Proceedings of the SIGPLAN 95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 291-300, </pages> <month> June </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: Finally, in Section 6, we summarize the paper and discuss future directions for research. 2. Related Work There are many tools that employ techniques based on program instrumentation to carry out different tasks. These tasks range from emulation and tracing to optimization <ref> [19] </ref>. The Wisconsin Wind Tunnel architecture simulator [27], for example, allows the emulation of a cycle counter, which the underlying hardware does not provide. Techniques based on program instrumentation have also been used in optimizations [31, 32]. <p> There is another group of tools, sometimes called binary editing or executable editing tools, which have different design goals and offer a library of routines for modifying executable files. The tools in this group include the OM system [32], EEL <ref> [19] </ref>, ATOM [30], and Etch [4], which are explained in more detail below. These tools differ in that they offer a library of routines for modifying executable files. Users, in turn, can design and build their own customized tools to meet their needs using these tools.
Reference: [20] <author> Han B. Lee. </author> <title> BIT: Bytecode Instrumenting Tool. </title> <type> MS thesis, </type> <institution> University of Colorado, Boulder, CO, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Over the years, researchers have built numerous tools that allow them to obtain this information. This paper describes BIT (Bytecode Instrumenting Tool) <ref> [20] </ref>, a tool that allows JVM bytecodes to be instrumented for the purpose of extracting measurements of their dynamic behavior. The JVM is an abstract machine specification designed to support the Java programming language, and JVM bytecodes are equivalent to binaries on other machines [21].
Reference: [21] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The JVM is an abstract machine specification designed to support the Java programming language, and JVM bytecodes are equivalent to binaries on other machines <ref> [21] </ref>. Although there are tools that allow binary instrumentation on a number of different operating systems and machine architectures, BIT is the first framework of which we are aware that supports JVM bytecode instrumentation.
Reference: [22] <institution> MIPS Computer Systems, Inc. Assembly Language Programmers Guide, </institution> <year> 1986. </year>
Reference: [23] <author> J. Eliot B. Moss and Antony L. Hosking. </author> <title> Approaches to Adding Persistence to Java. </title> <booktitle> First International Workshop on Persistence and Java, </booktitle> <month> Septermber </month> <year> 1996. </year>
Reference-contexts: There is a tool called NetProf [26] that visualizes Java profile information by translating Java bytecodes to Java source code. There are also tools that 3 carry out postprocessing on class files such as osjcfp [25] and the work by Cattell <ref> [23] </ref> to make classes persistence-capable. However, the inner workings of these tools have not been published. Furthermore, these are also customized tools and have the same limitations mentioned above.
Reference: [24] <author> Martin Odersky, Michael Philippsen, and Christian Kemper. EspressoGrinder. </author> <note> http://wwwipd.ira.uka.de/~espresso/. </note>
Reference-contexts: The characteristics measured were time required to instrument user programs, execution time of the instrumented programs, and the size of instrumented programs. For these measurements, Jmark 1.2.1 [8], a JVM benchmark suite from Ziff-Davis publishing company; JLex [3], a lexical analyzer generator for Java; EspressoGrinder <ref> [24] </ref>, a Java compiler; CUP [16], a parser generator; and BIT were used as user applications on which the custom tools mentioned above were run.
Reference: [25] <author> ODI. </author> <title> PSE/PSE Pro for Java API User Guide. </title> <year> 1997. </year>
Reference-contexts: There is a tool called NetProf [26] that visualizes Java profile information by translating Java bytecodes to Java source code. There are also tools that 3 carry out postprocessing on class files such as osjcfp <ref> [25] </ref> and the work by Cattell [23] to make classes persistence-capable. However, the inner workings of these tools have not been published. Furthermore, these are also customized tools and have the same limitations mentioned above.
Reference: [26] <author> Srinivasan Parthasarathy, Michael Cierniak, and Wei Li. NetProf: </author> <title> Network-based High-level Profiling of Java Bytecode. </title> <type> Technical Report 622, </type> <institution> Computer Science Department, University of Rochester, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: However, the Java interpreter provides some profiling information, which includes the method invocation sequence and the size of objects allocated, when invoked with the prof switch. There is a tool called NetProf <ref> [26] </ref> that visualizes Java profile information by translating Java bytecodes to Java source code. There are also tools that 3 carry out postprocessing on class files such as osjcfp [25] and the work by Cattell [23] to make classes persistence-capable.
Reference: [27] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, and David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers. </title> <booktitle> In Proceedings of the 1993 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 48-60, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Finally, in Section 6, we summarize the paper and discuss future directions for research. 2. Related Work There are many tools that employ techniques based on program instrumentation to carry out different tasks. These tasks range from emulation and tracing to optimization [19]. The Wisconsin Wind Tunnel architecture simulator <ref> [27] </ref>, for example, allows the emulation of a cycle counter, which the underlying hardware does not provide. Techniques based on program instrumentation have also been used in optimizations [31, 32].
Reference: [28] <author> Michael D. Smith. </author> <title> Tracing with Pixie. Memo from Center for Integrated Systems, </title> <institution> Stanford Univ., </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Techniques based on program instrumentation have also been used in optimizations [31, 32]. However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie <ref> [28] </ref>, and Epoxie [33] generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures.
Reference: [29] <author> K. So et al. </author> <title> PSIMUL A System for Parallel Execution of Parallel Programs. in Performance Evaluation of Supercomputers, </title> <editor> J.L. Martin, ed., </editor> <publisher> Elsevier Science Publishers B.V., North Hoolan, </publisher> <year> 1988. </year>
Reference: [30] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM A System for Building Customized Program Analysis Tools. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 196-205, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Moreover, many of these tools use inter-process communication or files to relay program behavior to the analysis routines, which are expensive <ref> [30] </ref>. There is another group of tools, sometimes called binary editing or executable editing tools, which have different design goals and offer a library of routines for modifying executable files. The tools in this group include the OM system [32], EEL [19], ATOM [30], and Etch [4], which are explained in <p> to the analysis routines, which are expensive <ref> [30] </ref>. There is another group of tools, sometimes called binary editing or executable editing tools, which have different design goals and offer a library of routines for modifying executable files. The tools in this group include the OM system [32], EEL [19], ATOM [30], and Etch [4], which are explained in more detail below. These tools differ in that they offer a library of routines for modifying executable files. Users, in turn, can design and build their own customized tools to meet their needs using these tools. <p> To provide a concrete understanding of how BIT works, we present a customized tool that could aid in branch prediction as illustrated by Srivastava and Eustace <ref> [30] </ref>. This tool counts the number of branches taken and not taken at all the branches in different methods. Figure 2 shows the instrumentation code for this tool. BITs methods are shown in bold. <p> To increase the execution speed of the instrumented user programs, we could inline analysis methods, removing method invocation overhead (see <ref> [30] </ref>). Allowing multiple arguments to analysis routines would significantly decrease the number of method calls required to do the instrumentation, and would also substantially improve performance. 6.
Reference: [31] <author> Amitabh Srivastava and David Wall. </author> <title> Link-Time Optimization of Address Calculation on a 64-bit Architecture. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 49-60, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Such information is used to identify critical pieces of code; for debugging purposes; to evaluate and compare the performance of different software or hardware implementations such as branch prediction, cache replacement, and instruction scheduling; and in support of profiledriven optimizations <ref> [31] </ref>. Over the years, researchers have built numerous tools that allow them to obtain this information. This paper describes BIT (Bytecode Instrumenting Tool) [20], a tool that allows JVM bytecodes to be instrumented for the purpose of extracting measurements of their dynamic behavior. <p> These tasks range from emulation and tracing to optimization [19]. The Wisconsin Wind Tunnel architecture simulator [27], for example, allows the emulation of a cycle counter, which the underlying hardware does not provide. Techniques based on program instrumentation have also been used in optimizations <ref> [31, 32] </ref>. However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables.
Reference: [32] <author> Amitabh Srivastava and David Wall. </author> <title> A Practical System for Intermodule Code Optimization at Link-Time. </title> <journal> Journal of Programming Languages, </journal> <volume> vol 1, no 1, </volume> <pages> pages 1-18, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: These tasks range from emulation and tracing to optimization [19]. The Wisconsin Wind Tunnel architecture simulator [27], for example, allows the emulation of a cycle counter, which the underlying hardware does not provide. Techniques based on program instrumentation have also been used in optimizations <ref> [31, 32] </ref>. However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie [28], and Epoxie [33] generate address traces and instruction counts by rewriting program executables. <p> There is another group of tools, sometimes called binary editing or executable editing tools, which have different design goals and offer a library of routines for modifying executable files. The tools in this group include the OM system <ref> [32] </ref>, EEL [19], ATOM [30], and Etch [4], which are explained in more detail below. These tools differ in that they offer a library of routines for modifying executable files. Users, in turn, can design and build their own customized tools to meet their needs using these tools.
Reference: [33] <author> David W. Wall. </author> <title> Systems for Late Code modification. </title> <editor> In Robert Giegerich and Susan L. Graham, eds., </editor> <title> Code Generation Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 275-293, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Techniques based on program instrumentation have also been used in optimizations [31, 32]. However, most of the tools that have been developed using program instrumentation techniques are used for studying program or system behavior. Tools such as QPT [18], Pixie [28], and Epoxie <ref> [33] </ref> generate address traces and instruction counts by rewriting program executables. MPTRACE [13] and ATUM [1] generate data and instruction traces, and PROTEUS [5] and Shade [7] emulate other architectures.
Reference: [34] <author> Benjamin Zorn and Paul Hilfinger. </author> <title> A Memory Allocation Profiler for C and Lisp Programs. </title> <booktitle> USENIX Conference Proceedings, </booktitle> <pages> pages 223-237, </pages> <month> Summer </month> <year> 1988. </year> <title> Sun, Sun Microsystems, and Java are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries. </title>
Reference-contexts: Exceptions are being ignored in the current implementation. 9 Larger customized tools using BIT need to be built to prove BITs usefulness. Possible candidates include a tool that performs hierarchical profiling of a class file such as gprof [13], HiProf [10], and mprof <ref> [34] </ref>. Recently, there have been other advances in profiling including flow and context sensitive profiling [2] and interprocedural dataflow analysis [11]. These advanced profiling techniques could also be applied to JVM programs with BIT. 7. Availability BIT source is freely available.
References-found: 34

