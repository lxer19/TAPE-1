URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/nl95.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Evaluation of Regular Nonlinear Recursions by Deductive Database Techniques  
Author: Jiawei Han and Laks V.S. Lakshmanan 
Address: Burnaby, BC, Canada V5A 1S6  Montreal, Quebec, Canada H3G 1M8  
Affiliation: School of Computing Science, Simon Fraser University,  Dept. of Computer Science, Concordia University,  
Abstract: Nonlinear recursion is one of the most challenging classes of logic programs for efficient evaluation in logic programming systems. We identify one popular class of nonlinear recursion, regular nonlinear recursion, and investigate its efficient implementation by a deductive database approach. The approach performs a detailed query binding analysis based on query information, constraint information and the structure of a recursion, selects an appropriate predicate evaluation order and generates an efficient query evaluation plan. Interesting query evaluation techniques, such as chain-following, chain-split, and constraint pushing, are developed for the efficient evaluation of different kinds of queries. Furthermore, the technique can be extended to the evaluation of regular nonlinear recursions in HiLog and F-logic programs. The study not only presents a method for the evaluation of regular nonlinear recursions in a declarative way but also demonstrates the power of the deductive database approach in the analysis and evaluation of sophisticated logic programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [13, 1, 2, 4, 41, 21, 30, 38, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets <ref> [1] </ref>, counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [13, 1, 2, 4, 41, 21, 30, 38, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets <ref> [1] </ref>, counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. 1986 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> In Section 5, we discuss the extension of the method to the evaluation of HiLog and F-logic programs, the efficiency of the evaluation method in comparison with others, and the implementation considerations. The study is summarized in Section 6. 2 Regular and Irregular Nonlinear Recursions Like many researchers <ref> [38, 2] </ref>, we assume that a deductive database is partitioned into three portions: (i) an extensional database (EDB) (a set of database relations), (ii) an intensional database (IDB) (a set of predicates defined by Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> Similar to the notations used in the magic sets transformation <ref> [2, 38] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound or free, and a string of b's and f 's used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> The nonlinear recursions which are linearizable (such as ancestor) are excluded from this discussion since they can be transformed into equivalent linear ones and be evaluated efficiently by linear recursive query evaluation techniques <ref> [2] </ref>. Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques [2, 11] for function-free recursions may still be applicable to the rectified 10 recursions. However, a rectified functional predicate may correspond to an infinite relation. <p> Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques <ref> [2, 11] </ref> for function-free recursions may still be applicable to the rectified 10 recursions. However, a rectified functional predicate may correspond to an infinite relation. The semi--naive bottom-up evaluation may not terminate on such recursions. <p> Similar to the dynamic query plan generation and query optimization in relational systems [38], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization <ref> [2, 23] </ref>. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [20], HiLog [8], XSQL [19], etc.
Reference: [3] <author> C. Beeri, P. Kanellakis, F. Bancilhon, and R. Ramakrishnan. </author> <title> Bounds on the propagation of selection into logic programs. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 214-226, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: It is performed using the methods discussed in Section 3. Step 2 is necessary and correct since the correct ordering of the predicates will lead to finite and efficient evaluation. Step 3 is correct because the most selective information should be pushed into the rectified chain for initial processing <ref> [3] </ref>. The iterative query evaluation can be determined by the query binding analysis because the binding information can be passed to the next iteration based on the regularity of the recursion.
Reference: [4] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [13, 1, 2, 4, 41, 21, 30, 38, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets <ref> [4] </ref>, generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets <ref> [4] </ref>, generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = [9; 5]" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; <ref> [4; 5; 9] </ref>)", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 4.4 Suppose the query on the quick sort recursion is posed as, "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append (<ref> [4] </ref>; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> follows. * The evaluation of (4.34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s <p> possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % <p> and "X Bs = [5; 9]". * The evaluation for qsort (Littles; <ref> [4] </ref>) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; <p> for qsort (Littles; <ref> [4] </ref>) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 <p> to "Littles = <ref> [4] </ref>"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % <p> of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = <ref> [4; 9] </ref>: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should <p> <ref> [4] </ref>; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f <p> (4; []; <ref> [4] </ref>); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. <p> []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; <ref> [4] </ref>; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. <p> 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f <ref> [4; 9] </ref>; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; <ref> [4; 5; 9] </ref>); X &gt; 4". <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 38, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation.
Reference: [5] <author> A. Brodsky and Y. Sagiv. </author> <title> On termination of datalog programs. </title> <booktitle> In Proc. 1st Int. Conf. Deductive and Object-Oriented Databases (DOOD'89), </booktitle> <pages> pages 95-112, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 39] </ref>. <p> Chain-split is also performed in the evaluation of append bbf . For brevity, this is not shown in the paper. The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (4.20) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.26) * This leads to the evaluation of "partition ([5]; 4; X Ls; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs <p> <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.26) * This leads to the evaluation of "partition ([5]; 4; X Ls; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 <p> 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.26) * This leads to the evaluation of "partition ([5]; 4; X Ls; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 ; Bs): (4.27) * The evaluation of "partition ([]; 4; X Ls; Bs 0 )" applying rule (4.24) derives "X Ls = []" and "Bs 0 = []". <p> It in turn derives "X Ls = []" and "Bs = <ref> [5] </ref>" in (4.27) and "XLs = []" and "X Bs = [9; 5]" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = [9; 5]" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = [5; 9]" by a <p> 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". <p> (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; <ref> [4; 5; 9] </ref>)", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 4.4 Suppose the query on the quick sort recursion is posed as, "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> follows. * The evaluation of (4.34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "X Bs = <ref> [5; 9] </ref>". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; <ref> [4; 5; 9] </ref>); X &gt; 4". <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [38, 25, 12, 7, 27, 28] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [31, 5, 18, 33, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [6] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of inequality constraints in logic programs. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 227-240, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 39] </ref>. <p> The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [39, 40, 6, 35, 29] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 3.4 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [7] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <editor> In W. Kim, J.-M. Nicolas, and S. Nishio, editors, </editor> <booktitle> Deductive and Object-Oriented Databases, </booktitle> <pages> pages 25-44. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [8] <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15 </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 23]. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [20], HiLog <ref> [8] </ref>, XSQL [19], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 4.3 can be extended to incorporate module facility in HiLog [8]. <p> such as F-logic [20], HiLog <ref> [8] </ref>, XSQL [19], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 4.3 can be extended to incorporate module facility in HiLog [8]. Example 5.1 The quick sort recursion shown in Example 4.3 can be turned into a module definition in HiLog to provide an alternative semantics for modular logic programming. Similar to [8], let P artition be an internal predicate, Sort be an external predicate, append and cons be global predicates defined <p> an example, the quick sort program presented in Example 4.3 can be extended to incorporate module facility in HiLog <ref> [8] </ref>. Example 5.1 The quick sort recursion shown in Example 4.3 can be turned into a module definition in HiLog to provide an alternative semantics for modular logic programming. Similar to [8], let P artition be an internal predicate, Sort be an external predicate, append and cons be global predicates defined outside of the module, and Order be a parameter which can be instantiated to any binary predicate of the user's choice.
Reference: [9] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [37, 9, 38, 26] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> Chain-split is also performed in the evaluation of append bbf . For brevity, this is not shown in the paper. The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (4.20) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.25) 14 * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.26) * This leads to the evaluation of "partition ([5]; 4; X Ls; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = [9; 5]" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" <p> It in turn derives "X Ls = []" and "Bs = [5]" in (4.27) and "XLs = []" and "X Bs = <ref> [9; 5] </ref>" in (4.26). (4.25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = [5; 9]" by a <p> 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". <p> (4; Bs; X Bs); append (Ls; XBs; Y s): (4.28) * The evaluation of "qsort ([]; Ls)" applying the rule (4.21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (X X s; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; <ref> [4; 5; 9] </ref>)", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based <p> In this case, the answer to the query will be all of the possible alternatives in X X s corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> For example, the evaluation of a query, "? qsort (X X s; [4; 5; 9])", will lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation [16, 14, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 4.4 Suppose the query on the quick sort recursion is posed as, "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; <ref> [9] </ref>; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> The evaluation of query "? qsort ([5jX s]; [4; 5; 9])" proceeds as follows. * The evaluation of (4.34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; <ref> [9] </ref>; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> follows. * The evaluation of (4.34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; X s; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (X s; 5; Littles; Bigs): (4.35) Notice that append (Ls; X Bs; [4; 5; 9]) may derive a set of values for Ls and X Bs. <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "X Bs = <ref> [5; 9] </ref>". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as <p> However, its following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % <p> following predicate cons (5; Bs; X Bs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 <p> and leave only one valid answer, "Ls = [4]" and "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which <p> "X Bs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) <p> qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; <p> (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (X s; 5; [4]; [9])". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 <p> the requirement becomes the evaluation for "partition (X s; 5; [4]; <ref> [9] </ref>)". * The evaluation of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; <p> of "partition (X s; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = <ref> [4; 9] </ref>: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should <p> <ref> [9] </ref>)" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f [4; <p> follows. partition (Xs; 5; [4]; <ref> [9] </ref>) cons (4; []; [4]); partition (X s 0 ; 5; []; [9]); % which derives X s 0 = [9]: 4 5; cons (4; X s 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. <p> 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> [9]) cons (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be XX s = f <ref> [4; 9] </ref>; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> (9; []; [9]); partition (X s 0 ; 5; [4]; []); % which derives X s 0 = [4]: 9 &gt; 5; cons (9; X s 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be XX s = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; [4; 5; 9]); X &gt; 4". <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([X jX s]; <ref> [4; 5; 9] </ref>); X &gt; 4". <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 38, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation.
Reference: [10] <author> J. Han. </author> <title> Constraint-based reasoning in deductive databases. </title> <booktitle> In Proc. 7th Int. Conf. Data Engineering, </booktitle> <pages> pages 257-265, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Query processing terminates when all such generated tuples are eliminated. 2 The algorithm which determines a set of sufficient conditions for the termination of query evaluation and transforms query or integrity constraints into termination restraint, when applicable, is similar to the one for the class of linear programs <ref> [10] </ref> and will not be presented here to save space. <p> After the exit portion is evaluated, the buffered portion should obtain sufficient binding information for evaluation (because the recursion is weakly finitely evaluable), and the evaluation proceeds by patching up the corresponding buffered values in the evaluation. This kind of evaluation is called chain-split evaluation <ref> [10] </ref>. <p> lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [16, 14, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> Instantiate other constraint information and push those constraints, when possible, into the adorned chain predicate (s) for efficient evaluation based on the principles of constraint-based recursive query evaluation <ref> [10] </ref>. 5. <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [38, 25, 12, 7, 27, 28] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [31, 5, 18, 33, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method. <p> Without such knowledge, it is difficult to fully explore various kinds of constraints, query instantiations, and argument relationships in a recursion for efficient query processing. For example, the pushing of some monotonicity constraints into chain expressions for efficient processing cannot be realized in the magic sets evaluation <ref> [10] </ref>. More studies need to be performed on the magic sets method to explore the regularity of the structures of a recursion in the efficient evaluation of functional recursions. In the following example, we compare the chain-based evaluation with other techniques in the evaluation of the hanoi recursion. <p> A detailed discussion based on this approach for the class of linear programs appears in <ref> [10] </ref>. 6 Conclusions We investigated the efficient evaluation of one popular class of nonlinear recursion, regular nonlinear recursion, in deductive database and logic programming systems based on a deductive database approach.
Reference: [11] <author> J. Han. </author> <title> Compilation-based list processing in deductive databases. </title> <editor> In A. Pirotte, C. Delobel, and G. Gottlob, editors, </editor> <booktitle> Extending Database Technology - EDBT'92 [Lecture Notes in Computer Science 580], </booktitle> <pages> pages 104-119. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> However, many application programs involve complex recursions with function symbols [37, 9, 38, 26]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [22, 21, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [34, 32, 42, 24]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. <p> Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques <ref> [2, 11] </ref> for function-free recursions may still be applicable to the rectified 10 recursions. However, a rectified functional predicate may correspond to an infinite relation. The semi--naive bottom-up evaluation may not terminate on such recursions. <p> However, a rectified functional predicate may correspond to an infinite relation. The semi--naive bottom-up evaluation may not terminate on such recursions. A chain-based evaluation method <ref> [11] </ref> is developed in this section for the evaluation of a regular functional nonlinear recursion, which views the recursion as a set of growing sequence of chains in which every chain is a set of connected predicates with certain regular patterns.
Reference: [12] <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <pages> 299-322, </pages> <year> 1992. </year>
Reference-contexts: ; X 3 ; Y 2 ); b (X 3 ; Y 1 ; Y 2 ): (2.14) Similarly, the nonlinear recursion r, defined by f (2.14), (2.15)g, is irregular. 2 An irregular linear recursion can be transformed into an equivalent, regular linear recursion by a normalization process described in <ref> [12] </ref>. However, it is an open problem to determine what kind of irregular nonlinear recursions can be regularized. <p> The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [13] <author> L. J. Henschen and S. Naqvi. </author> <title> On compiling queries in recursive first-order databases. </title> <journal> J. ACM, </journal> <volume> 31 </volume> <pages> 47-85, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions.
Reference: [14] <author> T. Imielinski. </author> <title> Intelligent query answering in rule based systems. </title> <journal> J. Logic Programming, </journal> <volume> 4 </volume> <pages> 229-257, </pages> <year> 1987. </year>
Reference-contexts: lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [16, 14, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate.
Reference: [15] <author> Y. E. Ioannidis and R. Ramakrishnan. </author> <title> Efficient transitive closure algorithms. </title> <booktitle> In Proc. 14th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 382-394, </pages> <address> Long Beach, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [13, 1, 2, 4, 41, 21, 30, 38, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms <ref> [15, 17] </ref>, magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [16] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proc. 14th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, Germany, </address> <year> 1987. </year>
Reference-contexts: lead to "X Xs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (X X s; [9; 4; 5])" will lead to no answer. 2 4.4 Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [16, 14, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> Furthermore, our study has been focused on the static control of query execution [23], in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution <ref> [16, 25] </ref>. Although static control, exercised by a query optimizer, is suitable for finding all the answers to a query, the dynamic control of the search process, exercised by the system at run time, may further reduce search space, enhance performance, and produce a few but knowledgeable answers.
Reference: [17] <author> B. Jiang. </author> <title> A suitable algorithm for computing partial transitive closures. </title> <booktitle> In Proc. 6th Int. Conf. Data Engineering, </booktitle> <pages> pages 264-271, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [13, 1, 2, 4, 41, 21, 30, 38, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms <ref> [15, 17] </ref>, magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [18] <author> D. B. Kemp, K. Ramamohanarao, I. Balbin, and K. Meenakshi. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pages 981-998, </pages> <address> Cleveland, OH, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [38, 25, 12, 7, 27, 28] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [31, 5, 18, 33, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [19] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented database. </title> <booktitle> In Proc. 1992 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 393-402, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 23]. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [20], HiLog [8], XSQL <ref> [19] </ref>, etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 4.3 can be extended to incorporate module facility in HiLog [8].
Reference: [20] <author> M. Kifer, G. Lausen, and J. Wu. </author> <booktitle> Logical foundations of object-oriented and frame-based languages. In J. ACM, </booktitle> <year> 1993. </year>
Reference-contexts: systems [38], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 23]. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic <ref> [20] </ref>, HiLog [8], XSQL [19], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 4.3 can be extended to incorporate module facility in HiLog [8].
Reference: [21] <author> M. Kifer, R. Ramakrishnan, and A. Silberschatz. </author> <title> An axiomatic approach to deciding finiteness of queries in deductive databases. </title> <booktitle> In Proc. 7th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 52-60, </pages> <address> Austin, TX, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> However, many application programs involve complex recursions with function symbols [37, 9, 38, 26]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [22, 21, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [34, 32, 42, 24]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. <p> For example, f (X 1 ; : : : ; X k ) = V is transformed to f (X 1 ; : : : ; X k ; V ). A similar transformation is also discussed in <ref> [31, 21] </ref>. Since the transformation maps a functional logical rule to a function-free one, the compilation and analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates. <p> A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [31, 21, 33] </ref>. Definition 3.1 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions).
Reference: [22] <author> R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. </author> <title> A framework for testing safety and effective computability of extended datalog. </title> <booktitle> In Proc. 1988 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 154-163, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: However, many application programs involve complex recursions with function symbols [37, 9, 38, 26]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [22, 21, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [34, 32, 42, 24]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
Reference: [23] <author> R. Krishnamurthy and C. Zaniolo. </author> <title> Optimization in a logic based language for knowledge and data intensive applications. </title> <booktitle> In Extending Database Technology (EDBT'88) [Lecture Notes in Computer Science 303], </booktitle> <pages> pages 16-33, </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The evaluation of a set of chains is similar to the evaluation of a set of connected relational expressions to which optimization method developed for relational query optimization can be largely applied <ref> [23] </ref>. The analysis of the structure of a recursion, the available query constraints and integrity constraints may lead to appropriate ordering of predicates in the evaluation, the maximal usage of query and integrity constraints and other optimization techniques. <p> However, the theorem does not claim the optimality of the algorithm. This is because the actual generation and selection of the query evaluation plan is a sophisticated and costly process, exponential to the size of the set of predicates in the recursion and the number of available access paths <ref> [23] </ref>. <p> Similar to the dynamic query plan generation and query optimization in relational systems [38], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization <ref> [2, 23] </ref>. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [20], HiLog [8], XSQL [19], etc. <p> The remaining unused subset will be submitted for evaluation only when not enough answers to the query have been generated. Furthermore, our study has been focused on the static control of query execution <ref> [23] </ref>, in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution [16, 25].
Reference: [24] <author> L. V. S. Lakshmanan, K. Ashraf, and J. Han. </author> <title> Homomorphic tree embeddings and their applications to recursive program optimization. </title> <booktitle> In Proc. 1993 Conf. Logic in Computer Science, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [22, 21, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [34, 32, 42, 24] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
Reference: [25] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding query power in constraint logic programming languages. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pages 20-36, </pages> <address> Cleveland, OH, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases. <p> Furthermore, our study has been focused on the static control of query execution [23], in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution <ref> [16, 25] </ref>. Although static control, exercised by a query optimizer, is suitable for finding all the answers to a query, the dynamic control of the search process, exercised by the system at run time, may further reduce search space, enhance performance, and produce a few but knowledgeable answers.
Reference: [26] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Data Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [37, 9, 38, 26] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> Example 2.4 Many recursions encountered in practical applications are regular ones. For example, the recursions ackermann ((2.7) - (2.9)) [36] and blue-blooded frenchman ((2.11) - (2.10)) <ref> [26] </ref> are both regular ones. ackermann (0; N; s (N )): (2.7) ackermann (s (M ); 0; V al) ackermann (M; s (0); V al): (2.8) ackermann (s (M ); s (N ); V al) ackermann (s (M ); N; V al 1 ); ackermann (M; V al 1 ; V
Reference: [27] <author> J. F. Naughton. </author> <title> Compiling separable recursions. </title> <booktitle> In Proc. 1988 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 312-319, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [28] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proc. 1989 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 235-242, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [29] <author> L. Plumer. </author> <title> Termination proofs for logic programs based on predicate inequalities. </title> <booktitle> In Proc. 7th Int. Conf. on Logic Programming, </booktitle> <pages> pages 634-648, </pages> <address> Jerusalem, </address> <year> 1990. </year>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [39, 40, 6, 35, 29] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 3.4 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [30] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proc. Int. Conf. Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions.
Reference: [31] <author> R. Ramakrishnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: For example, f (X 1 ; : : : ; X k ) = V is transformed to f (X 1 ; : : : ; X k ; V ). A similar transformation is also discussed in <ref> [31, 21] </ref>. Since the transformation maps a functional logical rule to a function-free one, the compilation and analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates. <p> A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [31, 21, 33] </ref>. Definition 3.1 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions). <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [38, 25, 12, 7, 27, 28] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [31, 5, 18, 33, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [32] <author> R. Ramakrishnan, Y. Sagiv, J.D. Ullman, and M. Vardi. </author> <title> Proof-tree transformation theorems and their applications. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 172-181, </pages> <address> Philadelphia, PA, </address> <year> 1989. </year>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [22, 21, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [34, 32, 42, 24] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
Reference: [33] <author> Y. Sagiv and M. Vardi. </author> <title> Safety of datalog queries over infinite databases. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 160-171, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [31, 21, 33] </ref>. Definition 3.1 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions). <p> The term weak finite evaluability is used here to distinguish (strong) finite evaluability which requires the evaluation of a query not only produces a finite intermediate relation at each step but also terminates and generates a finite, complete set of answers <ref> [33] </ref>. <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [38, 25, 12, 7, 27, 28] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [31, 5, 18, 33, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [34] <author> Y. P. Saraiya. </author> <title> Linearising nonlinear recursions in polynomial time. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 182-189, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [22, 21, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [34, 32, 42, 24] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
Reference: [35] <author> K. Sohn and A. van Gelder. </author> <title> Termination detection in logic programs using argument sizes. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 216-226, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [39, 40, 6, 35, 29] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 3.4 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [36] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The notations used in this paper are similar to Prolog <ref> [36] </ref>. 2 ancestor (X; Y ) parent (X; Y ): (2.1) ancestor (X; Y ) ancestor (X; W ); ancestor (W; Y ): (2.2) Example 2.2 The recursion hanoi, defined by f (2.3), (2.4)g, is a functional nonlinear recursion. It defines the Towers of Hanoi puzzle [36], that is, moving N <p> are similar to Prolog <ref> [36] </ref>. 2 ancestor (X; Y ) parent (X; Y ): (2.1) ancestor (X; Y ) ancestor (X; W ); ancestor (W; Y ): (2.2) Example 2.2 The recursion hanoi, defined by f (2.3), (2.4)g, is a functional nonlinear recursion. It defines the Towers of Hanoi puzzle [36], that is, moving N discs from peg A to peg B using peg C as an intermediary. <p> Example 2.4 Many recursions encountered in practical applications are regular ones. For example, the recursions ackermann ((2.7) - (2.9)) <ref> [36] </ref> and blue-blooded frenchman ((2.11) - (2.10)) [26] are both regular ones. ackermann (0; N; s (N )): (2.7) ackermann (s (M ); 0; V al) ackermann (M; s (0); V al): (2.8) ackermann (s (M ); s (N ); V al) ackermann (s (M ); N; V al 1 ); <p> This kind of evaluation is called chain-split evaluation [10]. Example 4.3 The quick sort recursion, qsort, defined by the following program (adopted from <ref> [36] </ref>) is a strongly regular nonlinear recursion because every argument in the head of each recursive rule of qsort and partition is static-regular. qsort ([X jX s]; Y s) partition (X s; X; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); append (Ls; [X jBs]; Y s): (4.10) qsort ([]; []): <p> It is important to compare the method with other implementation techniques for the evaluation of logic programs. Prolog implementations <ref> [36] </ref> can be applied to the evaluation of both regular and irregular nonlinear recursions. In this context, Prolog implementations cover a larger class of logic programs than the chain-based evaluation method. However, a Prolog implementation cannot guarantee the termination of an evaluation.
Reference: [37] <author> S. Tsur. </author> <title> Deductive databases in action. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 142-153, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [37, 9, 38, 26] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs.
Reference: [38] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, </title> <journal> Vols. </journal> <volume> 1 & 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [37, 9, 38, 26] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> In Section 5, we discuss the extension of the method to the evaluation of HiLog and F-logic programs, the efficiency of the evaluation method in comparison with others, and the implementation considerations. The study is summarized in Section 6. 2 Regular and Irregular Nonlinear Recursions Like many researchers <ref> [38, 2] </ref>, we assume that a deductive database is partitioned into three portions: (i) an extensional database (EDB) (a set of database relations), (ii) an intensional database (IDB) (a set of predicates defined by Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> Such a relation cannot be represented by a finite EDB relation. Thus the evaluation of a functional predicate should still rely on its corresponding function definition. A functional predicate can also be transformed back to its functional form, when necessary, which is called the predicate-function transformation. As discussed in <ref> [38] </ref>, logical rules in different forms should be rectified to facilitate the compilation and analysis. <p> For example, the linear recursion sg (twisted same generation relatives) <ref> [38] </ref>, defined by f (2.12), (2.13)g, is irregular. sg (X; Y ) parent (X; X p); sg (Y p; X p); parent (Y; Y p): (2.12) sg (X; Y ) sibling (X; Y ): (2.13) r (X; X 1 ; Y ) a (X; Y ); r (X 1 ; X <p> In other words, a finiteness constraint X ! Y over a predicate r implies that each value of attribute X corresponds to a finite set of Y values in r. Finiteness constraint is strictly weaker than the functional dependency studied in database theory <ref> [38] </ref>. It holds trivially for all finite predicates. Since EDB relations are finite, the arguments in EDB relations satisfy finiteness constraints. <p> Similar to the notations used in the magic sets transformation <ref> [2, 38] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound or free, and a string of b's and f 's used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> Similar to the dynamic query plan generation and query optimization in relational systems <ref> [38] </ref>, one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 23]. 17 5 Discussion 5.1 Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [20], HiLog <p> In this case, it is unnecessary to perform function-predicate transformation on such structures. This is because when an object structure is not to be altered in a program, the resolution operation on the structure is essentially simple structure (or term) matching, which can be implemented fairly efficiently <ref> [38] </ref>. It is unnecessary to delay the resolution on such object structures by a function-predicate transformation. <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 38, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. <p> The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [38, 25, 12, 7, 27, 28] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [31, 5, 18, 33, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [39] <author> J. D. Ullman and A. van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> J. ACM, </journal> <volume> 35 </volume> <pages> 345-373, </pages> <year> 1988. </year>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 39] </ref>. <p> The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [39, 40, 6, 35, 29] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 3.4 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [40] <author> A. van Gelder. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <booktitle> In Proc. 9th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 47-60, </pages> <address> Nashville, TN, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [39, 40, 6, 35, 29] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 3.4 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [41] <author> L. Vieille. </author> <title> From QSQ towards QoSaQ: Global optimization of recursive queries. </title> <booktitle> In Proc. 2nd Int. Conf. Expert Database Systems, </booktitle> <pages> pages 743-778, </pages> <address> Vienna, VA, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [13, 1, 2, 4, 41, 21, 30, 38, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [41], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> Some interesting query evaluation techniques, such as transitive closure algorithms [15, 17], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach <ref> [41] </ref>, etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols [37, 9, 38, 26].
Reference: [42] <author> W. Zhang, C.T. Yu, and D. Troy. </author> <title> Necessary and sufficient condition to linearize doubly recursive programs in logic databases. </title> <journal> ACM Trans. Database Syst., </journal> <volume> 15 </volume> <pages> 459-482, </pages> <year> 1990. </year> <month> 25 </month>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [22, 21, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [34, 32, 42, 24] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
References-found: 42

