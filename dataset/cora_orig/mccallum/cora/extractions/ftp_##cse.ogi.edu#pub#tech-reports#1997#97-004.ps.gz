URL: ftp://cse.ogi.edu/pub/tech-reports/1997/97-004.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: (synthetix-request@cse.ogi.edu)  
Title: A Toolkit for Specializing Production Operating System Code  
Author: Crispin Cowan, Dylan McNamee, Andrew Black, Calton Pu, Jonathan Walpole Charles Krasic, Perry Wagle, and Qian Zhang 
Web: http://www.cse.ogi.edu/DISC/projects/synthetix/  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology [10pt] Renauld Marlet University of Rennes IRISA  
Abstract: Specialization has been recognized as a powerful technique for optimizing operating systems. However, specialization has not been broadly applied beyond the research community because the current techniques, based on manual specialization, are time-consuming and error-prone. This paper describes a specialization toolkit that should help broaden the applicability of specializing operating systems by assisting in the automatic generation of specialized code, and guarding the specialized code to ensure the specialized system continues to be correct. We demonstrate the effectiveness of the toolkit by describing experiences we have had applying it in real, production environments. We report on our experiences with applying the tools to three disparate portions of operating systems: signal delivery, memory allocation and RPC. We describe how we used the toolkit to specialize these components, and present the resulting performance improvements. We conclude that a toolkit-based approach to specialization can work, and is an effective operating system optimization technique. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L.O. Andersen. </author> <title> Binding-time Analysis and the Taming of C Pointers. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM'93), </booktitle> <pages> pages 47-58, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Some of the tools described were actually designed for specialization, such as the C-Mix <ref> [1] </ref> partial evaluation compiler. Others are general-purpose software engineering tools that just happen to be useful for specialization, such as the Lackwit C analysis tool. 5.1 C-Mix Partial Evaluation Compiler C-Mix [1] is the only other partial evaluator for C programs besides Tempo. <p> Some of the tools described were actually designed for specialization, such as the C-Mix <ref> [1] </ref> partial evaluation compiler. Others are general-purpose software engineering tools that just happen to be useful for specialization, such as the Lackwit C analysis tool. 5.1 C-Mix Partial Evaluation Compiler C-Mix [1] is the only other partial evaluator for C programs besides Tempo. Like Tempo, C-Mix can partially evaluate C programs, do inter-procedural analysis, and deal with complex data structures and side-effects.
Reference: [2] <author> David A. Barrett and Bejamin G. Zorn. </author> <title> Using lifetime predictors to improve memory allocation performance. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Poor placement policy can cause the client to incur more memory penalties than otherwise necessary. Recent work in memory allocation suggests that specializing allocators to real program behavior is imperative in addressing all dimensions of allocator performance <ref> [4, 2, 15, 32, 35] </ref>. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it [32].
Reference: [3] <author> Brian N. Bershad, Stefan Savage, Przemysaw Pardyak, Emin Gun Sirer, Marc Fiuczynski, David Becker, Susan Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The toolkit approach to specialization distinguishes our work from previous specialization work [26], as well as other customizable operating system projects such as SPIN <ref> [3] </ref>. The guarding tools we provide support the explicit description and representation of quasi-invariants, thus helping the system preserve correctness despite evolving customization and specialization.
Reference: [4] <author> Jeff Bonwick. </author> <title> The slab allocator: An object-caching kernel memory allocator. </title> <booktitle> In USENIX Summer 1994 Technical Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Poor placement policy can cause the client to incur more memory penalties than otherwise necessary. Recent work in memory allocation suggests that specializing allocators to real program behavior is imperative in addressing all dimensions of allocator performance <ref> [4, 2, 15, 32, 35] </ref>. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it [32]. <p> The same specializations above on size and region will be used in conjunction with the specialized methods of Vmalloc to improve locality. For example, we can identify important common large object sizes and allocate them from using Vmalloc's pool method. Aside from decreased memory 12 overhead this affords, <ref> [4] </ref> shows how common initializa--tions can be avoided to improve locality. 4.4 RPC Specialization The specialization of Sun RPC (proposed in [34]) was the first successful application of systems code using partial evaluation, in particular the Tempo program special-izer [8] (summarized in Section 3.1).
Reference: [5] <author> Authors anonymized for review. </author> <title> A Distributed Real-Time MPEG Video Audio Player. </title>
Reference-contexts: Our original intuition was that signals are used between processes to communicate asynchronous information, such as the arrival of a video frame in a buffer <ref> [5] </ref>. However, this technique is also used to implement more general services: Xavier Leroy's POSIX Threads implementation for Linux [19] uses signals extensively for inter-thread synchronization.
Reference: [6] <author> Frederick W. Clegg, Gary Shiu-Fan Ho, Steven R. Kusmer, and John R. Sontag. </author> <title> The HP-UX Operating System on HP Precision Architecture Computers. </title> <journal> Hewlett-Packard Journal, </journal> <volume> 37(12) </volume> <pages> 4-22, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Section 3.4.1 describes usage of the MemGuard library. 3.3.1 MemGuard Implementation When MemGuard is asked to guard a quasi-invariant term, the first task is to turn off write-permissions for that page in virtual memory. In some architecture/OS combinations, such as the HP-UX operating system on the HP-PA architecture <ref> [6] </ref>, we were able to locate protection bits in the virtual memory hardware that were not used by the operating system. <p> This approach is not practical in general, because a 32-bit address space with 8 KB pages results in 524,288 pages. 64-bit machines, such as the HP-PA <ref> [6] </ref> and the DEC Alpha [30] further aggravate this problem.
Reference: [7] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: Using Quasi-Invariants to Generate Specialized Code Given some invariant conditions, specialized code can be generated for certain system components. While this can and has been done by hand, it can be automated using partial evaluation techniques <ref> [7, 29] </ref>. Partial evaluation is specifically the idea of defining some of the input to a function to be constant (truly invariant) and using that invariance to optimize the code. Section 3.1 describes our partial evaluation compiler for C code. <p> Section 3.5 describes our tools for efficiently allowing concurrent execution nd replacement of specialized code. The remainder of this section describes each of our tools. 3.1 Tempo: Generating Specialized Code Tempo is a program specializer based on partial evaluation <ref> [7, 18] </ref>. Tempo takes a generic source program P gen written in C plus a known subset of its input (the quasi-invariants), and produces a specialized C program P spec , which is simplified with respect to the quasi-invariants.
Reference: [8] <author> Charles Consel and Francois Noel. </author> <title> A general approach to run-time specialization and its application to C. </title> <booktitle> In 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St. Petersburgh Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Given that some set of invariants and quasi-invariants are true, a specialized component can be created that improves functionality or performance over the generic component that it replaces. Optimizations can be done using formal, mechanical methods such as partial evaluation with respect to the invariants <ref> [8] </ref>, or they can be at a higher level of changing the component's behavior while preserving the functional interface, such as changing the page replacement algorithm to adapt to application needs. Previous specialization research has extensively explored filesystem operations, such as read [20, 26]. <p> Tempo takes a generic source program P gen written in C plus a known subset of its input (the quasi-invariants), and produces a specialized C program P spec , which is simplified with respect to the quasi-invariants. Tempo supports both compile-time and run-time program specialization <ref> [8] </ref>, but in the specialization experiments carried out so far, we have used only compile-time specialization. Conceptually, program specialization using partial evaluation is straightforward. Tempo uses the known subset of input to analyze P gen , dividing it into static and dynamic parts. <p> Aside from decreased memory 12 overhead this affords, [4] shows how common initializa--tions can be avoided to improve locality. 4.4 RPC Specialization The specialization of Sun RPC (proposed in [34]) was the first successful application of systems code using partial evaluation, in particular the Tempo program special-izer <ref> [8] </ref> (summarized in Section 3.1). Since the RPC experiment is being reported in another submission to SOSP'97 (Automatic Specialization of Sun RPC Using a Partial Evaluator, by anonymous authors), we only outline the main results here.
Reference: [9] <author> Authors anonymized for review. </author> <title> Fast Concurrent Dynamic Linking for an Adaptive Operating System. </title>
Reference-contexts: This replacement is called replugging, and requires fast, safe, concurrent dynamic linking. The challenge is to facilitate very low latency execution of a function via an indirect function pointer while concurrently allowing the pointer to be changed. Locks are a logical choice, but locks may substantially degrade performance. In <ref> [9] </ref>, we describe a portable algorithm that supports low-latency invocation of replaceable functions while allowing concurrent update of pointers to those functions. The need for sophisticated replugging is a function of the kernel and the hardware. <p> Thus a function pointer suffices, without additional concurrency control requirements. simple replugger An asymmetric concurrency control mechanism, as described in <ref> [9] </ref>. This concurrency control mechanism allows fast invocation of the replaceable function, and somewhat slower replace ment of the function. counting replugger An enhancement to the simple re-plugger that counts the number of threads executing the specialized code.
Reference: [10] <author> Authors anonymized for review. </author> <title> Specialization Classes: An Object Framework for Specialization. </title>
Reference-contexts: When a guard detects that a quasi-invariant has been violated, it invokes a specialized version-management component, described in <ref> [10] </ref>. The most common action to be taken by the version-manager is to replace the dependent specialized components with other, differently specialized components, or with generic components. This replacement is called replugging, and requires fast, safe, concurrent dynamic linking. <p> A second solution to the problem of analyzing pointers is to make the various stages of compilation explicit in the original code. We have begun investigation into how such staging should be expressed, using an object-oriented paradigm <ref> [10, 33] </ref>.
Reference: [11] <author> Dawson R. Engler, Wilson C. Hsieh, and M. Frans Kaashoek. </author> <title> `C: A Language for High-Level, Efficient, and Machine-Independent Dynamic Code Generation. </title> <booktitle> In 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St. Petersburgh Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: We have begun investigation into how such staging should be expressed, using an object-oriented paradigm [10, 33]. Other examples related to this kind of approach are the use of an explicit eval function in functional programming and the 'C (tick C) approach <ref> [11] </ref>. 6.2 Experiences with Guarding Tools The correctness and performance of a system containing specialized code depend on the correctness and performance of the guarding tools. There are interesting correctness and performance trade-offs for each of the guarding tools proposed in this paper.
Reference: [12] <author> Dawson R. Engler, M. Frans Kaashoek, and James O'Toole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-level Resource Management. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The responsibility of ensuring that specializations do not conflict with each other is left to to extension-writers and the authors of built-in services. Exokernel <ref> [12] </ref> represents another approach to operating system customization. Exokernel pushes system services outside the kernel. Exokernel also enforces mainly syntactic protection without explicit description and representation of quasi-invariants.
Reference: [13] <author> Bryan Ford, Mike Hibler, Jay Lepreau, Patrick Tullmann, Godmar Back, and Stephen Clawson. </author> <title> Microkernels Meet Recursive Virtual Machines. </title> <booktitle> In Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 137-151, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The Utah Flux project has constructed a software architecture that supports flexible replacement of operating system components, particularly nesting of operating system components <ref> [13, 14] </ref> using concepts such as recursive virtual machines [27]. These flexible layers of indirection come at some cost. However, specialization may be able to minimize these costs.
Reference: [14] <author> Bryan Ford and Sai Susarla. </author> <title> CPU Inheritance Scheduling. </title> <booktitle> In Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 91-105, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The Utah Flux project has constructed a software architecture that supports flexible replacement of operating system components, particularly nesting of operating system components <ref> [13, 14] </ref> using concepts such as recursive virtual machines [27]. These flexible layers of indirection come at some cost. However, specialization may be able to minimize these costs.
Reference: [15] <author> Dirk Grunwald and Benjamin Zorn. </author> <title> Customalloc: Efficient synthesized memory allocators. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 23(8) </volume> <pages> 851-869, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Poor placement policy can cause the client to incur more memory penalties than otherwise necessary. Recent work in memory allocation suggests that specializing allocators to real program behavior is imperative in addressing all dimensions of allocator performance <ref> [4, 2, 15, 32, 35] </ref>. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it [32]. <p> Vmal-loc employs several heuristics aimed precisely at avoiding the splay tree. By specializing for static size arguments, we can remove the initial interpretation and directly execute the appropriate strategy. For the small objects, this leads to code similar in spirit of the synthesized allocators produced by CustoMalloc <ref> [15] </ref>. The region abstraction provided by Vmalloc is yet another example of binding a connection between system entities. This binding allows Vmalloc to provide specialized services, but it imposes the familiar interpretation overhead and associated indirections through region data structures.
Reference: [16] <author> Dirk Grunwald, Benjamin Zorn, and Robert Henderson. </author> <title> Improving the cache locality of memory allocation. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 177-186, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: There are reasons to believe that existing allocators have design traits that cause them to negatively affect the client program's locality of reference. Internally, allocators commonly employ performance enhancing heuristics, such as boundary tags, that disregard the penalty of polluting the data cache <ref> [16] </ref>. A boundary tag is a technique that reduces the space overhead of the allocator by placing bookkeeping data inside currently unused memory blocks.
Reference: [17] <author> Michael K. Johnson. </author> <title> The Linux Kernel Hacker's Guide: A Tour of the Linux VFS. </title> <address> http://www.redhat.com:8080/ HyperNews/get/fs/vfstour.html, </address> <year> 1996. </year>
Reference-contexts: Second, we could have repeated the hand-specialization experiments on Linux, and compared them to the same specializations done via the toolkit. Unfortunately, the portions of the system that were addressed in previous experiments have already been hand-specialized in the Linux system. Comments from the developers who did this specialization <ref> [17] </ref> bear out our claim that doing such specialization by hand is difficult and obfuscates the system.
Reference: [18] <author> N.D. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Section 3.5 describes our tools for efficiently allowing concurrent execution nd replacement of specialized code. The remainder of this section describes each of our tools. 3.1 Tempo: Generating Specialized Code Tempo is a program specializer based on partial evaluation <ref> [7, 18] </ref>. Tempo takes a generic source program P gen written in C plus a known subset of its input (the quasi-invariants), and produces a specialized C program P spec , which is simplified with respect to the quasi-invariants.
Reference: [19] <author> Xavier Leroy. </author> <title> The LinuxThreads library. </title> <address> http://pauillac.inria.fr/ xleroy/linuxthreads/, </address> <year> 1996. </year>
Reference-contexts: Our original intuition was that signals are used between processes to communicate asynchronous information, such as the arrival of a video frame in a buffer [5]. However, this technique is also used to implement more general services: Xavier Leroy's POSIX Threads implementation for Linux <ref> [19] </ref> uses signals extensively for inter-thread synchronization. Linux threads are somewhat unusual, in that they use kernel level processes with shared address spaces, rather than threads within a single process, much like Plan 9 [25] variable-weight processes. Signals are used to communicate between these processes in the thread library.
Reference: [20] <author> Authors anonymized for review. </author> <title> Threads and Input/Output in the Synthesis Kernel. </title>
Reference-contexts: 1 Introduction Specialization has been demonstrated to improve the performance of generic operating system code by dynamically creating optimized code for common cases that are discovered at run time <ref> [20, 26] </ref>. However promising, specialization has yet to make a significant impact outside the research community. This paper introduces a toolkit we are constructing that eases the task of specializing production operating system code. <p> Previous specialization research has extensively explored filesystem operations, such as read <ref> [20, 26] </ref>. In these projects, various quasi-invariants related to kernel open file objects (file descriptors) were exploited as specialization opportunities. For example, when an application repeatedly performs small sequential reads, the file descriptor's current physical block number is a quasi-invariant. <p> In any case, the transient connection between entities produces quasi-invariants describing the relationship between the entities. In previous file system specialization experiments <ref> [20, 26] </ref>, the connection was between a process and a file, and the quasi-invariants related to things such as the location of the file, and whether the file was shared.
Reference: [21] <author> James G. Mitchell. </author> <title> JavaOS: Back To The Future. </title> <booktitle> In Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> page 1, </pages> <month> October </month> <year> 1996. </year> <type> Invited talk. 15 </type>
Reference-contexts: This indicates the desirability of semantically cleaner programming languages, such as Java, ML or Modula-3, for building specialization-friendly operating systems. In particular, the use of Java for implementing JavaOS has already shown some interesting optimization opportunities, such as copy-elimination <ref> [21] </ref>. A second solution to the problem of analyzing pointers is to make the various stages of compilation explicit in the original code. We have begun investigation into how such staging should be expressed, using an object-oriented paradigm [10, 33].
Reference: [22] <author> Robert O'Callahan and Daniel Jackson. Lackwit: </author> <title> A Pro--gram Understanding Tool Based on Type Inference. </title> <booktitle> In Proceedings of International Conference on Software Engineering (ICSE'97), </booktitle> <address> Boston, MA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: C-Mix is also more consumptive of code space, because it eagerly replicates code to avoid problems in binding-time analysis. 5.2 Lackwit C Program Understanding Tool Lackwit <ref> [22] </ref> is a program understanding tool for C based on type inference.
Reference: [23] <author> Doug Orr. </author> <title> OMOS an object server for program execution. </title> <booktitle> In Proc. International Workshop on Object-Oriented Operating Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Lackwit performs more precise analysis than TypeGuard, but at the expense of using an algorithm that is NP-hard in the worst case. 5.3 OMOS Dynamic Linking Tool The Utah Flex project developed OMOS <ref> [23] </ref>, an object/meta-object server that allows the dynamic linking of executable modules. OMOS provides for the dynamic instantiation of executable modules, and wraps them in an object-oriented package, even if they were not written in an object-oriented language.
Reference: [24] <author> Przemyslaw Pardyak and Brian N. Bershad. </author> <title> Dynamic binding for an Extensible System. </title> <booktitle> In Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 201-212, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: In contrast, systems like SPIN enforce protection through the use of a type-safe programming language combined with a dispatcher which enforces constraints described by the service-writer <ref> [24] </ref>. For example, the dispatcher might enforce that a particular virtual memory extension can only handle faults for the process that installed it. SPIN also includes a hierarchical name-space that limits the damage caused by broken specialized modules to only those tasks that specifically ask to use the specialized components.
Reference: [25] <author> Rob Pike, Dave Presotto, Ken Thompson, and Howard Trickey. </author> <title> Plan 9 from Bell Labs. </title> <booktitle> In Proceedings of the Summer UKUUG Conference, </booktitle> <pages> pages 1-9, </pages> <address> London, UK, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: Linux threads are somewhat unusual, in that they use kernel level processes with shared address spaces, rather than threads within a single process, much like Plan 9 <ref> [25] </ref> variable-weight processes. Signals are used to communicate between these processes in the thread library. Table 6 shows the impact of signal specialization on a test program using this thread library. The test program is an implementation of the classic producer-consumer problem, using thread mutex's for synchronization.
Reference: [26] <author> Authors anonymized for review. </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System. </title>
Reference-contexts: 1 Introduction Specialization has been demonstrated to improve the performance of generic operating system code by dynamically creating optimized code for common cases that are discovered at run time <ref> [20, 26] </ref>. However promising, specialization has yet to make a significant impact outside the research community. This paper introduces a toolkit we are constructing that eases the task of specializing production operating system code. <p> Previous specialization research has extensively explored filesystem operations, such as read <ref> [20, 26] </ref>. In these projects, various quasi-invariants related to kernel open file objects (file descriptors) were exploited as specialization opportunities. For example, when an application repeatedly performs small sequential reads, the file descriptor's current physical block number is a quasi-invariant. <p> For example, when an application repeatedly performs small sequential reads, the file descriptor's current physical block number is a quasi-invariant. This quasi-invariant was used to generate a specialized version of read that performed better than the unspecialized read by more than a factor of 3 <ref> [26] </ref>. 2.2 Motivation for a Specialization Toolkit Even though specialization can be a powerful optimization technique, it has not been broadly applied in commercial operating systems. We believe this is because correct and effective specialization is hard to do. <p> One in-dication of the difficulty of this task is that all of the previous work in operating system specialization has concentrated on only one subsystem (the filesystem), and only a limited number of quasi-invariants within that subsystem (e.g., shared status, sequentiality of reads, and existence of holes in file layout.) <ref> [26] </ref>. The experiences reported in Section 4 indicate that tools can not replace human intuition and experience, but that tools can be used to assist kernel developers to evaluate quasi-invariant candidates, and aid the verification phase. <p> The toolkit approach to specialization distinguishes our work from previous specialization work <ref> [26] </ref>, as well as other customizable operating system projects such as SPIN [3]. The guarding tools we provide support the explicit description and representation of quasi-invariants, thus helping the system preserve correctness despite evolving customization and specialization. <p> Making such a counting replug-ger concurrent-safe requires an atomic increment of some kind. The experiments described in <ref> [26] </ref> were performed using HP-UX 9.04 (which is single-threaded) on an HP9000 S800 dual processor, and thus we implemented the simple replugger. <p> In any case, the transient connection between entities produces quasi-invariants describing the relationship between the entities. In previous file system specialization experiments <ref> [20, 26] </ref>, the connection was between a process and a file, and the quasi-invariants related to things such as the location of the file, and whether the file was shared.
Reference: [27] <author> Authors anonymized for review. </author> <title> The Synthesis Kernel. </title>
Reference-contexts: The Utah Flux project has constructed a software architecture that supports flexible replacement of operating system components, particularly nesting of operating system components [13, 14] using concepts such as recursive virtual machines <ref> [27] </ref>. These flexible layers of indirection come at some cost. However, specialization may be able to minimize these costs. The replaceable software components are large and complex, and the relationship between them is largely quasi-invariant, because the components are not replaced frequently.
Reference: [28] <author> William Pugh. </author> <title> Skip Lists: A Probabilistic Alternative to Balanced Trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: This approach is not practical in general, because a 32-bit address space with 8 KB pages results in 524,288 pages. 64-bit machines, such as the HP-PA [6] and the DEC Alpha [30] further aggravate this problem. Thus MemGuard must resort either to hierarchical data structures <ref> [28] </ref>, or explicitly allocated and managed memory regions [31] that are sub-indexed linearly. 1 Unfortunately, it is not possible to move a quasi-invariant term to a separate page without inducing consistency checking problems at least as difficult as the guarding problem itself. Operation Min Avg.
Reference: [29] <author> P. Sestoft and A. V. Zamulin. </author> <title> Annotated bibliography on partial evaluation and mixed computation. </title> <editor> In D. Bjrner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Using Quasi-Invariants to Generate Specialized Code Given some invariant conditions, specialized code can be generated for certain system components. While this can and has been done by hand, it can be automated using partial evaluation techniques <ref> [7, 29] </ref>. Partial evaluation is specifically the idea of defining some of the input to a function to be constant (truly invariant) and using that invariance to optimize the code. Section 3.1 describes our partial evaluation compiler for C code.
Reference: [30] <author> Richard L. </author> <title> Sites. Alpha AXP Architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 33-44, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: This approach is not practical in general, because a 32-bit address space with 8 KB pages results in 524,288 pages. 64-bit machines, such as the HP-PA [6] and the DEC Alpha <ref> [30] </ref> further aggravate this problem.
Reference: [31] <author> Avadis Tevanian, Jr. </author> <title> Architecture-Independent Virtual Memory Manager for Parallel and Distributed Environments: The Mach Approach. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: Thus MemGuard must resort either to hierarchical data structures [28], or explicitly allocated and managed memory regions <ref> [31] </ref> that are sub-indexed linearly. 1 Unfortunately, it is not possible to move a quasi-invariant term to a separate page without inducing consistency checking problems at least as difficult as the guarding problem itself. Operation Min Avg.
Reference: [32] <author> Kiem-Phong Vo. </author> <title> Vmalloc: A general and efficient memory allocator. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 26(3) </volume> <pages> 357-374, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Poor placement policy can cause the client to incur more memory penalties than otherwise necessary. Recent work in memory allocation suggests that specializing allocators to real program behavior is imperative in addressing all dimensions of allocator performance <ref> [4, 2, 15, 32, 35] </ref>. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it [32]. <p> in addressing all dimensions of allocator performance [4, 2, 15, 32, 35]. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it <ref> [32] </ref>. Figure 6 contains a portion of the Vmalloc interface. By providing various different disciplines and methods, Vmalloc allows application programmers an ability to tailor memory allocation to their needs. <p> Vmalloc's general purpose allocator is based on a best-fit method which combines use of a splay tree data structure and several performance improving heuristics. Performance of Vmalloc's best-fit allocator is competitive with the best of several popular malloc implementations <ref> [32] </ref>. Vmalloc provides a transition path to specializing memory allocation of legacy programs. A set of stubs is provided that allows the standard malloc calls to be redirected to Vmalloc.
Reference: [33] <author> Authors anonymized for review. </author> <title> Declarative Specialization of Object-Oriented Programs. </title>
Reference-contexts: A second solution to the problem of analyzing pointers is to make the various stages of compilation explicit in the original code. We have begun investigation into how such staging should be expressed, using an object-oriented paradigm <ref> [10, 33] </ref>.
Reference: [34] <author> Eugen-Nicolae Volanschi, Gilles Muller, and Charles Con-sel. </author> <title> Safe Operating system Specialization: The RPC Case Study. </title> <booktitle> In Proceedings of the First Annual Workshop on Compiler Support for System Software, </booktitle> <address> Tuscon, AZ, </address> <month> Febru-ary </month> <year> 1996. </year>
Reference-contexts: For example, we can identify important common large object sizes and allocate them from using Vmalloc's pool method. Aside from decreased memory 12 overhead this affords, [4] shows how common initializa--tions can be avoided to improve locality. 4.4 RPC Specialization The specialization of Sun RPC (proposed in <ref> [34] </ref>) was the first successful application of systems code using partial evaluation, in particular the Tempo program special-izer [8] (summarized in Section 3.1).
Reference: [35] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic storage allocation: A survey and critical review. </title> <booktitle> In 1995 International Workshop on Memory Management, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <pages> 1195. </pages>
Reference-contexts: Fragmentation is a measure of how efficient an allocator utilizes of memory. Fragmentation and allocator latency necessarily trade-off against each other. Many studies emphasize that maximizing the allocator's capacity to avoid fragmentation should be the primary design objective <ref> [35] </ref>. Latency and fragmentation have traditionally been identified as the key performance dimensions for malloc, while locality effects are often overlooked. There are reasons to believe that existing allocators have design traits that cause them to negatively affect the client program's locality of reference. <p> Poor placement policy can cause the client to incur more memory penalties than otherwise necessary. Recent work in memory allocation suggests that specializing allocators to real program behavior is imperative in addressing all dimensions of allocator performance <ref> [4, 2, 15, 32, 35] </ref>. 4.3.1 Vmalloc: Towards Specialized Allocation Vmalloc is an allocator that extends the standard mal-loc interface with the notion of memory regions, each of which has an associated discipline for obtaining new memory and a method for managing it [32].
Reference: [36] <author> Robert P. Wilson, Robert S. French, Christopher S. Wilson, Saman P. Amarasighe, Jennifer M Anderson, Steve K.K. Tjiang, Shih-Wei Liao, Chau-Wen Tseng, Mary W. Hall, Monica S. Lam, and John L. Hennessy. </author> <title> SUIF: An Infrastructure for Research on Parallelizing and Optimizing Compilers. </title> <address> http://suif.stanford.edu/ suif/suif-overview/suif.html. </address>
Reference-contexts: The tool is based on the SUIF compiler toolkit <ref> [36] </ref>. SUIF provides a basic framework that parses C source code and stores it in a standardized intermediate format that is used by each phase of the compiler. We have used the SUIF library of functions for manipulating this intermediate representation to process the program as follows: 1.
Reference: [37] <author> Benjamin Zorn. </author> <title> A collection of malloc benchmarks. </title> <journal> ftp://ftp.cs.colorado.edu/pub/misc/malloc-benchmarks/. </journal> <volume> 16 </volume>
Reference-contexts: Vmalloc provides a framework for addressing the other dimensions, while the application of Tempo to Vmalloc removes much of the additional latency that would otherwise accompany Vmalloc's flexibility. 4.3.3 Vmalloc Specialization Performance For our experiment we use a set of benchmark applications provided by Benjamin Zorn's memory allocation repository <ref> [37] </ref>. The benchmarks are run to measure four scenarios. The first scenario, LIBC, uses standard malloc implementation provided in the Linux libc library. The second, VMALLOC, uses the unmodified Vmalloc via the mal-loc compatibility stubs.
References-found: 37

