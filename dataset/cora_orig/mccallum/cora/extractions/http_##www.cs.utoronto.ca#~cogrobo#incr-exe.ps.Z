URL: http://www.cs.utoronto.ca/~cogrobo/incr-exe.ps.Z
Refering-URL: http://www.cs.utoronto.ca/~cogrobo/
Root-URL: 
Email: j j  
Phone: 0 0  
Title: D  Abstract ConGolog ConGolog Off-line and On-line execution  
Author: D Giuseppe De Giacomo Hector Levesque 
Abstract-found: 0
Intro-found: 1
Reference: <editor> rap prs strips while do endWhileAcceptable Acceptable Acceptable single etc guarantee incremental planning Proc. </editor> <booktitle> AAAI-88 Proc. AAAI-96 AAAI-87 Proc. IJCAI-97 Proc. KR-96 The Semantics of Programming Languages IEEE Expert 6 Proc. 3rd European Workshop on Planning Proc. AAAI-96 Journal of Logic Programming 1-3 Artificial Intelligence Machine Intelligence Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy Proc. of AAAI-93 The operator is used for a nondeterministic choice of value. </booktitle>
Reference: [1] <author> J. A. Ambros-Ingerson and S. Steel. </author> <title> Integrating Planning, Execution and Monitoring. </title> <address> In , Saint Paul, Minnesota, </address> <year> 1988. </year>
Reference: [2] <author> F. Bacchus and F. Kabanza. </author> <title> Planning for temporally extended goals. </title> <booktitle> In , Portland, </booktitle> <address> Oregon, </address> <year> 1996. </year>
Reference: [3] <author> R. J. Firby. </author> <title> An investigation in reactive planning in complex domains. </title> <booktitle> In , Seattle, </booktitle> <address> Washington, </address> <year> 1987. </year>
Reference: [4] <author> G. de Giacomo, Y. Lesp erance, and H .Levesque. </author> <title> Reasoning about concurrent execution, prioritized interrupts, </title> <booktitle> and exogenous actions in the situation calculus. In , Nagoya, </booktitle> <address> Japan, </address> <year> 1997. </year>
Reference-contexts: Dipartimento di Informatica e Sistemistica Universita di Roma La Sapienza Via Salaria 113, 00198 Rome, Italy Department of Computer Science University of Toronto Toronto, Canada M5S 3H5 In <ref> [4] </ref> it was argued that when it comes to providing high level control to autonomous agents or robots, the notion of offers an alternative to classical planning that may be more practical in many applications. <p> This can involve considerable search when is very nondeterministic, but much less search when is more deterministic. The feasibility of this approach for AI purposes clearly depends on the expressive power of the programming language in question. In <ref> [4] </ref>, a language called is presented, which in addition to nondeterminism, contains facilities for sequence, iteration, conditionals, concurrency, and prioritized interrupts. In this paper, we extend the expressive power of this language by providing much finer control over the nondeterminism, and by making provisions for sensing actions. <p> In the following section, we formally characterize program execution in the language of the situation calculus. Next, we describe an incremental interpreter in Prolog that is correct with respect to this specification. The final section contains discussion and conclusions. To be compatible with planning, the interpreter presented in <ref> [4] </ref> executes in an manner, in the sense that it must find a sequence of actions constituting an entire legal execution of a program actually executing any of them in the world. <p> Trans Final initial situation do do fluents Poss SF We will see below that this problem is compounded in the presence of sensing actions. If a small amount of nondeterminism in a program is to remain practical (as suggested by <ref> [4] </ref>), we need to be able to choose between and based on some local criterion without necessarily having to go through all of . <p> It therefore appears that only an on-line execution style is practical for large programs containing nondeterminism and sensing actions. The technical machinery we use to define on-line program execution in the presence of sensing is essentially that of <ref> [4] </ref>, we use the predicates and to define a single step semantics of programs [6, 13]. However some adaptation is necessary to deal with on-line execution, sensing results, and the operator. The starting point in the definition is the situation calculus [12]. <p> This formula uses to tell us what must be true for the sensing to come out as specified by starting in . The on-line execution of a program consists of a sequence of legal single-step transitions. In <ref> [4] </ref>, two special predicates, and were axiomatized, where ( ) was intended to say that program may legally terminate in situation , and where ( ) was intended to say that program in situation may legally execute one step, ending in situation with program remaining. <p> For our account here, we include all the axioms for and from <ref> [4] </ref> (the details of which we omit), and add two new ones below for the operator. However, instead of using these axioms to characterize a formula for off-line execution, we will use them together with sensing values to define on-line execution. <p> The interpreter in <ref> [4] </ref> as well as in earlier work on which it was based [10] was designed to handle cases where what was known about the initial situation could be represented by a set of atomic formulas together with a closed-world assumption.
Reference: [5] <author> K. Golden and D. Weld. </author> <title> Representing sensing actions: the middle ground revisited. </title> <address> In , Cambridge, Mas-sachusetts, </address> <year> 1996. </year>
Reference-contexts: There is no loss of expressive power here since to execute a program the old way, we need only put the entire program within a operator. This on-line style of execution is well-suited to programs containing sensing actions. As described in <ref> [5, 9, 15] </ref>, sensing actions are actions that can be taken by the agent or robot to obtain information about the state of certain fluents, rather than to change them.
Reference: [6] <author> M. </author> <title> Hennessy. </title> . <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: The technical machinery we use to define on-line program execution in the presence of sensing is essentially that of [4], we use the predicates and to define a single step semantics of programs <ref> [6, 13] </ref>. However some adaptation is necessary to deal with on-line execution, sensing results, and the operator. The starting point in the definition is the situation calculus [12].
Reference: [7] <author> F. F. Ingrand, M. P. Georgeff, and A. S. Rao. </author> <title> An architecture for real-time reasoning and system control. </title> , , , <year> 1992, </year>
Reference: [8] <author> P. Jonsson and C. Backstrom. </author> <title> Incremental planning. </title> <booktitle> In , 1995. </booktitle>
Reference: [9] <author> H. Levesque. </author> <title> What is planning in the presence of sensing? In , Portland, </title> <address> Oregon, </address> <year> 1996. </year>
Reference-contexts: There is no loss of expressive power here since to execute a program the old way, we need only put the entire program within a operator. This on-line style of execution is well-suited to programs containing sensing actions. As described in <ref> [5, 9, 15] </ref>, sensing actions are actions that can be taken by the agent or robot to obtain information about the state of certain fluents, rather than to change them. <p> The only option available is to see if one or or would lead to for values of . This requires considering both and , even though in the end, only one of them will be executed. Similarly, if we attempt to generate a low-level robot program (as suggested in <ref> [9] </ref> for planning in the presence of sensing), we end up having to consider both and . The situation is even worse with loops. <p> performing the action ; relations whose truth values vary from situation to situation, are called (relational) , and are denoted by predicate symbols taking a situation term as their last argument; there is a special predicate ( ) used to state that action is executable in situation ; finally, following <ref> [9] </ref>, there is a special predicate ( ) used to state that action would return the binary sensing result 1 in situation . Within this language, we can formulate domain theories which describe how the world changes as the result of the available actions. <p> Unique names axioms for the primitive actions. Some foundational, domain independent axioms. Finally, as in <ref> [9] </ref>, we include Sensed fluent axioms, one for each primitive action of the form ( ) ( ) characterizing .
Reference: [10] <author> H. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> , <booktitle> Special issue on actions, </booktitle> , , <pages> pp. 59-83, </pages> <year> 1997. </year>
Reference-contexts: The interpreter in [4] as well as in earlier work on which it was based <ref> [10] </ref> was designed to handle cases where what was known about the initial situation could be represented by a set of atomic formulas together with a closed-world assumption. In the presence of sensing, however, we cannot simply apply a closed-world assumption blindly.
Reference: [11] <author> F. Lin and R. Reiter. </author> <title> How to progress a database. </title> <booktitle> In , , pp. </booktitle> <pages> 131-167, </pages> <year> 1997. </year>
Reference-contexts: Final Trans Trans Final In practice, we would not want the history list to get too long, and would use some form of rolling forward <ref> [11] </ref>. /* P is a program */ /* H is a history, initially [] */ /* H ::= [] | [(Act,1/0)|H] */ incrInterpret (P,H) :- final (P,H). incrInterpret (P,H) :- nextAct (P,H,Act,P1), !, execute (Act,Sv), incrInterpret (P1,[(Act,Sv)|H]). incrInterpret (P,H) :- trans (P,H,P1,H), incrInterpret (P1,H). nextAct (P,H,Act,P1) :- trans (P,H,P1,[(Act,_)|H]). execute (Act,Sv)
Reference: [12] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In , vol. </booktitle> <volume> 4, </volume> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: However some adaptation is necessary to deal with on-line execution, sensing results, and the operator. The starting point in the definition is the situation calculus <ref> [12] </ref>.
Reference: [13] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Dept. Aarhus Univ. Denmark, </institution> <year> 1981. </year>
Reference-contexts: The technical machinery we use to define on-line program execution in the presence of sensing is essentially that of [4], we use the predicates and to define a single step semantics of programs <ref> [6, 13] </ref>. However some adaptation is necessary to deal with on-line execution, sensing results, and the operator. The starting point in the definition is the situation calculus [12].
Reference: [14] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. In , pages 359-380. </title> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Within this language, we can formulate domain theories which describe how the world changes as the result of the available actions. One possibility is an action theory of the following form <ref> [14] </ref>: Axioms describing the initial situation, . <p> Successor state axioms, one for each fluent , stating under what conditions ( ( )) holds as function of what holds in situation These take the place of the so-called effect axioms, but also provide a solution to the frame problem <ref> [14] </ref>. Unique names axioms for the primitive actions. Some foundational, domain independent axioms. Finally, as in [9], we include Sensed fluent axioms, one for each primitive action of the form ( ) ( ) characterizing .

References-found: 15

