URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/castelluccia.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/program.html
Root-URL: 
Email: -claude.castelluccia, walid.dabbous-@inria.fr  sean@netapp.com  
Title: Generating Ecient Protocol Code from an Abstract Specitcation  
Author: Claude Castelluccia, Walid Dabbous Sean O'Malley 
Address: 2004, route des Lucioles BP 93, 06902 Sophia Antipolis, France  Appliance, 319 N. Bernardo, Moutain View, CA 94043, USA  
Affiliation: INRIA,  Network  
Abstract: A protocol compiler takes as input an abstract specitcation of a protocol and generates an implementation of that proto col. Protocol compilers usually produce inecient code both in terms of code speed and code size. In this paper, we show that the combination of two techniques makes it possible to build protocol compilers that generate ecient code. These techniques are i) the use of a compiler that generates from the specitcation a unique tree-shaped automaton (rather than multiple independent automata), and ii) the use of op timization techniques applied at the automaton level, i.e. on the branches of the trees. We have developed a protocol compiler that uses both these techniques. The compiler takes as input a protocol specitcation written in the synchronous language Esterel. The specitcation is compiled into a unique automaton by the Esterel front end compiler. The automaton is then opti mized and converted into C code by our protocol optimizer called HIPPCO. HIPPCO improves code performance 1 and reduces code size by simultaneously optimizing the perfor mance of the common path and optimizing the size of the uncommon path. We evaluate the gain expected with our approach on a real-life example, namely a working subset of the TCP protocol generated from an Esterel specitcation. We compare the protocol code generated with our approach to that derived from the standard BSD TCP implementa tion. The results are very encouraging. HIPPCO-generated code executes up to 25 % fewer instructions than the BSD code for input packet processing while maintaining compa rable code size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Berry and G. Gonthier. </author> <title> The Esterel synchronous program ming language: Design, semantic, implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <year> 1988. </year>
Reference-contexts: The overall architecture of this environment is presented in tgure 1 and detailed in the remainder of this section. 3.1 The Esterel Tool We have used Esterel as the specitcation language and au tomaton generator for our development environment. Es terel is an imperative synchronous language developed at INRIA <ref> [4, 1] </ref>. In this subsection, we justify this choice and present the main characteristics of this language.
Reference: [2] <author> Grard Berry. </author> <title> Real-time programming: Special purpose or general purpose languages. </title> <booktitle> In Information Processing IFIP Conference, </booktitle> <publisher> Elsevier Science Publishers, B.V. North Hol land, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: This environ ment has three parts, namely the specitcation language, the compiler for that language and the run time system. The source language in our development environment is the Esterel language <ref> [4, 2] </ref>. Esterel is a synchronous language that supports the abstract specitcation of protocol behav iors [6, 3]. The compiler for that language is composed of the combination of the Esterel front end compiler and of the HIPPCO tool.
Reference: [3] <author> Grard Berry and Georges Gonthier. </author> <title> Incremental develop ment of an HDLC protocol in esterel. </title> <type> Technical Report 1031, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: This environ ment has three parts, namely the specitcation language, the compiler for that language and the run time system. The source language in our development environment is the Esterel language [4, 2]. Esterel is a synchronous language that supports the abstract specitcation of protocol behav iors <ref> [6, 3] </ref>. The compiler for that language is composed of the combination of the Esterel front end compiler and of the HIPPCO tool. The Esterel front end compiles the modular specitcations into sequential and minimal automata.
Reference: [4] <author> Frdric Boussinot and Robert de Simone. </author> <title> The ESTEREL language. </title> <type> Technical Report 1487, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: This environ ment has three parts, namely the specitcation language, the compiler for that language and the run time system. The source language in our development environment is the Esterel language <ref> [4, 2] </ref>. Esterel is a synchronous language that supports the abstract specitcation of protocol behav iors [6, 3]. The compiler for that language is composed of the combination of the Esterel front end compiler and of the HIPPCO tool. <p> The overall architecture of this environment is presented in tgure 1 and detailed in the remainder of this section. 3.1 The Esterel Tool We have used Esterel as the specitcation language and au tomaton generator for our development environment. Es terel is an imperative synchronous language developed at INRIA <ref> [4, 1] </ref>. In this subsection, we justify this choice and present the main characteristics of this language.
Reference: [5] <author> L. Brakmo and L. Peterson. </author> <title> Performance problems in bsd4.4 tcp. </title> <journal> Computer Communication Review, </journal> <volume> (5):6986, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: TCP-Lite was shipped with a minor bug in its header prediction code. The code as shipped includes one case in its fast path which requires re-calculation of the congestion window which is not done in the fast path <ref> [5] </ref>. HIPPCO optimizations are general tree to tree translations which can easily be shown not to change the semantics of the overall program. It also needs to be driven home that a process intensive specitcation does not require a process intensive implemen tation.
Reference: [6] <author> C. Castelluccia, I. Chrisment, W. Dabbous, C. Diot, C. Huitema, E. Siegel, and R. De Simone. </author> <title> Tailored protocol development using esterel. </title> <type> Technical Report 2374, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> Octobre </month> <year> 1994. </year>
Reference-contexts: This environ ment has three parts, namely the specitcation language, the compiler for that language and the run time system. The source language in our development environment is the Esterel language [4, 2]. Esterel is a synchronous language that supports the abstract specitcation of protocol behav iors <ref> [6, 3] </ref>. The compiler for that language is composed of the combination of the Esterel front end compiler and of the HIPPCO tool. The Esterel front end compiles the modular specitcations into sequential and minimal automata.
Reference: [7] <author> Claude Castelluccia. </author> <title> Automating header prediction. </title> <booktitle> In Pro ceedings of the 1st Annual Workshop on Compiler Support For System Software, </booktitle> <address> Tucson, Arizona, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Increasing the execution speed of a proto col code is equivalent to decreasing the number of cycles required for its execution. This is a complex task because these cycles comes from dierent sources. The number of cycles required to execute the program is given by the fol lowing formula <ref> [19, 7] </ref>: Cycles total = IC fi CP I + m access fi miss rate fi miss pen where IC is the number of instructions executed, CP I the average number of cycles per instruction, m access the total number of memory accesses within the program, miss rate the rate of
Reference: [8] <author> Claude Castelluccia and Walid Dabbous. </author> <title> Modular commu nication subsystem implementation using a synchronous ap proach. </title> <booktitle> In Proceedings of the Usenix High-Speed Networking Symposium, </booktitle> <pages> pages 111, </pages> <address> Oakland, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: An example of an Esterel specitcation and of the derived automaton is presented in appendix A. This module origi nates from a prototype specitcation of a restricted version of the TCP protocol in Esterel <ref> [8] </ref>. It handles the management of the TCP retransmission timer. Notations We detne in this subsection the notations that are used in tgures 2, 3 and 5. A state-tree is composed of a collection of cascaded nodes.
Reference: [9] <author> Claude Castelluccia and Walid Dabbous. HIPPCO: </author> <title> an HIgh performance protocol code optimizer. </title> <type> Technical Report 2748, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: The compiler for that language is composed of the combination of the Esterel front end compiler and of the HIPPCO tool. The Esterel front end compiles the modular specitcations into sequential and minimal automata. These automata are then optimized and converted into ecient C implementations by HIPPCO 2 <ref> [9] </ref>, the protocol code opti mizer we have developed. C is used as the target language for HIPPCO for portability reasons.
Reference: [10] <author> Claude Castelluccia and Phillip Hoschka. </author> <title> A compiler-based approach to protocol optimization. </title> <editor> In S.-P. Chang, editor, </editor> <booktitle> Proceeding of the High Performance Communication Subsys tem Workshop, </booktitle> <address> Mistic, Connecticut, USA, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Therefore, the common path can be identited from the probabilities of the transitions [31]. In HIPPCO, these probabilities are computed by a Markov analysis <ref> [10] </ref> of the automaton. The transitions of a state are detned by the dierent paths that an input can follow through the tree of this state. They are therefore detned by an input and the se quence of tests (and their results) that lead to the leaf node. <p> Thus: P (T 1;2 ) = P (S 1 ) fi P (pack) fi P (:(size &gt; T )) fi P (check)) In <ref> [10] </ref>, we have shown that the visit counts V j of the state S j can be computed by solving the following system of n linear equations (where n is the number of states): V j = ffi 1j + k=1 k;j where ffi ij = 1 for i = j,
Reference: [11] <author> P. Chang, S. Mahlke, and W. Hwu. </author> <title> Using protle information to assist classic code optimizations. </title> <journal> Software-Practice and Experience, </journal> <volume> 21(12):13011321, </volume> <year> 1991. </year>
Reference-contexts: One of our contributions is to apply these optimizations in the context of a protocol compiler and to automate the application of these techniques. In the teld of compiler optimizations, the problem of re structuring programs to improve program performance has been studied by numerous researchers. In <ref> [25, 11, 29] </ref>, pro tling data is used to guide the positioning of basic blocks and functions in order to increase the performance of the instruction cache. The optimizations in this paper are di rectly inspired by this work. However our approach diers in several aspects. <p> The optimizations in this paper are di rectly inspired by this work. However our approach diers in several aspects. First, the tree structure of our code, without loop and jump, considerably simplites the analysis of the code and the design of the optimizations. As shown in <ref> [25, 11, 29] </ref>, the graph structure of traditional programs re quires manipulation of the program basic blocks to optimize the performance of the code. With our tree structure, the same results can be achieved at a higher level just by mov ing around branches and subtrees.
Reference: [12] <author> D. Clark, V. Jacobson, J. Romkey, and M. Salwen. </author> <title> An anal ysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6):2329, </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: This is similar to the approach adopted in <ref> [12] </ref>. A specitc detail concern ing IC should be taken into account: let I c be the average number of instructions executed to process an input packet, 5 We measure the miss rate as if the protocol was running alone.
Reference: [13] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceed ings of the ACM Symposium on Communications Architec tures and Protocols, pages 200208, </booktitle> <address> Philadelphia, Pennsyl vania, </address> <month> September </month> <year> 1990. </year> <journal> IEEE. Computer Communications Review, </journal> <volume> Vol. 20(4), </volume> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: As the performance bottleneck has been shifted to the mem ory system <ref> [13, 18, 17] </ref>, the second two forms of optimization have gained in importance. HIPPCO uses those three types of optimizations.
Reference: [14] <author> K. D. Cooper, M. W. Hall, and L. Torczon. </author> <title> An experiment with inline substitution. </title> <journal> Software-Practice and Experience, </journal> <pages> pages 581601, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Second, by removing the function boundary, more ecient optimizations can be performed by the low-level compiler. The penalty for inlining is a code size increase which may adversely eect the instruction cache hit rate and slow down program execution speed <ref> [14, 16, 27, 21] </ref>.
Reference: [15] <author> Jon Crowcroft, Ian Wakeman, Zheng Wang, and Dejan Sirovica. </author> <title> Layering considered harmful. </title> <journal> IEEE Network Mag azine, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Furthermore, this architecture increases the poten tial of compiler optimizations by eliminating all traces of module boundaries and hence enabling nearly unlimited in ter-procedural optimization <ref> [26, 15] </ref>. Synchronous languages are used to implement the con trol portion of a program. The computational and data ma nipulation parts are performed by functions implemented in another language (C for example).
Reference: [16] <author> Jack W. Davidson and Anne M. Holler. Subprogram inlin ing: </author> <title> A study of a c function inliner. </title> <journal> Software-Practice and Experience, </journal> <volume> 18:775790, </volume> <year> 1988. </year>
Reference-contexts: Second, by removing the function boundary, more ecient optimizations can be performed by the low-level compiler. The penalty for inlining is a code size increase which may adversely eect the instruction cache hit rate and slow down program execution speed <ref> [14, 16, 27, 21] </ref>.
Reference: [17] <author> David C. Feldmeier. </author> <title> A survey of high performance proto col implementation techniques. </title> <type> Technical report, </type> <institution> Bellcore, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: As the performance bottleneck has been shifted to the mem ory system <ref> [13, 18, 17] </ref>, the second two forms of optimization have gained in importance. HIPPCO uses those three types of optimizations.
Reference: [18] <author> Per Gunningberg, Craig Partridge, Teet Sirotkin, and Bjorn Victor. </author> <title> Delayed evaluation of gigabit protocols. </title> <booktitle> In Proceed ings of the Second MultiG Workshop, </booktitle> <address> Stockholm, Sweden, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: As the performance bottleneck has been shifted to the mem ory system <ref> [13, 18, 17] </ref>, the second two forms of optimization have gained in importance. HIPPCO uses those three types of optimizations.
Reference: [19] <author> J. L. Hennesy and D. D. Patterson. </author> <booktitle> Computer Architecture: </booktitle>
Reference-contexts: Increasing the execution speed of a proto col code is equivalent to decreasing the number of cycles required for its execution. This is a complex task because these cycles comes from dierent sources. The number of cycles required to execute the program is given by the fol lowing formula <ref> [19, 7] </ref>: Cycles total = IC fi CP I + m access fi miss rate fi miss pen where IC is the number of instructions executed, CP I the average number of cycles per instruction, m access the total number of memory accesses within the program, miss rate the rate of
References-found: 19

