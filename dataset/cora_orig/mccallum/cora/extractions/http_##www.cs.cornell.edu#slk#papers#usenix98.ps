URL: http://www.cs.cornell.edu/slk/papers/usenix98.ps
Refering-URL: 
Root-URL: 
Title: Implementing Multiple Protection Domains in Java  
Author: Chris Hawblitzel, ChiChao Chang, Grzegorz Czajkowski, Deyu Hu, and Thorsten von Eicken 
Affiliation: Department of Computer Science Cornell University  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Balfanz, D. and Gong, L. </author> <title> Experience with Secure MultiProcessing in Java. </title> <type> Technical Report 560-97, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> September, </month> <year> 1997. </year>
Reference-contexts: JDK 1.2 "protection domains" are implicitly created based on the origin of the code, and on its signature. This definition of a protection domain is closer to a user in Unix, while the J-Kernel's protection domain is more like a process in Unix. Balfanz et al. <ref> [1] </ref> define an extension to the JDK which associates domains with users running particular code, so that a domain becomes more like a process. However, if domains are able to share objects directly, revocation, resource management, and domain termination still need to be addressed in the JDK.
Reference: 2. <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p.267-284, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: All three of these systems allow non-capability objects to be passed directly between domains, and generally correspond to the share anything approach described in Section 2. They do not address the issues of revocation, domain termination, thread protection, or resource accounting. The SPIN project <ref> [2] </ref> allows safe Modula-3 code to be downloaded into the operating system kernel to extend the kernels functionality. SPIN has a particularly nice model of dynamic linking [39] to control the namespace of different extensions.
Reference: 3. <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <booktitle> 12 th ACM Symposium on Operating Systems Principles, p. </booktitle> <pages> 102-113, </pages> <address> Lichtfield Park, AZ, </address> <month> December </month> <year> 1989. </year> <title> System Operation Platform m s L4 Round-trip IPC P5-133 1.82 Exokernel Protected control transfer (r/t) DEC-5000 2.40 Eros Round-trip IPC P5-120 4.90 J-Kernel Method invocation with 3 args P5-133 3.77 Table 6. Comparison with selected kernels. </title>
Reference: 4. <author> R. S. Boyer, and Y. Yu. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <editor> J. </editor> <booktitle> ACM 43(1), p. </booktitle> <pages> 166-192, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: While, in theory, it is possible to prove that certain pieces of code only modify a restricted set of memory locations, in practice this is very difficult for languages like C and arbitrary assembly language <ref> [4, 30] </ref>, and cannot be fully automated. In contrast, the type system and the linker in a safe language restrict what operations a particular piece of code is allowed to perform on which memory locations.
Reference: 5. <author> J. Chase, H. Levy, E. Lazowska, and M. Baker-Harvey. </author> <title> Lightweight Shared Objects in a 64-Bit Operating System. </title> <booktitle> ACM ObjectOriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Single-address operating systems, like Opal <ref> [5] </ref> and Mungi [15], remove the address space borders, allowing for cheaper and easy sharing of data between processes. Opal and Mungi were implemented on architectures offering large address spaces (64-bit) and used password capabilities as the protection mechanism.
Reference: 6. <author> S. Drossopoulou, S. Eisenbach. </author> <title> Java is Type Safe Probably. </title> <booktitle> 11 th European Conference on ObjectOriented Programming, </booktitle> <address> Jyvskyl, Finland, </address> <month> June </month> <year> 1997. </year>
Reference: 7. <institution> Electric Communities. </institution> <address> The E White Paper. http://www.communities.com/products/tools/e. </address>
Reference-contexts: Wallach et. al. [41] describe three models of Java security: type hiding (making use of dynamic class loading to control a domains namespace), stack introspection, and capabilities. They recommended a mix of these three techniques. The E language from Electric Communities <ref> [7] </ref> is an extension of Java targeted towards distributed systems. Es security architecture is capability based; programmers are encouraged to use object references as the fundamental building block for protection. Odyssey [9] is a system that supports mobile agents written in Java; agents may share Java objects directly.
Reference: 8. <author> R. Engler, M. Kaashoek, and J. James OToole. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 251266, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The systems are carefully tuned and aggressively exploit features of the underlying hardware. The L4 m-kernel [14] rigorously aims for minimality and is designed from scratch, unlike first-generation m-kernels, which evolved from monolithic OS kernels. The system was successful at dispelling some common misconceptions about m-kernel performance limitations. Exokernel <ref> [8] </ref> shares L4s goal of being an ultrafast minimalist kernel, but is also concerned with untrusted loadable modules (similar to the SPIN project). Untrusted code is given efficient control over hardware resources by separating management from protection.
Reference: 9. <institution> General Magic. Odyssey. </institution> <note> http://www.genmagic.com/agents. </note>
Reference-contexts: They recommended a mix of these three techniques. The E language from Electric Communities [7] is an extension of Java targeted towards distributed systems. Es security architecture is capability based; programmers are encouraged to use object references as the fundamental building block for protection. Odyssey <ref> [9] </ref> is a system that supports mobile agents written in Java; agents may share Java objects directly. Hagimont et al. [13] describe a system to support capabilities defined with special IDL files.
Reference: 10. <author> L. Gong. </author> <title> Java Security: Present and Near Future. </title> <journal> IEEE Micro, </journal> <volume> 17(3), </volume> <editor> p. </editor> <volume> 1419, </volume> <month> May/June </month> <year> 1997. </year>
Reference: 11. <author> Gong, L. and Schemers, R. </author> <title> Implementing Protection Domains in the Java Development Kit 1.2. Internet Society Symposium on Network and Distributed System Security, </title> <address> San Diego, CA, </address> <month> March </month> <year> 1998. </year>
Reference-contexts: For instance, Suns JDK 1.1 added a notion of authentication, based on code signing, while the JDK 1.2 adds a richer structure for authorization, including classes that represent permissions and methods that perform access control checks based on stack introspection <ref> [11] </ref>. JDK 1.2 "protection domains" are implicitly created based on the origin of the code, and on its signature. This definition of a protection domain is closer to a user in Unix, while the J-Kernel's protection domain is more like a process in Unix. <p> However, only system classes may be shared between domains that have different class loaders, which limits the expressiveness of communication between domains. In contrast, the J-Kernel allows domains to share classes without requiring these domains to use the same class loader. In the future work section, Gong et al. <ref> [11] </ref> mentions separating current system classes (such as file classes) into separate domains, in accordance with the principle of least privilege. The J-Kernel already moves facilities LRMI w/ Serial.
Reference: 12. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java language specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java <ref> [12] </ref>, Modula-3 [32], and CAML [22] use type safety and controlled linking to enforce protection between multiple components without relying on hardware support.
Reference: 13. <author> D. Hagimont, and L. Ismail. </author> <title> A Protection Scheme for Mobile Agents on Java. </title> <booktitle> 3 rd Annual ACM/IEEE Intl Conference on Mobile Computing and Networking, </booktitle> <address> Budapest, Hungary, </address> <month> September 2630, </month> <year> 1997. </year>
Reference-contexts: Es security architecture is capability based; programmers are encouraged to use object references as the fundamental building block for protection. Odyssey [9] is a system that supports mobile agents written in Java; agents may share Java objects directly. Hagimont et al. <ref> [13] </ref> describe a system to support capabilities defined with special IDL files. All three of these systems allow non-capability objects to be passed directly between domains, and generally correspond to the share anything approach described in Section 2.
Reference: 14. <editor> H. Hrtig, et. al. </editor> <booktitle> The Performance of m-Kernel-Based Systems. 16 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 6677, Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Several research operating systems support very fast inter-process communication. Recent projects, like L4, Exokernel, and Eros, provide fine-tuned implementations of selected IPC mechanisms, yielding an order of magnitude improvement over traditional operating systems. The systems are carefully tuned and aggressively exploit features of the underlying hardware. The L4 m-kernel <ref> [14] </ref> rigorously aims for minimality and is designed from scratch, unlike first-generation m-kernels, which evolved from monolithic OS kernels. The system was successful at dispelling some common misconceptions about m-kernel performance limitations.
Reference: 15. <author> G. Heiser, et. al. </author> <title> Implementation and Performance of the Mungi Single-Address-Space Operating System. </title> <type> Technical Report UNSW-CSE-TR-9704, </type> <institution> Univeristy of New South Wales, </institution> <address> Sydney, Australia, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Single-address operating systems, like Opal [5] and Mungi <ref> [15] </ref>, remove the address space borders, allowing for cheaper and easy sharing of data between processes. Opal and Mungi were implemented on architectures offering large address spaces (64-bit) and used password capabilities as the protection mechanism. Password capabilities are protected from forgery by a combination of encryption and sparsity.
Reference: 16. <author> JavaSoft. </author> <title> JavaBeans, </title> <note> Version 1.01 Specification. http://java.sun.com. </note>
Reference-contexts: Most web servers support plug-ins as well and in this case, the robustness issue is even more importanta browser crash may be annoying, but a server crash can be disastrous. The robustness versus performance tradeoff is pervasive in component software (e.g., OLE, JavaBeans <ref> [16] </ref>, ActiveX, OpenDoc). Microsofts COM [27], for example, provides two different models for composing components: each component can run in its own process for protection, or multiple components can share a process (often termed in-proc) for performance.
Reference: 17. <author> JavaSoft. </author> <title> Remote Method Invocation Specification. </title> <address> http://java.sun.com. </address>
Reference-contexts: Other classes that provide corresponding implementations can then be declared to implement the interface. Normally interface classes are used to provide a limited form of multiple inheritance (properly called interface inheritance) in that a class can implement multiple interfaces. In addition, Suns remote method invocation (RMI) specification <ref> [17] </ref> pioneered the use of interfaces as compiler annotations. Instead of using a separate interface definition language (IDL), the RMI specification simply uses interface classes that are flagged to the RMI system in that they extend the class Remote. <p> This avoids offline stub generators and IDL files, and it allows the J-Kernel to specialize the stubs to invoke the target methods with minimal overhead. Besides switching domains, stubs have three roles: copying arguments, supporting revocation, and protecting threads. By default, the J-Kernel uses Javas built-in serialization features <ref> [17] </ref> to copy an argument: the J-Kernel serializes an argument into an array of bytes, and then deserializes the byte array to produce a fresh copy of the argument. While this is convenient because many built-in Java classes are serializable, it involves a substantial overhead.
Reference: 18. <author> JavaSoft. </author> <title> New Security Model for JDK1.2. </title> <address> http://java.sun.com </address>
Reference-contexts: At the time of this writing the implementation of JWS as an IIS plug-in with JIT was not fully functional. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [18, 33, 28] </ref>. For instance, Suns JDK 1.1 added a notion of authentication, based on code signing, while the JDK 1.2 adds a richer structure for authorization, including classes that represent permissions and methods that perform access control checks based on stack introspection [11].
Reference: 19. <author> JavaSoft. </author> <title> Java Servlet API. </title> <address> http://java.sun.com. </address>
Reference-contexts: The goal is to allow users to dynamically extend the functionality of the server by uploading Java programs, called servlets <ref> [19] </ref>, that customize the HTTP request processing for a subset of the servers URL space. Instead of building (or porting) an entire HTTP server in Java, we integrated the J-Kernel into the off-the-shelf Microsoft server (IIS 3.0).
Reference: 20. <author> JavaSoft. JavaServer Documentation. </author> <note> http://java.sun.com </note>
Reference-contexts: Server throughput measurements To quantify the impact of the J-Kernel overheads in the performance of the HTTP server, several simple experiments measure the number of documents per second that can be served by Microsofts IIS, Suns Java Web Server 1.0.2 (JWS) <ref> [20] </ref>, and J-Kernel running inside IIS. The hardware platform consists of a quad-processor 200MHz Pentium-Pro (results obtained on one and two-processor machines are similar). The parameter of the experiments is the size of document being served.
Reference: 21. <author> A. K. Jones and W. A. Wulf. </author> <title> Towards the Design of Secure Systems. </title> <journal> Software Practice and Experience, </journal> <volume> Volume 5, Number 4, </volume> <editor> p. </editor> <volume> 321336, </volume> <year> 1975. </year>
Reference-contexts: Using Java as the basis for the J-Kernel simplifies many of the issues that plagued traditional capability systems. First, unlike systems based on capability lists, the J-Kernel can store capabilities in data structures, because capabilities are implemented as Java objects. Second, rights amplification <ref> [21] </ref> is implicit in the objectoriented nature of Java: invocations are made on methods, rather than functions, and methods automatically acquire rights to their self parameter. In addition, selective class sharing can be used to amplify other parameters.
Reference: 22. <author> X. Leroy. </author> <title> Objective Caml. </title> <address> http://pauillac.inria.fr/ocaml/. </address>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java [12], Modula-3 [32], and CAML <ref> [22] </ref> use type safety and controlled linking to enforce protection between multiple components without relying on hardware support. In a safe language environment, calls across protection boundaries could potentially be as cheap as simple function calls, enabling as much communication between components as desired without performance drawbacks.
Reference: 23. <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference: 24. <editor> J. Liedtke. </editor> <booktitle> 2Qfl NHUQHOfl &RQVWUXFWLRQfl 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 237250, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference: 25. <editor> J. Liedtke, et. al. </editor> <booktitle> Achieved IPC Performance. 6 th Workshop on Hot Topics in Operating Systems, </booktitle> <address> Chatham, MA, </address> <month> May. </month>
Reference: 26. <author> T. Lindholm, and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference: 27. <author> Microsoft Corporation and Digital Equipment Corporaton. </author> <title> The Component Object Model Specification. </title> <address> Redmond, WA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Most web servers support plug-ins as well and in this case, the robustness issue is even more importanta browser crash may be annoying, but a server crash can be disastrous. The robustness versus performance tradeoff is pervasive in component software (e.g., OLE, JavaBeans [16], ActiveX, OpenDoc). Microsofts COM <ref> [27] </ref>, for example, provides two different models for composing components: each component can run in its own process for protection, or multiple components can share a process (often termed in-proc) for performance.
Reference: 28. <institution> Microsoft Corporation. Microsoft Security Management Architecture White Paper. http://www.microsoft.com/ie/ security. </institution>
Reference-contexts: At the time of this writing the implementation of JWS as an IIS plug-in with JIT was not fully functional. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [18, 33, 28] </ref>. For instance, Suns JDK 1.1 added a notion of authentication, based on code signing, while the JDK 1.2 adds a richer structure for authorization, including classes that represent permissions and methods that perform access control checks based on stack introspection [11].
Reference: 29. <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to Typed Assembly Language. </title> <booktitle> 25 th ACM Symposium on Principles of Programming Languages. </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: Since it uses Modula-3 pointers directly as capabilities, the limitations of the share anything approach apply to it. Several recent software-based protection techniques do not rely on a particular high level language like Java or Modula-3. Typed assembly language <ref> [29] </ref> pushes type safety down to the assembly language level, so that code written at the assembly language level can be statically type checked and verified as safe.
Reference: 30. <author> G. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without RunTime Checking. </title> <booktitle> 2 nd USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <address> p. 229243, Seattle, WA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: While, in theory, it is possible to prove that certain pieces of code only modify a restricted set of memory locations, in practice this is very difficult for languages like C and arbitrary assembly language <ref> [4, 30] </ref>, and cannot be fully automated. In contrast, the type system and the linker in a safe language restrict what operations a particular piece of code is allowed to perform on which memory locations. <p> With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures. However, it is not clear how to extend optimized sandboxing techniques to CISC architectures, and sandboxing cannot enforce protection at as fine a granularity as a type system. Proof carrying code <ref> [30, 31] </ref> generalizes many different approaches to software protection arbitrary binary code can be executed as long as it comes with a proof that it is safe.
Reference: 31. <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> 24 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> p. 106119, Paris, </address> <year> 1997. </year>
Reference-contexts: With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures. However, it is not clear how to extend optimized sandboxing techniques to CISC architectures, and sandboxing cannot enforce protection at as fine a granularity as a type system. Proof carrying code <ref> [30, 31] </ref> generalizes many different approaches to software protection arbitrary binary code can be executed as long as it comes with a proof that it is safe.
Reference: 32. <author> G. Nelson, ed. </author> <title> System Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java [12], Modula-3 <ref> [32] </ref>, and CAML [22] use type safety and controlled linking to enforce protection between multiple components without relying on hardware support. In a safe language environment, calls across protection boundaries could potentially be as cheap as simple function calls, enabling as much communication between components as desired without performance drawbacks.
Reference: 33. <author> Netscape Corporation. </author> <title> Java Capabilities API. </title> <address> http://www.netscape.com. </address>
Reference-contexts: At the time of this writing the implementation of JWS as an IIS plug-in with JIT was not fully functional. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [18, 33, 28] </ref>. For instance, Suns JDK 1.1 added a notion of authentication, based on code signing, while the JDK 1.2 adds a richer structure for authorization, including classes that represent permissions and methods that perform access control checks based on stack introspection [11].
Reference: 34. <author> Rashid, R. </author> <title> Threads of a New System. Unix Review, </title> <editor> p. </editor> <volume> 3749, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Java libraries installed as system classes often have undocumented and unpredictable dependencies on one another 3 . Richard Rashid warned that the UNIX kernel had become a dumping ground for every new feature or facility <ref> [34] </ref>; it seems that the Java system classes are becoming a similar dumping ground. 3.2 J-Kernel MicroBenchmarks To evaluate the performance of the J-Kernel mechanisms we measured a number of microbenchmarks on the J-Kernel as well as on a number of reference systems.
Reference: 35. <author> D. D. Redell. </author> <title> Naming and Protection in Extendible Operating Systems. </title> <type> Technical Report 140, </type> <institution> Project MAC, MIT 1974. </institution>
Reference-contexts: In addition, selective class sharing can be used to amplify other parameters. Although many capability systems did not support revocation, the idea of using indirection to implement revocation goes back to Redell <ref> [35] </ref>. The problems with resource accounting were also on the minds of implementers of capability systemsWulf et. al. [42] point out that No one owns an object in the Hydra scheme of things; thus its very hard to know to whom the cost of maintaining it should be charged.
Reference: 36. <author> V. Saraswat. </author> <title> Java is not typesafe. </title> <note> at http://www.research.att.com/~vj/bug.html. </note>
Reference: 37. <author> Z. Shao. </author> <title> Typed Common Intermediate Format. </title> <booktitle> 1997 USENIX Conference on DomainSpecific Languages, </booktitle> <address> Santa Barbara, California, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation [40] and verification of assembly language [29,30,31] may someday offer solutions, but are still an active area of research <ref> [37] </ref>. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. 2 Language-based protection background In an unsafe language, any code running in an address space can potentially modify any memory location in that address space.
Reference: 38. <author> J. S. Shapiro, D. J. Farber, and J. M. Smith. </author> <title> The Measured Performance of a Fast Local IPC. </title> <booktitle> 5 th Intl Workshop on ObjectOrientation in Operating Systems, </booktitle> <address> Seattle, WA. </address> <year> 1996 </year>
Reference-contexts: Exokernel [8] shares L4s goal of being an ultrafast minimalist kernel, but is also concerned with untrusted loadable modules (similar to the SPIN project). Untrusted code is given efficient control over hardware resources by separating management from protection. The focus of the EROS <ref> [38] </ref> project is to support orthogonal persistence and real-time computations. Despite quite different objectives, all three systems manage to provide very fast implementations of IPC with comparable performance, as shown in Table 6. A short explanation of the operation column is needed.
Reference: 39. <author> E. G. Sirer, M. Fiuczynski, and P. Pardyak. </author> <title> Writing an Operating System with Modula-3. </title> <booktitle> First Workshop on Compiler Support for System Software, </booktitle> <address> Tucson, AZ, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: They do not address the issues of revocation, domain termination, thread protection, or resource accounting. The SPIN project [2] allows safe Modula-3 code to be downloaded into the operating system kernel to extend the kernels functionality. SPIN has a particularly nice model of dynamic linking <ref> [39] </ref> to control the namespace of different extensions. Since it uses Modula-3 pointers directly as capabilities, the limitations of the share anything approach apply to it. Several recent software-based protection techniques do not rely on a particular high level language like Java or Modula-3.
Reference: 40. <author> R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> 14 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 203216, Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation <ref> [40] </ref> and verification of assembly language [29,30,31] may someday offer solutions, but are still an active area of research [37]. Section 4 describes an extensible web server based on the J-Kernel. <p> Typed assembly language [29] pushes type safety down to the assembly language level, so that code written at the assembly language level can be statically type checked and verified as safe. Software fault isolation <ref> [40] </ref> inserts runtime sandboxing checks into binary executables to restrict the range of memory that is accessible to the code. With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures.
Reference: 41. <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible Security Architectures for Java. </title> <booktitle> 16 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 116128, Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: domains that share a class must also share other classes referenced by that class. compatibility with the standard Java file API, we have also written alternate versions of Java's standard file classes, which are just stubs that make the necessary cross-domain calls. (This is similar to the interposition proposed by <ref> [41] </ref>). The J-Kernel moves functionality out of the system classes and into domains for the same reasons that micro-kernels move functionality out of the operating system kernel. <p> HTTP server throughput in pages/second for files and networking out of the system classes and into separate domains. A number of related safe-language systems are based on the idea of using object references as capabilities. Wallach et. al. <ref> [41] </ref> describe three models of Java security: type hiding (making use of dynamic class loading to control a domains namespace), stack introspection, and capabilities. They recommended a mix of these three techniques. The E language from Electric Communities [7] is an extension of Java targeted towards distributed systems.
Reference: 42. <author> W. A. Wulf, R. Levin, and S.P. Harbison, Hydra/C. </author> <title> mmp: An Experimental Computer System, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1981. </year>
Reference-contexts: Although many capability systems did not support revocation, the idea of using indirection to implement revocation goes back to Redell [35]. The problems with resource accounting were also on the minds of implementers of capability systemsWulf et. al. <ref> [42] </ref> point out that No one owns an object in the Hydra scheme of things; thus its very hard to know to whom the cost of maintaining it should be charged.
References-found: 42

