URL: http://cs.nyu.edu/cs/faculty/paige/papers/viewing.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Email: paige@cs.nyu.edu  
Title: Viewing A Program Transformation System At Work  
Author: Robert Paige 
Address: 251 Mercer St., New York, NY 10012, USA  
Affiliation: Computer Science Department, New York University/Courant Institute  
Abstract: How to decrease labor and improve reliability in the development of efficient implementations of nonnumerical algorithms and labor intensive software is an increasingly important problem as the demand for computer technology shifts from easier applications to more complex algorithmic ones; e.g., optimizing compilers for supercomputers, intricate data structures to implement efficient solutions to operations research problems, search and analysis algorithms in genetic engineering, complex software tools for workstations, design automation, etc. It is also a difficult problem that is not solved by current CASE tools and software management disciplines, which are oriented towards data processing and other applications, where the implementation and a prediction of its resource utilization follow more directly from the specification. Recently, Cai and Paige reported experiments suggesting a way to implement nonnumerical algorithms in C at a programming rate (i.e., source lines per second) that is at least five times greater than a conventional approach in which C programs are written entirely by hand [12]. The runtime performance of the C programs produced by this new approach was shown to be comparable to good hand code. The proposed software development methodology makes use of fully automatic, generic program transformations that capture algorithm design principles. This paper discusses some of the ideas underlying the transformational methodology, and illustrates these ideas through explanatory examples of the APTS system at work.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho and J. Ullman. </author> <title> Universality Of Data Retrieval Languages. </title> <booktitle> In Proc. ACM 6th POPL, </booktitle> <pages> pages 110-117, </pages> <month> Jan, </month> <year> 1979. </year>
Reference-contexts: Morris at Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman <ref> [1] </ref>, Selinger [55], Banchilhon [2], Ramakrishnan [3], and Willard [63,64]). One key contribution of our work has been to provide a priori algebraic and syntactic reasoning about the program speedup that would result from applying transformations (see [10,44,15,17].
Reference: [2] <author> F. Bancilhon. </author> <title> Naive Evaluation of Recursively defined Relations. On Knowledge-Base Management Systems, N, </title> <editor> Brodie and H, Mylopoulos, </editor> <booktitle> editors, </booktitle> <pages> pages 165-178, </pages> <year> 1986. </year>
Reference-contexts: [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon <ref> [2] </ref>, Ramakrishnan [3], and Willard [63,64]). One key contribution of our work has been to provide a priori algebraic and syntactic reasoning about the program speedup that would result from applying transformations (see [10,44,15,17].
Reference: [3] <author> F. Bancilhon, and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query-processing strategies. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 16-52, </pages> <year> 1986. </year>
Reference-contexts: and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon [2], Ramakrishnan <ref> [3] </ref>, and Willard [63,64]). One key contribution of our work has been to provide a priori algebraic and syntactic reasoning about the program speedup that would result from applying transformations (see [10,44,15,17].
Reference: [4] <author> D. Barstow. </author> <title> Knowledge-Based Program Construction, </title> <publisher> Elsevier North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: set for a property, and of fixed points have concerned the programming language and database communities for over twenty years (e.g., included within the programming language community are Jay Earley at UC Berkeley [24,25,26], Jim Morris at Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow <ref> [4] </ref> and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon [2], Ramakrishnan [3], and Willard [63,64]).
Reference: [5] <author> R. Bayer. </author> <title> Query evaluation and recursion in deductive database system. </title> <type> unpublished manuscript, </type> <year> 1985. </year>
Reference: [6] <author> C. Beeri and P. Bernstein. </author> <title> Computational Problems Related to the Design of Normal Form Relation Schemes. </title> <journal> ACM TODS, </journal> <volume> 4:(1):30-59, </volume> <year> 1979. </year>
Reference-contexts: Bernstein and Beeri <ref> [6] </ref> and Dowling and Gallier [23] independently solved this problem with the same asymptotic complexity as our compiled C program, and all three solutions use the power of address arithmetic to directly access arrays.
Reference: [7] <author> R. Bird. </author> <title> An introduction to the theory of lists. in Logic Programming and Calculi of Discrete Design, </title> <editor> M. Broy ed., </editor> <booktitle> pp. </booktitle> <pages> 5-42, </pages> <booktitle> NATO ASI Series F, </booktitle> <volume> Vol 3, 6, </volume> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird <ref> [7] </ref> and Meertens [39]. Smith has also used program transformations in algorithm design [57]. A major benefit of algorithm design by transformation is that it produces an actual program along with an algorithm. Consequently, we can conduct experimental benchmarks to obtain computational results that complement the theoretical improvements.
Reference: [8] <author> B. Bloom and R. Paige. </author> <title> Computing Ready Simulations Efficiently. </title> <booktitle> In Proc. First North American Process Algebra Workshop, </booktitle> <editor> A. Zwarico and S. Purushothaman, editors, </editor> <booktitle> Workshops in Computer Science Series, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 119 - 134, </pages> <year> 1992. </year> <month> 15 </month>
Reference-contexts: The methodology has been used to invent new algorithms for propositional Horn Clause Satisfiability on a sequential pointer machine [48], transformation from regular expressions to DFA's [18], and ready simulation <ref> [8] </ref>. We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39]. Smith has also used program transformations in algorithm design [57].
Reference: [9] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, B. Lang, and V. Pascual. </author> <title> Centaur: the system. </title> <booktitle> Proc. ACM SIGSOFT/SIGPLAN Software Eng. Symp. on Pracical Software Dev. Environments, </booktitle> <pages> pp. 14-24, </pages> <year> 1989. </year>
Reference-contexts: Other transformational systems currently in use with capabilities similar to APTS are Refine [50], KIDS [56] (which is built on top of Refine), Centaur <ref> [9] </ref>, and ASF+SDF [36]. The most pressing and perhaps most difficult open problem in APTS system research is in devising a scheme to maintain the consistency of PDB relations incrementally in the presence of conditional rewriting.
Reference: [10] <author> J. Cai and R. Paige. </author> <title> Binding Performance at Language Design Time. </title> <booktitle> In Proc. ACM POPL, </booktitle> <pages> pages 85 - 97, </pages> <month> Jan, </month> <year> 1987. </year>
Reference-contexts: Consequently, it can be shown that the attribute closure specification given in the transcript resides within a variant of the linear time language described in <ref> [10] </ref>. The transcript begins just below with a directive to startup the APTS system running under UNIX. The SETL2 runtime interpreter `stlx' is invoked with the SETL2 program `apts', which resides in the SETL2 executable module library.
Reference: [11] <author> J. Cai and R. Paige. </author> <title> Look Ma, No Hashing, And No Arrays Neither. </title> <booktitle> In Proc. ACM POPL, </booktitle> <pages> pages 143 - 154, </pages> <month> Jan, </month> <year> 1991. </year>
Reference: [12] <author> J. Cai and R. Paige. </author> <title> Towards Increased Productivity of Algorithm Implementation. </title> <booktitle> In Proc. ACM SIGSOFT, </booktitle> <pages> pages 71 - 78, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: These domains are the kernels of data structure aggregates supporting the real-time simulation of set theoretic primitive operations. The preceding translators were used in productivity studies, and the results were highly encouraging and surprising <ref> [12] </ref>. These results suggest that our approach can achieve at least a five-fold improvement in programming productivity of nonnumerical algorithm implementation (compared with conventional hand-crafted programming) without sacrificing more than 50% in run-time performance. <p> It is annotated by hand to indicate the corresponding SETL2 code that is translated. A copy of the full transcript will be passed out separately at the conference. The transcript ends with the compilation and execution of the C program. As was reported in <ref> [12] </ref>, it runs 30 times faster than the SETL2 program running under Snyder's `stlx' interpreter. Based on Snyder's and our experiments, this indicates performance comparable to good hand coded C.
Reference: [13] <author> J. Cai and R. Paige. </author> <title> Program Derivation by Fixed Point Computation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 197-261, </pages> <year> 1988/89. </year>
Reference-contexts: The first transformation makes use of a dominated convergence argument to compute least and greatest fixed point operations efficiently <ref> [13] </ref>. The second transformation, finite differencing, uses a syntactic characterization of the amortized complexity to maintain and exploit program invariants [43,10] in order to turn costly repeated calculations into more efficient incremental counterparts. <p> One of these compilers translates a major fragment of SETL2 into C. The other translates SQ2+ <ref> [13] </ref> (a strongly typed functional subset of SETL2 augmented with fixed point expressions) into C. Our SQ2+ and SETL2-to-C compilers are written in about 10,000 lines of RSL.
Reference: [14] <author> J. Cai. </author> <title> A Language for Semantic Analysis. </title> <type> Technical Report 635, </type> <institution> Courant Institute/New York University, </institution> <year> 1993. </year>
Reference-contexts: Consequently, the PDB must be updated to be consistent with the new program and the RDB. The inference and transformation engines make use of the efficient bottom up pattern matching algorithm of Cai, Paige, and Tarjan [16]. The inference engine used to calculate RDB relations <ref> [14] </ref> combines this bottom up pattern matcher with RETE style pattern matching [28] and seminaive evaluation of Datalog [5,2,61]. Other transformational systems currently in use with capabilities similar to APTS are Refine [50], KIDS [56] (which is built on top of Refine), Centaur [9], and ASF+SDF [36]. <p> More details about the inference rules and how they are implemented in APTS can be found in <ref> [14] </ref>. The conditional rewriting transformation `nminfp' can turn the functional attribute closure specification above into a simple imperative program that computes the conditional least fixed point by dominated convergence.
Reference: [15] <author> J. Cai, P. Facon, F. Henglein, R. Paige, and E. Schonberg. </author> <title> Type Transformation and Data Structure Choice. In Constructing Programs From Specifications, </title> <editor> B. Moeller editor, </editor> <publisher> North-Holland, </publisher> <pages> pages 126 - 124, </pages> <year> 1991. </year>
Reference-contexts: Our SQ2+ and SETL2-to-C compilers are written in about 10,000 lines of RSL. Perhaps the most interesting aspect of these compilers is the subtype inference method used to implement data structure selection based on the real-time simulation of an abstract set machine on a RAM <ref> [15] </ref>. The subtype inference algorithm was shown to be based on a logic in which all type variables represent unique finite minimal domains that could be computed efficiently. These domains are the kernels of data structure aggregates supporting the real-time simulation of set theoretic primitive operations. <p> The SQ2+ language is a strongly typed variant of the Curry/Hindley type discipline for the -calculus [20,32]. It is parametric since it contains type variables, but it is not polymorphic. Based on the SQ2+ type inference system described in <ref> [15] </ref>, the APTS inference engine computes types for each program expression. It also computes other program properties, such as monotone expressions, the bound and free variables of expressions, and a kind of abstract syntax. These properties are all stored as relations in the the APTS PDB (Program Database). <p> In this case, there is only one - b27 - which the system asks us to instantiate manually. Type `int' is supplied, and compilation continues. The final transformation, which makes use of concepts found in [53], but relies mainly on the type/subtype inference mechanism of <ref> [15] </ref>, implements all set and map datatypes using array and list data structures. This transformation rests on the discovery of finite universal sets, called bases, to be used for avoiding data replication and for creating aggregate data structures that implement logical associative access operations using simpler cursor or pointer access.
Reference: [16] <author> J. Cai, R. Paige, and R. Tarjan. </author> <title> More Efficient Bottom-Up Multi-Pattern Matching In Trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 106:(1):21 - 60, </volume> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Consequently, the PDB must be updated to be consistent with the new program and the RDB. The inference and transformation engines make use of the efficient bottom up pattern matching algorithm of Cai, Paige, and Tarjan <ref> [16] </ref>. The inference engine used to calculate RDB relations [14] combines this bottom up pattern matcher with RETE style pattern matching [28] and seminaive evaluation of Datalog [5,2,61]. <p> prepfd : primd , rcc1 , rcd1 , rfu1 , prima , intelim , invelim , pelim , difelim , subselim , rcd2 , rfu2 , extosf , rcd3 , seqc ; The algorithm used to implement group transformations is based on the incremental linear pattern matching preprocessor found in <ref> [16] </ref>. Regardless of the number of rewriting transformations belonging to a group, matching can proceed bottom-up so that the exact subset of individual rules whose left-hand-sides match a given program subtree can be computed in unit time, and presented in linear time in the subset size.
Reference: [17] <author> J. Cai and R. Paige. </author> <title> Languages Polynomial in the Input Plus Output. In Algebraic Methodology and Software Technology, </title> <editor> M. Nivat, C. Rattray, T. Rus, and G. Scollo, editors, </editor> <booktitle> Workshops in Computing Series, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 287 - 302, </pages> <year> 1992. </year>
Reference: [18] <author> C.-H. Chang and R. Paige. </author> <title> From Regular Expressions to DFA's Using Compressed NFA's. </title> <booktitle> In Proc. </booktitle> <volume> CPM '92, </volume> <editor> A. Apostolico, M. Crochemore, Z. Galil, and U. Manber, editors, Springer-Verlag, </editor> <booktitle> Lecture Notes in Computer Science number 644, </booktitle> <pages> pages 88 - 108, </pages> <year> 1992. </year>
Reference-contexts: The methodology has been used to invent new algorithms for propositional Horn Clause Satisfiability on a sequential pointer machine [48], transformation from regular expressions to DFA's <ref> [18] </ref>, and ready simulation [8]. We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39].
Reference: [19] <author> P. Cousot and R. Cousot. </author> <title> Constructive versions of Tarski's fixed point theorems. </title> <journal> Pacific J. Math., </journal> <volume> 82:(1):43-57, </volume> <year> 1979. </year>
Reference-contexts: included within the programming language community are Jay Earley at UC Berkeley [24,25,26], Jim Morris at Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot <ref> [19] </ref>; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon [2], Ramakrishnan [3], and Willard [63,64]).
Reference: [20] <author> H. Curry. </author> <title> Modified basic functionality in combinatory logic. </title> <journal> Dialectica, </journal> <volume> 23 </volume> <pages> 83-92, </pages> <year> 1969. </year>
Reference: [21] <author> R. Dewar, A. Grand, S. C. Liu, J. Schwartz, and E. Schonberg. </author> <title> Program by Refinement as Exemplified by the SETL Representation Sublanguage. </title> <journal> TOPLAS, </journal> <volume> 1:(1):27-49, </volume> <month> July, </month> <year> 1979. </year>
Reference: [22] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: The whole system consists of only 15,000 lines of SETL2 [58] source code (including comments), and it makes use of no foreign tools. APTS has meta-tools for syntax, semantics, conditional rewriting, and built-in finite differencing (an abstract mechanization of top down stepwise refinement <ref> [22] </ref>) supporting a single integrated transformational language called RSL. This language has been designed to implement very complex transformations together with the program analysis needed to justify when such transformations can be applied. Compiler construction is a major application. Compilers written in RSL make use of the following APTS components.
Reference: [23] <author> W. Dowling and J. Gallier. </author> <title> Linear-Time Algorithms For Testing The Satisfiability of Propositional Horn Formulae. </title> <journal> J. Logic Programming, </journal> <volume> 3 </volume> <pages> 267-284, </pages> <year> 1984. </year>
Reference-contexts: Bernstein and Beeri [6] and Dowling and Gallier <ref> [23] </ref> independently solved this problem with the same asymptotic complexity as our compiled C program, and all three solutions use the power of address arithmetic to directly access arrays.
Reference: [24] <author> J. Earley. </author> <title> Toward an Understanding of Data Structures. </title> <journal> CACM, </journal> <volume> 14:(10):617-627, </volume> <month> Oct. </month> <year> 1971. </year>
Reference: [25] <author> J. Earley. </author> <title> High Level Operations in Automatic Programming. </title> <booktitle> In Proc. Symp. on Very High Level Langs., Sigplan Notices, </booktitle> <address> 9:(4), </address> <month> Apr, </month> <year> 1974. </year>
Reference: [26] <author> J. Earley. </author> <title> High Level Iterators and a Method for Automatically Designing Data Structure Representation. J of Computer Languages, </title> <address> 1:(4):321-342, </address> <year> 1976. </year> <month> 16 </month>
Reference: [27] <author> A. Fong and J. Ullman. </author> <title> Induction Variables in Very High Level Languages. </title> <booktitle> In Proc. Third ACM POPL, </booktitle> <pages> pages 104-112, </pages> <month> Jan, </month> <year> 1976. </year>
Reference-contexts: programming language and database communities for over twenty years (e.g., included within the programming language community are Jay Earley at UC Berkeley [24,25,26], Jim Morris at Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton <ref> [27] </ref>, Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon [2], Ramakrishnan [3], and Willard [63,64]).
Reference: [28] <author> C. Forgy. </author> <title> RETE, a fast algorithm for the many patterns many objects Match problem. </title> <journal> Ari-tifical Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: The inference and transformation engines make use of the efficient bottom up pattern matching algorithm of Cai, Paige, and Tarjan [16]. The inference engine used to calculate RDB relations [14] combines this bottom up pattern matcher with RETE style pattern matching <ref> [28] </ref> and seminaive evaluation of Datalog [5,2,61]. Other transformational systems currently in use with capabilities similar to APTS are Refine [50], KIDS [56] (which is built on top of Refine), Centaur [9], and ASF+SDF [36].
Reference: [29] <author> H. Goldstine. </author> <title> A History of Numerical Analysis, </title> <publisher> Springer-Verlag, </publisher> <year> 1977. </year>
Reference-contexts: a with := x1 ; end loop ; 5 print ( a ) ; end ; The SQ2+-to-C translator proceeds to the next phase of compilation, which applies finite differencing, named after the 16th century method attributed to Henry Briggs for computing tables of successive polynomial values by difference polynomials <ref> [29] </ref>.
Reference: [30] <author> A. Goldberg and R. Paige. </author> <booktitle> Stream Processing ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pp. 53-62, </pages> <month> Aug, </month> <year> 1984. </year>
Reference-contexts: &lt;= replacement code is .e supply identifier for .e &gt;:g invariant for - .x in domain f | .q in .x - &lt;= replacement code is .e - .q - supply identifier for .e &gt;:h After the six invariants are detected, a stream processing transformation based on Goldberg and Paige <ref> [30] </ref> inserts code that aims to establish the invariants on entry to the while loop using a minimal number of loops. In this case stream processing generates the code appearing on lines 3 through just before line 24 below.
Reference: [31] <author> L. Henschen and S. Naqvi. </author> <title> On Compiling Queries in Recursive First-order Database. </title> <journal> CACM, </journal> <volume> 31 </volume> <pages> 47-85, </pages> <year> 1984. </year>
Reference: [32] <author> J. Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> J Trans. AMS, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference: [33] <author> J. Jeuring. </author> <title> The Derivation of On-Line Algorithms, with an Application to Finding Palindromes. </title> <journal> Algorithmica, </journal> <volume> 11:(2):146-184, </volume> <month> Feb., </month> <year> 1994. </year>
Reference-contexts: The methodology has been used to invent new algorithms for propositional Horn Clause Satisfiability on a sequential pointer machine [48], transformation from regular expressions to DFA's [18], and ready simulation [8]. We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring <ref> [33] </ref> and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39]. Smith has also used program transformations in algorithm design [57]. A major benefit of algorithm design by transformation is that it produces an actual program along with an algorithm.
Reference: [34] <author> N. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation, </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Currently, the SETL-to-C compiler translates 4.5 SETL lines into 22 C lines per minute on a SPARCstation 2. At this rate two days would be needed to translate APTS. We plan to improve this performance in several ways including application of partial evaluation techniques developed by Neil Jones's group <ref> [34] </ref>. Three sources of inefficiency will be examined to improve the performance of SETL2-to-C translation using APTS: the SETL2-to-C translator in the APTS meta-language, the APTS interpreters, and the SETL2 system in which APTS is implemented.
Reference: [35] <author> E. Kant. </author> <title> Efficiency in Program Synthesis, </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: property, and of fixed points have concerned the programming language and database communities for over twenty years (e.g., included within the programming language community are Jay Earley at UC Berkeley [24,25,26], Jim Morris at Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant <ref> [35] </ref> at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger [55], Banchilhon [2], Ramakrishnan [3], and Willard [63,64]).
Reference: [36] <author> P. Klint, ed. </author> <note> The ASF+SDF Meta-environment User's Guide, version 26, </note> <year> 1993. </year>
Reference-contexts: Other transformational systems currently in use with capabilities similar to APTS are Refine [50], KIDS [56] (which is built on top of Refine), Centaur [9], and ASF+SDF <ref> [36] </ref>. The most pressing and perhaps most difficult open problem in APTS system research is in devising a scheme to maintain the consistency of PDB relations incrementally in the presence of conditional rewriting.
Reference: [37] <author> D. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol 1: </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference: [38] <author> J. Low and P. Rovner. </author> <title> Techniques for the automatic selection of data structures. </title> <booktitle> In Proc Third POPL, </booktitle> <pages> pages 58 - 67, </pages> <year> 1976. </year>
Reference: [39] <author> L. Meertens. </author> <title> Algorithmics towards programming as a mathematical activity. </title> <booktitle> Proc. CWI Symp. on Mathematics and Computer Science, </booktitle> <editor> J. W. de Bakker, M. Hazewinkel and J.K. Lenstra eds., </editor> <volume> CWI Monograph Vol 1, </volume> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens <ref> [39] </ref>. Smith has also used program transformations in algorithm design [57]. A major benefit of algorithm design by transformation is that it produces an actual program along with an algorithm. Consequently, we can conduct experimental benchmarks to obtain computational results that complement the theoretical improvements.
Reference: [40] <author> L. Meertens. </author> <title> Incremental Optimum-Fit Line Breaking WG2.1 TR 720 REN-5, </title> <month> Jan., </month> <year> 1994. </year>
Reference-contexts: We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens <ref> [40] </ref> add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39]. Smith has also used program transformations in algorithm design [57]. A major benefit of algorithm design by transformation is that it produces an actual program along with an algorithm.
Reference: [41] <author> J. Morris and M. Wells. </author> <title> The Specification of program flow in Madcap VI. </title> <booktitle> In Proc. ACM Natl. Conf., </booktitle> <pages> pages 755 - 762, </pages> <year> 1972. </year>
Reference: [42] <author> S. Naqvi and L. Henschen. </author> <title> Synthesizing Least Fixed Point Queries into Non-recursive Iterative Programs. </title> <booktitle> In Proc. IJCAI 83, </booktitle> <pages> pages 25-28, </pages> <month> Aug, </month> <year> 1983. </year>
Reference: [43] <author> R. Paige. </author> <title> Programming With Invariants. </title> <journal> IEEE Software, </journal> <volume> 3:(1):56-69, </volume> <month> Jan, </month> <year> 1986. </year>
Reference: [44] <author> R. Paige. </author> <title> Real-time Simulation of a Set Machine on a RAM. </title> <booktitle> In Proc. ICCI '89, Computing and Information, </booktitle> <volume> Vol II, </volume> <editor> R. Janicki and W. Koczkodaj, </editor> <booktitle> editors, </booktitle> <pages> pages 69-73, </pages> <year> 1989. </year>
Reference: [45] <author> R. Paige. </author> <title> Symbolic Finite Differencing Part I. </title> <booktitle> Proc. ESOP 90, </booktitle> <editor> N. Jones ed., Springer-Verlag, </editor> <booktitle> Lecture Notes in Computer Science 432, </booktitle> <year> 1990. </year>
Reference: [46] <author> R. Paige. </author> <title> APTS Reference Manual. </title> <type> unpublished manuscript, </type> <year> 1993. </year> <month> 17 </month>
Reference-contexts: The methodology makes use of generic, fully automatic program transformations that can produce high performance code. These program transformations have been tested on paper by using them for algorithm inventions and explanations. The methodology is implemented in the APTS transformational programming system <ref> [46] </ref>. Feasibility of the approach has been tested by conducting experiments with APTS to compare productivity of the new methodology with conventional hand-crafted programming. <p> Consequently, we can conduct experimental benchmarks to obtain computational results that complement the theoretical improvements. This gives our work a potential for pragmatic as well as theoretical impact. 2 1.3 Transformational System The APTS meta-transformational environment was built by Cai and Paige in order to implement the preceding transformations <ref> [46] </ref>. The whole system consists of only 15,000 lines of SETL2 [58] source code (including comments), and it makes use of no foreign tools.
Reference: [47] <author> R. Paige. </author> <title> Efficient Translation of External Input in a Dynamically Typed Language. </title> <booktitle> Proc. IFIP Congress 94, </booktitle> <year> 1994. </year>
Reference-contexts: That result together with the input processing algorithms in <ref> [47] </ref> provide a full pointer machine solution in worst case time and space linear in the length of the external input string. Consequently, it can be shown that the attribute closure specification given in the transcript resides within a variant of the linear time language described in [10].
Reference: [48] <author> R. Paige and F. Henglein. </author> <title> Mechanical Translation of Set Theoretic Problem Specifications Into Efficient RAM Code A Case Study. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4:(2):207-232, </volume> <month> Aug., </month> <year> 1987. </year>
Reference-contexts: The main point of our algorithm design work is to test the viability and utility of our transformational methodology before launching into an implementation. The methodology has been used to invent new algorithms for propositional Horn Clause Satisfiability on a sequential pointer machine <ref> [48] </ref>, transformation from regular expressions to DFA's [18], and ready simulation [8]. We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39]. <p> Bernstein and Beeri [6] and Dowling and Gallier [23] independently solved this problem with the same asymptotic complexity as our compiled C program, and all three solutions use the power of address arithmetic to directly access arrays. In <ref> [48] </ref> Paige and Henglein showed on paper how program transformations like the ones demonstrated in the transcript below could be used to obtain a pointer machine implementation [37,60] of attribute closure with linear worst case time and space AFTER the input is converted to a necessary internal form.
Reference: [49] <author> R. Paige and J. Schwartz. </author> <title> Expression Continuity and the Formal Differentiation of Algorithms. </title> <booktitle> In Proc. 4th ACM POPL, </booktitle> <pages> pages 58-71, </pages> <month> Jan, </month> <year> 1977. </year>
Reference: [50] <editor> Refine User's Guide Version 3.0, </editor> <booktitle> Reasoning Systems, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: The inference engine used to calculate RDB relations [14] combines this bottom up pattern matcher with RETE style pattern matching [28] and seminaive evaluation of Datalog [5,2,61]. Other transformational systems currently in use with capabilities similar to APTS are Refine <ref> [50] </ref>, KIDS [56] (which is built on top of Refine), Centaur [9], and ASF+SDF [36]. The most pressing and perhaps most difficult open problem in APTS system research is in devising a scheme to maintain the consistency of PDB relations incrementally in the presence of conditional rewriting.
Reference: [51] <author> P. Rovner. </author> <title> Automatic Representation Selection for Associative Data Structures. </title> <type> Technical Report 10, </type> <institution> Dept. of Computer Science, University of Rochester, </institution> <year> 1977. </year>
Reference: [52] <author> E. Schonberg, J. Schwartz, and M. Sharir. </author> <title> An Automatic Technique for Selection of Data Representations in in SETL Programs. </title> <journal> ACM TOPLAS, </journal> <volume> 3:(2):126-143, </volume> <month> Apr, </month> <year> 1981. </year>
Reference: [53] <author> J. Schwartz. </author> <title> Automatic Data Structure Choice in a Language of Very High Level. </title> <journal> CACM, </journal> <volume> 18:(12):722-728, </volume> <month> Dec, </month> <year> 1975. </year>
Reference-contexts: In this case, there is only one - b27 - which the system asks us to instantiate manually. Type `int' is supplied, and compilation continues. The final transformation, which makes use of concepts found in <ref> [53] </ref>, but relies mainly on the type/subtype inference mechanism of [15], implements all set and map datatypes using array and list data structures.
Reference: [54] <author> J. Schwartz. </author> <title> Optimization of Very High Level Languages, Parts I, II. </title> <editor> J. </editor> <booktitle> of Computer Languages, </booktitle> <address> 1:(2,3):161-218, </address> <year> 1975. </year>
Reference: [55] <author> P. Selinger, et.al. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <pages> pages 23-34, </pages> <month> May, </month> <year> 1979. </year>
Reference-contexts: One major consequence is a way to implement efficient searching for subsets that satisfy a property (exemplified by a database index used to compute a selection query in relational algebra <ref> [55] </ref>). The final transformation (data structure selection) simulates associative access on a sequential RAM in real-time [44,11,15]. The result is a way to implement primitive set theoretic operations efficiently. <p> Los Alamos [41,62], Low and Rovner at the U. of Rochester [38,51], Barstow [4] and Kant [35] at Stanford, Fong and Ullman at Princeton [27], Jack Schwartz at NYU [53,54,49,52,21], and Cousot and Cousot [19]; included within the database community are Naqui and Henschen [42,31], Aho and Ullman [1], Selinger <ref> [55] </ref>, Banchilhon [2], Ramakrishnan [3], and Willard [63,64]). One key contribution of our work has been to provide a priori algebraic and syntactic reasoning about the program speedup that would result from applying transformations (see [10,44,15,17].
Reference: [56] <author> D. Smith. </author> <title> KIDS A Knowledge-Based Software Development System. </title> <booktitle> Proc. Workshop on Automating Software Design, AAAI-88, </booktitle> <pages> pp. 129-136, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: The inference engine used to calculate RDB relations [14] combines this bottom up pattern matcher with RETE style pattern matching [28] and seminaive evaluation of Datalog [5,2,61]. Other transformational systems currently in use with capabilities similar to APTS are Refine [50], KIDS <ref> [56] </ref> (which is built on top of Refine), Centaur [9], and ASF+SDF [36]. The most pressing and perhaps most difficult open problem in APTS system research is in devising a scheme to maintain the consistency of PDB relations incrementally in the presence of conditional rewriting.
Reference: [57] <author> D. Smith. </author> <title> private communication, </title> <year> 1991. </year>
Reference-contexts: We are currently working on transformational explanations and proofs of parallel algorithms. Recent algorithm inventions due to Jeuring [33] and Meertens [40] add credibility to the calculational approach to algorithm derivation due to Bird [7] and Meertens [39]. Smith has also used program transformations in algorithm design <ref> [57] </ref>. A major benefit of algorithm design by transformation is that it produces an actual program along with an algorithm. Consequently, we can conduct experimental benchmarks to obtain computational results that complement the theoretical improvements.
Reference: [58] <author> K. Snyder. </author> <title> The SETL2 Programming Language. </title> <type> Technical Report 490, </type> <institution> Courant Institute/ New York University, </institution> <year> 1990. </year>
Reference-contexts: This gives our work a potential for pragmatic as well as theoretical impact. 2 1.3 Transformational System The APTS meta-transformational environment was built by Cai and Paige in order to implement the preceding transformations [46]. The whole system consists of only 15,000 lines of SETL2 <ref> [58] </ref> source code (including comments), and it makes use of no foreign tools. APTS has meta-tools for syntax, semantics, conditional rewriting, and built-in finite differencing (an abstract mechanization of top down stepwise refinement [22]) supporting a single integrated transformational language called RSL.
Reference: [59] <author> K. </author> <type> Snyder private communication, </type> <year> 1993. </year>
Reference-contexts: Three sources of inefficiency will be examined to improve the performance of SETL2-to-C translation using APTS: the SETL2-to-C translator in the APTS meta-language, the APTS interpreters, and the SETL2 system in which APTS is implemented. Both Snyder's <ref> [59] </ref> and our experiments suggest that at least a factor of 30 improvement can be obtained in SETL2-to-C translation by bootstrapping the entire APTS system into C.
Reference: [60] <author> R. Tarjan. </author> <title> A Class Of Algorithms Which Require Nonlinear Time To Maintain Disjoint Sets. </title> <journal> J. Comput. Sys. Sci., </journal> <volume> 18 </volume> <pages> 110-127, </pages> <year> 1979. </year>
Reference: [61] <author> J. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, I, </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Inference rules are specified in a language similar to Datalog <ref> [61] </ref> augmented with function symbols and primitive pattern matching predicates. The APTS inference engine analyzes the program (being compiled) for properties specified in the RDB, and it outputs the Program Database (PDB) of finite relations (sets of tuples that represent ground terms) storing the program's properties. <p> There is a notion of `safe' rules (under a closed world assumption) to allow for limited forms of negation and built-in predicates, and a semantics similar to the logic databases found in <ref> [61] </ref>. More details about the inference rules and how they are implemented in APTS can be found in [14]. The conditional rewriting transformation `nminfp' can turn the functional attribute closure specification above into a simple imperative program that computes the conditional least fixed point by dominated convergence.
Reference: [62] <author> M. Wells and J. Morris. </author> <title> The unified data structure capability in Madcap VI. </title> <journal> Intl. Journal of Comp. and Info. Sci., </journal> <volume> 1:(3):193 - 208, </volume> <month> Sept. </month> <year> 1972. </year>
Reference: [63] <author> D. Willard. </author> <title> Abstract Predicate Retrieval Theory. </title> <type> Technical Report 83-3, </type> <institution> State University of New York at Albany, </institution> <month> Aug, </month> <year> 1983. </year>
Reference: [64] <author> D. Willard. </author> <title> Quasilinear Algorithms for Processing Relational Calculus Expressions. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> pages 243-257, </pages> <year> 1990. </year> <month> 18 </month>
References-found: 64

