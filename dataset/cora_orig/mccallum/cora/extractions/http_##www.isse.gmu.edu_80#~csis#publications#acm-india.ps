URL: http://www.isse.gmu.edu:80/~csis/publications/acm-india.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Email: firay,jajodiag@isse.gmu.edu  bertino@disi.unige.it  mancini@disi.unige.it  
Phone: 2  3  
Title: An Advanced Commit Protocol for MLS Distributed Database Systems  
Author: Indrajit Ray ; Elisa Bertino ; Sushil Jajodia ; Luigi Mancini ; 
Note: Partially supported by National Science Foundation under grants IRI-9303416 Partially supported by Italian M.U.R.S.T. and by Nato Collaborative Research grant number 930888 Partially supported by National Science Foundation under grants IRI-9303416 and INT-9412507 and by National Security Agency under grant MDA904-94-C-6118 Partially supported by Italian M.U.R.S.T.  
Address: Fairfax, VA 22030-4444, U.S.A.  Milano, 20135 Milano, Italy  Genova, Genova, Italy  
Affiliation: 1 Center for Secure Information Systems and Department of Information and Software Systems Engineering George Mason University,  Dipartimento di Scienze dell'Informazione Universita di  Dipartimento di Informatica e Scienze Universita di  
Abstract: The classical Early Prepare commit protocol (EP), used in many commercial systems, is not suitable for use in multilevel secure distributed database systems that employ a locking protocol for concurrency control. This is because EP requires that read locks be not released by a subtrans-action during its window of uncertainty; however, it is not possible for a locking protocol to provide this guarantee in a multilevel secure system (since read lock of a higher level transaction on a lower level data object must be released whenever a lower level transaction wants to write it). The Secure Early Prepare protocol (SEP) overcomes this difficulty by aborting those distributed transactions that release their low level read locks prematurely. We see this approach as being too restrictive. One of the major benefits of distributed processing is its robustness to failures, and SEP fails to take advantage of this. In this work, we propose the Advanced Secure Early Prepare commit protocol (ASEP) together with a number of language primitives that can be used as system calls in distributed transactions. These language primitives permit features like partial rollback and forward recovery, and allow a distributed transaction to proceed even when a subtransac-tion has released its low level read locks prematurely. This not only offers flexibility, but also can be used, if desired, by a sophisticated programmer to tradeoff consistency for atomicity of the distributed transaction. c fl1996 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that new copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or fee. Request Permissions from Publication Dept., ACM Inc., Fax +1 (212) 869-0481 or &lt;permissions@acm.org&gt; 
Abstract-found: 1
Intro-found: 1
Reference: [ABJ94] <author> Vijaylakshmi Atluri, Elisa Bertino, and Sushil Jajodia. </author> <title> Degrees of Isolation, Concurrency Control Protocols and Commit Protocols. </title> <editor> In J. Biskup et al., editors, </editor> <booktitle> Database Security, VIII: Status and Prospects, </booktitle> <pages> pages 259-274. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: the locking protocols in multilevel secure (MLS) systems is that in order to avoid a covert channel any read locks acquired by a high level transaction on a low level data object must be released whenever a low transaction attempts to acquire a write lock on the same data object <ref> [HS75, MJ93, Inf93b, Inf93a, ABJ94] </ref>. Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) [MLO86, SC93]. <p> To guarantee serializability, Atluri, Bertino, and Jajodia proposed a secure early prepare commit protocol (SEP) in <ref> [ABJ94] </ref>. <p> This includes the possibilities we provide such as attempting a rollback and reexecution at only one site if there is some kind of failure. 2.2 Secure concurrency control protocol We assume that each transaction manager TM s uses a secure locking protocol as the concurrency control protocol <ref> [MJ93, Inf93b, Inf93a, ABJ94] </ref>. These locking protocols have the common feature that whenever a transaction T i wishes to read (write) a data object x, it must first acquire a read lock (write lock) on x. <p> However, in an MLS environment, read locks on a low level object have to be released, whenever a low transaction tries to write to the same object. <ref> [ABJ94] </ref> solves this problem by introducing a confirmation phase before the decision phase of EP. The complete description of SEP is as follows: 1. <p> sends a No messages after handling the signals, the distributed transaction will abort. 2 7 Ensuring Consistency under ASEP In the previous section, we gave two examples that show how our primitives can be used to commit transactions that would have to abort under a different commit protocol (e.g., SEP <ref> [ABJ94] </ref>). The cost, however, is that this is achieved by possibly sacrificing serializability. We shift our focus in this section and show how our primitives can help even if a programmer desires serializability at all times. <p> The Repeat : : : Until loop in the GetSignal command is executed once. If all the low reading participants send a NoSignalServiced message to the coordinator, then the distributed transaction commits, otherwise it aborts. Note that in this case ASEP reduces to SEP <ref> [ABJ94] </ref>.) 2. The Repeat : : : Until loop in the GetSignal command is executed over and over again with each of the low reading participants rolling back completely when servicing a signal, until all of them send NoSignalServiced messages. 3. <p> ASEP improves upon the secure early prepare protocol (SEP) of <ref> [ABJ94] </ref> by allowing the distributed transaction to proceed even when a subtransaction has released its low level read locks prematurely. ASEP allows partial rollback of sub-transactions so that the main transaction can proceed to completion without sacrificing consistency.
Reference: [BHG87] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: The commit protocol on the other hand ensures the atomicity of a distributed transaction: All its subtransactions either commit or abort. There are several different concurrency and commit protocols with two-phase locking (2PL) and basic two-phase commit (2PC) being the most well-known, respectively <ref> [BHG87] </ref>.
Reference: [BL76] <author> D. E. Bell and L. J. LaPadula. </author> <title> Secure Computer Systems: Unified Exposition and Mul-tics Interpretation. </title> <type> Technical Report MTR-2997, </type> <institution> The Mitre Corp., </institution> <address> Burlington Road, Bedford, MA 01730, </address> <month> March </month> <year> 1976. </year>
Reference-contexts: Our security policy is based on the Bell-LaPadula model <ref> [BL76] </ref>.
Reference: [EMS91] <editor> J. L. Eppinger, L. B. Mummert, and A. Z. Spec-tor, editors. Camelot and Avalon: </editor> <title> A Distributed Transaction Facility. </title> <publisher> Morgan Kaufman Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: ASEP also allows forward recovery measures to be incorporated, which will prevent starvation if required, albeit at the expense of consistency. As part of our future work, we would like to implement ASEP using a transaction processing language like Avalon <ref> [EMS91] </ref>. This will enable us to analyze not only its performance, but its impact on different types of transaction processing, particularly long lived transactions in a cooperative environment, as well.
Reference: [HCH + 93] <author> J. D. Horton, R. H. Cooper, W. F. Hyslop, B. G. Nickerson, O. K. Ward, R. Harland, E. Ashby, and W. M. Stewart. </author> <title> The Cascade Vulnerability Problem. </title> <journal> Journal of Computer Security, </journal> <volume> 2(4) </volume> <pages> 279-290, </pages> <year> 1993. </year>
Reference-contexts: In such case, those read/write operations are treated as another subtransaction T i which is executed at the originating site. The top-level transaction T performs only coordination and supervisory functions. 1 This assumption is necessary to avoid the cascade vulnerability problem <ref> [HCH + 93, MS88] </ref>. Page 2 We have chosen to use the nested structure for two rea-sons. First, it allows for an elegant way of representing asynchronously and independently executing subtrans-actions. Second, in a nested transaction, subtransactions can fail independently of each other and independently of the containing transaction.
Reference: [HS75] <author> Thomas H. Hinke and Marvin Schaefer. </author> <title> Secure Database Management System. </title> <type> Technical Report RADC-TR-75-266, </type> <institution> System Development Corporation, </institution> <month> November </month> <year> 1975. </year>
Reference-contexts: the locking protocols in multilevel secure (MLS) systems is that in order to avoid a covert channel any read locks acquired by a high level transaction on a low level data object must be released whenever a low transaction attempts to acquire a write lock on the same data object <ref> [HS75, MJ93, Inf93b, Inf93a, ABJ94] </ref>. Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) [MLO86, SC93]. <p> Although the original ?-property proposed in the Bell-LaPadula model allows transactions to write into levels above their security level, it seems appropriate to disallow transactions that write to higher levels for the sake of database integrity <ref> [HS75, JK90] </ref>. The trusted DBMSs that are available commercially have the same restriction.
Reference: [Inf93a] <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA. In-formix OnLine/Secure Administrator's Guide, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: the locking protocols in multilevel secure (MLS) systems is that in order to avoid a covert channel any read locks acquired by a high level transaction on a low level data object must be released whenever a low transaction attempts to acquire a write lock on the same data object <ref> [HS75, MJ93, Inf93b, Inf93a, ABJ94] </ref>. Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) [MLO86, SC93]. <p> This includes the possibilities we provide such as attempting a rollback and reexecution at only one site if there is some kind of failure. 2.2 Secure concurrency control protocol We assume that each transaction manager TM s uses a secure locking protocol as the concurrency control protocol <ref> [MJ93, Inf93b, Inf93a, ABJ94] </ref>. These locking protocols have the common feature that whenever a transaction T i wishes to read (write) a data object x, it must first acquire a read lock (write lock) on x.
Reference: [Inf93b] <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA. </address> <note> In-formix OnLine/Secure Security Features User's Guide, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: the locking protocols in multilevel secure (MLS) systems is that in order to avoid a covert channel any read locks acquired by a high level transaction on a low level data object must be released whenever a low transaction attempts to acquire a write lock on the same data object <ref> [HS75, MJ93, Inf93b, Inf93a, ABJ94] </ref>. Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) [MLO86, SC93]. <p> This includes the possibilities we provide such as attempting a rollback and reexecution at only one site if there is some kind of failure. 2.2 Secure concurrency control protocol We assume that each transaction manager TM s uses a secure locking protocol as the concurrency control protocol <ref> [MJ93, Inf93b, Inf93a, ABJ94] </ref>. These locking protocols have the common feature that whenever a transaction T i wishes to read (write) a data object x, it must first acquire a read lock (write lock) on x.
Reference: [JK90] <author> Sushil Jajodia and Boris Kogan. </author> <title> Transaction Processing in Multilevel Secure Databases Using Replicated Architecture. </title> <booktitle> In Proc. of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 360-368, </pages> <address> Oakland, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Although the original ?-property proposed in the Bell-LaPadula model allows transactions to write into levels above their security level, it seems appropriate to disallow transactions that write to higher levels for the sake of database integrity <ref> [HS75, JK90] </ref>. The trusted DBMSs that are available commercially have the same restriction.
Reference: [JM93] <author> Sushil Jajodia and Catherine McCollum. </author> <title> Using Two-phase Commit for Crash Recovery in Federated Multilevel Secure Database Management Systems. </title> <editor> In C. E. Landwehr et al., editors, </editor> <booktitle> Dependable Computing and Fault Tolerant Systems, </booktitle> <volume> Vol. 8, </volume> <pages> pages 365-381. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: What it implies is that read locks may get released within a subtransaction's window of uncertainty (period after a participant has voted yes to commit, but before it receives the commit or abort decision from the coordinator), possibly resulting in nonserializable executions <ref> [JM93, JMB94] </ref>. To guarantee serializability, Atluri, Bertino, and Jajodia proposed a secure early prepare commit protocol (SEP) in [ABJ94]. <p> A site N i is allowed to communicate with another site N j only if L max (N i ) = L max (N j ). 1 The reader may refer to <ref> [JM93] </ref> for additional details on the MLS distributed database model. Our security policy is based on the Bell-LaPadula model [BL76].
Reference: [JMB94] <author> Sushil Jajodia, Catherine D. McCollum, and Barbara T. Blaustein. </author> <title> Integrating Concurrency Control and Commit Algorithms in Distributed Multilevel Secure Databases. </title> <editor> In T. F. Keefe and C. E. Landwehr, editors, </editor> <booktitle> Database Security, VII: Status and Prospects, </booktitle> <pages> pages 109-121. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: What it implies is that read locks may get released within a subtransaction's window of uncertainty (period after a participant has voted yes to commit, but before it receives the commit or abort decision from the coordinator), possibly resulting in nonserializable executions <ref> [JM93, JMB94] </ref>. To guarantee serializability, Atluri, Bertino, and Jajodia proposed a secure early prepare commit protocol (SEP) in [ABJ94].
Reference: [MJ93] <author> John McDermott and Sushil Jajodia. </author> <title> Orange locking: Channel-free database concurrency control via locking. </title> <editor> In B. M. Thuraisingham and C. E. Landwehr, editors, </editor> <booktitle> Database Security, VI: Status and Prospects, </booktitle> <pages> pages 267-284. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1993. </year>
Reference-contexts: the locking protocols in multilevel secure (MLS) systems is that in order to avoid a covert channel any read locks acquired by a high level transaction on a low level data object must be released whenever a low transaction attempts to acquire a write lock on the same data object <ref> [HS75, MJ93, Inf93b, Inf93a, ABJ94] </ref>. Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) [MLO86, SC93]. <p> This includes the possibilities we provide such as attempting a rollback and reexecution at only one site if there is some kind of failure. 2.2 Secure concurrency control protocol We assume that each transaction manager TM s uses a secure locking protocol as the concurrency control protocol <ref> [MJ93, Inf93b, Inf93a, ABJ94] </ref>. These locking protocols have the common feature that whenever a transaction T i wishes to read (write) a data object x, it must first acquire a read lock (write lock) on x.
Reference: [MLO86] <author> C. Mohan, B. Lindsay, and R. Obermarck. </author> <title> Transaction Management in R* Distributed Database Management System. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 11(4) </volume> <pages> 378-396, </pages> <month> De-cember </month> <year> 1986. </year>
Reference-contexts: Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) <ref> [MLO86, SC93] </ref>. What it implies is that read locks may get released within a subtransaction's window of uncertainty (period after a participant has voted yes to commit, but before it receives the commit or abort decision from the coordinator), possibly resulting in nonserializable executions [JM93, JMB94]. <p> However, T i must release a read lock on a data object x whenever another transaction T j such that L (T j ) &lt; L (T i ) requests a write lock on x. 3 Secure Early Prepare Protocol (SEP) As we indicated in the introduction, the conventional EP <ref> [MLO86, SC93] </ref> fails in an MLS system since EP requires that no locks can be released by a subtransaction within its window of uncertainty.
Reference: [Mos85] <author> J. Eliot B. Moss. </author> <title> Nested Transactions. An Approach to Reliable Distributed Computing. Information Systems Series. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachussetts, </address> <year> 1985. </year>
Reference-contexts: We model a distributed transaction T as a nested transaction <ref> [Mos85] </ref>. Nested transactions have a hierarchical grouping structure: each nested transaction consists of either primitive actions (read or write) or some nested transactions.
Reference: [MS88] <author> Jonathan K. Millen and Martin W. Schwartz. </author> <title> The Cascading Problem for Interconnected Networks. </title> <booktitle> In Proc. of the Fourth Aerospace Computer Security Applications Conference, </booktitle> <pages> pages 269-274, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: In such case, those read/write operations are treated as another subtransaction T i which is executed at the originating site. The top-level transaction T performs only coordination and supervisory functions. 1 This assumption is necessary to avoid the cascade vulnerability problem <ref> [HCH + 93, MS88] </ref>. Page 2 We have chosen to use the nested structure for two rea-sons. First, it allows for an elegant way of representing asynchronously and independently executing subtrans-actions. Second, in a nested transaction, subtransactions can fail independently of each other and independently of the containing transaction.
Reference: [SC93] <author> James W. Stamos and Flaviu Cristian. </author> <title> Coordinator Log Transaction Execution Protocol. </title> <booktitle> Distributed and Parallel Databases, </booktitle> <volume> 1 </volume> <pages> 383-408, </pages> <year> 1993. </year> <pages> Page 10 </pages>
Reference-contexts: Unfortunately, this has grave implications for the corresponding commit protocol, specially the early prepare commit protocol (EP) <ref> [MLO86, SC93] </ref>. What it implies is that read locks may get released within a subtransaction's window of uncertainty (period after a participant has voted yes to commit, but before it receives the commit or abort decision from the coordinator), possibly resulting in nonserializable executions [JM93, JMB94]. <p> However, T i must release a read lock on a data object x whenever another transaction T j such that L (T j ) &lt; L (T i ) requests a write lock on x. 3 Secure Early Prepare Protocol (SEP) As we indicated in the introduction, the conventional EP <ref> [MLO86, SC93] </ref> fails in an MLS system since EP requires that no locks can be released by a subtransaction within its window of uncertainty.
References-found: 16

