URL: http://www.cs.ucsd.edu/users/goguen/ps/ftp97.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: Order Equational Logic: Proofs about Partiality using Subsorts and Retracts 1  
Author: Joseph A. Goguen 
Address: San Diego, La Jolla CA 92093-0114 USA  
Affiliation: Department of Computer Science Engineering University of California at  
Note: Stretching First  
Abstract: An obsolete version of this paper appears in Proceedings, International Workshop on First Order Theorem Proving, ed. Maria Paola Bonacina and Ulrich Furbach, RISC-Linz Report 97-70, pages 78-85, 1997; available from http://www.logic.at/ftp97. Abstract: This paper explores some new proof techniques for first order equational logic. It is widely recognized that equational logic is simple, (relatively) decidable, and (relatively) easily mechanized. But it is also widely thought that equational logic for models with total functions has a limited ability to handle partial functions. This paper shows how the modest stretch of equational logic to order sorted total equational logic with retracts effectively handles both calculations and proofs for partial functions. There are actually two approaches, one using subsorts of definition and the other using error supersorts. We illustrate both approaches, but concentrate on the second. We show how information is lost when passing from an order sorted algebra to the corresponding partial algebra, and we use certain properties of this forgetful transformation to establish the adequacy of order sorted total equational reasoning. In addition, we explain a multitude of different kinds of partial satisfaction, consider the stretch to full first order satisfaction, defend against some unjust accusations, and consider parameterized theories, which confer much of the power of higher order logic in a purely first order setting. Appendix A makes precise some formal relations between partial algebra and order sorted algebra using the notion of institution and the new notion of a semi-natural institution representation, and Appendix B justifies our use in proofs of certain equations that involve retracts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jean Benabou. </author> <title> Structures algebriques dans les categories. </title> <editor> Cahiers de Topologie et Geometrie Differentiel, </editor> <volume> 10 </volume> <pages> 1-126, </pages> <year> 1968. </year>
Reference-contexts: EL was unsorted at birth [3], and was later extended to many sorts in various ways, of which <ref> [1] </ref> was perhaps the first, with [12] perhaps the notationally simplest and most widely used today; see [23, 19] for many technical and historical details.
Reference: [2] <author> Jan Bergstra and John Tucker. </author> <title> Characterization of computable data types by means of a finite equational specification method. </title> <editor> In Jaco de Bakker and Jan van Leeuwen, editors, </editor> <booktitle> Automata, Languages and Programming, Seventh Colloquium, </booktitle> <pages> pages 76-90. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 81. </volume>
Reference-contexts: Another sign we are on the right track is that any computable algebra has an equational specification, as first proved by Bergstra and Tucker <ref> [2] </ref>; moreover, this specification tends to be simple and intuitive in practice.
Reference: [3] <author> Garrett Birkhoff. </author> <title> On the structure of abstract algebras. </title> <booktitle> Proceedings of the Cambridge Philosophical Society, </booktitle> <volume> 31 </volume> <pages> 433-454, </pages> <year> 1935. </year>
Reference-contexts: EL was unsorted at birth <ref> [3] </ref>, and was later extended to many sorts in various ways, of which [1] was perhaps the first, with [12] perhaps the notationally simplest and most widely used today; see [23, 19] for many technical and historical details.
Reference: [4] <author> Peter Burmeister. </author> <title> A Model Theoretic Oriented Appraoch to Partial Algebras. </title> <publisher> Akademie-Verlag Berlin, </publisher> <year> 1986. </year>
Reference-contexts: get no satisfaction. 'Cause I try and I try and I try and I try." and also "You can't always get what you want, but if you try sometime you just might get what you need." Two classic references on partial algebra are by Horst Reichel [36] and Peter Burmeister <ref> [4] </ref>, are excellent sources of mathematical satisfaction. More recently, Cerioli, Mossakowski and Reichel in their survey [7] argue in favor of partial satisfaction and against aspects of OSEL, particularly retracts. <p> more satisfying than that of partial algebras; for example, as shown (later in this paper) by the difficulties of finding satisfactory notions of satisfaction and homomorphism, as well as by the considerable complexity of sound and complete rules of deduction for partial algebra (e.g., see the systems in [36] and <ref> [4] </ref>). Moreover, polymorphism seems more natural to order sorted algebra than to partial algebra (since, so far as I know, no one has so far studied, let alone implemented, polymorphic partial algebra).
Reference: [5] <author> Graham Button and Wes Sharrock. </author> <title> Occasioned practises in the work of implementing development methodologies. </title> <editor> In Marina Jirotka and Joseph Goguen, editors, </editor> <booktitle> Requirements Engineering: Social and Technical Issues, </booktitle> <pages> pages 217-240. </pages> <publisher> Academic, </publisher> <year> 1994. </year>
Reference-contexts: The claim seems to assume a top-down model of system development. However, actual empirical studies have clearly shown that this (essentially) never happens in real projects (e.g., see <ref> [5] </ref>). This observation is important because it implies that exception handling is not separable into some later phase, but instead must be considered throughout the development process; and indeed, many mature software engineering methods call for designing systems from the beginning so as to facilitate exception handling. 5. <p> of those who make claims like the ones discussed here may have an incorrect understanding of how software development proceeds in practice, and an inadequate appreciation of the limits of formality and of the necessity for informality in real life, including the design of real systems; e.g., see [15] and <ref> [5] </ref>. 11 The CafeOBJ system [8] automatically adds error supersorts and overloads operators, and it is also easy to add them by hand, especially using a powerful editor like emacs. 13 4.1 Unconditional Partial Satisfaction We first consider satisfaction of unconditional equations by partial algebras, over a many sorted signature ;
Reference: [6] <author> Maura Cerioli and Jose Meseguer. </author> <title> Can I borrow your logic? In Proceedings, </title> <booktitle> International Symposium on Mathematical Foundations of Computer Science (Gdansk), </booktitle> <pages> pages 342-351. </pages> <publisher> Springer, </publisher> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 711. </volume>
Reference: [7] <author> Maura Cerioli, Till Mossakowski, and Horst Reichel. </author> <title> From total equational to partial first order. In State of the Art in Algebraic Specification. </title> <journal> IFIP, </journal> <note> to appear 1998. Chapter 3. </note>
Reference-contexts: This is what the injections X do, also taking account of the fact that we are really dealing with equivalence classes of terms. 3.1.1 In Defense of Retracts As Theorem 5 makes very clear, retracts add new terms to old sorts. According to <ref> [7] </ref>, this is "a problem" because of "changing the semantics of the specification." But Theorem 5 plus the doctrine that the semantics is the injection refute this claim: the "new error elements" reside in a shadowy penumbra, distinctly set off from the bright central region of pure elements by the injection, <p> The authors of <ref> [7] </ref> advocate the use of partial functions, and thus have no need for retracts. <p> Partial satisfaction can be combined with ordered sorts; but the resulting system is significantly more complex than either part, and has no advantages over OSEL. Although the suggestion of <ref> [7] </ref> to make retracts partial in such a system would avoid having retract terms of pure subsorts, it would also prevent the many valuable uses of retracts, including proofs about partial functions (see Section 3.3), defining the definedness predicate (see Section 4.6), and error recovery 8 . 7 Those who don't <p> More recently, Cerioli, Mossakowski and Reichel in their survey <ref> [7] </ref> argue in favor of partial satisfaction and against aspects of OSEL, particularly retracts. It has been claimed that partial algebra is better than order sorted algebra for "requirements" because it allows error behavior to be filled in later on, as step-wise development proceeds. <p> ^ F 1 j= F 2 , which says that to prove an implication, it suffices to assume the condition and then prove the conclusion. (This is actually one of the rules used in the proof given in Section 3.3; see Chapter 8 of [17] for more information.) In contrast, <ref> [7] </ref> gives several elaborate special deductive systems for partial first order equational logic, in order to cope with several kinds of satisfaction. <p> the following: Theorem 11: (Completeness) If is a supersorted signature, then U is first order multiple satisfaction preserving and creating for strict -algebras. 2 It is worth noting that the extra power of first order logic allows some of the notions of partial satisfaction to be reduced to others (see <ref> [7] </ref>), and that for order sorted algebra, all notions of satisfaction can be reduced to just the usual total notion. This is because we can define "ok predicates" (which parallel the "definedness predicates" denoted "#" that are used in partial algebra) with retracts. <p> be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see [22] and especially Chapter 8 of [17]. 4.7 Modularity and Parameterization Axel Poigne [33, 34, 35] has noted some problems with parameterized modules in order sorted algebra; see also <ref> [7] </ref>. Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, [35] contains some provocative examples that are worth discussing here.
Reference: [8] <author> Razvan Diaconescu and Kokichi Futatsugi. </author> <title> CafeOBJ Report: The Language, Proof Techniques, and Methodologies for Object-Oriented Algebraic Specification, volume 6. </title> <publisher> World Scientific, </publisher> <year> 1998. </year> <note> To appear, AMAST Series in Computing. </note>
Reference-contexts: [X] = X . red 0 *(s 0 - s s 0) . red [s 0 - s s 0] . close 9 This could be done automatically and implicitly by the system, so that the user doesn't have to be bothered about it, and in fact, the CafeOBJ system <ref> [8] </ref> takes this approach. 9 The first term is irreducible because its sort is Nat? and there are no equations of that sort; the second is irreducible for the same reason. <p> like the ones discussed here may have an incorrect understanding of how software development proceeds in practice, and an inadequate appreciation of the limits of formality and of the necessity for informality in real life, including the design of real systems; e.g., see [15] and [5]. 11 The CafeOBJ system <ref> [8] </ref> automatically adds error supersorts and overloads operators, and it is also easy to add them by hand, especially using a powerful editor like emacs. 13 4.1 Unconditional Partial Satisfaction We first consider satisfaction of unconditional equations by partial algebras, over a many sorted signature ; conditional equations are considered in <p> This adventure is still in progress, but many results can be found in [21], along with further references. Among other related adventures under way, a dual adventure called coalgebra [37], and the new CafeOBJ industrial strength OBJ implementation that directly implements hidden algebra and includes a powerful support environment <ref> [9, 8] </ref> should certainly be mentioned. The parallel adventure of membership equational logic should also be mentioned [31]; it provides another way to reason about partial functions.
Reference: [9] <author> Kokichi Futatsugi and Ataru Nakagawa. </author> <title> An overview of Cafe specification environment. </title> <booktitle> In Proceedings, </booktitle> <institution> ICFEM'97. University of Hiroshima, </institution> <year> 1997. </year>
Reference-contexts: This adventure is still in progress, but many results can be found in [21], along with further references. Among other related adventures under way, a dual adventure called coalgebra [37], and the new CafeOBJ industrial strength OBJ implementation that directly implements hidden algebra and includes a powerful support environment <ref> [9, 8] </ref> should certainly be mentioned. The parallel adventure of membership equational logic should also be mentioned [31]; it provides another way to reason about partial functions.
Reference: [10] <author> Martin Gogolla. </author> <title> Partially ordered sorts in algebraic specifications. </title> <editor> In Bruno Courcelle, editor, </editor> <booktitle> Proceedings, Ninth CAAP (Bordeaux), </booktitle> <pages> pages 139-153. </pages> <address> Cambridge, </address> <year> 1984. </year> <note> Also Forschungsbericht Nr. 169, </note> <institution> Universitat Dortmund, Abteilung Informatik, </institution> <year> 1983. </year>
Reference-contexts: Most of the problems identified in [35] arise from rejecting strong overloading (see Section 3) and adopting "single universe" order sorted algebra in the formulation of Gogolla <ref> [10, 11] </ref>, (although the situation is much the same for any other single universe approach). To avoid making this paper much longer, the discussion that follows assumes some familiarity with the technicalities of various approaches to order sorted algebra; one suitable survey is [19].
Reference: [11] <author> Martin Gogolla. </author> <title> Uber partiell goerdnete Sortenmengen und deren Anwendung zur Fehlerbehandlung in Abstrakten Datentypen. </title> <type> PhD thesis, </type> <institution> Universitat Dortmund, Abteilung Informatik, </institution> <year> 1983, 1986. </year>
Reference-contexts: Most of the problems identified in [35] arise from rejecting strong overloading (see Section 3) and adopting "single universe" order sorted algebra in the formulation of Gogolla <ref> [10, 11] </ref>, (although the situation is much the same for any other single universe approach). To avoid making this paper much longer, the discussion that follows assumes some familiarity with the technicalities of various approaches to order sorted algebra; one suitable survey is [19].
Reference: [12] <author> Joseph Goguen. </author> <title> Semantics of computation. </title> <editor> In Ernest Manes, editor, </editor> <booktitle> Proceedings, First International Symposium on Category Theory Applied to Computation and Control, </booktitle> <pages> pages 151-163. </pages> <publisher> Springer, </publisher> <address> 1975. (San Fransisco, </address> <month> February </month> <year> 1974.) </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 25. </volume>
Reference-contexts: EL was unsorted at birth [3], and was later extended to many sorts in various ways, of which [1] was perhaps the first, with <ref> [12] </ref> perhaps the notationally simplest and most widely used today; see [23, 19] for many technical and historical details. Section 2 quickly reviews many sorted EL, and Section 3 covers the extension to order sorted EL [24], with examples including an inductive proof about a typical partial function. <p> Following <ref> [12] </ref>, this can be based on sorted sets: Given a set S, whose elements are called sorts, an S-sorted set A is a family of sets A s , one for each s 2 S.
Reference: [13] <author> Joseph Goguen. </author> <title> Higher-order functions considered unnecessary for higher-order programming. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 309-352. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year> <note> University of Texas at Austin Year of Programming Series; preliminary version in SRI Technical Report SRI-CSL-88-1, </note> <month> January </month> <year> 1988. </year>
Reference-contexts: Another fruitful topic would be to develop tools to support the style of reasoning about partial functions introduced in this paper; a preprocessor that prepares input for OBJ would be one approach. We close this section by reviewing some work from <ref> [13] </ref> showing that parameterized specifications give much of the power of higher order logic in a purely first order setting 21 . <p> -2 3). ***&gt; should be: 1 2 -1 4 red in MAP [(sq_).FNS] : map (0 1 -2 3). ***&gt; should be: 0 1 4 9 red in MAP [(dbl_).FNS] : map (0 1 -2 3). ***&gt; should be: 0 2 -4 6 21 However, the OBJ3 code used in <ref> [13] </ref> is obsolete; the code used here follows that in [26]. 21 The following module defines another classical higher order function, which applies a given function twice; some instantiations and computations are also given. obj 2 [F :: FN] is var X : S . endo red in 2 [(sq_).FNS] : <p> Of course, not all higher order reeasoning can be captured this way, but it does appear that many of the most useful patterns are cpatured. To summarize some discussions in <ref> [13] </ref>, the difference between this kind of parameterized programming with modules and higher order functional programming is essentially the difference between programming in the large and programming in the small. Parameterized programming does not just combine functions, it combines modules. <p> One important application area is describing architectures for software systems, as discussed in [16]. Moreover, some of the proofs in <ref> [13] </ref>, e.g., for vlsi verification, use the higher order capability. 22 Acknowledgements Thanks to Kokichi Futatsugi for generous support and encouragement through the CafeOBJ project, to Maura Cerioli for frankly expressing some interesting questions and doubts, to Peter Mosses for several helpful and provocative suggestions, and to Razvan Diaconescu for some
Reference: [14] <author> Joseph Goguen. </author> <title> Proving and rewriting. </title> <editor> In Helene Kirchner and Wolfgang Wechler, editors, </editor> <booktitle> Proceedings, Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 1-24. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 463. </volume> <pages> 23 </pages>
Reference-contexts: Notice that the left side is pure iff the condition is satisfied, and it is easily proved that the same holds for the right side. We proceed by induction on the variable N , using an OBJ "proof score" in the style of <ref> [14, 17, 22] </ref>.
Reference: [15] <author> Joseph Goguen. </author> <title> Formality and informality in requirements engineering. </title> <booktitle> In Proceedings, International Conference on Requirements Engineering, </booktitle> <pages> pages 102-108. </pages> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: that many of those who make claims like the ones discussed here may have an incorrect understanding of how software development proceeds in practice, and an inadequate appreciation of the limits of formality and of the necessity for informality in real life, including the design of real systems; e.g., see <ref> [15] </ref> and [5]. 11 The CafeOBJ system [8] automatically adds error supersorts and overloads operators, and it is also easy to add them by hand, especially using a powerful editor like emacs. 13 4.1 Unconditional Partial Satisfaction We first consider satisfaction of unconditional equations by partial algebras, over a many sorted
Reference: [16] <author> Joseph Goguen. </author> <title> Parameterized programming and software architecture. </title> <booktitle> In Proceedings, Reuse'96, </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: One important application area is describing architectures for software systems, as discussed in <ref> [16] </ref>.
Reference: [17] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: Thus we can do computations for OBJ3 theories, not just objects, though of course there is no algorithm to decide equality. Thus OBJ3 can be considered a specification langauge with an 4 executable sublanguage. However, this paper mainly uses OBJ3 for proofs. See <ref> [17, 26] </ref> for more detail on OBJ3. 3 Partiality, Subsorts and Retracts It seems little known that overloaded order sorted algebra with retracts gives a rigorous theory for partial functions, and that reasoning about such functions can be mechanized in systems like OBJ3 [26]. <p> Notice that the left side is pure iff the condition is satisfied, and it is easily proved that the same holds for the right side. We proceed by induction on the variable N , using an OBJ "proof score" in the style of <ref> [14, 17, 22] </ref>. <p> M : N at) L + M N ) N (L + M ) = (N L) M ) ) Rules for transforming first order formulae like the above into boolean combinations of universally quantified equations are fairly obvious, and are discussed informally in Section 4.6, while Chapter 8 of <ref> [17] </ref> (available at http://www.cs.ucsd.edu/users/goguen/ps/tp/fol.ps.gz) gives more details, examples and validity proofs; here we are less formal. The approach is to reduce first order formulae to combinations of ground equations that can be checked by reduction. <p> ) F 2 ) if T ^ F 1 j= F 2 , which says that to prove an implication, it suffices to assume the condition and then prove the conclusion. (This is actually one of the rules used in the proof given in Section 3.3; see Chapter 8 of <ref> [17] </ref> for more information.) In contrast, [7] gives several elaborate special deductive systems for partial first order equational logic, in order to cope with several kinds of satisfaction. <p> This is not the place for details, but it should be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see [22] and especially Chapter 8 of <ref> [17] </ref>. 4.7 Modularity and Parameterization Axel Poigne [33, 34, 35] has noted some problems with parameterized modules in order sorted algebra; see also [7]. Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, [35] contains some provocative examples that are worth discussing here.
Reference: [18] <author> Joseph Goguen and Rod Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 39(1) </volume> <pages> 95-146, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: These notions originated in the semantics of the Clear specification language, e.g., see <ref> [18] </ref>. A rather clever example in [35] shows that the so-called passing compatibility condition fails to hold for the one universe approach, even in the case where there are no subsorts (this condition concerns protection of the actual parameter when instantiating a parameterized module under initial semantics).
Reference: [19] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> An Oxford survey of order sorted algebra. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 4 </volume> <pages> 363-392, </pages> <year> 1994. </year>
Reference-contexts: EL was unsorted at birth [3], and was later extended to many sorts in various ways, of which [1] was perhaps the first, with [12] perhaps the notationally simplest and most widely used today; see <ref> [23, 19] </ref> for many technical and historical details. Section 2 quickly reviews many sorted EL, and Section 3 covers the extension to order sorted EL [24], with examples including an inductive proof about a typical partial function. <p> This section sketches overloaded order sorted EL with retracts (abbreviated OSEL) <ref> [24, 19, 32] </ref>, as well as its implementation and use in OBJ3, with some examples. Subsection 3.1.1 defends retracts against various accusations that they are somehow inadequate or unnatural. The theory of OSEL is much like that of MSEL, modulo some technicalities. <p> But OSEL also supports (what in <ref> [19] </ref> is called) strong polymorphism 6 , whereby in addition to appearing in the number hierarchy above, 0 and 1 may also appear in the integers modulo 2, Z 2 , the integers modulo 3, Z 3 , etc., and can also be characters, and perhaps even Booleans; moreover, they can <p> To avoid making this paper much longer, the discussion that follows assumes some familiarity with the technicalities of various approaches to order sorted algebra; one suitable survey is <ref> [19] </ref>.
Reference: [20] <author> Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Operational semantics of order-sorted algebra. </title> <editor> In Wilfried Brauer, editor, </editor> <booktitle> Proceedings, 1985 International Conference on Automata, Languages and Programming. Springer, 1985. Lecture Notes in Computer Science, </booktitle> <volume> Volume 194. </volume>
Reference-contexts: The OBJ3 notation and implementation handle OSEL much the same as MSEL, though to say this is to skip over some non-trivial technical points, for which see <ref> [20, 28] </ref>. Some people seem to think that OSEL is little more than a notational convenience, allowing some explicit injective functions to be replaced by implicit inclusions for certain many sorted algebras 5 . But to dismiss OSEL for such reasons is wrong, for several different reasons: 1.
Reference: [21] <author> Joseph Goguen and Grant Malcolm. </author> <title> A hidden agenda. </title> <note> To appear, Theoretical Computer Science; also, </note> <institution> UCSD Dept. Computer Science & Eng. </institution> <type> Technical Report CS97-538, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: The most recent stretch with which I am especially familiar is called "hidden equational logic" or "hidden algebra." It handles states with other features of current interest in computer science, including concurrency, nondeterminism, objects and inheritance. This adventure is still in progress, but many results can be found in <ref> [21] </ref>, along with further references. Among other related adventures under way, a dual adventure called coalgebra [37], and the new CafeOBJ industrial strength OBJ implementation that directly implements hidden algebra and includes a powerful support environment [9, 8] should certainly be mentioned.
Reference: [22] <author> Joseph Goguen and Grant Malcolm. </author> <title> Algebraic Semantics of Imperative Programs. </title> <publisher> MIT, </publisher> <year> 1996. </year>
Reference-contexts: Hereafter we use the word "equation" for both the conditional and unconditional cases. 2 Here the parentheses are considered new symbols; see e.g. <ref> [22] </ref> for details. <p> This says we can regard the universally variables as new constants instead. 2.1 Basic OBJ Notation OBJ3 <ref> [22, 26] </ref> is a specification language sufficiently powerful that it can be used as a programming language for small applications, and as a prototyping language for larger applications, and as a verification engine. <p> Each equation is considered to be quantified by exactly the variables that occur in it (provided of course that these variables have been declared). A comprehensive discussion of OBJ3 features can be found in [26], with many further examples and more theory in <ref> [22] </ref>. 2.2 Term Rewriting Term rewriting is the most important implementation technique for EL. This subsection gives a very quick intuitive overview of concepts that are needed for this paper. <p> Notice that the left side is pure iff the condition is satisfied, and it is easily proved that the same holds for the right side. We proceed by induction on the variable N , using an OBJ "proof score" in the style of <ref> [14, 17, 22] </ref>. <p> This is not the place for details, but it should be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see <ref> [22] </ref> and especially Chapter 8 of [17]. 4.7 Modularity and Parameterization Axel Poigne [33, 34, 35] has noted some problems with parameterized modules in order sorted algebra; see also [7].
Reference: [23] <author> Joseph Goguen and Jose Meseguer. </author> <title> Completeness of many-sorted equational logic. </title> <journal> Houston Journal of Mathematics, </journal> <volume> 11(3) </volume> <pages> 307-334, </pages> <year> 1985. </year>
Reference-contexts: EL was unsorted at birth [3], and was later extended to many sorts in various ways, of which [1] was perhaps the first, with [12] perhaps the notationally simplest and most widely used today; see <ref> [23, 19] </ref> for many technical and historical details. Section 2 quickly reviews many sorted EL, and Section 3 covers the extension to order sorted EL [24], with examples including an inductive proof about a typical partial function.
Reference: [24] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 217-273, </pages> <year> 1992. </year> <note> Drafts exist from as early as 1985. </note>
Reference-contexts: Section 2 quickly reviews many sorted EL, and Section 3 covers the extension to order sorted EL <ref> [24] </ref>, with examples including an inductive proof about a typical partial function. Section 4 explains some aspects of partial algebra, particularly its great multitude of satisfaction relations, and how they can be handled in order sorted algebra, including partial recursive functions; parameterization and modularity are also discussed. <p> This section sketches overloaded order sorted EL with retracts (abbreviated OSEL) <ref> [24, 19, 32] </ref>, as well as its implementation and use in OBJ3, with some examples. Subsection 3.1.1 defends retracts against various accusations that they are somehow inadequate or unnatural. The theory of OSEL is much like that of MSEL, modulo some technicalities. <p> OSEL homomorphisms must also respect the subsort relation in an appropriate sense. Then the term algebra construction carries over and gives an initial algebra. We usually assume regular signatures, so that terms have a unique parse of least sort <ref> [24] </ref>; otherwise terms must be annotated with sort information. Adding the mild technical condition of local filtration yields coherent signatures, for which equations and their satisfaction, as well as congruences and quotients, go much as before. <p> We close this section with a brief discussion of overloading. OSEL supports (what in <ref> [24] </ref> is called) subsort polymorphism, whereby for example, 0 and 1 can appear as they commonly do in the natural numbers N, the full integers Z, the rationals Q, the reals R, and the complexes C, in an entirely 5 One precise, and rather elegant, statement of the result relied upon <p> integers Z, the rationals Q, the reals R, and the complexes C, in an entirely 5 One precise, and rather elegant, statement of the result relied upon here is that every category of algebras of an order sorted specification is equivalent to a certain category of many sorted models; see <ref> [24] </ref>. 5 consistent way, because N Z Q R C. <p> Therefore reduced terms that contain retracts are informative error messages, like top r:Stack&gt;NeStack (empty), that can be used to "trap" and handle the error; 6 And in <ref> [24] </ref> is called) ad hoc polymorphism, but we now prefer a term without the negative connotations of "ad hoc". 6 they are also useful in debugging, in case the error was unexpected. <p> The following result, proved in <ref> [24] </ref>, shows that adding retracts is "safe" in the sense of not interfering with free models of the original specification. Faithfulness is a very weak condition that holds, for example, if (; E) has no models where some carriers are empty and others are not, or if E is Church-Rosser. <p> In such cases, sort constraints can do the job; these are declarations that a certain term has (or should have) a certain (sub)sort, under certain given conditions <ref> [24, 28] </ref>. When a term that needs to lie in the subsort has arguments that don't satisfy the conditions, then we get a parse failure. If there is just one variable, then a retract can be inserted, but this is not possible if there is more than one variable. <p> (t 1 ); :::; a (t n )) = A 0 (a 0 ([t 1 ]); :::; a 0 ([t n ])), so that a (t) is pure and is equal to a 0 ([t]). 16 For this to work properly, must be a regular signature in the sense of <ref> [24] </ref>; however this is a very mild restriction, and hereafter we just assume that it holds. 17 Appendix A will show that ff is a natural transformation. 18 We take this to include the case where is a constant, when n = 0. 17 Conversely, assume a (t) is pure, i.e., <p> Poigne's own proposed solution to the difficulties that he discovered with one universe order sorted algebra involves some rather complex restrictions on specifications 20 to make them behave as if they satisified a version of a theorem in <ref> [24] </ref>, which says that any variety of order sorted algebras is equivalent to a category of conditional many sorted algebras (this theorem is not true of unrestricted Gogolla algebras).
Reference: [25] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, IV, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice Hall, </publisher> <year> 1978. </year>
Reference-contexts: Initial algebras are abstract in this sense. Moreover, the word "abstract" in "abstract data type" has exactly the same meaning, since an ADT is defined to be the isomorphism class of initial algebras of a specification <ref> [25] </ref>; this is no mere pun, but a significant fact about software engineering. Another sign we are on the right track is that any computable algebra has an equational specification, as first proved by Bergstra and Tucker [2]; moreover, this specification tends to be simple and intuitive in practice.
Reference: [26] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouannaud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Algebraic Specification with OBJ: An Introduction with Case Studies. Academic, </title> <note> to appear. Also Technical Report SRI-CSL-88-9, August 1988, SRI International. </note>
Reference-contexts: This says we can regard the universally variables as new constants instead. 2.1 Basic OBJ Notation OBJ3 <ref> [22, 26] </ref> is a specification language sufficiently powerful that it can be used as a programming language for small applications, and as a prototyping language for larger applications, and as a verification engine. <p> The == operation is explained in the next subsection. Each equation is considered to be quantified by exactly the variables that occur in it (provided of course that these variables have been declared). A comprehensive discussion of OBJ3 features can be found in <ref> [26] </ref>, with many further examples and more theory in [22]. 2.2 Term Rewriting Term rewriting is the most important implementation technique for EL. This subsection gives a very quick intuitive overview of concepts that are needed for this paper. <p> Thus we can do computations for OBJ3 theories, not just objects, though of course there is no algorithm to decide equality. Thus OBJ3 can be considered a specification langauge with an 4 executable sublanguage. However, this paper mainly uses OBJ3 for proofs. See <ref> [17, 26] </ref> for more detail on OBJ3. 3 Partiality, Subsorts and Retracts It seems little known that overloaded order sorted algebra with retracts gives a rigorous theory for partial functions, and that reasoning about such functions can be mechanized in systems like OBJ3 [26]. <p> See [17, 26] for more detail on OBJ3. 3 Partiality, Subsorts and Retracts It seems little known that overloaded order sorted algebra with retracts gives a rigorous theory for partial functions, and that reasoning about such functions can be mechanized in systems like OBJ3 <ref> [26] </ref>. This section sketches overloaded order sorted EL with retracts (abbreviated OSEL) [24, 19, 32], as well as its implementation and use in OBJ3, with some examples. Subsection 3.1.1 defends retracts against various accusations that they are somehow inadequate or unnatural. <p> Retracts inserted by the parser are usually invisible to users, but can be made visible with a special switch; on the other hand, retracts inserted by users in places where the parser would not put them are always visible. More details about the OBJ3 implementation can be found in <ref> [26] </ref>. <p> in MAP [(sq_).FNS] : map (0 1 -2 3). ***&gt; should be: 0 1 4 9 red in MAP [(dbl_).FNS] : map (0 1 -2 3). ***&gt; should be: 0 2 -4 6 21 However, the OBJ3 code used in [13] is obsolete; the code used here follows that in <ref> [26] </ref>. 21 The following module defines another classical higher order function, which applies a given function twice; some instantiations and computations are also given. obj 2 [F :: FN] is var X : S . endo red in 2 [(sq_).FNS] : xx (3). ***&gt; should be: 81 red xx (4). ***&gt;
Reference: [27] <author> Anne Haxthausen and Friederike Nickl. </author> <title> Pushouts of order-sorted algebraic specifications. </title> <booktitle> In Algebraic Methodology and Software Technology (AMAST '96). Springer, 1996. Lecture Notes in Computer Science, </booktitle> <volume> Volume 1101. </volume>
Reference-contexts: However, this difficulty can be overcome in various ways, one of which is to apply some easy to check sufficient conditions for pushouts of regular signatures to be regular given in <ref> [27] </ref>.
Reference: [28] <author> Claude Kirchner, Helene Kirchner, and Jose Meseguer. </author> <title> Operational semantics of OBJ3. </title> <editor> In T. Lepisto and Aarturo Salomaa, editors, </editor> <booktitle> Proceedings, 15th International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 287-301. </pages> <publisher> Springer, </publisher> <year> 1988. </year> <institution> (Tampere, Finland, </institution> <month> 11-15 July </month> <year> 1988.) </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 317. </volume>
Reference-contexts: The OBJ3 notation and implementation handle OSEL much the same as MSEL, though to say this is to skip over some non-trivial technical points, for which see <ref> [20, 28] </ref>. Some people seem to think that OSEL is little more than a notational convenience, allowing some explicit injective functions to be replaced by implicit inclusions for certain many sorted algebras 5 . But to dismiss OSEL for such reasons is wrong, for several different reasons: 1. <p> In such cases, sort constraints can do the job; these are declarations that a certain term has (or should have) a certain (sub)sort, under certain given conditions <ref> [24, 28] </ref>. When a term that needs to lie in the subsort has arguments that don't satisfy the conditions, then we get a parse failure. If there is just one variable, then a retract can be inserted, but this is not possible if there is more than one variable.
Reference: [29] <author> Saunders Mac Lane and Garrett Birkhoff. </author> <title> Algebra. </title> <publisher> Macmillan, </publisher> <year> 1967. </year>
Reference-contexts: The word "abstract" in the phrase "abstract algebra" means "uniquely defined up to isomor-phism"; for example, an "abstract group" is an isomorphism class of groups, indicating that we are not interested in properties of any particular representation, but only in properties that hold for all representations; e.g., see <ref> [29] </ref>. Initial algebras are abstract in this sense. Moreover, the word "abstract" in "abstract data type" has exactly the same meaning, since an ADT is defined to be the isomorphism class of initial algebras of a specification [25]; this is no mere pun, but a significant fact about software engineering.
Reference: [30] <author> Jose Meseguer. </author> <title> General logics. </title> <editor> In H.-D. Ebbinghaus et al., editors, </editor> <booktitle> Proceedings, Logic Colloquium 1987, </booktitle> <pages> pages 275-329. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference: [31] <author> Jose Meseguer. </author> <title> Membership algebra as a logical framework for equational specification, 1997. </title> <type> Draft manuscript. </type> <institution> Computer Science Lab, SRI International. </institution>
Reference-contexts: Among other related adventures under way, a dual adventure called coalgebra [37], and the new CafeOBJ industrial strength OBJ implementation that directly implements hidden algebra and includes a powerful support environment [9, 8] should certainly be mentioned. The parallel adventure of membership equational logic should also be mentioned <ref> [31] </ref>; it provides another way to reason about partial functions. As yet there is very little experience that would allow us to compare these approaches, but this should be a focus for some future research.
Reference: [32] <author> Jose Meseguer and Joseph Goguen. </author> <title> Order-sorted algebra solves the constructor selector, multiple representation and coercion problems. </title> <journal> Information and Computation, </journal> <volume> 103(1) </volume> <pages> 114-158, </pages> <month> March </month> <year> 1993. </year> <note> Revision of a paper presented at LICS 1987. </note>
Reference-contexts: This section sketches overloaded order sorted EL with retracts (abbreviated OSEL) <ref> [24, 19, 32] </ref>, as well as its implementation and use in OBJ3, with some examples. Subsection 3.1.1 defends retracts against various accusations that they are somehow inadequate or unnatural. The theory of OSEL is much like that of MSEL, modulo some technicalities. <p> The ability to handle errors with retracts adds a whole new dimension to OSEL. For example, <ref> [32] </ref> illustrates the capability for automatic runtime invocation of coercions when type mismatches are detected (and the code given there is not just a specification, it really runs!). 4. <p> partial functions (see Section 3.3), defining the definedness predicate (see Section 4.6), and error recovery 8 . 7 Those who don't mind a little category theory will be pleased to note that this family is a natural transformation between the two free functors. 8 A nice example is given in <ref> [32] </ref>, where retracts are used to automatically detect and then handle data representation mismatch errors, by doing runtime representation changes. This example involves cartesian and polar representations of 7 The example below was sent to me by email as an argument against OSEL.
Reference: [33] <author> Axel Poigne. </author> <title> Error handling for parametrized data types. </title> <editor> In Hans-Jorg Kreowski, editor, </editor> <title> Recent Trends in Data Type Specification: </title> <booktitle> Third Workshop on Specification of Abstract Data Types, </booktitle> <pages> pages 224-239. </pages> <publisher> Springer, </publisher> <year> 1984. </year> <journal> Informatik-Fachberichte, </journal> <volume> Volume 116. </volume> <pages> 24 </pages>
Reference-contexts: This is not the place for details, but it should be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see [22] and especially Chapter 8 of [17]. 4.7 Modularity and Parameterization Axel Poigne <ref> [33, 34, 35] </ref> has noted some problems with parameterized modules in order sorted algebra; see also [7]. Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, [35] contains some provocative examples that are worth discussing here.
Reference: [34] <author> Axel Poigne. </author> <title> Partial algebras, subsorting, and dependent types: Prerequesites for error handling in al-gebraic specifications. In Recent Trends in Data Type Specification: </title> <booktitle> Fifth Workshop on Specification of Abstract Data Types, </booktitle> <pages> pages 208-234. </pages> <publisher> Springer, </publisher> <year> 1987. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 332. </volume>
Reference-contexts: This is not the place for details, but it should be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see [22] and especially Chapter 8 of [17]. 4.7 Modularity and Parameterization Axel Poigne <ref> [33, 34, 35] </ref> has noted some problems with parameterized modules in order sorted algebra; see also [7]. Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, [35] contains some provocative examples that are worth discussing here.
Reference: [35] <author> Axel Poigne. </author> <title> Parameterization for order-sorted algebraic specification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 40(3) </volume> <pages> 229-268, </pages> <year> 1990. </year>
Reference-contexts: Poigne <ref> [35] </ref> opposes this kind of polymorphism, claiming that it "does not enhance the lucidity of specifications". But this claim goes against hundreds of years of notational convention in mathematics and dozens of years in computer science. <p> This is not the place for details, but it should be noted that there are some subtle points about using Boolean valued functions as predicates in proofs like those above; see [22] and especially Chapter 8 of [17]. 4.7 Modularity and Parameterization Axel Poigne <ref> [33, 34, 35] </ref> has noted some problems with parameterized modules in order sorted algebra; see also [7]. Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, [35] contains some provocative examples that are worth discussing here. <p> Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, <ref> [35] </ref> contains some provocative examples that are worth discussing here. Most of the problems identified in [35] arise from rejecting strong overloading (see Section 3) and adopting "single universe" order sorted algebra in the formulation of Gogolla [10, 11], (although the situation is much the same for any other single universe <p> Despite typos, incompletely justified assertions (mathematical and otherwise), errors, and misleading assertions 19 and terminology, <ref> [35] </ref> contains some provocative examples that are worth discussing here. Most of the problems identified in [35] arise from rejecting strong overloading (see Section 3) and adopting "single universe" order sorted algebra in the formulation of Gogolla [10, 11], (although the situation is much the same for any other single universe approach). <p> The usual notion of parameterized specification is just an inclusion of specifications, where the source is called the parameter theory and the target is called the body; the usual notion of in-stantiation for a parameterized specification (called "parameter passing" in <ref> [35] </ref>) is a pushout of specifications, involving the inclusion of the parameter and another specification morphism, called a view, from the parameter spec to another spec. These notions originated in the semantics of the Clear specification language, e.g., see [18]. A rather clever example in [35] shows that the so-called passing <p> specification (called "parameter passing" in <ref> [35] </ref>) is a pushout of specifications, involving the inclusion of the parameter and another specification morphism, called a view, from the parameter spec to another spec. These notions originated in the semantics of the Clear specification language, e.g., see [18]. A rather clever example in [35] shows that the so-called passing compatibility condition fails to hold for the one universe approach, even in the case where there are no subsorts (this condition concerns protection of the actual parameter when instantiating a parameterized module under initial semantics). <p> Analysis of this example shows that this occurs just because strong overloading is disallowed. Poinge's discussion of the PADHOC specification in <ref> [35] </ref> is erroneous, because (here as elsewhere) the theory claimed to be the colimit is correct for the Gogolla approach, but not for our OSEL approach, so that Poinge's claims about our approach are not justified. A problem for the one universe approach that is not noted in [35] concerns multiple <p> specification in <ref> [35] </ref> is erroneous, because (here as elsewhere) the theory claimed to be the colimit is correct for the Gogolla approach, but not for our OSEL approach, so that Poinge's claims about our approach are not justified. A problem for the one universe approach that is not noted in [35] concerns multiple instantiations of the same spec; for example, if some software system has two different stacks of natural numbers, then it will be difficult to distinguish their states, and their error messages, in a one universe approach, without extensive renaming. The only point raised in [35] that seems to <p> not noted in <ref> [35] </ref> concerns multiple instantiations of the same spec; for example, if some software system has two different stacks of natural numbers, then it will be difficult to distinguish their states, and their error messages, in a one universe approach, without extensive renaming. The only point raised in [35] that seems to be a genuine difficulty for our version of OSEL is that pushouts of regular signatures may not be regular. <p> Despite its complexity, Poigne's approach does not attempt to solve the difficulty (discussed in Section 3.1 above) with parsing terms like top pop push (7,push (3,empty)). 19 In particular, the assertion in footnote 2, page 233 of <ref> [35] </ref> is incorrect. 20 I have to say that I find it misleading to redefine the word "specification" to require satisfaction of these conditions. 20 5 Stretching Even Further The quest to stretch equational logic in useful ways continues.
Reference: [36] <author> Horst Reichel. </author> <title> Structural Induction on Partial Algebras. </title> <publisher> Akademie-Verlag Berlin, </publisher> <year> 1984. </year>
Reference-contexts: 10 , "I can't get no satisfaction. 'Cause I try and I try and I try and I try." and also "You can't always get what you want, but if you try sometime you just might get what you need." Two classic references on partial algebra are by Horst Reichel <ref> [36] </ref> and Peter Burmeister [4], are excellent sources of mathematical satisfaction. More recently, Cerioli, Mossakowski and Reichel in their survey [7] argue in favor of partial satisfaction and against aspects of OSEL, particularly retracts. <p> simpler and more satisfying than that of partial algebras; for example, as shown (later in this paper) by the difficulties of finding satisfactory notions of satisfaction and homomorphism, as well as by the considerable complexity of sound and complete rules of deduction for partial algebra (e.g., see the systems in <ref> [36] </ref> and [4]). Moreover, polymorphism seems more natural to order sorted algebra than to partial algebra (since, so far as I know, no one has so far studied, let alone implemented, polymorphic partial algebra).
Reference: [37] <author> Horst Reichel. </author> <title> An approach to object semantics based on terminal co-algebras. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5 </volume> <pages> 129-152, </pages> <year> 1995. </year>
Reference-contexts: This adventure is still in progress, but many results can be found in [21], along with further references. Among other related adventures under way, a dual adventure called coalgebra <ref> [37] </ref>, and the new CafeOBJ industrial strength OBJ implementation that directly implements hidden algebra and includes a powerful support environment [9, 8] should certainly be mentioned. The parallel adventure of membership equational logic should also be mentioned [31]; it provides another way to reason about partial functions.
Reference: [38] <author> Andrzej Tarlecki. </author> <title> Moving between logical systems. </title> <editor> In Magne Haveraaen, Olaf Owe, and Ole-Johan Dahl, editors, </editor> <title> Recent Trends in Data Type Specification, </title> <booktitle> volume 1130 of Lecture Notes in Computer Science, </booktitle> <pages> pages 478-502. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <booktitle> Proceedings of 11th Workshop on Specification of Abstract Data Types. </booktitle> <address> Oslo, Norway, </address> <month> September </month> <year> 1995. </year>
References-found: 38

