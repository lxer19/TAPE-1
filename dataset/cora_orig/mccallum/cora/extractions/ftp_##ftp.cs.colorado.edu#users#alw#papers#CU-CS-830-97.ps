URL: ftp://ftp.cs.colorado.edu/users/alw/papers/CU-CS-830-97.ps
Refering-URL: http://www.cs.colorado.edu/~alw/RecentPubs.html
Root-URL: http://www.cs.colorado.edu
Email: freid,alwg@cs.colorado.edu fuggetta@elet.polimi.it  
Title: Toward Feature Engineering of Software Systems  
Author: C. Reid Turner Alfonso Fuggetta and Alexander L. Wolf 
Keyword: agenda in feature engineering.  
Address: Boulder, CO 80309 USA 20133 Milano, Italy  
Affiliation: Department of Computer Science Dipartimento di Elettronica e Informazione University of Colorado Politecnico di Milano  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-830-97 February 1997 ABSTRACT The gulf between the user and the developer perspectives leads to difficulties in producing successful software systems. Users are focused on the problem domain, where the system's features are the primary concern. Developers are focused on the solution domain, where the system's lifecycle artifacts are key. Presently, there is little understanding of how to narrow this gulf. This paper argues for establishing an organizing viewpoint that we term feature engineering. Feature engineering promotes features as first-class objects throughout the software lifecycle and across the problem and solution domains. The goal of the paper is not to propose a specific new technique or technology. Rather, it aims at laying out some basic concepts and terminology that can be used as a foundation for developing a sound and complete theory of feature engineering. The paper discusses the impact that features have on different phases of the lifecycle, provides some ideas on how these phases can be improved by fully exploiting the concept of feature, and suggests topics for a research The work of A. Fuggetta was supported in part by CNR. The work of A.L. Wolf was supported in part by the Air Force Material Command, Rome Laboratory, and the Defense Advanced Research Projects Agency under Contract Number F30602-94-C-0253. The content of the information does not necessarily reflect the position or the policy of the U.S. Government and no official endorsement should be inferred. c fl 1997 C. Reid Turner, Alfonso Fuggetta, and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho and N. Griffeth. </author> <title> Feature Interaction in the Global Information Infrastructure. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 2-5. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: address the question of how those features would be reflected in lifecycle artifacts other than requirements specifications and in a restricted form of design prototypes. * Several researchers have studied the feature interaction problem, which is concerned with how to identify, prevent, and resolve conflicts among a set of features <ref> [1, 4, 11, 24] </ref>.
Reference: [2] <institution> AT&T Network Systems. 5ESS R fl Switch Global Technical Description, </institution> <month> September </month> <year> 1991. </year> <note> Issue 3. </note>
Reference-contexts: Looking at the example of the telephone switch software, features such as call waiting and call forwarding both relate to the treatment of incoming calls to a busy subscriber line <ref> [2] </ref>, and thus exhibit overlapping requirements fragments. The identification of such feature interactions at the requirements phase can help eliminate unanticipated interaction problems during later phases in the software lifecycle. <p> In this way, the feature interactions are caused to distill out into identifiable components. In the telephone switch, for example, the call forwarding, abbreviated dialing, and direct connection features all require the association of directory numbers with a subscriber line <ref> [2] </ref>. Each 9 Switching Module (see Figure 1) includes a special database to store such information. Thus, the database, as a design element, is driven by a specific and identifiable set of features. <p> This would be useful, for example, in guiding the testing of modifications to the database component of the telephone switch's Switching Module, which is shared by several features <ref> [2] </ref>. Such feature-combination tests could prove useful for detecting unwanted feature interactions. The feature-oriented organization of test sets can also help to minimize regression testing. This harks back to the theme of users posing requests in terms of features.
Reference: [3] <author> D. Batory and S O'Malley. </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The approaches identified in this literature do not provide insight into the role of features across the full range of lifecycle activities and the ability of features to span the problem and solution domains. * Automatic software generation is based on an analysis of a domain to uncover reusable components <ref> [3, 21] </ref>. The components are grouped into subsets having the same functional interface; a complete system is created by choosing an appropriate element from each subset. The choice is based on the "features" exhibited by the elements.
Reference: [4] <author> E.J. Cameron and H. Velthuuijsen. </author> <title> Feature Interactions in Telecommunications Systems. </title> <journal> IEEE Communications Magazine, </journal> <volume> 31 </volume> <pages> 18-23, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: address the question of how those features would be reflected in lifecycle artifacts other than requirements specifications and in a restricted form of design prototypes. * Several researchers have studied the feature interaction problem, which is concerned with how to identify, prevent, and resolve conflicts among a set of features <ref> [1, 4, 11, 24] </ref>.
Reference: [5] <author> D.L. Carney, J.I. Cochrane, L.J. Gitten, E.M. Prell, and R. Staehler. </author> <title> Architectural Overview. </title> <journal> AT&T Technical Journal, </journal> <volume> 64(6) </volume> <pages> 1339-1356, </pages> <year> 1985. </year>
Reference-contexts: Bell Laboratories, for example, developed a design in the solution domain for its 5ESS R fl switch software by following a layered architectural style <ref> [5] </ref>. The layers are depicted in Figure 1. The Abstract Switching Machine layer was intended to provide the foundation upon which the features (called "applications") themselves would be built. This was supposed to result in a clean separation of concerns, permitting features to be more easily added and modified.
Reference: [6] <author> Y.-F. Chen, D.S. Rosenblum, and K.-P. Vo. TestTube: </author> <title> A System for Selective Regression Testing. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 211-220. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: At the module level, the core is composed of the bottom two subsystems, which have no tie back to any feature at the requirements level, other than in their use by subsystems that do have such a tie. Chen, Rosenblum, and Vo <ref> [6] </ref> make a similar observation about the existence of feature components and core components, but their definition is based on test coverage. In particular, core components are those that are exercised by all test cases, whereas feature components are those exercised by only a subset of the test cases.
Reference: [7] <author> K.W. Church and J.I. Helfman. Dotplot: </author> <title> A Program for Exploring Self-Similarity in Millions of Lines for Text and Code. </title> <journal> Journal of Computational and Graphical Statistics, </journal> <volume> 2(2) </volume> <pages> 153-174, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The reverse is also true, but less obvious, since it arises from the duplicate-then-modify style of code update. Such a style results in a proliferation of similar code fragments that are falsely independent (so-called self-similar code <ref> [7] </ref>). 5 2.3 The Instance Level If we populate the model of Figure 2 and examine it at the instance level, additional insights into features are revealed. Figure 3 depicts this level for the instances of entities and relationships of a hypothetical system.
Reference: [8] <author> M.A. Cusumano and R.W. Selby. </author> <title> Microsoft Secrets. </title> <publisher> The Free Press, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: To date, the notion of feature has not been concretely defined, nor has there been much work specifically addressing its support throughout the lifecycle. Nevertheless, one does find the concept used in several relevant and useful, if limited, ways. * Cusumano and Selby <ref> [8] </ref> describe the strong orientation of software development at Microsoft Corporation toward the use of feature teams and feature-driven architectures. <p> Nevertheless, a feature orientation frequently exists during implementation. Cusumano and Selby <ref> [8] </ref> report that development efforts for many Microsoft product groups are organized by the features of their product. Small teams of developers are assigned responsibility for one or more of those features. Especially complicated features are assigned to stronger teams that include developers with more experience.
Reference: [9] <author> P.H. Feiler. </author> <title> Configuration Management Models in Commercial Environments. </title> <type> Technical Report SEI-91-TR-07, </type> <institution> Software Engineering Institute, Pittsburgh, Pennsylvania, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Realizing this expanded role for configuration management will require feature implementations to be separately encapsulated and versioned. Bare files do not appear to be the right abstraction for this purpose. Change sets <ref> [9, 23] </ref>, on the other hand, show promise as a potentially useful 11 storage base.
Reference: [10] <author> H.V. Gomaa, H.V. Sugumaran, C. Bosch, and I. Tavakoli. </author> <title> A Prototype Domain Modeling Environment for Reusable Software Architectures. </title> <booktitle> In Proceedings of the Third International Conference on the Software Reuse, </booktitle> <pages> pages 74-83. </pages> <publisher> IEEE Computer Society, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: Domain analysis uses the notion of features to distinguish basic, core functionality from variant, optional functionality <ref> [10] </ref>. Although features are an explicit element of domain models, their connection to other lifecycle artifacts is effectively non existent. * There has been work on so-called requirements clustering techniques [13, 17], which would appear to lend itself to the identification of features within requirements specifications.
Reference: [11] <author> N.D. Griffeth and Y. Lin. </author> <title> Extending Telecommunications Systems: The Feature-Interaction Problem. </title> <journal> IEEE Computer, </journal> <volume> 26(8) </volume> <pages> 14-18, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: address the question of how those features would be reflected in lifecycle artifacts other than requirements specifications and in a restricted form of design prototypes. * Several researchers have studied the feature interaction problem, which is concerned with how to identify, prevent, and resolve conflicts among a set of features <ref> [1, 4, 11, 24] </ref>. <p> Although similar in nature, they are quite different in their ramifications. The absence of an interaction in the problem domain does not imply the absence of an interaction in the solution domain, which gives rise to the feature interaction "problem" <ref> [11] </ref>. The reverse is also true, but less obvious, since it arises from the duplicate-then-modify style of code update.
Reference: [12] <author> P. Hsia, A.M. Davis, </author> <title> and D.C. Kung. Status Report: Requirements Engineering. </title> <journal> IEEE Software, </journal> <volume> 10(6) </volume> <pages> 75-79, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: includes activities relating to the ": : : identification and documentation of customer and user needs, creation of a document that describes the external behavior and associated constraints that will satisfy those needs, analysis and validation of the requirements document to ensure consistency, completeness, and feasibility, and evolution of needs." <ref> [12] </ref> Research in requirements engineering is primarily focused on formulating improved requirements notations and analyses, and on developing methods and mechanisms for requirements elicitation, rationale capture, and traceability. <p> The fundamental difficulty with requirements engineering in practice today is identified by Hsia et al.: "For the most part, the state of the practice is that requirements engineering produces one large document, written in a natural language, that few people bother to read." <ref> [12] </ref> Feature engineering will make the requirements effort more useful by carrying the results of this effort forward to the other lifecycle activities in a disciplined way.
Reference: [13] <author> P. Hsia and A. Gupta. </author> <title> Incremental Delivery Using Abstract Data Types and Requirements Clustering. </title> <booktitle> In Proceedings of the Second International Conference on Systems Integration, </booktitle> <pages> pages 137-150. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Domain analysis uses the notion of features to distinguish basic, core functionality from variant, optional functionality [10]. Although features are an explicit element of domain models, their connection to other lifecycle artifacts is effectively non existent. * There has been work on so-called requirements clustering techniques <ref> [13, 17] </ref>, which would appear to lend itself to the identification of features within requirements specifications. <p> In addition to the work on feature analysis in the FODA methodology, we have found two other research efforts in requirements engineering that are potentially useful in the development of feature identification techniques. Hsia and Gupta <ref> [13] </ref> have proposed an automated technique for grouping requirements specifications. Their purpose is to support incremental delivery of system functionality through progressive prototypes. The cohesive structures that Hsia and Gupta seek to identify are abstract data types (ADTs) for objects in the problem domain.
Reference: [14] <author> M. Jackson. </author> <title> Software Requirements and Specifications: A Lexicon of Practice, </title> <booktitle> Principles, and Prejudices. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Developers are concerned with the creation and maintenance of lifecycle artifacts, which do not necessarily have a particular meaning in the problem domain. Jackson notes that developers are often quick to focus on the solution domain at the expense of a proper analysis of the problem domain <ref> [14] </ref>. This bias is understandable, since developers work primarily with solution-domain artifacts. Yet the majority of their tasks are motivated by demands emanating from the problem domain.
Reference: [15] <author> K.C. Kang, S.G. Cohen, J.A. Hess, </author> <title> W.E. Novak, and A.S. Peterson. Feature-Oriented Domain Analysis (FODA) Feasibility Study. </title> <type> Technical Report CMU/SEI-90-TR-21, </type> <institution> Software Engineering Institute, Pittsburgh, Pennsylvania, </institution> <year> 1990. </year>
Reference-contexts: must be made available to external organizations, such as telecom munications providers. 1 R fl Switch Architecture. * In domain analysis and modeling, the activity of feature analysis has been defined to capture a customer's or an end user's understanding of the general capabilities of systems in an application domain <ref> [15, 20] </ref>. Domain analysis uses the notion of features to distinguish basic, core functionality from variant, optional functionality [10]. <p> Requirements analysis must include the identification of the set of requirements fragments that comprise each feature, as well as the various dependencies that might exist among the features. If the requirements analysis follows a domain analysis, such as that found in the FODA methodology <ref> [15, 20] </ref>, then it is likely that the important feature set has already been identified.
Reference: [16] <author> H. Ossher and W. Harrison. </author> <title> Combination of Inheritance Hierarchies. </title> <booktitle> In Proceedings of the Conference on Object-oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 25-40. </pages> <institution> Association for Computer Machinery, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Small teams of developers are assigned responsibility for one or more of those features. Especially complicated features are assigned to stronger teams that include developers with more experience. This organizational structure built around features extends to testing teams that are assigned responsibility for testing particular features. Ossher and Harrison <ref> [16] </ref> discuss a method of extending existing class hierarchies by applying "extension hierarchies", which would appear to bear some relation to feature engineering at the implementation level. Goals for this work include reducing modification of existing code and separating different extensions.
Reference: [17] <author> J.D. Palmer and Y. Liang. </author> <title> Indexing and Clustering of Software Requirements Specifications. </title> <booktitle> Information and Decision Technologies, </booktitle> <volume> 18(4) </volume> <pages> 283-299, </pages> <year> 1992. </year>
Reference-contexts: Domain analysis uses the notion of features to distinguish basic, core functionality from variant, optional functionality [10]. Although features are an explicit element of domain models, their connection to other lifecycle artifacts is effectively non existent. * There has been work on so-called requirements clustering techniques <ref> [13, 17] </ref>, which would appear to lend itself to the identification of features within requirements specifications. <p> It is not clear, however, that ADTs are the most suitable representation for features. In addition, their goal of delivering ADT-based prototypes transcends requirements analysis and forces what amount to design choices. Palmer and Liang <ref> [17] </ref> have described a somewhat different requirements clustering technique. They define the problem as an effort to "aggregate a set of N requirements into a set of M requirement [s] clusters where M t N ". This is a precise statement of the goal of identifying 8 features.
Reference: [18] <author> M.H. Penedo and E.D. Stuckle. </author> <title> PMDB|A Project Master Database for Software Engineering Environments. </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering, </booktitle> <pages> pages 150-157. </pages> <publisher> IEEE Computer Society, </publisher> <month> August </month> <year> 1985. </year> <month> 17 </month>
Reference-contexts: Furthermore, the groupings of artifacts made explicit in the third definition can be inferred by using the first definition together with an appropriate model of the relationships among lifecycle artifacts (e.g., PMDB <ref> [18] </ref>). Thus, for the purposes of this paper, we employ the first definition. We use this definition as a core concept to develop a model of the artifacts that are created during software engineering activities. This model is not intended to be definitive of all lifecycle artifacts.
Reference: [19] <author> S.P. Reiss. </author> <title> Connecting Tools Using Message Passing in the Field Environment. </title> <journal> IEEE Software, </journal> <pages> pages 57-66, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The message substrate is a shared medium that is responsible for message delivery, while the protocols provide for anonymous communication. A good example of a system using the event-action style is the Field environment <ref> [19] </ref>. This system provides a collection of software development tools that are integrated using the message substrate. The message substrate essentially directs messages generated by one tool to all other tools that have registered their interest in the message.
Reference: [20] <author> Jr. R.W. Krut. </author> <title> Integrating 001 Tool Support into the Feature-Oriented Domain Analysis Methodology. </title> <type> Technical Report CMU/SEI-93-TR-01, </type> <institution> Software Engineering Institute, Pittsburgh, Pennsylvania, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: must be made available to external organizations, such as telecom munications providers. 1 R fl Switch Architecture. * In domain analysis and modeling, the activity of feature analysis has been defined to capture a customer's or an end user's understanding of the general capabilities of systems in an application domain <ref> [15, 20] </ref>. Domain analysis uses the notion of features to distinguish basic, core functionality from variant, optional functionality [10]. <p> Requirements analysis must include the identification of the set of requirements fragments that comprise each feature, as well as the various dependencies that might exist among the features. If the requirements analysis follows a domain analysis, such as that found in the FODA methodology <ref> [15, 20] </ref>, then it is likely that the important feature set has already been identified.
Reference: [21] <author> M. Sitaraman. </author> <title> Performance Parameterized Reusable Software Components. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(4) </volume> <pages> 567-587, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The approaches identified in this literature do not provide insight into the role of features across the full range of lifecycle activities and the ability of features to span the problem and solution domains. * Automatic software generation is based on an analysis of a domain to uncover reusable components <ref> [3, 21] </ref>. The components are grouped into subsets having the same functional interface; a complete system is created by choosing an appropriate element from each subset. The choice is based on the "features" exhibited by the elements.
Reference: [22] <author> A.M. Sloane and J. Holdsworth. </author> <title> Beyond Traditional Program Slicing. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 180-186. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: One possible technique would be to broaden the scope of program slicing, following Sloane and Holdsworth <ref> [22] </ref>, to create a feature slice through the implementation artifacts. A feature slice would include all of the fragments that contribute to a feature's implementation.
Reference: [23] <institution> Software Maintenance & Development Systems, Inc, Concord, Massachusetts. Aide de Camp Product Overview, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Realizing this expanded role for configuration management will require feature implementations to be separately encapsulated and versioned. Bare files do not appear to be the right abstraction for this purpose. Change sets <ref> [9, 23] </ref>, on the other hand, show promise as a potentially useful 11 storage base.
Reference: [24] <author> P. Zave. </author> <title> Feature Interactions and Formal Specifications in Telecommunications. </title> <journal> IEEE Computer, </journal> <volume> 26(8) </volume> <pages> 20-29, </pages> <month> August </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: address the question of how those features would be reflected in lifecycle artifacts other than requirements specifications and in a restricted form of design prototypes. * Several researchers have studied the feature interaction problem, which is concerned with how to identify, prevent, and resolve conflicts among a set of features <ref> [1, 4, 11, 24] </ref>.
References-found: 24

