URL: http://www.pdos.lcs.mit.edu/~engler/serverOS-sigops96.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~engler/
Root-URL: 
Email: fkaashoek,engler,ganger,kerrg@lcs.mit.edu  
Title: Server Operating Systems  
Author: M. Frans Kaashoek, Dawson R. Engler, Gregory R. Ganger, and Deborah A. Wallach 
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: We introduce server operating systems, which are sets of abstractions and runtime support for specialized, high-performance server applications. We have designed and are implementing a prototype server OS with support for aggressive specialization, direct device-to-device access, an event-driven organization, and dynamic compiler-assisted ILP. Using this server OS, we have constructed an HTTP server that outperforms servers running on a conventional OS by more than an order of magnitude and that can safely timeshare the hardware platform with other applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: To assist with identifying context for an I/O event, the non-blocking interfaces save application-specified values, demultiplex events internally and return the corresponding value to the application. Dynamic, compiler-assisted ILP We use pipes <ref> [1] </ref> to provide dynamic ILP. A pipe is a computation written to act on streaming data, taking several bytes of data as input and producing several bytes of output while performing only a tiny computation (such as a byte swap, or an accumulation for a checksum). <p> This approach eliminates protection boundaries, making sharing the machine among multiple servers/applications difficult. Many aspects of the prototype server OS described in this paper have been proposed and/or implemented previously. For example, integrated layer processing was introduced in [6] and a static, compiler-assisted implementation is described in <ref> [1] </ref>. The event-driven programming style is an old idea, for which John Ousterhout made a strong case in [18]. Both the Harvest cache and Open Market's high-performance WebServer [17] are implemented in this style (to the extent that the OSs on which they operate allow).
Reference: [2] <author> B. N. Bershad, S. Savage, et al. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In 15th ACM SOSP, </booktitle> <pages> pages 267-284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> Although we use the exokernel as a platform for building server OSs, it is likely that other extensible operating systems (e.g., Spin <ref> [2] </ref>, Cache Kernel [5], Vino [23]) could also provide the necessary base support. Some of the extensible abstractions that we are developing could even be added to a conventional OS (e.g., UNIX or Windows NT). The contributions of this paper are threefold. <p> Design In this section, we describe in more detail the components of a prototype server operating system that we have designed and are in the process of building. 2.1 Specialization It has been clearly demonstrated that specializing abstractions and their implementations in application-specific ways can substantially increase performance (e.g., see <ref> [2, 8, 13, 22] </ref>). Because performance is critical for server applications, our prototype server OS supports specialization directly. At the same time, because of the extensible OS used as a base, multiple applications can safely co-exist on a system, even when some of them use differently-specialized resource management policies. <p> Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN <ref> [2] </ref>, the exokernel [8], and Synthetix [22].
Reference: [3] <author> H. Briceno. </author> <title> Design techniques for building fast servers. In MIT Student Workshop, </title> <note> 1996. To appear. </note>
Reference-contexts: Using a prototype server OS, we constructed an HTTP server that provides more than an order of magnitude increase in performance when compared to servers running on a conventional OS while still allowing for safe timesharing of the hardware. Other servers, including NFS <ref> [3] </ref> and FTP, are under construction. Server operating systems offer a way of harnessing the substantial performance improvements offered by extensible operating systems for server applications without the software engineering crisis (caused by separate, slightly different, re-implementations for every application) predicted by some.
Reference: [4] <author> A. Chankhunthod, P. B. Danzig, et al. </author> <title> A hierarchical internet object cache. </title> <booktitle> In Usenix Technical Conference, </booktitle> <pages> pages 153-163, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The experiments were run when no other users were present. As discussed earlier, Cheetah runs on the Aegis exokernel. For comparison purposes, we measured both NCSA/1.4.2 [16] and Harvest/1.3 <ref> [4] </ref> (configured as an httpd-accelerator) running on Ultrix v4.3. configurations. For small document sizes (0 bytes, 10 bytes and 100 bytes), Cheetah services 8 times as many requests as the Harvest cache, which in turn serves 2 times as many as the NCSA server alone.
Reference: [5] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In OSDI, </booktitle> <pages> pages 179-193, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Although we use the exokernel as a platform for building server OSs, it is likely that other extensible operating systems (e.g., Spin [2], Cache Kernel <ref> [5] </ref>, Vino [23]) could also provide the necessary base support. Some of the extensible abstractions that we are developing could even be added to a conventional OS (e.g., UNIX or Windows NT). The contributions of this paper are threefold. <p> Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel <ref> [5] </ref>, Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix [22].
Reference: [6] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In ACM SIGCOMM 1990, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: (and vice versa), avoiding scheduling delays, traversal of file system layers and network layers, and redundant data copies. * Support for event-driven organization of server applications, which avoids the thread management and concur rency control problems inherent in a thread per request organization. * Compiler-supported, dynamic integrated layer processing (ILP) <ref> [6] </ref> to improve the throughput of application specific networking software. The construction of server OSs is greatly simplified by using an extensible operating system. <p> requiring some locking), they allow common cases to be handled with minimal delay/overhead, offering substantial performance improvements. 2.4 Dynamic, compiler-assisted ILP One important, well-known technique for improving network software performance is integrated layer processing (ILP), wherein multiple protocol actions (e.g., checksum and byte-swap) are merged into a single-pass, minimal-overhead function <ref> [6] </ref>. In particular, by combining the protocol actions into a single pass over message data, ILP can reduce the impact of memory system performance on networking. Unfortunately, achieving near-optimal ILP manually is a non-trivial task that needs to be re-addressed each time the sequence of protocol actions changes. <p> We expect the performance of Cheetah to increase further when we exploit the ILP and ASH techniques described earlier, as both have been shown to offer reductions in software overhead <ref> [6, 8, 24] </ref>. For all of the experiments, the HTTP servers were running on dedicated DECstation 5000/125s, which are 25 MHz MIPS R3000 machines. Each client application synchronously requests a single document (i.e., URL) 1000 times. <p> This approach eliminates protection boundaries, making sharing the machine among multiple servers/applications difficult. Many aspects of the prototype server OS described in this paper have been proposed and/or implemented previously. For example, integrated layer processing was introduced in <ref> [6] </ref> and a static, compiler-assisted implementation is described in [1]. The event-driven programming style is an old idea, for which John Ousterhout made a strong case in [18].
Reference: [7] <institution> Digital Equipment Corporation. Alta Vista. </institution> <note> http://www.altavista.digital.com, 1996. </note>
Reference-contexts: Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista <ref> [7] </ref>, which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). The second approach is to create an operating system specifically designed for a single server configuration [11, 12, 20].
Reference: [8] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> an operating system architecture for application-specific resource management. </title> <booktitle> In 15th ACM SOSP, </booktitle> <pages> pages 251-266, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> The construction of server OSs is greatly simplified by using an extensible operating system. We are constructing our prototype server OS as a set of libraries on top of the Aegis exokernel <ref> [8] </ref>, which provides applications with direct, protected access to hardware resources. The exokernel OS architecture, by design, allows arbitrarily-specialized applications to safely timeshare a system. <p> Design In this section, we describe in more detail the components of a prototype server operating system that we have designed and are in the process of building. 2.1 Specialization It has been clearly demonstrated that specializing abstractions and their implementations in application-specific ways can substantially increase performance (e.g., see <ref> [2, 8, 13, 22] </ref>). Because performance is critical for server applications, our prototype server OS supports specialization directly. At the same time, because of the extensible OS used as a base, multiple applications can safely co-exist on a system, even when some of them use differently-specialized resource management policies. <p> This section describes our ongoing implementation of a prototype server OS, which includes efficient and parameterizable implementations of TCP/IP [21] and a disk-based file system, in terms of the server OS support outlined in Section 2. We are building server OSs as libraries on top of an exokernel <ref> [8] </ref>. The exokernel OS architecture is designed to provide application-level software with direct, protected access to hardware resources by limiting kernel functionality to multiplexing hardware resources among applications. This kernel support is sufficient to allow us to construct server OSs such as the one described in Section 2. <p> We expect the performance of Cheetah to increase further when we exploit the ILP and ASH techniques described earlier, as both have been shown to offer reductions in software overhead <ref> [6, 8, 24] </ref>. For all of the experiments, the HTTP servers were running on dedicated DECstation 5000/125s, which are 25 MHz MIPS R3000 machines. Each client application synchronously requests a single document (i.e., URL) 1000 times. <p> Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel <ref> [8] </ref>, and Synthetix [22]. Our contribution is to extend and combine these independent techniques into server OSs that enable a modular approach to building specialized, high-performance server applications. 7 Summary and Conclusions We have argued for server operating systems, which support modular construction of specialized, high-performance server applications.
Reference: [9] <author> D.R. Engler, D.A. Wallach, and M.F. Kaashoek. </author> <title> Design and implementation of a modular, flexible, and fast system for dynamic protocol composition. </title> <type> Technical Memorandum TM-552, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: The pipes are written in a low-level language similar to that of a RISC machine, augmented with useful primitives (such as byteswap). The dynamic ILP interface and implementation are described in <ref> [9] </ref>. 4 Cheetah: A Fast HTTP Server This section describes Cheetah, a fast HTTP server constructed using our prototype server operating system. The development of Cheetah proceeded in several stages, which we expect to be the common approach when building highly-specialized server applications.
Reference: [10] <editor> J.H. Hartman, A.B. Montz, et al. </editor> <title> Scout: A communication-oriented operating system. </title> <type> Technical Report TR 94-20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> Both the Harvest cache and Open Market's high-performance WebServer [17] are implemented in this style (to the extent that the OSs on which they operate allow). Support for direct device-to-device data movement is a main focus of both the container shipping mechanism [19] and the Scout operating system <ref> [10] </ref>. Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix [22]. <p> is a main focus of both the container shipping mechanism [19] and the Scout operating system <ref> [10] </ref>. Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix [22].
Reference: [11] <author> D. Hitz. </author> <title> An NFS file server appliance. </title> <type> Technical Report 3001, </type> <institution> Network Applicance Corporation, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). The second approach is to create an operating system specifically designed for a single server configuration <ref> [11, 12, 20] </ref>. With this approach, a different operating system is generally constructed from the ground up for each different server, greatly increasing the implementation effort [20]. <p> Somewhat less common are examples of the other extreme: server software built on or linked into a rudimentary kernel. Network Appliance's approach to building high-performance servers, as illustrated by their very successful NFS systems (e.g., <ref> [11] </ref>), is to dedicate each system to a single server application running on top of a rudimentary kernel. This approach precludes effective time-sharing of the hardware resources among a server and other servers or maintenance applications.
Reference: [12] <author> D. Major, G. Minshall, and K. Powell. </author> <title> An overview of the NetWare operating system. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 355-372, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). The second approach is to create an operating system specifically designed for a single server configuration <ref> [11, 12, 20] </ref>. With this approach, a different operating system is generally constructed from the ground up for each different server, greatly increasing the implementation effort [20]. <p> This approach precludes effective time-sharing of the hardware resources among a server and other servers or maintenance applications. Servers are constructed on Novell's NetWare operating system by linking modules with the kernel <ref> [12] </ref>. This approach eliminates protection boundaries, making sharing the machine among multiple servers/applications difficult. Many aspects of the prototype server OS described in this paper have been proposed and/or implemented previously. For example, integrated layer processing was introduced in [6] and a static, compiler-assisted implementation is described in [1].
Reference: [13] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In 12th ACM SOSP, </booktitle> <pages> pages 191-201, </pages> <year> 1989. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> Design In this section, we describe in more detail the components of a prototype server operating system that we have designed and are in the process of building. 2.1 Specialization It has been clearly demonstrated that specializing abstractions and their implementations in application-specific ways can substantially increase performance (e.g., see <ref> [2, 8, 13, 22] </ref>). Because performance is critical for server applications, our prototype server OS supports specialization directly. At the same time, because of the extensible OS used as a base, multiple applications can safely co-exist on a system, even when some of them use differently-specialized resource management policies. <p> Support for direct device-to-device data movement is a main focus of both the container shipping mechanism [19] and the Scout operating system [10]. Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis <ref> [13] </ref>, the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix [22].
Reference: [14] <author> M. K. McKusick, W. N. Joy, et al. </author> <title> A fast file system for unix. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: The file system library implements a file system similar to the Fast File System <ref> [14] </ref>. However, in addition to support for non-blocking operations, as described above, this library is highly configurable. In particular, the cache replacement, miss handling, write-back and flush routines are all specified by the application during the initialization phase. Although default implementations exist, it is trivial to replace them.
Reference: [15] <author> J. C. </author> <title> Mogul. </title> <booktitle> The case for persistent-connection http. In ACM SIGCOMM 1995, </booktitle> <pages> pages 299-313, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Document Size (b) Throughput vs. Number of Clients cache, which serves it well during light workloads, its performance falls rapidly as the workload increases because of the TCP/IP implementation thrust upon it by Ultrix. (We believe that this reduction is caused by connections in the TIME WAIT state <ref> [15] </ref>.) After 1500 requests, Harvest throughput drops by 48% and exceeds that of the NCSA server (whose throughput also decreases by 21%) by only 38%. In contrast, Cheetah's performance remains stable in the face of heavy connection rates.
Reference: [16] <institution> NCSA, University of Illinois, Urbana-Champaign. </institution> <note> NCSA HTTPd. http://hoohoo.ncsa.uiuc.edu/index.html. </note>
Reference-contexts: The experiments were run when no other users were present. As discussed earlier, Cheetah runs on the Aegis exokernel. For comparison purposes, we measured both NCSA/1.4.2 <ref> [16] </ref> and Harvest/1.3 [4] (configured as an httpd-accelerator) running on Ultrix v4.3. configurations. For small document sizes (0 bytes, 10 bytes and 100 bytes), Cheetah services 8 times as many requests as the Harvest cache, which in turn serves 2 times as many as the NCSA server alone.
Reference: [17] <author> Open Market, Inc. </author> <title> WebServer technical overview. </title> <address> http://www.openmarket.com/library/WhitePapers/Server/, March 1996. </address>
Reference-contexts: For example, integrated layer processing was introduced in [6] and a static, compiler-assisted implementation is described in [1]. The event-driven programming style is an old idea, for which John Ousterhout made a strong case in [18]. Both the Harvest cache and Open Market's high-performance WebServer <ref> [17] </ref> are implemented in this style (to the extent that the OSs on which they operate allow). Support for direct device-to-device data movement is a main focus of both the container shipping mechanism [19] and the Scout operating system [10].
Reference: [18] <author> J. K. Ousterhout. </author> <title> Why threads are a bad idea (for most purposes). </title> <note> Invited Talk at 1996 Usenix Technical Conference (slides available at http://www.sunlabs.com/~ouster/), January 1996. </note>
Reference-contexts: With such an event-driven organization, a server application can exploit the same level of concurrency (on a uniprocessor) without the problems described above <ref> [18] </ref>. Our prototype server OS supports non-blocking versions of file system and network protocol abstractions to support event-driven programming. <p> For example, integrated layer processing was introduced in [6] and a static, compiler-assisted implementation is described in [1]. The event-driven programming style is an old idea, for which John Ousterhout made a strong case in <ref> [18] </ref>. Both the Harvest cache and Open Market's high-performance WebServer [17] are implemented in this style (to the extent that the OSs on which they operate allow). Support for direct device-to-device data movement is a main focus of both the container shipping mechanism [19] and the Scout operating system [10].
Reference: [19] <author> J. Pasquale, E. Anderson, and P. K. Muller. </author> <title> Container shipping: Operating system support for i/o-intensive applications. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 85-93, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Both the Harvest cache and Open Market's high-performance WebServer [17] are implemented in this style (to the extent that the OSs on which they operate allow). Support for direct device-to-device data movement is a main focus of both the container shipping mechanism <ref> [19] </ref> and the Scout operating system [10]. Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix [22].
Reference: [20] <author> R. Pike, D. Presotto, et al. </author> <title> Plan 9 from Bell Labs. </title> <journal> Computing Systems, </journal> <volume> 8(3) </volume> <pages> 221-254, </pages> <year> 1995. </year>
Reference-contexts: With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). The second approach is to create an operating system specifically designed for a single server configuration <ref> [11, 12, 20] </ref>. With this approach, a different operating system is generally constructed from the ground up for each different server, greatly increasing the implementation effort [20]. <p> The second approach is to create an operating system specifically designed for a single server configuration [11, 12, 20]. With this approach, a different operating system is generally constructed from the ground up for each different server, greatly increasing the implementation effort <ref> [20] </ref>. Furthermore, because this approach does not multiplex resources among multiple servers, it requires that each server have an entire machine dedicated to it, even though server traffic tends to be bursty and could therefore be multiplexed.
Reference: [21] <author> J. Postel. </author> <title> Transmission control protocol. </title> <type> RFC 793, </type> <institution> USC/Information Sciences Institute, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: This section describes our ongoing implementation of a prototype server OS, which includes efficient and parameterizable implementations of TCP/IP <ref> [21] </ref> and a disk-based file system, in terms of the server OS support outlined in Section 2. We are building server OSs as libraries on top of an exokernel [8].
Reference: [22] <author> C. Pu, T. Autry, et al. </author> <title> Optimistic incremental specialization: streamlining a commercial operating system. </title> <booktitle> In 15th ACM SOSP, </booktitle> <pages> pages 314-324, </pages> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> Design In this section, we describe in more detail the components of a prototype server operating system that we have designed and are in the process of building. 2.1 Specialization It has been clearly demonstrated that specializing abstractions and their implementations in application-specific ways can substantially increase performance (e.g., see <ref> [2, 8, 13, 22] </ref>). Because performance is critical for server applications, our prototype server OS supports specialization directly. At the same time, because of the extensible OS used as a base, multiple applications can safely co-exist on a system, even when some of them use differently-specialized resource management policies. <p> Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino [23], Scout [10], SPIN [2], the exokernel [8], and Synthetix <ref> [22] </ref>. Our contribution is to extend and combine these independent techniques into server OSs that enable a modular approach to building specialized, high-performance server applications. 7 Summary and Conclusions We have argued for server operating systems, which support modular construction of specialized, high-performance server applications.
Reference: [23] <author> C. Small and M. Seltzer. Vino: </author> <title> an integrated platform for operating systems and database research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard, </institution> <year> 1994. </year>
Reference-contexts: This approach can simplify the construction of server applications, but seriously compromises performance by forcing them to use overly general OS abstractions. These abstractions frequently provide an order of magnitude less performance (for primitive operations) than is available from the hardware <ref> [2, 8, 10, 13, 22, 23] </ref>. Furthermore, these abstractions are usually high-level, directly preventing servers from exploiting domain-specific knowledge. With this approach, achieving high performance generally requires very powerful hardware (e.g., Alta Vista [7], which uses 12 state-of-the-art Alpha CPUs and over 7 GB of physical memory). <p> Although we use the exokernel as a platform for building server OSs, it is likely that other extensible operating systems (e.g., Spin [2], Cache Kernel [5], Vino <ref> [23] </ref>) could also provide the necessary base support. Some of the extensible abstractions that we are developing could even be added to a conventional OS (e.g., UNIX or Windows NT). The contributions of this paper are threefold. <p> Finally, specialization and support for it in the form of extensible operating systems is a central focus of a number of OS projects, including Synthesis [13], the Cache Kernel [5], Vino <ref> [23] </ref>, Scout [10], SPIN [2], the exokernel [8], and Synthetix [22].
Reference: [24] <author> D. A. Wallach, D. R. Engler, and M. F. Kaashoek. ASHs: </author> <title> Application-specific handlers for high-performance messaging. </title> <booktitle> In ACM SIGCOMM 1996, </booktitle> <month> August </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Our prototype server OS supports non-blocking versions of file system and network protocol abstractions to support event-driven programming. To make this organization even more effective, our prototype server operating system allows aggressive server applications to construct and install code modules (called application-specific safe handlers (ASHs) <ref> [24] </ref>) to be executed immediately upon the occurrence of a relevant hardware interrupt. So, for example, when a network packet or disk interrupt destined for the server application is taken, an application-constructed handler can be run (in addition to the kernel code required for dealing with the interrupt). <p> We expect the performance of Cheetah to increase further when we exploit the ILP and ASH techniques described earlier, as both have been shown to offer reductions in software overhead <ref> [6, 8, 24] </ref>. For all of the experiments, the HTTP servers were running on dedicated DECstation 5000/125s, which are 25 MHz MIPS R3000 machines. Each client application synchronously requests a single document (i.e., URL) 1000 times.
References-found: 24

