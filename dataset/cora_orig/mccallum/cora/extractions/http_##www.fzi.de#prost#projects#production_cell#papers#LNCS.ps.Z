URL: http://www.fzi.de/prost/projects/production_cell/papers/LNCS.ps.Z
Refering-URL: http://www.fzi.de/prost/projects/production_cell/Publications.html
Root-URL: http://www.fzi.de
Email: e-mail: flewerentz lindnerg@fzi.de  
Title: Case Study Production Cell: A Comparative Study in Formal Specification and Verification  
Author: Claus Lewerentz and Thomas Lindner 
Address: Haid-und-Neu-Strae 10-14, 76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik (FZI),  
Abstract: This article reports on a case study in formal specification and verification. The task of the case study was to develop a program for controlling a metal-processing industrial production cell ensuring a number of safety and liveness properties. The system comprises 14 sensors and 13 actuators. It is an example of a safety-critical system, and can be modeled with a finite automaton comprising about 10 12 states. About a dozen different methods have been applied to this realistic, but not unduly complex, example. The construction of mathematically verified control programs for the production cell demonstrates the usefulness of such methods for guaranteeing properties. The comparative overview given here provides a roadmap for the developer who intends to rely on formal methods for similar applications. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Austin and G. I. Parkin. </author> <title> Formal methods: A survey. </title> <type> Technical report, </type> <institution> National Physical Laboratory, Great Britain, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Context of the Case Study A recent questionnaire <ref> [1] </ref> of the British National Physical Laboratory (NPL) showed that one of the major impediments of formal methods to gain broader acceptance in industry is the lack of realistic, comparative surveys.
Reference: 2. <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language: Design, semantics, implementation. </title> <type> Technical report, </type> <institution> Ecole Nationale Sup erieure des Mines de Paris, </institution> <year> 1988. </year>
Reference-contexts: Table 1 gives a short characterization of each of the applied methods. 4 4.1 ESTEREL This contribution [7] was aimed at designing a working controller for the production cell. Fig. 5. Visualization of the ESTEREL automaton controlling the deposit belt ESTEREL <ref> [2] </ref> is an imperative programming language for reactive systems developed by G erard Berry at Sophia-Antipolis. <p> Like LUSTRE (cf. section 4.2), it is based on the hypothesis of perfect synchrony: it is assumed that input signals are synchronous with output signals, and that the program is executed on an infinitely fast machine. Other members of the family of synchronous languages <ref> [2, 17, 28, 19] </ref> are SIGNAL and StateCharts (cf. section 4.3). 4 Please note that this table is not supposed to be understandable by the beginner. It rather tries to give a quick overview for the more experienced reader. Communication in ESTEREL is based on signals.
Reference: 3. <author> A. Brauer, C. Lewerentz, and T. Lindner. </author> <title> Implementation a visualization of an industrial production cell using Tcl/Tk. </title> <booktitle> In Proceedings of the first workshop on Tcl/Tk, </booktitle> <year> 1993. </year>
Reference-contexts: This visualization was constructed using the Tool Command Language (Tcl) together with its X widget set toolkit (Tk), both developed by John Ousterhout at the University of California at Berkeley. Tcl/Tk is described in [36, 37], and how the visualization was constructed using Tcl/Tk is described in <ref> [3] </ref>. Figure 2 shows a screen dump of the visualization, together with a control panel for manual control. The visualization can be controlled with a program which reads sensor values from Unix's stdin and writes its control commands to stdout according to a standardized ASCII protocol.
Reference: 4. <author> M. Broy, F. Dederichs, C. Dendorfer, M. Fuchs, T. F. Gritzner, and R. Weber. </author> <title> The design of distributed systems an introduction to FOCUS. </title> <type> Technical Report SFB 342/2/92, </type> <institution> Technische Universit at M unchen, </institution> <year> 1992. </year>
Reference-contexts: It took about one day to carry out the proofs. 4.6 FOCUS The object of this contribution [39] is to specify the production cell system in a formal framework called FOCUS and implement the specification in Concurrent ML. In addition, some liveness and safety properties are proved. FOCUS <ref> [4] </ref> is a design methodology for distributed systems developed by M. Broy at the Technische Universit at M unchen. A system is designed in three phases: In the requirement specification phase one describes the behavior of the system in a trace logic as a set of action traces. <p> This specification is used to formalize the safety properties given in the informal task description. Streams, as found in SPECTRUM [5] or FOCUS <ref> [4] </ref>, both developed at the Technische Univer-sit at M unchen by M. Broy, are finite or infinite sequences of observable actions. They can be used to describe runs of a distributed system. Predicates over streams describe valid or invalid runs of the system.
Reference: 5. <author> M. Broy, C. Facchi, R. Grosu, R. Hettler, H. Humann, D. Nazareth, F. Regensburger, and K. Stlen. </author> <title> The requirement and design specification language SPECTRUM, an informal introduction. </title> <type> Technical Report TUM-I9140, </type> <institution> Technische Universit at M unchen, </institution> <year> 1992. </year>
Reference-contexts: This specification is used to formalize the safety properties given in the informal task description. Streams, as found in SPECTRUM <ref> [5] </ref> or FOCUS [4], both developed at the Technische Univer-sit at M unchen by M. Broy, are finite or infinite sequences of observable actions. They can be used to describe runs of a distributed system. Predicates over streams describe valid or invalid runs of the system.
Reference: 6. <editor> M. Broy and S. J ahnichen, editors. </editor> <booktitle> Korrekte Software durch formale Methoden. </booktitle> <institution> Technische Universit at Berlin, </institution> <address> Franklinstrae 28-29, D-10587 Berlin, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: With this case study we try to close this gap at least for the area of safety-critical reactive systems of moderate size. This case study was done as one of two major case studies of the KORSO project <ref> [6] </ref>. Both case studies have a common primary aim which is to show the usefulness of formal methods for critical software systems and to prove their applicability to real-world examples.
Reference: 7. <author> R. Budde. </author> <title> A ESTEREL Applied to the Case Study Production Cell. </title> <note> In [29], Chapter 5. </note>
Reference-contexts: The outcomes are named (like specifications, implementations, proofs). Finally, we evaluate the contribution according to the criteria given in Chapter 3. Table 1 gives a short characterization of each of the applied methods. 4 4.1 ESTEREL This contribution <ref> [7] </ref> was aimed at designing a working controller for the production cell. Fig. 5. Visualization of the ESTEREL automaton controlling the deposit belt ESTEREL [2] is an imperative programming language for reactive systems developed by G erard Berry at Sophia-Antipolis.
Reference: 8. <author> G. Schellhorn and A. Burandt. </author> <title> Specification and Verification of Distributed Technical Systems with Central Control. </title> <note> In [29], Chapter 13. </note>
Reference-contexts: FOCUS allows for modular proving, therefore, if just the architecture of the components were rebuild, the implementation of the components would be reusable with all proofs carried out. 4.7 KIV This contribution <ref> [8] </ref> focuses on studying how distributed systems can be modelled within first-order logic, and which requirements for the correctness of a central control program can be expressed and verified using the KIV system. The KIV (Karlsruhe Interactive Verifier) [21, 22] system is designed for the development of correct software systems.
Reference: 9. <author> J. R. Burch, E. M. Clare, K. L. McMillan, D. L. Dill, and J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Conference on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: These diagrams can in principle be checked fully automatically against the StateCharts model by translating the latter into a so-called Binary Decision Diagram (BDD), transforming the former in temporal logic, and finally checking the validity of the logical formulas by symbolic model checking <ref> [9] </ref>. StateCharts and SDTs were applied to the case study in the following way: First, the interface between production cell and control program was defined. It was decided to model both actuators and sensors as states.
Reference: 10. <author> J. Burghardt. </author> <title> Deductive Synthesis Applied to the Case Study Production Cell. </title> <note> In [29], Chapter 17. </note>
Reference-contexts: After getting familiar with the problem, CP1 was implemented in three days and verified within three weeks. About 14 days were spent to implement CP2. 4.9 Deductive Program Synthesis The aim of this contribution <ref> [10] </ref> was to write a formal specification of the production cell that is as close as possible to the informal requirements description and to show how a verified TTL-like circuitry can be constructed from this, using deductive program synthesis.
Reference: 11. <author> E. Casais. </author> <title> An Experiment in Framework Development. </title> <institution> Forschungszentrum Informatik, </institution> <note> submitted for publication. </note>
Reference-contexts: We assume that parts of the specification code could be reused for an extended or modified version of the production cell; the contribution allows no conclusion about the reuse of proofs. 4.12 Eiffel The aim of this work <ref> [11] </ref> was to design an object-oriented framework for production cells and to instantiate this framework for the specific production cell considered. Reusability was given a high priority. Another objective was to investigate the role formal techniques could play to effectively support the development of such libraries of reusable components.
Reference: 12. <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite state concurrent systems using temporal logic specifications. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 117-126, </pages> <year> 1983. </year>
Reference-contexts: SDT proved to be useful for debugging and systematic testing, but is not really well suited for formal verification. Therefore, translating SDL specifications to transition systems and doing symbolic model checking of temporal logic formulas <ref> [12] </ref> is being considered. This work is still being carried out, and due to the lack of tools it is mainly interesting from a research point of view. Currently, the main outcome of the work is a controller generated from SDT 5 .
Reference: 13. <author> S. Conrad, M. Gogolla, and R. Herzig. TROLL light: </author> <title> A core language for specifying objects. </title> <type> Informatik-Bericht 92-02, </type> <institution> Technische Universit at Braunschweig, </institution> <year> 1992. </year>
Reference-contexts: Instead, the production cell has been specified as a community of concurrently existing and interacting objects. TROLL light is a language for the conceptual modeling of information systems and has been developed by the Technische Universit at Braunschweig <ref> [13] </ref>. Systems are specified as a community of interacting objects, the main specification concept being object descriptions, called templates. Templates describe static and dynamic properties, i.e. valid states and valid state evolutions of a prototypical object.
Reference: 14. <author> W. Damm, H. Hungar, P. Kelb, and R. </author> <title> Schl or. Using Graphical Specification Languages and Symbolic Modelchecking in the Verification of a Production Cell. </title> <note> In [29], Chapter 8. </note>
Reference-contexts: Reuse of LUSTRE programs and proofs is only possible on the level of nodes, the only structuring mechanism provided by the language. 4.3 StateCharts with Timing Diagrams This work <ref> [14] </ref> aimed at the formal specification of both the control program and the production cell, and the verification of safety and liveness properties of the composed system. The control program and the behavior of the production cell were specified using a sublanguage of StateCharts, introduced by D. Harel [19].
Reference: 15. <author> D. Dranidis and S. Gastinger. </author> <title> Describing Traces in an Algebraic Specification Language Abstractly by Predicates and more Concretely by CSP-like Programming Constructs. </title> <note> In [29], Chapter 12. </note>
Reference-contexts: We regard this technique to be an interesting approach for HW/SW-Codesign, if one suitably extends the set of available constructs for synthesizing the system according to a given goal. 4.10 SPECTRUM This work <ref> [15] </ref> describes the production cell on two levels of abstraction: Fig. 7. An example for an event diagram CSP Specification. The aim of this specification is to formally describe the behavior of the production cell using a sublanguage of CSP.
Reference: 16. <author> F. Erasmy and E. Sekerinski. </author> <title> RAISE A Rigorous Approach Using Stepwise Refinement Applied to the Case Study Production Cell. </title> <note> In [29], Chapter 16. </note>
Reference-contexts: It took about one month to write and validate the specification, which is about 2000 lines in length (SDL textual notation generated from diagrams). 4.5 RAISE The objective of the RAISE contribution <ref> [16] </ref> was to specify the production cell system, to prove properties of the system at a high level of abstraction, to generate an implementation, and prove that the implementation fulfils the specification. RAISE stands for a Rigorous Approach to Industrial Software Engeneering.
Reference: 17. <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The Synchronous Data Flow Programming Language LUSTRE. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> volume 79(9), </volume> <pages> pp. 1305-1320, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Like LUSTRE (cf. section 4.2), it is based on the hypothesis of perfect synchrony: it is assumed that input signals are synchronous with output signals, and that the program is executed on an infinitely fast machine. Other members of the family of synchronous languages <ref> [2, 17, 28, 19] </ref> are SIGNAL and StateCharts (cf. section 4.3). 4 Please note that this table is not supposed to be understandable by the beginner. It rather tries to give a quick overview for the more experienced reader. Communication in ESTEREL is based on signals. <p> LUSTRE <ref> [17] </ref> is a declarative synchronous programming language for reactive systems developed by N. Halbwachs. Pure LUSTRE, that is LUSTRE without data types, allows to write control programs which react on boolean inputs by generating boolean outputs. Programs are structured in nodes.
Reference: 18. <author> S. P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: remarkable; and the same would be true for any proofs carried out. 4.13 Modula-3 The object of this contribution [40] was to examine how the benefits of object-oriented design and parallel programming can be combined by modelling and implementing a controller of the production cell in the programming language Modula-3 <ref> [18] </ref>. Also, safety requirements were verified for the model obtained. Modula-3 adopts the techniques of structured and modular programming and adds constructs for object-orientation and parallel programming. Concurrent programming is supported in Modula-3 by so-called threads which allow multiple points of execution.
Reference: 19. <author> D. Harel. </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year> <note> 20. </note> . <author> Haugen and B. Mller-Pedersen. </author> <title> Tutorial on object-oriented SDL. </title> <type> SPECS-SISU Report 91002, </type> <institution> Norwegian Computing Center, </institution> <address> P. Box 114 Blindern, N-0314 Oslo, </address> <year> 1991. </year>
Reference-contexts: Like LUSTRE (cf. section 4.2), it is based on the hypothesis of perfect synchrony: it is assumed that input signals are synchronous with output signals, and that the program is executed on an infinitely fast machine. Other members of the family of synchronous languages <ref> [2, 17, 28, 19] </ref> are SIGNAL and StateCharts (cf. section 4.3). 4 Please note that this table is not supposed to be understandable by the beginner. It rather tries to give a quick overview for the more experienced reader. Communication in ESTEREL is based on signals. <p> The control program and the behavior of the production cell were specified using a sublanguage of StateCharts, introduced by D. Harel <ref> [19] </ref>. This is a visual formalism capable of describing state transition systems. In addition, one may describe states hierarchically (a state being allowed to have substates) and express parallelism by allowing a system to be in two or more states at the same time.
Reference: 21. <author> M. Heisel, W. Reif, and W. Stefan. </author> <title> A dynamic logic for program verification. </title> <editor> In Meyer and Taitslin, editors, </editor> <booktitle> Proceedings of Logic in Botic 89, </booktitle> <publisher> LNCS. Springer, </publisher> <year> 1989. </year>
Reference-contexts: The KIV (Karlsruhe Interactive Verifier) <ref> [21, 22] </ref> system is designed for the development of correct software systems. The system supports structured first-order specifications and a tactical theorem proving approach for program verification. Specifications are written in first order predicate logic and refined towards an implementation in a PASCAL-like programming language.
Reference: 22. <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Tactical theorem proving in program verification. </title> <booktitle> In 10th International Conference on Automated Deduction, </booktitle> <publisher> LNCS. Springer, </publisher> <year> 1990. </year>
Reference-contexts: The KIV (Karlsruhe Interactive Verifier) <ref> [21, 22] </ref> system is designed for the development of correct software systems. The system supports structured first-order specifications and a tactical theorem proving approach for program verification. Specifications are written in first order predicate logic and refined towards an implementation in a PASCAL-like programming language.
Reference: 23. <author> R. Herzig and N. Vlachantonis. </author> <title> Specification of the Production Cell Example with a Language for the Conceptual Modelling of Information Systems. </title> <note> In [29], Chapter 21. </note>
Reference-contexts: The stream-based specification describes about 130 actions and is composed out of 50 modules. It is about 10 pages in length, developed in about four weeks. 4.11 TROLL light As the focus of TROLL light is the construction of correct information systems, the objective of this contribution <ref> [23] </ref> was not the proof of the suitability of the method for constructing a correct implementation. Instead, the production cell has been specified as a community of concurrently existing and interacting objects.
Reference: 24. <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: An example for an event diagram CSP Specification. The aim of this specification is to formally describe the behavior of the production cell using a sublanguage of CSP. CSP (Communicating Sequential Processes) <ref> [24] </ref> is a language for the description of systems operating concurrently, developed by C. A. R. Hoare at Oxford. Communicating Processes are used to describe the behavior of systems. Processes can be specified in an imperative style and in a descriptive style as well.
Reference: 25. <author> L. Holenderski. </author> <title> LUSTRE A Verified Production Cell Controller. </title> <note> In [29], Chapter 6. </note>
Reference-contexts: A disadvantage for reusing ESTEREL programs is the unpredictable size of the generated automaton: small changes in an ESTEREL program can result in significant changes of the size of the automaton. 4.2 LUSTRE The goal of the LUSTRE contribution <ref> [25] </ref> was to develop a controller for the simulation and to formally verify the safety requirements of the task description. LUSTRE [17] is a declarative synchronous programming language for reactive systems developed by N. Halbwachs.
Reference: 26. <author> T. K aufl. </author> <title> The program verifier Tatzelwurm. </title> <editor> In H. Kersten, editor, </editor> <booktitle> Sichere Software: Formale Spezifikation und Verifikation vertrauensw urdiger Systeme. </booktitle> <year> 1990. </year>
Reference-contexts: The verification system Tatzelwurm was designed at the Universit at Karlsruhe <ref> [26] </ref> to develop and verify sequential programs written in an imperative language. A Hoare like calculus is used to generate proof obligations sufficient for the correctness of the program. For the proof of the validity of the verification conditions a theorem prover specialized on program verification is available.
Reference: 27. <author> S. Klingenbeck, T. K aufl. </author> <title> Verification of Safety Requirements with a Program Verification System. </title> <note> In [29], Chapter 14. </note>
Reference-contexts: The program has a length of 160 lines. One of the three specification levels is fairly reusable. Liveness proofs seem to be not reusable at all, but the excellent proof replay mechanism of KIV makes the correction of specification and implementation easier. 4.8 Tatzelwurm The goal of this contribution <ref> [27] </ref> was to come up with a complete formal development of the control software of the production cell, enforcing a number of safety and liveness conditions. The verification system Tatzelwurm was designed at the Universit at Karlsruhe [26] to develop and verify sequential programs written in an imperative language.
Reference: 28. <author> P. Le Guernic, A. Beneviste, P. Bournai, and T. Gauthier. </author> <title> SIGNAL: A data flow oriented language for signal processing. </title> <type> Technical Report 246, </type> <institution> IRISA, Rennes, France, </institution> <year> 1985. </year>
Reference-contexts: Like LUSTRE (cf. section 4.2), it is based on the hypothesis of perfect synchrony: it is assumed that input signals are synchronous with output signals, and that the program is executed on an infinitely fast machine. Other members of the family of synchronous languages <ref> [2, 17, 28, 19] </ref> are SIGNAL and StateCharts (cf. section 4.3). 4 Please note that this table is not supposed to be understandable by the beginner. It rather tries to give a quick overview for the more experienced reader. Communication in ESTEREL is based on signals.
Reference: 29. <author> C. Lewerentz and T. Lindner, </author> <title> editors. Case Study Production Cell: A Comparative Study in Formal Software Development. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg Berlin 1994. </address>
Reference-contexts: The same control program can be used for running the toy model (cf. fig. 3 and 4) as well. More details can be found in the appendix of <ref> [29] </ref>. Fig. 3. The toy model (top view) 3 Evaluation Criteria The title of this article calls this work a comparative study. In this section we present the criteria according to which we did this comparison. <p> Modelling and implementation were done by a student in about 3 months. 5 Conclusion Guaranteed properties. This case study shows how formal methods allow for guaranteeing properties of systems consisting of software, hardware, and mechanics. The resulting contributions, summarized in <ref> [29] </ref>, can be used as a roadmap both for selecting and applying a method to a similar problem. <p> Future Work: Call for Contribution This case study is not regarded to be complete. Most contributors regard their work as unfinished, but we think that it is worthwile to document the outcomes obtained so far in a book <ref> [29] </ref>. We encourage any other institute to try out their favorite methodology on the case study production cell. We will keep on maintaining a ftp database for both task description, simulation, and a record of contributed work, be it published papers, reports, or specifications/implementations 7 .
Reference: 30. <author> T. Lindner. </author> <title> Task description of the case study production cell. </title> <type> Technical report, </type> <institution> Forschungszen-trum Informatik, </institution> <address> Haid-und-Neu-Strae 10-14, D-76131 Karlsruhe, </address> <year> 1993. </year>
Reference-contexts: of the model, the production sequence should be able to run without an 1 All exisiting contributions got rid of this by assuming that the reaction of the computer is quick enough and thus succeeded in simplifying the case-study to a causality-based one. 2 The task description was given in <ref> [30] </ref> and can be obtained via anonymous ftp from ftp.fzi.de in the directory /pub/korso/fzelle/english/task. Fig. 1. Top view of the production cell operator. <p> Errors in requirements and specifications. As the case study was to be performed for several institutes spread over Germany, we tried to come up with an unambiguous, complete requirements description <ref> [30] </ref>. Even though the production cell is a system which is relatively easy to understand, our first task description was both incomplete and erroneous. Almost every specification contributed corrections of the task description so did the construction of the simulation with the graphical visualization.
Reference: 31. <author> T. Lindner and S. Heinkel. </author> <title> SDL: The Specification and Description Language Applied to the Case Study Production Cell with the SDT Support Tool. </title> <note> In [29], Chapter 10. </note>
Reference-contexts: The model checker ran between one and five minutes for each property proved (Sparc 10 with 95 MB core memory). 4.4 SDL The goal of the SDL contribution <ref> [31] </ref> was to specify both the control program and the production cell in order to prove properties of the system. SDL, the Specification and Description Language standardized by CCITT [20], is an asynchronous programming language for distributed communicating systems.
Reference: 32. <author> M. L owe, F. Cornelius, J. Faulhaber, and R. </author> <note> Wess ally. </note> <institution> Ein Fallbeispiel f ur KORSO Das het-erogene verteilte Managementsystem HDMS der Projektgruppe Medizin Informatik (PMI) am Deutschen Herzzentrum Berlin und an der TU Berlin Ein Vorschlag. </institution> <type> Technical Report 92-45, </type> <institution> TU Berlin, </institution> <year> 1992. </year>
Reference-contexts: This case study was done as one of two major case studies of the KORSO project [6]. Both case studies have a common primary aim which is to show the usefulness of formal methods for critical software systems and to prove their applicability to real-world examples. Whereas the HDMS-A <ref> [32] </ref> case study examines the applicability of a set of formal methods to a really large and complex information system, this case study focuses on comparing different approaches to formal and semi-formal software construction devel oped inside and outside the KORSO project, and checking their suitability for the class of problems
Reference: 33. <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: The deductive program synthesis approach due to Manna and Waldinger <ref> [33] </ref> is a method for program development in the small. It concentrates on deriving one algorithm from a given specification and some given axioms of background knowledge. Axioms and specifications are given as first order predicate logic formulas.
Reference: 34. <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: An object-oriented framework [35] provides a family of inter-related classes that can be reused, mainly through compositions, for the rapid construction of a large number of programs in a particular application domain. The framework was developed in Eiffel <ref> [34] </ref> a compiled object-oriented programming language with a Pascal-like syntax. In order to bridge the gap between specification and programming languages, Eiffel provides restricted facilities to specify invariants and pre- and postconditions expressed in a variant of propositional logic.
Reference: 35. <author> O. Nierstrasz, S. Gibbs, and D. Tsichritzis. </author> <title> Component-oriented software development. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 160-165, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Reusability was given a high priority. Another objective was to investigate the role formal techniques could play to effectively support the development of such libraries of reusable components. An object-oriented framework <ref> [35] </ref> provides a family of inter-related classes that can be reused, mainly through compositions, for the rapid construction of a large number of programs in a particular application domain. The framework was developed in Eiffel [34] a compiled object-oriented programming language with a Pascal-like syntax.
Reference: 36. <author> J. K. Ousterhout. </author> <title> An embeddable command language. </title> <booktitle> In Proceedings of the 1990 Winter USENIX Conference, </booktitle> <year> 1990. </year>
Reference-contexts: We decided to construct a simulation with a graphical visualization which runs under X Windows. This visualization was constructed using the Tool Command Language (Tcl) together with its X widget set toolkit (Tk), both developed by John Ousterhout at the University of California at Berkeley. Tcl/Tk is described in <ref> [36, 37] </ref>, and how the visualization was constructed using Tcl/Tk is described in [3]. Figure 2 shows a screen dump of the visualization, together with a control panel for manual control.
Reference: 37. <author> J. K. Ousterhout. </author> <title> An X11 toolkit based on the Tcl language. </title> <booktitle> In Proceedings of the 1991 Winter USENIX Conference, </booktitle> <year> 1991. </year>
Reference-contexts: We decided to construct a simulation with a graphical visualization which runs under X Windows. This visualization was constructed using the Tool Command Language (Tcl) together with its X widget set toolkit (Tk), both developed by John Ousterhout at the University of California at Berkeley. Tcl/Tk is described in <ref> [36, 37] </ref>, and how the visualization was constructed using Tcl/Tk is described in [3]. Figure 2 shows a screen dump of the visualization, together with a control panel for manual control.
Reference: 38. <author> J. L. Peterson. </author> <title> Petri Net Theory and the Modelling of Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: Fig. 8. An example of a Petri net: the table controller The core difficulty of the case study lies in producer-consumer synchronization a problem which can be suitably handled with Petri nets <ref> [38] </ref>. Petri net theory was used to specify and validate some important local properties of individual machine controllers (cf. fig. 8 for the table) like liveness and safety. A proof obligation regarding the conformance between the initial Petri net specification and the final object-oriented classes should be discharged.
Reference: 39. <author> J. Phillips and M. Fuchs. </author> <title> Formal Development of a Production Cell in FOCUS A Case Study In [29], </title> <note> Chapter 11. </note>
Reference-contexts: To find the right style and the right sublanguage, however, takes the novice a couple of weeks. It took about one day to carry out the proofs. 4.6 FOCUS The object of this contribution <ref> [39] </ref> is to specify the production cell system in a formal framework called FOCUS and implement the specification in Concurrent ML. In addition, some liveness and safety properties are proved. FOCUS [4] is a design methodology for distributed systems developed by M. Broy at the Technische Universit at M unchen.
Reference: 40. <author> A. R uping and E. Sekerinski. </author> <title> Modula-3: Modelling and Implementation of a Production Cell In [29], </title> <note> Chapter 20. </note>
Reference-contexts: The flexibility of the resulting implementation is therefore remarkable; and the same would be true for any proofs carried out. 4.13 Modula-3 The object of this contribution <ref> [40] </ref> was to examine how the benefits of object-oriented design and parallel programming can be combined by modelling and implementing a controller of the production cell in the programming language Modula-3 [18]. Also, safety requirements were verified for the model obtained.
Reference: 41. <author> R. Schl or and W. Damm. </author> <title> Specification and verification of system-level hardware designs using timing diagrams. </title> <booktitle> In The European Conference on Design Automation with the European Event in ASIC Design, </booktitle> <pages> pages 518-524, </pages> <year> 1993. </year>
Reference-contexts: State transitions are enabled by events, which may additionally depend on conditions (boolean expressions over states) and which are allowed to initiate other events. Safety and liveness properties are also expressed in a graphical language, called Symbolic Timing Diagrams (SDTs). These have been introduced by Schl or and Damm <ref> [41] </ref> and allow for expressing temporal logic formulas in a graphical way, similar to timing diagrams known from telecommunication or signaling systems.
Reference: 42. <author> R. M. Smullyan. </author> <title> First Order Logic. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin Heidelberg New York, </address> <year> 1968. </year>
Reference-contexts: The system accepts a subset of Pascal as a programming language. An order-sorted first-order logic with equality is used as the specification language. The input for the verification system consists of a program containing annotations with the specification. The prover uses the analytic tableaux developed by Smullyan <ref> [42] </ref>. The set of rules is enlarged by rules for equivalence and for a generalization of the modus ponens. The prover can be used fully automatically without user interaction. For this case study a program controlling the production cell was implemented.
Reference: 43. <author> TeleLOGIC Malm o AB. </author> <title> SDT User's Guide, </title> <year> 1993. </year>
Reference-contexts: While changing the state the process may perform some actions, like updating local variables, calling procedures, and sending signals to other processes. There are several commercial tools on the market to support this language which is very popular for telecommunications applications. The SDT tool <ref> [43] </ref> from TeleLOGIC was used. It supports the verification by allowing to perform some reachability analysis. One can specify message sequence charts (MSCs), a very simple form of timing diagrams, and verify a SDL specification against them.
References-found: 42

