URL: http://www.cs.tamu.edu/research/phoenix/techreports/TR_95-019.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/phoenix/papers_bib.html
Root-URL: 
Title: An Algorithm for Supporting Fault Tolerant Objects in Distributed Object Oriented Operating Systems  
Author: Ganesha Beedubail, Anish Karmarkar, Anil Gurijala, Willis Marti and Udo Pooch 
Address: College Station, TX 77843.  
Affiliation: Department of Computer Science, Texas A&M University,  
Abstract: Technical Report (TR 95-019) April 1995 1 . Abstract This paper presents a new algorithm for supporting fault tolerant objects in distributed object oriented systems. The fault tolerance provided by the algorithm is fully user transparent. The algorithm uses checkpointing and message logging scheme. However the novelty of this scheme is in identifying the checkpointing instances such that the checkpointing time will not affect the regular response time for the object requests. It also results in storing the minimum amount of object state(object address space). A simple message logging scheme that pairs the logging of response message and the next request message reduces the message logging time by half on an average compared to other similar logging schemes. The scheme exploits the general features and concepts associated with the notion of the objects and object interactions to its advantage. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Lea, C. Jacquemot, and E. Pillevesse, </author> <title> "Cool: System support for distributed programming," </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, no. 9, </volume> <pages> pp. 37-46, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Object oriented distributed operating systems are getting mainstream acceptance. They are maturing from research ideas to research prototypes <ref> [1, 2, 3] </ref> and soon will appear as commercial systems. When these systems are regularly used for critical applications, the reliability of the object services becomes a crucial issue. However system developers of these systems will neither have the time nor expertise to develop fault tolerant object services.
Reference: [2] <author> G. Hamilton and P. Kougiouris, </author> <title> "The spring nucleus: A microkernel for objects," </title> <booktitle> In Proc. of 1993 Summer Usenix Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Object oriented distributed operating systems are getting mainstream acceptance. They are maturing from research ideas to research prototypes <ref> [1, 2, 3] </ref> and soon will appear as commercial systems. When these systems are regularly used for critical applications, the reliability of the object services becomes a crucial issue. However system developers of these systems will neither have the time nor expertise to develop fault tolerant object services. <p> The programming model used in this system is the object oriented paradigm. The object interfaces are defined in such a system using some standard interface definition language (IDL), though this fact is not necessary (or assumed) for our algorithm. Systems such as SPRING <ref> [2, 3] </ref> provide such features. The objects in the system are active (i.e. the object is always executing for providing services). 3.1 Objects Objects basically contain the data (also called object state) and code (procedure or methods) to manipulate the object state.
Reference: [3] <author> J. Mitchel et al., </author> <title> "An overview of the spring system," </title> <booktitle> In Proceedings of of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Object oriented distributed operating systems are getting mainstream acceptance. They are maturing from research ideas to research prototypes <ref> [1, 2, 3] </ref> and soon will appear as commercial systems. When these systems are regularly used for critical applications, the reliability of the object services becomes a crucial issue. However system developers of these systems will neither have the time nor expertise to develop fault tolerant object services. <p> The programming model used in this system is the object oriented paradigm. The object interfaces are defined in such a system using some standard interface definition language (IDL), though this fact is not necessary (or assumed) for our algorithm. Systems such as SPRING <ref> [2, 3] </ref> provide such features. The objects in the system are active (i.e. the object is always executing for providing services). 3.1 Objects Objects basically contain the data (also called object state) and code (procedure or methods) to manipulate the object state.
Reference: [4] <author> K. P. Birman et al., </author> <title> "Implementing fault-tolerant distributed objects," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 6, no. 11, </volume> <pages> pp. 502-508, </pages> <year> 1985. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> Simple independent checkpointing schemes suffer with this problem. This problem can be solved by logging the messages in conjunction with independent checkpointing. This approach is generally known as message logging. In pessimistic message logging scheme <ref> [4, 5, 7] </ref> each message is synchronously logged on stable storage as it is received. When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. <p> However this algorithm makes an assumption that concurrent invocation of algorithm is not in effect. The algorithm presented by Leu and Bhargava [19] allow higher concurrency among the invocation of checkpoint and rollback algorithm. Some other interesting variations of the above checkpointing schemes are found in <ref> [4, 20] </ref>. In the algorithm presented by Birman et.al.[4] for implementing k-resilient objects, an independent checkpointing scheme is used in conjunction with the retained results.
Reference: [5] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> "Fault tolerance under UNIX," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14]. <p> Simple independent checkpointing schemes suffer with this problem. This problem can be solved by logging the messages in conjunction with independent checkpointing. This approach is generally known as message logging. In pessimistic message logging scheme <ref> [4, 5, 7] </ref> each message is synchronously logged on stable storage as it is received. When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. <p> Note that by logging CL REPLY and the next CL REQUEST messages together we reduced the message logging time (on an average) by half compared to other similar pessimistic logging schemes <ref> [5, 7] </ref>. Note that once we successfully take the latest state checkpoint we can delete the old state checkpoint and the logged messages. We will explain the recovery algorithm using an example. Refer to the figure 6. For simplicity messages are numbered as m 1 ; m 2 ; etc. <p> Thus the FTC will deliver the reply for m 8 when O 1 is recovered to the state F 1 . 4.4 Discussion In this section we will discuss about the cost of our algorithm (qualitatively) compared to the other checkpointing algorithms <ref> [5, 7, 8, 11] </ref>. The favorable metric to our algorithm is the response time overhead introduced by the checkpointing. As discussed previously, average of this time will be negligible since in general the checkpoints are taken when the object is not servicing any request.
Reference: [6] <author> E. C. Cooper, </author> <title> "Replicated distributed programs," </title> <booktitle> In ACM Symp. on Oper. Syst. Princ., </booktitle> <pages> pp. 63-78, </pages> <year> 1985. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> A few systems also consider synchronous message passing like remote procedure calls <ref> [6, 14] </ref>. Although there exists a duality between object oriented systems and process (and messages) based systems [15, 16], not much work has been done in exploiting the structure and properties of the object oriented systems in providing fault tolerance [15]. <p> This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower. Modular redundancy (or process replication) takes a different approach for fault tolerance <ref> [6, 11, 14, 21, 22] </ref>. This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. <p> The client discards the duplicate replies. In [22] Fred Schneider presents a detailed model for this approach, which he calls a state machine approach for implementing fault tolerant services. He discusses the agreement and the order requirements of the application messages for this scheme. Eric Cooper describes <ref> [6] </ref> replicated procedure call (RPC) mechanism for constructing highly available distributed programs.Pankaj Jalote describes [14] a fault tolerant RPC provided by employing a combination of the modular redundancy approach and the primary standby approach.
Reference: [7] <author> P. Jalote, </author> <title> "Fault tolerant processes," </title> <booktitle> Distributed Computing, </booktitle> <pages> pp. 187-195, </pages> <year> 1989. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14]. <p> Simple independent checkpointing schemes suffer with this problem. This problem can be solved by logging the messages in conjunction with independent checkpointing. This approach is generally known as message logging. In pessimistic message logging scheme <ref> [4, 5, 7] </ref> each message is synchronously logged on stable storage as it is received. When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. <p> Note that by logging CL REPLY and the next CL REQUEST messages together we reduced the message logging time (on an average) by half compared to other similar pessimistic logging schemes <ref> [5, 7] </ref>. Note that once we successfully take the latest state checkpoint we can delete the old state checkpoint and the logged messages. We will explain the recovery algorithm using an example. Refer to the figure 6. For simplicity messages are numbered as m 1 ; m 2 ; etc. <p> Thus the FTC will deliver the reply for m 8 when O 1 is recovered to the state F 1 . 4.4 Discussion In this section we will discuss about the cost of our algorithm (qualitatively) compared to the other checkpointing algorithms <ref> [5, 7, 8, 11] </ref>. The favorable metric to our algorithm is the response time overhead introduced by the checkpointing. As discussed previously, average of this time will be negligible since in general the checkpoints are taken when the object is not servicing any request.
Reference: [8] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Recovery in distributed systems using optimistic message logging and checkpointing," </title> <journal> Journal of Algorithms, </journal> <volume> vol. 11, </volume> <pages> pp. 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. Since this leads to high failure free overhead (synchronously logging messages on stable storage is expensive) optimistic message logging schemes <ref> [19, 8, 13, 9] </ref> were proposed. In this approach messages are logged asynchronously (many messages may be grouped together) on stable storage. When failure occurs, processes coordinate to determine an optimal consistent set of checkpoints and recover from that point. <p> Thus the FTC will deliver the reply for m 8 when O 1 is recovered to the state F 1 . 4.4 Discussion In this section we will discuss about the cost of our algorithm (qualitatively) compared to the other checkpointing algorithms <ref> [5, 7, 8, 11] </ref>. The favorable metric to our algorithm is the response time overhead introduced by the checkpointing. As discussed previously, average of this time will be negligible since in general the checkpoints are taken when the object is not servicing any request.
Reference: [9] <author> R. E. Strom and S. A. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 3, no. 3, </volume> <pages> pp. 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: In this paper we will present a novel scheme for providing such user transparent fault tolerance for objects executing on a distributed object oriented operating system. Various schemes for providing fault tolerance for process/services in a distributed systems do exist in literature <ref> [4, 5, 6, 7, 8, 9] </ref>. Similar to some of those schemes, our scheme uses check-pointing and message logging. However the novelty of our scheme is that, it uses the general 1 This Paper was revised in July 1995. <p> When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. Since this leads to high failure free overhead (synchronously logging messages on stable storage is expensive) optimistic message logging schemes <ref> [19, 8, 13, 9] </ref> were proposed. In this approach messages are logged asynchronously (many messages may be grouped together) on stable storage. When failure occurs, processes coordinate to determine an optimal consistent set of checkpoints and recover from that point.
Reference: [10] <author> E. N. Elnozahy and W. Zwaenepoel, "Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback, and fast output commit," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 41, no. 5, </volume> , <month> May </month> <year> 1992. </year>
Reference-contexts: Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14]. <p> However for the environment we are considering (client-server based environment), we believe that the synchronous logging scheme is the only solution. This is because, in these environments, client objects are short living entities. The interaction of the long living (server) objects with the client objects requires output commit actions <ref> [10] </ref> which requires a synchronous message logging. Thus we have to log all the object invocations synchronously.
Reference: [11] <author> E. N. Elnozahy and W. Zwaenepoel, </author> <title> "An integrated approach to fault tolerance," In Management of Replicated Data, </title> <booktitle> 1992 Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14]. <p> This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower. Modular redundancy (or process replication) takes a different approach for fault tolerance <ref> [6, 11, 14, 21, 22] </ref>. This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. <p> In [21] he also describes an algorithm for resilient objects in broadcast networks, which reduces the number of messages required to keep copies of the object in a consistent state. Elnozahy describes the Manetho system <ref> [11] </ref> which employs both replication and rollback recovery methods for providing transparent fault tolerance for distributed applications. A checkpointing scheme that exploits the structure of object based system is given by Lin and Ahamad [15]. This algorithm uses a consistent checkpointing scheme similar to the algorithm given in [18]. <p> Thus the FTC will deliver the reply for m 8 when O 1 is recovered to the state F 1 . 4.4 Discussion In this section we will discuss about the cost of our algorithm (qualitatively) compared to the other checkpointing algorithms <ref> [5, 7, 8, 11] </ref>. The favorable metric to our algorithm is the response time overhead introduced by the checkpointing. As discussed previously, average of this time will be negligible since in general the checkpoints are taken when the object is not servicing any request.
Reference: [12] <author> L. M. Silva and J. G. Silva, </author> <title> "Global checkpointing for distributed programs," </title> <booktitle> In Symp. Reliab. Distr. Systems, </booktitle> <pages> pp. 155-162, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14].
Reference: [13] <author> A. P. Sistla and J. L. Welch, </author> <title> "Efficient distributed recovery using message logging," </title> <booktitle> In Proc. ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Section 4 presents our algorithm for supporting fault tolerant objects in distributed systems. Section 5 concludes the paper and discusses the future work. 2 Related Work In the literature, the subject of fault tolerance for distributed system is primarily addressed for process based systems with asynchronous message passing <ref> [5, 7, 10, 11, 12, 13] </ref>. A few systems also consider synchronous message passing like remote procedure calls [6, 14]. <p> When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. Since this leads to high failure free overhead (synchronously logging messages on stable storage is expensive) optimistic message logging schemes <ref> [19, 8, 13, 9] </ref> were proposed. In this approach messages are logged asynchronously (many messages may be grouped together) on stable storage. When failure occurs, processes coordinate to determine an optimal consistent set of checkpoints and recover from that point.
Reference: [14] <author> K. Yap, P. Jalote, and S. Tripati, </author> <title> "Fault tolerant remote procedure call," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 48-54, </pages> <year> 1988. </year> <month> 14 </month>
Reference-contexts: A few systems also consider synchronous message passing like remote procedure calls <ref> [6, 14] </ref>. Although there exists a duality between object oriented systems and process (and messages) based systems [15, 16], not much work has been done in exploiting the structure and properties of the object oriented systems in providing fault tolerance [15]. <p> This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower. Modular redundancy (or process replication) takes a different approach for fault tolerance <ref> [6, 11, 14, 21, 22] </ref>. This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. <p> He discusses the agreement and the order requirements of the application messages for this scheme. Eric Cooper describes [6] replicated procedure call (RPC) mechanism for constructing highly available distributed programs.Pankaj Jalote describes <ref> [14] </ref> a fault tolerant RPC provided by employing a combination of the modular redundancy approach and the primary standby approach. In [21] he also describes an algorithm for resilient objects in broadcast networks, which reduces the number of messages required to keep copies of the object in a consistent state.
Reference: [15] <author> L. Lin and M. Ahamad, </author> <title> "Checkpointing and rollback-recovery in distributed object based systems," </title> <booktitle> In FTCS-20, </booktitle> <pages> pp. 97-104, </pages> <year> 1990. </year>
Reference-contexts: A few systems also consider synchronous message passing like remote procedure calls [6, 14]. Although there exists a duality between object oriented systems and process (and messages) based systems <ref> [15, 16] </ref>, not much work has been done in exploiting the structure and properties of the object oriented systems in providing fault tolerance [15]. Techniques for providing fault tolerance can be basically classified into two categories: a) check-pointing and rollback recovery and b) process replication (or modular redundancy). <p> Although there exists a duality between object oriented systems and process (and messages) based systems [15, 16], not much work has been done in exploiting the structure and properties of the object oriented systems in providing fault tolerance <ref> [15] </ref>. Techniques for providing fault tolerance can be basically classified into two categories: a) check-pointing and rollback recovery and b) process replication (or modular redundancy). <p> Elnozahy describes the Manetho system [11] which employs both replication and rollback recovery methods for providing transparent fault tolerance for distributed applications. A checkpointing scheme that exploits the structure of object based system is given by Lin and Ahamad <ref> [15] </ref>. This algorithm uses a consistent checkpointing scheme similar to the algorithm given in [18]. However the algorithm given in [18] does not consider the process behavior while deciding the checkpoint and rollback dependencies. But in the algorithm given in [15], the checkpoint and rollback dependencies are derived considering the operational <p> of object based system is given by Lin and Ahamad <ref> [15] </ref>. This algorithm uses a consistent checkpointing scheme similar to the algorithm given in [18]. However the algorithm given in [18] does not consider the process behavior while deciding the checkpoint and rollback dependencies. But in the algorithm given in [15], the checkpoint and rollback dependencies are derived considering the operational behavior of the invoked objects. The basic idea is classify the operations as lookup or modify operations. They assume that the type of operations can be identified in most cases from its source code. <p> Thus by utilizing the semantics of the object operations and invocations the number of objects involved in the checkpointing and rollback are minimized. Our algorithm also uses the behavior of the objects and operations of the objects but quite differently than that used in <ref> [15] </ref>. We do not assume the semantics of the object operations for two reasons. First, it is quite quite difficult to get the semantics of the object operations by parsing the source code (unless we use a special language in which object states are somehow tagged).
Reference: [16] <author> L. V. Mancini and S. K. Srivastava, </author> <title> "Replication within atomic actions and conversations: A case study in fault tolerant duality," </title> <booktitle> In FTCS-19, </booktitle> <pages> pp. 454-461, </pages> <year> 1989. </year>
Reference-contexts: A few systems also consider synchronous message passing like remote procedure calls [6, 14]. Although there exists a duality between object oriented systems and process (and messages) based systems <ref> [15, 16] </ref>, not much work has been done in exploiting the structure and properties of the object oriented systems in providing fault tolerance [15]. Techniques for providing fault tolerance can be basically classified into two categories: a) check-pointing and rollback recovery and b) process replication (or modular redundancy).
Reference: [17] <author> K. M. Chandy and L. Lamport, </author> <title> "Distributed snapshots: Determining global states in distributed systems," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 3, no. 1, </volume> <pages> pp. 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: Since checkpointing is independent, the checkpoints of different processes may not define a consistent state (a consistent global state is one, in which messages are recorded as received only if they are also recorded as sent <ref> [17] </ref>). If the recorded state is not consistent, then while recovering from a crash this may cause rollback of other processes (cascaded rollbacks)[18]. Simple independent checkpointing schemes suffer with this problem. This problem can be solved by logging the messages in conjunction with independent checkpointing. <p> Note that this does not happen in the case of pessimistic message logging case. The recovery is only a local affair. In the consistent checkpointing schemes [18, 19] all processes coordinate the checkpointing activity such that the set of checkpoints form a consistent global state <ref> [17] </ref>. No application related processing is carried out during the execution of the checkpointing algorithm. In the algorithm proposed by Koo and Toueg [18], consistent checkpointing is taken by a two-phase message exchange. This algorithm saves two kinds of checkpoints in the stable storage: tentative and permanent.
Reference: [18] <author> R. Koo and S. Toueg, </author> <title> "Checkpointing and rollback-recovery for distributed systems," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 13, no. 1, </volume> <pages> pp. 23-31, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This may require multiple processes rollback to their earlier state even though they did not fail. Note that this does not happen in the case of pessimistic message logging case. The recovery is only a local affair. In the consistent checkpointing schemes <ref> [18, 19] </ref> all processes coordinate the checkpointing activity such that the set of checkpoints form a consistent global state [17]. No application related processing is carried out during the execution of the checkpointing algorithm. <p> In the consistent checkpointing schemes [18, 19] all processes coordinate the checkpointing activity such that the set of checkpoints form a consistent global state [17]. No application related processing is carried out during the execution of the checkpointing algorithm. In the algorithm proposed by Koo and Toueg <ref> [18] </ref>, consistent checkpointing is taken by a two-phase message exchange. This algorithm saves two kinds of checkpoints in the stable storage: tentative and permanent. <p> A checkpointing scheme that exploits the structure of object based system is given by Lin and Ahamad [15]. This algorithm uses a consistent checkpointing scheme similar to the algorithm given in <ref> [18] </ref>. However the algorithm given in [18] does not consider the process behavior while deciding the checkpoint and rollback dependencies. But in the algorithm given in [15], the checkpoint and rollback dependencies are derived considering the operational behavior of the invoked objects. <p> A checkpointing scheme that exploits the structure of object based system is given by Lin and Ahamad [15]. This algorithm uses a consistent checkpointing scheme similar to the algorithm given in <ref> [18] </ref>. However the algorithm given in [18] does not consider the process behavior while deciding the checkpoint and rollback dependencies. But in the algorithm given in [15], the checkpoint and rollback dependencies are derived considering the operational behavior of the invoked objects. The basic idea is classify the operations as lookup or modify operations.
Reference: [19] <author> P. Y. Leu and B. Bargava, </author> <title> "Concurrent robust checkpointing and rollback recovery in distributed systems," </title> <booktitle> In 4th Int. Conf. on Data Engineering, </booktitle> <pages> pp. 154-163, </pages> <year> 1988. </year>
Reference-contexts: When a process fails it can recover locally (without communicating with the other processes) by re-processing the messages from the stable storage log. Since this leads to high failure free overhead (synchronously logging messages on stable storage is expensive) optimistic message logging schemes <ref> [19, 8, 13, 9] </ref> were proposed. In this approach messages are logged asynchronously (many messages may be grouped together) on stable storage. When failure occurs, processes coordinate to determine an optimal consistent set of checkpoints and recover from that point. <p> This may require multiple processes rollback to their earlier state even though they did not fail. Note that this does not happen in the case of pessimistic message logging case. The recovery is only a local affair. In the consistent checkpointing schemes <ref> [18, 19] </ref> all processes coordinate the checkpointing activity such that the set of checkpoints form a consistent global state [17]. No application related processing is carried out during the execution of the checkpointing algorithm. <p> Koo and Toueg show that this algorithm is optimal in the sense that, it forces a minimum number of processes to take a checkpoint and to rollback. However this algorithm makes an assumption that concurrent invocation of algorithm is not in effect. The algorithm presented by Leu and Bhargava <ref> [19] </ref> allow higher concurrency among the invocation of checkpoint and rollback algorithm. Some other interesting variations of the above checkpointing schemes are found in [4, 20]. In the algorithm presented by Birman et.al.[4] for implementing k-resilient objects, an independent checkpointing scheme is used in conjunction with the retained results.
Reference: [20] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Sender-based message logging," </title> <booktitle> In Digest of papers: The 17 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 14-19, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: However this algorithm makes an assumption that concurrent invocation of algorithm is not in effect. The algorithm presented by Leu and Bhargava [19] allow higher concurrency among the invocation of checkpoint and rollback algorithm. Some other interesting variations of the above checkpointing schemes are found in <ref> [4, 20] </ref>. In the algorithm presented by Birman et.al.[4] for implementing k-resilient objects, an independent checkpointing scheme is used in conjunction with the retained results. <p> During the recovery, these retained results is available for the failed processes (the call is not re-executed). The sender based message logging scheme was proposed by Johnson and Zwaenpoel <ref> [20] </ref>. This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower.
Reference: [21] <author> P. Jalote, </author> <title> "Resilient objects in broadcast networks," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 15, no. 1, </volume> <pages> pp. 68-72, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower. Modular redundancy (or process replication) takes a different approach for fault tolerance <ref> [6, 11, 14, 21, 22] </ref>. This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. <p> Eric Cooper describes [6] replicated procedure call (RPC) mechanism for constructing highly available distributed programs.Pankaj Jalote describes [14] a fault tolerant RPC provided by employing a combination of the modular redundancy approach and the primary standby approach. In <ref> [21] </ref> he also describes an algorithm for resilient objects in broadcast networks, which reduces the number of messages required to keep copies of the object in a consistent state.
Reference: [22] <author> F. Schneider, </author> <title> "Implementing fault tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: This algorithm can tolerate only one fault in the system (one node crash). But the message is logged in the volatile storage (main memory), and thus the message logging overhead is substantially lower. Modular redundancy (or process replication) takes a different approach for fault tolerance <ref> [6, 11, 14, 21, 22] </ref>. This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. <p> This approach generally assumes a client-server based distributed system. The server (and maybe the clients too) is replicated. Each replica of the server executes the client request concurrently and sends a reply. The client discards the duplicate replies. In <ref> [22] </ref> Fred Schneider presents a detailed model for this approach, which he calls a state machine approach for implementing fault tolerant services. He discusses the agreement and the order requirements of the application messages for this scheme.
References-found: 22

