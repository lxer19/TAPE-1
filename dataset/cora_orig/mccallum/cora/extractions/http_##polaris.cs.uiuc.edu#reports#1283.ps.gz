URL: http://polaris.cs.uiuc.edu/reports/1283.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: System Z1 Programming Manual  
Author: Kwangkeun Yi and Luddy Harrison 
Note: 1 This work was supported in part by the U.S. Department of Energy under Grant No. DE-FG02-85ER25001 with additional support from NSF under Grant No. NSF CCR 90-24554.  
Date: January 1993  
Address: 465 CSRL, 1308 West Main Street Urbana, IL 61801-2307  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Zahira Ammarguellat. </author> <title> A control-flow normalization algorithm and its complexity. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 237-251, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The important feature of the language is that * It has no iterative construct. All iterative expressions will be expressed in tail-recursive procedure calls. * It has no goto or return. These control constructs are removed by the control flow normalization methods <ref> [1] </ref>. The reader may want to see [9] for the definition of MIL. 4.2.2 Constant Propagation And Alias Analysis An abstract interpreter specification for constant propagation and alias analysis is presented. These two analyses are handled without extra mechanism but those necessary for the standard interpretation (in abstract way).
Reference: [2] <author> Geoffrey L. Burn. </author> <title> Abstract Interpretation and the Parallel Evaluation of Functional Languages. </title> <type> PhD thesis, </type> <institution> Department of Computing, Imperial College, University of London, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: Dvi or postscript file of this manual is also available. 1.4 System Overview The overall configuration of system Z1 is shown in Figure 1.1. 1.4.1 Analysis Generation The input to system Z1 is an abstract interpreter <ref> [6, 7, 2] </ref> specification for a target language. From an abstract interpreter specification, system Z1 generates three C modules: one for domain element management, one for semantics operations, and one for fixpoint computation. These three modules are linked with libraries and the target language parser into an executable program analyzer. <p> The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.5 Input to Z1: An Abstract Interpreter It is the user's job to define an abstract interpreter <ref> [6, 7, 2] </ref> for input to system Z1. An abstract interpreter consists of two things: * Abstract domain definitions. * An abstract interpretation rule over the abstract domains.
Reference: [3] <author> Geoffrey L. Burn. </author> <title> Lazy Functional Languages: Abstract Interpretation and Compilation. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The user is responsible for defining a correct abstract interpreter. Abstract (approximated) evaluation of programs should provide a sufficient information about the programs' run-time behaviors: every run-time behavior must be implied by the information gathered by abstract interpretation. The user may want to see <ref> [8, 5, 3] </ref> for frameworks of designing correct ones.
Reference: [4] <author> Liling Chen and Williams Ludwell Harrison III. </author> <title> An efficient algorithm for complex program analysis. </title> <type> Technical report, </type> <institution> Center for Supercomputing R & D, Univ. of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Figure 1.2 shows a basic algorithm to compute the collecting analysis. In reality, we use an optimized version which iterates, for example, only for a subset of program points whose T X and T Y entries were changed by the previous iteration. We use the algorithm in <ref> [4] </ref>. Note that by means of a separate fixpoint computation driver (Tabulate), an abstract interpreter defi nition, which include neither a fixpoint operator nor a property-collecting mechanism, becomes a collecting analysis specification. 1.7 Snapshots Steps of using system Z1 is: 1. Specify an abstract interpreter in the specification language. 2.
Reference: [5] <author> Patrick Cousot. </author> <title> Semantic foundations of program analysis. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: Theory and Applications, chapter 10. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: The user is responsible for defining a correct abstract interpreter. Abstract (approximated) evaluation of programs should provide a sufficient information about the programs' run-time behaviors: every run-time behavior must be implied by the information gathered by abstract interpretation. The user may want to see <ref> [8, 5, 3] </ref> for frameworks of designing correct ones.
Reference: [6] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: and analysis problems. 1.1 What Z1 Can Do * From a high-level specification, Z1 creates a C code for the interprocedural program analysis. * From a high-level specification, Z1 tunes the analysis in cost and accuracy. * The virtues of Z1 come from the power of the abstract interpretation framework <ref> [6, 7, 8] </ref>. Z1 allows us to specify a detailed analysis for difficult and dynamic lanague features (e.g., aliases, unrestrained pointer manipulation, dynamic memory generations, first-class functions). <p> Dvi or postscript file of this manual is also available. 1.4 System Overview The overall configuration of system Z1 is shown in Figure 1.1. 1.4.1 Analysis Generation The input to system Z1 is an abstract interpreter <ref> [6, 7, 2] </ref> specification for a target language. From an abstract interpreter specification, system Z1 generates three C modules: one for domain element management, one for semantics operations, and one for fixpoint computation. These three modules are linked with libraries and the target language parser into an executable program analyzer. <p> The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.5 Input to Z1: An Abstract Interpreter It is the user's job to define an abstract interpreter <ref> [6, 7, 2] </ref> for input to system Z1. An abstract interpreter consists of two things: * Abstract domain definitions. * An abstract interpretation rule over the abstract domains.
Reference: [7] <author> Patrick Cousot and Radhia Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: and analysis problems. 1.1 What Z1 Can Do * From a high-level specification, Z1 creates a C code for the interprocedural program analysis. * From a high-level specification, Z1 tunes the analysis in cost and accuracy. * The virtues of Z1 come from the power of the abstract interpretation framework <ref> [6, 7, 8] </ref>. Z1 allows us to specify a detailed analysis for difficult and dynamic lanague features (e.g., aliases, unrestrained pointer manipulation, dynamic memory generations, first-class functions). <p> Dvi or postscript file of this manual is also available. 1.4 System Overview The overall configuration of system Z1 is shown in Figure 1.1. 1.4.1 Analysis Generation The input to system Z1 is an abstract interpreter <ref> [6, 7, 2] </ref> specification for a target language. From an abstract interpreter specification, system Z1 generates three C modules: one for domain element management, one for semantics operations, and one for fixpoint computation. These three modules are linked with libraries and the target language parser into an executable program analyzer. <p> The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.5 Input to Z1: An Abstract Interpreter It is the user's job to define an abstract interpreter <ref> [6, 7, 2] </ref> for input to system Z1. An abstract interpreter consists of two things: * Abstract domain definitions. * An abstract interpretation rule over the abstract domains.
Reference: [8] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation frameworks. </title> <type> Technical Report LIX/RR/92/10, </type> <institution> Ecole Polytechnique, </institution> <year> 1992. </year>
Reference-contexts: and analysis problems. 1.1 What Z1 Can Do * From a high-level specification, Z1 creates a C code for the interprocedural program analysis. * From a high-level specification, Z1 tunes the analysis in cost and accuracy. * The virtues of Z1 come from the power of the abstract interpretation framework <ref> [6, 7, 8] </ref>. Z1 allows us to specify a detailed analysis for difficult and dynamic lanague features (e.g., aliases, unrestrained pointer manipulation, dynamic memory generations, first-class functions). <p> The user is responsible for defining a correct abstract interpreter. Abstract (approximated) evaluation of programs should provide a sufficient information about the programs' run-time behaviors: every run-time behavior must be implied by the information gathered by abstract interpretation. The user may want to see <ref> [8, 5, 3] </ref> for frameworks of designing correct ones.
Reference: [9] <author> Williams Ludwell Harrison III and Zahira Ammarguellat. </author> <title> A program's eye view of miprac. </title> <editor> In D. Gel-ernter, A. Nicolau, and D. Padua, editors, </editor> <title> Languages and Compilers for Parallel Computing (Also as a UIUC CSRD Report 1227). </title> <publisher> MIT Press, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: System Z1 does not generate the syntax tree, nor does it provide any operator to access its nodes. The user must write C procedures for those operations and use them as foreign procedures. Currently, we have implemented ANSI C, FORTRAN, and SCHEME front-ends for an intermediate language MIL (MIPRAC <ref> [9] </ref> Intermediate Language), along with a set of routines to access MIL programs, so that Z1 may be used to analyze programs in these source languages. 2.10 Error and Warning Messages Z1 issues two kind messages while it compiles the input specification: warning and error messages. <p> The store components of the post-states that are associated with the input program points will show us which variable stays constant. 32 4.2 Real Examples 33 4.2 Real Examples 4.2.1 Target Language We have the following target language. It is called MIL (MIPRAC Interprocedural Language <ref> [9] </ref>). We have ANSI C, FORTRAN, and SCHEME front-ends already built for the target language. The abstract syntax of MIL is as follows. <p> The important feature of the language is that * It has no iterative construct. All iterative expressions will be expressed in tail-recursive procedure calls. * It has no goto or return. These control constructs are removed by the control flow normalization methods [1]. The reader may want to see <ref> [9] </ref> for the definition of MIL. 4.2.2 Constant Propagation And Alias Analysis An abstract interpreter specification for constant propagation and alias analysis is presented. These two analyses are handled without extra mechanism but those necessary for the standard interpretation (in abstract way).
Reference: [10] <author> Paul Hudak and Jonathan Young. </author> <title> Collecting interpretations of expressions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 269-290, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: We call this a collecting analysis <ref> [10] </ref>. How can an interpreter definition be a specification of a collecting analysis? An interpreter is a function that defines, for each language construct, its evaluation rule. Each evaluation rule is a state transformer: a function from a pre-state to a post-state.
Reference: [11] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative alorithm. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: An abstract interpreter consists of two things: * Abstract domain definitions. * An abstract interpretation rule over the abstract domains. From the perspective of the conventional data flow analysis framework <ref> [12, 11] </ref>, the abstract domains correspond to data flow value spaces, which is modeled as semi-lattices, and the interpretation rule corresponds to the flow value transformation functions associated with the flow graph nodes. The user is responsible for defining a correct abstract interpreter.
Reference: [12] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, 77. </pages>
Reference-contexts: An abstract interpreter consists of two things: * Abstract domain definitions. * An abstract interpretation rule over the abstract domains. From the perspective of the conventional data flow analysis framework <ref> [12, 11] </ref>, the abstract domains correspond to data flow value spaces, which is modeled as semi-lattices, and the interpretation rule corresponds to the flow value transformation functions associated with the flow graph nodes. The user is responsible for defining a correct abstract interpreter.
Reference: [13] <author> Kwangkeun Yi and Williams Ludwell Harrison III. </author> <title> Automatic generation and management of interpro-cedural program analyses. </title> <booktitle> In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <volume> pages 246-259 (also as CSRD Report No. 1260), </volume> <month> January </month> <year> 1993. </year> <month> 52 </month>
Reference-contexts: This is because a program analysis in the abstract interpretation framework is viewed as an abstract simulation of input programs. (The reader may want to see <ref> [13] </ref> for more detailed discussion about the framework's merits.) * Z1 provides the run-time supports (e.g. garbage collection), and geneates utility procedures (e.g. data type pretty printers, dump/restore routines for the analysis result) needed to debug the input specification and to examine the analysis result.
References-found: 13

