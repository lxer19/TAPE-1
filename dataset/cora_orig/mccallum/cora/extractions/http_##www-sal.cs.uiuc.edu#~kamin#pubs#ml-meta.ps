URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/ml-meta.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: s-kamin@uiuc.edu  
Title: Standard ML as a Meta-Programming Language  
Author: Samuel Kamin 
Date: September 20, 1996  
Address: Urbana, Illinois  
Affiliation: Computer Science Dept. University of Illinois  
Abstract: Meta-programming languages, or program generators, are languages whose programs produce programs in other languages. We show how Standard ML makes an excellent meta-programming language, by adding appropriate program-valued | by which we mean string-valued | operations for each domain. We do so by giving four examples of meta-programming languages: a top-down parser generator; a "geometric region server" language modelled on one developed at Yale; a version of the "Message Specification Language," developed at Oregon Graduate Institute; and a pretty-printing specification language. Embedding meta-programming languages in ML in this way is easy to do, and the result is a language that, unlike most meta-programming languages, is higher-order. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ahmed, D. Gelernter, </author> <title> Program builders as alternatives to high-level languages, </title> <institution> Yale Univ. C.S. Dept. </institution> <type> TR 887, </type> <month> November </month> <year> 1991. </year>
Reference-contexts: We illustrate how this language structure can be useful in meta-programming. 1.1 Related work Meta-programming is a very common activity, but meta-programming languages do not always seem to be considered as full-fledged languages, with data types, control structures, and so on. Examples include Gelernter's program builders <ref> [1] </ref>, and Waters's KBEmacs [14]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations.
Reference: [2] <author> B. Balzer, N. Goldman, D. Wile, </author> <title> Rationale and Support for Domain Specific Languages, </title> <journal> USC/Information Sciences Institute, </journal> <note> available at http://www.isi.edu/software-sciences/dssa/dssls/dssls.html. </note>
Reference-contexts: Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI [3] (on which section 5 of this paper is based) and at ISI <ref> [2] </ref> is specifically aimed at the development of meta-programming languages. In both cases, the meta-program is translated to a very-high-level language, from which an imperative language program is extracted. Our approach is more direct: the meta-programming language provides operations that manipulate programs, not specifications.
Reference: [3] <author> J. Bell, F. Bellegarde, J. Hook, R.B. Kieburtz, A. Kotov, J. Lewis, L. McKinney, D.P. Oliva, T. Shear, L. Tong, L. Walton, and T. Zhou, </author> <title> Software design for reliabiity and reuse: A proof-of-concept demonstration, </title> <address> TRI-Ada '94. </address>
Reference-contexts: The metaprogram is remarkably similar to the original. fl Supported by NSF Contract CCR 93-03043 1 * Message Specification Language. This language was developed at Oregon Graduate Institute <ref> [3, 13] </ref> as an experiment in using domain-specific languages to promote code reuse in a specialized class of programs. * Pretty-printer. Pretty-printing specifications are translated to C++ code to perform the pretty-printing. <p> Examples include Gelernter's program builders [1], and Waters's KBEmacs [14]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI <ref> [3] </ref> (on which section 5 of this paper is based) and at ISI [2] is specifically aimed at the development of meta-programming languages. In both cases, the meta-program is translated to a very-high-level language, from which an imperative language program is extracted. <p> &gt; 0.0) && ((((259.0-p.x)* ( 62.0- 25.0) - ( 25.0-p.y)*(118.0-259.0)) &gt; 0.0) && 1))))) The Message Specification Language, or MSL, was designed as an approach to engineering reusable code in the domain of "message translation and validation." This is a domain of programming which has been studied by software engineers <ref> [3, 10] </ref> precisely as a model area for the study of software re-use. The problem is to translate and validate incoming "messages"|bit streams| from a variety of sources in a variety of formats. <p> The problem is to translate and validate incoming "messages"|bit streams| from a variety of sources in a variety of formats. The formats of these messages are described in semi-formal "interface control documents." An example is given in Figure 2 of <ref> [3] </ref> and reproduced here as Figure 1. The translation process involves pulling bits off the incoming stream and storing appropriate values in records; validation is simply checking that the messages have the required form. In past work, the language in which translation and validation has been performed is ADA. <p> We will describe only delim, asc2int, seq, and alt. Given an expression e denoting a character in the C++ programming (usually a character constant, though it could be a variable), delim e produce C++ code to check if the current byte 3 There is no corresponding figure given in <ref> [3] </ref> with which to compare our Figure 5. 13 System.Control.quotation := true; val % = implode o (map (fn QUOTE x =&gt; x|ANTIQUOTE x=&gt;x)); type expr = string; type predicate = expr; type statement = string; type fieldname = string; abstype bitsource = source of expr * expr (* byte array <p> They should correspond to variant records, or tagged unions. In this version of MSL-in-SML, they are treated as untagged unions. 19 We have attempted to show that much of the value of MSL, as defined in <ref> [3] </ref>, can be obtained directly in a functional language like SML. There remains some syntactic awkwardness, but in general the language illustrated in Figure 4 (MSL-in-SML) is not very much different from the one illustrated in Figure 2 (MSL). As compared to that of [3], this approach has several advantages: * <p> value of MSL, as defined in <ref> [3] </ref>, can be obtained directly in a functional language like SML. There remains some syntactic awkwardness, but in general the language illustrated in Figure 4 (MSL-in-SML) is not very much different from the one illustrated in Figure 2 (MSL). As compared to that of [3], this approach has several advantages: * It is much simpler to produce a new language this way. The MSL language of Figure 2 is specified with the usual context-free syntax, and sophisticated language-development tools. * The language designer has complete control over the code that is generated.
Reference: [4] <author> W. E. Carlson, P. Hudak, M. P. Jones, </author> <title> An experiment using Haskell to prototype "Geometric Region Servers" for navy command and control, </title> <institution> Research Report YALEU/DCS/RR-1031, Yale Univ. C. S. Dept., </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The examples are: * Top-down parser generator. This is a well known example of "combinator-style" programming [8]. The combinators used in developing a parser in a functional language can be redefined to generate a parser in C++. * Geometric region server. The Haskell code presented by Carlson et al. <ref> [4] </ref> to solve this problem directly can be modified to produce C++ code that solves it. The metaprogram is remarkably similar to the original. fl Supported by NSF Contract CCR 93-03043 1 * Message Specification Language. <p> of parsing rules by mapping over a list of binary operators applies with very little change: "Exp" ::= fold (op ||) (map (fn bop =&gt; (nonterm "Exp") ++ (term bop) ++ (nonterm "Exp")) ["+", "-", "*", "/"]) (fn lab =&gt; %`return false;`); 4 Geometric region server Carlson, Hudak, and Jones <ref> [4] </ref> report an experiment in which a Haskell program was developed as a prototype "geometric region server" for Naval command and control. <p> We give a sampling of the dozen or so such functions defined in <ref> [4] </ref>. * Circular region with given radius: (* circle: real -&gt; Region *) fun circle r = fn p =&gt; sqrdist p &lt; r*r; * The halfplane to the left of the line joining two points: (* halfplane: Point -&gt; Point -&gt; Region *) fun halfplane a b = let fun <p> As an example of these operations, one of the regions defined in <ref> [4] </ref> is the "tight zone": (convexPoly [Pt (0.0,5.0), Pt (118.0,32.0), Pt (118.0,62.0), Pt (0.0,25.0)]) (convexPoly [Pt (118.0,32.0), Pt (259.0,5.0), Pt (259.0, 25.0), Pt (118.0,62.0)]) It produces a region which, when applied to the C++ expression p, produces this C++ predicate: (((((0.0-p.x)* ( 32.0- 5.0) - ( 5.0-p.y)*(118.0-0.0)) &gt; 0.0) && ((((118.0-p.x)*
Reference: [5] <author> D. Carr, </author> <title> Glue: A tree-based program development and maintenance system which uses explicit, typed, higher order cliches, M.S. </title> <type> Thesis, </type> <institution> Univ. of Illinois C.S. Dept. Report UIUCDCS-R-89-1495, </institution> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: Sheard and Nelson have specifically addressed the use of ML as a meta-language for itself [11]. Their concern is to guarantee the type correctness of generated ML programs. In earlier work <ref> [5] </ref>, we advocated the use of "higher-order macros," in the context of a tree editor, as a way to allow for a very flexible presentation of programs.
Reference: [6] <author> P. Hudak, </author> <title> Building domain-specific embedded languages, </title> <booktitle> position paper for Workshop on Software Engineering and Programming Languages, </booktitle> <address> Cambridge, MA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In our Emacs "glue-mode" one could present a program with the inner loop at the top of the tree, providing macros that would unmangle the tree structure into a linear representation. This could be regarded as a generalized "literate programming" mode. 2 Paul Hudak and his associates, in <ref> [6, 7] </ref>, emphasize the notion that a set of definitions in a functional language can be regarded as a new language. This is our basic position as well; we are simply applying it in the domain of meta-programming. 2 A note on the meta-language Our meta-language is Standard ML.
Reference: [7] <author> P. Hudak, T. Makucevich, S. Gadde, B. Whong, </author> <title> Haskore music notation: An algebra of music, </title> <journal> J. Func. Prog., </journal> <note> to appear. </note>
Reference-contexts: In our Emacs "glue-mode" one could present a program with the inner loop at the top of the tree, providing macros that would unmangle the tree structure into a linear representation. This could be regarded as a generalized "literate programming" mode. 2 Paul Hudak and his associates, in <ref> [6, 7] </ref>, emphasize the notion that a set of definitions in a functional language can be regarded as a new language. This is our basic position as well; we are simply applying it in the domain of meta-programming. 2 A note on the meta-language Our meta-language is Standard ML.
Reference: [8] <author> G. Hutton, </author> <title> Higher-order functions for parsing, </title> <journal> J. Func. Prog. </journal> <volume> 2(3), </volume> <pages> 323-343, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: All of our examples are meta-programming languages, intended to aid in the production of C++ programs. The examples are: * Top-down parser generator. This is a well known example of "combinator-style" programming <ref> [8] </ref>. The combinators used in developing a parser in a functional language can be redefined to generate a parser in C++. * Geometric region server. The Haskell code presented by Carlson et al. [4] to solve this problem directly can be modified to produce C++ code that solves it.
Reference: [9] <author> S. Kamin, </author> <title> Report of a workshop on future directions in programming languages and compilers, </title> <journal> ACM SIGPLAN Notices 30 (7), </journal> <month> July </month> <year> 1995, </year> <pages> 9-28. </pages>
Reference-contexts: Pretty-printing specifications are translated to C++ code to perform the pretty-printing. This work is a contribution to the program laid out in the workshop report <ref> [9] </ref>: to aid in the design and implementation of special-purpose languages. The workshop's conclusions included the finding that these languages represent the greatest potential for application of research in programming languages. Our view is that many special-purpose languages are far more special than their purpose requires.
Reference: [10] <author> C. Plinta, K. Lee, and M. Rissman, </author> <title> A model solution for C 3 I message translation and validation, </title> <type> Technical Report CMU/SEI-89-TR-12, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: &gt; 0.0) && ((((259.0-p.x)* ( 62.0- 25.0) - ( 25.0-p.y)*(118.0-259.0)) &gt; 0.0) && 1))))) The Message Specification Language, or MSL, was designed as an approach to engineering reusable code in the domain of "message translation and validation." This is a domain of programming which has been studied by software engineers <ref> [3, 10] </ref> precisely as a model area for the study of software re-use. The problem is to translate and validate incoming "messages"|bit streams| from a variety of sources in a variety of formats.
Reference: [11] <author> T. Sheard, N. Nelson, </author> <title> Type safe abstractions using program generators, </title> <type> OGI Tech. </type> <institution> Rpt. </institution> <month> 95-013. </month> <title> [12] . Standard ML of New Jersey User's Guide, </title> <month> February </month> <year> 1993. </year>
Reference-contexts: Furthermore, that language has powerful features inherited from its base language (ML), and the translation is not dependent upon the success of a compiler in compiling a very-high-level language down to imperative code. Sheard and Nelson have specifically addressed the use of ML as a meta-language for itself <ref> [11] </ref>. Their concern is to guarantee the type correctness of generated ML programs. In earlier work [5], we advocated the use of "higher-order macros," in the context of a tree editor, as a way to allow for a very flexible presentation of programs.
Reference: [13] <author> L. Walton and J. Hook, </author> <title> Message Specification Language (MSL): Reference Manual, Revision: </title> <institution> 1.8, Oregon Graduate Institute, </institution> <month> Oct. 6, </month> <year> 1994. </year>
Reference-contexts: The metaprogram is remarkably similar to the original. fl Supported by NSF Contract CCR 93-03043 1 * Message Specification Language. This language was developed at Oregon Graduate Institute <ref> [3, 13] </ref> as an experiment in using domain-specific languages to promote code reuse in a specialized class of programs. * Pretty-printer. Pretty-printing specifications are translated to C++ code to perform the pretty-printing.
Reference: [14] <author> R. C. Waters, </author> <title> The Programmer's Apprentic: A session with KBEmacs, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-11(11), </volume> <pages> 1296-1320, </pages> <month> Nov. </month> <year> 1985. </year> <month> 31 </month>
Reference-contexts: Examples include Gelernter's program builders [1], and Waters's KBEmacs <ref> [14] </ref>. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations.
References-found: 13

