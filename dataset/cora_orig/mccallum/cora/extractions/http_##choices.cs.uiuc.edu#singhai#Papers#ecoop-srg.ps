URL: http://choices.cs.uiuc.edu/singhai/Papers/ecoop-srg.ps
Refering-URL: http://choices.cs.uiuc.edu/singhai/Papers/opt.html
Root-URL: http://www.cs.uiuc.edu
Email: E-mail: sane@iconcomp.com,  E-mail: fsinghai,rhcg@uiuc.edu,  
Phone: 2  
Title: Framework Design for End-to-End Optimization  
Author: Aamod Sane Ashish Singhai ;? and Roy H. Campbell 
Web: Web: http://www.iconcomp.com  Web: http://choices.cs.uiuc.edu  
Address: 11940 Jollyville Road, Suite 300N, Austin, TX 78759 USA.  1304 W. Springfield Avenue, Urbana, IL 61801 USA.  
Affiliation: 1 Icon Computing Inc.,  Department of Computer Science, University of Illinois,  
Date: July 1998  
Note: Appears in the Proceedings of the 12th ECOOP, Brussels,  
Abstract: Framework optimizations capitalize on object dependencies, while framework flexibility and composability demand object independence. This paper shows how to balance these conflicting needs using new design techniques. These techniques embody the observation that common optimizations can be realized by reifying and tuning object interactions. Their application is illustrated for two complex frameworks: a virtual memory framework and a framework for distributed objects. A catalog of patterns that covers common optimizations is also presented.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Mark B. Abbott and Larry L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Even when it does write them, it batches neighboring disk blocks together and writes them using only one disk access. Other examples: delaying marshaling of arguments in RPC until sending them and using scatter-gather hardware to collect memory fragments (see Sect. 6 for details); direct demultiplexing for network read <ref> [1] </ref>. 4.4 Eager Evaluation Eager evaluation is the dual of lazy evaluation. It computes some results that may not be needed immediately. <p> The research on Paths [20] comes closest to our work. It introduces a path as an explicit abstraction that connect the layers in an operating system and describes optimizations along a path. Clark [6] and others describe many optimizations for network protocols. In <ref> [1] </ref> Abbot et. al. describe "Integrated Layer Processing (ILP)," their technique for optimizing protocols. ILP also relies upon fusing protocol layers to reduce copying and expediting protocol processing. Schmidt et. al. [11] document a comprehensive set of optimizations for Object Request Brokers (ORBs).
Reference: 2. <author> Robert Allen. </author> <title> A Formal Approach to Software Architecture. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Carnegie Mellon University, Pittsburgh, </institution> <month> May </month> <year> 1997. </year> <month> CMU-CS-97-144. </month>
Reference-contexts: For example, encoding a pipe that connects two communicating programs with procedure calls obscures the data flow aspects. This paper was a starting point for our work. An architecture description language UniCon [34] and a formal description language Wright <ref> [2] </ref> explicitly model connections. The Demeter project introduces a notation for making the structure of frameworks explicit, and express framework traversals as regular expressions [18]. This helps in framework evolution, because changes to the object structure can be expressed by changing the structure description rather than method code.
Reference: 3. <author> Aart J. C. Bik and Harry A. G. Wijshoff. </author> <title> On automatic data structure selection and code generation for sparse computations. </title> <booktitle> In Proceedings of the Workshop on Languages and Compilers for Parallel Computing (LCPC), volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 57-75. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: Web browsers relax security checks if the applet source is the local machine. Operating systems share read-only code segments among processes. Spreadsheets can use finite precision for money but arbitrary precision for other numerical data. Numerical packages supply different algorithms for different types of matrices <ref> [3] </ref> such as positive definite, upper triangular, symmetric, dense, and sparse. They also precondition data for algorithms. Web servers may perform lossy compression on data depending upon the client type (on-line distillation [9]). 4.6 Memory Usage Optimizations Memory optimizations are among the most widely studied optimizations.
Reference: 4. <author> Roy Campbell, Nayeem Islam, Peter Madany, and David Raila. </author> <title> Experiences designing and implementing Choices: an object-oriented system in C++. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: This gives framework builders a method for analyzing and developing whole-framework optimizations in a systematic way. Overview. In Sect. 2 we present examples of framework optimizations selected from a wide variety of frameworks that we have built over the years in the Choices operating system <ref> [4] </ref> and other projects. The frameworks include a filesystem framework [40], a virtual memory framework [25], an instrumentation framework [30], and a video conferencing framework [39]. Sect. 3 analyses these examples, motivating a set of objects that make object relationships first-class. <p> Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 2.2 Changing concurrency control in virtual memory Consider a pagefault task in a virtual memory framework <ref> [4] </ref>. The task locates the faulting virtual page using AddressSpace, allocates a physical page using PhysicalPageStore, retrieves swapped page contents from the file system, updates VirtualMap to make the page accessible, and updates PhysicalMap.
Reference: 5. <author> Zhigang Chen. </author> <title> Coding and transmission of digital video on the internet. </title> <type> Technical Report UIUCDCS-R-1997-2016, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <year> 1997. </year>
Reference-contexts: Message driven scheduling schedules tasks when their message arrive. Protocols Knowledge about the type of communication, transport medium, and data helps design custom protocols to optimize factors such as latency, buffer space, and throughput. Multimedia transmission protocols can be optimized for bursty loss in the Internet to avoid retransmissions <ref> [5] </ref>. Protocols for mobile computing are optimized to reduce expensive transmission from mobile hosts. Parallel distributed programs use protocols that exploit com munication patterns [14]. Communication Optimizations In addition to protocols, communication across endpoints can also be optimized. Use asynchronous (non-blocking) communication for overlapping communication with computation.
Reference: 6. <author> D. Clark, V. Jocabson, J. Romkey, and M. Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> Jun </month> <year> 1989. </year>
Reference-contexts: If the other result is an extension of the first (e.g., fetching two disk blocks, instead of one), modify arguments (e.g., change the number of blocks to read in DataObject) to get the extended result. Examples Computing checksum of a network packet as a side effect of copying it <ref> [6] </ref>, TCP header prediction [6], prefetching in databases and file systems. 4.5 Using Type Information Data are typed, so some of their properties are known a priori. Therefore, we can substitute faster algorithms that exploit their properties. <p> Examples Computing checksum of a network packet as a side effect of copying it <ref> [6] </ref>, TCP header prediction [6], prefetching in databases and file systems. 4.5 Using Type Information Data are typed, so some of their properties are known a priori. Therefore, we can substitute faster algorithms that exploit their properties. <p> The research on Paths [20] comes closest to our work. It introduces a path as an explicit abstraction that connect the layers in an operating system and describes optimizations along a path. Clark <ref> [6] </ref> and others describe many optimizations for network protocols. In [1] Abbot et. al. describe "Integrated Layer Processing (ILP)," their technique for optimizing protocols. ILP also relies upon fusing protocol layers to reduce copying and expediting protocol processing.
Reference: 7. <author> A. Dave, N. Islam, and R. H. Campbell. </author> <title> A low-latency scalable locking algorithm for shared memory multiprocessors. </title> <booktitle> In Proceedings of the 6th Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 10-17. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Continuations, which may reduce thread usage, can be implemented using TaskObjects and DataObjects (see Sect. 5.3 for examples). Examples Databases use intention mode locking [21] to improve concurrency and avoid deadlock. Parts of operating systems disable interrupts to implement critical sections. Array locks <ref> [7] </ref> distribute accesses over a larger region of memory to reduce contention in multiprocessors. 4.8 Structure Directed Optimization Just as algorithms are optimized for a given data structure, framework tasks can be optimized for a given organization of framework objects.
Reference: 8. <author> Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom. Flick: </author> <title> A flexible, optimizing IDL compiler. </title> <booktitle> In ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 44-56, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Optimizing Memory Usage. We use the type information for arguments, results, and Requests (Sect. 4.5) to optimize memory usage. Other memory usage optimizations (Sect. 4.6) <ref> [11, 8] </ref> are as follows.
Reference: 9. <author> Armando Fox, Steven D. Gribble, Eric A. Brewer, and Elan Amir. </author> <title> Adapting to network and client variability via on-demand dynamic distillation. </title> <booktitle> In Proceedings of the 7th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 160-170. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: Numerical packages supply different algorithms for different types of matrices [3] such as positive definite, upper triangular, symmetric, dense, and sparse. They also precondition data for algorithms. Web servers may perform lossy compression on data depending upon the client type (on-line distillation <ref> [9] </ref>). 4.6 Memory Usage Optimizations Memory optimizations are among the most widely studied optimizations. The amount of memory available to a framework is limited, and dynamic allocations and releases are slow. Therefore, we need to optimize memory usage for improving speed and reducing the memory footprint. <p> The basic objects provide methods to perform individual operations. As discussed in Sect. 3, we connect them through the following in teraction objects. MarshalTasks produce network representation of Arguments and Results. They may use conventional representations such as XDR, or non-conventional marshaling mechanisms such as compression or distillation <ref> [9] </ref>. - ClientCallTasks implement the client side of a remote call. It involves allocating memory, invoking MarshalTask, sending the marshaled data on the corresponding Channel and doing the inverse processing for the Result. - ServiceTasks implement the server side of a remote call.
Reference: 10. <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Different applications can tailor these objects in different ways, while the basic objects in the framework remain unchanged. Implementing TaskObject, DataObject, StructureObject using patterns. Various design pattern catalogs (such as <ref> [10] </ref>) suggest patterns that can be used to implement task, data and structure objects. For instance, a TaskObject can be implemented as a Command or a Mediator, and may use patterns like State, or techniques like Object-Oriented State Machines [27]. Selection between specialized TaskObjects may be implemented as a Strategy. <p> Tasks like pagefault and pageout become PageFaultTask and PageOutTask. Their parameters, results, and the objects they visit are recorded in a VMData object. The virtual memory system as a whole is represented by VMSystem, a StructureObject implemented as a Facade <ref> [10] </ref>. Domain also serves as a Struc-tureObject, representing the virtual memory objects associated with particular processes. 4 The idea of optimizing via reified object relationships was developed while implementing this framework; our description pretends as if this idea was applied from the beginning.
Reference: 11. <author> A. Gokhale and D. C. Schmidt. </author> <title> Principles for optimizing corba internet inter-orb protocol performance. </title> <booktitle> In Proceedings of the 31st Hawaii International Conference onf System Sciences, </booktitle> <pages> pages 375-386, </pages> <month> January </month> <year> 1998. </year> <note> (to appear). </note>
Reference-contexts: Optimizing Memory Usage. We use the type information for arguments, results, and Requests (Sect. 4.5) to optimize memory usage. Other memory usage optimizations (Sect. 4.6) <ref> [11, 8] </ref> are as follows. <p> Clark [6] and others describe many optimizations for network protocols. In [1] Abbot et. al. describe "Integrated Layer Processing (ILP)," their technique for optimizing protocols. ILP also relies upon fusing protocol layers to reduce copying and expediting protocol processing. Schmidt et. al. <ref> [11] </ref> document a comprehensive set of optimizations for Object Request Brokers (ORBs). This paper is among the first works on applying networking optimizations to distributed object systems. We distinguish our work from the above in that we show how to apply optimizations to arbitrary frameworks.
Reference: 12. <author> N. C. Hutchinson and Larry L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Examples RPC frameworks avoid dynamic allocations using buffer pool for requests, operating systems use copy-on-write to share pages, networking frameworks use data structures like mbuf [16] and x-kernel messages <ref> [12] </ref> to add or remove protocol headers without copying. The resource exchanger pattern [28] combines many of these optimizations. 4.7 Concurrency Optimization Concurrent operations on shared objects must be serialized in a framework. When serialization is implemented using locks, the framework must avoid cyclic dependencies.
Reference: 13. <author> IONA Technologies. </author> <title> The Orbix Architecture, </title> <month> November </month> <year> 1996. </year> <note> Available at http: //www.iona.com/Products/Orbix/Architecture/index.html. </note>
Reference-contexts: This task must receive a request, find the server object, unmarshal the arguments, invoke the requested method on the server, and marshal and send the reply, if any. Basic Objects. This suggests the following basic objects for this framework (sim ilar to TAO [29] or Orbix <ref> [13] </ref>). - ObjectRef s represent remote objects locally. A client invokes methods on an ObjectRef. - ActualObjects are server objects that implement the desired functionality. Calls on ObjectRef s are forwarded to the corresponding ActualObjects. Arguments represent the arguments to a method invocation (call).
Reference: 14. <author> N. Islam, A. Dave, and R. H. Campbell. </author> <title> Communication compilation for unreliable networks. </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 188-195, </pages> <month> May </month> <year> 1996. </year> <booktitle> Appears in the Proceedings of the 12th ECOOP, </booktitle> <address> Brussels, </address> <month> July </month> <year> 1998 </year>
Reference-contexts: Multimedia transmission protocols can be optimized for bursty loss in the Internet to avoid retransmissions [5]. Protocols for mobile computing are optimized to reduce expensive transmission from mobile hosts. Parallel distributed programs use protocols that exploit com munication patterns <ref> [14] </ref>. Communication Optimizations In addition to protocols, communication across endpoints can also be optimized. Use asynchronous (non-blocking) communication for overlapping communication with computation. Avoid data conversion to a common format if both endpoints use same data representation.
Reference: 15. <author> Gregor Kiczales, John Lamping, Cristina Videira Lopes, Anurag Mendhekar, and Gail Murphy. </author> <title> Open implementation design guidelines. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 481-490, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: The purpose of these proposals is to ease evolution of systems and make them easier to understand. Reflective systems [38, 23] advocate reifying many aspects of objects. Kicza-les <ref> [15] </ref> presents a design methodology, "Open Analysis and Design," which suggests incorporating reflective interfaces for customization. Shaw [33] argues that the connections between components deserve first-class status. For example, encoding a pipe that connects two communicating programs with procedure calls obscures the data flow aspects.
Reference: 16. <author> S. J. Le*er, M. K. McKusick, M. J. Karels, and J. S. Quaterman. </author> <title> The Design and Implementation of the 4.3 BSD UNIX Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Examples RPC frameworks avoid dynamic allocations using buffer pool for requests, operating systems use copy-on-write to share pages, networking frameworks use data structures like mbuf <ref> [16] </ref> and x-kernel messages [12] to add or remove protocol headers without copying. The resource exchanger pattern [28] combines many of these optimizations. 4.7 Concurrency Optimization Concurrent operations on shared objects must be serialized in a framework. When serialization is implemented using locks, the framework must avoid cyclic dependencies.
Reference: 17. <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: For other examples, see the uses of StructureObjects in Sect. 4.7. 4.9 Miscellaneous Scheduling Scheduling optimizations are usually applicable to system level frameworks. Specialized schedulers encapsulate optimizations and Structure-Objects associate applications with them. Gang scheduling schedules a group of cooperating processes together. Different Real-time scheduling algorithms <ref> [17] </ref> implement policies for executing tasks so that they meet their deadlines. Priority inheritance scheduling [32] prevents unbounded priority inversion in real-time systems. Message driven scheduling schedules tasks when their message arrive.
Reference: 18. <author> Cristina Videira Lopes and Karl Lieberherr. </author> <title> Abstracting process-to-function relations in concurrent object-oriented applications. </title> <booktitle> In Proceedings of the 8th European Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 81-99. </pages> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: This paper was a starting point for our work. An architecture description language UniCon [34] and a formal description language Wright [2] explicitly model connections. The Demeter project introduces a notation for making the structure of frameworks explicit, and express framework traversals as regular expressions <ref> [18] </ref>. This helps in framework evolution, because changes to the object structure can be expressed by changing the structure description rather than method code. Our approach shares the advantages of reification and encapsulation with these works. However, our focus is different.
Reference: 19. <author> Paul E. McKenney. </author> <title> Selecting locking primitives for parallel programming. </title> <journal> Communications of the ACM, </journal> <volume> 39(10) </volume> <pages> 75-82, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Implementation Use a TaskObject to localize all lock acquisition and release operations over a task. Thereafter, it can be specialized to implement different trade-offs. Hot-spot contention can be reduced by splitting critical sections, and locking overhead can be reduced by putting many objects under the protection of one lock <ref> [19] </ref>. On a uniprocessor, TaskObject can be changed to manipulate interrupts and scheduling to reduce locking overhead. <p> A StructureObject can associate different types of locks (e.g., read lock and read-write lock) with a DataObject for different access types, and group objects that are used together under one lock (see Sect. 6 for an example). Struc-tureObject objects can explicitly represent lock hierarchies <ref> [19] </ref> and make them obvious and easy to understand. DataObjects can be used as tokens for implementing mutual exclusion. If DataObjects are maintained in different memory pools and caches, contention for the global heap is reduced.
Reference: 20. <author> David Mosberger and Larry L. Peterson. </author> <title> Making paths explicit in the scout operating system. </title> <booktitle> In 2nd Symposium on Operating Systems Design and Implementation (OSDI '96), </booktitle> <pages> pages 153-167. </pages> <publisher> USENIX, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: They have argued that many system-wide properties can not be implemented without application-specific knowledge. This argument forms the basis of the insight that implementing optimizations requires changes not only to objects, but also to their interactions. The research on Paths <ref> [20] </ref> comes closest to our work. It introduces a path as an explicit abstraction that connect the layers in an operating system and describes optimizations along a path. Clark [6] and others describe many optimizations for network protocols. <p> This paper is among the first works on applying networking optimizations to distributed object systems. We distinguish our work from the above in that we show how to apply optimizations to arbitrary frameworks. Our ideas are more general than Paths <ref> [20] </ref> since we go beyond control paths: we explicitly represent data traveling along the path, as well as the structure of object interconnections. We also show how most common optimizations from the literature can be represented as transformations of control, data, and structure.
Reference: 21. <author> Nathan Goodman Philip A. Bernstein, Vassos Hadzilacos. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: If DataObjects are maintained in different memory pools and caches, contention for the global heap is reduced. Continuations, which may reduce thread usage, can be implemented using TaskObjects and DataObjects (see Sect. 5.3 for examples). Examples Databases use intention mode locking <ref> [21] </ref> to improve concurrency and avoid deadlock. Parts of operating systems disable interrupts to implement critical sections.
Reference: 22. <author> Calton Pu, Henry Massalin, and John Ioannidis. </author> <title> The synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: The optimized TaskObject is a special version of the generic TaskObject. If the framework is changed, the optimized version may be discarded or reprogrammed. Examples Optimizing the innermost loops in numerical programs, optimizing file systems for small files because most files are small, dynamic code spe cialization in Synthesis <ref> [22] </ref>, pointer swizzling in object databases. Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 4.3 Lazy Evaluation The premise underlying lazy evaluation is that if we delay a task until its results are actually needed, more information may become available that can help optimize the task.
Reference: 23. <editor> Reflection'96, </editor> <address> San Francisco, CA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 There have been many proposals to give first-class status to relationships between system components. The purpose of these proposals is to ease evolution of systems and make them easier to understand. Reflective systems <ref> [38, 23] </ref> advocate reifying many aspects of objects. Kicza-les [15] presents a design methodology, "Open Analysis and Design," which suggests incorporating reflective interfaces for customization. Shaw [33] argues that the connections between components deserve first-class status.
Reference: 24. <author> J. H. Saltzer, D. P. Reed, and D. D. Clark. </author> <title> End-to-end arguments in system design. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Our approach is to encapsulate object interactions and then customize the interactions for performance without changing the objects themselves. ? Ashish Singhai is supported in part by the grant NSF-CDA-94-01124. 1 The idea of whole system or end-to-end analyses originates in <ref> [24] </ref>. Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 This scheme has several benefits. First, encapsulation localizes the changes needed for optimization. So it is easier to understand the optimizations, and to estimate how adding new objects or tasks would affect efficiency. <p> The end-to-end argument in system design was introduced by Saltzer et. al. <ref> [24] </ref>. They describe the implications of end-to-end argument for system structuring. They have argued that many system-wide properties can not be implemented without application-specific knowledge. This argument forms the basis of the insight that implementing optimizations requires changes not only to objects, but also to their interactions.
Reference: 25. <author> Aamod Sane. </author> <title> Techniques for Developing Correct, Fast, and Robust Implementations of Distributed Protocols. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Overview. In Sect. 2 we present examples of framework optimizations selected from a wide variety of frameworks that we have built over the years in the Choices operating system [4] and other projects. The frameworks include a filesystem framework [40], a virtual memory framework <ref> [25] </ref>, an instrumentation framework [30], and a video conferencing framework [39]. Sect. 3 analyses these examples, motivating a set of objects that make object relationships first-class. We then show that well known optimization techniques from the literature can be expressed using this approach. <p> For each class, we discuss how to determine when an optimization is applicable, and how to implement it. Each catalog entry also presents several examples from the literature. Sections 5 and 6 describe two large frameworks that we have built using this approach: a virtual memory framework <ref> [25] </ref> and a distributed object framework [37]. Section 5 also includes examples of inter-framework optimizations. After presenting related work is Sect. 7, we conclude in Sect. 8 with a discussion of future research. 2 Examples This section presents four examples of end-to-end optimizations in the frameworks we have built. <p> However, this hides dependencies among locks in method call sequences. Therefore it is difficult and deadlock-prone to add extensions like copy-on-write or distributed shared memory that visit and lock the same objects. In our virtual memory framework <ref> [25] </ref> we addressed this problem by coding virtual memory tasks in objects such as PageOutTask and PageFaultTask. They encapsulate concurrency control and make the order of locking operations explicit. This simplifies adding new tasks like PageOutToRemoteHost, customizing tasks for performance like UniprocessorPageFault, and sharing and caching data across tasks. <p> Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 5 Optimizing a Virtual Memory Framework This section describes optimizations for the virtual memory framework 4 of the Choices operating system <ref> [25] </ref>. The virtual memory framework uses the networking framework to implement distributed shared memory. We show how our techniques help in optimizing interactions between these two frameworks. 5.1 Framework Description The virtual memory framework provides memory management to user processes.
Reference: 26. <author> Aamod Sane and Roy Campbell. </author> <title> Composite messages: A structural pattern for communication among software components. </title> <booktitle> In OOPSLA'95 Workshop on Design Patterns in Concurrent, Distributed, and Parallel Object-Oriented Systems, </booktitle> <year> 1995. </year>
Reference-contexts: For instance, a TaskObject can be implemented as a Command or a Mediator, and may use patterns like State, or techniques like Object-Oriented State Machines [27]. Selection between specialized TaskObjects may be implemented as a Strategy. A DataObject can be implemented using ParameterObject <ref> [26] </ref>. A StructureObject can involve a Facade or a Factory augmented with interfaces for querying object structure. Example. We recast the example of Sect. 1 in terms of TaskObject, DataObject, and StructureObject. In the example, a file framework defined FileServer s and Clients.
Reference: 27. <author> Aamod Sane and Roy Campbell. </author> <title> Object-oriented state machines: Subclassing, composition, delegation, and genericity. </title> <booktitle> In Proceedings of the OOPSLA, </booktitle> <pages> pages 17-32. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1995. </year>
Reference-contexts: Various design pattern catalogs (such as [10]) suggest patterns that can be used to implement task, data and structure objects. For instance, a TaskObject can be implemented as a Command or a Mediator, and may use patterns like State, or techniques like Object-Oriented State Machines <ref> [27] </ref>. Selection between specialized TaskObjects may be implemented as a Strategy. A DataObject can be implemented using ParameterObject [26]. A StructureObject can involve a Facade or a Factory augmented with interfaces for querying object structure. Example. We recast the example of Sect. 1 in terms of TaskObject, DataObject, and StructureObject. <p> The VMData objects suggested the network optimizations and also the generalization to use continuations. Besides interaction objects, our framework uses other ideas like object-oriented state machines <ref> [27] </ref> and resource exchanger [28] to simplify the implementation. 6 Optimizing a Distributed Object Framework In this section we consider optimizations in Quarterware, a framework for distributed object computing [37]. 6.1 Framework Description A distributed object framework performs two basic tasks: 1.
Reference: 28. <author> Aamod Sane and Roy Campbell. </author> <title> Resource exchanger: A behavioral pattern for low overhead concurrent resource management. In Pattern Languages of Program Design. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Examples RPC frameworks avoid dynamic allocations using buffer pool for requests, operating systems use copy-on-write to share pages, networking frameworks use data structures like mbuf [16] and x-kernel messages [12] to add or remove protocol headers without copying. The resource exchanger pattern <ref> [28] </ref> combines many of these optimizations. 4.7 Concurrency Optimization Concurrent operations on shared objects must be serialized in a framework. When serialization is implemented using locks, the framework must avoid cyclic dependencies. This involves analyzing all objects in a framework. <p> The VMData objects suggested the network optimizations and also the generalization to use continuations. Besides interaction objects, our framework uses other ideas like object-oriented state machines [27] and resource exchanger <ref> [28] </ref> to simplify the implementation. 6 Optimizing a Distributed Object Framework In this section we consider optimizations in Quarterware, a framework for distributed object computing [37]. 6.1 Framework Description A distributed object framework performs two basic tasks: 1.
Reference: 29. <author> Douglas C. Schmidt and Chris Cleeland. </author> <title> Applying patterns to develop extensible and maintainable orb middleware. </title> <note> Available at http://www.cs.wustl.edu/ "~schmidt/ORB-patterns.ps.gz. </note>
Reference-contexts: This task must receive a request, find the server object, unmarshal the arguments, invoke the requested method on the server, and marshal and send the reply, if any. Basic Objects. This suggests the following basic objects for this framework (sim ilar to TAO <ref> [29] </ref> or Orbix [13]). - ObjectRef s represent remote objects locally. A client invokes methods on an ObjectRef. - ActualObjects are server objects that implement the desired functionality. Calls on ObjectRef s are forwarded to the corresponding ActualObjects. Arguments represent the arguments to a method invocation (call). <p> We implement different versions of ServiceTasks to represent these trade-offs (similar to invocation strategies <ref> [29] </ref>).
Reference: 30. <author> Mohlalefi Sefika. </author> <title> Design conformance management of software systems: An architecture-oriented approach. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <month> August </month> <year> 1996. UIUCDCS-R-96-1974. </year>
Reference-contexts: Overview. In Sect. 2 we present examples of framework optimizations selected from a wide variety of frameworks that we have built over the years in the Choices operating system [4] and other projects. The frameworks include a filesystem framework [40], a virtual memory framework [25], an instrumentation framework <ref> [30] </ref>, and a video conferencing framework [39]. Sect. 3 analyses these examples, motivating a set of objects that make object relationships first-class. We then show that well known optimization techniques from the literature can be expressed using this approach. This leads to our catalog in pattern form.
Reference: 31. <author> Mohlalefi Sefika, Aamod Sane, and Roy H. Campbell. </author> <title> Architecture-oriented visualization. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), volume 31(10) of ACM SIG-PLAN Notices, </booktitle> <pages> pages 389-405, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: In our system <ref> [31] </ref>, we use instruments that represent system structure, like PatternInstrument and SubFrameworkInstrument. These instruments integrate instance and method level data to provide high-level views. This reduces the volume of instrumentation data and minimizes system perturbation. This optimization makes the high-level structure of interacting objects explicit.
Reference: 32. <author> L. Sha, R. Rajkumar, and J. P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Specialized schedulers encapsulate optimizations and Structure-Objects associate applications with them. Gang scheduling schedules a group of cooperating processes together. Different Real-time scheduling algorithms [17] implement policies for executing tasks so that they meet their deadlines. Priority inheritance scheduling <ref> [32] </ref> prevents unbounded priority inversion in real-time systems. Message driven scheduling schedules tasks when their message arrive. Protocols Knowledge about the type of communication, transport medium, and data helps design custom protocols to optimize factors such as latency, buffer space, and throughput.
Reference: 33. <author> M. Shaw. </author> <title> Procedure calls are the assembly language of software interconnections: Connectors deserve first class. </title> <editor> In D. Lamb, editor, </editor> <booktitle> Studies of Software Design, Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 volume 1078 of Lecture Notes in Computer Science, </booktitle> <pages> pages 17-32, </pages> <address> Baltimore, Md, May 1993. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The purpose of these proposals is to ease evolution of systems and make them easier to understand. Reflective systems [38, 23] advocate reifying many aspects of objects. Kicza-les [15] presents a design methodology, "Open Analysis and Design," which suggests incorporating reflective interfaces for customization. Shaw <ref> [33] </ref> argues that the connections between components deserve first-class status. For example, encoding a pipe that connects two communicating programs with procedure calls obscures the data flow aspects. This paper was a starting point for our work.
Reference: 34. <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Shaw [33] argues that the connections between components deserve first-class status. For example, encoding a pipe that connects two communicating programs with procedure calls obscures the data flow aspects. This paper was a starting point for our work. An architecture description language UniCon <ref> [34] </ref> and a formal description language Wright [2] explicitly model connections. The Demeter project introduces a notation for making the structure of frameworks explicit, and express framework traversals as regular expressions [18].
Reference: 35. <author> Abraham Silberschatz and Peter B. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <year> 1997. </year>
Reference-contexts: This is shown in Fig. 1 (a). However, in this implementation, every access incurs disk seek latency. Therefore, fast implementations batch requests that refer to the same track, amortizing the latency over the batch of requests <ref> [35] </ref>. Batching is implemented by changing how File and DiskDriver interact. For instance, first we change the arguments to read () and readDisk () into Requests that can be sorted, queued and compacted. Next, we modify read () to enqueue a Request and wait for it to complete.
Reference: 36. <author> Ashish Singhai, Aamod Sane, and Roy Campbell. </author> <title> Reflective ORBs: Support for robust, time-critical distribution. </title> <booktitle> In Proceedings of the ECOOP'97 Workshop on Reflective Real-Time Object-Oriented Programming and Systems, volume (to appear) of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: task processing is sequential. - STMultiThreaded creates a new thread for each task and implements thread per-message strategy. - STThreadPerClient has one thread for each client, and it uses the inputChan nel attribute of the CallData to associate it with the corresponding thread. - STRealTime executes real-time scheduling for requests <ref> [36] </ref>.
Reference: 37. <author> Ashish Singhai, Aamod Sane, and Roy Campbell. </author> <title> Quarterware for middleware. </title> <booktitle> In Proceddings of the 18th International Conference on Distributed Computing Systems (ICDCS). IEEE, </booktitle> <month> May </month> <year> 1998. </year>
Reference-contexts: Each catalog entry also presents several examples from the literature. Sections 5 and 6 describe two large frameworks that we have built using this approach: a virtual memory framework [25] and a distributed object framework <ref> [37] </ref>. Section 5 also includes examples of inter-framework optimizations. After presenting related work is Sect. 7, we conclude in Sect. 8 with a discussion of future research. 2 Examples This section presents four examples of end-to-end optimizations in the frameworks we have built. <p> Besides interaction objects, our framework uses other ideas like object-oriented state machines [27] and resource exchanger [28] to simplify the implementation. 6 Optimizing a Distributed Object Framework In this section we consider optimizations in Quarterware, a framework for distributed object computing <ref> [37] </ref>. 6.1 Framework Description A distributed object framework performs two basic tasks: 1. A local method invocation on the client side is converted into a remote request.
Reference: 38. <author> Brian C. Smith. </author> <title> Reflection and Semantics in A Procedural Language. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1982. </year> <month> MIT-LCS-272. </month>
Reference-contexts: Appears in the Proceedings of the 12th ECOOP, Brussels, July 1998 There have been many proposals to give first-class status to relationships between system components. The purpose of these proposals is to ease evolution of systems and make them easier to understand. Reflective systems <ref> [38, 23] </ref> advocate reifying many aspects of objects. Kicza-les [15] presents a design methodology, "Open Analysis and Design," which suggests incorporating reflective interfaces for customization. Shaw [33] argues that the connections between components deserve first-class status.
Reference: 39. <author> Habanero project, </author> <year> 1997. </year> <note> Available at: http://http://www.ncsa.uiuc.edu/SDG/ Software/Habanero/. </note>
Reference-contexts: The frameworks include a filesystem framework [40], a virtual memory framework [25], an instrumentation framework [30], and a video conferencing framework <ref> [39] </ref>. Sect. 3 analyses these examples, motivating a set of objects that make object relationships first-class. We then show that well known optimization techniques from the literature can be expressed using this approach. This leads to our catalog in pattern form. <p> This reduces the volume of instrumentation data and minimizes system perturbation. This optimization makes the high-level structure of interacting objects explicit. We call this structure directed optimization. 2.4 Video Conferencing: Control and Data Separation In a video conferencing system that we are developing <ref> [39] </ref>, Clients produce and consume video streams. A straightforward implementation is to let each client 3 For example, synchronized methods in Java implicitly acquire and release locks.
Reference: 40. <author> Lim Swee. </author> <title> Adaptive Caching in a Distributed File System. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: Overview. In Sect. 2 we present examples of framework optimizations selected from a wide variety of frameworks that we have built over the years in the Choices operating system [4] and other projects. The frameworks include a filesystem framework <ref> [40] </ref>, a virtual memory framework [25], an instrumentation framework [30], and a video conferencing framework [39]. Sect. 3 analyses these examples, motivating a set of objects that make object relationships first-class. We then show that well known optimization techniques from the literature can be expressed using this approach.
References-found: 40

