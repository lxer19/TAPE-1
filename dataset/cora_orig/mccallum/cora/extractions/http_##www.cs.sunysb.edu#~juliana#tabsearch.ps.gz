URL: http://www.cs.sunysb.edu/~juliana/tabsearch.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,warreng@cs.sunysb.edu  
Title: Controlling the Search in Tabled Evaluations  
Author: Juliana Freire David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: SLG has proven to be an efficient and elegant strategy to evaluate normal logic programs with respect to the well-founded semantics. Given the flexibility tabling provides in the choice of when to schedule answers, efficiency of evaluation can be further improved by choosing an appropriate scheduling strategy, that is, how and when answers are returned to consuming nodes. Several different scheduling strategies for SLG have been investigated including a set-at-a-time strategy well-suited for accessing relations in external databases. This paper explores Local Scheduling, a strategy that by following the dependencies among subgoals during evaluation, simplifies the computation of the well-founded model of programs with negation, and avoids non-productive computation in the presence of answer subsumption (e.g., in aggregate computation and abstract interpretation). Even though Local Scheduling performs well in general, there are cases where it leads to unacceptable performance the same can be said of other scheduling strategies for SLG. Since different applications have different requirements, the ability to use multiple strategies in an evaluation is likely to be beneficial. We discuss the issues involved in intermixing different strategies in an SLG evaluation and explore an implementation which provides engine-level support for a mixed-strategy evaluation at the predicate level. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> WAM: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We also discuss the issues involved in intermixing different strategies in an evaluation and how this can be implemented in the SLG-WAM. 5 Engine Design 5.1 The SLG WAM Besides the memory areas for a regular WAM <ref> [1] </ref> implementation (i.e., heap, local, choice point and trail), the SLG-WAM needs a table and a completion stack. The table maintains information about all (tabled) subgoals encountered by the evaluation as well as answers for each subgoal.
Reference: [2] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3):255 299, </volume> <year> 1991. </year>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques <ref> [2] </ref>. In Aditi [11], for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [10]).
Reference: [3] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10:91124, </volume> <year> 1991. </year>
Reference-contexts: By ensuring a component is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling [5] for applications that benefit from answer subsumption, such as many aggregate computations [12] and program analyses <ref> [3] </ref>, and therefore its performance can be asymptotically better than that of Batched Scheduling.
Reference: [4] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1):2074, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: An implementation of this mixed-strategy evaluation is described and performance results are given. 2 SLG: A Brief Overview This section provides a brief (and informal) overview of SLG; for a more detailed discussion see <ref> [4] </ref>. An SLG evaluation consists of a sequence of forests (or SLG systems) of SLG trees. As applicable operations are performed, the evaluation proceeds moving from forest to forest. <p> 4.2 Local Scheduling for Programs with Negation In order to correctly evaluate programs with negation, the SLG-WAM has to know the exact dependencies among subgoals so that it can verify whether loops through negation exist, in which case it delays literals (through the NEGATIVE DELAY operation) to break the loops <ref> [4] </ref>. The original implementation of the well-founded semantics on top of the SLG-WAM uses Batched Scheduling as its scheduling strategy, and at runtime it keeps an approximation of the subgoal dependency graph (SDG) of the program in a stack (the completion stack).
Reference: [5] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <booktitle> In 8th International Symposium PLILP, </booktitle> <pages> pages 243258. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in [6] we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. In <ref> [5] </ref> we described Local Scheduling for definite programs. <p> By ensuring a component is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling <ref> [5] </ref> for applications that benefit from answer subsumption, such as many aggregate computations [12] and program analyses [3], and therefore its performance can be asymptotically better than that of Batched Scheduling. <p> Note that at this point there is a choice of either returning the newly derived answer in node 4 to the consumer in node 2 (the action taken by Single Stack Scheduling <ref> [5] </ref>), or resolving the next available clause for a/2 (the action taken by Batched Scheduling [5]). We choose the former (see Table 1 (a)), and from now on we will follow the steps taken by Single Stack Scheduling. Node 5 is created and SUBGOAL CALL of p (2,Y) is issued. <p> Note that at this point there is a choice of either returning the newly derived answer in node 4 to the consumer in node 2 (the action taken by Single Stack Scheduling <ref> [5] </ref>), or resolving the next available clause for a/2 (the action taken by Batched Scheduling [5]). We choose the former (see Table 1 (a)), and from now on we will follow the steps taken by Single Stack Scheduling. Node 5 is created and SUBGOAL CALL of p (2,Y) is issued. <p> A different strategy might delay or batch the return of answers. For instance, Batched Scheduling (see Table 1 (b)) favors the execution of PROGRAM CLAUSE RESOLUTION and batches the return of answers until no more program clauses are available. Different strategies have different performance behaviors. For instance, in <ref> [5] </ref> we compared implementations of Single Stack Scheduling and Batched Scheduling, and not only Batched Scheduling has proven to be faster, but it also uses much less memory than Single Stack Scheduling for a representative set of benchmarks. 2 Other strategies are possible. <p> In what follows we will concentrate on Local Scheduling, a strategy whose variant for definite programs was introduced in <ref> [5] </ref>. In Section 4, we review its basic characteristics 4 Table 1: Possible sequence of SLG operations for Example 3.1. 1. SC (Initial Query) 2. PCR (Node1, C4) 3. PCR (Node1, C5) 4. PCR (Node3, C1) 5. ACR (Node4, Node2) 6. SC (Node5) 7. PCR (Node6, C4) 8. <p> We also discuss the pros and cons of using Local Scheduling. 4 Local Scheduling 4.1 Local Scheduling and Definite Programs Local Scheduling can be seen as a variant of Batched Scheduling <ref> [5] </ref> that tries to completely evaluate sub-goals as soon as possible. To achieve that, it delays the return of answers out of an SCC until the SCC is completely evaluated, thereby preserving the SCC ordering during evaluation. The following example illustrates the actions of Local Scheduling. <p> A more comprehensive description of Local Scheduling for definite programs as well as a thorough performance analysis is provided in <ref> [5] </ref>. 4.2 Local Scheduling for Programs with Negation In order to correctly evaluate programs with negation, the SLG-WAM has to know the exact dependencies among subgoals so that it can verify whether loops through negation exist, in which case it delays literals (through the NEGATIVE DELAY operation) to break the loops <p> XSB v. 1.7 and XSB-Local are freely available at http://www.cs.sunysb.edu/~sbprolog. XSB-Integ is available upon request. 12 * XSB v. 1.7: uses Batched Scheduling <ref> [5] </ref>. * XSB-Local: uses Local Scheduling (Section 5.3). * XSB-Integ: combines Batched Scheduling and Local Scheduling at the predicate level (Section 5.4). We consider both execution time and memory usage of SLG-WAM engines as well as the dynamic count of SLG-WAM instructions and operations. <p> Local Scheduling for Programs with Negation For a representative set of definite programs that do not require answer subsumption, we have shown that XSB-Local adds between 10-20% overhead over XSB v. 1.7 <ref> [5] </ref>. However, for programs with negation there seems to be essentially no overhead.
Reference: [6] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in <ref> [6] </ref> we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. In [5] we described Local Scheduling for definite programs. <p> Further research is also needed to assess the possibility of automatically inferring for each predicate which strategy might result in the best performance. Finally, we would like to add Breadth-First <ref> [6] </ref> as another scheduling option for the mixed-strategy evaluation.
Reference: [7] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> The limits of fixed-order computation. </title> <booktitle> In International Workshop on Logic and Databases. </booktitle> <publisher> LNAI: Springer-Verlag, </publisher> <year> 1995. </year> <month> 17 </month>
Reference-contexts: During the COMPLETION operation, if negative dependencies are present, the engine has to explicitly build the exact SDG of the program to detect whether negative loops are present <ref> [7, 8] </ref>. In contrast, an engine based on Local Scheduling can avoid this step: Since SCCs are preserved during the evaluation, the completion stack represents the exact SDG of the program, and thus negative dependencies are only created if there are actual loops through negation. <p> The COMPLETION operation for the mixed-strategy engine is described in Algorithm 5.5. Note that for negation handling, Integ CheckComplete will act according to the strategy of the leader: for Batched Scheduling it will use the procedures and data structures described in <ref> [7] </ref> (which are currently implemented in XSB); for Local Scheduling, even though the mechanisms for delay and simplification are the same as for Batched Scheduling, a simpler implementation can be achieved since there is no need to build SDGs, all manipulations required to maintain the necessary SDG structures are avoided.
Reference: [8] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> An abstract machine for computing the well-founded se-mantics. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 274289, </pages> <year> 1996. </year>
Reference-contexts: During the COMPLETION operation, if negative dependencies are present, the engine has to explicitly build the exact SDG of the program to detect whether negative loops are present <ref> [7, 8] </ref>. In contrast, an engine based on Local Scheduling can avoid this step: Since SCCs are preserved during the evaluation, the completion stack represents the exact SDG of the program, and thus negative dependencies are only created if there are actual loops through negation. <p> When negative dependencies are present, in order to correctly evaluate normal programs under the well-founded semantics, the engine has to explicitly build the SDG of the program to determine the exact dependencies and find an independent SCC (ISCC) <ref> [8] </ref>. Given this ISCC, the engine will then check for negative loops and delay subgoals if necessary. Not only this can be a time consuming task, but also the introduction of a new data structure for the SDG increases 10 the complexity of the actual source code.
Reference: [9] <author> T. Swift and D. S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633654, </pages> <year> 1994. </year>
Reference-contexts: Local Scheduling also benefits the evaluation of programs with negation: It simplifies the implementation of the well-founded semantics on top of the SLG-WAM <ref> [9] </ref> by avoiding the creation of extraneous negative dependencies; and it improves the performance of some programs (both running times and memory usage). In this paper we describe an implementation of Local Scheduling in the SLG-WAM that supports programs with negation (stratified or not) and report its resulting performance.
Reference: [10] <author> J. Ullman. </author> <title> Principles of Data and Knowledge-base Systems Vol I. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: In bottom-up systems, the search can be controlled through the use of different rewriting techniques [2]. In Aditi [11], for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive <ref> [10] </ref>). Here we discuss the issues involved in providing engine support for different scheduling strategies at the predicate level as means of controlling the search in an SLG evaluation to attain the best possible performance.
Reference: [11] <author> J. Vaghani, K. Ramamohanarao, D.B. Kemp, Z. Somogyi, P.J. Stuckey, T.S. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2):245288, </volume> <year> 1994. </year>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques [2]. In Aditi <ref> [11] </ref>, for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [10]).
Reference: [12] <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 1334, </pages> <year> 1993. </year>
Reference-contexts: By ensuring a component is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling [5] for applications that benefit from answer subsumption, such as many aggregate computations <ref> [12] </ref> and program analyses [3], and therefore its performance can be asymptotically better than that of Batched Scheduling.
Reference: [13] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 304318, </pages> <year> 1996. </year> <note> 18 This appendix contains only supplementary reference material for the convenience of the referees. </note>
Reference-contexts: In a sense, Local Scheduling resembles the strategy proposed by Zukowski and Freitag in <ref> [13] </ref> where instead of SCCs program fragments are evaluated by different fixpoints 2 . <p> The main contributions of this paper are as follows: 1 A set of mutually dependent subgoals is completely evaluated after all answers are returned to all consumers in the set. 2 As a remark, the strategy described in <ref> [13] </ref> evaluates modularly stratified programs, whereas Local Scheduling can handle stratified as well as non-stratified negation. 1 * We explore Local Scheduling and how it can benefit the evaluation of normal programs.
References-found: 13

