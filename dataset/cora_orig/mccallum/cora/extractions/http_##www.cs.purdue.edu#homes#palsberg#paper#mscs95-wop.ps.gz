URL: http://www.cs.purdue.edu/homes/palsberg/paper/mscs95-wop.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Strong Normalization with Non-structural Subtyping  
Author: Mitchell Wand Patrick O'Keefe Jens Palsberg 
Date: June 1, 1994  
Note: Mathematical Structures in Computer Science, 5(3):419-430, 1995.  
Abstract: We study a type system with a notion of subtyping that involves a largest type &gt;, a smallest type ?, atomic coercions between base types, and the usual ordering of function types. We prove that any -term typable in this system is strongly normalizing; this solves an open problem of Thatte. We also prove that the fragment without ? types strictly fewer terms. This demonstrates that ? adds power to a type system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: Partial types comprise an ordered set (T B ; ), where T B is the set of well-formed finite terms over B [ f?; &gt;; !g. (For an extension with recursive types, see the paper by Amadio and Cardelli <ref> [1] </ref>.) Here, ? and &gt; are constant symbols, and ! is a binary type constructor.
Reference: [2] <author> Paola Giannini and Simona Ronchi Della Rocca. </author> <title> Characterization of typings in polymorphic type discipline. </title> <booktitle> In Proc. LICS'88, Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 61-70, </pages> <year> 1988. </year>
Reference-contexts: The -term (x:xxx)(y:y) is not typable in PTB, but it is typable in F , and 2. The -term (x:y:y (xI)(xK)), where I = a:a, K = b:c:b, and = d:dd, is not typable in F <ref> [2] </ref>, but it is typable in PTB and also in PT. It follows that PT and F are also incomparable.
Reference: [3] <author> Carsten K. Gomard. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 282-287, </pages> <year> 1990. </year>
Reference-contexts: In particular, it is desirable to allow strongly-typed languages to have "holes" in the type structure, so that portions of the program that are not fully understood may be written using dynamic typing. There have been several proposals for creating such holes, such as <ref> [3, 9, 10] </ref>. Typically, one gives the result of such an untyped computation a special type, untyped. Such a value can be passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print [10]. Thatte [9] called this partial type inference. <p> It allows portions of a program to escape the scrutiny of the type-checker [10]; it allows for heterogeneous lists and persistent data [9]; and it can also be used to facilitate binding-time analysis or analysis of type errors <ref> [3] </ref>. It also serves as a basis for dealing with the "don't care" types for records in [8]. fl Work supported by the National Science Foundation and DARPA under grants CCR-9002253 and CCR-9014603. y College of Computer Science, Northeastern University, 360 Huntington Avenue, 161CN, Boston, MA 02115, USA.
Reference: [4] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: To obtain such negative results, we rephrase the type inference in terms of solving a system of type constraints, following for example <ref> [4] </ref>. 5.1 Constraints Given a -term M , assume that M has been ff-converted so that all bound variables are distinct. <p> In particular, if M is closed, then M is typable with type t if and only if there exists a solution L of T (M ) such that L ([[M ]]) = t. Proof. Similar to the proof of Theorem 2.1 in the journal version of <ref> [4] </ref>, in outline as follows. Given a solution of the constraint system, it is straightforward to construct a derivation of A ` M : t. <p> The latter result could also be obtained using one of the two known type inference algorithms for PT <ref> [6, 4] </ref>. To give some intuition about why this -term is untypable over PT, we give a direct proof. Notice that (f:f (f x))(v:vy) is not closed. We might have used the closed -term x:y:(f:f (f x))(v:vy) instead, but we have preferred to use the shorter (f:f (f x))(v:vy).
Reference: [5] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year>
Reference-contexts: Intuitively, if s t, then we can coerce s to t. The coercions among elements of B have been called atomic by Mitchell <ref> [5] </ref>. We will refer to the fourth rule as the congruence rule for function types. Typical inclusions are ? ? ! &gt;, &gt; ! &gt; &gt;, &gt; ! &gt; (&gt; ! &gt;) ! &gt;. Lemma 1 The relation is a partial order. Proof. <p> Thatte's system of partial types did not include ?; the fragment of the type system without ? will be denoted PT. Reduction is as usual given by the rewriting rule scheme (x:M )M 0 ) M [M 0 =x]; Mitchell <ref> [5] </ref> has shown that subject reduction holds. This system types terms which are not typable in the simply-typed -calculus. For example, consider f:(f K (f I)), where K and I are the usual combinators.
Reference: [6] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag (LNCS 582), </publisher> <year> 1992. </year>
Reference-contexts: The latter result could also be obtained using one of the two known type inference algorithms for PT <ref> [6, 4] </ref>. To give some intuition about why this -term is untypable over PT, we give a direct proof. Notice that (f:f (f x))(v:vy) is not closed. We might have used the closed -term x:y:(f:f (f x))(v:vy) instead, but we have preferred to use the shorter (f:f (f x))(v:vy).
Reference: [7] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 175-180, </pages> <year> 1992. </year>
Reference-contexts: Conversely, observe that if A ` M : t is derivable, then there exists a derivation of A ` M : t such that each use of one of the ordinary rules is followed by exactly one use of the subsumption rule. The approach in for example <ref> [11, 7] </ref> then gives a set of inequalities of the desired form. 2 5.2 An untypable -term In this subsection we prove that the the strongly normalizing -term (x:xxx)(y:y) is not typable. First we present a small system of constraints which is unsolvable.
Reference: [8] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 77-88, </pages> <year> 1989. </year>
Reference-contexts: It also serves as a basis for dealing with the "don't care" types for records in <ref> [8] </ref>. fl Work supported by the National Science Foundation and DARPA under grants CCR-9002253 and CCR-9014603. y College of Computer Science, Northeastern University, 360 Huntington Avenue, 161CN, Boston, MA 02115, USA. E-mail: wand@ccs.neu.edu. z 85 East India Row #39B, Boston, MA 02110, USA.
Reference: [9] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1988, </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag (LNCS 317), </publisher> <year> 1988. </year>
Reference-contexts: In particular, it is desirable to allow strongly-typed languages to have "holes" in the type structure, so that portions of the program that are not fully understood may be written using dynamic typing. There have been several proposals for creating such holes, such as <ref> [3, 9, 10] </ref>. Typically, one gives the result of such an untyped computation a special type, untyped. Such a value can be passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print [10]. Thatte [9] called this partial type inference. <p> Typically, one gives the result of such an untyped computation a special type, untyped. Such a value can be passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print [10]. Thatte <ref> [9] </ref> called this partial type inference. The addition of a type untyped allows several different kinds of flexibility. It allows portions of a program to escape the scrutiny of the type-checker [10]; it allows for heterogeneous lists and persistent data [9]; and it can also be used to facilitate binding-time analysis <p> Thatte <ref> [9] </ref> called this partial type inference. The addition of a type untyped allows several different kinds of flexibility. It allows portions of a program to escape the scrutiny of the type-checker [10]; it allows for heterogeneous lists and persistent data [9]; and it can also be used to facilitate binding-time analysis or analysis of type errors [3]. <p> We prove that any -term typable in this system is strongly normalizing. The constant type &gt; corresponds to untyped. The constant type ? is useful for typing "dead code". Thatte's partially typed terms <ref> [9] </ref> correspond to the fragment without ?. Our result implies that partially typed terms are strongly normalizing as well, solving an open problem in [9]. <p> The constant type &gt; corresponds to untyped. The constant type ? is useful for typing "dead code". Thatte's partially typed terms <ref> [9] </ref> correspond to the fragment without ?. Our result implies that partially typed terms are strongly normalizing as well, solving an open problem in [9].
Reference: [10] <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pages 213-221. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: In particular, it is desirable to allow strongly-typed languages to have "holes" in the type structure, so that portions of the program that are not fully understood may be written using dynamic typing. There have been several proposals for creating such holes, such as <ref> [3, 9, 10] </ref>. Typically, one gives the result of such an untyped computation a special type, untyped. Such a value can be passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print [10]. Thatte [9] called this partial type inference. <p> Typically, one gives the result of such an untyped computation a special type, untyped. Such a value can be passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print <ref> [10] </ref>. Thatte [9] called this partial type inference. The addition of a type untyped allows several different kinds of flexibility. It allows portions of a program to escape the scrutiny of the type-checker [10]; it allows for heterogeneous lists and persistent data [9]; and it can also be used to facilitate <p> passed as an ordinary value, but is not manipulable except by a polymorphic procedure, such as print <ref> [10] </ref>. Thatte [9] called this partial type inference. The addition of a type untyped allows several different kinds of flexibility. It allows portions of a program to escape the scrutiny of the type-checker [10]; it allows for heterogeneous lists and persistent data [9]; and it can also be used to facilitate binding-time analysis or analysis of type errors [3].
Reference: [11] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 1-15, </pages> <year> 1991. </year> <month> 12 </month>
Reference-contexts: Conversely, observe that if A ` M : t is derivable, then there exists a derivation of A ` M : t such that each use of one of the ordinary rules is followed by exactly one use of the subsumption rule. The approach in for example <ref> [11, 7] </ref> then gives a set of inequalities of the desired form. 2 5.2 An untypable -term In this subsection we prove that the the strongly normalizing -term (x:xxx)(y:y) is not typable. First we present a small system of constraints which is unsolvable.
References-found: 11

