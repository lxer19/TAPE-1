URL: http://siesta.cs.wustl.edu/~drd1/stoc.ps
Refering-URL: http://siesta.cs.wustl.edu/~drd1/research.html
Root-URL: http://www.cs.wustl.edu
Email: (drd1, sg, sds)@cs.wustl.edu  
Title: TCP Dynamic Acknowledgment Delay: Theory and Practice (Extended Abstract)  
Author: Daniel R. Dooly and Sally A. Goldman and Stephen D. Scott 
Keyword: p  
Address: St. Louis, MO 63130  
Affiliation: Dept. of Computer Science Washington University  
Note: In Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing, to appear, 1998. 1  Supported in part by NSF NYI Grant CCR-9357707 with  
Abstract: We study an on-line problem that is motivated by the networking problem of dynamically adjusting delays of acknowledgments in the Transmission Control Protocol (TCP). The theoretical problem we study is the following. There is a sequence of n packet arrival times A = ha 1 ; : : : ; a n i and a look-ahead coefficient L. The goal is to partition A into k subsequences oe 1 ; oe 2 ; : : : ; oe k (where a subsequence end is defined by an acknowledgment) that minimizes a linear combination of the cost for the number of acknowledgments sent and the cost for the additional latency introduced by delaying acknowledgments. At each arrival, an oracle provides the algorithm with the times of the next L arrivals. First we give an O(n 2 ) dynamic programming algorithm for optimally solving the off-line problem. Then we describe an on-line algorithm that greedily acknowledges exactly when the cost for an acknowledgment is less than the latency cost obtained by not acknowledging. We show that for this algorithm there is a sequence of n packet arrivals for which it is -competitive. Next we present a second on-line algorithm which is a slight modification of the first that we prove is 2-competitive. Let C opt be the cost of the optimal solution and let C A be the cost of the solution produced by algorithm A. We then show that for any on-line algorithm A with any constant look-ahead L, C A 2C opt c where c is a factor that can be made arbitrarily small with respect to C opt . Thus, in the worst case, our result for L = 0 is the best possible even for on-line algorithms that can use any constant look-ahead. We then give some initial empirical results using arrival sequences from real network traffic where we compare the two methods used in TCP for acknowledgment delay with our two on-line algorithms. In all cases we examine performance with L = 0 and L = 1. Finally, we consider an alternate definition for the latency cost in our objective func matching funds provided by WUTA. Copyright c fl1998 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. tion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Borodin, N. Linial, and M. Saks. </author> <title> An optimal online algorithm for metrical task systems. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 745-763, </pages> <year> 1992. </year>
Reference-contexts: That is, i = P (t i a j ). In an optimal solution t i will always be when the last packet of oe i arrives. The factor j 2 <ref> [0; 1] </ref> weights the relative importance of minimizing acknowledgments and minimizing latency. <p> in the 2 cost of an acknowledgment versus the cost of increased la-tency, we introduce an objective function, f (k; ) = jk + (1 j), to measure the performance where k is the total number of acknowledgments, is the total latency 1 , and j is a factor from <ref> [0; 1] </ref> that weights the relative importance of minimizing acknowledgments and minimizing latency. <p> Thus j = 1=2 evenly divides optimization effort between minimizing acknowledgments and minimizing latency. So when we discuss arrival and departure times, we will use the normalized clock. 4 Related Work We use standard competitive analysis <ref> [11, 7, 1] </ref> to evaluate our algorithms. Namely, let C opt be the cost (for acknowledgments and latency) for the optimal algorithm and let C A be the cost for algorithm A. Then we say that A is ff-competitive if for all sequences of arrivals, C A ffC opt . <p> specifically, often an algorithm A is said to be ff-competitive if C A ffC opt + c where c is a constant that is inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 [2; n] Initialize M min [0] 0 Initialize M <ref> [1; 1] </ref> 1 j + (1 j) a 1 Initialize M min [1] M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] If M [i; j] &lt; M min [i] then <p> A ffC opt + c where c is a constant that is inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 [2; n] Initialize M min [0] 0 Initialize M [1; 1] 1 j + (1 j) a 1 Initialize M min <ref> [1] </ref> M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] If M [i; j] &lt; M min [i] then M min [i] M [i; j] Thus the goal is to minimize <p> opt + c where c is a constant that is inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 [2; n] Initialize M min [0] 0 Initialize M <ref> [1; 1] </ref> 1 j + (1 j) a 1 Initialize M min [1] M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] If M [i; j] &lt; M min [i] then M min [i] M [i; j] Thus the goal is to minimize jk + <p> is a constant that is inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 [2; n] Initialize M min [0] 0 Initialize M [1; 1] 1 j + (1 j) a 1 Initialize M min <ref> [1] </ref> M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] If M [i; j] &lt; M min [i] then M min [i] M [i; j] Thus the goal is to minimize jk + (1 j) P k i=1 <p> Let M [i; j] for i; j 2 <ref> [1; n] </ref> be the minimum cost solution (using f 0 ) for the subsequence ha 1 ; : : : ; a i i (i.e. there is an acknowledgment after a i ) when the second-to-last acknowledgment of this subsequence is after a ij .
Reference: [2] <author> D. D. Clark. </author> <title> Window and acknowledgment strategy in TCP. Internet Request for Comments 813, </title> <month> July </month> <year> 1982. </year> <note> http://www.cis.ohio-state.edu/htbin/rfc/ rfc813.html. </note>
Reference-contexts: For the real networking problem, past traffic characteristics could be used to estimate the time of the next arrival (s) which in turn could be used to decide when to send an acknowledgment, an idea endorsed by Clark <ref> [2] </ref>. <p> Delaying acknowledgments allows the TCP to acknowledge multiple incoming data segments with a single acknowledgment and sometimes to piggy-back the acknowledgment on an outgoing data segment <ref> [12, 9, 2] </ref>. By reducing the number of acknowledgments sent and received, we reduce bandwidth consumption and the overhead required to send and receive each acknowledgment (due to generating checksums, handling interrupts, etc.). <p> When the timer fires all outstanding acknowledgments are sent. One of our research goals for the acknowledgment delay problem is to use prior traffic patterns to learn a rule for predicting when the next arrival will be. Clark <ref> [2] </ref> speculated that such a predictor could be very useful in dynamically adjusting the acknowledgment delay timer. However, having a very good prediction for the next arrival is only valuable if that information could help in deciding whether or not to delay the acknowledgment. <p> The following restrictions apply to the solution. (1) The arrival of a rush packet requires an immediate acknowledgment. A packet is rush if it falls into one of several categories such as packets that are used in the maintenance of a connection like a SYN or FIN <ref> [9, 4, 2] </ref>. (2) The maximum allowed delay of any acknowledgment is o 500 ms [4]. (3) Each departure can only be combined with acknowledgments (i.e. two departures cannot be combined). <p> to the packets acknowledged by acknowledgment i. 2 More specifically, often an algorithm A is said to be ff-competitive if C A ffC opt + c where c is a constant that is inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 <ref> [2; n] </ref> Initialize M min [0] 0 Initialize M [1; 1] 1 j + (1 j) a 1 Initialize M min [1] M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] <p> inde pendent of C opt . 3 Off-Line Initialize M min [i] 1 for all i 2 <ref> [2; n] </ref> Initialize M min [0] 0 Initialize M [1; 1] 1 j + (1 j) a 1 Initialize M min [1] M [1; 1] Initialize M pt [1] 1 For i 2 [2; n] M [i; j] 1 j + (1 j) j a i + M min [i j] If M [i; j] &lt; M min [i] then M min [i] M [i; j] Thus the goal is to minimize jk + (1 j) P k i=1 i where i is the
Reference: [3] <author> A. Costello and G. Varghese. </author> <title> Redesigning the BSD call-out and timer facilities. </title> <type> Technical Report WUCS-95-23, </type> <institution> Washington University in St. Louis, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.wustl.edu/cs/techreports/1995/ wucs-95-23.ps.gz. </note>
Reference-contexts: A possible impediment to implementing our on-line algorithms is the need to perform more maintenance on timers in the operating system than we would in the schemes currently used in TCP implementations. This would normally be very expensive, but is mitigated by the work of Costello and Varghese <ref> [3] </ref> who reimplemented the BSD kernel to improve the overhead of maintaining timers from linear in the number of timers to constant time.
Reference: [4] <editor> R. Braden (Editor). </editor> <title> Requirements for Internet hosts| communication layers. Internet Request for Comments 1122, </title> <address> Oct. </address> <year> 1989. </year> <note> http://www.cis.ohio-state.edu/ htbin/rfc/rfc1122.html. </note>
Reference-contexts: The following restrictions apply to the solution. (1) The arrival of a rush packet requires an immediate acknowledgment. A packet is rush if it falls into one of several categories such as packets that are used in the maintenance of a connection like a SYN or FIN <ref> [9, 4, 2] </ref>. (2) The maximum allowed delay of any acknowledgment is o 500 ms [4]. (3) Each departure can only be combined with acknowledgments (i.e. two departures cannot be combined). <p> A packet is rush if it falls into one of several categories such as packets that are used in the maintenance of a connection like a SYN or FIN [9, 4, 2]. (2) The maximum allowed delay of any acknowledgment is o 500 ms <ref> [4] </ref>. (3) Each departure can only be combined with acknowledgments (i.e. two departures cannot be combined).
Reference: [5] <author> A. R. Karlin, M. S. Manasse, L. A. McGeoch, and S. Owicki. </author> <title> Competitive randomized algorithms for nonuniform problems. </title> <booktitle> In Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 301-309, </pages> <year> 1990. </year>
Reference-contexts: In Section 4, we describe the key differences between the on-line problem considered here and some classic online problems such as the rent-to-buy (or spin-block) problem <ref> [8, 5] </ref> and the snoopy caching problem [5]. In Section 5, we describe an O (n 2 ) dynamic programming algorithm for optimally solving the off-line version of the acknowledgment delay problem. Next, in Section 6, we describe two different on-line algorithms (both having the same general form). <p> In Section 4, we describe the key differences between the on-line problem considered here and some classic online problems such as the rent-to-buy (or spin-block) problem [8, 5] and the snoopy caching problem <ref> [5] </ref>. In Section 5, we describe an O (n 2 ) dynamic programming algorithm for optimally solving the off-line version of the acknowledgment delay problem. Next, in Section 6, we describe two different on-line algorithms (both having the same general form). <p> This method of selecting t is similar to the algorithm of Karlin et al. <ref> [5, 7, 6] </ref> for the rent-to-buy problem in which their on-line algorithm waits exactly long enough such that the cost of waiting ("renting") equals the cost of committing ("buying"). <p> Then we say that A is ff-competitive if for all sequences of arrivals, C A ffC opt . We are not including an additive factor as is often done 2 . Our problem is a generalization of the rent-to-buy problem (which has also been called the spin-block problem) <ref> [8, 5] </ref>. In the rent-to-buy problem the on-line algorithm is told that a given item can be rented at 1 dollar per day or bought for a cost of K dollars. The item will be needed for d days where d is not known to the on-line algorithm. <p> While for the rent-to-buy problem the off-line problem is trivially solved, for the acknowledgment delay problem, finding an optimal solution even in the off-line case is non-trivial. Another well-studied on-line problem is the snoopy caching problem <ref> [5] </ref>. This problem is also a generalization of the rent-to-buy problem. However, the generalization there is orthogonal to what we consider in this paper. Finally, there are some problems in which the on-line problem with look-ahead has been studied.
Reference: [6] <author> A. R. Karlin, M. S. Manasse, L. Rudolph, and D. D. Sleator. </author> <title> Competitive snoopy caching. </title> <booktitle> In Proceedings of the 27th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 244-254, </pages> <year> 1986. </year>
Reference-contexts: This method of selecting t is similar to the algorithm of Karlin et al. <ref> [5, 7, 6] </ref> for the rent-to-buy problem in which their on-line algorithm waits exactly long enough such that the cost of waiting ("renting") equals the cost of committing ("buying").
Reference: [7] <author> A. R. Karlin, M. S. Manasse, L. Rudolph, and D. D. Sleator. </author> <title> Competitive snoopy caching. </title> <journal> Algorithmica, </journal> <volume> 3(1) </volume> <pages> 79-119, </pages> <year> 1988. </year>
Reference-contexts: This method of selecting t is similar to the algorithm of Karlin et al. <ref> [5, 7, 6] </ref> for the rent-to-buy problem in which their on-line algorithm waits exactly long enough such that the cost of waiting ("renting") equals the cost of committing ("buying"). <p> Thus j = 1=2 evenly divides optimization effort between minimizing acknowledgments and minimizing latency. So when we discuss arrival and departure times, we will use the normalized clock. 4 Related Work We use standard competitive analysis <ref> [11, 7, 1] </ref> to evaluate our algorithms. Namely, let C opt be the cost (for acknowledgments and latency) for the optimal algorithm and let C A be the cost for algorithm A. Then we say that A is ff-competitive if for all sequences of arrivals, C A ffC opt .
Reference: [8] <author> P. Krishnan, Philip M. Long, and Jeffrey Scott Vitter. </author> <title> Learning to make rent-to-buy decisions with systems applications. </title> <booktitle> In Proc. 12th International Conference on Machine Learning, </booktitle> <pages> pages 322-330. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1995. </year>
Reference-contexts: In Section 4, we describe the key differences between the on-line problem considered here and some classic online problems such as the rent-to-buy (or spin-block) problem <ref> [8, 5] </ref> and the snoopy caching problem [5]. In Section 5, we describe an O (n 2 ) dynamic programming algorithm for optimally solving the off-line version of the acknowledgment delay problem. Next, in Section 6, we describe two different on-line algorithms (both having the same general form). <p> Then we say that A is ff-competitive if for all sequences of arrivals, C A ffC opt . We are not including an additive factor as is often done 2 . Our problem is a generalization of the rent-to-buy problem (which has also been called the spin-block problem) <ref> [8, 5] </ref>. In the rent-to-buy problem the on-line algorithm is told that a given item can be rented at 1 dollar per day or bought for a cost of K dollars. The item will be needed for d days where d is not known to the on-line algorithm.
Reference: [9] <author> V. Paxson. </author> <title> Measurements and Analysis of End-to-End Internet Dynamics. </title> <type> PhD thesis, </type> <institution> University of Califor-nia, Berkeley, </institution> <month> April </month> <year> 1997. </year> <month> ftp://ftp.ee.lbl.gov/papers/vp-thesis/dis.ps.gz. </month>
Reference-contexts: Delaying acknowledgments allows the TCP to acknowledge multiple incoming data segments with a single acknowledgment and sometimes to piggy-back the acknowledgment on an outgoing data segment <ref> [12, 9, 2] </ref>. By reducing the number of acknowledgments sent and received, we reduce bandwidth consumption and the overhead required to send and receive each acknowledgment (due to generating checksums, handling interrupts, etc.). <p> TCP implementations, if they delay acknowledgments at all, use one of two approaches. Solaris TCP uses an interval timer of 50 ms. When a packet arrives, a timer is started that expires in 50 ms at which point the acknowledgment is sent. The BSD-derived TCPs <ref> [12, 9] </ref> use a 200 ms "heartbeat" timer. Here the timer fires every 200 ms independent of the arrivals of the packets. When the timer fires all outstanding acknowledgments are sent. <p> The following restrictions apply to the solution. (1) The arrival of a rush packet requires an immediate acknowledgment. A packet is rush if it falls into one of several categories such as packets that are used in the maintenance of a connection like a SYN or FIN <ref> [9, 4, 2] </ref>. (2) The maximum allowed delay of any acknowledgment is o 500 ms [4]. (3) Each departure can only be combined with acknowledgments (i.e. two departures cannot be combined).
Reference: [10] <author> V. Paxson and S. Floyd. </author> <title> Wide-area traffic: the failure of Poisson modeling. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(3) </volume> <pages> 226-244, </pages> <month> June </month> <year> 1995. </year> <note> http://ee.lbl.gov/nrg-papers.html. </note>
Reference-contexts: The data for our simulations came from a trace of two hours of all wide-area TCP traffic between the Lawrence Berkeley Laboratory and the rest of the world <ref> [10] </ref>. This trace (LBL-TCP-3) is available at http://ita.ee.lbl.gov/. While the simulations are based on real data, for our initial simulations we simplified the traces. Specifically, we ignored o and all departures, so our algorithms only processed one long arrival sequence with no limits on individual acknowledgment delays.
Reference: [11] <author> D. Sleator and R. Tarjan. </author> <title> Amortized efficiency of list update and paging rules. </title> <journal> Communications of the ACM, </journal> <volume> 28(2) </volume> <pages> 202-208, </pages> <year> 1985. </year>
Reference-contexts: Thus j = 1=2 evenly divides optimization effort between minimizing acknowledgments and minimizing latency. So when we discuss arrival and departure times, we will use the normalized clock. 4 Related Work We use standard competitive analysis <ref> [11, 7, 1] </ref> to evaluate our algorithms. Namely, let C opt be the cost (for acknowledgments and latency) for the optimal algorithm and let C A be the cost for algorithm A. Then we say that A is ff-competitive if for all sequences of arrivals, C A ffC opt .
Reference: [12] <author> W. R. Stevens. </author> <title> TCP/IP Illustrated, Volume 1: The Protocols. </title> <publisher> Addision-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: Delaying acknowledgments allows the TCP to acknowledge multiple incoming data segments with a single acknowledgment and sometimes to piggy-back the acknowledgment on an outgoing data segment <ref> [12, 9, 2] </ref>. By reducing the number of acknowledgments sent and received, we reduce bandwidth consumption and the overhead required to send and receive each acknowledgment (due to generating checksums, handling interrupts, etc.). <p> TCP implementations, if they delay acknowledgments at all, use one of two approaches. Solaris TCP uses an interval timer of 50 ms. When a packet arrives, a timer is started that expires in 50 ms at which point the acknowledgment is sent. The BSD-derived TCPs <ref> [12, 9] </ref> use a 200 ms "heartbeat" timer. Here the timer fires every 200 ms independent of the arrivals of the packets. When the timer fires all outstanding acknowledgments are sent.
Reference: [13] <author> Tzuoo-Hawn Yeh, Cheng-Ming Kuo, Chin-Laung Lei, and Hsu-Chun Yen. </author> <title> Competitive analysis of on-line disk scheduling. </title> <booktitle> In Proceedings of the 7th Internation Symposium on Algorithms and Computation, </booktitle> <pages> pages 356-365, </pages> <year> 1996. </year>
Reference-contexts: This problem is also a generalization of the rent-to-buy problem. However, the generalization there is orthogonal to what we consider in this paper. Finally, there are some problems in which the on-line problem with look-ahead has been studied. For example, Yeh et al. <ref> [13] </ref> study the on-line disk scheduling problem where you can look ahead at the next k variables that are to be read and from that knowledge you want to pick the order in which to read the variables from the disk to minimize the seek start-up time.
References-found: 13

